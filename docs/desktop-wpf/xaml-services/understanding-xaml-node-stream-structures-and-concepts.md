---
title: Zapoznanie się ze strukturami i koncepcjami strumienia węzłów XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: b3de3dca029c5e676fc7cdebc7735cfdade0228a
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/27/2020
ms.locfileid: "82071620"
---
# <a name="xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="938c6-102">Struktury i koncepcje strumienia węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-102">XAML node stream structures and concepts</span></span>

<span data-ttu-id="938c6-103">Czytniki XAML i moduły zapisu XAML zaimplementowane w usługach .NET XAML są oparte na koncepcji projektowej strumienia węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-103">XAML readers and XAML writers as implemented in .NET XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="938c6-104">Strumień węzłów XAML jest konceptualizacji zestawu węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="938c6-105">W tej konceptualizacji procesor XAML przechodzi przez strukturę relacji węzłów w XAML po jednym na raz.</span><span class="sxs-lookup"><span data-stu-id="938c6-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="938c6-106">W dowolnym momencie tylko jeden bieżący rekord lub bieżąca pozycja istnieje w otwartym strumieniu węzła XAML, a wiele aspektów interfejsu API raportuje tylko informacje dostępne z tej pozycji.</span><span class="sxs-lookup"><span data-stu-id="938c6-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="938c6-107">Bieżący węzeł w strumieniu węzła XAML można opisać jako obiekt, element członkowski lub wartość.</span><span class="sxs-lookup"><span data-stu-id="938c6-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="938c6-108">Traktując XAML jako strumień węzła XAML, czytniki XAML mogą komunikować się ze modułami zapisującymi XAML i umożliwiać programowi wyświetlanie, interakcję z nim lub zmienianie zawartości strumienia węzła XAML podczas ścieżki ładowania lub operacji zapisywania ścieżki obejmującej XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="938c6-109">Projekt interfejsu API czytnika i modułu zapisującego XAML oraz koncepcja strumienia węzła XAML są podobne do poprzednich <xref:System.Xml.XmlReader> <xref:System.Xml.XmlWriter> powiązanych projektów i koncepcji czytnika i modułu zapisującego, takich jak model obiektu dokumentu XML (DOM) oraz klasy i.</span><span class="sxs-lookup"><span data-stu-id="938c6-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="938c6-110">W tym temacie omówiono pojęcia strumienia węzłów XAML i opisano, jak można pisać procedury, które współdziałają z reprezentacjami XAML na poziomie węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="938c6-111">Ładowanie xaml do czytnika XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="938c6-112">Klasa <xref:System.Xaml.XamlReader> podstawowa nie deklaruje określonej techniki ładowania początkowego XAML do czytnika XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="938c6-113">Zamiast tego klasa pochodna deklaruje i implementuje technikę ładowania, w tym ogólne cechy i ograniczenia jego źródła wejściowego dla XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="938c6-114">Na przykład <xref:System.Xaml.XamlObjectReader> odczytuje wykres obiektu, zaczynając od źródła wejściowego pojedynczego obiektu, który reprezentuje katalog główny lub bazowy.</span><span class="sxs-lookup"><span data-stu-id="938c6-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="938c6-115">Następnie <xref:System.Xaml.XamlObjectReader> tworzy strumień węzła XAML z wykresu obiektu.</span><span class="sxs-lookup"><span data-stu-id="938c6-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="938c6-116">Najbardziej widoczna podklasa .NET XAML Services jest . <xref:System.Xaml.XamlReader> <xref:System.Xaml.XamlXmlReader></span><span class="sxs-lookup"><span data-stu-id="938c6-116">The most prominent .NET XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="938c6-117"><xref:System.Xaml.XamlXmlReader>ładuje początkowy kod XAML, ładując plik tekstowy bezpośrednio za pośrednictwem strumienia lub ścieżki pliku, lub pośrednio za pośrednictwem powiązanej klasy czytnika, takiej jak <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="938c6-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="938c6-118">Można <xref:System.Xaml.XamlReader> uznać, że zawiera całość źródła danych wejściowych XAML po załadowaniu.</span><span class="sxs-lookup"><span data-stu-id="938c6-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="938c6-119">Jednak <xref:System.Xaml.XamlReader> podstawowy interfejs API jest zaprojektowany tak, że czytnik wchodzi w interakcję z jednym węzłem XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="938c6-120">Po pierwszym załadowaniu pierwszy pojedynczy węzeł, który napotkasz, jest katalogiem głównym XAML i jego obiektem początkowym.</span><span class="sxs-lookup"><span data-stu-id="938c6-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="938c6-121">Koncepcja strumienia węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="938c6-122">Jeśli jesteś bardziej zaznajomiony z DOM, metafory drzewa lub zapytania oparte podejście do uzyskiwania dostępu do technologii opartych na XML, pomocny sposób koncepcji strumienia węzła XAML jest w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="938c6-122">If you are more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="938c6-123">Wyobraź sobie, że załadowany kod XAML jest dom lub drzewa, gdzie każdy możliwy węzeł jest rozwijany do końca, a następnie prezentowane liniowo.</span><span class="sxs-lookup"><span data-stu-id="938c6-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="938c6-124">W miarę przechodzenia przez węzły, może być przechodzenie "w" lub "out" poziomów, które byłyby istotne dla DOM, ale strumień węzła XAML nie jawnie śledzić, ponieważ te pojęcia poziomu nie są istotne dla strumienia węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="938c6-125">Strumień węzła ma "bieżącą" pozycję, ale jeśli nie zostały zapisane inne części strumienia samodzielnie jako odwołania, każdy aspekt strumienia węzła innych niż bieżąca pozycja węzła jest poza widoku.</span><span class="sxs-lookup"><span data-stu-id="938c6-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="938c6-126">Koncepcja strumienia węzła XAML ma znaczącą zaletę, że jeśli przejdziesz przez cały strumień węzła, masz pewność, że przetworzyłeś całą reprezentację XAML; nie musisz się martwić, że kwerenda, operacja DOM lub inne nieliniowe podejście do przetwarzania informacji nie odebrano części pełnej reprezentacji XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="938c6-127">Z tego powodu reprezentacja strumienia węzła XAML jest idealna zarówno do łączenia czytników XAML i modułów zapisu XAML, jak i do zapewnienia systemu, w którym można wstawić własny proces, który działa między fazami odczytu i zapisu operacji przetwarzania XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="938c6-128">W wielu przypadkach kolejność węzłów w strumieniu węzła XAML jest celowo optymalizowane lub uporządkowane przez czytniki XAML w porównaniu z kolejnością, która może pojawić się na wykresie tekstu źródłowego, binarnego lub obiektu.</span><span class="sxs-lookup"><span data-stu-id="938c6-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="938c6-129">To zachowanie jest przeznaczone do wymuszania architektury przetwarzania XAML, zgodnie z którą moduły zapisające XAML nigdy nie znajdują się w sytuacji, w której muszą wrócić "wstecz" w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="938c6-130">W idealnym przypadku wszystkie operacje zapisu XAML powinny być w stanie działać na podstawie kontekstu schematu oraz bieżącej pozycji strumienia węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="938c6-131">Podstawowa pętla węzła odczytu</span><span class="sxs-lookup"><span data-stu-id="938c6-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="938c6-132">Podstawowa pętla węzła odczytu do badania strumienia węzła XAML składa się z następujących pojęć.</span><span class="sxs-lookup"><span data-stu-id="938c6-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="938c6-133">Na potrzeby pętli węzłów, jak omówiono w tym temacie, załóżmy, że czytasz tekstowy, czytelny dla człowieka plik XAML przy użyciu <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="938c6-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="938c6-134">Łącza w tej sekcji odnoszą się do interfejsu API <xref:System.Xaml.XamlXmlReader>pętli węzłów XAML zaimplementowanych przez program .</span><span class="sxs-lookup"><span data-stu-id="938c6-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="938c6-135">Upewnij się, że nie znajdujesz się na końcu <xref:System.Xaml.XamlXmlReader.IsEof%2A>strumienia węzła XAML (sprawdź lub użyj zwracanej <xref:System.Xaml.XamlXmlReader.Read%2A> wartości).</span><span class="sxs-lookup"><span data-stu-id="938c6-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="938c6-136">Jeśli jesteś na końcu strumienia, nie ma bieżącego węzła i należy zakończyć.</span><span class="sxs-lookup"><span data-stu-id="938c6-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="938c6-137">Sprawdź, jaki typ węzła strumień węzła XAML jest obecnie udostępniany przez wywołanie <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="938c6-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="938c6-138">Jeśli masz skojarzony moduł zapisujący obiekt XAML, który <xref:System.Xaml.XamlWriter.WriteNode%2A> jest połączony bezpośrednio, zazwyczaj wywołane w tym momencie.</span><span class="sxs-lookup"><span data-stu-id="938c6-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="938c6-139">Na podstawie <xref:System.Xaml.XamlNodeType> których jest zgłaszane jako bieżący węzeł lub bieżący rekord, wywołać jedną z następujących czynności, aby uzyskać informacje o zawartości węzła:</span><span class="sxs-lookup"><span data-stu-id="938c6-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="938c6-140">W <xref:System.Xaml.XamlXmlReader.NodeType%2A> przypadku <xref:System.Xaml.XamlNodeType.StartMember> <xref:System.Xaml.XamlNodeType.EndMember>połączenia <xref:System.Xaml.XamlXmlReader.Member%2A> telefonicznego <xref:System.Xaml.XamlMember> lub telefonicznego w celu uzyskania informacji o człowianym.</span><span class="sxs-lookup"><span data-stu-id="938c6-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="938c6-141">Element członkowski <xref:System.Xaml.XamlDirective>może być elementem członkowskim , a zatem niekoniecznie musi być konwencjonalnym elementem członkowskim zdefiniowanym przez typ poprzedniego obiektu.</span><span class="sxs-lookup"><span data-stu-id="938c6-141">The member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="938c6-142">Na przykład `x:Name` stosowane do obiektu pojawia się jako <xref:System.Xaml.XamlMember.IsDirective%2A> element członkowski <xref:System.Xaml.XamlMember.Name%2A> XAML, gdzie jest true i element członkowski jest `Name`, z innymi właściwościami wskazującymi, że ta dyrektywa znajduje się w języku XAML przestrzeni nazw XAML języka.</span><span class="sxs-lookup"><span data-stu-id="938c6-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="938c6-143">Dla <xref:System.Xaml.XamlXmlReader.NodeType%2A> lub <xref:System.Xaml.XamlNodeType.StartObject> <xref:System.Xaml.XamlNodeType.EndObject>, <xref:System.Xaml.XamlXmlReader.Type%2A> wywołać, aby uzyskać <xref:System.Xaml.XamlType> informacje o obiekcie.</span><span class="sxs-lookup"><span data-stu-id="938c6-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="938c6-144">Dla <xref:System.Xaml.XamlXmlReader.NodeType%2A> a <xref:System.Xaml.XamlNodeType.Value>, <xref:System.Xaml.XamlXmlReader.Value%2A>zadzwoń .</span><span class="sxs-lookup"><span data-stu-id="938c6-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="938c6-145">Węzeł jest wartością tylko wtedy, gdy jest najprostszym wyrażeniem wartości dla elementu członkowskiego lub tekstem inicjowania obiektu (jednak należy pamiętać o zachowaniu konwersji typu, jak zostało to udokumentowane w nadchodzącej sekcji tego tematu).</span><span class="sxs-lookup"><span data-stu-id="938c6-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="938c6-146">Dla <xref:System.Xaml.XamlXmlReader.NodeType%2A> , <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>wywołać, <xref:System.Xaml.XamlXmlReader.Namespace%2A> aby uzyskać informacje o obszarze nazw dla węzła obszaru nazw.</span><span class="sxs-lookup"><span data-stu-id="938c6-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="938c6-147">Wywołanie, <xref:System.Xaml.XamlXmlReader.Read%2A> aby przejść czytnik XAML do następnego węzła w strumieniu węzła XAML i powtórzyć kroki ponownie.</span><span class="sxs-lookup"><span data-stu-id="938c6-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="938c6-148">Strumień węzła XAML dostarczany przez czytniki XAML usług .NET XAML zawsze zapewnia pełny, głęboki przechodzenie wszystkich możliwych węzłów.</span><span class="sxs-lookup"><span data-stu-id="938c6-148">The XAML node stream provided by .NET XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="938c6-149">Typowe techniki kontroli przepływu dla pętli węzła XAML `while (reader.Read())`obejmują definiowanie <xref:System.Xaml.XamlXmlReader.NodeType%2A> obiektu w obrębie i włączanie w każdym punkcie węzła w pętli węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="938c6-150">Jeśli strumień węzła znajduje się na końcu pliku, bieżący węzeł ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="938c6-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="938c6-151">Najprostsza pętla, która używa czytnika i modułu zapisującego przypomina poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="938c6-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="938c6-152">Ten podstawowy przykład pętli węzła XAML ścieżki obciążenia w sposób przejrzysty łączy czytnik XAML i <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>moduł zapisujący XAML, nie robiąc nic innego niż w przypadku użycia .</span><span class="sxs-lookup"><span data-stu-id="938c6-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="938c6-153">Ale ta podstawowa struktura jest następnie rozszerzana, aby zastosować do scenariusza czytania lub pisania.</span><span class="sxs-lookup"><span data-stu-id="938c6-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="938c6-154">Niektóre możliwe scenariusze są następujące:</span><span class="sxs-lookup"><span data-stu-id="938c6-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="938c6-155">Włącz <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="938c6-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="938c6-156">Wykonaj różne akcje w zależności od tego, który typ węzła jest odczytywany.</span><span class="sxs-lookup"><span data-stu-id="938c6-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="938c6-157">Nie dzwonić <xref:System.Xaml.XamlWriter.WriteNode%2A> we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="938c6-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="938c6-158">Tylko <xref:System.Xaml.XamlWriter.WriteNode%2A> w <xref:System.Xaml.XamlXmlReader.NodeType%2A> niektórych przypadkach.</span><span class="sxs-lookup"><span data-stu-id="938c6-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="938c6-159">W ramach logiki dla określonego typu węzła przeanalizuj specyfikę tego węzła i działaj na nich.</span><span class="sxs-lookup"><span data-stu-id="938c6-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="938c6-160">Na przykład można zapisywać tylko obiekty pochodzące z określonego obszaru nazw XAML, a następnie upuszczać lub odraczać wszystkie obiekty, które nie pochodzą z tego obszaru nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-160">For example, you could only write objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="938c6-161">Można też upuścić lub w inny sposób ponownie przetworzyć wszelkie dyrektywy XAML, które system XAML nie obsługuje w ramach przetwarzania elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="938c6-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="938c6-162">Zdefiniuj niestandardowe, <xref:System.Xaml.XamlObjectWriter> które zastępuje `Write*` metody, ewentualnie wykonywanie mapowania typów, który pomija kontekst schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="938c6-163">Konstruuj <xref:System.Xaml.XamlXmlReader> do użycia kontekstu schematu XAML nondefault, tak aby dostosowane różnice w zachowaniu XAML są używane zarówno przez czytelnika, jak i moduł zapisujący.</span><span class="sxs-lookup"><span data-stu-id="938c6-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="938c6-164">Uzyskiwanie dostępu do xaml poza koncepcją pętli węzła</span><span class="sxs-lookup"><span data-stu-id="938c6-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="938c6-165">Istnieją potencjalnie inne sposoby pracy z reprezentacją XAML inne niż jako pętla węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="938c6-166">Na przykład może istnieć czytnik XAML, który może odczytywać indeksowany węzeł `x:Name`lub `x:Uid`w szczególności uzyskuje dostęp do węzłów bezpośrednio przez , przez , lub za pośrednictwem innych identyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="938c6-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="938c6-167">Usługi .NET XAML nie zapewniają pełną implementację, ale zapewnia sugerowany wzorzec za pośrednictwem usług i typów pomocy technicznej.</span><span class="sxs-lookup"><span data-stu-id="938c6-167">.NET XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="938c6-168">Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.IXamlIndexingReader> i <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="938c6-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

## <a name="working-with-the-current-node"></a><span data-ttu-id="938c6-169">Praca z bieżącym węzłem</span><span class="sxs-lookup"><span data-stu-id="938c6-169">Working with the Current Node</span></span>

<span data-ttu-id="938c6-170">Większość scenariuszy, które używają pętli węzła XAML nie tylko odczytywać węzły.</span><span class="sxs-lookup"><span data-stu-id="938c6-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="938c6-171">Większość scenariuszy przetwarza bieżące węzły i przekazuje każdy <xref:System.Xaml.XamlWriter>węzeł po jednym naraz do implementacji programu .</span><span class="sxs-lookup"><span data-stu-id="938c6-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="938c6-172">W typowym scenariuszu <xref:System.Xaml.XamlXmlReader> ścieżki obciążenia tworzy strumień węzła XAML; węzły XAML są przetwarzane zgodnie z logiką i kontekstem schematu XAML; a węzły są przekazywane <xref:System.Xaml.XamlObjectWriter>do pliku .</span><span class="sxs-lookup"><span data-stu-id="938c6-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="938c6-173">Następnie należy zintegrować wykres wynikowy obiektu do aplikacji lub struktury.</span><span class="sxs-lookup"><span data-stu-id="938c6-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="938c6-174">W typowym scenariuszu <xref:System.Xaml.XamlObjectReader> zapisz ścieżki odczytuje wykres obiektu, przetwarzane są poszczególne <xref:System.Xaml.XamlXmlWriter> węzły XAML, a wynik wyprowadza serializowany wynik jako plik tekstowy XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="938c6-175">Kluczem jest to, że zarówno ścieżki, jak i scenariusze obejmują pracę z dokładnie jednym węzłem XAML naraz, a węzły XAML są dostępne do leczenia w znormalizowany sposób zdefiniowany przez system typu XAML i the.NET interfejsów API usług XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="938c6-176">Ramki i zakres</span><span class="sxs-lookup"><span data-stu-id="938c6-176">Frames and Scope</span></span>

<span data-ttu-id="938c6-177">Pętla węzła XAML przechodzi przez strumień węzła XAML w sposób liniowy.</span><span class="sxs-lookup"><span data-stu-id="938c6-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="938c6-178">Strumień węzła przechodzi do obiektów, do elementów członkowskich, które zawierają inne obiekty i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="938c6-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="938c6-179">Często jest przydatne do śledzenia zakresu w strumieniu węzła XAML przez implementowanie koncepcji ramki i stosu.</span><span class="sxs-lookup"><span data-stu-id="938c6-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="938c6-180">Jest to szczególnie ważne, jeśli aktywnie dostosowujesz strumień węzła, gdy jesteś w nim.</span><span class="sxs-lookup"><span data-stu-id="938c6-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="938c6-181">Obsługa ramki i stosu, które można zaimplementować jako część logiki pętli węzła może liczyć `StartObject` (lub) `GetObject`i `EndObject` zakresy, jak zejść do struktury węzła XAML, jeśli struktura jest przemyślana z perspektywy DOM.</span><span class="sxs-lookup"><span data-stu-id="938c6-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="938c6-182">Przechodzenie przez węzły obiektów i wprowadzanie ich</span><span class="sxs-lookup"><span data-stu-id="938c6-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="938c6-183">Pierwszy węzeł w strumieniu węzła, gdy jest otwierany przez czytnik XAML, jest węzłem-obiektem startowym obiektu głównego.</span><span class="sxs-lookup"><span data-stu-id="938c6-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="938c6-184">Z definicji ten obiekt jest zawsze węzeł pojedynczego obiektu i nie ma żadnych rysów.</span><span class="sxs-lookup"><span data-stu-id="938c6-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="938c6-185">W każdym przykładzie XAML w świecie rzeczywistym obiekt główny jest zdefiniowany jako zawierający jedną lub więcej właściwości, które przechowują więcej obiektów, a te właściwości mają węzły członkowskie.</span><span class="sxs-lookup"><span data-stu-id="938c6-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="938c6-186">Węzły członkowskie mają następnie jeden lub więcej węzłów obiektu lub może również zakończyć się w węźle wartości zamiast.</span><span class="sxs-lookup"><span data-stu-id="938c6-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="938c6-187">Obiekt główny zazwyczaj definiuje identyfikatory nazw XAML, które są syntaktycznie przypisywane jako atrybuty w `Namescope` znacznikach tekstowych XAML, ale mapowane na typ węzła w reprezentacji strumienia węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="938c6-188">Rozważmy poniższy przykład XAML (jest to dowolny kod XAML, który nie jest wspierany przez istniejące typy w .NET).</span><span class="sxs-lookup"><span data-stu-id="938c6-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in .NET).</span></span> <span data-ttu-id="938c6-189">Załóżmy, że `FavorCollection` w `List<T>` `Favor`tym `Balloon` `NoiseMaker` modelu obiektu, `Favor`jest `Balloon.Color` , i `Color` są przypisane do , właściwość jest wspierany `Color` przez obiekt podobny do sposobu WPF definiuje kolory jako znane nazwy kolorów i obsługuje konwerter typów dla składni atrybutów.</span><span class="sxs-lookup"><span data-stu-id="938c6-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="938c6-190">Znaczniki XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-190">XAML markup</span></span>|<span data-ttu-id="938c6-191">Wynikowy strumień węzła XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="938c6-192">`Namespace`węzeł dla`Party`</span><span class="sxs-lookup"><span data-stu-id="938c6-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="938c6-193">`StartObject`węzeł dla`Party`</span><span class="sxs-lookup"><span data-stu-id="938c6-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="938c6-194">`StartMember`węzeł dla`Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="938c6-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="938c6-195">`StartObject`węzeł dla niejawnych`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="938c6-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="938c6-196">`StartMember`dla właściwości `FavorCollection` niejawne elementy.</span><span class="sxs-lookup"><span data-stu-id="938c6-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="938c6-197">`StartObject`węzeł dla`Balloon`</span><span class="sxs-lookup"><span data-stu-id="938c6-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="938c6-198">`StartMember`węzeł dla`Color`</span><span class="sxs-lookup"><span data-stu-id="938c6-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="938c6-199">`Value`węzeł dla ciągu wartości atrybutu`"Red"`</span><span class="sxs-lookup"><span data-stu-id="938c6-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="938c6-200">`EndMember`For`Color`</span><span class="sxs-lookup"><span data-stu-id="938c6-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="938c6-201">`StartMember`węzeł dla`HasHelium`</span><span class="sxs-lookup"><span data-stu-id="938c6-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="938c6-202">`Value`węzeł dla ciągu wartości atrybutu`"True"`</span><span class="sxs-lookup"><span data-stu-id="938c6-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="938c6-203">`EndMember`For`HasHelium`</span><span class="sxs-lookup"><span data-stu-id="938c6-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="938c6-204">`EndObject`For`Balloon`</span><span class="sxs-lookup"><span data-stu-id="938c6-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="938c6-205">`StartObject`węzeł dla`NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="938c6-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="938c6-206">`StartMember`węzeł dla`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="938c6-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="938c6-207">`Value`węzeł dla ciągu wartości inicjowania`"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="938c6-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="938c6-208">`EndMember`węzeł dla`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="938c6-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="938c6-209">`EndObject`For`NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="938c6-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="938c6-210">`EndMember`dla właściwości `FavorCollection` niejawne elementy.</span><span class="sxs-lookup"><span data-stu-id="938c6-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="938c6-211">`EndObject`węzeł dla niejawnych`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="938c6-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="938c6-212">`EndMember`For`Favors`</span><span class="sxs-lookup"><span data-stu-id="938c6-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="938c6-213">`EndObject`For`Party`</span><span class="sxs-lookup"><span data-stu-id="938c6-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="938c6-214">W strumieniu węzła XAML można polegać na następującym zachowaniu:</span><span class="sxs-lookup"><span data-stu-id="938c6-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="938c6-215">Jeśli `Namespace` węzeł istnieje, jest dodawany do strumienia bezpośrednio przed `StartObject` zadeklarowanym `xmlns`obszarem nazw XAML z programem .</span><span class="sxs-lookup"><span data-stu-id="938c6-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="938c6-216">Spójrz na poprzednią tabelę z XAML i przykładowy strumień węzła ponownie.</span><span class="sxs-lookup"><span data-stu-id="938c6-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="938c6-217">Zwróć `StartObject` uwagę, `Namespace` jak i węzły wydają się być transponowane w porównaniu do ich pozycji deklaracji w znacznikach tekstu.</span><span class="sxs-lookup"><span data-stu-id="938c6-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="938c6-218">Jest to reprezentatywne dla zachowania, w którym węzły obszaru nazw zawsze pojawiają się przed węzłem, do którego mają zastosowanie w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="938c6-219">Celem tego projektu jest to, że informacje o przestrzeni nazw są niezbędne do modułu zapisującego obiekt i muszą być znane, zanim moduł zapisujący obiekt podejmie próbę wykonania mapowania typów lub innego przetworzenia obiektu.</span><span class="sxs-lookup"><span data-stu-id="938c6-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="938c6-220">Umieszczenie informacji o przestrzeni nazw XAML przed jego zakres aplikacji w strumieniu ułatwia zawsze przetwarzać strumień węzła w jego przedstawionej kolejności.</span><span class="sxs-lookup"><span data-stu-id="938c6-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="938c6-221">Ze względu na powyższe uwagę `Namespace` jest to jeden lub więcej węzłów, które można przeczytać najpierw w większości `StartObject` rzeczywistych przypadków znaczników podczas przechodzenia przez węzły od początku, a nie katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="938c6-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="938c6-222">Po `StartObject` węźle `StartMember`może `Value`nastąpić `EndObject`, lub natychmiastowy .</span><span class="sxs-lookup"><span data-stu-id="938c6-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="938c6-223">Nigdy nie następuje `StartObject`od razu inny .</span><span class="sxs-lookup"><span data-stu-id="938c6-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="938c6-224">A `StartMember` może nastąpić `StartObject` `Value`, lub `EndMember`natychmiastowe .</span><span class="sxs-lookup"><span data-stu-id="938c6-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="938c6-225">Może następować `GetObject`po , dla elementów członkowskich, gdzie wartość ma pochodzić `StartObject` z istniejącej wartości obiektu nadrzędnego, a nie, który będzie utworzyć wystąpienie nowej wartości.</span><span class="sxs-lookup"><span data-stu-id="938c6-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="938c6-226">Po nim może również `Namespace` znajdować się węzeł, `StartObject`który ma zastosowanie do nadchodzącego .</span><span class="sxs-lookup"><span data-stu-id="938c6-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="938c6-227">Nigdy nie następuje `StartMember`od razu inny .</span><span class="sxs-lookup"><span data-stu-id="938c6-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="938c6-228">Węzeł `Value` reprezentuje samą wartość; nie ma "EndValue".</span><span class="sxs-lookup"><span data-stu-id="938c6-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="938c6-229">Po nim może następować tylko plik `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="938c6-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="938c6-230">Tekst inicjowania XAML obiektu, który może być użyty przez konstrukcję, nie powoduje, że struktura Object-Value.</span><span class="sxs-lookup"><span data-stu-id="938c6-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="938c6-231">Zamiast tego tworzony jest węzeł dedykowanego elementu członkowskiego dla nazwanego `_Initialization` elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="938c6-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="938c6-232">i ten węzeł elementu członkowskiego zawiera ciąg wartości inicjowania.</span><span class="sxs-lookup"><span data-stu-id="938c6-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="938c6-233">Jeśli istnieje, `_Initialization` jest zawsze `StartMember`pierwszym .</span><span class="sxs-lookup"><span data-stu-id="938c6-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="938c6-234">`_Initialization`mogą być kwalifikowane w niektórych reprezentacji usług XAML z języka XAML namescope języka, aby wyjaśnić, że `_Initialization` nie jest zdefiniowaną właściwością w typach kopii zapasowych.</span><span class="sxs-lookup"><span data-stu-id="938c6-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="938c6-235">Kombinacja Wartość elementu członkowskiego reprezentuje ustawienie atrybutu wartości.</span><span class="sxs-lookup"><span data-stu-id="938c6-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="938c6-236">Ostatecznie może istnieć konwerter wartości zaangażowany w przetwarzanie tej wartości, a wartość jest zwykłym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="938c6-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="938c6-237">Jednak to nie jest oceniane, dopóki moduł zapisujący obiekt XAML przetwarza ten strumień węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="938c6-238">Moduł zapisujący obiekt XAML posiada niezbędny kontekst schematu XAML, mapowanie systemu typu i inne wsparcie potrzebne do konwersji wartości.</span><span class="sxs-lookup"><span data-stu-id="938c6-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="938c6-239">Węzeł `EndMember` może następować `StartMember` węzeł dla następnego elementu `EndObject` członkowskiego lub węzeł dla właściciela elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="938c6-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="938c6-240">Węzeł `EndObject` może następować `EndMember` po węźle.</span><span class="sxs-lookup"><span data-stu-id="938c6-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="938c6-241">Może również następować `StartObject` węzeł dla przypadków, gdy obiekty są równorzędne w elementach kolekcji.</span><span class="sxs-lookup"><span data-stu-id="938c6-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="938c6-242">Lub może być po `Namespace` węźle, który `StartObject`ma zastosowanie do nadchodzącego .</span><span class="sxs-lookup"><span data-stu-id="938c6-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="938c6-243">W przypadku unikatowego zamknięcia całego strumienia `EndObject` węzła, po katalogu głównym nie następuje nic; czytnik jest teraz koniec pliku i <xref:System.Xaml.XamlReader.Read%2A> `false`zwraca .</span><span class="sxs-lookup"><span data-stu-id="938c6-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="938c6-244">Konwertery wartości i strumień węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="938c6-245">Konwerter wartości jest ogólnym terminem dla rozszerzenia znaczników, konwertera typów (w tym serializatorów wartości) lub innej dedykowanej klasy, która jest raportowana jako konwerter wartości za pośrednictwem systemu typu XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="938c6-246">W strumieniu węzła XAML użycie konwertera typu i użycie rozszerzenia znaczników mają bardzo różne reprezentacje.</span><span class="sxs-lookup"><span data-stu-id="938c6-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="938c6-247">Konwertery typów w strumieniu węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="938c6-248">Zestaw atrybutów, który ostatecznie powoduje użycie konwertera typu jest zgłaszany w strumieniu węzła XAML jako wartość elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="938c6-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="938c6-249">Strumień węzła XAML nie próbuje utworzyć obiektu wystąpienia konwertera typu i przekazać wartość do niego.</span><span class="sxs-lookup"><span data-stu-id="938c6-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="938c6-250">Przy użyciu implementacji konwersji konwertera typów wymaga wywoływania kontekstu schematu XAML i używania go do mapowania typu.</span><span class="sxs-lookup"><span data-stu-id="938c6-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="938c6-251">Nawet określenie, który typ klasy konwertera powinny być używane do przetwarzania wartości wymaga kontekstu schematu XAML pośrednio.</span><span class="sxs-lookup"><span data-stu-id="938c6-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="938c6-252">W przypadku korzystania z domyślnego kontekstu schematu XAML te informacje są dostępne w systemie typu XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="938c6-253">Jeśli potrzebujesz informacji o klasie konwertera typu na poziomie strumienia węzła XAML przed <xref:System.Xaml.XamlMember> nawiązaniem połączenia z modułem zapisu XAML, możesz uzyskać je na podstawie informacji o ustawionym członu.</span><span class="sxs-lookup"><span data-stu-id="938c6-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="938c6-254">Jednak w przeciwnym razie dane wejściowe konwertera typu powinny być zachowywane w strumieniu węzła XAML jako wartość zwykła, dopóki nie zostaną wykonane pozostałe operacje wymagające systemu mapowania typów i kontekstu schematu XAML, na przykład tworzenie obiektu przez moduł zapisujący obiekt XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type-mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="938c6-255">Rozważmy na przykład następujący konspekt definicji klasy i użycie XAML dla niego:</span><span class="sxs-lookup"><span data-stu-id="938c6-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="938c6-256">Tekstowa reprezentacja strumienia węzła XAML dla tego użycia może być wyrażona w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="938c6-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="938c6-257">`StartObject`z <xref:System.Xaml.XamlType> reprezentowaniem`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="938c6-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="938c6-258">`StartMember`z <xref:System.Xaml.XamlMember> reprezentowaniem`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="938c6-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="938c6-259">`Value`węzeł, z ciągiem tekstowym "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="938c6-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="938c6-260">`EndMember`Pasuje`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="938c6-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="938c6-261">`EndObject`Pasuje`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="938c6-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="938c6-262">Należy zauważyć, że nie ma wystąpienia konwertera typu w tym strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="938c6-263">Ale można uzyskać informacje konwerter typu, dzwoniąc <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> na <xref:System.Xaml.XamlMember> for `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="938c6-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="938c6-264">Jeśli masz prawidłowy kontekst schematu XAML, możesz również wywołać metody konwertera, uzyskując wystąpienie z <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>programu .</span><span class="sxs-lookup"><span data-stu-id="938c6-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="938c6-265">Rozszerzenia znaczników w strumieniu węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="938c6-266">Użycie rozszerzenia znaczników jest zgłaszane w strumieniu węzła XAML jako węzeł obiektu w obrębie elementu członkowskiego, gdzie obiekt reprezentuje wystąpienie rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="938c6-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="938c6-267">W związku z tym użycie rozszerzenia znaczników jest przedstawiony bardziej jawnie w reprezentacji strumienia węzła niż użycie konwertera typu jest i przenosi więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="938c6-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="938c6-268"><xref:System.Xaml.XamlMember>informacje nie mogły powiedzieć ci nic o rozszerzeniu znaczników, ponieważ użycie ma miejsce sytuacyjne i różni się w każdym możliwym przypadku znaczników; nie jest dedykowany i niejawny dla każdego typu lub elementu członkowskiego, jak w przypadku konwerterów typów.</span><span class="sxs-lookup"><span data-stu-id="938c6-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="938c6-269">Reprezentacja strumienia węzłów rozszerzeń znaczników jako węzłów obiektów ma miejsce, nawet jeśli użycie rozszerzenia znaczników zostało dokonane w formularzu atrybutu w znacznikach tekstowych XAML (co często ma miejsce).</span><span class="sxs-lookup"><span data-stu-id="938c6-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="938c6-270">Rozszerzenia znaczników, które używały jawnego formularza elementu obiektu, są traktowane w ten sam sposób.</span><span class="sxs-lookup"><span data-stu-id="938c6-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="938c6-271">W węźle obiektu rozszerzenia znaczników mogą istnieć elementy członkowskie tego rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="938c6-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="938c6-272">Reprezentacja strumienia węzła XAML zachowuje użycie tego rozszerzenia znaczników, niezależnie od tego, czy jest to użycie parametru pozycyjnego, czy użycie z jawnymi nazwanymi parametrami.</span><span class="sxs-lookup"><span data-stu-id="938c6-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="938c6-273">W przypadku użycia parametru pozycyjnego strumień węzła XAML `_PositionalParameters` zawiera właściwość zdefiniowaną przez język XAML, która rejestruje użycie.</span><span class="sxs-lookup"><span data-stu-id="938c6-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="938c6-274">Ta właściwość <xref:System.Collections.Generic.List%601> jest <xref:System.Object> rodzajowy z ograniczeniem.</span><span class="sxs-lookup"><span data-stu-id="938c6-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="938c6-275">Ograniczenie jest obiektem, a nie ciągiem, ponieważ niewykluczone użycie parametru pozycyjnego może zawierać zagnieżdżone użycie rozszerzenia znaczników w nim.</span><span class="sxs-lookup"><span data-stu-id="938c6-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="938c6-276">Aby uzyskać dostęp do parametrów pozycyjnych z użycia, można iterować za pośrednictwem listy i używać indeksatorów dla poszczególnych wartości listy.</span><span class="sxs-lookup"><span data-stu-id="938c6-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="938c6-277">Dla użycia nazwanego parametru każdy nazwany parametr jest reprezentowany jako węzeł członkowski o tej nazwie w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="938c6-278">Wartości członkowskie nie są koniecznie ciągi, ponieważ może istnieć użycie rozszerzenia znaczników zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="938c6-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="938c6-279">`ProvideValue`z rozszerzenia znaczników nie jest jeszcze wywoływana.</span><span class="sxs-lookup"><span data-stu-id="938c6-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="938c6-280">Jednak jest wywoływana, jeśli połączysz czytnik XAML i `WriteEndObject` moduł zapisujący XAML, tak aby jest wywoływany w węźle rozszerzenia znaczników podczas badania go w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="938c6-281">Z tego powodu zazwyczaj potrzebujesz tego samego kontekstu schematu XAML dostępne, jak byłoby używane w celu utworzenia wykresu obiektu na ścieżce ładowania.</span><span class="sxs-lookup"><span data-stu-id="938c6-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="938c6-282">W `ProvideValue` przeciwnym razie z dowolnego rozszerzenia znaczników można zgłaszać wyjątki w tym miejscu, ponieważ nie ma oczekiwanych usług dostępnych.</span><span class="sxs-lookup"><span data-stu-id="938c6-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="938c6-283">Elementy członkowskie xaml i xml zdefiniowane w strumieniu węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="938c6-284">Niektóre elementy członkowskie są wprowadzane do strumienia węzła XAML z powodu interpretacji i <xref:System.Xaml.XamlMember> konwencji czytnika XAML, a nie za pośrednictwem jawnego wyszukiwania lub konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="938c6-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="938c6-285">Często te elementy członkowskie są dyrektywy XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="938c6-286">W niektórych przypadkach jest to czynność odczytu XAML, który wprowadza dyrektywę do strumienia węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="938c6-287">Innymi słowy oryginalny wpisowy tekst XAML nie jawnie określić dyrektywy elementu członkowskiego, ale czytnik XAML wstawia dyrektywy w celu spełnienia strukturalnych konwencji XAML i raport informacji w strumieniu węzła XAML przed utratą tych informacji.</span><span class="sxs-lookup"><span data-stu-id="938c6-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="938c6-288">Na poniższej liście zwraca uwagę na wszystkie przypadki, w których oczekuje się, że czytnik XAML wprowadzi węzeł elementu członkowskiego XAML dyrektywy i jak ten węzeł elementu członkowskiego jest identyfikowany w implementacjach usług .NET XAML Services.</span><span class="sxs-lookup"><span data-stu-id="938c6-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in .NET XAML Services implementations.</span></span>

- <span data-ttu-id="938c6-289">**Tekst inicjowania węzła obiektu:** Nazwa tego węzła `_Initialization`członkowskiego jest , reprezentuje dyrektywę XAML i jest zdefiniowana w przestrzeni nazw XAML języka XAML języka.</span><span class="sxs-lookup"><span data-stu-id="938c6-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="938c6-290">Można uzyskać jednostkę statyczną <xref:System.Xaml.XamlLanguage.Initialization%2A>dla niego z .</span><span class="sxs-lookup"><span data-stu-id="938c6-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="938c6-291">**Parametry pozycyjne dla rozszerzenia znaczników:** Nazwa tego węzła `_PositionalParameters`członkowskiego jest i jest zdefiniowana w przestrzeni nazw XAML języka XAML języka.</span><span class="sxs-lookup"><span data-stu-id="938c6-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="938c6-292">Zawsze zawiera ogólną listę obiektów, z których każdy jest parametrem pozycyjnym wstępnie oddzielone przez podział na znak `,` ogranicznika, jak podano w wejściowym XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="938c6-293">Można uzyskać jednostkę statyczną dla dyrektywy <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>parametrów pozycyjnych z .</span><span class="sxs-lookup"><span data-stu-id="938c6-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="938c6-294">**Nieznana zawartość:** Nazwa tego węzła `_UnknownContent`członkowskiego to .</span><span class="sxs-lookup"><span data-stu-id="938c6-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="938c6-295">Ściśle rzecz biorąc, <xref:System.Xaml.XamlDirective>jest to , i jest zdefiniowany w języku XAML przestrzeni nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="938c6-296">Ta dyrektywa jest używana jako wartownika w przypadkach, gdy element obiektu XAML zawiera zawartość w źródłowym XAML, ale nie można określić właściwości zawartości w aktualnie dostępnym kontekście schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="938c6-297">Ten przypadek można wykryć w strumieniu węzła `_UnknownContent`XAML, sprawdzając, czy nie ma członków o nazwie .</span><span class="sxs-lookup"><span data-stu-id="938c6-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="938c6-298">Jeśli żadna inna akcja nie zostanie podjęta w <xref:System.Xaml.XamlObjectWriter> strumieniu węzła `WriteEndObject` XAML `_UnknownContent` ścieżki obciążenia, domyślna próba jest podejmowana, gdy napotka element członkowski na dowolnym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="938c6-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="938c6-299">Domyślny <xref:System.Xaml.XamlXmlWriter> nie zgłasza i traktuje element członkowski jako niejawny.</span><span class="sxs-lookup"><span data-stu-id="938c6-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="938c6-300">Można uzyskać jednostkę statyczną dla `_UnknownContent` z . <xref:System.Xaml.XamlLanguage.UnknownContent%2A></span><span class="sxs-lookup"><span data-stu-id="938c6-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="938c6-301">**Właściwość kolekcji:** Mimo że zapasowy typ CLR klasy kolekcji, który jest używany dla XAML zwykle ma dedykowaną właściwość o nazwie, która przechowuje elementy kolekcji, ta właściwość nie jest znana systemowi typu XAML przed rozdzielczością typu kopii zapasowej.</span><span class="sxs-lookup"><span data-stu-id="938c6-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="938c6-302">Zamiast tego strumień węzła XAML `Items` wprowadza symbol zastępczy jako element członkowski typu XAML kolekcji.</span><span class="sxs-lookup"><span data-stu-id="938c6-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="938c6-303">W implementacji usług .NET XAML nazwa tej dyrektywy lub `_Items`elementu członkowskiego w strumieniu węzła jest .</span><span class="sxs-lookup"><span data-stu-id="938c6-303">In .NET XAML Services implementation, the name of this directive or member in the node stream is `_Items`.</span></span> <span data-ttu-id="938c6-304">Stała dla tej dyrektywy może <xref:System.Xaml.XamlLanguage.Items%2A>być uzyskana z .</span><span class="sxs-lookup"><span data-stu-id="938c6-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="938c6-305">Należy zauważyć, że strumień węzła XAML może zawierać Items właściwości z elementów, które okazują się nie być parsable na podstawie rozdzielczości typu kopii zapasowej i kontekstu schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="938c6-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="938c6-306">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="938c6-306">For example,</span></span>

- <span data-ttu-id="938c6-307">**Elementy członkowskie zdefiniowane w języku XML:** Zdefiniowane `xml:base`przez XML elementy `xml:lang` członkowskie `xml:space` są zgłaszane jako `base` `lang`dyrektywy `space` XAML o nazwie , a także w implementacjach usług .NET XAML Services.</span><span class="sxs-lookup"><span data-stu-id="938c6-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in .NET XAML Services implementations.</span></span> <span data-ttu-id="938c6-308">Obszar nazw dla nich jest obszar `http://www.w3.org/XML/1998/namespace`nazw XML .</span><span class="sxs-lookup"><span data-stu-id="938c6-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="938c6-309">Stałe dla każdego z nich <xref:System.Xaml.XamlLanguage>można uzyskać od .</span><span class="sxs-lookup"><span data-stu-id="938c6-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="938c6-310">Kolejność węzłów</span><span class="sxs-lookup"><span data-stu-id="938c6-310">Node Order</span></span>

<span data-ttu-id="938c6-311">W niektórych <xref:System.Xaml.XamlXmlReader> przypadkach zmienia kolejność węzłów XAML w strumieniu węzłów XAML w porównaniu z kolejnością, w jaką węzły są wyświetlane, jeśli są wyświetlane w znacznikach lub są przetwarzane jako XML.</span><span class="sxs-lookup"><span data-stu-id="938c6-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="938c6-312">Odbywa się to w celu zamówienia węzłów, takie, że można <xref:System.Xaml.XamlObjectWriter> przetwarzać strumień węzła w sposób tylko do przodu.</span><span class="sxs-lookup"><span data-stu-id="938c6-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="938c6-313">W usługach XAML .NET czytnik XAML zmienia kolejność węzłów, zamiast pozostawiać to zadanie modułowi zapisującego XAML jako optymalizację wydajności dla konsumentów modułu zapisującego obiekt XAML strumienia węzła.</span><span class="sxs-lookup"><span data-stu-id="938c6-313">In .NET XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="938c6-314">Niektóre dyrektywy są przeznaczone specjalnie do zapewnienia więcej informacji do tworzenia obiektu z elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="938c6-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="938c6-315">Dyrektywy te są `Initialization` `PositionalParameters`następujące: `FactoryMethod` `Arguments`, , `TypeArguments`, .</span><span class="sxs-lookup"><span data-stu-id="938c6-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="938c6-316">Czytniki XAML usług .NET XAML próbują umieścić te dyrektywy jako pierwsze elementy `StartObject`członkowskie w strumieniu węzłów po obiekcie , z przyczyn, które są wyjaśnione w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="938c6-316">.NET XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="938c6-317">Zachowanie XamlObjectWriter i kolejność węzłów</span><span class="sxs-lookup"><span data-stu-id="938c6-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="938c6-318">`StartObject`do <xref:System.Xaml.XamlObjectWriter> a nie musi być sygnał do modułu zapisującego obiekt XAML do natychmiastowego konstruowania wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="938c6-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="938c6-319">XAML zawiera kilka funkcji języka, które umożliwiają zainicjowanie obiektu z dodatkowymi danymi wejściowymi i nie polegać wyłącznie na wywoływaniu konstruktora bez parametrów do tworzenia obiektu początkowego, a dopiero potem ustawienie właściwości.</span><span class="sxs-lookup"><span data-stu-id="938c6-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="938c6-320">Funkcje te <xref:System.Windows.Markup.XamlDeferLoadAttribute>obejmują: ; tekst inicjowania; [x:TypArguments](xtypearguments-directive.md); parametry pozycyjne rozszerzenia znaczników; metody fabryczne i skojarzone [x:Arguments](xarguments-directive.md) nodes (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="938c6-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](xtypearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](xarguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="938c6-321">Każdy z tych przypadków opóźnia rzeczywistą budowę obiektu, a ponieważ strumień węzła jest ponownie zamówiony, moduł zapisujący obiekt XAML może polegać na zachowaniu faktycznego konstruowania wystąpienia za każdym razem, gdy napotka się element członkowski start, który nie jest specjalnie dyrektywą budowlaną dla tego typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="938c6-321">Each of these cases delays the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="938c6-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="938c6-322">GetObject</span></span>

<span data-ttu-id="938c6-323">`GetObject`reprezentuje węzeł XAML, gdzie zamiast konstruowania nowego obiektu, moduł zapisujący obiekt XAML powinien zamiast tego uzyskać wartość właściwości zawierającej obiekt.</span><span class="sxs-lookup"><span data-stu-id="938c6-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="938c6-324">Typowy przypadek, `GetObject` w którym węzeł występuje w strumieniu węzła XAML jest dla obiektu kolekcji lub obiektu słownika, gdy zawierająca właściwość jest celowo tylko do odczytu w modelu obiektu typu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="938c6-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="938c6-325">W tym scenariuszu kolekcji lub słownika często jest tworzony i inicjowany (zwykle puste) przez logikę inicjowania typu posiadania.</span><span class="sxs-lookup"><span data-stu-id="938c6-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="938c6-326">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="938c6-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="938c6-327">Usługi XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="938c6-328">Przestrzeń nazw XAML</span><span class="sxs-lookup"><span data-stu-id="938c6-328">XAML Namespaces</span></span>](namespaces.md)
