---
title: Definiowanie typów niestandardowych do użytku z usługami .NET XAML
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "82071858"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="46192-102">Definiowanie typów niestandardowych do użytku z usługami .NET XAML</span><span class="sxs-lookup"><span data-stu-id="46192-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="46192-103">Podczas definiowania typów niestandardowych, które są obiektami biznesowymi lub są typami, które nie mają zależności od określonych struktur, istnieją pewne najlepsze rozwiązania dla XAML, które można wykonać.</span><span class="sxs-lookup"><span data-stu-id="46192-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="46192-104">Jeśli zastosujesz się do tych praktyk, usługi .NET XAML Services i ich czytniki XAML i moduły zapisu XAML mogą odnajdywać cechy XAML danego typu i nadać mu odpowiednią reprezentację w strumieniu węzła XAML przy użyciu systemu typu XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="46192-105">W tym temacie opisano najlepsze rozwiązania dotyczące definicji typów, definicji elementów członkowskich i przypisywania typów lub elementów członkowskich CLR.</span><span class="sxs-lookup"><span data-stu-id="46192-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="46192-106">Szyki konstruktora i definicje typów dla XAML</span><span class="sxs-lookup"><span data-stu-id="46192-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="46192-107">Aby utworzyć wystąpienie jako element obiektu w języku XAML, klasa niestandardowa musi spełniać następujące wymagania:</span><span class="sxs-lookup"><span data-stu-id="46192-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="46192-108">Klasa niestandardowa musi być publiczna i musi ujawnić bez parametrów konstruktora publicznego.</span><span class="sxs-lookup"><span data-stu-id="46192-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="46192-109">(Zobacz poniższą sekcję, aby zapoznać się z uwagami dotyczącymi struktur).</span><span class="sxs-lookup"><span data-stu-id="46192-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="46192-110">Klasa niestandardowa nie może być klasą zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="46192-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="46192-111">Dodatkowa "kropka" w ścieżce pełnej nazwy sprawia, że podział obszaru nazw klasy jest niejednoznaczny i koliduje z innymi funkcjami XAML, takimi jak dołączone właściwości.</span><span class="sxs-lookup"><span data-stu-id="46192-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="46192-112">Jeśli obiekt może zostać utworzony jako element obiektu, utworzony obiekt może wypełnić formę elementu właściwości wszystkich właściwości, które przyjmują obiekt jako ich typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="46192-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="46192-113">Nadal można podać wartości obiektów dla typów, które nie spełniają tych kryteriów, jeśli włączysz konwerter wartości.</span><span class="sxs-lookup"><span data-stu-id="46192-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="46192-114">Aby uzyskać więcej informacji, zobacz [Konwertery typów i rozszerzenia znaczników dla XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="46192-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="46192-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="46192-115">Structures</span></span>

<span data-ttu-id="46192-116">Struktury są zawsze w stanie być konstruowane w XAML, według definicji CLR.</span><span class="sxs-lookup"><span data-stu-id="46192-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="46192-117">Dzieje się tak, ponieważ kompilator CLR niejawnie tworzy konstruktora bez parametrów dla struktury.</span><span class="sxs-lookup"><span data-stu-id="46192-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="46192-118">Ten konstruktor inicjuje wszystkie wartości właściwości do ich wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="46192-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="46192-119">W niektórych przypadkach domyślne zachowanie konstrukcji dla struktury nie jest pożądane.</span><span class="sxs-lookup"><span data-stu-id="46192-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="46192-120">Może to być spowodowane strukturą jest przeznaczony do wypełniania wartości i funkcji koncepcyjnie jako unii.</span><span class="sxs-lookup"><span data-stu-id="46192-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="46192-121">Jako związek zawarte wartości mogą mieć wzajemnie wykluczające się interpretacje, a zatem żadna z jego właściwości nie jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="46192-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="46192-122">Przykładem takiej struktury w słownictwie WPF jest <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="46192-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="46192-123">Takie struktury należy zaimplementować konwerter typów, tak aby wartości mogą być wyrażone w formie atrybutu, przy użyciu konwencji ciągów, które tworzą różne interpretacje lub tryby wartości struktury.</span><span class="sxs-lookup"><span data-stu-id="46192-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="46192-124">Struktura powinna również uwidaczniać podobne zachowanie dla konstrukcji kodu za pośrednictwem konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="46192-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="46192-125">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="46192-125">Interfaces</span></span>

<span data-ttu-id="46192-126">Interfejsy mogą być używane jako podstawowe typy elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="46192-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="46192-127">System typu XAML sprawdza listę przypisywaną i oczekuje, że obiekt, który jest dostarczany jako wartość może być przypisany do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="46192-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="46192-128">Nie istnieje pojęcie, jak interfejs musi być przedstawiony jako typ XAML tak długo, jak odpowiedni typ przypisywania obsługuje wymagania konstrukcyjne XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="46192-129">Metody fabryczne</span><span class="sxs-lookup"><span data-stu-id="46192-129">Factory Methods</span></span>

<span data-ttu-id="46192-130">Metody fabryczne są funkcją XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="46192-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="46192-131">Modyfikują zasadę XAML, że obiekty muszą mieć konstruktory bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="46192-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="46192-132">Metody fabryczne nie są opisane w tym artykule.</span><span class="sxs-lookup"><span data-stu-id="46192-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="46192-133">Zobacz [x:FactoryMethod Dyrektywy](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="46192-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="46192-134">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="46192-134">Enumerations</span></span>

<span data-ttu-id="46192-135">Wyliczenia mają zachowanie konwersji typu natywnego XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="46192-136">Nazwy stałych wyliczenia określone w języku XAML są rozpoznawane względem podstawowego typu wyliczenia i zwracają wartość wyliczenia do modułu zapisującego obiekt XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="46192-137">XAML obsługuje użycie w stylu flagi dla <xref:System.FlagsAttribute> wyliczenia z zastosowanym.</span><span class="sxs-lookup"><span data-stu-id="46192-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="46192-138">Aby uzyskać więcej informacji, zobacz Szczegółowo [składnię XAML](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="46192-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="46192-139">[(Składnia XAML w szczegółach](../../framework/wpf/advanced/xaml-syntax-in-detail.md) jest napisana dla odbiorców WPF, ale większość informacji w tym temacie jest istotne dla XAML, który nie jest specyficzny dla określonej struktury implementacji.)</span><span class="sxs-lookup"><span data-stu-id="46192-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="46192-140">Definicje elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="46192-140">Member Definitions</span></span>

<span data-ttu-id="46192-141">Typy można zdefiniować elementy członkowskie dla użycia XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="46192-142">Jest możliwe dla typów do definiowania elementów członkowskich, które są użyteczne xaml, nawet jeśli ten określony typ nie jest użyteczny xaml.</span><span class="sxs-lookup"><span data-stu-id="46192-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="46192-143">Jest to możliwe ze względu na dziedziczenie CLR.</span><span class="sxs-lookup"><span data-stu-id="46192-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="46192-144">Tak długo, jak jakiś typ, który dziedziczy element członkowski obsługuje użycie XAML jako typ, a element członkowski obsługuje użycie XAML dla jego typu bazowego lub ma dostępną składnię XAML, ten element członkowski jest użyteczny dla języka XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="46192-145">Właściwości</span><span class="sxs-lookup"><span data-stu-id="46192-145">Properties</span></span>

<span data-ttu-id="46192-146">Jeśli właściwości są definiowane jako publiczna właściwość `get` `set` CLR przy użyciu typowych wzorców CLR i akcesorów oraz słów kluczowych <xref:System.Xaml.XamlMember> odpowiednich dla <xref:System.Xaml.XamlMember.IsReadPublic%2A> języka, system typów XAML może zgłaszać właściwość jako element członkowski z odpowiednimi informacjami dla właściwości, takimi jak i <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="46192-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="46192-147">Określone właściwości można włączyć składnię tekstu, stosując <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="46192-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="46192-148">Aby uzyskać więcej informacji, zobacz [Konwertery typów i rozszerzenia znaczników dla XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="46192-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="46192-149">W przypadku braku składni tekstu lub natywnej konwersji XAML i w przypadku braku dalszych pośrednich, takich jak użycie rozszerzenia znaczników, typ właściwości (w<xref:System.Xaml.XamlMember.TargetType%2A> systemie typu XAML) musi mieć możliwość zwrócenia wystąpienia do modułu zapisującego obiekt XAML, traktując typ docelowy jako typ CLR.</span><span class="sxs-lookup"><span data-stu-id="46192-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="46192-150">W przypadku korzystania z XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) może służyć do dostarczania wartości, jeśli poprzednie uwagi nie są spełnione; jednak jest to bardziej problem użycia niż problem z definicją typu.</span><span class="sxs-lookup"><span data-stu-id="46192-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="46192-151">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="46192-151">Events</span></span>

<span data-ttu-id="46192-152">Jeśli zdarzenia są definiowane jako publiczne zdarzenie CLR, system typu XAML może zgłaszać zdarzenie jako element członkowski jako <xref:System.Xaml.XamlMember.IsEvent%2A> `true`.</span><span class="sxs-lookup"><span data-stu-id="46192-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="46192-153">Okablowanie programów obsługi zdarzeń nie jest w zakresie funkcji usług .NET XAML Services; okablowanie pozostawia się określonym ramom i implementacjom.</span><span class="sxs-lookup"><span data-stu-id="46192-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="46192-154">Metody</span><span class="sxs-lookup"><span data-stu-id="46192-154">Methods</span></span>

<span data-ttu-id="46192-155">Wbudowany kod metod nie jest domyślną funkcją XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="46192-156">W większości przypadków nie bezpośrednio odwołać się do elementów członkowskich metody z XAML, a rola metod w XAML jest tylko w celu zapewnienia obsługi określonych wzorców XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="46192-157">[x:Dyrektywa FactoryMethod](xfactorymethod-directive.md) jest wyjątkiem.</span><span class="sxs-lookup"><span data-stu-id="46192-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="46192-158">Pola</span><span class="sxs-lookup"><span data-stu-id="46192-158">Fields</span></span>

<span data-ttu-id="46192-159">Wytyczne dotyczące projektowania PROGRAMU CLR zniechęcają do pól niestatycznych.</span><span class="sxs-lookup"><span data-stu-id="46192-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="46192-160">W przypadku pól statycznych można uzyskiwać dostęp do wartości pól statycznych tylko za pośrednictwem [x:Static Markup Extension](xstatic-markup-extension.md); w takim przypadku nie robisz nic specjalnego w definicji CLR, aby udostępnić pole dla [x:Static](xstatic-markup-extension.md) użycia.</span><span class="sxs-lookup"><span data-stu-id="46192-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="46192-161">Członkowie dołączani</span><span class="sxs-lookup"><span data-stu-id="46192-161">Attachable Members</span></span>

<span data-ttu-id="46192-162">Dołączane elementy członkowskie są narażone na XAML za pośrednictwem wzorca metody akcesora na typ definiujący.</span><span class="sxs-lookup"><span data-stu-id="46192-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="46192-163">Sam typ definiujący nie musi być użyteczny jako obiekt XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="46192-164">W rzeczywistości typowy pattern jest zadeklarować klasę usługi, której rolą jest właścicielem dołączanego elementu członkowskiego i implementowania powiązanych zachowań, ale nie obsługują żadnej innej funkcji, takiej jak reprezentacja interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="46192-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="46192-165">W poniższych sekcjach symbol zastępczy *PropertyName* reprezentuje nazwę dołączanego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="46192-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="46192-166">Ta nazwa musi być prawidłowa w [XamlName Grammar](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="46192-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="46192-167">Należy zachować ostrożność kolizji nazw między tymi wzorcami i innych metod typu.</span><span class="sxs-lookup"><span data-stu-id="46192-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="46192-168">Jeśli istnieje element członkowski, który pasuje do jednego z wzorców, może być interpretowany jako dołączany element członkowski ścieżki użycia przez procesor XAML, nawet jeśli nie było to intencją.</span><span class="sxs-lookup"><span data-stu-id="46192-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="46192-169">Akcesor GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="46192-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="46192-170">Podpis akcesora `GetPropertyName` musi być:</span><span class="sxs-lookup"><span data-stu-id="46192-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="46192-171">Obiekt `target` można określić jako bardziej szczegółowy typ w implementacji.</span><span class="sxs-lookup"><span data-stu-id="46192-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="46192-172">Można użyć tego do zakresu użycia członka dołączane; użycia poza zamierzonym zakresem będzie zgłaszać nieprawidłowe wyjątki rzutowanie, które są następnie powierzchniowe przez błąd analizy XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="46192-173">Nazwa `target` parametru nie jest wymaganiem, ale jest nazwany `target` przez konwencję w większości implementacji.</span><span class="sxs-lookup"><span data-stu-id="46192-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="46192-174">Zwracana wartość może być określona jako bardziej szczegółowy typ w implementacji.</span><span class="sxs-lookup"><span data-stu-id="46192-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="46192-175">Aby obsługiwać włączoną składnię <xref:System.ComponentModel.TypeConverter> tekstu dla użycia atrybutu dołączanego elementu członkowskiego, zastosuj <xref:System.ComponentModel.TypeConverterAttribute> do `GetPropertyName` akcesora.</span><span class="sxs-lookup"><span data-stu-id="46192-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="46192-176">Zastosowanie do `get` zamiast `set` może wydawać się nie intuicyjne; jednak ta konwencja może obsługiwać koncepcję tylko do odczytu dołączanych elementów członkowskich, które są serializable, co jest przydatne w scenariuszach projektanta.</span><span class="sxs-lookup"><span data-stu-id="46192-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="46192-177">Akcesor SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="46192-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="46192-178">Podpis akcesora `SetPropertyName` musi być:</span><span class="sxs-lookup"><span data-stu-id="46192-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="46192-179">Obiekt `target` można określić jako bardziej szczegółowy typ w implementacji, z taką samą logiką i konsekwencjami, jak opisano w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="46192-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="46192-180">Obiekt `value` można określić jako bardziej szczegółowy typ w implementacji.</span><span class="sxs-lookup"><span data-stu-id="46192-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="46192-181">Należy pamiętać, że wartość dla tej metody jest dane wejściowe pochodzące z użycia XAML, zazwyczaj w formie atrybutu.</span><span class="sxs-lookup"><span data-stu-id="46192-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="46192-182">Z formularza atrybutu musi być obsługa konwertera wartości dla składni `GetPropertyName`tekstu i atrybut na akcesor s.</span><span class="sxs-lookup"><span data-stu-id="46192-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="46192-183">Dołączane sklepy członkowskie</span><span class="sxs-lookup"><span data-stu-id="46192-183">Attachable Member Stores</span></span>

<span data-ttu-id="46192-184">Metody akcesora zazwyczaj nie są wystarczające, aby zapewnić środki do umieszczenia dołączanych wartości elementów członkowskich na wykresie obiektu lub do pobierania wartości z wykresu obiektu i serializować je poprawnie.</span><span class="sxs-lookup"><span data-stu-id="46192-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="46192-185">Aby zapewnić tę funkcję, `target` obiekty w poprzednich podpisów akcesor musi być zdolny do przechowywania wartości.</span><span class="sxs-lookup"><span data-stu-id="46192-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="46192-186">Mechanizm magazynowania powinny być zgodne z zasadą dołączania elementu członkowskiego, że element członkowski jest dołączony do obiektów docelowych, gdzie dołączany element członkowski nie znajduje się na liście członków.</span><span class="sxs-lookup"><span data-stu-id="46192-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="46192-187">Usługi .NET XAML services zapewniają technikę implementacji dla <xref:System.Xaml.IAttachedPropertyStore> <xref:System.Xaml.AttachablePropertyServices>dołączanych magazynów elementów członkowskich za pośrednictwem interfejsów API i .</span><span class="sxs-lookup"><span data-stu-id="46192-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="46192-188"><xref:System.Xaml.IAttachedPropertyStore>jest używany przez moduły zapisu XAML do odnajdowania implementacji magazynu i powinny być implementowane na typ, który jest `target` akcesorów.</span><span class="sxs-lookup"><span data-stu-id="46192-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="46192-189">Statyczne <xref:System.Xaml.AttachablePropertyServices> interfejsy API są używane w treści akcesorów i <xref:System.Xaml.AttachableMemberIdentifier>odnoszą się do dołączanego elementu członkowskiego przez jego .</span><span class="sxs-lookup"><span data-stu-id="46192-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="46192-190">Atrybuty CLR związane z XAML</span><span class="sxs-lookup"><span data-stu-id="46192-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="46192-191">Poprawne przypisywanie typów, elementów członkowskich i zestawów jest ważne w celu raportowania informacji o systemie typu XAML do usług .NET XAML Services.</span><span class="sxs-lookup"><span data-stu-id="46192-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="46192-192">Raportowanie informacji o systemie typu XAML jest istotne, jeśli ma zastosowanie do jednej z następujących sytuacji:</span><span class="sxs-lookup"><span data-stu-id="46192-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="46192-193">Typy mają być używane z systemami XAML, które są bezpośrednio oparte na czytnikach XAML usług .NET XAML i modułach zapisu XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="46192-194">Definiujesz lub używasz platformy wykorzystującej XAML, która jest oparta na tych czytnikach XAML i modułach zapisujących XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="46192-195">Aby uzyskać listę każdego atrybutu związanego z XAML, który jest odpowiedni dla obsługi XAML typów niestandardowych, zobacz [Atrybuty CLR związane z XAML dla typów niestandardowych i bibliotek](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="46192-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="46192-196">Sposób użycia</span><span class="sxs-lookup"><span data-stu-id="46192-196">Usage</span></span>

<span data-ttu-id="46192-197">Użycie typów niestandardowych wymaga, aby autor znaczników mapować prefiks dla zestawu i obszaru nazw CLR, które zawierają typ niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="46192-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="46192-198">Ta procedura nie jest udokumentowana w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="46192-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="46192-199">Poziom dostępu</span><span class="sxs-lookup"><span data-stu-id="46192-199">Access Level</span></span>

<span data-ttu-id="46192-200">XAML zapewnia możliwość ładowania i tworzenia wystąpienia `internal` typów, które mają poziom dostępu.</span><span class="sxs-lookup"><span data-stu-id="46192-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="46192-201">Ta możliwość jest dostępna, dzięki czemu kod użytkownika można zdefiniować własne typy, a następnie utworzyć wystąpienia tych klas z znaczników, który jest również częścią tego samego zakresu kodu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="46192-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="46192-202">Przykład z WPF jest zawsze, gdy <xref:System.Windows.Controls.UserControl> kod użytkownika definiuje, który jest przeznaczony jako sposób refaktoryzacji zachowanie interfejsu użytkownika, ale nie jako `public` część dowolnego mechanizmu rozszerzenia możliwe, które mogą być implikowane przez zadeklarowanie klasy pomocniczej z poziomem dostępu.</span><span class="sxs-lookup"><span data-stu-id="46192-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="46192-203">Takie <xref:System.Windows.Controls.UserControl> można zadeklarować `internal` z dostępem, jeśli kod zapasowy jest kompilowany do tego samego zestawu, z którego odwołuje się jako typ XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="46192-204">Dla aplikacji, która ładuje XAML w <xref:System.Xaml.XamlObjectWriter>pełnej `internal` relacji zaufania i używa, ładowanie klas z poziomem dostępu jest zawsze włączone.</span><span class="sxs-lookup"><span data-stu-id="46192-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="46192-205">Dla aplikacji, która ładuje XAML w ramach częściowego zaufania, <xref:System.Xaml.Permissions.XamlAccessLevel> można kontrolować charakterystyki poziomu dostępu przy użyciu interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="46192-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="46192-206">Ponadto mechanizmy odroczenia (takie jak system szablonów WPF) muszą mieć możliwość propagowania wszelkich uprawnień na poziomie dostępu i zachowywania ich dla ewentualnych ocen czasu wykonywania; jest to obsługiwane wewnętrznie przez <xref:System.Xaml.Permissions.XamlAccessLevel> przekazywanie informacji.</span><span class="sxs-lookup"><span data-stu-id="46192-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="46192-207">Implementacja WPF</span><span class="sxs-lookup"><span data-stu-id="46192-207">WPF Implementation</span></span>

<span data-ttu-id="46192-208">WPF XAML używa modelu dostępu częściowego zaufania, gdzie jeśli BAML jest <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> ładowany w ramach częściowego zaufania, dostęp jest ograniczony do zestawu, który jest źródłem BAML.</span><span class="sxs-lookup"><span data-stu-id="46192-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="46192-209">Dla odroczenia WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> używa jako mechanizm przekazywania informacji o poziomie dostępu.</span><span class="sxs-lookup"><span data-stu-id="46192-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="46192-210">W terminologii WPF XAML *typ wewnętrzny* jest typem zdefiniowanym przez ten sam zestaw, który zawiera również odwołanie XAML.</span><span class="sxs-lookup"><span data-stu-id="46192-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="46192-211">Taki typ można mapować za pomocą przestrzeni nazw XAML, która celowo pomija assembly= `xmlns:local="clr-namespace:WPFApplication1"`część mapowania, na przykład .</span><span class="sxs-lookup"><span data-stu-id="46192-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="46192-212">Jeśli BAML odwołuje się do typu `internal` wewnętrznego i ten `GeneratedInternalTypeHelper` typ ma poziom dostępu, generuje klasę dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="46192-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="46192-213">Jeśli chcesz uniknąć `GeneratedInternalTypeHelper`, należy użyć `public` poziomu dostępu lub musi czynnikiem odpowiedniej klasy w oddzielnym zestawie i uzależnić ten zestaw.</span><span class="sxs-lookup"><span data-stu-id="46192-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="46192-214">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="46192-214">See also</span></span>

- [<span data-ttu-id="46192-215">Atrybuty CLR związane z XAML dla niestandardowych typów i bibliotek</span><span class="sxs-lookup"><span data-stu-id="46192-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="46192-216">Usługi XAML</span><span class="sxs-lookup"><span data-stu-id="46192-216">XAML Services</span></span>](../../../api/index.md)
