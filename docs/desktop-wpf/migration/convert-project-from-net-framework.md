---
title: Migrowanie aplikacji WPF do platformy .NET Core 3.0
description: Dowiedz się, jak przeprowadzić migrację aplikacji Windows Presentation Foundation (WPF) do platformy .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071312"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="6a55d-103">Migrowanie aplikacji WPF do platformy .NET Core</span><span class="sxs-lookup"><span data-stu-id="6a55d-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="6a55d-104">W tym artykule opisano kroki niezbędne do migracji aplikacji Windows Presentation Foundation (WPF) z programu .NET Framework do platformy .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="6a55d-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="6a55d-105">Jeśli nie masz aplikacji WPF pod ręką do portu, ale chcesz wypróbować proces, możesz użyć przykładowej aplikacji **Bean Trader** dostępnej na [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="6a55d-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="6a55d-106">Oryginalna aplikacja (targetowanie .NET Framework 4.7.2) jest dostępna w folderze NetFx\BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="6a55d-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="6a55d-107">Najpierw wyjaśnimy kroki niezbędne do przenoszenia aplikacji w ogóle, a następnie przejdziemy przez konkretne zmiany, które mają zastosowanie do próbki **Bean Trader.**</span><span class="sxs-lookup"><span data-stu-id="6a55d-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="6a55d-108">Aby przeprowadzić migrację do platformy .NET Core, należy najpierw:</span><span class="sxs-lookup"><span data-stu-id="6a55d-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="6a55d-109">Zrozumienie i aktualizowanie zależności NuGet:</span><span class="sxs-lookup"><span data-stu-id="6a55d-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="6a55d-110">Uaktualnij zależności NuGet, `<PackageReference>` aby użyć formatu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="6a55d-111">Przejrzyj zależności nuget najwyższego poziomu dla zgodności .NET Core lub .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="6a55d-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="6a55d-112">Uaktualnij pakiety NuGet do nowszych wersji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="6a55d-113">Użyj [analizatora przenoszenia platformy .NET,](../../standard/analyzers/portability-analyzer.md) aby zrozumieć zależności .NET.</span><span class="sxs-lookup"><span data-stu-id="6a55d-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="6a55d-114">Migrowanie pliku projektu do nowego formatu w stylu SDK:</span><span class="sxs-lookup"><span data-stu-id="6a55d-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="6a55d-115">Wybierz, czy mają być przeznaczone zarówno dla platformy .NET Core, jak i platformy .NET Framework, czy tylko do programu .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="6a55d-116">Skopiuj odpowiednie właściwości i elementy pliku projektu do nowego pliku projektu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="6a55d-117">Rozwiązywanie problemów z kompilacją:</span><span class="sxs-lookup"><span data-stu-id="6a55d-117">Fix build issues:</span></span>

    01. <span data-ttu-id="6a55d-118">Dodaj odwołanie do pakietu [Microsoft.Windows.Compatibility.](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)</span><span class="sxs-lookup"><span data-stu-id="6a55d-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="6a55d-119">Znajdź i napraw różnice na poziomie interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6a55d-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="6a55d-120">Usuń sekcje *app.config* inne niż `appSettings` lub `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="6a55d-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="6a55d-121">W razie potrzeby ponownie wygeneruj wygenerowany kod.</span><span class="sxs-lookup"><span data-stu-id="6a55d-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="6a55d-122">Testowanie środowiska uruchomieniowego:</span><span class="sxs-lookup"><span data-stu-id="6a55d-122">Runtime testing:</span></span>

    01. <span data-ttu-id="6a55d-123">Upewnij się, że przeniesiona aplikacja działa zgodnie z oczekiwaniami.</span><span class="sxs-lookup"><span data-stu-id="6a55d-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="6a55d-124">Uważaj <xref:System.NotSupportedException> na wyjątki.</span><span class="sxs-lookup"><span data-stu-id="6a55d-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="6a55d-125">Informacje o próbce</span><span class="sxs-lookup"><span data-stu-id="6a55d-125">About the sample</span></span>

<span data-ttu-id="6a55d-126">W tym artykule odwołuje [się do przykładowej aplikacji Bean Trader,](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) ponieważ używa różnych zależności podobnych do tych, które mogą mieć aplikacje WPF w świecie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="6a55d-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="6a55d-127">Aplikacja nie jest duża, ale ma być o krok od "Hello World" pod względem złożoności.</span><span class="sxs-lookup"><span data-stu-id="6a55d-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="6a55d-128">Aplikacja pokazuje niektóre problemy, które użytkownicy mogą napotkać podczas przenoszenia prawdziwych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="6a55d-129">Aplikacja komunikuje się z usługą WCF, więc aby działała poprawnie, należy również uruchomić projekt BeanTraderServer (dostępny w tym samym repozytorium GitHub) i upewnij się, że beantraderclient punktów konfiguracji do prawidłowego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="6a55d-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="6a55d-130">(Domyślnie przykład zakłada, że serwer jest uruchomiony *http://localhost:8090*na tym samym komputerze na poziomie , co będzie prawdą, jeśli uruchomisz BeanTraderServer lokalnie.)</span><span class="sxs-lookup"><span data-stu-id="6a55d-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="6a55d-131">Należy pamiętać, że ta przykładowa aplikacja ma na celu zademonstrowanie problemów i rozwiązań związanych z przenoszeniem .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="6a55d-132">Nie jest przeznaczony do wykazania WPF najlepszych praktyk.</span><span class="sxs-lookup"><span data-stu-id="6a55d-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="6a55d-133">W rzeczywistości, celowo zawiera pewne anty-wzorców, aby upewnić się, że natkniesz się co najmniej kilka ciekawych wyzwań podczas przenoszenia.</span><span class="sxs-lookup"><span data-stu-id="6a55d-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="6a55d-134">Przygotowanie</span><span class="sxs-lookup"><span data-stu-id="6a55d-134">Getting ready</span></span>

<span data-ttu-id="6a55d-135">Podstawowym wyzwaniem związanym z migracją aplikacji .NET Framework do platformy .NET Core jest to, że jej zależności mogą działać inaczej lub wcale.</span><span class="sxs-lookup"><span data-stu-id="6a55d-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="6a55d-136">Migracja jest o wiele łatwiejsza niż kiedyś; wiele pakietów NuGet jest teraz kierowanych na standard .NET.</span><span class="sxs-lookup"><span data-stu-id="6a55d-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="6a55d-137">Począwszy od .NET Core 2.0, obszary powierzchni .NET Framework i .NET Core stały się podobne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="6a55d-138">Mimo to niektóre różnice (zarówno w obsłudze pakietów NuGet i dostępnych interfejsów API .NET) pozostają.</span><span class="sxs-lookup"><span data-stu-id="6a55d-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="6a55d-139">Pierwszym krokiem w migracji jest przejrzenie zależności aplikacji i upewnienie się, że odwołania są w formacie, który można łatwo migrować do platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="6a55d-140">Uaktualnij `<PackageReference>` do odniesień NuGet</span><span class="sxs-lookup"><span data-stu-id="6a55d-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="6a55d-141">Starsze projekty platformy .NET Framework zazwyczaj wyświetlają ich zależności NuGet w pliku *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="6a55d-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="6a55d-142">Nowy format pliku projektu w stylu SDK [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) odwołuje się do pakietów NuGet jako elementów w samym pliku csproj, a nie w oddzielnym pliku konfiguracyjnym.</span><span class="sxs-lookup"><span data-stu-id="6a55d-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="6a55d-143">Podczas migracji istnieją dwie zalety `<PackageReference>`korzystania z odwołań do stylu:</span><span class="sxs-lookup"><span data-stu-id="6a55d-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="6a55d-144">Jest to styl odwołania NuGet, który jest wymagany dla nowego pliku projektu .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="6a55d-145">Jeśli już używasz `<PackageReference>`, te elementy pliku projektu mogą być kopiowane i wklejane bezpośrednio do nowego projektu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="6a55d-146">W przeciwieństwie do pliku `<PackageReference>` packages.config, elementy odnoszą się tylko do zależności najwyższego poziomu, od których zależy bezpośrednio projekt.</span><span class="sxs-lookup"><span data-stu-id="6a55d-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="6a55d-147">Wszystkie inne przechodnie pakiety NuGet zostaną określone w czasie przywracania i zarejestrowane w automatycznie wygenerowanym pliku obj\project.assets.json.</span><span class="sxs-lookup"><span data-stu-id="6a55d-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="6a55d-148">Dzięki temu znacznie łatwiej określić, jakie zależności ma projekt, co jest przydatne przy określaniu, czy niezbędne zależności będą działać na .NET Core, czy nie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="6a55d-149">Pierwszym krokiem do migracji aplikacji .NET Framework do platformy .NET Core jest zaktualizowanie jej w celu użycia `<PackageReference>` odwołań NuGet.</span><span class="sxs-lookup"><span data-stu-id="6a55d-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="6a55d-150">Visual Studio sprawia, że to proste.</span><span class="sxs-lookup"><span data-stu-id="6a55d-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="6a55d-151">Wystarczy kliknąć prawym przyciskiem myszy plik *packages.config* projektu w **Eksploratorze rozwiązań**programu Visual Studio, a następnie wybrać **pozycję Migruj package.config do PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="6a55d-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Uaktualnianie do packageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="6a55d-153">Pojawi się okno dialogowe przedstawiające obliczone zależności nuget najwyższego poziomu i pytanie, które inne pakiety NuGet powinny być promowane do najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="6a55d-154">Żaden z tych innych pakietów nie musi być na najwyższym poziomie dla próbki Bean Trader, więc możesz odznaczyć wszystkie te pola.</span><span class="sxs-lookup"><span data-stu-id="6a55d-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="6a55d-155">Następnie kliknij przycisk **Ok,** a plik *packages.config* zostanie usunięty, a `<PackageReference>` elementy zostaną dodane do pliku projektu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="6a55d-156">`<PackageReference>`-style odwołania nie przechowują pakietów NuGet lokalnie w folderze pakietów.</span><span class="sxs-lookup"><span data-stu-id="6a55d-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="6a55d-157">Zamiast tego są one przechowywane globalnie jako optymalizacja.</span><span class="sxs-lookup"><span data-stu-id="6a55d-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="6a55d-158">Po zakończeniu migracji edytuj plik csproj i `<Analyzer>` usuń wszystkie elementy odnoszące się do analizatorów, które wcześniej pochodziły z *pliku .. \packages.*</span><span class="sxs-lookup"><span data-stu-id="6a55d-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="6a55d-159">Nie martw się; ponieważ nadal masz odwołania do pakietu NuGet, analizatory zostaną uwzględnione w projekcie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="6a55d-160">Wystarczy oczyścić stare elementy w stylu `<Analyzer>` packages.config.</span><span class="sxs-lookup"><span data-stu-id="6a55d-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="6a55d-161">Przejrzyj pakiety NuGet</span><span class="sxs-lookup"><span data-stu-id="6a55d-161">Review NuGet packages</span></span>

<span data-ttu-id="6a55d-162">Teraz, gdy można zobaczyć najwyższego poziomu Pakiety NuGet, od których zależy projekt, można sprawdzić, czy te pakiety są dostępne w programie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="6a55d-163">Można określić, czy pakiet obsługuje program .NET Core, patrząc na jego zależności od [nuget.org](https://www.nuget.org/). Witryna [fuget.org](https://www.fuget.org/) utworzonej przez społeczność pokazuje te informacje w widocznym miejscu u góry strony z informacjami o pakiecie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="6a55d-164">Podczas kierowania .NET Core 3.0 wszystkie pakiety przeznaczone na .NET Core lub .NET Standard powinny działać (ponieważ .NET Core implementuje powierzchnię .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="6a55d-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="6a55d-165">W niektórych przypadkach określona wersja pakietu, który jest używany nie będzie przeznaczony dla .NET Core lub .NET Standard, ale nowsze wersje będą.</span><span class="sxs-lookup"><span data-stu-id="6a55d-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="6a55d-166">W takim przypadku należy rozważyć uaktualnienie do najnowszej wersji pakietu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="6a55d-167">Można również użyć pakietów kierowanych na platformę .NET Framework, ale to wprowadza pewne ryzyko.</span><span class="sxs-lookup"><span data-stu-id="6a55d-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="6a55d-168">Zależności programu .NET Core to .NET Framework są dozwolone, ponieważ obszary powierzchni .NET Core i .NET Framework są na tyle podobne, że takie zależności *często* działają.</span><span class="sxs-lookup"><span data-stu-id="6a55d-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="6a55d-169">Jeśli jednak pakiet spróbuje użyć interfejsu API platformy .NET, który nie jest obecny w systemie .NET Core, wystąpi wyjątek środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="6a55d-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="6a55d-170">Z tego powodu należy odwoływać się do pakietów .NET Framework tylko wtedy, gdy żadne inne opcje są dostępne i zrozumieć, że w ten sposób nakłada obciążenie testowe.</span><span class="sxs-lookup"><span data-stu-id="6a55d-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="6a55d-171">Jeśli istnieją pakiety, do których istnieją odwołania, które nie są przeznaczone dla platformy .NET Core lub .NET Standard, musisz pomyśleć o innych alternatywach:</span><span class="sxs-lookup"><span data-stu-id="6a55d-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="6a55d-172">Czy istnieją inne podobne pakiety, które mogą być używane zamiast?</span><span class="sxs-lookup"><span data-stu-id="6a55d-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="6a55d-173">Czasami NuGet autorzy publikują oddzielne . Core' wersje ich bibliotek specjalnie kierowania .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="6a55d-174">Pakiety biblioteki przedsiębiorstwa są przykładem publikowania społeczności ". NetCore" alternatywy.</span><span class="sxs-lookup"><span data-stu-id="6a55d-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="6a55d-175">W innych przypadkach nowsze pakiety SDK dla określonej usługi (czasami z różnymi nazwami pakietów) są dostępne dla platformy .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="6a55d-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="6a55d-176">Jeśli nie są dostępne żadne alternatywy, można kontynuować przy użyciu pakietów .NET Framework ukierunkowane, mając na uwadze, że trzeba będzie przetestować je dokładnie po uruchomieniu na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="6a55d-177">Próbka Bean Trader ma następujące zależności NuGet najwyższego poziomu:</span><span class="sxs-lookup"><span data-stu-id="6a55d-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="6a55d-178">**Castle.Windsor, wersja 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="6a55d-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="6a55d-179">Ten pakiet jest przeznaczony dla platformy .NET Standard 1.6, więc działa na programie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="6a55d-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, wersja 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="6a55d-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="6a55d-181">Jest to meta-pakiet, więc nie jest od razu oczywiste, które platformy obsługuje, ale [dokumentacja](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) wskazuje, że jego najnowsza wersja (2.9.2) będzie działać zarówno dla .NET Framework i .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="6a55d-182">**Nito.AsyncEx, wersja 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="6a55d-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="6a55d-183">Ten pakiet nie jest ukierunkowany na .NET Core, ale nowsza wersja 5.0 nie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="6a55d-184">Jest to typowe podczas migracji, ponieważ wiele pakietów NuGet dodano ostatnio obsługę .NET Standard, ale starsze wersje projektu będą kierowane tylko na platformę .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6a55d-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="6a55d-185">Jeśli różnica wersji jest tylko różnica wersji pomocniczej, często jest to łatwe do uaktualnienia do nowszej wersji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="6a55d-186">Ponieważ jest to istotna zmiana wersji, należy zachować ostrożność uaktualniania, ponieważ może być istotne zmiany w pakiecie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="6a55d-187">Jest jednak droga naprzód, która jest dobra.</span><span class="sxs-lookup"><span data-stu-id="6a55d-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="6a55d-188">**MahApps.Metro, wersja 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="6a55d-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="6a55d-189">Ten pakiet również nie jest ukierunkowany na .NET Core, ale ma nowszą wersję wstępną (2.0-alpha), która to robi.</span><span class="sxs-lookup"><span data-stu-id="6a55d-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="6a55d-190">Ponownie, trzeba zwrócić uwagę na przełomowe zmiany, ale nowszy pakiet jest zachęcający.</span><span class="sxs-lookup"><span data-stu-id="6a55d-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="6a55d-191">Bean Trader próbki NuGet zależności wszystkich docelowych .NET Standard/.NET Core lub nowsze wersje, które to zrobić, więc jest mało prawdopodobne, aby być żadnych problemów blokowania tutaj.</span><span class="sxs-lookup"><span data-stu-id="6a55d-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="6a55d-192">Uaktualnianie pakietów NuGet</span><span class="sxs-lookup"><span data-stu-id="6a55d-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="6a55d-193">Jeśli to możliwe, dobrze byłoby uaktualnić wersje wszystkich pakietów, które są przeznaczone tylko dla platformy .NET Core lub .NET Standard z nowszymi wersjami w tym momencie (z projektem nadal przeznaczone dla platformy .NET Framework), aby wcześnie wykryć i rozwiązać wszelkie przełomowe zmiany.</span><span class="sxs-lookup"><span data-stu-id="6a55d-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="6a55d-194">Jeśli wolisz nie wprowadzać żadnych istotnych zmian w istniejącej wersji programu .NET Framework aplikacji, możesz poczekać, aż pojawi się nowy plik projektu docelowy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="6a55d-195">Jednak uaktualnienie pakietów NuGet do wersji zgodnych z rdzeniem .NET z wyprzedzeniem sprawia, że proces migracji jest jeszcze łatwiejszy po utworzeniu nowego pliku projektu i zmniejsza liczbę różnic między wersjami programu .NET Framework i .NET Core aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="6a55d-196">Za pomocą próbki Bean Trader wszystkie niezbędne uaktualnienia można łatwo (przy użyciu menedżera pakietów NuGet programu Visual Studio) z jednym wyjątkiem: uaktualnienie z **MahApps.Metro 1.6.5** do **2.0** ujawnia przełomowe zmiany związane z interfejsami API zarządzania motywem i akcentami.</span><span class="sxs-lookup"><span data-stu-id="6a55d-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="6a55d-197">W idealnym przypadku aplikacja zostanie zaktualizowana, aby użyć nowszej wersji pakietu (ponieważ jest to bardziej prawdopodobne, aby działać na .NET Core).</span><span class="sxs-lookup"><span data-stu-id="6a55d-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="6a55d-198">W niektórych przypadkach może to jednak nie być wykonalne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="6a55d-199">W takich przypadkach nie uaktualniaj **MahApps.Metro,** ponieważ niezbędne zmiany są nietrywialne i ten samouczek koncentruje się na migracji do .NET Core 3, a nie do **MahApps.Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="6a55d-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="6a55d-200">Ponadto, jest to zależność .NET Framework niskiego ryzyka, ponieważ aplikacja Bean Trader wykonuje tylko niewielką część **MahApps.Metro**.</span><span class="sxs-lookup"><span data-stu-id="6a55d-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="6a55d-201">Będzie to oczywiście wymagać testowania, aby upewnić się, że wszystko działa po zakończeniu migracji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="6a55d-202">Gdyby to był rzeczywisty scenariusz, dobrze byłoby zgłosić problem, aby śledzić pracę, aby przejść do **MahApps.Metro** w wersji 2.0, ponieważ nie robi migracji teraz pozostawia pewne zadłużenie techniczne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="6a55d-203">Po nuget pakiety są aktualizowane `<PackageReference>` do najnowszych wersji, grupa towarów w pliku projektu bean trader powinien wyglądać następująco.</span><span class="sxs-lookup"><span data-stu-id="6a55d-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="6a55d-204">Analiza przenoszenia programu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="6a55d-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="6a55d-205">Po zrozumieniu stanu zależności NuGet projektu, następną rzeczą do rozważenia jest .NET Framework zależności interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6a55d-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="6a55d-206">Narzędzie [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) jest przydatne do zrozumienia, które interfejsy API platformy .NET są używane przez projekt na innych platformach .NET.</span><span class="sxs-lookup"><span data-stu-id="6a55d-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="6a55d-207">Narzędzie jest dostępne jako [wtyczka programu Visual Studio,](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer) [narzędzie wiersza polecenia](https://github.com/Microsoft/dotnet-apiport/releases)lub zawinięte w [prosty interfejs graficzny,](https://github.com/Microsoft/dotnet-apiport-ui)który upraszcza jego opcje.</span><span class="sxs-lookup"><span data-stu-id="6a55d-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="6a55d-208">Więcej informacji na temat korzystania z analizatora przenoszenia platformy .NET (API Port) przy użyciu interfejsu użytkownika w [blogu portingu do programu .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) jest dostępne w blogu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="6a55d-209">Jeśli wolisz używać wiersza polecenia, niezbędne kroki to:</span><span class="sxs-lookup"><span data-stu-id="6a55d-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="6a55d-210">Pobierz [analizator przenośności platformy .NET,](https://github.com/Microsoft/dotnet-apiport/releases) jeśli jeszcze go nie masz.</span><span class="sxs-lookup"><span data-stu-id="6a55d-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="6a55d-211">Upewnij się, że aplikacja .NET Framework do przenoszenia kompilacje pomyślnie (jest to dobry pomysł przed migracją niezależnie).</span><span class="sxs-lookup"><span data-stu-id="6a55d-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="6a55d-212">Uruchom port interfejsu API z wierszem polecenia w ten sposób.</span><span class="sxs-lookup"><span data-stu-id="6a55d-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="6a55d-213">Argument `-f` określa ścieżkę zawierającą pliki binarne do analizy.</span><span class="sxs-lookup"><span data-stu-id="6a55d-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="6a55d-214">Argument `-r` określa, który format pliku wyjściowego ma zostać sformatowy.</span><span class="sxs-lookup"><span data-stu-id="6a55d-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="6a55d-215">Argument `-t` określa, która platforma .NET do analizy użycia interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6a55d-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="6a55d-216">W takim przypadku chcesz .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="6a55d-217">Po otwarciu raportu HTML pierwsza sekcja wyświetli listę wszystkich analizowanych plików binarnych i jaki procent interfejsów API platformy .NET, których używają, jest dostępny na platformie docelowej.</span><span class="sxs-lookup"><span data-stu-id="6a55d-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="6a55d-218">Procent nie ma znaczenia sam w sobie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="6a55d-219">Co jest bardziej przydatne jest, aby zobaczyć określone interfejsy API, których brakuje.</span><span class="sxs-lookup"><span data-stu-id="6a55d-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="6a55d-220">Aby to zrobić, wybierz nazwę zestawu lub przewiń w dół do raportów dla poszczególnych zestawów.</span><span class="sxs-lookup"><span data-stu-id="6a55d-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="6a55d-221">Skoncentruj się na zestawach, dla których jesteś właścicielem kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="6a55d-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="6a55d-222">Na przykład w raporcie ApiPort dla bean trader znajduje się wiele plików binarnych, ale większość z nich należy do pakietów NuGet.</span><span class="sxs-lookup"><span data-stu-id="6a55d-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="6a55d-223">`Castle.Windsor`pokazuje, że zależy to od niektórych interfejsów API systemu.Web, których brakuje w programie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="6a55d-224">Nie jest to problemem, ponieważ wcześniej `Castle.Windsor` zweryfikowano, że obsługuje .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="6a55d-225">Często pakiety NuGet mają różne pliki binarne do użytku z różnymi platformami `Castle.Windsor` .NET, więc niezależnie od tego, czy wersja programu .NET Framework używa interfejsów API systemu.Web, czy nie, nie ma znaczenia, o ile pakiet jest również przeznaczony dla platformy .NET Standard lub .NET Core (co robi).</span><span class="sxs-lookup"><span data-stu-id="6a55d-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="6a55d-226">W przykładzie Bean Trader jedynym plikiem binarnym, który należy wziąć pod uwagę, jest **BeanTraderClient,** a raport pokazuje, że brakuje tylko dwóch interfejsów API platformy .NET: `System.ServiceModel.ClientBase<T>.Close` i `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="6a55d-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Raport przenoszenia BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="6a55d-228">Jest mało prawdopodobne, aby blokować problemy, ponieważ interfejsy API klienta WCF są (głównie) obsługiwane w programie .NET Core, więc muszą istnieć alternatywy dostępne dla tych centralnych interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="6a55d-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="6a55d-229">W rzeczywistości, `System.ServiceModel`patrząc na 's .NET <https://apisof.net>Obszar powierzchni rdzenia (za pomocą ), widać, że istnieją alternatywy asynchronicznej w .NET Core zamiast.</span><span class="sxs-lookup"><span data-stu-id="6a55d-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="6a55d-230">Na podstawie tego raportu i poprzedniej analizy zależności NuGet wygląda na to, że nie powinno być żadnych większych problemów migracji próbki Bean Trader do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="6a55d-231">Możesz przygotować się do następnego kroku, w którym faktycznie rozpoczniesz migrację.</span><span class="sxs-lookup"><span data-stu-id="6a55d-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="6a55d-232">Migrowanie pliku projektu</span><span class="sxs-lookup"><span data-stu-id="6a55d-232">Migrating the project file</span></span>

<span data-ttu-id="6a55d-233">Jeśli aplikacja nie używa nowego [formatu pliku projektu w stylu SDK,](../../core/tools/csproj.md)potrzebny jest nowy plik projektu, aby kierować reklamy na program .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="6a55d-234">Możesz zastąpić istniejący plik csproj lub, jeśli wolisz zachować istniejący projekt nietknięty w jego bieżącym stanie, możesz dodać nowy plik csproj kierowania .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="6a55d-235">Można tworzyć wersje aplikacji dla platformy .NET Framework i .NET Core za pomocą jednego pliku projektu `<TargetFrameworks>` w stylu SDK z [wieloma lokalizacjami docelowymi](../../standard/library-guidance/cross-platform-targeting.md) (określając wiele obiektów docelowych).</span><span class="sxs-lookup"><span data-stu-id="6a55d-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="6a55d-236">Aby utworzyć nowy plik projektu, można utworzyć nowy projekt WPF `dotnet new wpf` w programie Visual Studio lub użyć polecenia w katalogu tymczasowym do wygenerowania pliku projektu, a następnie skopiować/zmienić jego nazwę do poprawnej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="6a55d-237">Istnieje również narzędzie stworzone przez społeczność, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), które może zautomatyzować niektóre z migracji plików projektu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="6a55d-238">Narzędzie jest pomocne, ale nadal potrzebuje człowieka do przeglądania wyników, aby upewnić się, że wszystkie szczegóły migracji są poprawne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="6a55d-239">Jednym z określonych obszarów, które narzędzie nie obsługuje optymalnie jest migracja pakietów NuGet z plików *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="6a55d-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="6a55d-240">Jeśli narzędzie działa w pliku projektu, który nadal używa pliku *packages.config* do odwoływania się do pakietów NuGet, będzie automatycznie migrować do `<PackageReference>` elementów, ale doda `<PackageReference>` elementy dla *wszystkich* pakietów, a nie tylko te najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="6a55d-241">Jeśli zostały już zmigrowane do`<PackageReference>` elementów z programu Visual Studio (jak to zrobić w tym przykładzie), a następnie narzędzie może pomóc w pozostałej części konwersji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="6a55d-242">Podobnie jak Scott Hanselman zaleca w [swoim blogu na temat migracji plików csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), przenoszenie ręcznie jest edukacyjne i daje lepsze wyniki, jeśli masz tylko kilka projektów do portu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="6a55d-243">Ale jeśli przenosisz dziesiątki lub setki plików projektu, może pomóc narzędzie takie jak [CsprojToVs2017].</span><span class="sxs-lookup"><span data-stu-id="6a55d-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="6a55d-244">Aby utworzyć nowy plik projektu dla próbki `dotnet new wpf` Bean Trader, uruchom w katalogu tymczasowym i przenieś wygenerowany plik *csproj* do folderu *BeanTraderClient* i zmień jego nazwę **BeanTraderClient.Core.csproj**.</span><span class="sxs-lookup"><span data-stu-id="6a55d-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="6a55d-245">Ponieważ nowy format pliku projektu automatycznie zawiera pliki C#, *pliki resx* i pliki XAML, które znajduje się w katalogu lub w jego katalogu, plik projektu jest już prawie ukończony!</span><span class="sxs-lookup"><span data-stu-id="6a55d-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="6a55d-246">Aby zakończyć migrację, otwórz stare i nowe pliki projektu obok siebie i przejrzyj stare, aby sprawdzić, czy jakiekolwiek informacje, które zawiera, muszą zostać zmigrowane.</span><span class="sxs-lookup"><span data-stu-id="6a55d-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="6a55d-247">W przypadku przykładu Bean Trader następujące elementy powinny zostać skopiowane do nowego projektu:</span><span class="sxs-lookup"><span data-stu-id="6a55d-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="6a55d-248">Właściwości `<RootNamespace>` `<AssemblyName>`i `<ApplicationIcon>` właściwości powinny być kopiowane.</span><span class="sxs-lookup"><span data-stu-id="6a55d-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="6a55d-249">Należy również dodać `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` właściwość do nowego pliku projektu, ponieważ próbka Bean `[AssemblyTitle]`Trader zawiera atrybuty na poziomie zestawu (np. ) w pliku AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="6a55d-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="6a55d-250">Domyślnie nowe projekty w stylu SDK będą automatycznie generować te atrybuty na podstawie właściwości w pliku csproj.</span><span class="sxs-lookup"><span data-stu-id="6a55d-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="6a55d-251">Ponieważ nie chcesz, aby tak się stało w tym przypadku (atrybuty autogenerowane będą kolidować z `<GenerateAssemblyInfo>`tymi z AssemblyInfo.cs), należy wyłączyć atrybuty autogenerowane za pomocą programu .</span><span class="sxs-lookup"><span data-stu-id="6a55d-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="6a55d-252">Chociaż pliki *resx* są automatycznie uwzględniane jako `<Resource>` zasoby osadzone, inne elementy, takie jak obrazy, nie są.</span><span class="sxs-lookup"><span data-stu-id="6a55d-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="6a55d-253">Tak, skopiować `<Resource>` elementy do osadzania plików obrazów i ikon.</span><span class="sxs-lookup"><span data-stu-id="6a55d-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="6a55d-254">Można uprościć odwołania png do pojedynczego wiersza przy użyciu obsługi nowego formatu pliku projektu dla wzorców globbing: `<Resource Include="**\*.png" />`.</span><span class="sxs-lookup"><span data-stu-id="6a55d-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="6a55d-255">Podobnie `<None>` elementy są uwzględniane automatycznie, ale nie są domyślnie kopiowane do katalogu wyjściowego.</span><span class="sxs-lookup"><span data-stu-id="6a55d-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="6a55d-256">Ponieważ projekt Bean Trader `<None>` zawiera element, który *jest* kopiowany `PreserveNewest` do katalogu wyjściowego (przy `<None>` użyciu zachowań), należy zaktualizować automatycznie wypełniony element dla tego pliku, na przykład.</span><span class="sxs-lookup"><span data-stu-id="6a55d-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="6a55d-257">Przykład Bean Trader zawiera plik XAML (Default.Accent.xaml) `Content` jako `Page`(a nie jako), ponieważ motywy i akcenty zdefiniowane w tym pliku są ładowane z pliku XAML w czasie wykonywania, a nie są osadzane w samej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="6a55d-258">Nowy system projektu automatycznie zawiera ten `<Page>`plik jako , jednak, ponieważ jest to plik XAML.</span><span class="sxs-lookup"><span data-stu-id="6a55d-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="6a55d-259">Tak, trzeba zarówno usunąć plik XAML jako`<Page Remove="**\Default.Accent.xaml" />`stronę ( ) i dodać go jako zawartość.</span><span class="sxs-lookup"><span data-stu-id="6a55d-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="6a55d-260">Na koniec dodaj odwołania NuGet, `<ItemGroup>` kopiując `<PackageReference>` z wszystkich elementów.</span><span class="sxs-lookup"><span data-stu-id="6a55d-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="6a55d-261">Jeśli wcześniej nie uaktualniono pakietów NuGet do wersji zgodnych z rdzeniem platformy .NET, można to zrobić teraz, gdy odwołania do pakietu znajdują się w projekcie specyficznym dla rdzenia .NET.</span><span class="sxs-lookup"><span data-stu-id="6a55d-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="6a55d-262">W tym momencie powinno być możliwe, aby dodać nowy projekt do beantrader rozwiązania i otworzyć go w programie Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="6a55d-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="6a55d-263">Projekt powinien wyglądać poprawnie w `dotnet restore BeanTraderClient.Core.csproj` **Eksploratorze rozwiązań**i powinien pomyślnie przywrócić pakiety (z dwoma oczekiwanymi ostrzeżeniami związanymi z wersją MahApps.Metro, której używasz kierowania .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="6a55d-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="6a55d-264">Chociaż możliwe jest, aby zachować oba pliki projektu obok siebie (a nawet może być pożądane, jeśli chcesz zachować budowanie starego projektu dokładnie tak, jak było), to komplikuje proces migracji (dwa projekty będą próbowały użyć tego samego bin i obj foldery) i zwykle nie jest konieczne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="6a55d-265">Jeśli chcesz utworzyć dla obiektów docelowych .NET Core i `<TargetFramework>netcoreapp3.0</TargetFramework>` .NET Framework, możesz `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` zastąpić właściwość w nowym pliku projektu zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="6a55d-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="6a55d-266">W przypadku próbki Bean Trader usuń stary plik projektu (BeanTraderClient.csproj), ponieważ nie jest już potrzebny.</span><span class="sxs-lookup"><span data-stu-id="6a55d-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="6a55d-267">Jeśli wolisz zachować oba pliki projektu, należy je utworzyć do różnych ścieżek wyjściowych i pośrednich danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="6a55d-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="6a55d-268">Rozwiązywanie problemów z kompilacją</span><span class="sxs-lookup"><span data-stu-id="6a55d-268">Fix build issues</span></span>

<span data-ttu-id="6a55d-269">Trzecim etapem procesu przenoszenia jest uzyskanie projektu do kompilacji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="6a55d-270">Niektóre aplikacje będą już tworzyć pomyślnie po przekonwertowaniu pliku projektu na projekt w stylu SDK.</span><span class="sxs-lookup"><span data-stu-id="6a55d-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="6a55d-271">Jeśli tak jest w przypadku aplikacji, gratulacje!</span><span class="sxs-lookup"><span data-stu-id="6a55d-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="6a55d-272">Możesz przejść do kroku 4.</span><span class="sxs-lookup"><span data-stu-id="6a55d-272">You can go on to Step 4.</span></span> <span data-ttu-id="6a55d-273">Inne aplikacje będą potrzebować pewnych aktualizacji, aby je zbudować dla platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="6a55d-274">Jeśli spróbujesz `dotnet build` uruchomić w projekcie próbki Bean Trader teraz, na przykład (lub skompilować go w programie Visual Studio), będzie wiele błędów, ale otrzymasz je szybko naprawić.</span><span class="sxs-lookup"><span data-stu-id="6a55d-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="6a55d-275">Odwołania do systemu.ServiceModel i microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="6a55d-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="6a55d-276">Typowym źródłem błędów brakuje odwołań do interfejsów API, które są dostępne dla platformy .NET Core, ale nie są automatycznie uwzględniane w metapakiecie aplikacji .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="6a55d-277">Aby rozwiązać ten problem, `Microsoft.Windows.Compatibility` należy odwołać się do pakietu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="6a55d-278">Pakiet zgodności zawiera szeroki zestaw interfejsów API, które są powszechne w aplikacjach klasycznych systemu Windows, takich jak klient WCF, usługi katalogowe, rejestr, konfiguracja, interfejsy API list ACL i inne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="6a55d-279">W przypadku próbki Bean Trader większość błędów kompilacji <xref:System.ServiceModel> jest spowodowana brakującymi typami.</span><span class="sxs-lookup"><span data-stu-id="6a55d-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="6a55d-280">Można rozwiązać te rozwiązania, odwołując się do niezbędnych pakietów WCF NuGet.</span><span class="sxs-lookup"><span data-stu-id="6a55d-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="6a55d-281">Interfejsy API klienta WCF należą `Microsoft.Windows.Compatibility` do tych, które są obecne w pakiecie, więc odwoływanie się do pakietu zgodności jest jeszcze lepszym rozwiązaniem (ponieważ rozwiązuje również wszelkie problemy związane z interfejsami API, a także rozwiązania problemów WCF, które udostępnia pakiet zgodności).</span><span class="sxs-lookup"><span data-stu-id="6a55d-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="6a55d-282">Pakiet `Microsoft.Windows.Compatibility` pomaga w większości scenariuszy przenoszenia .NET Core 3.0 WPF i WinForms.</span><span class="sxs-lookup"><span data-stu-id="6a55d-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="6a55d-283">Po dodaniu odwołania `Microsoft.Windows.Compatibility`NuGet do , pozostaje tylko jeden błąd kompilacji!</span><span class="sxs-lookup"><span data-stu-id="6a55d-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="6a55d-284">Czyszczenie nieużywanych plików</span><span class="sxs-lookup"><span data-stu-id="6a55d-284">Cleaning up unused files</span></span>

<span data-ttu-id="6a55d-285">Jeden typ problemu migracji, który pojawia się często odnosi się do plików C# i XAML, które nie zostały wcześniej uwzględnione w kompilacji coraz pobrane przez nowe projekty w stylu SDK, które zawierają *wszystkie* źródła automatycznie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="6a55d-286">Następny błąd kompilacji, który widzisz w przykładzie Bean Trader odnosi się do złej implementacji interfejsu w *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="6a55d-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="6a55d-287">Nazwa pliku jest wskazówką, ale podczas inspekcji okaże się, że ten plik źródłowy jest niepoprawny.</span><span class="sxs-lookup"><span data-stu-id="6a55d-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="6a55d-288">Nie spowodowało to wcześniej problemów, ponieważ nie został uwzględniony w oryginalnym projekcie programu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6a55d-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="6a55d-289">Pliki źródłowe, które były obecne na dysku, ale nie zawarte w starym *csproj są* teraz automatycznie uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="6a55d-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="6a55d-290">W przypadku jednorazowych problemów, takich jak ten, łatwo jest porównać z poprzednim *csprojem,* `<Compile Remove="" />` aby potwierdzić, że plik nie jest potrzebny, a następnie albo go, albo, jeśli plik źródłowy nie jest już potrzebny nigdzie, usuń go.</span><span class="sxs-lookup"><span data-stu-id="6a55d-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="6a55d-291">W takim przypadku można bezpiecznie po prostu usunąć *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="6a55d-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="6a55d-292">Jeśli masz wiele plików źródłowych, które muszą być wykluczone w ten sposób, `<EnableDefaultCompileItems>` można wyłączyć automatyczne dołączanie plików Języka C#, ustawiając właściwość false w pliku projektu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="6a55d-293">Następnie można skopiować `<Compile Include>` elementy ze starego pliku projektu do nowego, aby utworzyć tylko źródła, które mają zostać uwzględnione.</span><span class="sxs-lookup"><span data-stu-id="6a55d-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="6a55d-294">Podobnie `<EnableDefaultPageItems>` może służyć do wyłączania automatycznego dołączania stron `<EnableDefaultItems>` XAML i może kontrolować zarówno za pomocą jednej właściwości.</span><span class="sxs-lookup"><span data-stu-id="6a55d-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="6a55d-295">Krótki bok na kompilatory multi-pass</span><span class="sxs-lookup"><span data-stu-id="6a55d-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="6a55d-296">Po usunięciu pliku naruszającego z próbki Bean Trader, można odtworzyć i otrzyma cztery błędy.</span><span class="sxs-lookup"><span data-stu-id="6a55d-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="6a55d-297">Nie masz go wcześniej?</span><span class="sxs-lookup"><span data-stu-id="6a55d-297">Didn't you have one before?</span></span> <span data-ttu-id="6a55d-298">Dlaczego liczba błędów wzrosła?</span><span class="sxs-lookup"><span data-stu-id="6a55d-298">Why did the number of errors go up?</span></span> <span data-ttu-id="6a55d-299">Kompilator języka C# jest [kompilatorem wieloprzebiegowym](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="6a55d-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="6a55d-300">Oznacza to, że przechodzi przez każdy plik źródłowy dwa razy.</span><span class="sxs-lookup"><span data-stu-id="6a55d-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="6a55d-301">Najpierw kompilator po prostu patrzy na metadanych i deklaracji w każdym pliku źródłowym i identyfikuje wszelkie problemy na poziomie deklaracji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="6a55d-302">Są to błędy, które zostały naprawione.</span><span class="sxs-lookup"><span data-stu-id="6a55d-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="6a55d-303">Następnie przechodzi przez kod ponownie do tworzenia źródła języka C# w IL; to drugi zestaw błędów, które teraz widzisz.</span><span class="sxs-lookup"><span data-stu-id="6a55d-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="6a55d-304">Kompilator Języka C# ma [więcej niż tylko dwa przebiegi](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), ale wynik końcowy jest, że błędy kompilatora dla dużych zmian kodu, takich jak ten mają tendencję do dwóch fal.</span><span class="sxs-lookup"><span data-stu-id="6a55d-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="6a55d-305">Poprawki zależności innych firm (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="6a55d-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="6a55d-306">Inną klasą problemu, który pojawia się w niektórych scenariuszach migracji jest różnice interfejsu API między .NET Framework i .NET Core wersje zależności.</span><span class="sxs-lookup"><span data-stu-id="6a55d-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="6a55d-307">Nawet jeśli pakiet NuGet jest przeznaczony zarówno dla platformy .NET Framework, jak i platformy .NET Standard lub .NET Core, mogą istnieć różne biblioteki do użycia z różnymi elementami docelowymi platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="6a55d-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="6a55d-308">Dzięki temu pakiety do obsługi wielu różnych platform .NET, które mogą wymagać różnych implementacji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="6a55d-309">Oznacza to również, że mogą występować małe różnice interfejsu API w bibliotekach podczas kierowania na różne platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="6a55d-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="6a55d-310">Następny zestaw błędów, które zobaczysz w próbce Bean `Castle.Windsor` Trader są związane z interfejsami API.</span><span class="sxs-lookup"><span data-stu-id="6a55d-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="6a55d-311">Projekt .NET Core Bean Trader używa `Castle.Windsor` tej samej wersji jako projektu docelowego .NET Framework (4.1.1), ale implementacje dla tych dwóch platform są nieco inne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="6a55d-312">W takim przypadku zostaną wyświetlenia następujących problemów, które należy rozwiązać:</span><span class="sxs-lookup"><span data-stu-id="6a55d-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="6a55d-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`nie jest dostępna w programie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="6a55d-314">Istnieje jednak podobny interfejs `Classes.FromAssemblyContaining` API dostępny, więc możemy zastąpić `Classes.FromThisAssembly()` oba `Classes.FromAssemblyContaining(t)`zastosowania `t` wywołaniem , gdzie jest typ nawiązywania połączenia.</span><span class="sxs-lookup"><span data-stu-id="6a55d-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="6a55d-315">Podobnie w *Bootstrapper.cs*. `Castle.Windsor.Installer.FromAssembly` Ta wartość jest niedostępna w programie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="6a55d-316">Zamiast tego wywołanie można `FromAssembly.Containing(typeof(Bootstrapper))`zastąpić .</span><span class="sxs-lookup"><span data-stu-id="6a55d-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="6a55d-317">Aktualizowanie użycia klienta WCF</span><span class="sxs-lookup"><span data-stu-id="6a55d-317">Updating WCF client usage</span></span>

<span data-ttu-id="6a55d-318">Po `Castle.Windsor` naprawieniu różnic ostatni błąd kompilacji pozostałych w projekcie .NET `BeanTraderServiceClient` Core Bean `DuplexClientBase`Trader jest to, że (który pochodzi z ) nie ma `Open` metody.</span><span class="sxs-lookup"><span data-stu-id="6a55d-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="6a55d-319">Nie jest to zaskakujące, ponieważ jest to interfejs API, który został wyróżniony przez analizator przenośności .NET na początku tego procesu migracji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="6a55d-320">Patrząc `BeanTraderServiceClient` na zwraca naszą uwagę na większy problem, choć.</span><span class="sxs-lookup"><span data-stu-id="6a55d-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="6a55d-321">Ten klient WCF został automatycznie wygenerowany przez narzędzie [Svcutil.exe.](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</span><span class="sxs-lookup"><span data-stu-id="6a55d-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="6a55d-322">**Klienci WCF generowane przez Svcutil są przeznaczone do użytku w programie .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="6a55d-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="6a55d-323">Rozwiązania korzystające z generowanych przez svcutil klientów WCF będą musiały ponownie wygenerować klientów zgodnych ze standardem .NET do użytku z programem .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="6a55d-324">Jednym z głównych powodów, dla których starzy klienci nie będą działać, jest to, że zależą one od konfiguracji aplikacji do definiowania powiązań WCF i punktów końcowych.</span><span class="sxs-lookup"><span data-stu-id="6a55d-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="6a55d-325">Ponieważ interfejsy API platformy .NET Standard WCF mogą działać na wielu platformach (gdzie interfejsy API system.configuration nie są dostępne), klienci WCF dla scenariuszy .NET Core i .NET Standard muszą definiować powiązania i punkty końcowe programowo, a nie w konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="6a55d-326">W rzeczywistości wszelkie użycie klienta WCF, które zależy od sekcji `<system.serviceModel>` app.config (czy utworzone za pomocą Svcutil lub ręcznie) będzie musiał zostać zmieniony, aby pracować na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="6a55d-327">Istnieją dwa sposoby automatycznego generowania klientów WCF zgodnych ze standardem platformy .NET:</span><span class="sxs-lookup"><span data-stu-id="6a55d-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="6a55d-328">Narzędzie `dotnet-svcutil` jest narzędziem .NET, które generuje klientów WCF w sposób podobny do tego, jak Svcutil pracował wcześniej.</span><span class="sxs-lookup"><span data-stu-id="6a55d-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="6a55d-329">Visual Studio może generować klientów WCF przy użyciu opcji [Odwołania do usługi sieci Web WCF](../../core/additional-tools/wcf-web-service-reference-guide.md) funkcji Połączone usługi.</span><span class="sxs-lookup"><span data-stu-id="6a55d-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="6a55d-330">Obu podejść działa dobrze.</span><span class="sxs-lookup"><span data-stu-id="6a55d-330">Either approach works well.</span></span> <span data-ttu-id="6a55d-331">Alternatywnie, oczywiście, można napisać kod klienta WCF samodzielnie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="6a55d-332">W tym przykładzie wybrałem funkcję połączonej usługi Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="6a55d-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="6a55d-333">Aby to zrobić, kliknij prawym przyciskiem myszy projekt *BeanTraderClient.Core* w Eksploratorze rozwiązań programu Visual Studio i wybierz pozycję **Dodaj** > **połączoną usługę**.</span><span class="sxs-lookup"><span data-stu-id="6a55d-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="6a55d-334">Następnie wybierz dostawcę referencyjnego usługi sieci Web WCF.</span><span class="sxs-lookup"><span data-stu-id="6a55d-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="6a55d-335">Spowoduje to utworzenie okna dialogowego, w którym można określić adres`localhost:8080` usługi sieci web Backend Bean Trader (jeśli serwer jest uruchomiony lokalnie) i obszar nazw, który wygenerował typy powinny być używane (**BeanTrader.Service**, na przykład).</span><span class="sxs-lookup"><span data-stu-id="6a55d-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Okno dialogowe Połączone usługi sieci Web WCF](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="6a55d-337">Po wybraniu przycisku **Zakończ** do projektu zostanie dodany nowy węzeł Usług połączonych, a w tym węźle zostanie dodany plik Reference.cs zawierający nowy klient .NET Standard WCF umożliwiający dostęp do usługi Bean Trader.</span><span class="sxs-lookup"><span data-stu-id="6a55d-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="6a55d-338">Jeśli spojrzeć `GetEndpointAddress` na `GetBindingForEndpoint` lub metod w tym pliku, zobaczysz, że powiązania i punkty końcowe są teraz generowane programowo (zamiast za pośrednictwem konfiguracji aplikacji).</span><span class="sxs-lookup"><span data-stu-id="6a55d-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="6a55d-339">Funkcja "Dodaj połączone usługi" może również dodać odwołania do niektórych pakietów System.ServiceModel w pliku projektu, które nie są potrzebne, ponieważ wszystkie niezbędne pakiety WCF są dołączone za pośrednictwem witryny Microsoft.Windows.Compatibility.</span><span class="sxs-lookup"><span data-stu-id="6a55d-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="6a55d-340">Sprawdź w csproj, czy dodano dodatkowe `<PackageReference>` elementy System.ServiceModel, a jeśli tak, usuń je.</span><span class="sxs-lookup"><span data-stu-id="6a55d-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="6a55d-341">Nasz projekt ma teraz nowe klasy klientów WCF *(w Reference.cs),* ale nadal ma stare (w BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="6a55d-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="6a55d-342">W tym momencie dostępne są dwie opcje:</span><span class="sxs-lookup"><span data-stu-id="6a55d-342">There are two options at this point:</span></span>

- <span data-ttu-id="6a55d-343">Jeśli chcesz mieć możliwość tworzenia oryginalnego projektu .NET Framework (obok nowego .NET Core-targeted jeden), można użyć `<Compile Remove="BeanTrader.cs" />` elementu w pliku csproj projektu .NET Core, tak aby .NET Framework i .NET Core wersje aplikacji używać różnych klientów WCF.</span><span class="sxs-lookup"><span data-stu-id="6a55d-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="6a55d-344">Ma to tę zaletę, pozostawiając istniejący projekt .NET Framework bez zmian, ale ma wadę, że kod przy użyciu generowanych klientów WCF może być nieco `#if` inna w przypadku .NET Core niż w projekcie .NET Framework, więc prawdopodobnie trzeba będzie użyć dyrektyw warunkowo skompilować niektóre WCF użycia klienta (tworzenie klientów, na przykład) do pracy w jeden sposób po utworzeniu dla .NET Core i inny sposób, gdy zostanie zbudowany dla .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6a55d-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="6a55d-345">Jeśli z drugiej strony niektóre zmiany kodu w istniejącym projekcie .NET Framework jest dopuszczalne, można usunąć *BeanTrader.cs* wszystkich razem.</span><span class="sxs-lookup"><span data-stu-id="6a55d-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="6a55d-346">Ponieważ nowy klient WCF jest zbudowany dla platformy .NET Standard, będzie działać zarówno w scenariuszach .NET Core, jak i .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6a55d-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="6a55d-347">Jeśli budujesz dla platformy .NET Framework oprócz platformy .NET Core (przez wiele kierowania lub przez dwa pliki csproj), możesz użyć tego nowego pliku *Reference.cs* dla obu obiektów docelowych.</span><span class="sxs-lookup"><span data-stu-id="6a55d-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="6a55d-348">Takie podejście ma tę zaletę, że kod nie będzie musiał rozwidlenia do obsługi dwóch różnych klientów WCF; ten sam kod będzie używany wszędzie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="6a55d-349">Wadą jest to, że wiąże się ze zmianą (prawdopodobnie stabilny) .NET Framework projektu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="6a55d-350">W przypadku próbki Bean Trader można wprowadzić małe zmiany w oryginalnym projekcie, jeśli ułatwia to migrację, więc wykonaj następujące kroki, aby uzgodnić użycie klienta WCF:</span><span class="sxs-lookup"><span data-stu-id="6a55d-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="6a55d-351">Dodaj nowy plik Reference.cs do projektu .NET Framework *BeanTraderClient.csproj* przy użyciu menu kontekstowego "Dodaj istniejący element" z eksploratora rozwiązań.</span><span class="sxs-lookup"><span data-stu-id="6a55d-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="6a55d-352">Pamiętaj, aby dodać "jako łącze", aby ten sam plik był używany przez oba projekty (w przeciwieństwie do kopiowania pliku C#).</span><span class="sxs-lookup"><span data-stu-id="6a55d-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="6a55d-353">Jeśli budujesz dla .NET Core i .NET Framework z jednego csproj (przy użyciu multi-targeting), a następnie ten krok nie jest konieczne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="6a55d-354">Usuń *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="6a55d-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="6a55d-355">Nowy klient WCF jest podobny do starego, ale wiele obszarów nazw w wygenerowanym kodzie są różne.</span><span class="sxs-lookup"><span data-stu-id="6a55d-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="6a55d-356">Z tego powodu konieczne jest zaktualizowanie projektu, tak aby typy klientów WCF były używane z BeanTrader.Service (lub niezależnie od nazwy obszaru nazw, które zostały wybrane) zamiast BeanTrader.Model lub bez obszaru nazw.</span><span class="sxs-lookup"><span data-stu-id="6a55d-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="6a55d-357">Budowanie *BeanTraderClient.Core.csproj* pomoże określić, gdzie te zmiany muszą zostać wprowadzone.</span><span class="sxs-lookup"><span data-stu-id="6a55d-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="6a55d-358">Poprawki będą potrzebne zarówno w języku C# i w plikach źródłowych XAML.</span><span class="sxs-lookup"><span data-stu-id="6a55d-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="6a55d-359">Na koniec odkryjesz, że wystąpił błąd w *BeanTraderServiceClientFactory.cs,* ponieważ zmieniły `BeanTraderServiceClient` się dostępne konstruktory dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="6a55d-360">Kiedyś możliwe było dostarczenie argumentu `InstanceContext` (który `CallbackHandler` został `Castle.Windsor` utworzony przy użyciu kontenera IoC).</span><span class="sxs-lookup"><span data-stu-id="6a55d-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="6a55d-361">Nowe konstruktory `CallbackHandler`tworzą nowe s.</span><span class="sxs-lookup"><span data-stu-id="6a55d-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="6a55d-362">Istnieją jednak konstruktory `BeanTraderServiceClient`w 's typ podstawowy, które pasują do tego, co chcesz.</span><span class="sxs-lookup"><span data-stu-id="6a55d-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="6a55d-363">Ponieważ automatyczniegenerowany kod klienta WCF istnieje w klasach częściowych, można łatwo rozszerzyć go.</span><span class="sxs-lookup"><span data-stu-id="6a55d-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="6a55d-364">Aby to zrobić, należy utworzyć nowy plik o nazwie *BeanTraderServiceClient.cs* a następnie utworzyć klasę częściową o tej samej nazwie (przy użyciu obszaru nazw BeanTrader.Service).</span><span class="sxs-lookup"><span data-stu-id="6a55d-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="6a55d-365">Następnie dodaj jeden konstruktor do typu częściowego, jak pokazano w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="6a55d-366">Po tych zmianach, Bean Trader próbki będzie teraz przy użyciu nowego klienta WCF .NET Standard `Open` i można dokonać ostatecznej poprawki zmiany wywołania w *TradingService.cs* zamiast tego. `await OpenAsync`</span><span class="sxs-lookup"><span data-stu-id="6a55d-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="6a55d-367">Z WCF problemy rozwiązane, .NET Core wersja próbki Bean Trader teraz buduje czysto!</span><span class="sxs-lookup"><span data-stu-id="6a55d-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="6a55d-368">Testowanie środowiska uruchomieniowego</span><span class="sxs-lookup"><span data-stu-id="6a55d-368">Runtime testing</span></span>

<span data-ttu-id="6a55d-369">Łatwo zapomnieć, że praca migracji nie jest wykonywana, gdy tylko projekt zostanie zbudowany czysto przeciwko .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a55d-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="6a55d-370">Ważne jest, aby pozostawić czas na przetestowanie złącza aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="6a55d-371">Gdy wszystko zostanie pomyślnie skompilować, upewnij się, że aplikacja działa zgodnie z oczekiwaniami, zwłaszcza jeśli używasz żadnych pakietów kierowania .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6a55d-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="6a55d-372">Spróbujmy uruchomić zanużaną aplikację Bean Trader i zobaczmy, co się stanie.</span><span class="sxs-lookup"><span data-stu-id="6a55d-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="6a55d-373">Aplikacja nie jest daleko przed niepowodzeniem z następującym wyjątkiem.</span><span class="sxs-lookup"><span data-stu-id="6a55d-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="6a55d-374">To oczywiście ma sens.</span><span class="sxs-lookup"><span data-stu-id="6a55d-374">This makes sense, of course.</span></span> <span data-ttu-id="6a55d-375">Należy pamiętać, że WCF nie używa już konfiguracji aplikacji, więc stara sekcja system.serviceModel pliku app.config musi zostać usunięta.</span><span class="sxs-lookup"><span data-stu-id="6a55d-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="6a55d-376">Zaktualizowany klient WCF zawiera wszystkie te same informacje w swoim kodzie, więc sekcja konfiguracji nie jest już potrzebna.</span><span class="sxs-lookup"><span data-stu-id="6a55d-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="6a55d-377">Jeśli chcesz, aby punkt końcowy WCF można było skonfigurować w app.config, można dodać go jako ustawienie aplikacji i zaktualizować kod klienta WCF, aby pobrać punkt końcowy usługi WCF z konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="6a55d-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="6a55d-378">Po usunięciu sekcji system.serviceModel *app.config*aplikacja uruchamia się, ale kończy się niepowodzeniem z innym wyjątkiem, gdy użytkownik się zaloguje.</span><span class="sxs-lookup"><span data-stu-id="6a55d-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="6a55d-379">Nieobsługiwał się `Func<T>.BeginInvoke`interfejs API jest .</span><span class="sxs-lookup"><span data-stu-id="6a55d-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="6a55d-380">Jak wyjaśniono w [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET `BeginInvoke` Core `EndInvoke` nie obsługuje i metody na typy delegatów ze względu na podstawowe zależności komunikacji zdalnej.</span><span class="sxs-lookup"><span data-stu-id="6a55d-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="6a55d-381">Ten problem i jego poprawka są wyjaśnione bardziej szczegółowo w [migracji Delegate.BeginInvoke wywołuje .NET](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) `BeginInvoke` Core `EndInvoke` blogu, ale `Task.Run` istotą jest to, że i wywołania powinny być zastąpione (lub async alternatywy, jeśli to możliwe).</span><span class="sxs-lookup"><span data-stu-id="6a55d-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="6a55d-382">Stosując ogólne rozwiązanie tutaj, `BeginInvoke` połączenie można zastąpić `Invoke` wywołaniem `Task.Run`rozpoczętym przez .</span><span class="sxs-lookup"><span data-stu-id="6a55d-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="6a55d-383">Po usunięciu `BeginInvoke` użycia aplikacja Bean Trader działa pomyślnie na programie .NET Core!</span><span class="sxs-lookup"><span data-stu-id="6a55d-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Bean Trader działa na .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="6a55d-385">Wszystkie aplikacje są różne, więc określone kroki potrzebne do migracji własnych aplikacji do platformy .NET Core będą się różnić.</span><span class="sxs-lookup"><span data-stu-id="6a55d-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="6a55d-386">Ale miejmy nadzieję, że próbki Bean Trader pokazuje ogólny przepływ pracy i rodzaje problemów, które można się spodziewać.</span><span class="sxs-lookup"><span data-stu-id="6a55d-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="6a55d-387">I, pomimo długości tego artykułu, rzeczywiste zmiany potrzebne w próbce Bean Trader, aby działało na .NET Core, były dość ograniczone.</span><span class="sxs-lookup"><span data-stu-id="6a55d-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="6a55d-388">Wiele aplikacji migruje do platformy .NET Core w ten sam sposób; z ograniczoną lub nawet nie wymaga żadnych zmian kodu.</span><span class="sxs-lookup"><span data-stu-id="6a55d-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
