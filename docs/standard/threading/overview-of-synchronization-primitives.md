---
title: Przegląd elementów podstawowych synchronizacji
description: Informacje o elementach podstawowych synchronizacji wątków .NET służących do synchronizowania dostępu do współużytkowanego zasobu lub interakcji wątku kontroli
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 31d5df6521b7c420943a7d3d0efcf6e4bee2d3a2
ms.sourcegitcommit: cdf67135a98a5a51913dacddb58e004a3c867802
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/21/2019
ms.locfileid: "69666281"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="1ba86-103">Przegląd elementów podstawowych synchronizacji</span><span class="sxs-lookup"><span data-stu-id="1ba86-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="1ba86-104">Platforma .NET udostępnia szereg typów, których można użyć do synchronizowania dostępu do zasobu udostępnionego lub współdziałania wątku współrzędnych.</span><span class="sxs-lookup"><span data-stu-id="1ba86-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1ba86-105">Użyj tego samego wystąpienia pierwotnego synchronizacji, aby chronić dostęp do zasobu udostępnionego.</span><span class="sxs-lookup"><span data-stu-id="1ba86-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="1ba86-106">W przypadku użycia innych wystąpień pierwotnych synchronizacji do ochrony tego samego zasobu należy obejść ochronę zapewnioną przez pierwotną synchronizację.</span><span class="sxs-lookup"><span data-stu-id="1ba86-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="1ba86-107">Klasy WaitHandle i typy uproszczonych synchronizacji</span><span class="sxs-lookup"><span data-stu-id="1ba86-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="1ba86-108">Wiele prymitywów synchronizacji platformy .NET pochodzi od <xref:System.Threading.WaitHandle?displayProperty=nameWithType> klasy, która hermetyzuje natywny uchwyt synchronizacji systemu operacyjnego i używa mechanizmu sygnalizowania dla interakcji wątku.</span><span class="sxs-lookup"><span data-stu-id="1ba86-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="1ba86-109">Te klasy obejmują:</span><span class="sxs-lookup"><span data-stu-id="1ba86-109">Those classes include:</span></span>

- <span data-ttu-id="1ba86-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, która przyznaje wyłączny dostęp do zasobu udostępnionego.</span><span class="sxs-lookup"><span data-stu-id="1ba86-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="1ba86-111">Stan obiektu mutex jest sygnalizowane, jeśli żaden z nich nie należy do niego.</span><span class="sxs-lookup"><span data-stu-id="1ba86-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="1ba86-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, które ogranicza liczbę wątków, które mogą uzyskiwać dostęp do zasobów udostępnionych lub puli zasobów współbieżnie.</span><span class="sxs-lookup"><span data-stu-id="1ba86-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="1ba86-113">Stan semafora jest ustawiany do sygnalizowania, gdy jego licznik jest większy od zera i nie jest sygnalizowane, gdy jego licznik ma wartość zero.</span><span class="sxs-lookup"><span data-stu-id="1ba86-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="1ba86-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, która reprezentuje zdarzenie synchronizacji wątku i może być w stanie sygnalizowane lub Niesygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="1ba86-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="1ba86-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, który pochodzi z <xref:System.Threading.EventWaitHandle> i, po zasygnalizowaniu automatycznie resetuje do stanu niesygnalizowanego po zwolnieniu pojedynczego wątku oczekującego.</span><span class="sxs-lookup"><span data-stu-id="1ba86-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="1ba86-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, który pochodzi z <xref:System.Threading.EventWaitHandle> i, po zasygnalizowaniu, pozostaje w stanie zasygnalizowania <xref:System.Threading.EventWaitHandle.Reset%2A> do momentu wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="1ba86-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="1ba86-117">W .NET Framework, ponieważ <xref:System.Threading.WaitHandle> pochodzą z <xref:System.MarshalByRefObject?displayProperty=nameWithType>, te typy mogą służyć do synchronizowania działań wątków między granicami domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="1ba86-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="1ba86-118">W .NET Framework i .NET Core niektóre z tych typów mogą reprezentować nazwane uchwyty synchronizacji systemu, które są widoczne w całym systemie operacyjnym i mogą być używane do synchronizacji między procesami:</span><span class="sxs-lookup"><span data-stu-id="1ba86-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="1ba86-119"><xref:System.Threading.Mutex>(.NET Framework i .NET Core),</span><span class="sxs-lookup"><span data-stu-id="1ba86-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="1ba86-120"><xref:System.Threading.Semaphore>(.NET Framework i .NET Core w systemie Windows)</span><span class="sxs-lookup"><span data-stu-id="1ba86-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="1ba86-121"><xref:System.Threading.EventWaitHandle>(.NET Framework i .NET Core w systemie Windows).</span><span class="sxs-lookup"><span data-stu-id="1ba86-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="1ba86-122">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.WaitHandle> informacje o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="1ba86-123">Typy uproszczonych synchronizacji nie polegają na podstawowych uchwytach systemu operacyjnego i zwykle zapewniają lepszą wydajność.</span><span class="sxs-lookup"><span data-stu-id="1ba86-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="1ba86-124">Nie można ich jednak używać do synchronizacji między procesami.</span><span class="sxs-lookup"><span data-stu-id="1ba86-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="1ba86-125">Użyj tych typów do synchronizacji wątków w ramach jednej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="1ba86-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="1ba86-126">Niektóre z tych typów są alternatywą dla typów pochodnych <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1ba86-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1ba86-127">Na przykład <xref:System.Threading.SemaphoreSlim> jest lekkim <xref:System.Threading.Semaphore>alternatywą dla.</span><span class="sxs-lookup"><span data-stu-id="1ba86-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="1ba86-128">Synchronizacja dostępu do zasobu udostępnionego</span><span class="sxs-lookup"><span data-stu-id="1ba86-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="1ba86-129">Platforma .NET udostępnia wiele elementów pierwotnych synchronizacji w celu kontrolowania dostępu do zasobu udostępnionego w wielu wątkach.</span><span class="sxs-lookup"><span data-stu-id="1ba86-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="1ba86-130">klasa monitora</span><span class="sxs-lookup"><span data-stu-id="1ba86-130">Monitor class</span></span>

<span data-ttu-id="1ba86-131"><xref:System.Threading.Monitor?displayProperty=nameWithType> Klasa przyznaje wzajemnie wyłączny dostęp do zasobu udostępnionego, przejmując lub zwalniając blokadę obiektu, który identyfikuje zasób.</span><span class="sxs-lookup"><span data-stu-id="1ba86-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="1ba86-132">Gdy blokada jest utrzymywana, wątek, który przechowuje blokadę, może ponownie uzyskać i zwolnić blokadę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="1ba86-133">Każdy inny wątek ma zablokowany dostęp do blokady, a <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> Metoda czeka na zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="1ba86-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="1ba86-134"><xref:System.Threading.Monitor.Enter%2A> Metoda uzyskuje wydaną blokadę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="1ba86-135">Można również użyć metody, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> aby określić czas, w którym wątek próbuje uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="1ba86-136">Ponieważ Klasa ma koligację wątku, wątek, który nabył blokadę, musi zwolnić blokadę, <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> wywołując metodę. <xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="1ba86-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="1ba86-137">Interakcje wątków, które uzyskują blokadę na tym samym obiekcie <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, można skoordynować przy użyciu metod, <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>i.</span><span class="sxs-lookup"><span data-stu-id="1ba86-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="1ba86-138">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> informacje o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="1ba86-139">Użyj instrukcji [Lock](../../csharp/language-reference/keywords/lock-statement.md) w C# i instrukcji [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) w Visual Basic, aby synchronizować dostęp do <xref:System.Threading.Monitor> zasobu udostępnionego, zamiast używać klasy bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="1ba86-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="1ba86-140">Te instrukcje są implementowane przy użyciu <xref:System.Threading.Monitor.Enter%2A> metod <xref:System.Threading.Monitor.Exit%2A> `try…finally` i bloku, aby upewnić się, że uzyskana blokada jest zawsze wydawana.</span><span class="sxs-lookup"><span data-stu-id="1ba86-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="1ba86-141">Mutex — Klasa</span><span class="sxs-lookup"><span data-stu-id="1ba86-141">Mutex class</span></span>

<span data-ttu-id="1ba86-142">Klasa <xref:System.Threading.Mutex?displayProperty=nameWithType> , taka jak <xref:System.Threading.Monitor>, udziela wyłącznego dostępu do zasobu udostępnionego.</span><span class="sxs-lookup"><span data-stu-id="1ba86-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="1ba86-143">Użyj jednego z przeciążeń metody [mutex. WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) , aby zażądać własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="1ba86-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="1ba86-144">Podobnie <xref:System.Threading.Monitor>jak <xref:System.Threading.Mutex> , ma koligację wątku, a wątek, który uzyskał element mutex, musi <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> zwolnić go przez wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="1ba86-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="1ba86-145">W przeciwieństwie <xref:System.Threading.Monitor>do <xref:System.Threading.Mutex> , Klasa może być używana do synchronizacji między procesami.</span><span class="sxs-lookup"><span data-stu-id="1ba86-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="1ba86-146">W tym celu należy użyć nazwanego obiektu mutex, który jest widoczny w całym systemie operacyjnym.</span><span class="sxs-lookup"><span data-stu-id="1ba86-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="1ba86-147">Aby utworzyć nazwane wystąpienie muteksa, należy użyć [konstruktora obiektu mutex](<xref:System.Threading.Mutex.%23ctor%2A>) , który określa nazwę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="1ba86-148">Możesz również wywołać metodę, <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> aby otworzyć istniejący obiekt o nazwie systemowy mutex.</span><span class="sxs-lookup"><span data-stu-id="1ba86-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="1ba86-149">Aby uzyskać więcej informacji, zobacz [](mutexes.md) artykuł dotyczący muteksów <xref:System.Threading.Mutex> i informacje o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="1ba86-150">Struktury spinlock, struktura</span><span class="sxs-lookup"><span data-stu-id="1ba86-150">SpinLock structure</span></span>

<span data-ttu-id="1ba86-151">Struktura, na przykład, przyznaje wyłączny dostęp do zasobu udostępnionego na podstawie dostępności blokady. <xref:System.Threading.Monitor> <xref:System.Threading.SpinLock?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="1ba86-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="1ba86-152">Gdy <xref:System.Threading.SpinLock> program próbuje uzyskać blokadę, która jest niedostępna, czeka w pętli, powtarzając sprawdzanie do momentu udostępnienia blokady.</span><span class="sxs-lookup"><span data-stu-id="1ba86-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="1ba86-153">Aby uzyskać więcej informacji na temat korzyści i wad korzystania z blokady pokrętła, zobacz artykuł [struktury spinlock](spinlock.md) i <xref:System.Threading.SpinLock> informacje o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="1ba86-154">Klasa ReaderWriterLockSlim</span><span class="sxs-lookup"><span data-stu-id="1ba86-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="1ba86-155"><xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> Klasa przyznaje wyłączny dostęp do zasobu udostępnionego do zapisu i umożliwia wielu wątkom dostęp do zasobu jednocześnie w celu odczytu.</span><span class="sxs-lookup"><span data-stu-id="1ba86-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="1ba86-156">Za pomocą <xref:System.Threading.ReaderWriterLockSlim> programu można synchronizować dostęp do udostępnionej struktury danych, która obsługuje operacje odczytu z bezpiecznymi wątkami, ale wymaga wyłącznego dostępu do wykonywania operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="1ba86-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="1ba86-157">Gdy wątek żąda wyłącznego dostępu (na przykład przez wywołanie <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> metody), kolejne żądania czytnika i składnika zapisywania są blokowane, dopóki wszyscy istniejący czytelnicy nie zamknie blokady, a moduł zapisujący przeszedł i zakończył blokadę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="1ba86-158">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.ReaderWriterLockSlim> informacje o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="1ba86-159">Semafory i klasy SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="1ba86-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="1ba86-160">Klasy <xref:System.Threading.Semaphore?displayProperty=nameWithType> i<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> ograniczają liczbę wątków, które mogą uzyskiwać dostęp do zasobów udostępnionych lub puli zasobów współbieżnie.</span><span class="sxs-lookup"><span data-stu-id="1ba86-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="1ba86-161">Dodatkowe wątki, które żądają zasobu, oczekują do momentu zwolnienia przez wątek semafora.</span><span class="sxs-lookup"><span data-stu-id="1ba86-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="1ba86-162">Ponieważ semafor nie ma koligacji wątku, wątek może uzyskać semafor, a inny może go zwolnić.</span><span class="sxs-lookup"><span data-stu-id="1ba86-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="1ba86-163"><xref:System.Threading.SemaphoreSlim>jest lekkim alternatywą <xref:System.Threading.Semaphore> dla i może być używany tylko do synchronizacji w ramach pojedynczej granicy procesu.</span><span class="sxs-lookup"><span data-stu-id="1ba86-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="1ba86-164">W systemie Windows można użyć <xref:System.Threading.Semaphore> do synchronizacji między procesami.</span><span class="sxs-lookup"><span data-stu-id="1ba86-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="1ba86-165">W tym celu należy utworzyć <xref:System.Threading.Semaphore> wystąpienie, które reprezentuje nazwany semafor systemowy przy użyciu jednego z konstruktorów [semaforów](<xref:System.Threading.Semaphore.%23ctor%2A>) , który określa nazwę lub <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1ba86-166"><xref:System.Threading.SemaphoreSlim>nie obsługuje nazwanych semaforów systemowych.</span><span class="sxs-lookup"><span data-stu-id="1ba86-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="1ba86-167">Aby uzyskać więcej informacji, zobacz artykuł [Semafor i SemaphoreSlim](semaphore-and-semaphoreslim.md) oraz <xref:System.Threading.Semaphore> dokumentacja interfejsu <xref:System.Threading.SemaphoreSlim> API lub.</span><span class="sxs-lookup"><span data-stu-id="1ba86-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="1ba86-168">Interakcja wątku lub sygnalizowanie</span><span class="sxs-lookup"><span data-stu-id="1ba86-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="1ba86-169">Interakcja wątku (lub sygnalizacja wątku) oznacza, że wątek musi oczekiwać na powiadomienie lub sygnał z co najmniej jednego wątku, aby można było wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="1ba86-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="1ba86-170">Na przykład jeśli wątek a wywołuje <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> metodę wątku b, wątek a jest blokowany do momentu zakończenia wątku b.</span><span class="sxs-lookup"><span data-stu-id="1ba86-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="1ba86-171">Elementy pierwotne synchronizacji opisane w poprzedniej sekcji zapewniają inny mechanizm sygnalizowania: przez zwolnienie blokady wątek powiadamia inny wątek, który może wykonać, przez uzyskanie blokady.</span><span class="sxs-lookup"><span data-stu-id="1ba86-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="1ba86-172">W tej sekcji opisano dodatkowe konstrukcje sygnalizujące zapewniane przez platformę .NET.</span><span class="sxs-lookup"><span data-stu-id="1ba86-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="1ba86-173">Klasy EventWaitHandle, AutoResetEvent, ManualResetEvent i ManualResetEventSlim</span><span class="sxs-lookup"><span data-stu-id="1ba86-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="1ba86-174"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> Klasa reprezentuje zdarzenie synchronizacji wątku.</span><span class="sxs-lookup"><span data-stu-id="1ba86-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="1ba86-175">Zdarzenie synchronizacji może być w stanie "Niesygnalizowane" lub "sygnalizowanie".</span><span class="sxs-lookup"><span data-stu-id="1ba86-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="1ba86-176">Gdy stan zdarzenia jest Niesygnalizowane, wątek, który wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A?> Przeciążenie zdarzenia, jest blokowany do momentu zasygnalizowania zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="1ba86-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="1ba86-177"><xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> Metoda ustawia stan zdarzenia do sygnalizowania.</span><span class="sxs-lookup"><span data-stu-id="1ba86-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="1ba86-178">Zachowanie <xref:System.Threading.EventWaitHandle> , które zostało zasygnalizowane, zależy od jego trybu resetowania:</span><span class="sxs-lookup"><span data-stu-id="1ba86-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="1ba86-179"><xref:System.Threading.EventWaitHandle> Utworzony<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> z flagą resetuje się automatycznie po zwolnieniu pojedynczego oczekującego wątku.</span><span class="sxs-lookup"><span data-stu-id="1ba86-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="1ba86-180">Jest to wartość, która jest taka sama jak w przypadku jednego wątku, za każdym razem, gdy jest ono sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="1ba86-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="1ba86-181">Klasa, która pochodzi od <xref:System.Threading.EventWaitHandle>, reprezentuje takie zachowanie. <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="1ba86-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="1ba86-182">Element <xref:System.Threading.EventWaitHandle> utworzony <xref:System.Threading.EventWaitHandle.Reset%2A> przy użyciu flagi pozostaje zasygnalizowani do momentu wywołania metody. <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="1ba86-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="1ba86-183">Jest on podobny do bramy, która jest zamykana do momentu, gdy zostanie zamknięty, dopóki ktoś jej nie zamknie.</span><span class="sxs-lookup"><span data-stu-id="1ba86-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="1ba86-184">Klasa, która pochodzi od <xref:System.Threading.EventWaitHandle>, reprezentuje takie zachowanie. <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="1ba86-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="1ba86-185">Klasa jest lekkim alternatywą dla <xref:System.Threading.ManualResetEvent>. <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="1ba86-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="1ba86-186">W systemie Windows można użyć <xref:System.Threading.EventWaitHandle> do synchronizacji między procesami.</span><span class="sxs-lookup"><span data-stu-id="1ba86-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="1ba86-187">W tym celu należy utworzyć <xref:System.Threading.EventWaitHandle> wystąpienie, które reprezentuje nazwane zdarzenie synchronizacji systemu przy użyciu jednego z konstruktorów [EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) , który określa nazwę lub <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="1ba86-188">Aby uzyskać więcej informacji, zobacz artykuł [EventWaitHandle](eventwaithandle.md) .</span><span class="sxs-lookup"><span data-stu-id="1ba86-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="1ba86-189">Aby uzyskać odwołanie do interfejsu API <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>zobacz <xref:System.Threading.ManualResetEvent>,, <xref:System.Threading.ManualResetEventSlim>, i.</span><span class="sxs-lookup"><span data-stu-id="1ba86-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="1ba86-190">Klasa CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="1ba86-190">CountdownEvent class</span></span>

<span data-ttu-id="1ba86-191"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> Klasa reprezentuje zdarzenie, które zostaje ustawione, gdy jego licznik ma wartość zero.</span><span class="sxs-lookup"><span data-stu-id="1ba86-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="1ba86-192">Chociaż <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> jest większa od zera, wątek, który wywołuje <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> , jest zablokowany.</span><span class="sxs-lookup"><span data-stu-id="1ba86-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="1ba86-193">Wywołaj <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> , aby zmniejszyć liczbę zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="1ba86-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="1ba86-194">W przeciwieństwie <xref:System.Threading.ManualResetEvent> do <xref:System.Threading.ManualResetEventSlim>lub, którego można użyć do odblokowania wielu wątków z sygnałem z jednego wątku, można użyć <xref:System.Threading.CountdownEvent> , aby odblokować jeden lub więcej wątków z sygnałami z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="1ba86-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="1ba86-195">Aby uzyskać więcej informacji, zobacz artykuł [CountdownEvent](countdownevent.md) i informacje <xref:System.Threading.CountdownEvent> o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="1ba86-196">Klasa barier</span><span class="sxs-lookup"><span data-stu-id="1ba86-196">Barrier class</span></span>

<span data-ttu-id="1ba86-197"><xref:System.Threading.Barrier?displayProperty=nameWithType> Klasa reprezentuje barierę wykonania wątku.</span><span class="sxs-lookup"><span data-stu-id="1ba86-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="1ba86-198">Wątek, który wywołuje <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> metodę sygnalizuje, że osiągnął barierę i czeka, aż inne wątki uczestników osiągnie barierę.</span><span class="sxs-lookup"><span data-stu-id="1ba86-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="1ba86-199">Gdy wszystkie wątki uczestników osiągają barierę, stają się one i są resetowane i mogą być używane ponownie.</span><span class="sxs-lookup"><span data-stu-id="1ba86-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="1ba86-200">Można użyć <xref:System.Threading.Barrier> , gdy co najmniej jeden wątek wymaga wyników innych wątków przed przejściem do kolejnej fazy obliczeń.</span><span class="sxs-lookup"><span data-stu-id="1ba86-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="1ba86-201">Aby uzyskać więcej informacji, zobacz [](barrier.md) artykuł dotyczący bariery i informacje o <xref:System.Threading.Barrier> interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="1ba86-202">Interlocked — Klasa</span><span class="sxs-lookup"><span data-stu-id="1ba86-202">Interlocked class</span></span>

<span data-ttu-id="1ba86-203"><xref:System.Threading.Interlocked?displayProperty=nameWithType> Klasa zawiera metody statyczne, które wykonują proste operacje niepodzielne na zmiennej.</span><span class="sxs-lookup"><span data-stu-id="1ba86-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="1ba86-204">Te operacje niepodzielne obejmują dodawanie, zwiększanie i zmniejszanie, wymianę i wymianę warunkową, które są zależne od porównania, i operacji odczytu z 64-bitową wartością całkowitą.</span><span class="sxs-lookup"><span data-stu-id="1ba86-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="1ba86-205">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Interlocked> informacje o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="1ba86-206">Metody SpinWait, struktura</span><span class="sxs-lookup"><span data-stu-id="1ba86-206">SpinWait structure</span></span>

<span data-ttu-id="1ba86-207"><xref:System.Threading.SpinWait?displayProperty=nameWithType> Struktura zapewnia obsługę czekania na grzbiet.</span><span class="sxs-lookup"><span data-stu-id="1ba86-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="1ba86-208">Można go użyć, gdy wątek musi oczekiwać na zasygnalizowanie zdarzenia lub spełnienia warunku, ale gdy rzeczywisty czas oczekiwania będzie krótszy niż czas oczekiwania wymagany przy użyciu dojścia oczekiwania lub przez inny blok wątku.</span><span class="sxs-lookup"><span data-stu-id="1ba86-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="1ba86-209">Za pomocą <xref:System.Threading.SpinWait>, można określić krótki okres czasu, który ma być obracany podczas oczekiwania, a następnie przekazać (na przykład przez oczekiwanie lub uśpiony) tylko wtedy, gdy warunek nie został spełniony w określonym czasie.</span><span class="sxs-lookup"><span data-stu-id="1ba86-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="1ba86-210">Aby uzyskać więcej informacji, zobacz artykuł [metody SpinWait](spinwait.md) i informacje <xref:System.Threading.SpinWait> o interfejsie API.</span><span class="sxs-lookup"><span data-stu-id="1ba86-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="1ba86-211">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="1ba86-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="1ba86-212">Kolekcje bezpieczne dla wątków</span><span class="sxs-lookup"><span data-stu-id="1ba86-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="1ba86-213">Wątkowość obiektów i funkcji</span><span class="sxs-lookup"><span data-stu-id="1ba86-213">Threading objects and features</span></span>](threading-objects-and-features.md)
