---
title: "Przegląd elementów podstawowych synchronizacji"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
caps.latest.revision: "17"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 58fb520365d0a80a8f8bc46e3fdbd23483fdf07f
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2017
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="b1b33-102">Przegląd elementów podstawowych synchronizacji</span><span class="sxs-lookup"><span data-stu-id="b1b33-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a><span data-ttu-id="b1b33-103">.NET Framework zapewnia szereg elementy podstawowe synchronizacji kontroli interakcji wątków i unikanie wyścigu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="b1b33-104">Te można około podzielone na trzy kategorie: blokowanie sygnalizowania i blokowanego operacji.</span><span class="sxs-lookup"><span data-stu-id="b1b33-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="b1b33-105">Kategorie nie są porządek ani jasno określone: niektóre mechanizmy synchronizacji mają cechy wiele kategorii; zdarzenia, które wersji pojedynczego wątku w czasie funkcjonalnie przypominają blokad; Wersja żadnej blokady można traktować jako sygnał; i operacje blokowane może służyć do skonstruowania blokad.</span><span class="sxs-lookup"><span data-stu-id="b1b33-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="b1b33-106">Kategorie są jednak nadal użyteczne.</span><span class="sxs-lookup"><span data-stu-id="b1b33-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="b1b33-107">Należy pamiętać, że synchronizacja wątku jest współpracy.</span><span class="sxs-lookup"><span data-stu-id="b1b33-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="b1b33-108">Jeśli jeszcze jeden wątek pomija mechanizm synchronizacji i uzyskuje bezpośredni dostęp do chronionych zasobów, mechanizmu synchronizacji nie może być skuteczne.</span><span class="sxs-lookup"><span data-stu-id="b1b33-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="b1b33-109">Ten przegląd zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="b1b33-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="b1b33-110">Blokowanie</span><span class="sxs-lookup"><span data-stu-id="b1b33-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="b1b33-111">Sygnalizowanie</span><span class="sxs-lookup"><span data-stu-id="b1b33-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="b1b33-112">Typy lekkie synchronizacji</span><span class="sxs-lookup"><span data-stu-id="b1b33-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="b1b33-113">Metody SpinWait</span><span class="sxs-lookup"><span data-stu-id="b1b33-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="b1b33-114">Operacje blokowane</span><span class="sxs-lookup"><span data-stu-id="b1b33-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="b1b33-115">Blokowanie</span><span class="sxs-lookup"><span data-stu-id="b1b33-115">Locking</span></span>  
 <span data-ttu-id="b1b33-116">Blokady zapewniają kontrolę nad zasobem jeden wątek w czasie, lub do określonej liczby wątków.</span><span class="sxs-lookup"><span data-stu-id="b1b33-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="b1b33-117">Wątek, który żąda w trybie wyłączności, gdy blokady jest w użyciu bloków do momentu udostępnienia blokady.</span><span class="sxs-lookup"><span data-stu-id="b1b33-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="b1b33-118">Blokady na wyłączność</span><span class="sxs-lookup"><span data-stu-id="b1b33-118">Exclusive Locks</span></span>  
 <span data-ttu-id="b1b33-119">Jest to najprostsza forma blokowania `lock` instrukcji w języku C# i `SyncLock` instrukcji w języku Visual Basic, która kontroluje dostęp do bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="b1b33-120">Takie bloku jest często nazywany sekcja krytyczna.</span><span class="sxs-lookup"><span data-stu-id="b1b33-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="b1b33-121">`lock` Instrukcji jest implementowane za pomocą <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metod i używa `try…catch…finally` bloku, aby upewnić się, jest zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="b1b33-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses `try…catch…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="b1b33-122">Ogólnie rzecz biorąc, przy użyciu `lock` lub `SyncLock` instrukcji, aby chronić małe bloki kodu, nigdy nie obejmujące więcej niż jedną metodę to najlepszy sposób, aby użyć <xref:System.Threading.Monitor> klasy.</span><span class="sxs-lookup"><span data-stu-id="b1b33-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="b1b33-123">Chociaż wydajne, <xref:System.Threading.Monitor> klasy jest podatne na oddzielony blokad i zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="b1b33-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="b1b33-124">Klasa monitora</span><span class="sxs-lookup"><span data-stu-id="b1b33-124">Monitor Class</span></span>  
 <span data-ttu-id="b1b33-125"><xref:System.Threading.Monitor> Klasa udostępnia dodatkowe funkcje, które mogą być używane w połączeniu z `lock` instrukcji:</span><span class="sxs-lookup"><span data-stu-id="b1b33-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="b1b33-126"><xref:System.Threading.Monitor.TryEnter%2A> Metoda pozwala wątku, który jest zablokowana i czeka na zasobów po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="b1b33-127">Zwraca wartość logiczną wskazującą powodzenie lub niepowodzenie, która może służyć do wykrywania i uniknąć potencjalnego zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="b1b33-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="b1b33-128"><xref:System.Threading.Monitor.Wait%2A> Metoda jest wywoływana przez wątek w sekcji krytycznych.</span><span class="sxs-lookup"><span data-stu-id="b1b33-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="b1b33-129">Udostępnia kontrolą zasobu i bloków do czasu ponownie zasób jest dostępny.</span><span class="sxs-lookup"><span data-stu-id="b1b33-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="b1b33-130"><xref:System.Threading.Monitor.Pulse%2A> i <xref:System.Threading.Monitor.PulseAll%2A> metody umożliwiają wątku, który jest około zwalnia blokadę lub <xref:System.Threading.Monitor.Wait%2A> można umieścić w kolejce gotowy, co najmniej jeden wątek, tak aby ich przejęcie blokady.</span><span class="sxs-lookup"><span data-stu-id="b1b33-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="b1b33-131">Limity czasu na <xref:System.Threading.Monitor.Wait%2A> przeciążenia metody Zezwalaj wątków oczekujących wprowadzić do kolejki gotowe.</span><span class="sxs-lookup"><span data-stu-id="b1b33-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="b1b33-132"><xref:System.Threading.Monitor> Klasy zapewniają blokowania w wielu domenach aplikacji, jeśli obiekt używany do blokowania pochodną <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="b1b33-133"><xref:System.Threading.Monitor>ma koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="b1b33-134">Oznacza to, wywołując musi się zakończyć wątku, który wprowadzono monitor <xref:System.Threading.Monitor.Exit%2A> lub <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="b1b33-135"><xref:System.Threading.Monitor> Klasa nie jest tworzone jako wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="b1b33-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="b1b33-136">Metody tej klasy są statyczne (`Shared` w języku Visual Basic) i działa na zablokować tworzone jako wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="b1b33-137">Omówienie koncepcji, zobacz [monitorów](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="b1b33-137">For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="b1b33-138">Mutex — Klasa</span><span class="sxs-lookup"><span data-stu-id="b1b33-138">Mutex Class</span></span>  
 <span data-ttu-id="b1b33-139">Żądanie wątków <xref:System.Threading.Mutex> wywołując przeciążenia jego <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b1b33-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="b1b33-140">Przeciążenia z limitów czasu podano umożliwia wątków czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="b1b33-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="b1b33-141">W odróżnieniu od <xref:System.Threading.Monitor> klasy obiektu mutex może być lokalnego lub globalnego.</span><span class="sxs-lookup"><span data-stu-id="b1b33-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="b1b33-142">Globalne muteksy, skrót o nazwie Muteksy są widoczne w systemie operacyjnym i może służyć do synchronizowania wątków w wielu domenach aplikacji lub procesów.</span><span class="sxs-lookup"><span data-stu-id="b1b33-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="b1b33-143">Lokalne muteksy pochodzi od <xref:System.MarshalByRefObject>i można go używać między granicami domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b1b33-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="b1b33-144">Ponadto <xref:System.Threading.Mutex> pochodną <xref:System.Threading.WaitHandle>, co oznacza, że mogą być używane z mechanizmów sygnalizowania, obsługiwanych przez <xref:System.Threading.WaitHandle>, takich jak <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, i <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b1b33-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="b1b33-145">Podobnie jak <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> ma koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="b1b33-146">W odróżnieniu od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> jest tworzone jako wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="b1b33-147">Omówienie koncepcji, zobacz [muteksy](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="b1b33-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="b1b33-148">Klasa struktury SpinLock</span><span class="sxs-lookup"><span data-stu-id="b1b33-148">SpinLock Class</span></span>  
 <span data-ttu-id="b1b33-149">Począwszy od [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], można użyć <xref:System.Threading.SpinLock> klasy, jeśli obciążenie wymagane przy <xref:System.Threading.Monitor> powoduje spadek wydajności.</span><span class="sxs-lookup"><span data-stu-id="b1b33-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="b1b33-150">Gdy <xref:System.Threading.SpinLock> napotka zablokowana sekcja krytyczna ją po prostu obraca w pętli do momentu udostępnienia blokady.</span><span class="sxs-lookup"><span data-stu-id="b1b33-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="b1b33-151">Jeśli blokady odbywa się bardzo krótki czas, Obracająca może zapewnić lepszą wydajność niż blokowania.</span><span class="sxs-lookup"><span data-stu-id="b1b33-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="b1b33-152">Jednak, jeśli blokada jest używana dla więcej niż kilka dziesiątki cykle, <xref:System.Threading.SpinLock> wykonuje także po prostu jako <xref:System.Threading.Monitor>, ale będzie używać więcej cykli procesora CPU i w związku z tym mogą obniżyć wydajność innych wątków lub procesów.</span><span class="sxs-lookup"><span data-stu-id="b1b33-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="b1b33-153">Inne blokad</span><span class="sxs-lookup"><span data-stu-id="b1b33-153">Other Locks</span></span>  
 <span data-ttu-id="b1b33-154">Blokady nie musi być wyłącznego.</span><span class="sxs-lookup"><span data-stu-id="b1b33-154">Locks need not be exclusive.</span></span> <span data-ttu-id="b1b33-155">Często jest to przydatne umożliwia ograniczoną liczbę wątków współbieżnych dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="b1b33-156">Semaforów i reader_writer_lock są przeznaczone do kontrolowania tego rodzaju dostęp do puli zasobów.</span><span class="sxs-lookup"><span data-stu-id="b1b33-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="b1b33-157">ReaderWriterLock — klasa</span><span class="sxs-lookup"><span data-stu-id="b1b33-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="b1b33-158"><xref:System.Threading.ReaderWriterLockSlim> Klasy adresów przypadek, w którym wątku, który zmienia danych, moduł zapisujący musi mieć wyłącznego dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="b1b33-159">Jeśli moduł zapisujący nie jest aktywne, dowolną liczbę czytników można uzyskać dostępu do zasobu (na przykład wywołując <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metody).</span><span class="sxs-lookup"><span data-stu-id="b1b33-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="b1b33-160">Wątek żądanie wyłącznego dostępu (na przykład wywołując <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metody), czytnika kolejnych żądań bloku dopiero po zamknięciu wszystkich istniejących czytelników blokady i wprowadził twórcę i zakończony blokady.</span><span class="sxs-lookup"><span data-stu-id="b1b33-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="b1b33-161"><xref:System.Threading.ReaderWriterLockSlim>ma koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="b1b33-162">Omówienie koncepcji, zobacz [blokuje moduł zapisujący czytnika](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="b1b33-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="b1b33-163">Semaphore — Klasa</span><span class="sxs-lookup"><span data-stu-id="b1b33-163">Semaphore Class</span></span>  
 <span data-ttu-id="b1b33-164"><xref:System.Threading.Semaphore> Klasa umożliwia określoną liczbę wątków, aby uzyskać dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="b1b33-165">Żądanie bloku zasobu, dopóki wątku zwalnia semafora dodatkowe wątki.</span><span class="sxs-lookup"><span data-stu-id="b1b33-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="b1b33-166">Podobnie jak <xref:System.Threading.Mutex> klasy <xref:System.Threading.Semaphore> pochodną <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="b1b33-167">Chce także <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> może być lokalnego lub globalnego.</span><span class="sxs-lookup"><span data-stu-id="b1b33-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="b1b33-168">Może służyć poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b1b33-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="b1b33-169">W odróżnieniu od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, i <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> nie mają koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="b1b33-170">Oznacza to, że można w scenariuszach, w której jeden wątek uzyskuje semafor i zwolnieniem innego.</span><span class="sxs-lookup"><span data-stu-id="b1b33-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="b1b33-171">Omówienie koncepcji, zobacz [semafor i klasa SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="b1b33-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="b1b33-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>to lekkie semafora synchronizacji w obrębie granicy jednego procesu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="b1b33-173">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="b1b33-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="b1b33-174">Sygnalizowania</span><span class="sxs-lookup"><span data-stu-id="b1b33-174">Signaling</span></span>  
 <span data-ttu-id="b1b33-175">Najprostszym sposobem oczekiwanie na sygnał z innego wątku jest wywołanie <xref:System.Threading.Thread.Join%2A> metodę, która blokuje dopiero po zakończeniu innego wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="b1b33-176"><xref:System.Threading.Thread.Join%2A>ma dwa przeciążenia, zezwalających na zablokowanych wątków przerwanie poza czas oczekiwania, po upływie określonego interwału.</span><span class="sxs-lookup"><span data-stu-id="b1b33-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="b1b33-177">Uchwyty oczekiwania Podaj znacznie większego zestawu oczekiwania i sygnalizowania możliwości.</span><span class="sxs-lookup"><span data-stu-id="b1b33-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="b1b33-178">Dojścia oczekiwania</span><span class="sxs-lookup"><span data-stu-id="b1b33-178">Wait Handles</span></span>  
 <span data-ttu-id="b1b33-179">Uchwyty oczekiwania pochodzi od <xref:System.Threading.WaitHandle> klasy, która z kolei jest pochodną <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="b1b33-180">W związku z tym uchwyty oczekiwania może służyć do synchronizowania działania wątków poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b1b33-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="b1b33-181">Blok wątków na oczekiwania obsługuje przez wywołanie metody wystąpienia <xref:System.Threading.WaitHandle.WaitOne%2A> lub jednej z metod statycznych <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, lub <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="b1b33-182">Jak są wydawane zależy od wywołano metodę oraz od rodzaju uchwyty oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="b1b33-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="b1b33-183">Omówienie koncepcji, zobacz [oczekiwania obsługuje](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="b1b33-183">For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="b1b33-184">Uchwyty oczekiwania na zdarzenie</span><span class="sxs-lookup"><span data-stu-id="b1b33-184">Event Wait Handles</span></span>  
 <span data-ttu-id="b1b33-185">Uchwyty oczekiwania na zdarzenie obejmują <xref:System.Threading.EventWaitHandle> klasy i jej klas pochodnych <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="b1b33-186">Wątki są zwalniane z dojścia oczekiwania podczas obsługi zdarzenia oczekiwania zostanie zasygnalizowane przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody lub za pomocą <xref:System.Threading.WaitHandle.SignalAndWait%2A> — metoda.</span><span class="sxs-lookup"><span data-stu-id="b1b33-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="b1b33-187">Zdarzenie poczekaj uchwytów albo samodzielnie automatycznie resetować, takich jak turnstile, który umożliwia tylko jeden wątek za pośrednictwem za każdym razem zostanie zasygnalizowane lub musi zostać zresetowany ręcznie, takie jak brama jest zamknięty, dopóki sygnalizuje, a następnie otwórz dopóki ktoś zostanie zamknięte.</span><span class="sxs-lookup"><span data-stu-id="b1b33-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="b1b33-188">Jak oznaczać ich nazw, <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent> reprezentują wcześniejsze i drugie, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="b1b33-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="b1b33-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>jest to lekkie zdarzenie synchronizacji w obrębie granicy jednego procesu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="b1b33-190"><xref:System.Threading.EventWaitHandle> Może reprezentować obu typów zdarzeń i może być lokalnego lub globalnego.</span><span class="sxs-lookup"><span data-stu-id="b1b33-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="b1b33-191">Klasy pochodne <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent> zawsze znajdują się lokalnie.</span><span class="sxs-lookup"><span data-stu-id="b1b33-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="b1b33-192">Uchwyty oczekiwania na zdarzenie nie mają koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="b1b33-193">Którymkolwiek wątku mogą sygnalizować dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="b1b33-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="b1b33-194">Omówienie koncepcji, zobacz [EventWaitHandle, autoresetevent —, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="b1b33-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="b1b33-195">Mutex i klasy semafora</span><span class="sxs-lookup"><span data-stu-id="b1b33-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="b1b33-196">Ponieważ <xref:System.Threading.Mutex> i <xref:System.Threading.Semaphore> pochodną klasy <xref:System.Threading.WaitHandle>, mogą być używane z metod statycznych <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="b1b33-197">Na przykład można użyć wątku <xref:System.Threading.WaitHandle.WaitAll%2A> metody poczekać, aż spełnione są wszystkie trzy z następujących czynności: <xref:System.Threading.EventWaitHandle> zostanie zasygnalizowane <xref:System.Threading.Mutex> wydaniu i <xref:System.Threading.Semaphore> zostanie zwolniony.</span><span class="sxs-lookup"><span data-stu-id="b1b33-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="b1b33-198">Analogicznie, można użyć wątku <xref:System.Threading.WaitHandle.WaitAny%2A> metody oczekiwanie na jeden z tych warunków ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="b1b33-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="b1b33-199">Aby uzyskać <xref:System.Threading.Mutex> lub <xref:System.Threading.Semaphore>, jest sygnalizowane oznacza, że został wydany.</span><span class="sxs-lookup"><span data-stu-id="b1b33-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="b1b33-200">Jeśli albo typ jest używany jako pierwszy argument funkcji <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody, jego zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="b1b33-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="b1b33-201">W przypadku liczby <xref:System.Threading.Mutex>, który ma koligacji wątków, jest zwracany wyjątek, jeśli wątek wywołujący nie jest właścicielem obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="b1b33-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="b1b33-202">Jak wspomniano wcześniej, semaforów nie mają koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="b1b33-203">Bariera</span><span class="sxs-lookup"><span data-stu-id="b1b33-203">Barrier</span></span>  
 <span data-ttu-id="b1b33-204"><xref:System.Threading.Barrier> Klasa udostępnia sposób cyklicznie synchronizacji wiele wątków, tak aby wszystkie bloku, w tym samym punktu i poczekaj, aż wszystkie wątki do wykonania.</span><span class="sxs-lookup"><span data-stu-id="b1b33-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="b1b33-205">Bariera jest przydatne, gdy jeden lub więcej wątków wymagają wyniki inny wątek przed kontynuowaniem do następnej fazy algorytmu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="b1b33-206">Aby uzyskać więcej informacji, zobacz [bariery](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="b1b33-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="b1b33-207">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="b1b33-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="b1b33-208">Typy lekkie synchronizacji</span><span class="sxs-lookup"><span data-stu-id="b1b33-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="b1b33-209">Począwszy od [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], można użyć elementy podstawowe synchronizacji, które zapewniają szybkie wydajności dzięki unikaniu kosztowne zależność od jądra systemu Win32 obiekty, takie jak oczekiwania dojść, jeśli to możliwe.</span><span class="sxs-lookup"><span data-stu-id="b1b33-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="b1b33-210">Ogólnie rzecz biorąc gdy krótki czas oczekiwania, i tylko wtedy, gdy nastąpiła oryginalnego typy synchronizacji i będzie niezadowalające należy używać tych typów.</span><span class="sxs-lookup"><span data-stu-id="b1b33-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="b1b33-211">Nie można użyć typu lightweight w scenariuszach, które wymagają komunikacji między procesami.</span><span class="sxs-lookup"><span data-stu-id="b1b33-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="b1b33-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>jest to Uproszczona wersja <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b1b33-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>jest to Uproszczona wersja <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b1b33-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b1b33-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType>reprezentuje zdarzenie, które staje się sygnalizowane po jego liczba jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="b1b33-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="b1b33-215"><xref:System.Threading.Barrier?displayProperty=nameWithType>Umożliwia wiele wątków do synchronizacji ze sobą bez konieczności formantu głównego wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="b1b33-216">Bariery zapobiega każdy wątek kontynuować dopóki wszystkie wątki osiągnięto określony punkt.</span><span class="sxs-lookup"><span data-stu-id="b1b33-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="b1b33-217">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="b1b33-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="b1b33-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="b1b33-218">SpinWait</span></span>  
 <span data-ttu-id="b1b33-219">Począwszy od [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], można użyć <xref:System.Threading.SpinWait?displayProperty=nameWithType> struktury, gdy wątek ma oczekiwać na zdarzenie, aby być sygnalizowane lub warunek jest spełniony, a czas oczekiwania rzeczywiste powinien być krótszy niż czas oczekiwania na wymagane przez przy użyciu dojścia oczekiwania lub otherwi SE blokuje bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="b1b33-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="b1b33-220">Przy użyciu <xref:System.Threading.SpinWait>, można określić krótkiego okresu pokrętła czasu oczekiwania, a następnie użyć instrukcji yield (na przykład przez Oczekiwanie lub uśpiony) tylko wtedy, gdy nie został spełniony warunek w określonym czasie.</span><span class="sxs-lookup"><span data-stu-id="b1b33-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="b1b33-221">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="b1b33-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="b1b33-222">Operacje blokowane</span><span class="sxs-lookup"><span data-stu-id="b1b33-222">Interlocked Operations</span></span>  
 <span data-ttu-id="b1b33-223">Operacje blokowane są prostych operacji niepodzielnych w lokalizacji pamięci z zastosowaniem metod statycznych <xref:System.Threading.Interlocked> klasy.</span><span class="sxs-lookup"><span data-stu-id="b1b33-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="b1b33-224">Tych operacjach niepodzielnych obejmują dodawanie, zwiększyć i zmniejszyć, exchange warunkowego programu exchange, w zależności od porównanie oraz operacje dla 64-bitowych wartości na platformach 32-bitowych odczytu.</span><span class="sxs-lookup"><span data-stu-id="b1b33-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1b33-225">Gwarancja niepodzielność jest ograniczona do poszczególnych działań; gdy jako jednostka odbywa się wiele operacji, należy użyć więcej coarse-grained mechanizmu synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="b1b33-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="b1b33-226">Mimo że żaden z tych operacji nie jest blokady lub sygnałów, ich może służyć do skonstruowania sygnałów i blokad.</span><span class="sxs-lookup"><span data-stu-id="b1b33-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="b1b33-227">Ponieważ są one natywnego systemu operacyjnego, operacje blokowane są bardzo szybkie.</span><span class="sxs-lookup"><span data-stu-id="b1b33-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="b1b33-228">Operacje blokowane umożliwia gwarancje volatile pamięci pisać aplikacje, które wykazują współbieżności nieblokujące zaawansowane.</span><span class="sxs-lookup"><span data-stu-id="b1b33-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="b1b33-229">Jednak wymagają one programowania zaawansowane, niskiego poziomu, więc w większości przypadków proste blokady są lepszym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="b1b33-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="b1b33-230">Omówienie koncepcji, zobacz [operacji Blokowanej](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="b1b33-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b1b33-231">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="b1b33-231">See Also</span></span>  
 [<span data-ttu-id="b1b33-232">Synchronizowanie danych na potrzeby wielowątkowości</span><span class="sxs-lookup"><span data-stu-id="b1b33-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="b1b33-233">Monitory</span><span class="sxs-lookup"><span data-stu-id="b1b33-233">Monitors</span></span>](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="b1b33-234">Muteksy</span><span class="sxs-lookup"><span data-stu-id="b1b33-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="b1b33-235">Semafor i klasa SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="b1b33-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="b1b33-236">EventWaitHandle, autoresetevent —, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="b1b33-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="b1b33-237">Uchwyty oczekiwania</span><span class="sxs-lookup"><span data-stu-id="b1b33-237">Wait Handles</span></span>](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="b1b33-238">Operacje blokowane</span><span class="sxs-lookup"><span data-stu-id="b1b33-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="b1b33-239">Reader_writer_lock</span><span class="sxs-lookup"><span data-stu-id="b1b33-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="b1b33-240">Bariery</span><span class="sxs-lookup"><span data-stu-id="b1b33-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="b1b33-241">Metody SpinWait</span><span class="sxs-lookup"><span data-stu-id="b1b33-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="b1b33-242">Struktury SpinLock</span><span class="sxs-lookup"><span data-stu-id="b1b33-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
