---
title: Przegląd elementów podstawowych synchronizacji
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 5098eea86ee910baad57115419e147df02e41ed9
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/03/2018
ms.locfileid: "43485537"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="34ceb-102">Przegląd elementów podstawowych synchronizacji</span><span class="sxs-lookup"><span data-stu-id="34ceb-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="34ceb-103">.NET Framework oferuje szeroką gamę elementów podstawowych synchronizacji, związanych z kontrolowaniem interakcje wątków i unikanie wyścigu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="34ceb-104">Te można grubsza podzielić na trzy kategorie: operacji blokowania, Sygnalizowanie i blokowane.</span><span class="sxs-lookup"><span data-stu-id="34ceb-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="34ceb-105">Kategorie nie są czyste, ani jasno określone: niektóre mechanizmy synchronizacji mają właściwości wielu kategorii; zdarzenia, które wersji pojedynczego wątku w danym momencie funkcjonalnie przypominają blokad; wydanie żadnej blokady mogą być uważane za sygnał; i operacje blokowane może służyć do konstruowania blokad.</span><span class="sxs-lookup"><span data-stu-id="34ceb-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="34ceb-106">Kategorie są jednak nadal przydatne.</span><span class="sxs-lookup"><span data-stu-id="34ceb-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="34ceb-107">Należy pamiętać, że synchronizacji wątków jest wspólne.</span><span class="sxs-lookup"><span data-stu-id="34ceb-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="34ceb-108">Jeśli jeszcze jeden wątek pomija mechanizm synchronizacji i uzyskuje dostęp do chronionego zasobu bezpośrednio, ten mechanizm synchronizacji nie może być skuteczne.</span><span class="sxs-lookup"><span data-stu-id="34ceb-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="34ceb-109">Ten przegląd zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="34ceb-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="34ceb-110">Blokowanie</span><span class="sxs-lookup"><span data-stu-id="34ceb-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="34ceb-111">Sygnalizowanie</span><span class="sxs-lookup"><span data-stu-id="34ceb-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="34ceb-112">Lekkich typów synchronizacji</span><span class="sxs-lookup"><span data-stu-id="34ceb-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="34ceb-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="34ceb-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="34ceb-114">Operacje blokowane</span><span class="sxs-lookup"><span data-stu-id="34ceb-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="34ceb-115">Blokowanie</span><span class="sxs-lookup"><span data-stu-id="34ceb-115">Locking</span></span>  
 <span data-ttu-id="34ceb-116">Blokady zapewniają kontrolę nad zasobem jednemu wątkowi w czasie lub przez określoną liczbę wątków.</span><span class="sxs-lookup"><span data-stu-id="34ceb-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="34ceb-117">Wątek, który żąda blokady na wyłączność, gdy blokada jest używana bloków, dopóki blokada staje się dostępna.</span><span class="sxs-lookup"><span data-stu-id="34ceb-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="34ceb-118">Blokady na wyłączność</span><span class="sxs-lookup"><span data-stu-id="34ceb-118">Exclusive Locks</span></span>  
 <span data-ttu-id="34ceb-119">To najprostsza forma blokowania `lock` instrukcji w języku C# i `SyncLock` instrukcji w języku Visual Basic, które kontrolują dostęp do bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="34ceb-120">Takie bloku jest często określane jako sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="34ceb-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="34ceb-121">`lock` Instrukcji jest implementowany przy użyciu <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody który używa `try…finally` bloku, aby upewnić się, że blokada jest zwalniana.</span><span class="sxs-lookup"><span data-stu-id="34ceb-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="34ceb-122">Ogólnie rzecz biorąc, przy użyciu `lock` lub `SyncLock` instrukcję, aby chronić małych blokach kodu, nigdy nie obejmujące więcej niż jednej metody to najlepszy sposób, aby użyć <xref:System.Threading.Monitor> klasy.</span><span class="sxs-lookup"><span data-stu-id="34ceb-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="34ceb-123">Mimo że jest to wydajne, <xref:System.Threading.Monitor> klasy jest podatna na oddzielony blokad i zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="34ceb-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="34ceb-124">Klasa monitora</span><span class="sxs-lookup"><span data-stu-id="34ceb-124">Monitor Class</span></span>  
 <span data-ttu-id="34ceb-125"><xref:System.Threading.Monitor> Klasa udostępnia dodatkowe funkcje, które mogą być używane w połączeniu z `lock` instrukcji:</span><span class="sxs-lookup"><span data-stu-id="34ceb-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="34ceb-126"><xref:System.Threading.Monitor.TryEnter%2A> Metoda umożliwia wątku, który jest zablokowany, oczekiwanie na zasób po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="34ceb-127">Zwraca wartość logiczną wskazującą, Powodzenie lub niepowodzenie, która może służyć do wykrywania i uniknięcia potencjalnego zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="34ceb-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="34ceb-128"><xref:System.Threading.Monitor.Wait%2A> Metoda jest wywoływana przez wątek w sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="34ceb-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="34ceb-129">Zrezygnuje kontrolę nad zasobem i blokuje aż zasób stanie się ponownie dostępny.</span><span class="sxs-lookup"><span data-stu-id="34ceb-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="34ceb-130"><xref:System.Threading.Monitor.Pulse%2A> i <xref:System.Threading.Monitor.PulseAll%2A> metody umożliwiają wątek, który jest około zwolnienia blokady lub wywołać <xref:System.Threading.Monitor.Wait%2A> można umieścić w kolejce gotowe, jeden lub więcej wątków, dzięki czemu mogą oni uzyskać blokady.</span><span class="sxs-lookup"><span data-stu-id="34ceb-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="34ceb-131">Przekroczenie limitu czasu w <xref:System.Threading.Monitor.Wait%2A> przeciążenia metody umożliwia wątków oczekujących jako znak ucieczki w kolejce gotowe.</span><span class="sxs-lookup"><span data-stu-id="34ceb-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="34ceb-132"><xref:System.Threading.Monitor> Klasy może zapewnić blokowanie w wielu domenach aplikacji, jeśli obiekt używany do blokowania pochodzi od klasy <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="34ceb-133"><xref:System.Threading.Monitor> ma koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="34ceb-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="34ceb-134">Oznacza to, że wątek, który wprowadzono monitora należy zamknąć, wywołując <xref:System.Threading.Monitor.Exit%2A> lub <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="34ceb-135"><xref:System.Threading.Monitor> Nie jest tworzone jako wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="34ceb-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="34ceb-136">Jego metody są statyczne (`Shared` w języku Visual Basic) oraz umożliwia korzystanie z zablokować tworzone jako wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="34ceb-137">Aby uzyskać omówienie pojęć, zobacz [monitorów](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="34ceb-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="34ceb-138">Mutex — Klasa</span><span class="sxs-lookup"><span data-stu-id="34ceb-138">Mutex Class</span></span>  
 <span data-ttu-id="34ceb-139">Żądanie wątków <xref:System.Threading.Mutex> poprzez wywołanie przeciążenia jego <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="34ceb-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="34ceb-140">Przeciążenia z limitów czasu podano, wątki czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="34ceb-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="34ceb-141">W odróżnieniu od <xref:System.Threading.Monitor> klasy obiektu mutex może być lokalne lub globalne.</span><span class="sxs-lookup"><span data-stu-id="34ceb-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="34ceb-142">Globalne muteksy, nazywane również o nazwie Muteksy są widoczne w całym systemie operacyjnym i może służyć do synchronizacji wątków w wielu domenach aplikacji lub procesów.</span><span class="sxs-lookup"><span data-stu-id="34ceb-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="34ceb-143">Lokalne muteksy pochodzić od <xref:System.MarshalByRefObject>i mogą być używane poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="34ceb-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="34ceb-144">Ponadto <xref:System.Threading.Mutex> pochodzi od klasy <xref:System.Threading.WaitHandle>, co oznacza, że mogą być używane z sygnalizowanie udostępnionych przez nią mechanizmów <xref:System.Threading.WaitHandle>, takich jak <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, i <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="34ceb-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="34ceb-145">Podobnie jak <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> ma koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="34ceb-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="34ceb-146">W odróżnieniu od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> jest tworzone jako wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="34ceb-147">Aby uzyskać omówienie pojęć, zobacz [muteksy](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="34ceb-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="34ceb-148">Klasa strukturze SpinLock</span><span class="sxs-lookup"><span data-stu-id="34ceb-148">SpinLock Class</span></span>  
 <span data-ttu-id="34ceb-149">Począwszy od [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], możesz użyć <xref:System.Threading.SpinLock> klasy, gdy obciążenie wymaga <xref:System.Threading.Monitor> spadku wydajności.</span><span class="sxs-lookup"><span data-stu-id="34ceb-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="34ceb-150">Gdy <xref:System.Threading.SpinLock> napotka zablokowane sekcję krytyczną, ją po prostu uruchamia w pętli do momentu blokady staje się dostępna.</span><span class="sxs-lookup"><span data-stu-id="34ceb-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="34ceb-151">Jeśli blokada jest posiadane bardzo krótki czas, rotowania może zapewnić lepszą wydajność niż blokowania.</span><span class="sxs-lookup"><span data-stu-id="34ceb-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="34ceb-152">Jednak, jeśli blokada jest używana dla więcej niż kilkadziesiąt cykle, <xref:System.Threading.SpinLock> wykonuje równie dobrze jak <xref:System.Threading.Monitor>, ale użyje więcej cykli procesora CPU i dlatego mogą obniżyć wydajność innych wątkach lub procesach.</span><span class="sxs-lookup"><span data-stu-id="34ceb-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="34ceb-153">Inne blokad</span><span class="sxs-lookup"><span data-stu-id="34ceb-153">Other Locks</span></span>  
 <span data-ttu-id="34ceb-154">Blokady nie muszą być wyłączności.</span><span class="sxs-lookup"><span data-stu-id="34ceb-154">Locks need not be exclusive.</span></span> <span data-ttu-id="34ceb-155">Często jest to przydatne zezwolenie na ograniczonej liczbie wątków równoczesny dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="34ceb-156">Semaforów i reader_writer_lock są przeznaczone do sterowania tego rodzaju dostępu do zasobów w puli.</span><span class="sxs-lookup"><span data-stu-id="34ceb-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="34ceb-157">ReaderWriterLock — klasa</span><span class="sxs-lookup"><span data-stu-id="34ceb-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="34ceb-158"><xref:System.Threading.ReaderWriterLockSlim> Klasy adresy przypadek, gdzie wątek, który zmienia dane, moduł zapisujący musi mieć wyłącznego dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="34ceb-159">Jeśli moduł zapisujący nie jest aktywne, dowolną liczbę czytników można uzyskać dostępu do zasobu (na przykład przez wywołanie metody <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metody).</span><span class="sxs-lookup"><span data-stu-id="34ceb-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="34ceb-160">Gdy wątek żąda wyłącznego dostępu (na przykład przez wywołanie metody <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metoda), czytnika kolejnych żądań bloku dopiero po zamknięciu wszystkich istniejących czytelników blokady i Edytor wprowadził i zakończony blokady.</span><span class="sxs-lookup"><span data-stu-id="34ceb-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="34ceb-161"><xref:System.Threading.ReaderWriterLockSlim> ma koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="34ceb-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="34ceb-162">Aby uzyskać omówienie pojęć, zobacz [blokuje moduł zapisujący czytnika](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="34ceb-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="34ceb-163">Semaphore — Klasa</span><span class="sxs-lookup"><span data-stu-id="34ceb-163">Semaphore Class</span></span>  
 <span data-ttu-id="34ceb-164"><xref:System.Threading.Semaphore> Klasy zezwala na określoną liczbę wątków, aby uzyskać dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="34ceb-165">Dodatkowe wątki nie żąda bloku zasobów, aż wątek zwalnia semafora.</span><span class="sxs-lookup"><span data-stu-id="34ceb-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="34ceb-166">Podobnie jak <xref:System.Threading.Mutex> klasy <xref:System.Threading.Semaphore> pochodzi od klasy <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="34ceb-167">Ponadto, takich jak <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> może być lokalne lub globalne.</span><span class="sxs-lookup"><span data-stu-id="34ceb-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="34ceb-168">Może służyć poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="34ceb-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="34ceb-169">W odróżnieniu od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, i <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> nie mają koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="34ceb-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="34ceb-170">Oznacza to, że może służyć w scenariuszach, gdzie jeden wątek uzyskuje semafora i inny do wydania.</span><span class="sxs-lookup"><span data-stu-id="34ceb-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="34ceb-171">Aby uzyskać omówienie pojęć, zobacz [Semaphore i SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="34ceb-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="34ceb-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> jest uproszczone semafora synchronizacji w obrębie granicy pojedynczego procesu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="34ceb-173">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="34ceb-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="34ceb-174">Sygnalizowania</span><span class="sxs-lookup"><span data-stu-id="34ceb-174">Signaling</span></span>  
 <span data-ttu-id="34ceb-175">Najprostszym sposobem na oczekiwanie na sygnał z innego wątku jest wywołanie <xref:System.Threading.Thread.Join%2A> metody, która blokuje ukończenie innego wątku.</span><span class="sxs-lookup"><span data-stu-id="34ceb-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="34ceb-176"><xref:System.Threading.Thread.Join%2A> ma dwa przeciążenia, zezwalających na zablokowany wątek zerwać czas oczekiwania, po upływie określonego interwału.</span><span class="sxs-lookup"><span data-stu-id="34ceb-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="34ceb-177">Uchwyty oczekiwania na zapewnia znacznie większego zestawu oczekiwania i sygnalizowanie możliwości.</span><span class="sxs-lookup"><span data-stu-id="34ceb-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="34ceb-178">Dojścia oczekiwania</span><span class="sxs-lookup"><span data-stu-id="34ceb-178">Wait Handles</span></span>  
 <span data-ttu-id="34ceb-179">Uchwyty oczekiwania na pochodzić od <xref:System.Threading.WaitHandle> klasy, która z kolei pochodzi od klasy <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="34ceb-180">W związku z tym uchwytami oczekiwania może służyć do synchronizowania działania wątków poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="34ceb-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="34ceb-181">Wątki na oczekiwania obsłuży przez wywołanie metody wystąpienia <xref:System.Threading.WaitHandle.WaitOne%2A> lub jednej z metod statycznych <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, lub <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="34ceb-182">Jak są wydawane zależy od wywołano metodę, która oraz od rodzaju dojść oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="34ceb-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="34ceb-183">Aby uzyskać omówienie pojęć, zobacz [oczekiwania obsługuje](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="34ceb-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="34ceb-184">Uchwyty oczekiwania na zdarzenie</span><span class="sxs-lookup"><span data-stu-id="34ceb-184">Event Wait Handles</span></span>  
 <span data-ttu-id="34ceb-185">Uchwyty oczekiwania na zdarzenie obejmują <xref:System.Threading.EventWaitHandle> klasa i jej klasy pochodne <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="34ceb-186">Wątki są zwalniane z dojścia oczekiwania zdarzenie, kiedy dojście oczekiwania zdarzenie jest sygnalizowane przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody lub za pomocą <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="34ceb-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="34ceb-187">Zdarzenie poczekaj uchwyty albo samodzielnie automatycznie resetować, takich jak powierzchniowe (s), która zezwala na tylko jeden wątek za pośrednictwem za każdym razem jest sygnalizowane lub muszą zostać zresetowane ręcznie, takie jak bramy, który jest zamknięty, dopóki sygnalizowane, a następnie otwórz aż ktoś zostanie zamknięty.</span><span class="sxs-lookup"><span data-stu-id="34ceb-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="34ceb-188">Jak sugerują nazwy <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent> reprezentują byłego i ostatniej, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="34ceb-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="34ceb-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> jest to uproszczone zdarzenie synchronizacji w obrębie granicy pojedynczego procesu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="34ceb-190"><xref:System.Threading.EventWaitHandle> Może reprezentować dowolnego typu zdarzenia i może być lokalne lub globalne.</span><span class="sxs-lookup"><span data-stu-id="34ceb-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="34ceb-191">Klasy pochodne <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent> zawsze są lokalne.</span><span class="sxs-lookup"><span data-stu-id="34ceb-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="34ceb-192">Uchwyty oczekiwania na zdarzenie nie mają koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="34ceb-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="34ceb-193">Wątek może sygnał dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="34ceb-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="34ceb-194">Aby uzyskać omówienie pojęć, zobacz [EventWaitHandle, autoresetevent —, CountdownEvent ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="34ceb-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="34ceb-195">Mutex i klasy semafora</span><span class="sxs-lookup"><span data-stu-id="34ceb-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="34ceb-196">Ponieważ <xref:System.Threading.Mutex> i <xref:System.Threading.Semaphore> klasy pochodzić od <xref:System.Threading.WaitHandle>, może służyć za pomocą metod statycznych <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="34ceb-197">Na przykład, można użyć wątku <xref:System.Threading.WaitHandle.WaitAll%2A> metodę, aby poczekać, aż wszystkie trzy następujące czynności są spełnione: <xref:System.Threading.EventWaitHandle> jest sygnalizowane <xref:System.Threading.Mutex> jest zwalniana i <xref:System.Threading.Semaphore> wydaniu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="34ceb-198">Podobnie, można użyć wątku <xref:System.Threading.WaitHandle.WaitAny%2A> metodę, aby poczekać, aż jeden z tych warunków jest spełniony.</span><span class="sxs-lookup"><span data-stu-id="34ceb-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="34ceb-199">Aby uzyskać <xref:System.Threading.Mutex> lub <xref:System.Threading.Semaphore>, jest sygnalizowane oznacza, że zostały udostępnione.</span><span class="sxs-lookup"><span data-stu-id="34ceb-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="34ceb-200">Jeśli albo typ jest używany jako pierwszy argument <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody, jest on zwalniany.</span><span class="sxs-lookup"><span data-stu-id="34ceb-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="34ceb-201">W przypadku właściwości <xref:System.Threading.Mutex>, który ma koligacji wątku, jest zgłaszany wyjątek, jeśli wątek wywołujący nie jest właścicielem obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="34ceb-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="34ceb-202">Jak wspomniano wcześniej, semaforów nie mają koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="34ceb-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="34ceb-203">Bariera</span><span class="sxs-lookup"><span data-stu-id="34ceb-203">Barrier</span></span>  
 <span data-ttu-id="34ceb-204"><xref:System.Threading.Barrier> Klasy zapewnia sposób cyklicznie synchronizacji wielu wątków, tak aby wszystkie bloku, w tym samym punktu i poczekaj, aż wszystkie wątki do ukończenia.</span><span class="sxs-lookup"><span data-stu-id="34ceb-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="34ceb-205">Barierę jest przydatne, gdy jeden lub więcej wątków wymagają wyników z innego wątku przed przejściem do następnej fazy algorytmu.</span><span class="sxs-lookup"><span data-stu-id="34ceb-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="34ceb-206">Aby uzyskać więcej informacji, zobacz [barierę](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="34ceb-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="34ceb-207">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="34ceb-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="34ceb-208">Lekkich typów synchronizacji</span><span class="sxs-lookup"><span data-stu-id="34ceb-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="34ceb-209">Począwszy od [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], możesz użyć podstawowych synchronizacji, które zapewniają wysoką wydajność dzięki unikaniu kosztownych poleganie na Win32 jądra obiektów, takich jak czekać dojść, zawsze, gdy jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="34ceb-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="34ceb-210">Ogólnie rzecz biorąc należy użyć tych typów, gdy krótkie czasy oczekiwania i tylko wtedy, gdy nastąpiła oryginalnego typy synchronizacji i okazały się niezadowalające.</span><span class="sxs-lookup"><span data-stu-id="34ceb-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="34ceb-211">Uproszczone typów nie można używać w scenariuszach wymagających komunikacji między procesami.</span><span class="sxs-lookup"><span data-stu-id="34ceb-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="34ceb-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> to Uproszczona wersja <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="34ceb-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> to Uproszczona wersja <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34ceb-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="34ceb-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> reprezentuje zdarzenie, które staje się sygnalizowane, gdy ich liczba jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="34ceb-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="34ceb-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> Umożliwia wielu wątków zsynchronizować ze sobą bez konieczności kontroli przez wątek główny.</span><span class="sxs-lookup"><span data-stu-id="34ceb-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="34ceb-216">Barierę uniemożliwia każdy wątek kontynuowanie dopóki wszystkie wątki osiągną określony punkt.</span><span class="sxs-lookup"><span data-stu-id="34ceb-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="34ceb-217">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="34ceb-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="34ceb-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="34ceb-218">SpinWait</span></span>  
 <span data-ttu-id="34ceb-219">Począwszy od [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], możesz użyć <xref:System.Threading.SpinWait?displayProperty=nameWithType> struktury, gdy wątek ma czekać na zdarzenie ma być zasygnalizowany lub warunek do spełnienia, ale gdy czas oczekiwania rzeczywiste powinien przypadać wcześniej niż czas oczekiwania, wymagane przez przy użyciu dojścia oczekiwania lub otherwi SE blokuje bieżący wątek.</span><span class="sxs-lookup"><span data-stu-id="34ceb-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="34ceb-220">Za pomocą <xref:System.Threading.SpinWait>, można określić krótki okres pokrętła oczekiwania, a następnie uzyskanie (np. przez oczekiwania lub uśpiony) tylko wtedy, gdy w określonym czasie nie został spełniony warunek.</span><span class="sxs-lookup"><span data-stu-id="34ceb-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="34ceb-221">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="34ceb-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="34ceb-222">Operacje blokowane</span><span class="sxs-lookup"><span data-stu-id="34ceb-222">Interlocked Operations</span></span>  
 <span data-ttu-id="34ceb-223">Operacje blokowane są proste niepodzielne operacje wykonywane na lokalizacji w pamięci przy użyciu metod statycznych <xref:System.Threading.Interlocked> klasy.</span><span class="sxs-lookup"><span data-stu-id="34ceb-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="34ceb-224">Te niepodzielne operacje obejmują dodawanie, Zwiększ oraz dekrementacja, exchange warunkowego programu exchange w zależności od porównania i operacji odczytu dla 64-bitowych wartości na platformach 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="34ceb-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="34ceb-225">Gwarancja niepodzielności jest ograniczona do poszczególnych operacji; gdy wiele operacji, należy wykonać jako zespół, należy użyć bardziej gruboziarnistych mechanizm synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="34ceb-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="34ceb-226">Mimo że żaden z tych operacji nie jest blokady lub sygnały, ich może służyć do konstruowania blokad i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="34ceb-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="34ceb-227">Ponieważ są one natywnych w systemie operacyjnym Windows, operacje blokowane są bardzo szybkie.</span><span class="sxs-lookup"><span data-stu-id="34ceb-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="34ceb-228">Operacje blokowane może służyć gwarancje pamięci volatile do pisania aplikacji, które wykazują współbieżności nieblokującej na poziomie zaawansowanym.</span><span class="sxs-lookup"><span data-stu-id="34ceb-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="34ceb-229">Jednak wymagają one programowanie zaawansowane, niskiego poziomu, dzięki czemu można w większości przypadków proste blokad lepszym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="34ceb-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="34ceb-230">Aby uzyskać omówienie pojęć, zobacz [operacji Blokowanej](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="34ceb-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="34ceb-231">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="34ceb-231">See Also</span></span>  
 [<span data-ttu-id="34ceb-232">Synchronizowanie danych na potrzeby wielowątkowości</span><span class="sxs-lookup"><span data-stu-id="34ceb-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="34ceb-233">Monitory</span><span class="sxs-lookup"><span data-stu-id="34ceb-233">Monitors</span></span>](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="34ceb-234">Muteksy</span><span class="sxs-lookup"><span data-stu-id="34ceb-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="34ceb-235">Semaphore i SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="34ceb-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="34ceb-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="34ceb-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="34ceb-237">Uchwyty oczekiwania</span><span class="sxs-lookup"><span data-stu-id="34ceb-237">Wait Handles</span></span>](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="34ceb-238">Operacje blokowane</span><span class="sxs-lookup"><span data-stu-id="34ceb-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="34ceb-239">reader_writer_lock, klasa</span><span class="sxs-lookup"><span data-stu-id="34ceb-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="34ceb-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="34ceb-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="34ceb-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="34ceb-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="34ceb-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="34ceb-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
