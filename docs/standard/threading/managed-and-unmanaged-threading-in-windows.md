---
title: Zarządzana i niezarządzana wątkowość w systemie Windows
ms.date: 10/24/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- threading [.NET], managed
- threads and fibers [.NET]
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
ms.openlocfilehash: 6ab0cc7c1ec2f7bbc633ac966dd18ab3ea7a395b
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/30/2019
ms.locfileid: "73127541"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="7a7bd-102">Wątki zarządzane i niezarządzane w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="7a7bd-102">Managed and unmanaged threading in Windows</span></span>

<span data-ttu-id="7a7bd-103">Zarządzanie wszystkimi wątkami odbywa się za pomocą klasy <xref:System.Threading.Thread>, w tym wątków utworzonych przez środowisko uruchomieniowe języka wspólnego oraz utworzonych poza środowiskiem uruchomieniowym, które wprowadzają kod w środowisku zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="7a7bd-104">Środowisko uruchomieniowe monitoruje wszystkie wątki w swoim procesie, które kiedykolwiek wykonywały kod w zarządzanym środowisku wykonywania.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="7a7bd-105">Nie śledzi żadnych innych wątków.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-105">It does not track any other threads.</span></span> <span data-ttu-id="7a7bd-106">Wątki mogą wprowadzać zarządzane środowisko wykonawcze za pomocą międzyoperacyjności modelu COM (ponieważ środowisko uruchomieniowe udostępnia obiekty zarządzane jako obiekty COM w niezarządzanym świecie), funkcję COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) i wywołanie platformy.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="7a7bd-107">Gdy niezarządzany wątek przejdzie do środowiska uruchomieniowego za pomocą, na przykład otoki wywoływanej przez COM, system sprawdza, czy Magazyn lokalny wątku tego wątku szuka wewnętrznego obiektu <xref:System.Threading.Thread> zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="7a7bd-108">Jeśli zostanie znaleziony, środowisko uruchomieniowe już wie o tym wątku.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="7a7bd-109">Jeśli jednak nie można znaleźć jednego z nich, środowisko uruchomieniowe utworzy nowy obiekt <xref:System.Threading.Thread> i zainstaluje go w magazynie lokalnym wątku tego wątku.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="7a7bd-110">W obszarze zarządzane wątki <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> jest stabilną identyfikacją zarządzanego wątku.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="7a7bd-111">W przypadku okresu istnienia wątku nie będzie kolizja z wartością z dowolnego innego wątku, niezależnie od domeny aplikacji, z której ma zostać uzyskana ta wartość.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7a7bd-112">**ThreadID** systemu operacyjnego nie ma stałej relacji z zarządzanym wątkiem, ponieważ niezarządzany host może kontrolować relacje między wątki zarządzane i niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="7a7bd-113">W przypadku zaawansowanego hosta można użyć interfejsu API Fiber do zaplanowania wielu zarządzanych wątków względem tego samego wątku systemu operacyjnego lub przenoszenia zarządzanego wątku między różnymi wątkami systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="7a7bd-114">Mapowanie z wątku Win32 na zarządzane wątkowość</span><span class="sxs-lookup"><span data-stu-id="7a7bd-114">Mapping from Win32 threading to managed threading</span></span>

 <span data-ttu-id="7a7bd-115">W poniższej tabeli zawarto Mapowanie elementów wątków Win32 do ich przybliżonych odpowiedników środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="7a7bd-116">Należy zauważyć, że to mapowanie nie reprezentuje identycznych funkcji.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="7a7bd-117">Na przykład **TerminateThread** nie wykonuje klauzul **finally** ani nie zwalnia zasobów i nie można go zablokować.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="7a7bd-118">Jednak <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> wykonuje cały kod wycofania, przejmuje wszystkie zasoby i może zostać odmówiony przy użyciu <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="7a7bd-119">Pamiętaj, aby dokładnie zapoznać się z dokumentacją przed wprowadzeniem założeń dotyczących funkcjonalności.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="7a7bd-120">W systemie Win32</span><span class="sxs-lookup"><span data-stu-id="7a7bd-120">In Win32</span></span>|<span data-ttu-id="7a7bd-121">W środowisku uruchomieniowym języka wspólnego</span><span class="sxs-lookup"><span data-stu-id="7a7bd-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="7a7bd-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-122">**CreateThread**</span></span>|<span data-ttu-id="7a7bd-123">Kombinacja **wątków** i <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="7a7bd-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="7a7bd-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-127">**Chodzenia**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-128">**WaitForSingleObject** w obsłudze wątku</span><span class="sxs-lookup"><span data-stu-id="7a7bd-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-129">**ExitThread —**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-129">**ExitThread**</span></span>|<span data-ttu-id="7a7bd-130">Brak równoważnej</span><span class="sxs-lookup"><span data-stu-id="7a7bd-130">No equivalent</span></span>|  
|<span data-ttu-id="7a7bd-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="7a7bd-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-133">Brak równoważnej</span><span class="sxs-lookup"><span data-stu-id="7a7bd-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-134">Brak równoważnej</span><span class="sxs-lookup"><span data-stu-id="7a7bd-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7a7bd-135">Blisko **CoInitializeEx** (ole32. BIBLIOTECE</span><span class="sxs-lookup"><span data-stu-id="7a7bd-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="7a7bd-136">Zarządzane wątki i apartamentach COM</span><span class="sxs-lookup"><span data-stu-id="7a7bd-136">Managed threads and COM apartments</span></span>

<span data-ttu-id="7a7bd-137">Wątek zarządzany może być oznaczony, aby wskazać, że będzie hostować Apartament [jednowątkowy](/windows/desktop/com/single-threaded-apartments) lub [wielowątkowy](/windows/desktop/com/multithreaded-apartments) .</span><span class="sxs-lookup"><span data-stu-id="7a7bd-137">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="7a7bd-138">(Aby uzyskać więcej informacji na temat architektury wątkowości COM, zobacz [procesy, wątki i apartamentach](/windows/desktop/com/processes--threads--and-apartments)). Metody <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>i <xref:System.Threading.Thread.TrySetApartmentState%2A> klasy <xref:System.Threading.Thread> zwracają i przypisują stan Apartment wątku.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-138">(For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="7a7bd-139">Jeśli stan nie został ustawiony, <xref:System.Threading.Thread.GetApartmentState%2A> zwraca <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7a7bd-140">Właściwość można ustawić tylko wtedy, gdy wątek jest w stanie <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>; można ją ustawić tylko raz dla wątku.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="7a7bd-141">Jeśli stan apartamentu nie zostanie ustawiony przed uruchomieniem wątku, wątek zostanie zainicjowany jako Apartament wielowątkowy (MTA).</span><span class="sxs-lookup"><span data-stu-id="7a7bd-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="7a7bd-142">Wątek finalizatora i wszystkie wątki kontrolowane przez <xref:System.Threading.ThreadPool> są MTA.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="7a7bd-143">W przypadku kodu uruchamiania aplikacji jedynym sposobem sterowania stanem apartamentu jest zastosowanie <xref:System.MTAThreadAttribute> lub <xref:System.STAThreadAttribute> do procedury punktu wejścia.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="7a7bd-144">W .NET Framework 1,0 i 1,1 Właściwość <xref:System.Threading.Thread.ApartmentState%2A> można ustawić jako pierwszy wiersz kodu.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="7a7bd-145">Nie jest to dozwolone w .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="7a7bd-146">Zarządzane obiekty, które są widoczne dla modelu COM, zachowują się tak, jakby były zagregowane organizatora wolnych wątków.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="7a7bd-147">Innymi słowy, mogą one być wywoływane z dowolnego apartamentu COM w sposób wolny od wątków.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="7a7bd-148">Jedynymi obiektami zarządzanymi, które nie wykazują tego zachowania, są te obiekty, które pochodzą od <xref:System.EnterpriseServices.ServicedComponent> lub <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="7a7bd-149">W zarządzanym świecie nie ma żadnego wsparcia dla <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>, chyba że są używane konteksty i wystąpienia zarządzane powiązane z kontekstem.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="7a7bd-150">W przypadku korzystania z usług przedsiębiorstwa, obiekt musi pochodzić od <xref:System.EnterpriseServices.ServicedComponent> (który sam jest pochodną <xref:System.ContextBoundObject>).</span><span class="sxs-lookup"><span data-stu-id="7a7bd-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="7a7bd-151">Gdy kod zarządzany jest wywoływany z obiektami COM, zawsze jest zgodny z regułami COM.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="7a7bd-152">Innymi słowy, wywoływany przez serwery proxy Apartment COM i otoki kontekstu COM+ 1,0, zgodnie z ustawieniami OLE32.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="7a7bd-153">Problemy z blokowaniem</span><span class="sxs-lookup"><span data-stu-id="7a7bd-153">Blocking issues</span></span>  

<span data-ttu-id="7a7bd-154">Jeśli wątek wywołuje niezarządzane wywołanie do systemu operacyjnego, który zablokował wątek w kodzie niezarządzanym, środowisko uruchomieniowe nie przejmie kontroli nad <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> lub <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7a7bd-155">W przypadku <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>środowisko uruchomieniowe oznacza wątek do **przerwania** i przejmuje kontrolę nad nim po ponownym wprowadzeniu kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="7a7bd-156">Zalecane jest używanie blokowania zarządzanego zamiast blokowania niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="7a7bd-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, i tak dalej, odpowiadają na <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> i <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7a7bd-158">Ponadto jeśli wątek znajduje się w Apartment jednowątkowym, wszystkie te zarządzane operacje blokowania będą prawidłowo przekazywać komunikaty w Twojej organizacji, gdy wątek zostanie zablokowany.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  

## <a name="threads-and-fibers"></a><span data-ttu-id="7a7bd-159">Wątki i włókien</span><span class="sxs-lookup"><span data-stu-id="7a7bd-159">Threads and fibers</span></span>

<span data-ttu-id="7a7bd-160">Model wątkowości .NET nie obsługuje [włókien](/windows/desktop/procthread/fibers).</span><span class="sxs-lookup"><span data-stu-id="7a7bd-160">The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers).</span></span> <span data-ttu-id="7a7bd-161">Nie należy wywoływać żadnej funkcji niezarządzanej, która jest implementowana przy użyciu włókien.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-161">You should not call into any unmanaged function that is implemented by using fibers.</span></span> <span data-ttu-id="7a7bd-162">Takie wywołania mogą spowodować awarię środowiska uruchomieniowego .NET.</span><span class="sxs-lookup"><span data-stu-id="7a7bd-162">Such calls may result in a crash of the .NET runtime.</span></span>

## <a name="see-also"></a><span data-ttu-id="7a7bd-163">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="7a7bd-163">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>
- <xref:System.Threading.ThreadState>
- <xref:System.EnterpriseServices.ServicedComponent>
- <xref:System.Threading.Thread>
- <xref:System.Threading.Monitor>
