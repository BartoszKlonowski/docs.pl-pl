---
title: 'Pamięć lokalna wątku: powiązane z wątkiem pola statyczne i gniazda danych'
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a17bc509c8c82bfb30811ec3511207ca2d823e5b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a><span data-ttu-id="f4db3-102">Pamięć lokalna wątku: powiązane z wątkiem pola statyczne i gniazda danych</span><span class="sxs-lookup"><span data-stu-id="f4db3-102">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span>
<span data-ttu-id="f4db3-103">Można użyć zarządzanej lokalny magazyn wątków (TLS) do przechowywania danych, która jest unikatowa w domenie wątku i aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-103">You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.</span></span> <span data-ttu-id="f4db3-104">.NET Framework udostępnia dwa sposoby używania zarządzanych TLS: statyczne miejsc pola i dane powiązane z wątkiem.</span><span class="sxs-lookup"><span data-stu-id="f4db3-104">The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.</span></span>  
  
-   <span data-ttu-id="f4db3-105">Użyj powiązane z wątkiem pola statyczne (powiązane z wątkiem `Shared` pola w języku Visual Basic), jeśli przewidujesz potrzeby użytkowników w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-105">Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time.</span></span> <span data-ttu-id="f4db3-106">Względne wątkom pola statyczne zapewniają najlepszą wydajność.</span><span class="sxs-lookup"><span data-stu-id="f4db3-106">Thread-relative static fields provide the best performance.</span></span> <span data-ttu-id="f4db3-107">One również zapewniają korzyści sprawdzania typu kompilacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-107">They also give you the benefits of compile-time type checking.</span></span>  
  
-   <span data-ttu-id="f4db3-108">Użyj miejsc danych po rzeczywiste wymagania mogą być tylko w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="f4db3-108">Use data slots when your actual requirements might be discovered only at run time.</span></span> <span data-ttu-id="f4db3-109">Gniazda danych są wolniejszy i bardziej nieodpowiednich w użyciu niż powiązane z wątkiem pola statyczne i dane są przechowywane jako typ <xref:System.Object>, więc należy rzutować go do poprawnego typu przed jego użyciem.</span><span class="sxs-lookup"><span data-stu-id="f4db3-109">Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.</span></span>  
  
 <span data-ttu-id="f4db3-110">W języku C++ niezarządzane, użyj `TlsAlloc` może dynamicznie przydzielać miejsc i `__declspec(thread)` Aby zadeklarować, że zmienna powinna zostać przydzielona w magazynie powiązane z wątkiem.</span><span class="sxs-lookup"><span data-stu-id="f4db3-110">In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage.</span></span> <span data-ttu-id="f4db3-111">Względne wątkom statycznego pola i danych umożliwiają zarządzanej wersji tego zachowania.</span><span class="sxs-lookup"><span data-stu-id="f4db3-111">Thread-relative static fields and data slots provide the managed version of this behavior.</span></span>  
  
 <span data-ttu-id="f4db3-112">W [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], można użyć <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> klasy w celu utworzenia obiektów wątków lokalnych, które są inicjowane opóźnieniem, gdy obiekt jest najpierw używane.</span><span class="sxs-lookup"><span data-stu-id="f4db3-112">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed.</span></span> <span data-ttu-id="f4db3-113">Aby uzyskać więcej informacji, zobacz [Incjalizacji](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="f4db3-113">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="uniqueness-of-data-in-managed-tls"></a><span data-ttu-id="f4db3-114">Unikatowość danych w protokole TLS zarządzanych</span><span class="sxs-lookup"><span data-stu-id="f4db3-114">Uniqueness of Data in Managed TLS</span></span>  
 <span data-ttu-id="f4db3-115">Czy można używać powiązane z wątkiem pola statyczne i gniazda danych, danych w protokole TLS zarządzanych jest unikatowy dla kombinacji domeny wątku i aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-115">Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.</span></span>  
  
-   <span data-ttu-id="f4db3-116">W domenie aplikacji jeden wątek nie może modyfikować danych z innego wątku, nawet wtedy, gdy oba wątki używają tego samego pola lub gniazda.</span><span class="sxs-lookup"><span data-stu-id="f4db3-116">Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.</span></span>  
  
-   <span data-ttu-id="f4db3-117">Gdy wątek uzyskuje dostęp do tego samego pola lub miejscem z wielu domen aplikacji, oddzielne wartość jest zachowywana w każdej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-117">When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.</span></span>  
  
 <span data-ttu-id="f4db3-118">Na przykład jeśli wątek ustawia wartość powiązane z wątkiem pola statyczne, przechodzi do innej domeny aplikacji, a następnie pobiera wartość pola, pobraną w drugiej domenie aplikacji różni się od wartości w pierwszej domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-118">For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.</span></span> <span data-ttu-id="f4db3-119">Ustawienie nową wartość dla pola w drugiej domenie aplikacji nie ma wpływu na wartości pola w pierwszej domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-119">Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.</span></span>  
  
 <span data-ttu-id="f4db3-120">Podobnie gdy wątek pobiera tego samego miejsca danych o podanej nazwie w dwóch różnych domenach aplikacji, dane w pierwszej domeny aplikacji pozostaje niezależnie od danych w drugiej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-120">Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.</span></span>  
  
## <a name="thread-relative-static-fields"></a><span data-ttu-id="f4db3-121">Względne wątkom pola statyczne</span><span class="sxs-lookup"><span data-stu-id="f4db3-121">Thread-Relative Static Fields</span></span>  
 <span data-ttu-id="f4db3-122">Jeśli znasz element danych jest zawsze unikatowa dla wątku i kombinacja domena aplikacji, zastosuj <xref:System.ThreadStaticAttribute> atrybutu pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="f4db3-122">If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field.</span></span> <span data-ttu-id="f4db3-123">Użyj pola, jak w przypadku innych pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="f4db3-123">Use the field as you would use any other static field.</span></span> <span data-ttu-id="f4db3-124">Dane w polu jest unikatowy dla każdego wątku, który korzysta z niego.</span><span class="sxs-lookup"><span data-stu-id="f4db3-124">The data in the field is unique to each thread that uses it.</span></span>  
  
 <span data-ttu-id="f4db3-125">Względne wątkom pola statyczne zapewnić lepszą wydajność niż gniazda danych i korzystać z sprawdzanie typów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-125">Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.</span></span>  
  
 <span data-ttu-id="f4db3-126">Należy pamiętać, że każdy kod konstruktora klasy będzie uruchamiany na pierwszym wątkiem w kontekście pierwszy, który uzyskuje dostęp do pola.</span><span class="sxs-lookup"><span data-stu-id="f4db3-126">Be aware that any class constructor code will run on the first thread in the first context that accesses the field.</span></span> <span data-ttu-id="f4db3-127">We wszystkich innych wątków i konteksty w tej samej domenie aplikacji, zostanie zainicjowana pola w celu `null` (`Nothing` w języku Visual Basic) są typy odwołań, czy do ich domyślnych wartości, jeśli są one typów wartości.</span><span class="sxs-lookup"><span data-stu-id="f4db3-127">In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types.</span></span> <span data-ttu-id="f4db3-128">W związku z tym nie należy polegać na konstruktorów klas zainicjować powiązane z wątkiem pola statyczne.</span><span class="sxs-lookup"><span data-stu-id="f4db3-128">Therefore, you should not rely on class constructors to initialize thread-relative static fields.</span></span> <span data-ttu-id="f4db3-129">Zamiast tego uniknąć, inicjowanie powiązane z wątkiem pola statyczne i założono, że są one inicjowane `null` (`Nothing`) lub do wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="f4db3-129">Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.</span></span>  
  
## <a name="data-slots"></a><span data-ttu-id="f4db3-130">Gniazda danych</span><span class="sxs-lookup"><span data-stu-id="f4db3-130">Data Slots</span></span>  
 <span data-ttu-id="f4db3-131">.NET Framework zapewnia miejsc danych dynamicznych, które są unikatowe dla kombinacji wątku i domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f4db3-131">The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.</span></span> <span data-ttu-id="f4db3-132">Istnieją dwa typy danych gniazd: o nazwie gniazda i gniazda bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="f4db3-132">There are two types of data slots: named slots and unnamed slots.</span></span> <span data-ttu-id="f4db3-133">Zarówno są implementowane za pomocą <xref:System.LocalDataStoreSlot> struktury.</span><span class="sxs-lookup"><span data-stu-id="f4db3-133">Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.</span></span>  
  
-   <span data-ttu-id="f4db3-134">Aby utworzyć miejsca danych o podanej nazwie, użyj <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> lub <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="f4db3-134">To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f4db3-135">Aby odwołać się do istniejącego o nazwie miejsca, podać jego nazwę, aby <xref:System.Threading.Thread.GetNamedDataSlot%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f4db3-135">To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.</span></span>  
  
-   <span data-ttu-id="f4db3-136">Aby utworzyć gniazda nienazwane danych, użyj <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="f4db3-136">To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f4db3-137">Zarówno nazwanych i nienazwanych gniazda, użyj <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> i <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> metody do ustawiania i pobierania informacji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="f4db3-137">For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot.</span></span> <span data-ttu-id="f4db3-138">Są to metody statyczne, które zawsze działają w wątku, który jest aktualnie wykonywany ich danych.</span><span class="sxs-lookup"><span data-stu-id="f4db3-138">These are static methods that always act on the data for the thread that is currently executing them.</span></span>  
  
 <span data-ttu-id="f4db3-139">Nazwane miejsc może być wygodne, ponieważ można pobrać gniazda, gdy będziesz potrzebować przez przekazanie jej nazwę, aby <xref:System.Threading.Thread.GetNamedDataSlot%2A> metody, zamiast utrzymywanie odwołania do gniazda bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="f4db3-139">Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot.</span></span> <span data-ttu-id="f4db3-140">Jednak jeśli inny składnik używa tej samej nazwy dla jego magazynu powiązane z wątkiem wątek wykonuje kod z składnika i innych składników, dwa składniki może spowodować uszkodzenie danych siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="f4db3-140">However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.</span></span> <span data-ttu-id="f4db3-141">(W tym scenariuszu założono, że oba te składniki są uruchomione w tej samej domenie aplikacji, a nie są zaprojektowane do udostępniania tych samych danych.)</span><span class="sxs-lookup"><span data-stu-id="f4db3-141">(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f4db3-142">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f4db3-142">See Also</span></span>  
 <xref:System.ContextStaticAttribute>  
 <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>  
 <xref:System.ThreadStaticAttribute>  
 <xref:System.Runtime.Remoting.Messaging.CallContext>  
 [<span data-ttu-id="f4db3-143">Wątkowość</span><span class="sxs-lookup"><span data-stu-id="f4db3-143">Threading</span></span>](../../../docs/standard/threading/index.md)
