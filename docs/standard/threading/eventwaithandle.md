---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 078bda2354a6f0aec2215b0c5da2a021f53ff922
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723787"
---
# <a name="eventwaithandle"></a><span data-ttu-id="5d74b-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="5d74b-102">EventWaitHandle</span></span>

<span data-ttu-id="5d74b-103"><xref:System.Threading.EventWaitHandle>Klasa pozwala wątkom komunikować się ze sobą przez sygnalizowanie i przez oczekiwanie na sygnały.</span><span class="sxs-lookup"><span data-stu-id="5d74b-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="5d74b-104">Dojścia do oczekiwania zdarzeń (nazywane również tylko zdarzeniami) są dojściami oczekiwania, które mogą być sygnalizowane, aby zwolnić jeden lub więcej oczekujących wątków.</span><span class="sxs-lookup"><span data-stu-id="5d74b-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="5d74b-105">Po zasygnalizowaniu dojście do oczekiwania na zdarzenie jest resetowane ręcznie lub automatycznie.</span><span class="sxs-lookup"><span data-stu-id="5d74b-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="5d74b-106"><xref:System.Threading.EventWaitHandle>Klasa może reprezentować albo lokalne dojście oczekiwania na zdarzenie (zdarzenie lokalne) lub nazwanego uchwytu oczekiwania zdarzenia systemu (nazwanego zdarzenia lub zdarzenia systemowe, widoczne dla wszystkich procesów).</span><span class="sxs-lookup"><span data-stu-id="5d74b-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5d74b-107">Uchwyty oczekiwania zdarzeń nie są [zdarzeniami](../events/index.md)platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="5d74b-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="5d74b-108">Brak obiektów delegowanych lub programów obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="5d74b-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="5d74b-109">Słowo "Event" służy do opisywania ich, ponieważ tradycyjnie nazywa się zdarzeniami systemu operacyjnego, a ponieważ czynność sygnalizująca dojście oczekiwania wskazuje na oczekujące wątki, które wystąpiły zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="5d74b-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="5d74b-110">Lokalne i nazwane zdarzenia czekają na używanie obiektów synchronizacji systemu, które są chronione przez <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> otoki, aby upewnić się, że zasoby zostały wydane.</span><span class="sxs-lookup"><span data-stu-id="5d74b-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="5d74b-111">Możesz użyć metody, <xref:System.Threading.WaitHandle.Dispose%2A> Aby zwolnić zasoby natychmiast po zakończeniu korzystania z obiektu.</span><span class="sxs-lookup"><span data-stu-id="5d74b-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="5d74b-112">Uchwyty oczekiwania zdarzeń, które są resetowane automatycznie</span><span class="sxs-lookup"><span data-stu-id="5d74b-112">Event Wait Handles That Reset Automatically</span></span>  

 <span data-ttu-id="5d74b-113">Można utworzyć automatyczne Resetowanie zdarzenia, określając <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> podczas tworzenia <xref:System.Threading.EventWaitHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="5d74b-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="5d74b-114">Ponieważ jego nazwa oznacza, to zdarzenie synchronizacji jest resetowane automatycznie po zasygnalizowaniu, po zwolnieniu pojedynczego wątku oczekującego.</span><span class="sxs-lookup"><span data-stu-id="5d74b-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="5d74b-115">Sygnalizowanie zdarzenia przez wywołanie <xref:System.Threading.EventWaitHandle.Set%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="5d74b-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="5d74b-116">Zdarzenia automatycznego resetowania są zwykle używane do zapewniania wyłącznego dostępu do zasobu dla pojedynczego wątku w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="5d74b-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="5d74b-117">Wątek żąda zasobu przez wywołanie <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="5d74b-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="5d74b-118">Jeśli żaden inny wątek nie utrzymuje dojścia oczekiwania, metoda zwraca `true` i wątek wywołujący ma kontrolę nad zasobem.</span><span class="sxs-lookup"><span data-stu-id="5d74b-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="5d74b-119">Podobnie jak w przypadku wszystkich mechanizmów synchronizacji, przed uzyskaniem dostępu do chronionego zasobu należy upewnić się, że wszystkie ścieżki kodu oczekują na odpowiednie dojście oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="5d74b-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="5d74b-120">Synchronizacja wątków jest spółdzielnią.</span><span class="sxs-lookup"><span data-stu-id="5d74b-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="5d74b-121">Jeśli automatyczne resetowanie zostanie sygnalizowane, gdy żaden wątek nie oczekuje, pozostaje zasygnalizowani do momentu, gdy wątki spróbuje go zaczekać.</span><span class="sxs-lookup"><span data-stu-id="5d74b-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="5d74b-122">Zdarzenie zwalnia wątek i natychmiast resetuje, blokując kolejne wątki.</span><span class="sxs-lookup"><span data-stu-id="5d74b-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="5d74b-123">Uchwyty oczekiwania zdarzeń resetowania ręcznie</span><span class="sxs-lookup"><span data-stu-id="5d74b-123">Event Wait Handles That Reset Manually</span></span>  

 <span data-ttu-id="5d74b-124">Zdarzenie resetowania ręcznego można utworzyć, określając <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> podczas tworzenia <xref:System.Threading.EventWaitHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="5d74b-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="5d74b-125">Ponieważ jego nazwa to oznacza, to zdarzenie synchronizacji należy zresetować ręcznie po zasygnalizowaniu.</span><span class="sxs-lookup"><span data-stu-id="5d74b-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="5d74b-126">Dopóki nie zostanie zresetowane, wywołując jego <xref:System.Threading.EventWaitHandle.Reset%2A> metodę, wątki, które czekają na obsługę zdarzeń, przejdą natychmiast bez blokowania.</span><span class="sxs-lookup"><span data-stu-id="5d74b-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="5d74b-127">Zdarzenie resetowania ręcznego działa jak Brama Corral.</span><span class="sxs-lookup"><span data-stu-id="5d74b-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="5d74b-128">Gdy zdarzenie nie jest sygnalizowane, wątki czekające na blok IT, takie jak konie w Corral.</span><span class="sxs-lookup"><span data-stu-id="5d74b-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="5d74b-129">Po zasygnalizowaniu zdarzenia przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody wszystkie oczekujące wątki można wykonać bezpłatnie.</span><span class="sxs-lookup"><span data-stu-id="5d74b-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="5d74b-130">Zdarzenie pozostanie sygnalizowane do momentu <xref:System.Threading.EventWaitHandle.Reset%2A> wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="5d74b-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="5d74b-131">Powoduje to, że zdarzenie resetowania ręcznego jest idealnym sposobem przechowywania wątków, które muszą czekać, aż jeden wątek zakończy zadanie.</span><span class="sxs-lookup"><span data-stu-id="5d74b-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="5d74b-132">Podobnie jak konie opuszczające Corral, czas potrzebny na zaplanowanie opublikowanych wątków przez system operacyjny i wznowienie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="5d74b-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="5d74b-133">Jeśli <xref:System.Threading.EventWaitHandle.Reset%2A> Metoda jest wywoływana przed wznowieniem wykonywania wszystkich wątków, pozostałe wątki są ponownie blokowane.</span><span class="sxs-lookup"><span data-stu-id="5d74b-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="5d74b-134">Które wątki są wznawiane i które wątki są zależne od losowych czynników, takich jak obciążenie systemu, liczba wątków oczekujących na harmonogram itd.</span><span class="sxs-lookup"><span data-stu-id="5d74b-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="5d74b-135">Nie jest to problem, jeśli wątek, który sygnalizuje zakończenie zdarzenia po zasygnalizowaniu, jest najbardziej typowym wzorcem użycia.</span><span class="sxs-lookup"><span data-stu-id="5d74b-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="5d74b-136">Jeśli chcesz, aby wątek zgłosił zdarzenie, aby rozpocząć nowe zadanie po wznowieniu wszystkich oczekujących wątków, należy je zablokować do momentu wznowienia wszystkich oczekujących wątków.</span><span class="sxs-lookup"><span data-stu-id="5d74b-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="5d74b-137">W przeciwnym razie masz sytuację wyścigu, a zachowanie kodu jest nieprzewidywalne.</span><span class="sxs-lookup"><span data-stu-id="5d74b-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="5d74b-138">Funkcje wspólne dla zdarzeń automatycznych i ręcznych</span><span class="sxs-lookup"><span data-stu-id="5d74b-138">Features Common to Automatic and Manual Events</span></span>  

 <span data-ttu-id="5d74b-139">Zwykle co najmniej jeden wątek jest blokowany na bloku, <xref:System.Threading.EventWaitHandle> dopóki nie jest to blok odblokowany wywoływanie <xref:System.Threading.EventWaitHandle.Set%2A> metody, która zwalnia jeden z oczekujących wątków (w przypadku zdarzeń resetowania automatycznego) lub wszystkich (w przypadku zdarzeń resetowania ręcznego).</span><span class="sxs-lookup"><span data-stu-id="5d74b-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="5d74b-140">Wątek może sygnalizować, <xref:System.Threading.EventWaitHandle> a następnie blokować na nim, jako operację niepodzielną, wywołując metodę statyczną <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5d74b-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5d74b-141"><xref:System.Threading.EventWaitHandle> obiekty mogą być używane z <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> metodami statycznymi i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5d74b-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="5d74b-142">Ponieważ <xref:System.Threading.EventWaitHandle> klasy i <xref:System.Threading.Mutex> pochodzą z <xref:System.Threading.WaitHandle> , można użyć obu klas z tymi metodami.</span><span class="sxs-lookup"><span data-stu-id="5d74b-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="5d74b-143">Nazwane zdarzenia</span><span class="sxs-lookup"><span data-stu-id="5d74b-143">Named Events</span></span>  

 <span data-ttu-id="5d74b-144">System operacyjny Windows zezwala na korzystanie z nazw uchwytów oczekiwania na zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="5d74b-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="5d74b-145">Nazwane zdarzenie to system Wide.</span><span class="sxs-lookup"><span data-stu-id="5d74b-145">A named event is system wide.</span></span> <span data-ttu-id="5d74b-146">Oznacza to, że po utworzeniu nazwanego zdarzenia jest ono widoczne dla wszystkich wątków we wszystkich procesach.</span><span class="sxs-lookup"><span data-stu-id="5d74b-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="5d74b-147">W ten sposób nazwane zdarzenia mogą służyć do synchronizowania działań procesów oraz wątków.</span><span class="sxs-lookup"><span data-stu-id="5d74b-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="5d74b-148">Można utworzyć <xref:System.Threading.EventWaitHandle> obiekt, który reprezentuje nazwane zdarzenie systemowe przy użyciu jednego z konstruktorów, które określają nazwę zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="5d74b-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5d74b-149">Ze względu na to, że nazwane zdarzenia są systemem szerokim, istnieje możliwość, <xref:System.Threading.EventWaitHandle> że wiele obiektów reprezentuje to samo nazwane zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="5d74b-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="5d74b-150">Za każdym razem, gdy wywołujesz konstruktora lub <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodę, <xref:System.Threading.EventWaitHandle> tworzony jest nowy obiekt.</span><span class="sxs-lookup"><span data-stu-id="5d74b-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="5d74b-151">Wielokrotne określenie tej samej nazwy powoduje utworzenie wielu obiektów reprezentujących to samo nazwane zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="5d74b-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="5d74b-152">Należy zachować ostrożność przy użyciu nazwanych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="5d74b-152">Caution is advised in using named events.</span></span> <span data-ttu-id="5d74b-153">Ponieważ są one całego systemu, inny proces, który używa tej samej nazwy, może blokować nieoczekiwane wątki.</span><span class="sxs-lookup"><span data-stu-id="5d74b-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="5d74b-154">Złośliwy kod wykonywany na tym samym komputerze może być używany jako podstawa ataku typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="5d74b-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="5d74b-155">Zabezpieczenia kontroli dostępu umożliwiają ochronę <xref:System.Threading.EventWaitHandle> obiektu, który reprezentuje nazwane zdarzenie, najlepiej przy użyciu konstruktora, który określa <xref:System.Security.AccessControl.EventWaitHandleSecurity> obiekt.</span><span class="sxs-lookup"><span data-stu-id="5d74b-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="5d74b-156">Możesz również zastosować zabezpieczenia kontroli dostępu przy użyciu <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metody, ale powoduje to pozostawienie okna luk w zabezpieczeniach między momentem utworzenia uchwytu oczekiwania na zdarzenie i czasu, gdy jest on chroniony.</span><span class="sxs-lookup"><span data-stu-id="5d74b-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="5d74b-157">Ochrona zdarzeń z zabezpieczeniami kontroli dostępu pomaga zapobiegać złośliwym atakom, ale nie rozwiązuje problemu przypadkowych kolizji nazw.</span><span class="sxs-lookup"><span data-stu-id="5d74b-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5d74b-158">W przeciwieństwie do <xref:System.Threading.EventWaitHandle> klasy, klasy pochodne <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent> mogą reprezentować tylko lokalne dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="5d74b-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="5d74b-159">Nie mogą reprezentować nazwanych zdarzeń systemowych.</span><span class="sxs-lookup"><span data-stu-id="5d74b-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5d74b-160">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="5d74b-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
