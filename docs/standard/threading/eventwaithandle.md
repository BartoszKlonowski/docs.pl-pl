---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 665676a25aea48388ba01b8028af00049b113f2b
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/23/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="29b7a-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="29b7a-102">EventWaitHandle</span></span>
<span data-ttu-id="29b7a-103"><xref:System.Threading.EventWaitHandle> Klasa umożliwia wątków, aby komunikować się ze sobą za pomocą sygnalizacji i Oczekiwanie na sygnały.</span><span class="sxs-lookup"><span data-stu-id="29b7a-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="29b7a-104">Uchwyty oczekiwania na zdarzenie (zwaną także po prostu zdarzeń) to dojścia oczekiwania, które można zasygnalizować aby zwolnić jeden lub więcej wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="29b7a-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="29b7a-105">Po zostanie zasygnalizowane dojścia oczekiwania jest resetowany ręcznie lub automatycznie.</span><span class="sxs-lookup"><span data-stu-id="29b7a-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="29b7a-106"><xref:System.Threading.EventWaitHandle> Klasa może reprezentować albo lokalnego oczekiwania obsługi zdarzenia (zdarzenie lokalnego) lub zdarzenia o nazwie systemu Zaczekaj dojścia (o nazwie zdarzenia lub zdarzeń systemowych są widoczne dla wszystkich procesów).</span><span class="sxs-lookup"><span data-stu-id="29b7a-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="29b7a-107">Uchwyty oczekiwania na zdarzenie nie są zdarzenia, w tym sensie, zazwyczaj przeznaczone przez wyrazie w programie .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="29b7a-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="29b7a-108">Nie ma żadnych obiektów delegowanych ani programów obsługi zdarzeń związane.</span><span class="sxs-lookup"><span data-stu-id="29b7a-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="29b7a-109">Słowa "event" służy do opisywania je, ponieważ one mieć tradycyjnie zostały określone jako zdarzenia systemu operacyjnego, a czynność sygnalizowania dojście oczekiwania wskazuje wątków oczekujących wystąpienia zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="29b7a-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="29b7a-110">Zarówno uchwyty oczekiwania na zdarzenie nazwane i lokalnych użyć obiektów synchronizacji systemu, które są chronione przez <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> otoki, aby upewnić się, że zasoby są wydawane.</span><span class="sxs-lookup"><span data-stu-id="29b7a-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="29b7a-111">Można użyć <xref:System.Threading.WaitHandle.Dispose%2A> metody, aby zwolnić zasoby natychmiast po zakończeniu przy użyciu obiektu.</span><span class="sxs-lookup"><span data-stu-id="29b7a-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="29b7a-112">Uchwyty oczekiwania na zdarzenie, które automatycznie resetować</span><span class="sxs-lookup"><span data-stu-id="29b7a-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="29b7a-113">Utwórz zdarzenie automatycznego resetowania, określając <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> podczas tworzenia <xref:System.Threading.EventWaitHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="29b7a-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="29b7a-114">Jak jego nazwa wskazuje, to zdarzenie synchronizacji automatycznie po resetuje sygnalizowane po zwalniania pojedynczego wątku oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="29b7a-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="29b7a-115">Sygnału zdarzenia przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="29b7a-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="29b7a-116">Automatyczne resetowanie zdarzenia zwykle są używane do zapewnienia wyłącznego dostępu do zasobu dla pojedynczego wątku w czasie.</span><span class="sxs-lookup"><span data-stu-id="29b7a-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="29b7a-117">Wątek żąda zasobu, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="29b7a-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="29b7a-118">Jeśli nie inne wątku wstrzymał dojście oczekiwania, metoda zwraca `true` i wątku wywołującym ma kontrolę zasobu.</span><span class="sxs-lookup"><span data-stu-id="29b7a-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="29b7a-119">Podobnie jak w przypadku wszystkich mechanizmów synchronizacji, należy się upewnić, czy wszystkie ścieżki kodu oczekiwanie na dojście odpowiednie oczekiwania przed uzyskaniem dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="29b7a-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="29b7a-120">Synchronizacja wątku jest współpracy.</span><span class="sxs-lookup"><span data-stu-id="29b7a-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="29b7a-121">W przypadku automatycznego resetowania zdarzenie jest sygnalizowane, gdy nie ma wątków oczekujących, pozostaje sygnałowego dopóki wątku próbuje czekać na nim.</span><span class="sxs-lookup"><span data-stu-id="29b7a-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="29b7a-122">Zdarzenie zwalnia wątku i resetuje natychmiast, blokowanie kolejnych wątków.</span><span class="sxs-lookup"><span data-stu-id="29b7a-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="29b7a-123">Uchwyty oczekiwania na zdarzenie, które ręcznie zresetować</span><span class="sxs-lookup"><span data-stu-id="29b7a-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="29b7a-124">Utwórz zdarzenie z resetowaniem ręcznym, określając <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> podczas tworzenia <xref:System.Threading.EventWaitHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="29b7a-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="29b7a-125">Jak jego nazwa wskazuje, to zdarzenie synchronizacji można ręcznie zresetować po ma zostać sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="29b7a-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="29b7a-126">Dopóki zostanie zresetowane, wywołując jego <xref:System.Threading.EventWaitHandle.Reset%2A> metody wątków oczekiwania na dojście zdarzenia bezzwłocznie ją kontynuować bez blokowania.</span><span class="sxs-lookup"><span data-stu-id="29b7a-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="29b7a-127">Zdarzenie działania takie jak brama corral resetowania ręcznego.</span><span class="sxs-lookup"><span data-stu-id="29b7a-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="29b7a-128">Gdy zdarzenie nie zostanie zasygnalizowane, wątków, które Zaczekaj na jej zablokować, takie jak konie w corral.</span><span class="sxs-lookup"><span data-stu-id="29b7a-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="29b7a-129">Gdy zdarzenie jest sygnalizowane, wywołując jego <xref:System.Threading.EventWaitHandle.Set%2A> metody, wszystkich wątków oczekujących są wolne kontynuować.</span><span class="sxs-lookup"><span data-stu-id="29b7a-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="29b7a-130">Zdarzenie pozostaje sygnałowego aż do jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="29b7a-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="29b7a-131">Dzięki temu zdarzeń resetowania ręcznego idealny do przechowywania zapasowej wątków, które trzeba czekać na zakończenie zadania, jeden wątek.</span><span class="sxs-lookup"><span data-stu-id="29b7a-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="29b7a-132">Jak konie, pozostawiając corral czas wydanych wątków do zaplanowania przez system operacyjny i wznowić wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="29b7a-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="29b7a-133">Jeśli <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana przed wszystkie wątki zostały wznowił pracę, pozostałe wątki ponownie zablokować.</span><span class="sxs-lookup"><span data-stu-id="29b7a-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="29b7a-134">Które wznawianie wątków i który blok wątków zależy od losowe czynniki, takie jak obciążenia w systemie, to liczba wątków oczekiwania dla harmonogramu i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="29b7a-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="29b7a-135">Nie jest to problem, jeśli wątek, który sygnalizuje zdarzenie kończy się po zasygnalizowaniu, który jest najbardziej typowych wzorca użycia.</span><span class="sxs-lookup"><span data-stu-id="29b7a-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="29b7a-136">Jeśli chcesz wątku, który sygnalizuje zdarzeń, aby rozpocząć nowego zadania po wszystkich oczekujących, który podjęto wątków musi zablokować dopóki podjęto wszystkich wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="29b7a-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="29b7a-137">W przeciwnym razie ma wyścigu i jest nieprzewidywalne zachowanie kodu.</span><span class="sxs-lookup"><span data-stu-id="29b7a-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="29b7a-138">Wspólne funkcje automatycznej i ręcznej zdarzenia</span><span class="sxs-lookup"><span data-stu-id="29b7a-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="29b7a-139">Zazwyczaj zablokować co najmniej jeden wątek na <xref:System.Threading.EventWaitHandle> do momentu wywołania wątku odblokowany <xref:System.Threading.EventWaitHandle.Set%2A> metodę, która udostępnia jeden z wątków oczekujących (w przypadku zdarzeń automatycznego resetowania) lub wszystkie z nich (w przypadku ręcznego resetowania zdarzeń).</span><span class="sxs-lookup"><span data-stu-id="29b7a-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="29b7a-140">Wątek może sygnalizować <xref:System.Threading.EventWaitHandle> a następnie zablokować, jako operacją niepodzielną, wywołując statycznych <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="29b7a-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="29b7a-141"><xref:System.Threading.EventWaitHandle>obiekty mogą być używane z statycznych <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="29b7a-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="29b7a-142">Ponieważ <xref:System.Threading.EventWaitHandle> i <xref:System.Threading.Mutex> pochodną klasy zarówno <xref:System.Threading.WaitHandle>, obie klasy można używać z tych metod.</span><span class="sxs-lookup"><span data-stu-id="29b7a-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="29b7a-143">Zdarzenia o nazwie</span><span class="sxs-lookup"><span data-stu-id="29b7a-143">Named Events</span></span>  
 <span data-ttu-id="29b7a-144">System operacyjny Windows umożliwia uchwyty oczekiwania na zdarzenie mieć nazwy.</span><span class="sxs-lookup"><span data-stu-id="29b7a-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="29b7a-145">Nazwane zdarzenie jest całym systemie.</span><span class="sxs-lookup"><span data-stu-id="29b7a-145">A named event is system wide.</span></span> <span data-ttu-id="29b7a-146">Oznacza to, że po utworzeniu zdarzenia o nazwie jest widoczne dla wszystkich wątków w wszystkich procesów.</span><span class="sxs-lookup"><span data-stu-id="29b7a-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="29b7a-147">W związku z tym nazwanego zdarzenia mogą służyć do synchronizowania działania procesów, a także wątków.</span><span class="sxs-lookup"><span data-stu-id="29b7a-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="29b7a-148">Można utworzyć <xref:System.Threading.EventWaitHandle> obiekt, który reprezentuje zdarzenia o nazwie systemu za pomocą jednego z konstruktorów, które określa nazwę zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="29b7a-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="29b7a-149">Ponieważ nazwanego zdarzenia to w całym systemie istnieje możliwość wielu <xref:System.Threading.EventWaitHandle> zdarzenia o nazwie obiekty reprezentujące takie same.</span><span class="sxs-lookup"><span data-stu-id="29b7a-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="29b7a-150">Zawsze należy wywołać konstruktora, lub <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metoda, nowy <xref:System.Threading.EventWaitHandle> tworzony jest obiekt.</span><span class="sxs-lookup"><span data-stu-id="29b7a-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="29b7a-151">Określenie tej samej nazwie wielokrotnie tworzy wiele obiektów, które reprezentują tego samego zdarzenia nazwanego.</span><span class="sxs-lookup"><span data-stu-id="29b7a-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="29b7a-152">Zalecane jest ostrożność przy użyciu o nazwie zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="29b7a-152">Caution is advised in using named events.</span></span> <span data-ttu-id="29b7a-153">Ponieważ są one całym systemie, inny proces, który używa tej samej nazwie może zablokować użytkownika wątków nieoczekiwanie.</span><span class="sxs-lookup"><span data-stu-id="29b7a-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="29b7a-154">Złośliwy kod na tym samym komputerze może wykorzystać tę podstawę ataku typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="29b7a-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="29b7a-155">Umożliwia kontrolę dostępu, aby chronić <xref:System.Threading.EventWaitHandle> obiekt, który reprezentuje nazwanego zdarzenia, najlepiej przy użyciu konstruktora, który określa <xref:System.Security.AccessControl.EventWaitHandleSecurity> obiektu.</span><span class="sxs-lookup"><span data-stu-id="29b7a-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="29b7a-156">Można także zastosować dla zabezpieczeń kontroli dostępu przy użyciu opcji <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metody, ale pozostawia okno luki w zabezpieczeniach między czas, zostanie utworzony uchwyt oczekiwania zdarzeń i jest on chroniony.</span><span class="sxs-lookup"><span data-stu-id="29b7a-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="29b7a-157">Ochrona zdarzeń przy użyciu kontroli dostępu zabezpieczeń pomaga zapobiegać złośliwe ataki, ale nie rozwiązuje problemu konflikty nazw przypadkowe.</span><span class="sxs-lookup"><span data-stu-id="29b7a-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="29b7a-158">W odróżnieniu od <xref:System.Threading.EventWaitHandle> klasy, klasy pochodne <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent> można tylko lokalne reprezentują uchwyty oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="29b7a-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="29b7a-159">Nie można reprezentują zdarzenia o nazwie system.</span><span class="sxs-lookup"><span data-stu-id="29b7a-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="29b7a-160">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="29b7a-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="29b7a-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="29b7a-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
