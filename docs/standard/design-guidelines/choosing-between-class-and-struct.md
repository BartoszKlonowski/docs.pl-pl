---
title: Wybieranie między klasą i strukturą
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
ms.openlocfilehash: 76042bef1475f2fdf14e309390dcba6654ccfaa9
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/24/2020
ms.locfileid: "76741748"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="a6ac3-102">Wybieranie między klasą i strukturą</span><span class="sxs-lookup"><span data-stu-id="a6ac3-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="a6ac3-103">Jedną z podstawowych decyzji projektowych każdej twarzy projektanta platformy jest to, czy projekt typu ma być klasą (typem referencyjnym) czy jako struktura (typ wartości).</span><span class="sxs-lookup"><span data-stu-id="a6ac3-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="a6ac3-104">Dobre zrozumienie różnic w zachowaniu typów referencyjnych i typów wartości jest decydujące w przypadku dokonania tego wyboru.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>

 <span data-ttu-id="a6ac3-105">Pierwszą różnicą między typami referencyjnymi i typami wartości, które należy wziąć pod uwagę, jest to, że typy odwołań są przydzielane na stercie i elementy bezużyteczne, a typy wartości są przydzielane na stosie lub w wierszu zawierającym typy i cofnięte przydział, gdy stos powoduje cofnięcie przydziału typu "niewietrzne" lub "typ zawierający".</span><span class="sxs-lookup"><span data-stu-id="a6ac3-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="a6ac3-106">W związku z tym alokacje i cofanie alokacji typów wartości są ogólnie tańsze niż alokacje i cofanie alokacji typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>

 <span data-ttu-id="a6ac3-107">Następnie tablice typów referencyjnych są przydzielane poza wierszem, co oznacza, że elementy tablicy są tylko odwołaniami do wystąpień typu referencyjnego znajdującego się na stercie.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="a6ac3-108">Tablice typu wartości są przypisywane wewnętrznie, co oznacza, że elementy tablicy są rzeczywistymi wystąpieniami typu wartości.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="a6ac3-109">W związku z tym alokacje i cofanie alokacji tablic typu wartości są znacznie tańsze niż alokacje i cofanie alokacji tablic typu referencyjnego.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="a6ac3-110">Ponadto, w większości przypadków tablice typów wartości wykazują znacznie lepszą miejscowość odwołania.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>

 <span data-ttu-id="a6ac3-111">Kolejna różnica jest związana z użyciem pamięci.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="a6ac3-112">Typy wartości są zapakowane, gdy rzutowanie na typ referencyjny lub jeden z implementowanych interfejsów.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="a6ac3-113">Są one nieopakowane podczas rzutowania z powrotem na typ wartości.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="a6ac3-114">Ponieważ pola są obiektami przydzielonymi na stercie i są zbierane jako elementy bezużyteczne, zbyt dużo opakowania i rozpakowywanie mogą mieć negatywny wpływ na stertę, Moduł wyrzucania elementów bezużytecznych i ostatecznie wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="a6ac3-115">W przeciwieństwie do tego opakowanie nie występuje w przypadku rzutowania typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="a6ac3-116">(Aby uzyskać więcej informacji, zobacz [opakowanie i rozpakowywanie](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="a6ac3-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>

 <span data-ttu-id="a6ac3-117">Następnie przydziały typu odwołania kopiują odwołanie, podczas gdy przydziały typów wartości skopiują całą wartość.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="a6ac3-118">W związku z tym przypisania dużych typów referencyjnych są tańsze niż przydziały dużych typów wartości.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>

 <span data-ttu-id="a6ac3-119">Na koniec typy odwołań są przesyłane przez odwołanie, a typy wartości są przenoszone przez wartość.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="a6ac3-120">Zmiany w wystąpieniu typu odwołania wpływają na wszystkie odwołania wskazujące na to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="a6ac3-121">Wystąpienia typu wartości są kopiowane, gdy są przesyłane przez wartość.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="a6ac3-122">W przypadku zmiany wystąpienia typu wartości kurs nie ma wpływu na żadne kopie.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="a6ac3-123">Ponieważ kopie nie są tworzone jawnie przez użytkownika, ale są niejawnie tworzone, gdy argumenty są przekazane lub zwracane są wartości zwracanych, typy wartości, które mogą zostać zmienione, mogą być mylące dla wielu użytkowników.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="a6ac3-124">W związku z tym typy wartości powinny być niezmienne.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-124">Therefore, value types should be immutable.</span></span>

 <span data-ttu-id="a6ac3-125">Jako reguła kciuka większość typów w środowisku powinna być klasą.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="a6ac3-126">Istnieją jednak sytuacje, w których cechy typu wartości są bardziej odpowiednie do używania struktur.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>

 <span data-ttu-id="a6ac3-127">✔️ ROZWAŻYĆ zdefiniowanie struktury zamiast klasy, jeśli wystąpienia typu są małe i często krótkotrwałe lub są często osadzone w innych obiektach.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-127">✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>

 <span data-ttu-id="a6ac3-128">❌ uniknąć definiowania struktury, chyba że typ ma wszystkie następujące cechy:</span><span class="sxs-lookup"><span data-stu-id="a6ac3-128">❌ AVOID defining a struct unless the type has all of the following characteristics:</span></span>

- <span data-ttu-id="a6ac3-129">Logicznie reprezentuje pojedynczą wartość, podobną do typów pierwotnych (`int`, `double`itp.).</span><span class="sxs-lookup"><span data-stu-id="a6ac3-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>

- <span data-ttu-id="a6ac3-130">Ma rozmiar wystąpienia poniżej 16 bajtów.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-130">It has an instance size under 16 bytes.</span></span>

- <span data-ttu-id="a6ac3-131">Jest to niezmienne.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-131">It is immutable.</span></span>

- <span data-ttu-id="a6ac3-132">Nie musi być on często opakowany.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-132">It will not have to be boxed frequently.</span></span>

 <span data-ttu-id="a6ac3-133">We wszystkich innych przypadkach należy zdefiniować typy jako klasy.</span><span class="sxs-lookup"><span data-stu-id="a6ac3-133">In all other cases, you should define your types as classes.</span></span>

 <span data-ttu-id="a6ac3-134">*Fragmenty © 2005, 2009 Microsoft Corporation. Wszelkie prawa zastrzeżone.*</span><span class="sxs-lookup"><span data-stu-id="a6ac3-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="a6ac3-135">*Ponownie Wydrukowano przez uprawnienie Pearson Education, Inc. z [wytycznych dotyczących projektowania platformy: konwencje, idiomy i wzorce dla bibliotek .NET do wielokrotnego użytku, 2. wydanie](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) przez Krzysztof Cwalina i Brad Abrams, opublikowane 22, 2008 przez Addison-Wesley Professional w ramach serii Microsoft Windows Development.*</span><span class="sxs-lookup"><span data-stu-id="a6ac3-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="a6ac3-136">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a6ac3-136">See also</span></span>

- [<span data-ttu-id="a6ac3-137">Typy — zalecenia dotyczące projektowania</span><span class="sxs-lookup"><span data-stu-id="a6ac3-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)
- [<span data-ttu-id="a6ac3-138">Struktura — zalecenia dotyczące projektowania</span><span class="sxs-lookup"><span data-stu-id="a6ac3-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
