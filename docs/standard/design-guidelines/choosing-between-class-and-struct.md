---
title: Wybieranie między klasą i strukturą
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 7590d5628f4951a8c7c2199f0e954007ed9fa962
ms.sourcegitcommit: b5cd9d5d3b75a5537fc9ad8a3f085f0bb1845ee0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/07/2018
ms.locfileid: "50757429"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="7e642-102">Wybieranie między klasą i strukturą</span><span class="sxs-lookup"><span data-stu-id="7e642-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="7e642-103">Jednym z decyzji projektowych podstawowe twarzy każdego Projektant framework jest czy zaprojektować typu jako klasę (typ odwołania) lub struct (typu wartości).</span><span class="sxs-lookup"><span data-stu-id="7e642-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="7e642-104">Dobre zrozumienie różnic w zachowaniu typy odwołań i typy wartości jest sprawą kluczową podczas wprowadzania tego wyboru.</span><span class="sxs-lookup"><span data-stu-id="7e642-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>  
  
 <span data-ttu-id="7e642-105">Pierwszy różnica między typami odwołań i typy wartości, które firma Microsoft będzie należy wziąć pod uwagę typów referencyjnych są przydzielone na stercie i jesdnostką zbierającą śmieci, natomiast typy wartości są przydzielane na stosie, lub bezpośrednio w zawierających typy i cofnięta kiedy stos rozwija lub po ich typem zawierającym cofnięcie jej przydziału.</span><span class="sxs-lookup"><span data-stu-id="7e642-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="7e642-106">W związku z tym alokacji i liczbą typów wartości są ogólnie rzecz biorąc tańsze niż alokacji i liczbą typów odwołań.</span><span class="sxs-lookup"><span data-stu-id="7e642-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>  
  
 <span data-ttu-id="7e642-107">Następnie tablice, odwołania, które typy są przydzielane poza wierszem, co oznacza tablicy, które elementy są tylko odwołania do wystąpienia typu referencyjnego znajdującej się na stosie.</span><span class="sxs-lookup"><span data-stu-id="7e642-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="7e642-108">Tablicami typu wartości są przydzielane w tekście, co oznacza, że elementy tablicy są bieżące wystąpienia typu wartości.</span><span class="sxs-lookup"><span data-stu-id="7e642-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="7e642-109">W związku z tym alokacji i liczbą tablicami typu wartości są znacznie tańsze niż alokacji i liczbą tablicami typu odwołania.</span><span class="sxs-lookup"><span data-stu-id="7e642-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="7e642-110">Ponadto w większości przypadków tablicami typu wartości następującej liczby etapów stwierdzono znacznie lepiej miejscowość odwołania.</span><span class="sxs-lookup"><span data-stu-id="7e642-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>  
  
 <span data-ttu-id="7e642-111">Następna różnica dotyczy użycia pamięci.</span><span class="sxs-lookup"><span data-stu-id="7e642-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="7e642-112">Typy wartości Pobierz zapakowany, jeśli zrzutować na typ referencyjny lub jeden z interfejsów, które implementują.</span><span class="sxs-lookup"><span data-stu-id="7e642-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="7e642-113">Otrzymają one rozpakowany Jeśli zrzutować do typu wartości.</span><span class="sxs-lookup"><span data-stu-id="7e642-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="7e642-114">Ponieważ pola są obiekty, które są przydzielane na stosie i zebranych elementów bezużytecznych, zbyt dużo pakowania, jak i rozpakowania może mieć negatywny wpływ na stercie modułu odśmiecania pamięci i ostatecznie wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="7e642-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="7e642-115">Z kolei nie takich pakowania wypada rzutowania są typami odwołań.</span><span class="sxs-lookup"><span data-stu-id="7e642-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="7e642-116">(Aby uzyskać więcej informacji, zobacz [opakowywanie i rozpakowywanie](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="7e642-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>
  
 <span data-ttu-id="7e642-117">Następnie przypisania typu odwołania wykonywać kopiowanie odwołania, natomiast wartość typu przypisania skopiować całą wartość.</span><span class="sxs-lookup"><span data-stu-id="7e642-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="7e642-118">Dlatego przypisania typów referencyjnych dużych są tańsze niż przypisania duża wartość.</span><span class="sxs-lookup"><span data-stu-id="7e642-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>  
  
 <span data-ttu-id="7e642-119">Na koniec typów referencyjnych są przekazywane przez odwołanie, natomiast typy wartości są przekazywane przez wartość.</span><span class="sxs-lookup"><span data-stu-id="7e642-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="7e642-120">Zmiany do wystąpienia typu referencyjnego wpływają na wszystkie odwołania, które wskazuje na wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="7e642-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="7e642-121">Wystąpienia typu wartości są kopiowane, gdy są przekazywane przez wartość.</span><span class="sxs-lookup"><span data-stu-id="7e642-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="7e642-122">Po zmianie wystąpienie typu wartości jego oczywiście nie wpływa na jego kopii.</span><span class="sxs-lookup"><span data-stu-id="7e642-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="7e642-123">Ponieważ kopie nie są jawnie tworzone przez użytkownika, ale są tworzone niejawnie, gdy argumenty są przekazywane lub zwracanych wartości są zwracane typy wartości, które mogą być zmieniane może być mylące dla wielu użytkowników.</span><span class="sxs-lookup"><span data-stu-id="7e642-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="7e642-124">W związku z tym typy wartości powinno być niezmienialne.</span><span class="sxs-lookup"><span data-stu-id="7e642-124">Therefore, value types should be immutable.</span></span>  
  
 <span data-ttu-id="7e642-125">Jako ogólną regułę można przyjąć większość typów w ramach powinna być klasy.</span><span class="sxs-lookup"><span data-stu-id="7e642-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="7e642-126">Istnieją jednak sytuacje, w których właściwości typu wartości stał się bardziej odpowiednie użycie struktury.</span><span class="sxs-lookup"><span data-stu-id="7e642-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>  
  
 <span data-ttu-id="7e642-127">**✓ CONSIDER** definiowania struktury zamiast klasy, jeśli wystąpienia typu małych i często krótkim okresie lub często są osadzone w innych obiektach.</span><span class="sxs-lookup"><span data-stu-id="7e642-127">**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>  
  
 <span data-ttu-id="7e642-128">**X AVOID** definiowania struktury, chyba że typ ma wszystkie następujące właściwości:</span><span class="sxs-lookup"><span data-stu-id="7e642-128">**X AVOID** defining a struct unless the type has all of the following characteristics:</span></span>  
  
-   <span data-ttu-id="7e642-129">Logicznie reprezentuje pojedynczą wartość, podobnie jak typy pierwotne (`int`, `double`itp.).</span><span class="sxs-lookup"><span data-stu-id="7e642-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>  
  
-   <span data-ttu-id="7e642-130">Ma rozmiar wystąpienia w obszarze 16 bajtów.</span><span class="sxs-lookup"><span data-stu-id="7e642-130">It has an instance size under 16 bytes.</span></span>  
  
-   <span data-ttu-id="7e642-131">Jest on niezmienny.</span><span class="sxs-lookup"><span data-stu-id="7e642-131">It is immutable.</span></span>  
  
-   <span data-ttu-id="7e642-132">Nie będzie można go opakować często.</span><span class="sxs-lookup"><span data-stu-id="7e642-132">It will not have to be boxed frequently.</span></span>  
  
 <span data-ttu-id="7e642-133">We wszystkich innych przypadkach należy zdefiniować typów jako klasy.</span><span class="sxs-lookup"><span data-stu-id="7e642-133">In all other cases, you should define your types as classes.</span></span>  
  
 <span data-ttu-id="7e642-134">*Portions © 2005, 2009 Microsoft Corporation. Wszelkie prawa zastrzeżone.*</span><span class="sxs-lookup"><span data-stu-id="7e642-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="7e642-135">*Przedrukowano przez uprawnienie Pearson edukacji, Inc. z [wytyczne dotyczące projektowania Framework: konwencje Idiomy i wzorce wielokrotnego użytku, do bibliotek .NET, wydanie 2](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina i Brad Abrams opublikowane 22 Oct 2008 przez Professional Addison Wesley jako część serii rozwoju Windows firmy Microsoft.*</span><span class="sxs-lookup"><span data-stu-id="7e642-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7e642-136">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="7e642-136">See also</span></span>

- [<span data-ttu-id="7e642-137">Typy — zalecenia dotyczące projektowania</span><span class="sxs-lookup"><span data-stu-id="7e642-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)  
- [<span data-ttu-id="7e642-138">Struktura — zalecenia dotyczące projektowania</span><span class="sxs-lookup"><span data-stu-id="7e642-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
