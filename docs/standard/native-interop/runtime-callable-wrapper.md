---
title: Wywoływana otoka środowiska uruchomieniowego
description: Środowisko CLR uwidacznia obiekty COM za pomocą otoki wywołującej środowisko uruchomieniowe, która zarządza wywołaniami między klientem .NET a obiektem COM.
ms.date: 03/30/2017
helpviewer_keywords:
- COM interop, COM wrappers
- RCW
- COM wrappers
- runtime callable wrappers
- interoperation with unmanaged code, COM wrappers
ms.assetid: 7e542583-1e31-4e10-b523-8cf2f29cb4a4
ms.openlocfilehash: 9c218fe7a08bd7181d66aa849bcca4cac00dc6fa
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/15/2020
ms.locfileid: "90535862"
---
# <a name="runtime-callable-wrapper"></a><span data-ttu-id="cd51a-103">Wywoływana otoka środowiska uruchomieniowego</span><span class="sxs-lookup"><span data-stu-id="cd51a-103">Runtime Callable Wrapper</span></span>
<span data-ttu-id="cd51a-104">Środowisko uruchomieniowe języka wspólnego udostępnia obiekty COM za pomocą serwera proxy zwanego otoką (otoka) środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="cd51a-104">The common language runtime exposes COM objects through a proxy called the runtime callable wrapper (RCW).</span></span> <span data-ttu-id="cd51a-105">Chociaż Otoka RCW wydaje się być zwykłym obiektem dla klientów platformy .NET, jej podstawową funkcją jest kierowanie wywołań między klientem .NET a obiektem COM.</span><span class="sxs-lookup"><span data-stu-id="cd51a-105">Although the RCW appears to be an ordinary object to .NET clients, its primary function is to marshal calls between a .NET client and a COM object.</span></span>  
  
 <span data-ttu-id="cd51a-106">Środowisko uruchomieniowe tworzy dokładnie jedną otokę RCW dla każdego obiektu COM, niezależnie od liczby odwołań istniejących w tym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="cd51a-106">The runtime creates exactly one RCW for each COM object, regardless of the number of references that exist on that object.</span></span> <span data-ttu-id="cd51a-107">Środowisko uruchomieniowe utrzymuje pojedynczą OTOKę na każdy proces dla każdego obiektu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-107">The runtime maintains a single RCW per process for each object.</span></span>  <span data-ttu-id="cd51a-108">Jeśli utworzysz otokę RCW w jednej domenie lub apartamentu aplikacji, a następnie przekażesz odwołanie do innej domeny lub apartamentu aplikacji, zostanie użyty serwer proxy do pierwszego obiektu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-108">If you create an RCW in one application domain or apartment, and then pass a reference to another application domain or apartment, a proxy to the first object will be used.</span></span>  <span data-ttu-id="cd51a-109">Jak widać na poniższej ilustracji, każda liczba zarządzanych klientów może przechowywać odwołanie do obiektów COM, które uwidaczniają interfejsy INew i INewer.</span><span class="sxs-lookup"><span data-stu-id="cd51a-109">As the following illustration shows, any number of managed clients can hold a reference to the COM objects that expose INew and INewer interfaces.</span></span>  

<span data-ttu-id="cd51a-110">Na poniższej ilustracji przedstawiono proces uzyskiwania dostępu do obiektów COM za pomocą otoki możliwej do uruchomienia:</span><span class="sxs-lookup"><span data-stu-id="cd51a-110">The following image shows the process for accessing COM objects through the runtime callable wrapper:</span></span>

 ![Proces uzyskiwania dostępu do obiektów COM za pomocą OTOKi.](./media/runtime-callable-wrapper/runtime-callable-wrapper.gif)  

 <span data-ttu-id="cd51a-112">Przy użyciu metadanych pochodzących z biblioteki typów środowisko uruchomieniowe tworzy zarówno wywoływany obiekt COM, jak i otokę dla tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-112">Using metadata derived from a type library, the runtime creates both the COM object being called and a wrapper for that object.</span></span> <span data-ttu-id="cd51a-113">Każda pozostała OTOKa utrzymuje pamięć podręczną wskaźników interfejsu w obiekcie COM, która otacza i zwalnia odwołanie do obiektu COM, gdy Otoka RCW nie jest już wymagana.</span><span class="sxs-lookup"><span data-stu-id="cd51a-113">Each RCW maintains a cache of interface pointers on the COM object it wraps and releases its reference on the COM object when the RCW is no longer needed.</span></span> <span data-ttu-id="cd51a-114">Środowisko uruchomieniowe wykonuje wyrzucanie elementów bezużytecznych dla otoki RCW.</span><span class="sxs-lookup"><span data-stu-id="cd51a-114">The runtime performs garbage collection on the RCW.</span></span>  
  
 <span data-ttu-id="cd51a-115">W przypadku innych działań Otoka RCW udostępnia dane między zarządzanym i niezarządzanym kodem w imieniu opakowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-115">Among other activities, the RCW marshals data between managed and unmanaged code, on behalf of the wrapped object.</span></span> <span data-ttu-id="cd51a-116">Otoka RCW zapewnia kierowanie argumentów metod i zwracanych wartości metod za każdym razem, gdy klient i serwer mają różne reprezentacje danych przekazywanych między nimi.</span><span class="sxs-lookup"><span data-stu-id="cd51a-116">Specifically, the RCW provides marshaling for method arguments and method return values whenever the client and server have different representations of the data passed between them.</span></span>  
  
 <span data-ttu-id="cd51a-117">Otoka standardowa wymusza wbudowane reguły organizowania.</span><span class="sxs-lookup"><span data-stu-id="cd51a-117">The standard wrapper enforces built-in marshaling rules.</span></span> <span data-ttu-id="cd51a-118">Na przykład gdy klient platformy .NET przekazuje typ ciągu jako część argumentu do niezarządzanego obiektu, otoka konwertuje ciąg na typ BSTR.</span><span class="sxs-lookup"><span data-stu-id="cd51a-118">For example, when a .NET client passes a String type as part of an argument to an unmanaged object, the wrapper converts the string to a BSTR type.</span></span> <span data-ttu-id="cd51a-119">Jeśli obiekt COM zwraca element BSTR do zarządzanego obiektu wywołującego, obiekt wywołujący otrzymuje ciąg.</span><span class="sxs-lookup"><span data-stu-id="cd51a-119">Should the COM object return a BSTR to its managed caller, the caller receives a String.</span></span> <span data-ttu-id="cd51a-120">Zarówno klient, jak i serwer wysyłają i odbierają dane, które są dla nich znane.</span><span class="sxs-lookup"><span data-stu-id="cd51a-120">Both the client and the server send and receive data that is familiar to them.</span></span> <span data-ttu-id="cd51a-121">Inne typy nie wymagają konwersji.</span><span class="sxs-lookup"><span data-stu-id="cd51a-121">Other types require no conversion.</span></span> <span data-ttu-id="cd51a-122">Na przykład, otoka standardowa zawsze przekaże 4-bajtową liczbę całkowitą między zarządzanym i niezarządzanym kodem bez konwertowania typu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-122">For instance, a standard wrapper will always pass a 4-byte integer between managed and unmanaged code without converting the type.</span></span>  
  
## <a name="marshaling-selected-interfaces"></a><span data-ttu-id="cd51a-123">Kierowanie wybranych interfejsów</span><span class="sxs-lookup"><span data-stu-id="cd51a-123">Marshaling selected interfaces</span></span>  
 <span data-ttu-id="cd51a-124">Głównym celem [otoki wywoływanej środowiska uruchomieniowego](runtime-callable-wrapper.md) (RCW) jest ukrywanie różnic między zarządzanymi i niezarządzanymi modelami programowania.</span><span class="sxs-lookup"><span data-stu-id="cd51a-124">The primary goal of the [runtime callable wrapper](runtime-callable-wrapper.md) (RCW) is to hide the differences between the managed and unmanaged programming models.</span></span> <span data-ttu-id="cd51a-125">W celu zapewnienia bezproblemowego przejścia Otoka RCW wykorzystuje wybrane interfejsy COM bez udostępniania ich klientom platformy .NET, jak pokazano na poniższej ilustracji.</span><span class="sxs-lookup"><span data-stu-id="cd51a-125">To create a seamless transition, the RCW consumes selected COM interfaces without exposing them to the .NET client, as shown in the following illustration.</span></span>

 <span data-ttu-id="cd51a-126">Na poniższej ilustracji przedstawiono interfejsy COM i otokę, która umożliwia wywoływanie środowiska uruchomieniowego:</span><span class="sxs-lookup"><span data-stu-id="cd51a-126">The following image shows COM interfaces and the runtime callable wrapper:</span></span>
  
 ![Zrzut ekranu przedstawiający otokę w środowisku uruchomieniowym z interfejsami.](./media/runtime-callable-wrapper/runtime-callable-wrapper-interfaces.gif)  
  
 <span data-ttu-id="cd51a-128">Podczas tworzenia jako obiekt z wczesnym wiązaniem, OTOKa jest określonego typu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-128">When created as an early-bound object, the RCW is a specific type.</span></span> <span data-ttu-id="cd51a-129">Implementuje interfejsy, które obiekt COM implementuje i uwidacznia metody, właściwości i zdarzenia z interfejsów obiektu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-129">It implements the interfaces that the COM object implements and exposes the methods, properties, and events from the object's interfaces.</span></span> <span data-ttu-id="cd51a-130">Na ilustracji Otoka RCW uwidacznia interfejs INew, ale zużywa interfejsy **IUnknown** i **IDispatch** .</span><span class="sxs-lookup"><span data-stu-id="cd51a-130">In the illustration, the RCW exposes the INew interface but consumes the **IUnknown** and **IDispatch** interfaces.</span></span> <span data-ttu-id="cd51a-131">Ponadto Otoka RCW uwidacznia wszystkie elementy członkowskie interfejsu INew do klienta platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="cd51a-131">Further, the RCW exposes all members of the INew interface to the .NET client.</span></span>  
  
 <span data-ttu-id="cd51a-132">Otoka RCW zużywa interfejsy wymienione w poniższej tabeli, które są uwidaczniane przez obiekt, który jest zawijany.</span><span class="sxs-lookup"><span data-stu-id="cd51a-132">The RCW consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="cd51a-133">Interfejs</span><span class="sxs-lookup"><span data-stu-id="cd51a-133">Interface</span></span>|<span data-ttu-id="cd51a-134">Opis</span><span class="sxs-lookup"><span data-stu-id="cd51a-134">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="cd51a-135">**IDispatch**</span><span class="sxs-lookup"><span data-stu-id="cd51a-135">**IDispatch**</span></span>|<span data-ttu-id="cd51a-136">Dla późnego wiązania do obiektów COM przy użyciu odbicia.</span><span class="sxs-lookup"><span data-stu-id="cd51a-136">For late binding to COM objects through reflection.</span></span>|  
|<span data-ttu-id="cd51a-137">**IErrorInfo**</span><span class="sxs-lookup"><span data-stu-id="cd51a-137">**IErrorInfo**</span></span>|<span data-ttu-id="cd51a-138">Zawiera tekstowy opis błędu, jego źródło, plik pomocy, kontekst pomocy oraz identyfikator GUID interfejsu, który definiuje błąd (zawsze **GUID_NULL** dla klas .NET).</span><span class="sxs-lookup"><span data-stu-id="cd51a-138">Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes).</span></span>|  
|<span data-ttu-id="cd51a-139">**IProvideClassInfo**</span><span class="sxs-lookup"><span data-stu-id="cd51a-139">**IProvideClassInfo**</span></span>|<span data-ttu-id="cd51a-140">Jeśli opakowany obiekt COM implementuje **IProvideClassInfo**, otoka wyodrębnia informacje o typie z tego interfejsu, aby zapewnić lepszą tożsamość typu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-140">If the COM object being wrapped implements **IProvideClassInfo**, the RCW extracts the type information from this interface to provide better type identity.</span></span>|  
|<span data-ttu-id="cd51a-141">**IUnknown**</span><span class="sxs-lookup"><span data-stu-id="cd51a-141">**IUnknown**</span></span>|<span data-ttu-id="cd51a-142">W przypadku tożsamości obiektu, przekształcenia typów i zarządzania okresem istnienia:</span><span class="sxs-lookup"><span data-stu-id="cd51a-142">For object identity, type coercion, and lifetime management:</span></span><br /><br /> <span data-ttu-id="cd51a-143">-Tożsamość obiektu</span><span class="sxs-lookup"><span data-stu-id="cd51a-143">-   Object identity</span></span><br />     <span data-ttu-id="cd51a-144">Środowisko uruchomieniowe rozróżnia obiekty COM, porównując wartość interfejsu **IUnknown** dla każdego obiektu.</span><span class="sxs-lookup"><span data-stu-id="cd51a-144">The runtime distinguishes between COM objects by comparing the value of the **IUnknown** interface for each object.</span></span><br /><span data-ttu-id="cd51a-145">-Typ przekształcenia</span><span class="sxs-lookup"><span data-stu-id="cd51a-145">-   Type coercion</span></span><br />     <span data-ttu-id="cd51a-146">Otoka RCW rozpoznaje odnajdywanie typu dynamicznego wykonywane przez metodę **QueryInterface** .</span><span class="sxs-lookup"><span data-stu-id="cd51a-146">The RCW recognizes the dynamic type discovery performed by the **QueryInterface** method.</span></span><br /><span data-ttu-id="cd51a-147">— Zarządzanie okresem istnienia</span><span class="sxs-lookup"><span data-stu-id="cd51a-147">-   Lifetime management</span></span><br />     <span data-ttu-id="cd51a-148">Przy użyciu metody **QueryInterface** , otoka pobiera i utrzymuje odwołanie do obiektu niezarządzanego, dopóki środowisko uruchomieniowe nie wykonuje wyrzucania elementów bezużytecznych w otoki, która zwalnia obiekt niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="cd51a-148">Using the **QueryInterface** method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object.</span></span>|  
  
 <span data-ttu-id="cd51a-149">Otoka (RCW) opcjonalnie wykorzystuje interfejsy wymienione w poniższej tabeli, które są udostępniane przez obiekt, który jest zawijany.</span><span class="sxs-lookup"><span data-stu-id="cd51a-149">The RCW optionally consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="cd51a-150">Interfejs</span><span class="sxs-lookup"><span data-stu-id="cd51a-150">Interface</span></span>|<span data-ttu-id="cd51a-151">Opis</span><span class="sxs-lookup"><span data-stu-id="cd51a-151">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="cd51a-152">**IConnectionPoint** i **IConnectionPointContainer**</span><span class="sxs-lookup"><span data-stu-id="cd51a-152">**IConnectionPoint** and **IConnectionPointContainer**</span></span>|<span data-ttu-id="cd51a-153">Otoka RCW Konwertuje obiekty, które uwidaczniają styl zdarzenia punktu połączenia do zdarzeń na podstawie delegowania.</span><span class="sxs-lookup"><span data-stu-id="cd51a-153">The RCW converts objects that expose the connection-point event style to delegate-based events.</span></span>|  
|<span data-ttu-id="cd51a-154">**IDispatchEx** (tylko .NET Framework)</span><span class="sxs-lookup"><span data-stu-id="cd51a-154">**IDispatchEx** (.NET Framework Only)</span></span> |<span data-ttu-id="cd51a-155">Jeśli klasa implementuje **IDispatchEx**, otoka zawiera implementację **IExpando**.</span><span class="sxs-lookup"><span data-stu-id="cd51a-155">If the class implements **IDispatchEx**, the RCW implements **IExpando**.</span></span> <span data-ttu-id="cd51a-156">Interfejs **IDispatchEx** jest rozszerzeniem interfejsu **IDispatch** , który, w przeciwieństwie do **IDispatch**, włącza Wyliczenie, Dodawanie, usuwanie i uwzględnianie wielkości liter dla elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="cd51a-156">The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members.</span></span>|  
|<span data-ttu-id="cd51a-157">**IEnumVARIANT**</span><span class="sxs-lookup"><span data-stu-id="cd51a-157">**IEnumVARIANT**</span></span>|<span data-ttu-id="cd51a-158">Włącza typy COM obsługujące wyliczenia, które mają być traktowane jako kolekcje.</span><span class="sxs-lookup"><span data-stu-id="cd51a-158">Enables COM types that support enumerations to be treated as collections.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="cd51a-159">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="cd51a-159">See also</span></span>

- [<span data-ttu-id="cd51a-160">Otoki COM</span><span class="sxs-lookup"><span data-stu-id="cd51a-160">COM Wrappers</span></span>](com-wrappers.md)
- [<span data-ttu-id="cd51a-161">Wywoływana otoka COM</span><span class="sxs-lookup"><span data-stu-id="cd51a-161">COM Callable Wrapper</span></span>](com-callable-wrapper.md)
- <span data-ttu-id="cd51a-162">[Podsumowanie dotyczące konwersji biblioteki typów na zestaw](/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="cd51a-162">[Type Library to Assembly Conversion Summary](/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))</span></span>
- [<span data-ttu-id="cd51a-163">Importowanie biblioteki typów jako zestawu</span><span class="sxs-lookup"><span data-stu-id="cd51a-163">Importing a Type Library as an Assembly</span></span>](../../framework/interop/importing-a-type-library-as-an-assembly.md)
