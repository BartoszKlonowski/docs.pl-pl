---
title: Wywołanie platformy (P/Invoke)
description: Dowiedz się, jak wywoływać funkcje natywne za pomocą P/Invoke w programie .NET.
ms.date: 01/18/2019
ms.openlocfilehash: cde52d9d0a4e3b84fec632b615b635e7b7df3924
ms.sourcegitcommit: 4b79862c5b41fbd86cf38f926f6a49516059f6f2
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/18/2020
ms.locfileid: "97678262"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="a5f6e-103">Wywołanie platformy (P/Invoke)</span><span class="sxs-lookup"><span data-stu-id="a5f6e-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="a5f6e-104">P/Invoke to technologia, która umożliwia dostęp do struktur, wywołań zwrotnych i funkcji w bibliotekach niezarządzanych z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="a5f6e-105">Większość interfejsu API P/Invoke jest zawarta w dwóch obszarach nazw: `System` i `System.Runtime.InteropServices` .</span><span class="sxs-lookup"><span data-stu-id="a5f6e-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="a5f6e-106">Korzystając z tych dwóch przestrzeni nazw, można opisać, w jaki sposób chcesz komunikować się ze składnikiem macierzystym.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="a5f6e-107">Zacznijmy od najbardziej typowego przykładu, który wywołuje funkcje niezarządzane w kodzie zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="a5f6e-108">Pokażmy okno komunikatu z aplikacji wiersza polecenia:</span><span class="sxs-lookup"><span data-stu-id="a5f6e-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="a5f6e-109">Poprzedni przykład jest prosty, ale pokazuje, co jest potrzebne do wywołania niezarządzanych funkcji z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="a5f6e-110">Przejdźmy do przykładu:</span><span class="sxs-lookup"><span data-stu-id="a5f6e-110">Let’s step through the example:</span></span>

- <span data-ttu-id="a5f6e-111">Wiersz #2 pokazuje instrukcję using dla `System.Runtime.InteropServices` przestrzeni nazw, która zawiera wszystkie elementy, które są zbędne.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-111">Line #2 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="a5f6e-112">Wiersz #8 wprowadza `DllImport` atrybut.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-112">Line #8 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="a5f6e-113">Ten atrybut jest decydujący, ponieważ informuje środowisko uruchomieniowe o konieczności załadowania niezarządzanej biblioteki DLL.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="a5f6e-114">Przekazaną ciągiem jest biblioteka DLL, w której znajduje się funkcja docelowa.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="a5f6e-115">Ponadto określa [zestaw znaków](./charset.md) , który ma być używany do organizowania ciągów.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="a5f6e-116">Na koniec określa, że ta funkcja wywołuje [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) i że środowisko uruchomieniowe powinno przechwycić ten kod błędu, aby użytkownik mógł go pobrać za pośrednictwem <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="a5f6e-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="a5f6e-117">Wiersz #9 jest cruxą działania P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-117">Line #9 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="a5f6e-118">Definiuje metodę zarządzaną, która ma **dokładnie taki sam podpis** jak niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="a5f6e-119">Deklaracja zawiera nowe słowo kluczowe, które można zauważyć, co oznacza, że `extern` środowisko uruchomieniowe jest metodą zewnętrzną, a po jej wywołaniu środowisko uruchomieniowe powinno je znaleźć w bibliotece DLL określonej w `DllImport` atrybucie.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="a5f6e-120">Pozostała część tego przykładu właśnie wywołuje metodę tak jak każda inna metoda zarządzana.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="a5f6e-121">Przykład jest podobny do macOS.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-121">The sample is similar for macOS.</span></span> <span data-ttu-id="a5f6e-122">Należy zmienić nazwę biblioteki w atrybucie, `DllImport` ponieważ macOS ma inny schemat nazewnictwa bibliotek dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="a5f6e-123">Poniższy przykład używa funkcji, `getpid(2)` Aby uzyskać identyfikator procesu aplikacji i wydrukować go w konsoli programu:</span><span class="sxs-lookup"><span data-stu-id="a5f6e-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="a5f6e-124">Jest on również podobny w systemie Linux.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-124">It is also similar on Linux.</span></span> <span data-ttu-id="a5f6e-125">Nazwa funkcji jest taka sama, ponieważ `getpid(2)` jest standardowym wywołaniem systemu [POSIX](https://en.wikipedia.org/wiki/POSIX) .</span><span class="sxs-lookup"><span data-stu-id="a5f6e-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="a5f6e-126">Wywoływanie kodu zarządzanego z niezarządzanego kodu</span><span class="sxs-lookup"><span data-stu-id="a5f6e-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="a5f6e-127">Środowisko uruchomieniowe umożliwia komunikację w obu kierunkach, co umożliwia wywołanie z powrotem do kodu zarządzanego z funkcji natywnych za pomocą wskaźników funkcji.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="a5f6e-128">Najbliższy element wskaźnika funkcji w kodzie zarządzanym jest **delegatem**, dlatego jest używany do zezwalania na wywołania zwrotne z kodu natywnego do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="a5f6e-129">Sposób korzystania z tej funkcji jest podobny do opisanego wcześniej procesu zarządzanego do natywnego.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="a5f6e-130">Dla danego wywołania zwrotnego należy zdefiniować delegata, który pasuje do podpisu i przekazać go do metody zewnętrznej.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="a5f6e-131">Środowisko uruchomieniowe zajmie się wszystkimi innymi.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="a5f6e-132">Przed przeprowadzeniem tego przykładu warto przejrzeć podpisy niezarządzanych funkcji, z którymi należy się skontaktować.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="a5f6e-133">Funkcja, która ma zostać wywołana, aby wyliczyć wszystkie okna, ma następujący podpis: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="a5f6e-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="a5f6e-134">Pierwszy parametr jest wywołaniem zwrotnym.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-134">The first parameter is a callback.</span></span> <span data-ttu-id="a5f6e-135">Wymienione wywołanie zwrotne ma następujący podpis: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="a5f6e-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="a5f6e-136">Teraz przyjrzyjmy się przykładowi:</span><span class="sxs-lookup"><span data-stu-id="a5f6e-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="a5f6e-137">Wiersz #9 w przykładzie definiuje delegata, który pasuje do sygnatury wywołania zwrotnego z kodu niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="a5f6e-138">Zwróć uwagę, jak typy LPARAM i HWND są reprezentowane przy użyciu `IntPtr` w kodzie zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="a5f6e-139">Linie #13 i #14 wprowadzają `EnumWindows` funkcję z biblioteki user32.dll.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="a5f6e-140">Linie #17-20 Implementuj delegata.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="a5f6e-141">W tym prostym przykładzie chcemy, aby dane były wyprowadzane do konsoli.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="a5f6e-142">Na koniec w wierszu #24 Metoda zewnętrzna jest wywoływana i przenoszona do delegata.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="a5f6e-143">Przykłady dla systemów Linux i macOS przedstawiono poniżej.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="a5f6e-144">Dla nich używana jest funkcja, `ftw` którą można znaleźć w `libc` bibliotece C.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="a5f6e-145">Ta funkcja służy do przechodzenia w hierarchie katalogów i przyjmuje wskaźnik do funkcji jako jeden z jej parametrów.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="a5f6e-146">Wymieniona funkcja ma następujący podpis: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)` .</span><span class="sxs-lookup"><span data-stu-id="a5f6e-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="a5f6e-147">w przykładzie macOS jest stosowana ta sama funkcja, a jedyną różnicą jest argument `DllImport` atrybutu, ponieważ macOS utrzymuje `libc` się w innym miejscu.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="a5f6e-148">Oba poprzednie przykłady zależą od parametrów, a w obu przypadkach parametry są podane jako typy zarządzane.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="a5f6e-149">Środowisko uruchomieniowe wykonuje "prawą czynność" i przetwarza je w odpowiedniki po drugiej stronie.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="a5f6e-150">Dowiedz się, w jaki sposób typy są organizowane do kodu natywnego na naszej stronie podczas [organizowania typów](type-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="a5f6e-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="a5f6e-151">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="a5f6e-151">More resources</span></span>

- <span data-ttu-id="a5f6e-152">[PInvoke.NET wiki](https://www.pinvoke.net/) to świetna witryna typu wiki z informacjami o typowych interfejsach API systemu Windows i sposobach ich wywoływania.</span><span class="sxs-lookup"><span data-stu-id="a5f6e-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="a5f6e-153">P/Invoke w języku C++/CLI</span><span class="sxs-lookup"><span data-stu-id="a5f6e-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="a5f6e-154">Dokumentacja narzędzia mono dla elementu P/Invoke</span><span class="sxs-lookup"><span data-stu-id="a5f6e-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
