---
title: Formaty ścieżek plików w systemie Windows
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: b3510be5d417b555d2db163636eac5ce0c0779e4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "77628049"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="fcaac-102">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="fcaac-102">File path formats on Windows systems</span></span>

<span data-ttu-id="fcaac-103">Elementy członkowskie wielu typów <xref:System.IO> w obszarze `path` nazw zawierają parametr, który umożliwia określenie ścieżki bezwzględnej lub względnej do zasobu systemu plików.</span><span class="sxs-lookup"><span data-stu-id="fcaac-103">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="fcaac-104">Ta ścieżka jest następnie przekazywana do [interfejsów API systemu plików systemu Windows](/windows/desktop/fileio/file-systems).</span><span class="sxs-lookup"><span data-stu-id="fcaac-104">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="fcaac-105">W tym temacie omówiono formaty ścieżek plików, których można używać w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="fcaac-105">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="fcaac-106">Tradycyjne ścieżki DOS</span><span class="sxs-lookup"><span data-stu-id="fcaac-106">Traditional DOS paths</span></span>

<span data-ttu-id="fcaac-107">Standardowa ścieżka DOS może składać się z trzech komponentów:</span><span class="sxs-lookup"><span data-stu-id="fcaac-107">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="fcaac-108">Litera woluminu lub napędu, po której następuje separator głośności (`:`).</span><span class="sxs-lookup"><span data-stu-id="fcaac-108">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="fcaac-109">Nazwa katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-109">A directory name.</span></span> <span data-ttu-id="fcaac-110">[Znak separatora katalogów](<xref:System.IO.Path.DirectorySeparatorChar>) oddziela podkatalogi w zagnieżdżonej hierarchii katalogów.</span><span class="sxs-lookup"><span data-stu-id="fcaac-110">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="fcaac-111">Opcjonalna nazwa pliku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-111">An optional filename.</span></span> <span data-ttu-id="fcaac-112">[Znak separatora katalogu](<xref:System.IO.Path.DirectorySeparatorChar>) oddziela ścieżkę pliku od nazwy pliku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-112">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="fcaac-113">Jeśli wszystkie trzy składniki są obecne, ścieżka jest bezwzględna.</span><span class="sxs-lookup"><span data-stu-id="fcaac-113">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="fcaac-114">Jeśli nie określono litery woluminu lub dysku, a nazwa katalogu zaczyna się od [znaku separatora katalogu,](<xref:System.IO.Path.DirectorySeparatorChar>)ścieżka jest względna od katalogu głównego bieżącego dysku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-114">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="fcaac-115">W przeciwnym razie ścieżka jest względem bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-115">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="fcaac-116">W poniższej tabeli przedstawiono niektóre możliwe ścieżki katalogów i plików.</span><span class="sxs-lookup"><span data-stu-id="fcaac-116">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="fcaac-117">Ścieżka</span><span class="sxs-lookup"><span data-stu-id="fcaac-117">Path</span></span>  |<span data-ttu-id="fcaac-118">Opis</span><span class="sxs-lookup"><span data-stu-id="fcaac-118">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="fcaac-119">Bezwzględna ścieżka pliku z katalogu głównego dysku C:</span><span class="sxs-lookup"><span data-stu-id="fcaac-119">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="fcaac-120">Ścieżka bezwzględna z katalogu głównego bieżącego dysku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-120">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="fcaac-121">Ścieżka względna do pliku w podkatalogu bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-121">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="fcaac-122">Ścieżka względna do pliku w katalogu, który jest elementem równorzędnym bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-122">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="fcaac-123">Ścieżka bezwzględna do pliku z katalogu głównego dysku C:</span><span class="sxs-lookup"><span data-stu-id="fcaac-123">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="fcaac-124">Ścieżka względna z bieżącego katalogu dysku C:.</span><span class="sxs-lookup"><span data-stu-id="fcaac-124">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="fcaac-125">Zwróć uwagę na różnicę między dwiema ostatnimi ścieżkami.</span><span class="sxs-lookup"><span data-stu-id="fcaac-125">Note the difference between the last two paths.</span></span> <span data-ttu-id="fcaac-126">Oba określają opcjonalny specyfikator woluminu (C: w obu przypadkach), ale pierwszy zaczyna się od katalogu głównego określonego woluminu, podczas gdy drugi nie.</span><span class="sxs-lookup"><span data-stu-id="fcaac-126">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="fcaac-127">W rezultacie pierwszy jest ścieżką bezwzględną z katalogu głównego dysku C:, podczas gdy drugi jest ścieżką względną z bieżącego katalogu dysku C:.</span><span class="sxs-lookup"><span data-stu-id="fcaac-127">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="fcaac-128">Użycie drugiego formularza, gdy pierwszy jest przeznaczony jest częstym źródłem błędów, które obejmują ścieżki plików systemu Windows.</span><span class="sxs-lookup"><span data-stu-id="fcaac-128">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="fcaac-129">Można określić, czy ścieżka pliku jest w pełni kwalifikowana (oznacza to, że ścieżka jest niezależna <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> od bieżącego katalogu i nie zmienia się po zmianie bieżącego katalogu), wywołując metodę.</span><span class="sxs-lookup"><span data-stu-id="fcaac-129">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="fcaac-130">Należy zauważyć, że taka ścieżka`.` może `..`zawierać względne segmenty katalogów ( i ) i nadal być w pełni kwalifikowane, jeśli rozwiązana ścieżka zawsze wskazuje na tę samą lokalizację.</span><span class="sxs-lookup"><span data-stu-id="fcaac-130">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="fcaac-131">W poniższym przykładzie przedstawiono różnicę między ścieżkami bezwzględnymi i względnymi.</span><span class="sxs-lookup"><span data-stu-id="fcaac-131">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="fcaac-132">Zakłada się, że katalog D:\FY2018\ istnieje i że nie ustawiono żadnego bieżącego katalogu dla D:\ z wiersza polecenia przed uruchomieniem przykładu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-132">It assumes that the directory D:\FY2018\ exists, and that you haven't set any current directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

[!INCLUDE [localized code comments](../../../includes/code-comments-loc.md)]

## <a name="unc-paths"></a><span data-ttu-id="fcaac-133">Ścieżki UNC</span><span class="sxs-lookup"><span data-stu-id="fcaac-133">UNC paths</span></span>

<span data-ttu-id="fcaac-134">Ścieżki konwencji nazewnictwa uniwersalnego (UNC), które są używane do uzyskiwania dostępu do zasobów sieciowych, mają następujący format:</span><span class="sxs-lookup"><span data-stu-id="fcaac-134">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="fcaac-135">Nazwa serwera lub hosta, która \\ \\jest poprzedzona .</span><span class="sxs-lookup"><span data-stu-id="fcaac-135">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="fcaac-136">Nazwa serwera może być nazwą komputera NetBIOS lub adresem IP/FQDN (obsługiwane są iPv4 oraz v6).</span><span class="sxs-lookup"><span data-stu-id="fcaac-136">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="fcaac-137">Nazwa udziału, która jest oddzielona \\od nazwy hosta przez .</span><span class="sxs-lookup"><span data-stu-id="fcaac-137">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="fcaac-138">Razem serwer i nazwa udziału tworzą wolumin.</span><span class="sxs-lookup"><span data-stu-id="fcaac-138">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="fcaac-139">Nazwa katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-139">A directory name.</span></span> <span data-ttu-id="fcaac-140">[Znak separatora katalogów](<xref:System.IO.Path.DirectorySeparatorChar>) oddziela podkatalogi w zagnieżdżonej hierarchii katalogów.</span><span class="sxs-lookup"><span data-stu-id="fcaac-140">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="fcaac-141">Opcjonalna nazwa pliku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-141">An optional filename.</span></span> <span data-ttu-id="fcaac-142">[Znak separatora katalogu](<xref:System.IO.Path.DirectorySeparatorChar>) oddziela ścieżkę pliku od nazwy pliku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-142">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="fcaac-143">Oto kilka przykładów ścieżek UNC:</span><span class="sxs-lookup"><span data-stu-id="fcaac-143">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="fcaac-144">Ścieżka</span><span class="sxs-lookup"><span data-stu-id="fcaac-144">Path</span></span>  |<span data-ttu-id="fcaac-145">Opis</span><span class="sxs-lookup"><span data-stu-id="fcaac-145">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="fcaac-146">Katalog główny dysku C: `system07`na .</span><span class="sxs-lookup"><span data-stu-id="fcaac-146">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="fcaac-147">Plik Foo.txt w katalogu testowym woluminu \\ \\udziału serwera2.\\</span><span class="sxs-lookup"><span data-stu-id="fcaac-147">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="fcaac-148">Ścieżki UNC muszą być zawsze w pełni kwalifikowane.</span><span class="sxs-lookup"><span data-stu-id="fcaac-148">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="fcaac-149">Mogą one obejmować względne`.` `..`segmenty katalogów ( i ), ale muszą one być częścią ścieżki w pełni kwalifikowanej.</span><span class="sxs-lookup"><span data-stu-id="fcaac-149">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="fcaac-150">Ścieżek względnych można używać tylko przez mapowanie ścieżki UNC na literę dysku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-150">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="fcaac-151">Ścieżki urządzeń DOS</span><span class="sxs-lookup"><span data-stu-id="fcaac-151">DOS device paths</span></span>

<span data-ttu-id="fcaac-152">System operacyjny Windows ma ujednolicony model obiektów, który wskazuje wszystkie zasoby, w tym pliki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-152">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="fcaac-153">Te ścieżki obiektów są dostępne z okna konsoli i są widoczne dla warstwy Win32 za pośrednictwem specjalnego folderu dowiązań symbolicznych, na które są mapowane starsze ścieżki DOS i UNC.</span><span class="sxs-lookup"><span data-stu-id="fcaac-153">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="fcaac-154">Ten folder specjalny jest dostępny za pośrednictwem składni ścieżki urządzenia DOS, która jest jedną z:</span><span class="sxs-lookup"><span data-stu-id="fcaac-154">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="fcaac-155">Oprócz identyfikowania dysku za pomocą litery dysku można zidentyfikować wolumin za pomocą jego identyfikatora GUID woluminu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-155">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="fcaac-156">Ma to formę:</span><span class="sxs-lookup"><span data-stu-id="fcaac-156">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="fcaac-157">Składnia ścieżki urządzenia DOS jest obsługiwana w implementacjach .NET działających w systemie Windows, począwszy od .NET Core 1.1 i .NET Framework 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="fcaac-157">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="fcaac-158">Ścieżka urządzenia DOS składa się z następujących składników:</span><span class="sxs-lookup"><span data-stu-id="fcaac-158">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="fcaac-159">Specyfikator ścieżki`\\.\` `\\?\`urządzenia ( lub ), który identyfikuje ścieżkę jako ścieżkę urządzenia DOS.</span><span class="sxs-lookup"><span data-stu-id="fcaac-159">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="fcaac-160">Jest `\\?\` obsługiwana we wszystkich wersjach programu .NET Core i w platformie .NET Framework, począwszy od wersji 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="fcaac-160">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="fcaac-161">Dowiązanie symboliczne do obiektu urządzenia "prawdziwe" (C: w przypadku nazwy dysku lub Wolumin{b75e2c83-0000-0000-602f00000000000000000} w przypadku identyfikatora GUID woluminu).</span><span class="sxs-lookup"><span data-stu-id="fcaac-161">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="fcaac-162">Pierwszy segment ścieżki urządzenia DOS po specyfikarze ścieżki urządzenia identyfikuje wolumin lub dysk.</span><span class="sxs-lookup"><span data-stu-id="fcaac-162">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="fcaac-163">(Na przykład `\\?\C:\` `\\.\BootPartition\`i .)</span><span class="sxs-lookup"><span data-stu-id="fcaac-163">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="fcaac-164">Istnieje szczególny link dla UNC, który nazywa `UNC`się, nic dziwnego, .</span><span class="sxs-lookup"><span data-stu-id="fcaac-164">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="fcaac-165">Przykład:</span><span class="sxs-lookup"><span data-stu-id="fcaac-165">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="fcaac-166">W przypadku unc urządzenia, serwer/część udziału tworzy wolumin.</span><span class="sxs-lookup"><span data-stu-id="fcaac-166">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="fcaac-167">Na przykład `\\?\server1\e:\utilities\\filecomparer\`w programie , część serwera/udziału jest server1\utilities.</span><span class="sxs-lookup"><span data-stu-id="fcaac-167">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="fcaac-168">Jest to istotne podczas wywoływania metody, takich jak <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> względne segmenty katalogów; nigdy nie jest możliwe przejście poza woluminem.</span><span class="sxs-lookup"><span data-stu-id="fcaac-168">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="fcaac-169">Ścieżki urządzeń DOS są w pełni kwalifikowane z definicji.</span><span class="sxs-lookup"><span data-stu-id="fcaac-169">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="fcaac-170">Względne segmenty`.` `..`katalogów ( i ) nie są dozwolone.</span><span class="sxs-lookup"><span data-stu-id="fcaac-170">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="fcaac-171">Bieżące katalogi nigdy nie wchodzą w ich użycie.</span><span class="sxs-lookup"><span data-stu-id="fcaac-171">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="fcaac-172">Przykład: Sposoby odwoływania się do tego samego pliku</span><span class="sxs-lookup"><span data-stu-id="fcaac-172">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="fcaac-173">W poniższym przykładzie przedstawiono niektóre ze sposobów, w jaki można odwoływać <xref:System.IO> się do pliku podczas korzystania z interfejsów API w obszarze nazw.</span><span class="sxs-lookup"><span data-stu-id="fcaac-173">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="fcaac-174">Przykład tworzy <xref:System.IO.FileInfo> obiekt i używa jego <xref:System.IO.FileInfo.Name> <xref:System.IO.FileInfo.Length> i właściwości do wyświetlania nazwy pliku i długości pliku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-174">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="fcaac-175">Normalizacja ścieżki</span><span class="sxs-lookup"><span data-stu-id="fcaac-175">Path normalization</span></span>

<span data-ttu-id="fcaac-176">Prawie wszystkie ścieżki przekazywane do interfejsów API systemu Windows są znormalizowane.</span><span class="sxs-lookup"><span data-stu-id="fcaac-176">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="fcaac-177">Podczas normalizacji system Windows wykonuje następujące kroki:</span><span class="sxs-lookup"><span data-stu-id="fcaac-177">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="fcaac-178">Identyfikuje ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="fcaac-178">Identifies the path.</span></span>
- <span data-ttu-id="fcaac-179">Stosuje bieżący katalog do ścieżek częściowo kwalifikowanych (względnych).</span><span class="sxs-lookup"><span data-stu-id="fcaac-179">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="fcaac-180">Kanonizuje separatory komponentów i katalogów.</span><span class="sxs-lookup"><span data-stu-id="fcaac-180">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="fcaac-181">Oblicza względne składniki`.` katalogu (dla `..` bieżącego katalogu i dla katalogu nadrzędnego).</span><span class="sxs-lookup"><span data-stu-id="fcaac-181">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="fcaac-182">Przycina niektóre znaki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-182">Trims certain characters.</span></span>

<span data-ttu-id="fcaac-183">Ta normalizacja odbywa się niejawnie, ale można <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> to zrobić jawnie, wywołując metodę, która otacza wywołanie [getFullPathName() funkcji](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="fcaac-183">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="fcaac-184">[Funkcję GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) systemu Windows można również wywołać bezpośrednio przy użyciu funkcji P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="fcaac-184">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identifying-the-path"></a><span data-ttu-id="fcaac-185">Identyfikowanie ścieżki</span><span class="sxs-lookup"><span data-stu-id="fcaac-185">Identifying the path</span></span>

<span data-ttu-id="fcaac-186">Pierwszym krokiem w normalizacji ścieżki jest identyfikacja typu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-186">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="fcaac-187">Ścieżki dzielą się na jedną z kilku kategorii:</span><span class="sxs-lookup"><span data-stu-id="fcaac-187">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="fcaac-188">Są to ścieżki urządzeń; oznacza to, że zaczynają się od dwóch separatorów i znaku zapytania lub kropki (`\\?` lub `\\.`).</span><span class="sxs-lookup"><span data-stu-id="fcaac-188">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="fcaac-189">Są to ścieżki UNC; oznacza to, że zaczynają się od dwóch separatorów bez znaku zapytania lub kropki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-189">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="fcaac-190">Są to w pełni wykwalifikowane ścieżki DOS; oznacza to, że zaczynają się od litery dysku, separatora głośności i separatora komponentu (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="fcaac-190">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="fcaac-191">Wyznaczają one starsze`CON` `LPT1`urządzenie ( , ).</span><span class="sxs-lookup"><span data-stu-id="fcaac-191">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="fcaac-192">Są one względem katalogu głównego bieżącego dysku; oznacza to, że zaczynają się od`\`separatora pojedynczego komponentu ( ).</span><span class="sxs-lookup"><span data-stu-id="fcaac-192">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="fcaac-193">Są one względem bieżącego katalogu określonego dysku; oznacza to, że zaczynają się od litery dysku, separatora głośności i separatora komponentu (`C:`).</span><span class="sxs-lookup"><span data-stu-id="fcaac-193">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="fcaac-194">Są one względem bieżącego katalogu; oznacza to, że zaczynają`temp\testfile.txt`się od czegokolwiek innego ( ).</span><span class="sxs-lookup"><span data-stu-id="fcaac-194">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="fcaac-195">Typ ścieżki określa, czy bieżący katalog jest stosowany w jakiś sposób.</span><span class="sxs-lookup"><span data-stu-id="fcaac-195">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="fcaac-196">Określa również, co to jest "korzeń" ścieżki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-196">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="fcaac-197">Obsługa starszych urządzeń</span><span class="sxs-lookup"><span data-stu-id="fcaac-197">Handling legacy devices</span></span>

<span data-ttu-id="fcaac-198">Jeśli ścieżka jest starszym urządzeniem `CON` `COM1`DOS, takim jak , lub `LPT1`, `\\.\` jest konwertowana na ścieżkę urządzenia przez przedwtowienie i zwrócenie.</span><span class="sxs-lookup"><span data-stu-id="fcaac-198">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="fcaac-199">Ścieżka, która zaczyna się od starszej nazwy urządzenia, <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> jest zawsze interpretowana jako starsze urządzenie za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="fcaac-199">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="fcaac-200">Na przykład ścieżka urządzenia `CON.TXT` DOS dla jest `\\.\CON`, `COM1.TXT\file1.txt` a `\\.\COM1`ścieżka urządzenia DOS dla jest .</span><span class="sxs-lookup"><span data-stu-id="fcaac-200">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="fcaac-201">Stosowanie bieżącego katalogu</span><span class="sxs-lookup"><span data-stu-id="fcaac-201">Applying the current directory</span></span>

<span data-ttu-id="fcaac-202">Jeśli ścieżka nie jest w pełni kwalifikowana, system Windows zastosuje do niej bieżący katalog.</span><span class="sxs-lookup"><span data-stu-id="fcaac-202">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="fcaac-203">UnCs i ścieżki urządzeń nie mają zastosowanego bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-203">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="fcaac-204">Nie ma również pełnego napędu\\z separatorem C: .</span><span class="sxs-lookup"><span data-stu-id="fcaac-204">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="fcaac-205">Jeśli ścieżka zaczyna się od separatora pojedynczego komponentu, zostanie zastosowany dysk z bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-205">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="fcaac-206">Na przykład jeśli ścieżka `\utilities` pliku jest `C:\temp\`i bieżący katalog `C:\utilities`jest , normalizacja generuje .</span><span class="sxs-lookup"><span data-stu-id="fcaac-206">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="fcaac-207">Jeśli ścieżka zaczyna się od litery dysku, separatora woluminu i separatora bez komponentu, stosowany jest ostatni bieżący zestaw katalogów z powłoki poleceń dla określonego dysku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-207">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="fcaac-208">Jeśli ostatni bieżący katalog nie został ustawiony, stosowany jest sam dysk.</span><span class="sxs-lookup"><span data-stu-id="fcaac-208">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="fcaac-209">Na przykład, jeśli ścieżka pliku `D:sources`jest `C:\Documents\`, bieżący katalog jest , `D:\sources\`a ostatni `D:\sources\sources`bieżący katalog na dysku D: był , wynik jest .</span><span class="sxs-lookup"><span data-stu-id="fcaac-209">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="fcaac-210">Te ścieżki "dysku względnego" są częstym źródłem błędów logiki programu i skryptu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-210">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="fcaac-211">Zakładając, że ścieżka rozpoczynająca się literą i dwukropkiem nie jest względna, oczywiście nie jest poprawna.</span><span class="sxs-lookup"><span data-stu-id="fcaac-211">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="fcaac-212">Jeśli ścieżka zaczyna się od czegoś innego niż separator, stosuje się bieżący dysk i bieżący katalog.</span><span class="sxs-lookup"><span data-stu-id="fcaac-212">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="fcaac-213">Na przykład, jeśli `filecompare` ścieżka jest, `C:\utilities\`a bieżący `C:\utilities\filecompare\`katalog jest , wynik jest .</span><span class="sxs-lookup"><span data-stu-id="fcaac-213">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="fcaac-214">Ścieżki względne są niebezpieczne w aplikacjach wielowątkowych (czyli w większości aplikacji), ponieważ bieżący katalog jest ustawieniem dla procesu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-214">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="fcaac-215">Każdy wątek można zmienić bieżący katalog w dowolnym momencie.</span><span class="sxs-lookup"><span data-stu-id="fcaac-215">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="fcaac-216">Począwszy od .NET Core 2.1, można wywołać <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> metodę, aby uzyskać ścieżkę bezwzględną ze ścieżki względnej i ścieżki podstawowej (bieżącego katalogu), który ma zostać rozwiązany.</span><span class="sxs-lookup"><span data-stu-id="fcaac-216">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalizing-separators"></a><span data-ttu-id="fcaac-217">Separatory kanoniczne</span><span class="sxs-lookup"><span data-stu-id="fcaac-217">Canonicalizing separators</span></span>

<span data-ttu-id="fcaac-218">Wszystkie ukośniki`/`do przodu ( ) są konwertowane na`\`standardowy separator systemu Windows, ukośnik tylny ( ).</span><span class="sxs-lookup"><span data-stu-id="fcaac-218">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="fcaac-219">Jeśli są one obecne, seria ukośników, które następują po pierwszych dwóch ukośników są zwinięte w jednym ukośniki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-219">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="fcaac-220">Ocena składników względnych</span><span class="sxs-lookup"><span data-stu-id="fcaac-220">Evaluating relative components</span></span>

<span data-ttu-id="fcaac-221">Podczas przetwarzania ścieżki oceniane są wszystkie komponenty lub segmenty składające się z pojedynczego lub podwójnego okresu (`.` lub `..`)</span><span class="sxs-lookup"><span data-stu-id="fcaac-221">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="fcaac-222">Dla pojedynczego okresu bieżący segment jest usuwany, ponieważ odwołuje się do bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-222">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="fcaac-223">W przypadku podwójnego okresu bieżący segment i segment nadrzędny są usuwane, ponieważ podwójny okres odnosi się do katalogu nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="fcaac-223">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="fcaac-224">Katalogi nadrzędne są usuwane tylko wtedy, gdy nie są poza katalogiem głównym ścieżki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-224">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="fcaac-225">Katalog główny ścieżki zależy od typu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-225">The root of the path depends on the type of path.</span></span> <span data-ttu-id="fcaac-226">Jest to dysk`C:\`( ) dla ścieżek DOS,`\\Server\Share`serwer / udział dla UNC`\\?\` ( `\\.\`) i prefiks ścieżki urządzenia dla ścieżek urządzenia ( lub ).</span><span class="sxs-lookup"><span data-stu-id="fcaac-226">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="fcaac-227">Przycinanie znaków</span><span class="sxs-lookup"><span data-stu-id="fcaac-227">Trimming characters</span></span>

<span data-ttu-id="fcaac-228">Wraz z przebiegami separatorów i segmentów względnych usuniętych wcześniej, niektóre dodatkowe znaki są usuwane podczas normalizacji:</span><span class="sxs-lookup"><span data-stu-id="fcaac-228">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="fcaac-229">Jeśli segment kończy się w jednym okresie, ten okres jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="fcaac-229">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="fcaac-230">(Segment pojedynczego lub podwójnego okresu jest znormalizowany w poprzednim kroku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-230">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="fcaac-231">Segment trzech lub więcej okresów nie jest znormalizowany i w rzeczywistości jest prawidłową nazwą pliku/katalogu).</span><span class="sxs-lookup"><span data-stu-id="fcaac-231">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="fcaac-232">Jeśli ścieżka nie kończy się w separatorze, wszystkie końcowe okresy i spacje (U +0020) są usuwane.</span><span class="sxs-lookup"><span data-stu-id="fcaac-232">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="fcaac-233">Jeśli ostatni segment jest po prostu pojedynczylub podwójny okres, podlega względnej reguły składników powyżej.</span><span class="sxs-lookup"><span data-stu-id="fcaac-233">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="fcaac-234">Ta reguła oznacza, że można utworzyć nazwę katalogu z spacją końcowe, dodając separator końcowy po spację.</span><span class="sxs-lookup"><span data-stu-id="fcaac-234">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="fcaac-235">Nigdy **nie** należy tworzyć katalogu lub nazwy pliku z spacją końcowej.</span><span class="sxs-lookup"><span data-stu-id="fcaac-235">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="fcaac-236">Spacje końcowe mogą utrudniać lub uniemożliwiać dostęp do katalogu, a aplikacje często nie mogą obsługiwać katalogów lub plików, których nazwy zawierają spacje końcowe.</span><span class="sxs-lookup"><span data-stu-id="fcaac-236">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="fcaac-237">Pomijanie normalizacji</span><span class="sxs-lookup"><span data-stu-id="fcaac-237">Skipping normalization</span></span>

<span data-ttu-id="fcaac-238">Zwykle każda ścieżka przekazana do interfejsu API systemu Windows jest (skutecznie) przekazywana do [funkcji GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) i znormalizowana.</span><span class="sxs-lookup"><span data-stu-id="fcaac-238">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="fcaac-239">Jest jeden ważny wyjątek: ścieżka urządzenia, która zaczyna się od znaku zapytania zamiast kropki.</span><span class="sxs-lookup"><span data-stu-id="fcaac-239">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="fcaac-240">Chyba że ścieżka `\\?\` zaczyna się dokładnie od (zwróć uwagę na użycie kanonicznego ukośnika odwrotnego), jest znormalizowana.</span><span class="sxs-lookup"><span data-stu-id="fcaac-240">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="fcaac-241">Dlaczego chcesz pominąć normalizację?</span><span class="sxs-lookup"><span data-stu-id="fcaac-241">Why would you want to skip normalization?</span></span> <span data-ttu-id="fcaac-242">Istnieją trzy główne powody:</span><span class="sxs-lookup"><span data-stu-id="fcaac-242">There are three major reasons:</span></span>

1. <span data-ttu-id="fcaac-243">Aby uzyskać dostęp do ścieżek, które są zwykle niedostępne, ale są legalne.</span><span class="sxs-lookup"><span data-stu-id="fcaac-243">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="fcaac-244">Plik lub katalog `hidden.`o nazwie , na przykład, jest niemożliwe do uzyskania dostępu w jakikolwiek inny sposób.</span><span class="sxs-lookup"><span data-stu-id="fcaac-244">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="fcaac-245">Aby zwiększyć wydajność, pomijając normalizację, jeśli już znormalizowano.</span><span class="sxs-lookup"><span data-stu-id="fcaac-245">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="fcaac-246">Tylko w ramach .NET Framework, aby pominąć `MAX_PATH` sprawdzanie długości ścieżki, aby umożliwić ścieżki, które są większe niż 259 znaków.</span><span class="sxs-lookup"><span data-stu-id="fcaac-246">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="fcaac-247">Większość interfejsów API zezwala na to, z pewnymi wyjątkami.</span><span class="sxs-lookup"><span data-stu-id="fcaac-247">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="fcaac-248">Program .NET Core obsługuje długie ścieżki `MAX_PATH` niejawnie i nie wykonuje czeku.</span><span class="sxs-lookup"><span data-stu-id="fcaac-248">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="fcaac-249">Sprawdzanie `MAX_PATH` dotyczy tylko .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="fcaac-249">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="fcaac-250">Pomijanie normalizacji i max sprawdzanie ścieżki jest jedyną różnicą między składnią dwóch ścieżek urządzenia; w przeciwnym razie są identyczne.</span><span class="sxs-lookup"><span data-stu-id="fcaac-250">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="fcaac-251">Należy zachować ostrożność podczas pomijania normalizacji, ponieważ można łatwo tworzyć ścieżki, które są trudne do radzenia sobie z "normalnymi" aplikacjami.</span><span class="sxs-lookup"><span data-stu-id="fcaac-251">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="fcaac-252">Ścieżki, `\\?\` które zaczynają się nadal są znormalizowane, jeśli jawnie przekazać je do [GetFullPathName funkcji](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="fcaac-252">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="fcaac-253">Ścieżki o więcej `MAX_PATH` niż znakach można `\\?\`przekazywać do [getfullpathname](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) bez .</span><span class="sxs-lookup"><span data-stu-id="fcaac-253">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="fcaac-254">Obsługuje ścieżki dowolnej długości do maksymalnego rozmiaru ciągu, który może obsłużyć system Windows.</span><span class="sxs-lookup"><span data-stu-id="fcaac-254">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="fcaac-255">Sprawa i system plików Systemu Windows</span><span class="sxs-lookup"><span data-stu-id="fcaac-255">Case and the Windows file system</span></span>

<span data-ttu-id="fcaac-256">Osobliwością systemu plików Systemu Windows, że użytkownicy i deweloperzy spoza systemu Windows znaleźć mylące jest to, że ścieżki i nazwy katalogów są bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="fcaac-256">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="fcaac-257">Oznacza to, że nazwy katalogów i plików odzwierciedlają obudowę ciągów używanych podczas ich tworzenia.</span><span class="sxs-lookup"><span data-stu-id="fcaac-257">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="fcaac-258">Na przykład wywołanie metody</span><span class="sxs-lookup"><span data-stu-id="fcaac-258">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="fcaac-259">tworzy katalog o nazwie TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="fcaac-259">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="fcaac-260">Jeśli zmienisz nazwę katalogu lub pliku, aby zmienić jego sprawę, katalog lub nazwa pliku odzwierciedla przypadek ciągu używanego podczas zmiany jego nazwy.</span><span class="sxs-lookup"><span data-stu-id="fcaac-260">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="fcaac-261">Na przykład poniższy kod zmienia nazwę pliku o nazwie test.txt na Test.txt:</span><span class="sxs-lookup"><span data-stu-id="fcaac-261">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="fcaac-262">Jednak porównania nazw katalogów i plików są niewrażliwe na wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="fcaac-262">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="fcaac-263">Jeśli szukasz pliku o nazwie "test.txt", interfejsy API systemu plików .NET ignorują przypadek w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="fcaac-263">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="fcaac-264">Test.txt, TEST. TXT, test. TXT i każda inna kombinacja wielkich i małych liter będzie zgodna z "test.txt".</span><span class="sxs-lookup"><span data-stu-id="fcaac-264">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
