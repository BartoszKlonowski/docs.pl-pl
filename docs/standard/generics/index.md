---
title: Typy ogólne w .NET
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- generic methods, type inference
- generics [.NET Framework], collections
- generic interfaces [.NET Framework]
- constructed generic types
- nested generic types
- generic type definitions
- generic classes [.NET Framework]
- generics [.NET Framework], interfaces
- generics [.NET Framework], about
- generics [.NET Framework]
- generic collections [.NET Framework]
- generic delegates [.NET Framework]
- generic type arguments
- generics [.NET Framework], delegates
- generics [.NET Framework], features
- constraints [.NET Framework]
- generic types
- generic type parameters
ms.assetid: 2994d786-c5c7-4666-ab23-4c83129fe39c
ms.openlocfilehash: 7f20e5108ad8bff602f5b761e65f093d987f2608
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "78156312"
---
# <a name="generics-in-net"></a><span data-ttu-id="ec657-102">Typy ogólne w .NET</span><span class="sxs-lookup"><span data-stu-id="ec657-102">Generics in .NET</span></span>

<span data-ttu-id="ec657-103">Rodzajowe umożliwiają dostosowanie metody, klasy, struktury lub interfejsu do dokładnego typu danych, na który działa.</span><span class="sxs-lookup"><span data-stu-id="ec657-103">Generics let you tailor a method, class, structure, or interface to the precise data type it acts upon.</span></span> <span data-ttu-id="ec657-104">Na przykład zamiast <xref:System.Collections.Hashtable> używać klasy, która umożliwia klucze i wartości dowolnego <xref:System.Collections.Generic.Dictionary%602> typu, można użyć klasy ogólnej i określić typ dozwolony dla klucza i typ dozwolony dla wartości.</span><span class="sxs-lookup"><span data-stu-id="ec657-104">For example, instead of using the <xref:System.Collections.Hashtable> class, which allows keys and values to be of any type, you can use the <xref:System.Collections.Generic.Dictionary%602> generic class and specify the type allowed for the key and the type allowed for the value.</span></span> <span data-ttu-id="ec657-105">Wśród korzyści z leków generycznych są zwiększone ponownego użycia kodu i bezpieczeństwa typu.</span><span class="sxs-lookup"><span data-stu-id="ec657-105">Among the benefits of generics are increased code reusability and type safety.</span></span>  

## <a name="defining-and-using-generics"></a><span data-ttu-id="ec657-106">Definiowanie i używanie leków ogólnych</span><span class="sxs-lookup"><span data-stu-id="ec657-106">Defining and Using Generics</span></span>
 <span data-ttu-id="ec657-107">Rodzajowe są klasy, struktury, interfejsy i metody, które mają symbole zastępcze (parametry typu) dla jednego lub więcej typów, które przechowują lub używają.</span><span class="sxs-lookup"><span data-stu-id="ec657-107">Generics are classes, structures, interfaces, and methods that have placeholders (type parameters) for one or more of the types that they store or use.</span></span> <span data-ttu-id="ec657-108">Klasa kolekcji rodzajowej może używać parametru typu jako symbolu zastępczego dla typu obiektów, które przechowuje; parametry typu są wyświetlane jako typy jego pól i typy parametrów jego metod.</span><span class="sxs-lookup"><span data-stu-id="ec657-108">A generic collection class might use a type parameter as a placeholder for the type of objects that it stores; the type parameters appear as the types of its fields and the parameter types of its methods.</span></span> <span data-ttu-id="ec657-109">Metoda ogólna może używać jego parametr typu jako typ jego wartości zwracanej lub jako typ jednego z jego parametrów formalnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-109">A generic method might use its type parameter as the type of its return value or as the type of one of its formal parameters.</span></span> <span data-ttu-id="ec657-110">Poniższy kod ilustruje prostą definicję klasy ogólnej.</span><span class="sxs-lookup"><span data-stu-id="ec657-110">The following code illustrates a simple generic class definition.</span></span>  
  
 [!code-cpp[Conceptual.Generics.Overview#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#2)]
 [!code-csharp[Conceptual.Generics.Overview#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#2)]
 [!code-vb[Conceptual.Generics.Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#2)]  
  
 <span data-ttu-id="ec657-111">Podczas tworzenia wystąpienia klasy ogólnej należy określić rzeczywiste typy, które mają zastąpić parametry typu.</span><span class="sxs-lookup"><span data-stu-id="ec657-111">When you create an instance of a generic class, you specify the actual types to substitute for the type parameters.</span></span> <span data-ttu-id="ec657-112">Ustanawia nową klasę rodzajową, określaną jako skonstruowana klasa ogólna, z wybranymi typami podstawionymi wszędzie, gdy pojawiają się parametry typu.</span><span class="sxs-lookup"><span data-stu-id="ec657-112">This establishes a new generic class, referred to as a constructed generic class, with your chosen types substituted everywhere that the type parameters appear.</span></span> <span data-ttu-id="ec657-113">Wynik jest klasy bezpieczne typu, który jest dostosowany do wyboru typów, jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="ec657-113">The result is a type-safe class that is tailored to your choice of types, as the following code illustrates.</span></span>  
  
 [!code-cpp[Conceptual.Generics.Overview#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#3)]
 [!code-csharp[Conceptual.Generics.Overview#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#3)]
 [!code-vb[Conceptual.Generics.Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#3)]  

### <a name="generics-terminology"></a><span data-ttu-id="ec657-114">Terminologia rodzajowa</span><span class="sxs-lookup"><span data-stu-id="ec657-114">Generics terminology</span></span>  
 <span data-ttu-id="ec657-115">Następujące terminy są używane do omawiania leków generycznych w .NET:</span><span class="sxs-lookup"><span data-stu-id="ec657-115">The following terms are used to discuss generics in .NET:</span></span>  
  
- <span data-ttu-id="ec657-116">*Definicja typu ogólnego* jest deklaracją klasy, struktury lub interfejsu, która działa jako szablon, z symbolami zastępczymi dla typów, które mogą zawierać lub używać.</span><span class="sxs-lookup"><span data-stu-id="ec657-116">A *generic type definition* is a class, structure, or interface declaration that functions as a template, with placeholders for the types that it can contain or use.</span></span> <span data-ttu-id="ec657-117">Na przykład <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> klasa może zawierać dwa typy: klucze i wartości.</span><span class="sxs-lookup"><span data-stu-id="ec657-117">For example, the <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> class can contain two types: keys and values.</span></span> <span data-ttu-id="ec657-118">Ponieważ definicja typu ogólnego jest tylko szablonem, nie można tworzyć wystąpień klasy, struktury lub interfejsu, który jest definicją typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="ec657-118">Because a generic type definition is only a template, you cannot create instances of a class, structure, or interface that is a generic type definition.</span></span>  
  
- <span data-ttu-id="ec657-119">*Ogólne parametry typu*lub parametry typu są *symbolami zastępczymi*w definicji typu ogólnego lub metody.</span><span class="sxs-lookup"><span data-stu-id="ec657-119">*Generic type parameters*, or *type parameters*, are the placeholders in a generic type or method definition.</span></span> <span data-ttu-id="ec657-120">Typ <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> ogólny ma dwa parametry `TKey` `TValue`typu i , które reprezentują typy jego kluczy i wartości.</span><span class="sxs-lookup"><span data-stu-id="ec657-120">The <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> generic type has two type parameters, `TKey` and `TValue`, that represent the types of its keys and values.</span></span>  
  
- <span data-ttu-id="ec657-121">*Skonstruowany typ rodzajowy*lub *typ konstruowany*jest wynikiem określania typów dla parametrów typu ogólnego definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="ec657-121">A *constructed generic type*, or *constructed type*, is the result of specifying types for the generic type parameters of a generic type definition.</span></span>  
  
- <span data-ttu-id="ec657-122">Argument *typu ogólnego* jest dowolnym typem, który jest zastępowany parametrem typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="ec657-122">A *generic type argument* is any type that is substituted for a generic type parameter.</span></span>  
  
- <span data-ttu-id="ec657-123">Termin *ogólny ogólny termin* obejmuje zarówno skonstruowane typy i definicje typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-123">The general term *generic type* includes both constructed types and generic type definitions.</span></span>  
  
- <span data-ttu-id="ec657-124">*Kowariancja* i *kontrawariancja* parametrów typu ogólnego umożliwiają użycie skonstruowanych typów ogólnych, których argumenty typu są bardziej pochodne (kowariancja) lub mniej pochodne (contravariance) niż typ konstruowany obiekt docelowy.</span><span class="sxs-lookup"><span data-stu-id="ec657-124">*Covariance* and *contravariance* of generic type parameters enable you to use constructed generic types whose type arguments are more derived (covariance) or less derived (contravariance) than a target constructed type.</span></span> <span data-ttu-id="ec657-125">Kowariancja i kontrawariancja są zbiorczo określane jako *wariancja*.</span><span class="sxs-lookup"><span data-stu-id="ec657-125">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="ec657-126">Aby uzyskać więcej informacji, zobacz [Kowariancja i wariancja](../../../docs/standard/generics/covariance-and-contravariance.md).</span><span class="sxs-lookup"><span data-stu-id="ec657-126">For more information, see [Covariance and Contravariance](../../../docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
- <span data-ttu-id="ec657-127">*Ograniczenia* są limity umieszczone na parametrach typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="ec657-127">*Constraints* are limits placed on generic type parameters.</span></span> <span data-ttu-id="ec657-128">Na przykład można ograniczyć parametr typu do <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> typów, które implementują interfejs ogólny, aby upewnić się, że można zamówić wystąpienia typu.</span><span class="sxs-lookup"><span data-stu-id="ec657-128">For example, you might limit a type parameter to types that implement the <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> generic interface, to ensure that instances of the type can be ordered.</span></span> <span data-ttu-id="ec657-129">Można również ograniczyć parametry typu do typów, które mają określoną klasę podstawową, które mają konstruktora bezparametrowego lub które są typami odwołań lub typami wartości.</span><span class="sxs-lookup"><span data-stu-id="ec657-129">You can also constrain type parameters to types that have a particular base class, that have a parameterless constructor, or that are reference types or value types.</span></span> <span data-ttu-id="ec657-130">Użytkownicy typu ogólnego nie mogą zastąpić argumentów typu, które nie spełniają ograniczeń.</span><span class="sxs-lookup"><span data-stu-id="ec657-130">Users of the generic type cannot substitute type arguments that do not satisfy the constraints.</span></span>  
  
- <span data-ttu-id="ec657-131">*Definicja metody ogólnej* jest metodą z dwiema listami parametrów: listą parametrów typu ogólnego i listą parametrów formalnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-131">A *generic method definition* is a method with two parameter lists: a list of generic type parameters and a list of formal parameters.</span></span> <span data-ttu-id="ec657-132">Parametry typu mogą być wyświetlane jako typ zwracany lub jako typy parametrów formalnych, jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="ec657-132">Type parameters can appear as the return type or as the types of the formal parameters, as the following code shows.</span></span>  
  
 [!code-cpp[Conceptual.Generics.Overview#4](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#4)]
 [!code-csharp[Conceptual.Generics.Overview#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#4)]
 [!code-vb[Conceptual.Generics.Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#4)]  
  
 <span data-ttu-id="ec657-133">Metody ogólne mogą być wyświetlane w typach ogólnych lub nieogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-133">Generic methods can appear on generic or nongeneric types.</span></span> <span data-ttu-id="ec657-134">Należy pamiętać, że metoda nie jest ogólny tylko dlatego, że należy do typu ogólnego, a nawet dlatego, że ma parametry formalne, których typy są parametrami ogólnymi typu otaczającego.</span><span class="sxs-lookup"><span data-stu-id="ec657-134">It is important to note that a method is not generic just because it belongs to a generic type, or even because it has formal parameters whose types are the generic parameters of the enclosing type.</span></span> <span data-ttu-id="ec657-135">Metoda jest ogólna tylko wtedy, gdy ma własną listę parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="ec657-135">A method is generic only if it has its own list of type parameters.</span></span> <span data-ttu-id="ec657-136">W poniższym kodzie `G` tylko metoda jest ogólny.</span><span class="sxs-lookup"><span data-stu-id="ec657-136">In the following code, only method `G` is generic.</span></span>  
  
 [!code-cpp[Conceptual.Generics.Overview#5](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#5)]
 [!code-csharp[Conceptual.Generics.Overview#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#5)]
 [!code-vb[Conceptual.Generics.Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#5)]  
  
## <a name="advantages-and-disadvantages-of-generics"></a><span data-ttu-id="ec657-137">Zalety i wady leków generycznych</span><span class="sxs-lookup"><span data-stu-id="ec657-137">Advantages and disadvantages of generics</span></span>
 <span data-ttu-id="ec657-138">Istnieje wiele zalet korzystania z kolekcji ogólnych i delegatów:</span><span class="sxs-lookup"><span data-stu-id="ec657-138">There are many advantages to using generic collections and delegates:</span></span>  
  
- <span data-ttu-id="ec657-139">Bezpieczeństwo typu.</span><span class="sxs-lookup"><span data-stu-id="ec657-139">Type safety.</span></span> <span data-ttu-id="ec657-140">Rodzajowe przesunięcie obciążenia bezpieczeństwa typu z ciebie do kompilatora.</span><span class="sxs-lookup"><span data-stu-id="ec657-140">Generics shift the burden of type safety from you to the compiler.</span></span> <span data-ttu-id="ec657-141">Nie ma potrzeby pisania kodu do testowania dla prawidłowego typu danych, ponieważ jest wymuszany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="ec657-141">There is no need to write code to test for the correct data type because it is enforced at compile time.</span></span> <span data-ttu-id="ec657-142">Zmniejsza się potrzeba rzutowania typu i możliwość błędów w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="ec657-142">The need for type casting and the possibility of run-time errors are reduced.</span></span>  
  
- <span data-ttu-id="ec657-143">Mniej kodu i kodu jest łatwiej ponownie używane.</span><span class="sxs-lookup"><span data-stu-id="ec657-143">Less code and code is more easily reused.</span></span> <span data-ttu-id="ec657-144">Nie ma potrzeby dziedziczenia z typu podstawowego i zastępowania elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="ec657-144">There is no need to inherit from a base type and override members.</span></span> <span data-ttu-id="ec657-145">Na przykład <xref:System.Collections.Generic.LinkedList%601> jest gotowy do natychmiastowego użycia.</span><span class="sxs-lookup"><span data-stu-id="ec657-145">For example, the <xref:System.Collections.Generic.LinkedList%601> is ready for immediate use.</span></span> <span data-ttu-id="ec657-146">Na przykład można utworzyć połączoną listę ciągów z następującą deklaracją zmiennej:</span><span class="sxs-lookup"><span data-stu-id="ec657-146">For example, you can create a linked list of strings with the following variable declaration:</span></span>  
  
     [!code-cpp[HowToGeneric#24](../../../samples/snippets/cpp/VS_Snippets_CLR/HowToGeneric/cpp/source2.cpp#24)]
     [!code-csharp[HowToGeneric#24](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToGeneric/CS/source2.cs#24)]
     [!code-vb[HowToGeneric#24](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToGeneric/VB/source2.vb#24)]  
  
- <span data-ttu-id="ec657-147">Lepsza wydajność.</span><span class="sxs-lookup"><span data-stu-id="ec657-147">Better performance.</span></span> <span data-ttu-id="ec657-148">Typy kolekcji ogólnych zazwyczaj działają lepiej do przechowywania i manipulowania typami wartości, ponieważ nie ma potrzeby, aby pole typów wartości.</span><span class="sxs-lookup"><span data-stu-id="ec657-148">Generic collection types generally perform better for storing and manipulating value types because there is no need to box the value types.</span></span>  
  
- <span data-ttu-id="ec657-149">Delegaci rodzajowy włączyć wywołania wywołań wywołania oparte na typie bez konieczności tworzenia wielu klas delegata.</span><span class="sxs-lookup"><span data-stu-id="ec657-149">Generic delegates enable type-safe callbacks without the need to create multiple delegate classes.</span></span> <span data-ttu-id="ec657-150">Na przykład <xref:System.Predicate%601> ogólny delegat umożliwia utworzenie metody, która implementuje własne kryteria wyszukiwania dla określonego typu i <xref:System.Array> używać metody <xref:System.Array.Find%2A> <xref:System.Array.FindLast%2A>z <xref:System.Array.FindAll%2A>metodami typu, takimi jak , i .</span><span class="sxs-lookup"><span data-stu-id="ec657-150">For example, the <xref:System.Predicate%601> generic delegate allows you to create a method that implements your own search criteria for a particular type and to use your method with methods of the <xref:System.Array> type such as <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A>.</span></span>  
  
- <span data-ttu-id="ec657-151">Rodzajowe usprawnić dynamicznie generowany kod.</span><span class="sxs-lookup"><span data-stu-id="ec657-151">Generics streamline dynamically generated code.</span></span> <span data-ttu-id="ec657-152">Korzystając z typów ogólnych z dynamicznie generowanym kodem, nie trzeba generować tego typu.</span><span class="sxs-lookup"><span data-stu-id="ec657-152">When you use generics with dynamically generated code you do not need to generate the type.</span></span> <span data-ttu-id="ec657-153">Zwiększa to liczbę scenariuszy, w których można użyć lekkich metod dynamicznych zamiast generowania całych zestawów.</span><span class="sxs-lookup"><span data-stu-id="ec657-153">This increases the number of scenarios in which you can use lightweight dynamic methods instead of generating entire assemblies.</span></span> <span data-ttu-id="ec657-154">Aby uzyskać więcej informacji, zobacz [Jak: Definiowanie i wykonywanie metod dynamicznych](../../../docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md) i <xref:System.Reflection.Emit.DynamicMethod>.</span><span class="sxs-lookup"><span data-stu-id="ec657-154">For more information, see [How to: Define and Execute Dynamic Methods](../../../docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md) and <xref:System.Reflection.Emit.DynamicMethod>.</span></span>  
  
 <span data-ttu-id="ec657-155">Oto pewne ograniczenia leków generycznych:</span><span class="sxs-lookup"><span data-stu-id="ec657-155">The following are some limitations of generics:</span></span>  
  
- <span data-ttu-id="ec657-156">Typy ogólne mogą pochodzić z większości <xref:System.MarshalByRefObject> klas podstawowych, takich jak (i ograniczenia mogą być używane <xref:System.MarshalByRefObject>do wymagania, że ogólne parametry typu pochodzą z klas podstawowych, takich jak ).</span><span class="sxs-lookup"><span data-stu-id="ec657-156">Generic types can be derived from most base classes, such as <xref:System.MarshalByRefObject> (and constraints can be used to require that generic type parameters derive from base classes like <xref:System.MarshalByRefObject>).</span></span> <span data-ttu-id="ec657-157">Jednak .NET Framework nie obsługuje typów ogólnych związanych z kontekstem.</span><span class="sxs-lookup"><span data-stu-id="ec657-157">However, the .NET Framework does not support context-bound generic types.</span></span> <span data-ttu-id="ec657-158">Typ ogólny można wyprowadzić z <xref:System.ContextBoundObject>, ale próba utworzenia <xref:System.TypeLoadException>wystąpienia tego typu powoduje .</span><span class="sxs-lookup"><span data-stu-id="ec657-158">A generic type can be derived from <xref:System.ContextBoundObject>, but trying to create an instance of that type causes a <xref:System.TypeLoadException>.</span></span>  
  
- <span data-ttu-id="ec657-159">Wyliczenia nie mogą mieć parametrów typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="ec657-159">Enumerations cannot have generic type parameters.</span></span> <span data-ttu-id="ec657-160">Wyliczenie może być ogólne tylko przypadkowo (na przykład, ponieważ jest zagnieżdżony w typogólny, który jest zdefiniowany przy użyciu języka Visual Basic, C#lub C++).</span><span class="sxs-lookup"><span data-stu-id="ec657-160">An enumeration can be generic only incidentally (for example, because it is nested in a generic type that is defined using Visual Basic, C#, or C++).</span></span> <span data-ttu-id="ec657-161">Aby uzyskać więcej informacji, zobacz "Wyliczenia" w [systemie typu wspólnego](../../../docs/standard/base-types/common-type-system.md).</span><span class="sxs-lookup"><span data-stu-id="ec657-161">For more information, see "Enumerations" in [Common Type System](../../../docs/standard/base-types/common-type-system.md).</span></span>  
  
- <span data-ttu-id="ec657-162">Lekkie metody dynamiczne nie mogą być ogólne.</span><span class="sxs-lookup"><span data-stu-id="ec657-162">Lightweight dynamic methods cannot be generic.</span></span>  
  
- <span data-ttu-id="ec657-163">W języku Visual Basic, C#i C++, zagnieżdżony typ, który jest ujęty w typ ogólny, nie może zostać uprzednio użyzczony, chyba że typy zostały przypisane do parametrów typu wszystkich typów otaczających.</span><span class="sxs-lookup"><span data-stu-id="ec657-163">In Visual Basic, C#, and C++, a nested type that is enclosed in a generic type cannot be instantiated unless types have been assigned to the type parameters of all enclosing types.</span></span> <span data-ttu-id="ec657-164">Innym sposobem na powiedzenie jest to, że w odbiciu, zagnieżdżony typ, który jest zdefiniowany przy użyciu tych języków zawiera parametry typu wszystkich jego typów otaczających.</span><span class="sxs-lookup"><span data-stu-id="ec657-164">Another way of saying this is that in reflection, a nested type that is defined using these languages includes the type parameters of all its enclosing types.</span></span> <span data-ttu-id="ec657-165">Dzięki temu parametry typu otaczającego typy mają być używane w definicjach elementów członkowskich typu zagnieżdżonego.</span><span class="sxs-lookup"><span data-stu-id="ec657-165">This allows the type parameters of enclosing types to be used in the member definitions of a nested type.</span></span> <span data-ttu-id="ec657-166">Aby uzyskać więcej informacji, zobacz <xref:System.Type.MakeGenericType%2A>"Typy zagnieżdżone" w .</span><span class="sxs-lookup"><span data-stu-id="ec657-166">For more information, see "Nested Types" in <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="ec657-167">Typ zagnieżdżony, który jest zdefiniowany przez emitowanie kodu w zestawie dynamicznym lub przy użyciu [Ilasm.exe (IL Asembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) nie jest wymagane do uwzględnienia parametrów typu jego otaczającego typów; jednak jeśli nie zawiera ich, parametry typu nie są w zakresie w klasie zagnieżdżonej.</span><span class="sxs-lookup"><span data-stu-id="ec657-167">A nested type that is defined by emitting code in a dynamic assembly or by using the [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) is not required to include the type parameters of its enclosing types; however, if it does not include them, the type parameters are not in scope in the nested class.</span></span>  
  
     <span data-ttu-id="ec657-168">Aby uzyskać więcej informacji, zobacz <xref:System.Type.MakeGenericType%2A>"Typy zagnieżdżone" w .</span><span class="sxs-lookup"><span data-stu-id="ec657-168">For more information, see "Nested Types" in <xref:System.Type.MakeGenericType%2A>.</span></span>  

## <a name="class-library-and-language-support"></a><span data-ttu-id="ec657-169">Biblioteka klas i obsługa języków</span><span class="sxs-lookup"><span data-stu-id="ec657-169">Class Library and Language Support</span></span>  
 <span data-ttu-id="ec657-170">.NET udostępnia szereg ogólnych klas kolekcji w następujących przestrzeniach nazw:</span><span class="sxs-lookup"><span data-stu-id="ec657-170">.NET provides a number of generic collection classes in the following namespaces:</span></span>  
  
- <span data-ttu-id="ec657-171">Obszar <xref:System.Collections.Generic> nazw zawiera większość typów kolekcji ogólnych dostarczonych <xref:System.Collections.Generic.List%601> przez <xref:System.Collections.Generic.Dictionary%602> .NET, takich jak i klas ogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-171">The <xref:System.Collections.Generic> namespace contains most of the generic collection types provided by .NET, such as the <xref:System.Collections.Generic.List%601> and <xref:System.Collections.Generic.Dictionary%602> generic classes.</span></span>  
  
- <span data-ttu-id="ec657-172">Obszar <xref:System.Collections.ObjectModel> nazw zawiera dodatkowe typy kolekcji <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> rodzajowych, takich jak klasa ogólna, które są przydatne do ujawniania modeli obiektów dla użytkowników klas.</span><span class="sxs-lookup"><span data-stu-id="ec657-172">The <xref:System.Collections.ObjectModel> namespace contains additional generic collection types, such as the <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> generic class, that are useful for exposing object models to users of your classes.</span></span>  
  
 <span data-ttu-id="ec657-173">Ogólne interfejsy do implementowania porównań sortowania i równości są dostarczane w obszarze <xref:System> nazw, wraz z ogólnymi typami delegatów dla programów obsługi zdarzeń, konwersji i predykatów wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ec657-173">Generic interfaces for implementing sort and equality comparisons are provided in the <xref:System> namespace, along with generic delegate types for event handlers, conversions, and search predicates.</span></span>  
  
 <span data-ttu-id="ec657-174">Obsługa typów ogólnych została <xref:System.Reflection> dodana do obszaru nazw do badania <xref:System.Reflection.Emit> typów ogólnych i metod ogólnych, do emitowania zestawów dynamicznych, które zawierają typy ogólne i metody, a także do <xref:System.CodeDom> generowania wykresów źródłowych, które zawierają generycznych.</span><span class="sxs-lookup"><span data-stu-id="ec657-174">Support for generics has been added to the <xref:System.Reflection> namespace for examining generic types and generic methods, to <xref:System.Reflection.Emit> for emitting dynamic assemblies that contain generic types and methods, and to <xref:System.CodeDom> for generating source graphs that include generics.</span></span>  
  
 <span data-ttu-id="ec657-175">Czas wykonywania języka wspólnego zawiera nowe opcodes i prefiksy do obsługi <xref:System.Reflection.Emit.OpCodes.Stelem> <xref:System.Reflection.Emit.OpCodes.Ldelem>typów <xref:System.Reflection.Emit.OpCodes.Unbox_Any> <xref:System.Reflection.Emit.OpCodes.Constrained>ogólnych <xref:System.Reflection.Emit.OpCodes.Readonly>w języku pośrednim firmy Microsoft (MSIL), w tym , , , , i .</span><span class="sxs-lookup"><span data-stu-id="ec657-175">The common language runtime provides new opcodes and prefixes to support generic types in Microsoft intermediate language (MSIL), including <xref:System.Reflection.Emit.OpCodes.Stelem>, <xref:System.Reflection.Emit.OpCodes.Ldelem>, <xref:System.Reflection.Emit.OpCodes.Unbox_Any>, <xref:System.Reflection.Emit.OpCodes.Constrained>, and <xref:System.Reflection.Emit.OpCodes.Readonly>.</span></span>  
  
 <span data-ttu-id="ec657-176">Visual C++, C# i Visual Basic zapewniają pełną obsługę definiowania i używania leków ogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-176">Visual C++, C#, and Visual Basic all provide full support for defining and using generics.</span></span> <span data-ttu-id="ec657-177">Aby uzyskać więcej informacji na temat obsługi języka, zobacz [Typy ogólne w języku Visual Basic](../../visual-basic/programming-guide/language-features/data-types/generic-types.md), Wprowadzenie do leków [ogólnych](../../csharp/programming-guide/generics/index.md)i [Omówienie typów ogólnych w języku Visual C++](/cpp/windows/overview-of-generics-in-visual-cpp).</span><span class="sxs-lookup"><span data-stu-id="ec657-177">For more information about language support, see [Generic Types in Visual Basic](../../visual-basic/programming-guide/language-features/data-types/generic-types.md), [Introduction to Generics](../../csharp/programming-guide/generics/index.md), and [Overview of Generics in Visual C++](/cpp/windows/overview-of-generics-in-visual-cpp).</span></span>

## <a name="nested-types-and-generics"></a><span data-ttu-id="ec657-178">Typy zagnieżdżone i generyki</span><span class="sxs-lookup"><span data-stu-id="ec657-178">Nested Types and Generics</span></span>  
 <span data-ttu-id="ec657-179">Typ, który jest zagnieżdżony w typie rodzajowym może zależeć od parametrów typu otaczającego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="ec657-179">A type that is nested in a generic type can depend on the type parameters of the enclosing generic type.</span></span> <span data-ttu-id="ec657-180">Czas wykonywania języka wspólnego uważa zagnieżdżonych typów jest ogólny, nawet jeśli nie mają parametrów typu ogólnego własnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-180">The common language runtime considers nested types to be generic, even if they do not have generic type parameters of their own.</span></span> <span data-ttu-id="ec657-181">Podczas tworzenia wystąpienia typu zagnieżdżonego należy określić argumenty typu dla wszystkich otaczających typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-181">When you create an instance of a nested type, you must specify type arguments for all enclosing generic types.</span></span>  

## <a name="related-topics"></a><span data-ttu-id="ec657-182">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="ec657-182">Related Topics</span></span>  
  
|<span data-ttu-id="ec657-183">Tytuł</span><span class="sxs-lookup"><span data-stu-id="ec657-183">Title</span></span>|<span data-ttu-id="ec657-184">Opis</span><span class="sxs-lookup"><span data-stu-id="ec657-184">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="ec657-185">Kolekcje ogólne w .NET</span><span class="sxs-lookup"><span data-stu-id="ec657-185">Generic Collections in .NET</span></span>](../../../docs/standard/generics/collections.md)|<span data-ttu-id="ec657-186">Opisuje ogólne klasy kolekcji i inne typy ogólne w .NET.</span><span class="sxs-lookup"><span data-stu-id="ec657-186">Describes generic collection classes and other generic types in .NET.</span></span>|  
|[<span data-ttu-id="ec657-187">Delegaty ogólne do manipulowania tablicami i listami</span><span class="sxs-lookup"><span data-stu-id="ec657-187">Generic Delegates for Manipulating Arrays and Lists</span></span>](../../../docs/standard/generics/delegates-for-manipulating-arrays-and-lists.md)|<span data-ttu-id="ec657-188">Opisuje ogólnych delegatów dla konwersji, predykatów wyszukiwania i akcje, które mają być podjęte na elementy tablicy lub kolekcji.</span><span class="sxs-lookup"><span data-stu-id="ec657-188">Describes generic delegates for conversions, search predicates, and actions to be taken on elements of an array or collection.</span></span>|  
|[<span data-ttu-id="ec657-189">Interfejsy ogólne</span><span class="sxs-lookup"><span data-stu-id="ec657-189">Generic Interfaces</span></span>](../../../docs/standard/generics/interfaces.md)|<span data-ttu-id="ec657-190">Opisuje ogólne interfejsy, które zapewniają typowe funkcje dla rodzin typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-190">Describes generic interfaces that provide common functionality across families of generic types.</span></span>|  
|[<span data-ttu-id="ec657-191">Kowariancja i kontrawariancja</span><span class="sxs-lookup"><span data-stu-id="ec657-191">Covariance and Contravariance</span></span>](../../../docs/standard/generics/covariance-and-contravariance.md)|<span data-ttu-id="ec657-192">Opisuje kowariancję i kontrawariancję w parametrach typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="ec657-192">Describes covariance and contravariance in generic type parameters.</span></span>|  
|[<span data-ttu-id="ec657-193">Często używane typy kolekcji</span><span class="sxs-lookup"><span data-stu-id="ec657-193">Commonly Used Collection Types</span></span>](../../../docs/standard/collections/commonly-used-collection-types.md)|<span data-ttu-id="ec657-194">Zawiera podsumowanie informacji o właściwościach i scenariuszach użycia typów kolekcji w .NET, w tym typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-194">Provides summary information about the characteristics and usage scenarios of the collection types in .NET, including generic types.</span></span>|  
|[<span data-ttu-id="ec657-195">Kiedy należy używać kolekcji ogólnych</span><span class="sxs-lookup"><span data-stu-id="ec657-195">When to Use Generic Collections</span></span>](../../../docs/standard/collections/when-to-use-generic-collections.md)|<span data-ttu-id="ec657-196">Opisuje ogólne reguły określania, kiedy używać typów kolekcji rodzajowych.</span><span class="sxs-lookup"><span data-stu-id="ec657-196">Describes general rules for determining when to use generic collection types.</span></span>|  
|[<span data-ttu-id="ec657-197">Instrukcje: definiowanie typu ogólnego przy użyciu emisji odbicia</span><span class="sxs-lookup"><span data-stu-id="ec657-197">How to: Define a Generic Type with Reflection Emit</span></span>](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)|<span data-ttu-id="ec657-198">W tym artykule wyjaśniono, jak generować zestawy dynamiczne, które zawierają typy ogólne i metody.</span><span class="sxs-lookup"><span data-stu-id="ec657-198">Explains how to generate dynamic assemblies that include generic types and methods.</span></span>|  
|[<span data-ttu-id="ec657-199">Typy ogólne w języku Visual Basic</span><span class="sxs-lookup"><span data-stu-id="ec657-199">Generic Types in Visual Basic</span></span>](../../visual-basic/programming-guide/language-features/data-types/generic-types.md)|<span data-ttu-id="ec657-200">W tym artykule opisano funkcję rodzajową dla użytkowników języka Visual Basic, w tym tematy inkanderiów dotyczące używania i definiowania typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="ec657-200">Describes the generics feature for Visual Basic users, including how-to topics for using and defining generic types.</span></span>|  
|[<span data-ttu-id="ec657-201">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="ec657-201">Introduction to Generics</span></span>](../../csharp/programming-guide/generics/index.md)|<span data-ttu-id="ec657-202">Zawiera omówienie definiowania i używania typów ogólnych dla użytkowników języka C#.</span><span class="sxs-lookup"><span data-stu-id="ec657-202">Provides an overview of defining and using generic types for C# users.</span></span>|  
|[<span data-ttu-id="ec657-203">Przegląd typów ogólnych w Visual C++</span><span class="sxs-lookup"><span data-stu-id="ec657-203">Overview of Generics in Visual C++</span></span>](/cpp/windows/overview-of-generics-in-visual-cpp)|<span data-ttu-id="ec657-204">Opisuje funkcję rodzajowy dla użytkowników języka C++, w tym różnice między rodzajowymi i szablonami.</span><span class="sxs-lookup"><span data-stu-id="ec657-204">Describes the generics feature for C++ users, including the differences between generics and templates.</span></span>|  

## <a name="reference"></a><span data-ttu-id="ec657-205">Dokumentacja</span><span class="sxs-lookup"><span data-stu-id="ec657-205">Reference</span></span>  
 <xref:System.Collections.Generic>  
  
 <xref:System.Collections.ObjectModel>  
  
 <xref:System.Reflection.Emit.OpCodes?displayProperty=nameWithType>  
