---
title: Kowariancja i kontrawariancja w typach ogólnych
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
author: mairaw
ms.author: mairaw
ms.openlocfilehash: fa4b8fdd56ed8a1304b6ee436ce3391c52ae7b9d
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/28/2019
ms.locfileid: "64622737"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="a035b-102">Kowariancja i kontrawariancja w typach ogólnych</span><span class="sxs-lookup"><span data-stu-id="a035b-102">Covariance and Contravariance in Generics</span></span>
<a name="top"></a> <span data-ttu-id="a035b-103">Kowariancja i kontrawariancja to terminy odwołujące się do możliwość używania typu bardziej pochodnego (bardziej szczegółowe) lub mniej pochodnego typu (specyficzne dla języka less) niż oryginalnie określony.</span><span class="sxs-lookup"><span data-stu-id="a035b-103">Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="a035b-104">Parametry typu ogólnego obsługują kowariancję i kontrawariancję, aby umożliwić większą elastyczność przypisywania i używania typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="a035b-104">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span> <span data-ttu-id="a035b-105">W kontekście systemu typów kowariancja, kontrawariancja i inwariancja mają następujące definicje.</span><span class="sxs-lookup"><span data-stu-id="a035b-105">When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="a035b-106">W przykładach założono, klasa bazowa o nazwie `Base` i Klasa pochodna o nazwie `Derived`.</span><span class="sxs-lookup"><span data-stu-id="a035b-106">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="a035b-107">Umożliwia użycie typu bardziej pochodnego niż oryginalnie określony.</span><span class="sxs-lookup"><span data-stu-id="a035b-107">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="a035b-108">Możesz przypisać wystąpienie `IEnumerable<Derived>` (`IEnumerable(Of Derived)` w języku Visual Basic) do zmiennej typu `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="a035b-108">You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="a035b-109">Umożliwia użycie bardziej ogólnego (mniej pochodnego) typu niż oryginalnie określony.</span><span class="sxs-lookup"><span data-stu-id="a035b-109">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="a035b-110">Możesz przypisać wystąpienie `Action<Base>` (`Action(Of Base)` w języku Visual Basic) do zmiennej typu `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="a035b-110">You can assign an instance of `Action<Base>` (`Action(Of Base)` in Visual Basic) to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="a035b-111">Oznacza, że można użyć tylko oryginalnie określonego typu, więc inwariantny parametr typu ogólnego nie jest ani kowariantny, ani kontrawariantny.</span><span class="sxs-lookup"><span data-stu-id="a035b-111">Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="a035b-112">Nie można przypisać wystąpienie `List<Base>` (`List(Of Base)` w języku Visual Basic) do zmiennej typu `List<Derived>` lub na odwrót.</span><span class="sxs-lookup"><span data-stu-id="a035b-112">You cannot assign an instance of `List<Base>` (`List(Of Base)` in Visual Basic) to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="a035b-113">Kowariantne parametry typu umożliwiają wykonywanie przypisań przypominających zwykły [polimorfizm](~/docs/csharp/programming-guide/classes-and-structs/polymorphism.md), jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="a035b-113">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](~/docs/csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="a035b-114"><xref:System.Collections.Generic.List%601> Klasy implementuje <xref:System.Collections.Generic.IEnumerable%601> interfejsu, więc `List<Derived>` (`List(Of Derived)` w języku Visual Basic) implementuje `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="a035b-114">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="a035b-115">Kowariantny parametr typu wykonuje resztę zadania.</span><span class="sxs-lookup"><span data-stu-id="a035b-115">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="a035b-116">Z drugiej strony, kontrawariancja wydaje się nielogiczna.</span><span class="sxs-lookup"><span data-stu-id="a035b-116">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="a035b-117">Poniższy przykład tworzy delegat typu `Action<Base>` (`Action(Of Base)` w języku Visual Basic), a następnie ten delegat jest przypisywany do zmiennej typu `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="a035b-117">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="a035b-118">Wydaje się to wsteczne, ale jest to bezpieczny dla typów kod, który można skompilować i uruchomić.</span><span class="sxs-lookup"><span data-stu-id="a035b-118">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="a035b-119">Wyrażenie lambda zgodnego z delegatem, jest ona przypisana do użytkownika, więc definiuje metodę przyjmującą jeden parametr typu `Base` i która nie zwraca żadnej wartości.</span><span class="sxs-lookup"><span data-stu-id="a035b-119">The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="a035b-120">Wynikowego delegata można przypisać do zmiennej typu `Action<Derived>` ponieważ parametr typu `T` z <xref:System.Action%601> delegata jest kontrawariantny.</span><span class="sxs-lookup"><span data-stu-id="a035b-120">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="a035b-121">Kod jest bezpieczny ponieważ `T` Określa typ parametru.</span><span class="sxs-lookup"><span data-stu-id="a035b-121">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="a035b-122">Gdy delegat typu `Action<Base>` jest wywoływany tak, jakby był delegatem typu `Action<Derived>`, jego argument musi być typu `Derived`.</span><span class="sxs-lookup"><span data-stu-id="a035b-122">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="a035b-123">Ten argument zawsze można bezpiecznie przekazać do metody podstawowej, ponieważ parametr metody jest kolumną typu `Base`.</span><span class="sxs-lookup"><span data-stu-id="a035b-123">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="a035b-124">Ogólnie, kowariantnego parametru typu można użyć jako typu zwracanego delegata, a kontrawariantnych parametrów typu można używać jako typów parametrów.</span><span class="sxs-lookup"><span data-stu-id="a035b-124">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="a035b-125">Na przykład kowariantnych parametrów typu można używać jako typów zwracanych metod interfejsu, a kontrawariantnych parametrów typu można używać jako typów parametrów metod interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a035b-125">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="a035b-126">Kowariancja i kontrawariancja są nazywane zbiorczo *wariancji*.</span><span class="sxs-lookup"><span data-stu-id="a035b-126">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="a035b-127">Parametr typu ogólnego, który nie jest oznaczony jako kowariantny lub kontrawariantny nazywa się *niezmiennej*.</span><span class="sxs-lookup"><span data-stu-id="a035b-127">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="a035b-128">Krótkie podsumowanie faktów na temat wariancji w środowisku uruchomieniowym języka wspólnego:</span><span class="sxs-lookup"><span data-stu-id="a035b-128">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="a035b-129">W [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], wariantne parametry typu są ograniczone do typów ogólnych interfejsów i delegatów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="a035b-129">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="a035b-130">Ogólny typ interfejsu lub delegata może mieć kowariantne i kontrawariantne parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-130">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="a035b-131">Wariancja dotyczy tylko typów referencyjnych; określenie typu wartości dla wariantnego parametru typu spowoduje, że parametr typu będzie inwariantny dla wynikowego skonstruowanego typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-131">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="a035b-132">Wariancja nie dotyczy kombinacji delegatów.</span><span class="sxs-lookup"><span data-stu-id="a035b-132">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="a035b-133">Oznacza to, jeśli istnieją dwa delegaty typu `Action<Derived>` i `Action<Base>` (`Action(Of Derived)` i `Action(Of Base)` w języku Visual Basic), nie można połączyć drugiego delegata z pierwszym, mimo że wynik byłby bezpieczny typ.</span><span class="sxs-lookup"><span data-stu-id="a035b-133">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="a035b-134">Wariancja umożliwia drugiego delegata do przypisania do zmiennej typu `Action<Derived>`, ale delegaty można łączyć tylko wtedy, gdy jest to dokładnie takie same ich typy.</span><span class="sxs-lookup"><span data-stu-id="a035b-134">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>  
  
 <span data-ttu-id="a035b-135">Kowariantne i kontrawariantne parametry typu szczegółowo opisano w następujących sekcjach:</span><span class="sxs-lookup"><span data-stu-id="a035b-135">The following subsections describe covariant and contravariant type parameters in detail:</span></span>  
  
- [<span data-ttu-id="a035b-136">Interfejsy ogólne z Kowariantnymi parametrami typu</span><span class="sxs-lookup"><span data-stu-id="a035b-136">Generic Interfaces with Covariant Type Parameters</span></span>](#InterfaceCovariantTypeParameters)  
  
- [<span data-ttu-id="a035b-137">Interfejsy ogólne z Kontrawariantnymi parametrami typu</span><span class="sxs-lookup"><span data-stu-id="a035b-137">Generic Interfaces with Contravariant Generic Type Parameters</span></span>](#InterfaceCovariantTypeParameters)  
  
- [<span data-ttu-id="a035b-138">Delegaty ogólne z Wariantnymi parametry typu</span><span class="sxs-lookup"><span data-stu-id="a035b-138">Generic Delegates with Variant Type Parameters</span></span>](#DelegateVariantTypeParameters)  
  
- [<span data-ttu-id="a035b-139">Definiowanie interfejsów ogólnych typu Variant i delegatów</span><span class="sxs-lookup"><span data-stu-id="a035b-139">Defining Variant Generic Interfaces and Delegates</span></span>](#DefiningVariantTypeParameters)  
  
- [<span data-ttu-id="a035b-140">Lista typów Variant ogólnego interfejsów i delegatów</span><span class="sxs-lookup"><span data-stu-id="a035b-140">List of Variant Generic Interface and Delegate Types</span></span>](#VariantList)  
  
<a name="InterfaceCovariantTypeParameters"></a>   
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="a035b-141">Interfejsy ogólne z kowariantnymi parametrami typu</span><span class="sxs-lookup"><span data-stu-id="a035b-141">Generic Interfaces with Covariant Type Parameters</span></span>  
 <span data-ttu-id="a035b-142">Począwszy od [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], kilka interfejsów ogólnych ma kowariantne parametry typu; na przykład: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, i <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="a035b-142">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="a035b-143">Wszystkie parametry typu tych interfejsów są kowariantne, więc parametry typu są używane tylko dla typów zwracanych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="a035b-143">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="a035b-144">W poniższym przykładzie pokazano kowariantne parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-144">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="a035b-145">W przykładzie zdefiniowano dwa typy: `Base` ma metodę statyczną o nazwie `PrintBases` przyjmującej `IEnumerable<Base>` (`IEnumerable(Of Base)` w języku Visual Basic) i drukującą elementy.</span><span class="sxs-lookup"><span data-stu-id="a035b-145">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="a035b-146">`Derived` dziedziczy `Base`.</span><span class="sxs-lookup"><span data-stu-id="a035b-146">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="a035b-147">W przykładzie jest tworzona pusta `List<Derived>` (`List(Of Derived)` w języku Visual Basic) i pokazuje, że tego typu mogą być przekazywane do `PrintBases` i przypisane do zmiennej typu `IEnumerable<Base>` bez rzutowania.</span><span class="sxs-lookup"><span data-stu-id="a035b-147">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="a035b-148"><xref:System.Collections.Generic.List%601> implementuje <xref:System.Collections.Generic.IEnumerable%601>, który ma jeden kowariantny parametr typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-148"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="a035b-149">Kowariantny parametr typu jest przyczyną wystąpienia `IEnumerable<Derived>` mogą być używane zamiast `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="a035b-149">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
 [<span data-ttu-id="a035b-150">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="a035b-150">Back to top</span></span>](#top)  
  
<a name="InterfaceContravariantTypeParameters"></a>   
## <a name="generic-interfaces-with-contravariant-generic-type-parameters"></a><span data-ttu-id="a035b-151">Interfejsy ogólne z kontrawariantnymi parametrami typu</span><span class="sxs-lookup"><span data-stu-id="a035b-151">Generic Interfaces with Contravariant Generic Type Parameters</span></span>  
 <span data-ttu-id="a035b-152">Począwszy od [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], kilka interfejsów ogólnych ma kontrawariantne parametry typu; na przykład: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, i <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="a035b-152">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="a035b-153">Te interfejsy mają tylko kontrawariantne parametry typu, więc te parametry typów są używane tyko jako typy parametrów w elementach członkowskich tych interfejsów.</span><span class="sxs-lookup"><span data-stu-id="a035b-153">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="a035b-154">W poniższym przykładzie pokazano kontrawariantne parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-154">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="a035b-155">W przykładzie zdefiniowano abstrakcyjny (`MustInherit` w języku Visual Basic) `Shape` klasy `Area` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a035b-155">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="a035b-156">Przykładzie zdefiniowano też `ShapeAreaComparer` klasę, która implementuje `IComparer<Shape>` (`IComparer(Of Shape)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a035b-156">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="a035b-157">Implementacja <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> Metoda opiera się na wartość `Area` właściwości, więc `ShapeAreaComparer` mogą być używane do sortowania `Shape` obiektów według obszaru.</span><span class="sxs-lookup"><span data-stu-id="a035b-157">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="a035b-158">`Circle` Klasa dziedziczy `Shape` i zastępuje `Area`.</span><span class="sxs-lookup"><span data-stu-id="a035b-158">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="a035b-159">W przykładzie jest tworzony <xref:System.Collections.Generic.SortedSet%601> z `Circle` obiektów, przy użyciu konstruktora przyjmującego `IComparer<Circle>` (`IComparer(Of Circle)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a035b-159">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="a035b-160">Jednak zamiast `IComparer<Circle>`, przykład przekazuje `ShapeAreaComparer` obiektu, który implementuje `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="a035b-160">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="a035b-161">W przykładzie można przekazać funkcję porównującą mniej pochodnego typu (`Shape`) kiedy kod wywołuje funkcję porównującą bardziej pochodnego typu (`Circle`), ponieważ parametr typu <xref:System.Collections.Generic.IComparer%601> ogólny interfejs jest kontrawariantny.</span><span class="sxs-lookup"><span data-stu-id="a035b-161">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="a035b-162">Gdy nowy `Circle` obiekt jest dodawany do `SortedSet<Circle>`, `IComparer<Shape>.Compare` — metoda (`IComparer(Of Shape).Compare` w języku Visual Basic) z `ShapeAreaComparer` obiektu jest wywoływana za każdym razem, nowy element jest porównywany z istniejącym elementem.</span><span class="sxs-lookup"><span data-stu-id="a035b-162">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="a035b-163">Typ parametru metody (`Shape`) jest mniej pochodny niż typ przekazywany (`Circle`), więc wywołanie jest bezpieczne dla typów.</span><span class="sxs-lookup"><span data-stu-id="a035b-163">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="a035b-164">Kontrawariancja umożliwia `ShapeAreaComparer` sortowanie kolekcji dowolnego pojedynczego typu oraz mieszanej kolekcji typów, które wynikają z `Shape`.</span><span class="sxs-lookup"><span data-stu-id="a035b-164">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  
  
 [<span data-ttu-id="a035b-165">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="a035b-165">Back to top</span></span>](#top)  
  
<a name="DelegateVariantTypeParameters"></a>   
## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="a035b-166">Delegaty ogólne z wariantnymi parametrami typu</span><span class="sxs-lookup"><span data-stu-id="a035b-166">Generic Delegates with Variant Type Parameters</span></span>  
 <span data-ttu-id="a035b-167">W [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], `Func` delegaty ogólne, takie jak <xref:System.Func%602>, mają kowariantne typy zwracane i kontrawariantne typy parametrów.</span><span class="sxs-lookup"><span data-stu-id="a035b-167">In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="a035b-168">`Action` Delegaty ogólne, takie jak <xref:System.Action%602>, mają kontrawariantne typy parametrów.</span><span class="sxs-lookup"><span data-stu-id="a035b-168">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="a035b-169">Oznacza to, że delegaty można przypisać do zmiennych, które mają bardziej pochodne typy parametrów i (w przypadku właściwości `Func` delegatów ogólnych) mniej pochodne typy zwracane.</span><span class="sxs-lookup"><span data-stu-id="a035b-169">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a035b-170">Ostatni parametr typu ogólnego `Func` delegatów ogólnych Określa typ wartości zwracanej w podpisie delegata.</span><span class="sxs-lookup"><span data-stu-id="a035b-170">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="a035b-171">Jest kowariantny (`out` — słowo kluczowe), podczas gdy inne parametry typu ogólnego są kontrawariantne (`in` — słowo kluczowe).</span><span class="sxs-lookup"><span data-stu-id="a035b-171">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="a035b-172">Ilustruje to poniższy kod.</span><span class="sxs-lookup"><span data-stu-id="a035b-172">The following code illustrates this.</span></span> <span data-ttu-id="a035b-173">Pierwsza część kodu definiuje klasę o nazwie `Base`, klasę o nazwie `Derived` dziedziczący po klasie `Base`oraz inną klasę z `static` — metoda (`Shared` w języku Visual Basic) o nazwie `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="a035b-173">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="a035b-174">Ta metoda przyjmuje wystąpienie `Base` i zwraca wystąpienie `Derived`.</span><span class="sxs-lookup"><span data-stu-id="a035b-174">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="a035b-175">(Jeśli argument jest wystąpieniem `Derived`, `MyMethod` zwraca go; Jeśli argument jest wystąpieniem `Base`, `MyMethod` zwraca nowe wystąpienie klasy `Derived`.) W `Main()`, przykład tworzy wystąpienie `Func<Base, Derived>` (`Func(Of Base, Derived)` w języku Visual Basic) reprezentujący `MyMethod`i zapisuje ją w zmiennej `f1`.</span><span class="sxs-lookup"><span data-stu-id="a035b-175">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="a035b-176">Drugi fragment kodu pokazuje, że tego delegata można przypisać do zmiennej typu `Func<Base, Base>` (`Func(Of Base, Base)` w języku Visual Basic), ponieważ zwracany typ jest kowariantny.</span><span class="sxs-lookup"><span data-stu-id="a035b-176">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="a035b-177">Trzeciej części kodu widać, że tego delegata można przypisać do zmiennej typu `Func<Derived, Derived>` (`Func(Of Derived, Derived)` w języku Visual Basic), ponieważ typ parametru jest kowariantny.</span><span class="sxs-lookup"><span data-stu-id="a035b-177">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="a035b-178">Końcowy fragment kodu pokazuje, że tego delegata można przypisać do zmiennej typu `Func<Derived, Base>` (`Func(Of Derived, Base)` w języku Visual Basic), łącząc efekty użycia kontrawariantnego typu parametru i kowariantnego typu zwracanego.</span><span class="sxs-lookup"><span data-stu-id="a035b-178">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-generic-and-non-generic-delegates"></a><span data-ttu-id="a035b-179">Wariancja w delegatach ogólnych i nieogólnych</span><span class="sxs-lookup"><span data-stu-id="a035b-179">Variance in Generic and Non-Generic Delegates</span></span>  
 <span data-ttu-id="a035b-180">W poprzednim kodzie podpis `MyMethod` dokładnie pasuje do podpisu skonstruowanego delegata ogólnego: `Func<Base, Derived>` (`Func(Of Base, Derived)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a035b-180">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="a035b-181">W przykładzie pokazano czy ten delegat ogólny mogą być przechowywane w zmiennych lub parametrach metody, które mają bardziej pochodne typy parametrów i mniej pochodne typy zwracane, tak długo, jak wszystkie typy delegatów są konstruowane na podstawie ogólnego typu delegatów <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="a035b-181">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="a035b-182">Jest to ważny punkt.</span><span class="sxs-lookup"><span data-stu-id="a035b-182">This is an important point.</span></span> <span data-ttu-id="a035b-183">Efekty zastosowania kowariancji i kontrawariancji w parametrach typu delegatów ogólnych są podobne do efektów zastosowania kowariancji i kontrawariancji w zwykłych powiązaniach delegatów (zobacz [wariancje w Delegatach (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) i [ Wariancje w Delegatach (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="a035b-183">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="a035b-184">Jednak wariancja w powiązaniach delegatów działa ze wszystkimi typami delegatów, a nie tylko z ogólnymi typami delegatów, które mają wariantne parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-184">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="a035b-185">Co więcej wariancja w powiązaniach delegatów umożliwia powiązanie metody z dowolnym delegatem, który ma bardziej restrykcyjne typy parametrów i mniej restrykcyjny typ zwracany, podczas gdy przypisanie delegatów ogólnych działa tylko wtedy, gdy oba typy delegatów są konstruowane na podstawie jednej definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="a035b-185">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="a035b-186">W poniższym przykładzie pokazano połączone efekty zastosowania wariancji w powiązaniu delegatów oraz zastosowania wariancji w parametrach typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="a035b-186">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="a035b-187">Przykładzie zdefiniowano hierarchię typów zawierającą trzy typy, od najmniej pochodnych (`Type1`) do najbardziej pochodnego (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="a035b-187">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="a035b-188">Wariancja w zwykłym powiązaniu delegatów służy do tworzenia powiązania metody mającej typ parametru z `Type1` i zwracanym typem `Type3` z delegatem ogólnym mającym typ parametru elementu `Type2` i zwracanym typem `Type2`.</span><span class="sxs-lookup"><span data-stu-id="a035b-188">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="a035b-189">Następnie wynikowy Delegat ogólny jest przypisywany do innej zmiennej, której typ delegata ogólnego ma parametr typu `Type3` i zwracanym typem `Type1`, przy użyciu kowariancji i kontrawariancji parametrów typu genetycznego.</span><span class="sxs-lookup"><span data-stu-id="a035b-189">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="a035b-190">Drugie przypisanie wymaga zarówno typ zmiennej i typ delegata zostały skonstruowane na podstawie jednej definicji typu ogólnego, w tym przypadku <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="a035b-190">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  
  
 [<span data-ttu-id="a035b-191">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="a035b-191">Back to top</span></span>](#top)  
  
<a name="DefiningVariantTypeParameters"></a>   
## <a name="defining-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="a035b-192">Definiowanie wariantów interfejsów i delegatów ogólnych</span><span class="sxs-lookup"><span data-stu-id="a035b-192">Defining Variant Generic Interfaces and Delegates</span></span>  
 <span data-ttu-id="a035b-193">Począwszy od [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Visual Basic i C# mają słowa kluczowe umożliwiające oznaczanie parametrów typu ogólnego interfejsów i delegatów jako kowariantnych lub kontrawariantnych.</span><span class="sxs-lookup"><span data-stu-id="a035b-193">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a035b-194">Począwszy od programu .NET Framework 2.0 środowisko uruchomieniowe języka wspólnego obsługuje adnotacje dotyczące wariancji w parametrach typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="a035b-194">Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.</span></span> <span data-ttu-id="a035b-195">Przed [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], jedynym sposobem zdefiniowania klasy ogólnej z tymi adnotacjami jest użycie języka Microsoft intermediate language (MSIL) przez skompilowanie klasy za pomocą [Ilasm.exe (asembler IL)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) lub wyemitowanie jej w dynamicznym zestaw.</span><span class="sxs-lookup"><span data-stu-id="a035b-195">Prior to the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.</span></span>  
  
 <span data-ttu-id="a035b-196">Kowariantny parametr typu jest oznaczona atrybutem `out` — słowo kluczowe (`Out` — słowo kluczowe w języku Visual Basic `+` dla [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="a035b-196">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="a035b-197">Kowariantnego parametru typu można użyć jako wartości zwracanej metody, która należy do interfejsu, lub typu zwracanego delegata.</span><span class="sxs-lookup"><span data-stu-id="a035b-197">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="a035b-198">Kowariantnego parametru typu nie można użyć jako ograniczenia typu ogólnego dla metod interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a035b-198">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a035b-199">Jeśli metoda interfejsu ma parametr, który jest typem ogólnym delegatów, kowariantny parametr typu dla typu interfejsu może być używany w celu określenia kontrawariantnego parametru typu dla typu delegata.</span><span class="sxs-lookup"><span data-stu-id="a035b-199">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="a035b-200">Kontrawariantnego parametru typu jest oznaczona atrybutem `in` — słowo kluczowe (`In` — słowo kluczowe w języku Visual Basic `-` dla [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="a035b-200">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="a035b-201">Kontrawariantnego parametru typu można użyć jako typu parametru metody, która należy do interfejsu, lub typu parametru delegata.</span><span class="sxs-lookup"><span data-stu-id="a035b-201">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="a035b-202">Kontrawariantnego parametru typu można użyć jako ograniczenia typu ogólnego dla metody interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a035b-202">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="a035b-203">Tylko typy interfejsów i typy delegatów mogą mieć wariantne parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-203">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="a035b-204">Typ interfejsu lub delegata może mieć kowariantne i kontrawariantne parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-204">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="a035b-205">Programy Visual Basic i C# nie zezwalają na naruszanie reguł używania kowariantnych i kontrawariantnych parametrów typu oraz dodawanie adnotacji o kowariancji i kontrawariancji do parametrów typu dla typów innych niż interfejsy i delegaty.</span><span class="sxs-lookup"><span data-stu-id="a035b-205">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span> <span data-ttu-id="a035b-206">[MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md) nie wykonuje takich kontroli, ale <xref:System.TypeLoadException> jest generowany, jeśli zostanie podjęta próba załadowania typu naruszającego reguły.</span><span class="sxs-lookup"><span data-stu-id="a035b-206">The [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.</span></span>  
  
 <span data-ttu-id="a035b-207">Aby uzyskać informacji i przykładowy kod, zobacz [wariancje w interfejsach (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) i [wariancje w interfejsach (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="a035b-207">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  
  
 [<span data-ttu-id="a035b-208">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="a035b-208">Back to top</span></span>](#top)  
  
<a name="VariantList"></a>   
## <a name="list-of-variant-generic-interface-and-delegate-types"></a><span data-ttu-id="a035b-209">Lista wariantów ogólnych typów interfejsów i delegatów</span><span class="sxs-lookup"><span data-stu-id="a035b-209">List of Variant Generic Interface and Delegate Types</span></span>  
 <span data-ttu-id="a035b-210">W [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], następujące typy interfejsów i delegatów mają kowariantne i/lub kontrawariantne parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a035b-210">In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="a035b-211">Typ</span><span class="sxs-lookup"><span data-stu-id="a035b-211">Type</span></span>|<span data-ttu-id="a035b-212">Kowariantne parametry typu</span><span class="sxs-lookup"><span data-stu-id="a035b-212">Covariant type parameters</span></span>|<span data-ttu-id="a035b-213">Kontrawariantne parametry typu</span><span class="sxs-lookup"><span data-stu-id="a035b-213">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="a035b-214"><xref:System.Action%601> Aby <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="a035b-214"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="a035b-215">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-215">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="a035b-216">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-216">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="a035b-217">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-217">Yes</span></span>|<span data-ttu-id="a035b-218">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-218">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="a035b-219">Tak</span><span class="sxs-lookup"><span data-stu-id="a035b-219">Yes</span></span>||  
|<span data-ttu-id="a035b-220"><xref:System.Func%602> Aby <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="a035b-220"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="a035b-221">Tak</span><span class="sxs-lookup"><span data-stu-id="a035b-221">Yes</span></span>|<span data-ttu-id="a035b-222">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-222">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="a035b-223">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-223">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="a035b-224">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-224">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="a035b-225">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-225">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="a035b-226">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-226">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="a035b-227">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-227">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="a035b-228">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-228">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="a035b-229">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-229">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="a035b-230">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-230">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="a035b-231">Yes</span><span class="sxs-lookup"><span data-stu-id="a035b-231">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="a035b-232">Tak</span><span class="sxs-lookup"><span data-stu-id="a035b-232">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="a035b-233">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a035b-233">See also</span></span>

- [<span data-ttu-id="a035b-234">Kowariancja i Kontrawariancja (C#)</span><span class="sxs-lookup"><span data-stu-id="a035b-234">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="a035b-235">Kowariancja i Kontrawariancja (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a035b-235">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="a035b-236">Wariancje w Delegatach (C#)</span><span class="sxs-lookup"><span data-stu-id="a035b-236">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="a035b-237">Wariancje w Delegatach (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a035b-237">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
