---
title: Asynchroniczne szczegółowo
description: Dowiedz się, jak I/O-powiązane z Procesora CPU asynchronicznego pisanie kodu wykonywanego i jest proste przy użyciu modelu opartego na zadaniach .NET async.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 7aa2bcdad9584ecf05dfee35e0887ed70737795d
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/23/2019
ms.locfileid: "54492836"
---
# <a name="async-in-depth"></a><span data-ttu-id="4d8d9-103">Asynchroniczne szczegółowo</span><span class="sxs-lookup"><span data-stu-id="4d8d9-103">Async in depth</span></span>

<span data-ttu-id="4d8d9-104">Zapisywanie operacji We/Wy i Procesora CPU kodu asynchronicznego jest proste przy użyciu modelu opartego na zadaniach .NET async.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="4d8d9-105">Model jest uwidaczniany przez `Task` i `Task<T>` typów i `async` i `await` słów kluczowych w języku C# i Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="4d8d9-106">(Specyficzne dla języka zasoby znajdują się w [Zobacz też](#see-also) sekcji.) W tym artykule wyjaśniono, jak używać asynchronicznych .NET i zapewnia wgląd w ramach asynchronicznych używane w sposób niewidoczny.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-tasklttgt"></a><span data-ttu-id="4d8d9-107">Zadanie i zadania&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="4d8d9-107">Task and Task&lt;T&gt;</span></span>

<span data-ttu-id="4d8d9-108">Zadania są konstrukcji używanych do wdrożenia, co jest nazywane [Promise modelu współbieżności](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="4d8d9-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="4d8d9-109">Krótko mówiąc oferują one, że możesz element "promise", które działają zakończy się w późniejszym czasie, dzięki czemu możesz skontaktować się z zobowiązania przy użyciu czystego interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

*   <span data-ttu-id="4d8d9-110">`Task` reprezentuje pojedynczej operacji, która nie zwraca wartości.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-110">`Task` represents a single operation which does not return a value.</span></span>
*   <span data-ttu-id="4d8d9-111">`Task<T>` reprezentuje jednej operacji, która zwraca wartość typu `T`.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="4d8d9-112">Ważne jest, aby Przyczyna o zadaniach jako abstrakcje wykonywane asynchronicznie, pracy i *nie* abstrakcji wątków.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="4d8d9-113">Domyślnie wykonywane podzadania wchodzące w bieżącym wątku i delegata pracy do systemu operacyjnego, zgodnie z potrzebami.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="4d8d9-114">Opcjonalnie, zadania można jawnie wymagane do uruchamiania w oddzielnym wątku za pomocą `Task.Run` interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="4d8d9-115">Zadania ujawnić protokół interfejsu API oraz funkcje monitorowania i oczekiwania na dostęp do wartości wyniku (w przypadku właściwości `Task<T>`) zadania.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="4d8d9-116">Integracja języka, za pomocą `await` — słowo kluczowe, zapewnia wyższego poziomu abstrakcji dotyczące korzystania z zadań.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span> 

<span data-ttu-id="4d8d9-117">Za pomocą `await` umożliwia aplikacji lub usługi wykonać przydatnych działań po uruchomieniu zadania przez reaguje formantu do obiektu wywołującego, dopóki zadanie jest wykonywane.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="4d8d9-118">Twój kod nie trzeba polegać na wywołania zwrotne lub zdarzeń w celu kontynuowania wykonywania po ukończeniu zadania.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="4d8d9-119">Języku i za pomocą integracji interfejsu API zadań robi to za Ciebie.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="4d8d9-120">Jeśli używasz `Task<T>`, `await` — słowo kluczowe zostanie dodatkowo "Odkodowywanie" wartość zwracana, gdy zadanie zostało ukończone.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="4d8d9-121">Szczegóły dotyczące sposobu działania zostały wyjaśnione poniżej.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="4d8d9-122">Dowiedz się więcej o zadaniach i różne sposoby interakcji z użytkownikiem w [opartego na zadaniach asynchronicznej wzorca (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="4d8d9-123">Bardziej zgłębić temat na zadania dla operacji I/O-powiązane z</span><span class="sxs-lookup"><span data-stu-id="4d8d9-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="4d8d9-124">W poniższej sekcji opisano, co się dzieje z wywołania operacji We/Wy async typowy widok metr 10 000.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="4d8d9-125">Zacznijmy od kilka przykładów.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="4d8d9-126">Pierwszy przykład wywołuje metodę async i zwraca aktywne zadanie, prawdopodobnie jeszcze zakończyć.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();
    
    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="4d8d9-127">Drugi przykład dodaje użytkowania `async` i `await` słów kluczowych do działania na zadanie.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();
    
    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");
    
    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.
    
    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="4d8d9-128">Wywołanie `GetStringAsync()` wywołań za pośrednictwem niższego poziomu bibliotek programu .NET (być może wywołaniem innych metod asynchronicznych) dopóki osiągnie P/Invoke międzyoperacyjny wywołania natywne biblioteki sieciowej.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="4d8d9-129">Bibliotekę natywną później może wywołać do wywołania interfejsu API systemu (takich jak `write()` do gniazda w systemie Linux).</span><span class="sxs-lookup"><span data-stu-id="4d8d9-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="4d8d9-130">Obiekt zadania, które zostaną utworzone na granicy natywnego/zarządzanego, prawdopodobnie za pomocą [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="4d8d9-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="4d8d9-131">Obiekt zadania będą przekazywane warstw, prawdopodobnie działa jako lub bezpośrednio zwracana, ostatecznie zwracana do początkowego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span> 

<span data-ttu-id="4d8d9-132">W drugim przykładzie powyżej `Task<T>` obiektu zostanie zwrócony z `GetStringAsync`.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="4d8d9-133">Korzystanie z `await` — słowo kluczowe spowoduje, że metoda zwraca obiekt nowo utworzonym zadaniem.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="4d8d9-134">Formant powraca do obiektu wywołującego z tej lokalizacji w `GetFirstCharactersCountAsync` metody.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="4d8d9-135">Metody i właściwości [zadań&lt;T&gt; ](xref:System.Threading.Tasks.Task%601) obiektów wywołujących Włącz, aby monitorować postęp zadania, które zostanie ukończone, gdy pozostały kod GetFirstCharactersCountAsync zostało wykonane.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="4d8d9-136">Po wywołaniu interfejsu API w systemu żądanie teraz obszaru jądra osiągnął w drodze do podsystemu sieci systemu operacyjnego (takich jak `/net` w jądrze systemu Linux).</span><span class="sxs-lookup"><span data-stu-id="4d8d9-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="4d8d9-137">W tym miejscu systemu operacyjnego będzie obsługiwać żądania sieciowe *asynchronicznie*.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="4d8d9-138">Szczegółów może różnić się w zależności od systemu operacyjnego używany (wywołanie sterownika urządzenia mogą być zaplanowane jako sygnał wysyłanych z powrotem do środowiska uruchomieniowego lub wywołania sterownika urządzenia, które mogą być nawiązywane i *następnie* sygnał odesłał), ale ostatecznie zostanie poinformowana środowiska uruchomieniowego czy żądanie sieci jest w toku.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="4d8d9-139">W tej chwili pracy dla sterownika urządzenia będą albo być zaplanowane, w toku lub już zakończona (żądanie jest już się "przewodowo") -, ale ponieważ jest to wszystkie wykonywane asynchronicznie, sterownik urządzenia jest w stanie natychmiast obsługi coś innego!</span><span class="sxs-lookup"><span data-stu-id="4d8d9-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="4d8d9-140">Na przykład w system operacyjny Windows wątek nawiązuje połączenie ze sterownikiem urządzenia sieci i prosi można wykonać operacji sieci za pośrednictwem przerwań żądania pakietu (IRP), które reprezentuje operację.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="4d8d9-141">Sterownik urządzenia otrzymuje MPP, sprawia, że połączenie z siecią, oznacza MPP jako "pending" i zwraca z powrotem do systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="4d8d9-142">Ponieważ teraz wątku systemu operacyjnego wie, że MPP jest "pending", nie ma żadnych więcej działań w celu dla tego zadania i "zwraca wartość" tak, aby może służyć do wykonywania innych zadań.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="4d8d9-143">Gdy żądanie jest spełniony, a danych wróci za pośrednictwem sterownika urządzenia, powiadamia Procesora nowych danych odebranych za pośrednictwem przerwania.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="4d8d9-144">Pobiera obsługi przerwań to różnią się w zależności od systemu operacyjnego, ale ostatecznie dane zostaną przekazane za pośrednictwem systemu operacyjnego aż do napotkania międzyoperacyjny wywołania systemowego (na przykład w systemie Linux obsługi przerwania będą planować dolnej połowie przerwania do danych za pośrednictwem systemu operacyjnego  asynchronicznie).</span><span class="sxs-lookup"><span data-stu-id="4d8d9-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="4d8d9-145">Uwaga że *również* się asynchronicznie stanie!</span><span class="sxs-lookup"><span data-stu-id="4d8d9-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="4d8d9-146">Wynik jest umieszczane w kolejce do czasu następnego dostępny wątek jest w stanie Wykonywanie metody asynchronicznej i "Odkodowywanie" wyniki ukończonego zadania.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-146">The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="4d8d9-147">W trakcie tego procesu całego kluczowym wnioskiem jest to, że **żaden wątek nie jest przeznaczony do obsługi zadania**.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="4d8d9-148">Mimo że praca jest wykonywana w kontekście niektóre (oznacza to, system operacyjny musi przekazać dane do sterownika urządzenia i reagować na przerwania), żaden wątek nie jest dedykowany do *oczekiwania* dla danych z żądania, aby wrócić do tego.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="4d8d9-149">Dzięki temu system do obsługi znacznie większa ilość pracy, zamiast czekać, aż niektóre wywołania operacji We/Wy zakończyć.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="4d8d9-150">Mimo że powyżej może wydawać się wiele zadań do wykonania, gdy mierzy czas zegarowy, jest miniscule w porównaniu do czasu, jaki zajmuje wykonują rzeczywistą pracę we/wy.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="4d8d9-151">Mimo że w ogóle nie będzie dokładny potencjalnych oś czasu dla takich wywołania będzie wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="4d8d9-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="4d8d9-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="4d8d9-152">0-1————————————————————————————————————————————————–2-3</span></span>

*   <span data-ttu-id="4d8d9-153">Czas poświęcony na z punktów `0` do `1` to wszystko, aż do metody asynchronicznej przekazuje sterowanie do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
*   <span data-ttu-id="4d8d9-154">Czas poświęcony na z punktów `1` do `2` jest czas spędzony na We/Wy przy użyciu procesora CPU, nie kosztów.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
*   <span data-ttu-id="4d8d9-155">Ponadto czas działania z punktów `2` do `3` to przekazanie kontroli Wstecz (i potencjalnie wartości) do metody asynchronicznej, w tym momencie jest wykonywane ponownie.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="4d8d9-156">Co to oznacza dla scenariusza serwera</span><span class="sxs-lookup"><span data-stu-id="4d8d9-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="4d8d9-157">Ten model dobrze działa z obciążenie serwera typowego scenariusza.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="4d8d9-158">Ponieważ nie istnieją wątki dedykowanego blokuje niezakończonych zadań, threadpool serwer może obsłużyć znacznie większą ilość żądań sieci web.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="4d8d9-159">Należy wziąć pod uwagę dwa serwery: taki, który jest uruchamiany kod asynchroniczny i jedną, która nie ma.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="4d8d9-160">Na potrzeby tego przykładu każdy serwer ma tylko 5 wątków dostępnych do obsługi żądań.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="4d8d9-161">Należy pamiętać, że te liczby są imaginarily małe i pełnią wyłącznie w kontekście demonstrative.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="4d8d9-162">Załóżmy, że oba serwery odbierania 6 współbieżnych żądań.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="4d8d9-163">Każde żądanie wykonuje operację We/Wy.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="4d8d9-164">Serwer *bez* kod asynchroniczny ma 6. żądania w kolejce do momentu mają jeden z wątków 5 zakończy pracę I/O-powiązane z i zapisywane odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="4d8d9-165">W punkcie, które pochodzą żądania 20 serwer może uruchomić spowolnienia, ponieważ kolejka jest wprowadzenie zbyt długa.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="4d8d9-166">Serwer *z* kolejek się 6. żądanie jest nadal uruchomiony kod async, ale ponieważ używa ona `async` i `await`, każdy z wątków są zwalniane po uruchomieniu pracy I/O-powiązane z, a nie po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="4d8d9-167">Do czasu żądania 20 jest dostarczany w kolejce dla żądań przychodzących będzie znacznie mniejsza (jeśli ma niczego w niej w ogóle), i nie spowalniają serwera.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="4d8d9-168">Chociaż jest to przykład contrived, działa w sposób bardzo podobne w świecie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="4d8d9-169">W rzeczywistości można oczekiwać, że serwer może obsługiwać więcej żądań przy użyciu o rząd wielkości `async` i `await` niż jeśli jego zostały dedykowanym wątku dla każdego żądania odbiera.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="4d8d9-170">Co to oznacza dla scenariusza klienta</span><span class="sxs-lookup"><span data-stu-id="4d8d9-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="4d8d9-171">Największe korzyści dotyczące korzystania z `async` i `await` dla klienta, aplikacja jest zwiększenie czasu odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="4d8d9-172">Chociaż można wykonać aplikacji interaktywnych duplikując wątków ręcznie, podczas duplikowania wątku jest kosztowną operacją względem tylko przy użyciu `async` i `await`.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="4d8d9-173">Szczególnie w przypadku podobny grę na urządzenia przenośne wpływ na wątku interfejsu użytkownika jak najmniejszy których to dotyczy operacji We/Wy jest niezwykle istotne.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="4d8d9-174">Co ważniejsze ponieważ praca I/O-powiązane z spędzony przez praktycznie w krótkim czasie na procesorze CPU, przypisywanie całego wątku procesora CPU w celu wykonania ledwie jakiejkolwiek przydatnej pracy będzie Niewydajne wykorzystanie zasobów.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="4d8d9-175">Ponadto wywołujący pracę w wątku interfejsu użytkownika (takie jak aktualizowanie interfejsu użytkownika) jest bardzo proste dzięki `async` metod i nie wymaga dodatkowej pracy (na przykład podczas wywoływania delegata wątkowo).</span><span class="sxs-lookup"><span data-stu-id="4d8d9-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-tasklttgt-for-a-cpu-bound-operation"></a><span data-ttu-id="4d8d9-176">Bardziej zgłębić temat do zadań i zadań&lt;T&gt; dla operacji zależne od Procesora CPU</span><span class="sxs-lookup"><span data-stu-id="4d8d9-176">Deeper Dive into Task and Task&lt;T&gt; for a CPU-Bound Operation</span></span>

<span data-ttu-id="4d8d9-177">Zależne od Procesora CPU `async` kod jest nieco inna niż I/O-granica `async` kodu.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="4d8d9-178">Ponieważ praca odbywa się na procesorze CPU, nie ma możliwości można pobrać na dedykowanym wątku do obliczeń.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="4d8d9-179">Korzystanie z `async` i `await` oferuje użytkownikowi eleganckie rozwiązanie do interakcji z tłem wątku i Zachowaj dynamiczne obiektu wywołującego metody async.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="4d8d9-180">Należy pamiętać, że nie zapewnia żadnej ochrony dla udostępnionych danych.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="4d8d9-181">Jeśli używasz udostępnionych danych nadal konieczne będzie zastosowanie strategii synchronizacji odpowiednich.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="4d8d9-182">W tym miejscu znajduje się 10 000 stóp wywołanie asynchroniczne zależne od Procesora CPU:</span><span class="sxs-lookup"><span data-stu-id="4d8d9-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));
    
    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!
    
    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;
    
    return result;
}
```

<span data-ttu-id="4d8d9-183">`CalculateResult()` wykonuje w wątku, który został wywołany w.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="4d8d9-184">Kiedy wywołuje `Task.Run`, jego kolejki kosztowna operacja Procesora CPU `DoExpensiveCalculation()`, w puli wątków i odbiera `Task<int>` obsługi.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="4d8d9-185">`DoExpensiveCalculation()` Po pewnym czasie działa równolegle na następny dostępny wątek, prawdopodobnie na inny rdzeń procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="4d8d9-186">Istnieje możliwość wykonania współbieżnych pracy podczas `DoExpensiveCalculation()` jest zajęty w innym wątku, ponieważ wątku, która nosi nazwę `CalculateResult()` jest nadal wykonywane.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="4d8d9-187">Raz `await` napotkaniu wykonywania `CalculateResult()` jest uzyskane do obiektu wywołującego, dzięki czemu inne prace, co można zrobić za pomocą bieżącego wątku podczas `DoExpensiveCalculation()` jest wychodzi się wynik.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="4d8d9-188">Po zakończeniu, wynik jest umieszczone w kolejce do uruchomienia w wątku głównym.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="4d8d9-189">Po pewnym czasie, wątek główny powróci do wykonywania `CalculateResult()`, w tym momencie jej wynik `DoExpensiveCalculation()`.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="4d8d9-190">Dlaczego czy asynchroniczne pomaga w tym miejscu?</span><span class="sxs-lookup"><span data-stu-id="4d8d9-190">Why does async help here?</span></span>

<span data-ttu-id="4d8d9-191">`async` i `await` są najlepszym rozwiązaniem Zarządzanie zadań intensywnie angażujących Procesor, gdy będziesz potrzebować czasu odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-191">`async` and `await` are the best practice managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="4d8d9-192">Istnieje wiele wzorce przy użyciu async za pomocą zadań intensywnie angażujących Procesor.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="4d8d9-193">Należy pamiętać, że istnieje niewielkim kosztem za pomocą async i nie jest zalecane w ścisłej pętli for.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="4d8d9-194">To pozwala określić, jak pisać kod wokół tej nowej możliwości.</span><span class="sxs-lookup"><span data-stu-id="4d8d9-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="4d8d9-195">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="4d8d9-195">See also</span></span>

- [<span data-ttu-id="4d8d9-196">Programowanie asynchroniczne w języku C#</span><span class="sxs-lookup"><span data-stu-id="4d8d9-196">Asynchronous programming in C#</span></span>](~/docs/csharp/async.md)
- [<span data-ttu-id="4d8d9-197">Programowanie asynchroniczne z async i await (C#)</span><span class="sxs-lookup"><span data-stu-id="4d8d9-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="4d8d9-198">Async — Programowanie wF#</span><span class="sxs-lookup"><span data-stu-id="4d8d9-198">Async Programming in F#</span></span>](~/docs/fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="4d8d9-199">Programowanie asynchroniczne z Async i Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="4d8d9-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](~/docs/visual-basic/programming-guide/concepts/async/index.md)
