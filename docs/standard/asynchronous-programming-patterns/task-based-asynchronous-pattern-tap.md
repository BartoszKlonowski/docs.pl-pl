---
title: Wzorzec asynchroniczny oparty na zadaniach (TAP)
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: 89c486618729c334bf74f0a1f4f9dd1b3cee8b0e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "78158171"
---
# <a name="task-based-asynchronous-pattern-tap"></a><span data-ttu-id="49e4d-102">Asynchroniczny wzorzec oparty na zadaniach (TAP)</span><span class="sxs-lookup"><span data-stu-id="49e4d-102">Task-based asynchronous pattern (TAP)</span></span>
<span data-ttu-id="49e4d-103">Wzorzec asynchroniczny (TAP) oparty <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> na <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> zadaniach <xref:System.Threading.Tasks?displayProperty=nameWithType> jest oparty na typach i typach w przestrzeni nazw, które są używane do reprezentowania dowolnych operacji asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="49e4d-103">The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="49e4d-104">Wzorzec TAP jest zalecanym asynchronicznym wzorcem projektowym dla nowych prac deweloperskich.</span><span class="sxs-lookup"><span data-stu-id="49e4d-104">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="49e4d-105">Nazewnictwo, parametry i typy zwracane</span><span class="sxs-lookup"><span data-stu-id="49e4d-105">Naming, parameters, and return types</span></span>

<span data-ttu-id="49e4d-106">We wzorcu TAP do tworzenia wystąpienia i wykonywania operacji asynchronicznej jest używana jedna metoda.</span><span class="sxs-lookup"><span data-stu-id="49e4d-106">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="49e4d-107">Kontrastuje to zarówno ze wzorem Asynchronicznego modelu `IAsyncResult`programowania (APM lub) oraz wzorcem asynchronicznym opartym na zdarzeniach (EAP).</span><span class="sxs-lookup"><span data-stu-id="49e4d-107">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="49e4d-108">APM `Begin` wymaga `End` i metod.</span><span class="sxs-lookup"><span data-stu-id="49e4d-108">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="49e4d-109">EAP wymaga metody, `Async` która ma sufiks, a także wymaga jednego `EventArg`lub więcej zdarzeń, typy delegatów obsługi zdarzeń i typy pochodne.</span><span class="sxs-lookup"><span data-stu-id="49e4d-109">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="49e4d-110">Metody asynchroniczne w tap `Async` obejmują sufiks po nazwie operacji dla metod, <xref:System.Threading.Tasks.Task> <xref:System.Threading.Tasks.Task%601>które <xref:System.Threading.Tasks.ValueTask>zwracają <xref:System.Threading.Tasks.ValueTask%601>typy oczekujące, takie jak , , , i .</span><span class="sxs-lookup"><span data-stu-id="49e4d-110">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="49e4d-111">Na przykład operacja `Get` asynchroniczna, `Task<String>` która `GetAsync`zwraca a może mieć nazwę .</span><span class="sxs-lookup"><span data-stu-id="49e4d-111">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="49e4d-112">Jeśli dodajesz metodę TAP do klasy, która już zawiera `Async` nazwę metody EAP z `TaskAsync` sufiksem, użyj zamiast tego sufiksu.</span><span class="sxs-lookup"><span data-stu-id="49e4d-112">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="49e4d-113">Na przykład jeśli klasa ma `GetAsync` już metodę, `GetTaskAsync`użyj nazwy .</span><span class="sxs-lookup"><span data-stu-id="49e4d-113">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="49e4d-114">Jeśli metoda uruchamia operację asynchroniczną, ale nie zwraca typu oczekującego, jej nazwa powinna zaczynać się od `Begin`, `Start`lub innego zlecenia sugerującego, że ta metoda nie zwraca lub nie zgłasza wyniku operacji.</span><span class="sxs-lookup"><span data-stu-id="49e4d-114">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="49e4d-115">Metoda TAP zwraca <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>lub a , na podstawie tego, czy `TResult`odpowiednia metoda synchroniczna zwraca void, czy typ .</span><span class="sxs-lookup"><span data-stu-id="49e4d-115">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="49e4d-116">Parametry metody TAP powinny być zgodne z parametrami jej synchronicznego odpowiednika i powinny być podane w tej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="49e4d-116">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="49e4d-117">Jednak `out` parametry `ref` są wyłączone z tej reguły i należy unikać całkowicie.</span><span class="sxs-lookup"><span data-stu-id="49e4d-117">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="49e4d-118">Wszelkie dane, które zostałyby `out` zwrócone za pośrednictwem lub `ref` parametru powinny być zwracane jako część `TResult` zwracane przez <xref:System.Threading.Tasks.Task%601>, i należy użyć krotki lub niestandardowej struktury danych, aby pomieścić wiele wartości.</span><span class="sxs-lookup"><span data-stu-id="49e4d-118">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="49e4d-119">Należy również rozważyć <xref:System.Threading.CancellationToken> dodanie parametru, nawet jeśli synchroniczny odpowiednik metody TAP nie oferuje jeden.</span><span class="sxs-lookup"><span data-stu-id="49e4d-119">You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="49e4d-120">Metody, które są przeznaczone wyłącznie do tworzenia, manipulacji lub kombinacji zadań (gdzie asynchroniczne intencji metody jest jasne w nazwie metody lub w nazwie typu, do którego należy metoda) nie muszą przestrzegać tego wzorca nazewnictwa; takie metody są często określane jako *kombinatory*.</span><span class="sxs-lookup"><span data-stu-id="49e4d-120">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="49e4d-121">Przykłady kombinatorów obejmują <xref:System.Threading.Tasks.Task.WhenAll%2A> <xref:System.Threading.Tasks.Task.WhenAny%2A>i , i są omówione w [za pomocą wbudowanych kombinatorów opartych na zadaniach](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) sekcji artykułu [Korzystanie z wzorca asynchronicznego opartego na zadaniach](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="49e4d-121">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="49e4d-122">Przykłady tego, jak składnia TAP różni się od składni używanej w starszych wzorcach programowania asynchronicznego, takich jak asynchroniczny model programowania (APM) i asynchroniczny wzorzec (EAP) oparty na zdarzeniach), zobacz [Wzorce programowania asynchronicznego](../../../docs/standard/asynchronous-programming-patterns/index.md).</span><span class="sxs-lookup"><span data-stu-id="49e4d-122">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="49e4d-123">Inicjującoperację asynchroniczną</span><span class="sxs-lookup"><span data-stu-id="49e4d-123">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="49e4d-124">Metoda asynchroniczna oparta na wzorcu TAP może wykonać synchronicznie niewielką ilość pracy, na przykład weryfikację argumentów i inicjowanie operacji asynchronicznej, zanim zwróci zadanie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="49e4d-124">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="49e4d-125">Praca synchroniczna powinna być ograniczona do minimum, tak aby metoda asynchroniczna mogła szybko zwracać wynik.</span><span class="sxs-lookup"><span data-stu-id="49e4d-125">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="49e4d-126">Powody oczekiwania szybkiego zwrócenia wyniku to m.in.:</span><span class="sxs-lookup"><span data-stu-id="49e4d-126">Reasons for a quick return include the following:</span></span>  
  
- <span data-ttu-id="49e4d-127">Metody asynchroniczne mogą być wywoływane z wątków interfejsu użytkownika (UI), a jakakolwiek długotrwała praca synchroniczna może niekorzystnie wpływać na czas reakcji aplikacji.</span><span class="sxs-lookup"><span data-stu-id="49e4d-127">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="49e4d-128">Wiele metod asynchronicznych może zostać uruchomionych jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="49e4d-128">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="49e4d-129">W związku z tym jakakolwiek długotrwała praca synchroniczna metody asynchronicznej może opóźnić zainicjowanie innych operacji asynchronicznych, zmniejszając w ten sposób korzyści płynące ze współbieżności.</span><span class="sxs-lookup"><span data-stu-id="49e4d-129">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="49e4d-130">W niektórych przypadkach nakład pracy wymagany do ukończenia operacji jest mniejszy niż ilość pracy potrzebna do asynchronicznego uruchomienia operacji.</span><span class="sxs-lookup"><span data-stu-id="49e4d-130">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="49e4d-131">Przykładem takiego scenariusza jest odczyt ze strumienia, gdzie operacja odczytu może się odbyć dzięki danym buforowanym już w pamięci.</span><span class="sxs-lookup"><span data-stu-id="49e4d-131">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="49e4d-132">W takich przypadkach operacja może zakończyć się synchronicznie i może zwracać zadanie, które zostało już zakończone.</span><span class="sxs-lookup"><span data-stu-id="49e4d-132">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="49e4d-133">Wyjątki</span><span class="sxs-lookup"><span data-stu-id="49e4d-133">Exceptions</span></span>  
 <span data-ttu-id="49e4d-134">Metoda asynchroniczna powinna zgłosić wyjątek z wywołania metody asynchronicznej tylko w odpowiedzi na błąd użycia.</span><span class="sxs-lookup"><span data-stu-id="49e4d-134">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="49e4d-135">Błędy użycia nie powinny nigdy występować w kodzie produkcyjnym.</span><span class="sxs-lookup"><span data-stu-id="49e4d-135">Usage errors should never occur in production code.</span></span> <span data-ttu-id="49e4d-136">Na przykład jeśli przekazywanie odwołania`Nothing` null (w języku Visual Basic) jako jeden z argumentów <xref:System.ArgumentNullException> metody powoduje stan błędu (zwykle reprezentowane przez wyjątek), można zmodyfikować kod wywołujący, aby upewnić się, że odwołanie null nigdy nie jest przekazywana.</span><span class="sxs-lookup"><span data-stu-id="49e4d-136">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="49e4d-137">W przypadku innych błędów wyjątki, które występują, gdy uruchomiona jest metoda asynchroniczna, powinny być przypisane do zwracanego zadania, nawet jeśli metoda asynchroniczna jest wykonywana synchronicznie przed zwróceniem zadania.</span><span class="sxs-lookup"><span data-stu-id="49e4d-137">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="49e4d-138">Zadanie zawiera zazwyczaj co najwyżej jeden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="49e4d-138">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="49e4d-139">Jeśli jednak zadanie reprezentuje wiele operacji (na <xref:System.Threading.Tasks.Task.WhenAll%2A>przykład), wiele wyjątków może być skojarzonych z jednym zadaniem.</span><span class="sxs-lookup"><span data-stu-id="49e4d-139">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="49e4d-140">Środowisko docelowe</span><span class="sxs-lookup"><span data-stu-id="49e4d-140">Target environment</span></span>  
 <span data-ttu-id="49e4d-141">Podczas implementacji metody wzorca TAP można określić, gdzie występuje wykonanie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="49e4d-141">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="49e4d-142">Można wybrać opcję wykonania operacji w puli wątków, zaimplementować je za pomocą asynchronicznego wejścia/wyjścia (bez powiązania z wątkiem dla większości wykonywanych operacji), uruchomić je w określonym wątku (na przykład wątku interfejsu użytkownika) lub użyć dowolnej liczby potencjalnych kontekstów.</span><span class="sxs-lookup"><span data-stu-id="49e4d-142">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="49e4d-143">Metoda TAP może nawet nie mieć nic do <xref:System.Threading.Tasks.Task> wykonania i może po prostu zwrócić a, który reprezentuje wystąpienie warunku w innym miejscu w systemie (na przykład zadanie, które reprezentuje dane docierające do struktury danych w kolejce).</span><span class="sxs-lookup"><span data-stu-id="49e4d-143">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="49e4d-144">Obiekt wywołujący metody TAP może zablokować oczekiwanie na zakończenie metody TAP przez synchroniczne oczekiwanie na wynikowe zadanie lub może uruchomić dodatkowy (kontynuacja) kod po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="49e4d-144">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="49e4d-145">Twórca kodu kontynuacji ma kontrolę nad tym, gdzie ten kod jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="49e4d-145">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="49e4d-146">Można utworzyć kod kontynuacji jawnie, za <xref:System.Threading.Tasks.Task> pomocą metod w <xref:System.Threading.Tasks.Task.ContinueWith%2A>klasie (na przykład) lub niejawnie przy użyciu `await` obsługi języka `Await` zbudowany na `AwaitValue` podstawie kontynuacji (na przykład w języku C#, w języku Visual Basic, w F#).</span><span class="sxs-lookup"><span data-stu-id="49e4d-146">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="49e4d-147">Stan zadania</span><span class="sxs-lookup"><span data-stu-id="49e4d-147">Task status</span></span>  
 <span data-ttu-id="49e4d-148">Klasa <xref:System.Threading.Tasks.Task> zapewnia cykl życia dla operacji asynchronicznych i ten <xref:System.Threading.Tasks.TaskStatus> cykl jest reprezentowany przez wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="49e4d-148">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="49e4d-149">Aby obsługiwać przypadki narożnika <xref:System.Threading.Tasks.Task> typów, które pochodzą z i <xref:System.Threading.Tasks.Task%601>, oraz <xref:System.Threading.Tasks.Task> do obsługi <xref:System.Threading.Tasks.Task.Start%2A> oddzielenia konstrukcji od planowania, klasa udostępnia metodę.</span><span class="sxs-lookup"><span data-stu-id="49e4d-149">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="49e4d-150">Zadania, które są tworzone <xref:System.Threading.Tasks.Task> przez konstruktorów publicznych są określane jako *zimne zadania*, <xref:System.Threading.Tasks.TaskStatus.Created> ponieważ rozpoczynają swój <xref:System.Threading.Tasks.Task.Start%2A> cykl życia w stanie niezaplanowanym i są planowane tylko wtedy, gdy jest wywoływana w tych wystąpieniach.</span><span class="sxs-lookup"><span data-stu-id="49e4d-150">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="49e4d-151">Wszystkie inne zadania rozpoczynają swój cykl życia w stanie upalnej, co oznacza, że operacje asynchroniczne, <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>które reprezentują, zostały już zainicjowane, a ich stan zadania jest wartością wyliczenia inną niż .</span><span class="sxs-lookup"><span data-stu-id="49e4d-151">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="49e4d-152">Wszystkie zadania, które są zwracane z metod wzorca TAP, muszą być aktywowane.</span><span class="sxs-lookup"><span data-stu-id="49e4d-152">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="49e4d-153">**Jeśli metoda TAP wewnętrznie używa konstruktora zadania do utworzenia wystąpienia zadania, które ma <xref:System.Threading.Tasks.Task.Start%2A> zostać <xref:System.Threading.Tasks.Task> zwrócone, metoda TAP musi wywołać obiekt przed zwróceniem go.**</span><span class="sxs-lookup"><span data-stu-id="49e4d-153">**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="49e4d-154">Konsumenci metody TAP może bezpiecznie założyć, że zwrócone zadanie jest <xref:System.Threading.Tasks.Task.Start%2A> aktywne <xref:System.Threading.Tasks.Task> i nie należy próbować wywołać na każdym, który jest zwracany z metody TAP.</span><span class="sxs-lookup"><span data-stu-id="49e4d-154">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="49e4d-155">Wywołanie <xref:System.Threading.Tasks.Task.Start%2A> aktywnego zadania <xref:System.InvalidOperationException> powoduje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="49e4d-155">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="49e4d-156">Anulowanie (opcjonalnie)</span><span class="sxs-lookup"><span data-stu-id="49e4d-156">Cancellation (optional)</span></span>  
 <span data-ttu-id="49e4d-157">We wzorcu TAP anulowanie jest opcjonalne dla implementatorów metody asynchronicznej i konsumentów metody asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="49e4d-157">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="49e4d-158">Jeśli operacja umożliwia anulowanie, udostępnia przeciążenie metody asynchronicznej, która<xref:System.Threading.CancellationToken> akceptuje token anulowania (wystąpienie).</span><span class="sxs-lookup"><span data-stu-id="49e4d-158">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="49e4d-159">Zgodnie z konwencją `cancellationToken`parametr nosi nazwę .</span><span class="sxs-lookup"><span data-stu-id="49e4d-159">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="49e4d-160">Operacja asynchroniczna monitoruje ten token pod kątem żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="49e4d-160">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="49e4d-161">Jeśli odbierze żądanie anulowania, może je zaakceptować i anulować operację.</span><span class="sxs-lookup"><span data-stu-id="49e4d-161">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="49e4d-162">Jeśli żądanie anulowania powoduje przedwczesne zakończenie pracy, metoda TAP zwraca zadanie, które kończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanie; nie ma dostępnego wyniku i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="49e4d-162">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="49e4d-163">Stan <xref:System.Threading.Tasks.TaskStatus.Canceled> jest uważany za stan końcowy (ukończony) dla zadania, wraz z <xref:System.Threading.Tasks.TaskStatus.Faulted> i <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanów.</span><span class="sxs-lookup"><span data-stu-id="49e4d-163">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="49e4d-164">W związku z tym <xref:System.Threading.Tasks.TaskStatus.Canceled> jeśli zadanie <xref:System.Threading.Tasks.Task.IsCompleted%2A> jest `true`w stanie, jego właściwość zwraca .</span><span class="sxs-lookup"><span data-stu-id="49e4d-164">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="49e4d-165">Po zakończeniu zadania w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanie, wszelkie kontynuacje zarejestrowane w zadaniu są zaplanowane lub <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> wykonane, chyba że opcja kontynuacji, takich jak został określony, aby zrezygnować z kontynuacji.</span><span class="sxs-lookup"><span data-stu-id="49e4d-165">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="49e4d-166">Każdy kod, który jest asynchronicznie czeka na anulowane zadanie za pomocą <xref:System.OperationCanceledException> funkcji języka nadal działa, ale odbiera lub wyjątek pochodzi od niego.</span><span class="sxs-lookup"><span data-stu-id="49e4d-166">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="49e4d-167">Kod, który jest blokowany synchronicznie oczekiwanie na <xref:System.Threading.Tasks.Task.Wait%2A> <xref:System.Threading.Tasks.Task.WaitAll%2A> zadanie za pomocą metod, takich jak i również kontynuować uruchamianie z wyjątkiem.</span><span class="sxs-lookup"><span data-stu-id="49e4d-167">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="49e4d-168">Jeśli token anulowania zażądał anulowania przed tap metoda, która akceptuje ten token jest <xref:System.Threading.Tasks.TaskStatus.Canceled> wywoływana, metoda TAP należy zwrócić zadanie.</span><span class="sxs-lookup"><span data-stu-id="49e4d-168">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="49e4d-169">Jeśli jednak żądanie anulowania zostanie zgłoszone, gdy trwa operacja asynchroniczna, operacja asynchroniczna nie musi akceptować żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="49e4d-169">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="49e4d-170">Zwrócone zadanie powinno zakończyć <xref:System.Threading.Tasks.TaskStatus.Canceled> się w stanie tylko wtedy, gdy operacja kończy się w wyniku żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="49e4d-170">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="49e4d-171">Jeśli wymagane jest anulowanie, ale wynik lub wyjątek jest nadal <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> <xref:System.Threading.Tasks.TaskStatus.Faulted> produkowany, zadanie powinno zakończyć się w lub stanie.</span><span class="sxs-lookup"><span data-stu-id="49e4d-171">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="49e4d-172">W przypadku metod asynchronicznych, które mają uwidaczniać możliwość anulowania przede wszystkim, nie trzeba podać przeciążenia, które nie akceptuje token anulowania.</span><span class="sxs-lookup"><span data-stu-id="49e4d-172">For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.</span></span> <span data-ttu-id="49e4d-173">W przypadku metod, które nie mogą być anulowane, nie należy dostarczać przeciążeń, które akceptują token anulowania. Pomaga to wskazać obiektowi wywołującemu, czy metodę docelową można w rzeczywistości anulować.</span><span class="sxs-lookup"><span data-stu-id="49e4d-173">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="49e4d-174">Kod konsumenta, który nie chce anulowania może <xref:System.Threading.CancellationToken> wywołać metodę, która akceptuje i podać <xref:System.Threading.CancellationToken.None%2A> jako wartość argumentu.</span><span class="sxs-lookup"><span data-stu-id="49e4d-174">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="49e4d-175"><xref:System.Threading.CancellationToken.None%2A>jest funkcjonalnie równoważny <xref:System.Threading.CancellationToken>domyślnemu .</span><span class="sxs-lookup"><span data-stu-id="49e4d-175"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="49e4d-176">Raportowanie postępu (opcjonalnie)</span><span class="sxs-lookup"><span data-stu-id="49e4d-176">Progress reporting (optional)</span></span>  
 <span data-ttu-id="49e4d-177">Niektóre operacje asynchroniczne korzystają z dostarczania powiadomień na temat postępu. Zazwyczaj są one używane do aktualizowania interfejsu użytkownika za pomocą informacji o postępie operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="49e4d-177">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="49e4d-178">W tap postęp jest obsługiwany <xref:System.IProgress%601> przez interfejs, który jest przekazywany do metody asynchronicznej jako parametr, który jest zwykle o nazwie `progress`.</span><span class="sxs-lookup"><span data-stu-id="49e4d-178">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="49e4d-179">Dostarczenie interfejsu postępu, gdy wywoływana jest metoda asynchroniczna, pomaga wyeliminować sytuację wyścigu, która wynika z niepoprawnego użycia (tzn. kiedy obsługa zdarzeń, która jest niepoprawnie rejestrowana po rozpoczęciu operacji, może pominąć aktualizacje).</span><span class="sxs-lookup"><span data-stu-id="49e4d-179">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="49e4d-180">Co więcej, interfejs postępu obsługuje różne implementacje postępu, co zostało określone przez kod konsumencki.</span><span class="sxs-lookup"><span data-stu-id="49e4d-180">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="49e4d-181">Kod konsumencki może uwzględniać tylko najnowszą aktualizację postępu lub może buforować wszystkie aktualizacje. Może on wywołać akcję dla każdej aktualizacji lub może określać, czy wywołanie jest przekazywane do określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="49e4d-181">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="49e4d-182">Te opcje można osiągnąć przy użyciu różnej implementacji interfejsu, dostosowanej do potrzeb danego konsumenta.</span><span class="sxs-lookup"><span data-stu-id="49e4d-182">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.</span></span>  <span data-ttu-id="49e4d-183">Podobnie jak w przypadku anulowania <xref:System.IProgress%601> implementacje TAP powinny zapewniać parametr tylko wtedy, gdy interfejs API obsługuje powiadomienia o postępie.</span><span class="sxs-lookup"><span data-stu-id="49e4d-183">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="49e4d-184">Na przykład jeśli `ReadAsync` metoda omówiona wcześniej w tym artykule jest w stanie zgłosić postęp pośredni w postaci liczby <xref:System.IProgress%601> bajtów odczytanych do tej pory, wywołanie wywołania wywołania pokroku może być interfejs:</span><span class="sxs-lookup"><span data-stu-id="49e4d-184">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="49e4d-185">Jeśli `FindFilesAsync` metoda zwraca listę wszystkich plików, które spełniają określony wzorzec wyszukiwania, wywołanie wywołania wywołania wywołania postępu może dostarczyć oszacowanie procentu pracy wykonanej, a także bieżący zestaw wyników częściowych.</span><span class="sxs-lookup"><span data-stu-id="49e4d-185">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.</span></span>  <span data-ttu-id="49e4d-186">Może to zrobić za pomocą spójnej kolekcji:</span><span class="sxs-lookup"><span data-stu-id="49e4d-186">It could do this either with a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="49e4d-187">lub za pomocą typu danych specyficznego dla interfejsu API:</span><span class="sxs-lookup"><span data-stu-id="49e4d-187">or with a data type that is specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="49e4d-188">W tym ostatnim przypadku specjalny typ danych jest `ProgressInfo`zwykle sufiksowany z .</span><span class="sxs-lookup"><span data-stu-id="49e4d-188">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="49e4d-189">Jeśli implementacje TAP zapewniają `progress` przeciążenia, które akceptują `null`parametr, muszą one zezwalać na argument, w którym to przypadku nie będzie raportowany postęp.</span><span class="sxs-lookup"><span data-stu-id="49e4d-189">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported.</span></span> <span data-ttu-id="49e4d-190">Implementacje TAP należy zgłosić <xref:System.Progress%601> postęp do obiektu synchronicznie, co umożliwia metodę asynchroniczną, aby szybko zapewnić postęp i umożliwić konsumentowi postępu, aby określić, jak i gdzie najlepiej obsługiwać informacje.</span><span class="sxs-lookup"><span data-stu-id="49e4d-190">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="49e4d-191">Na przykład wystąpienie postępu może wybrać przekazywanie wywołań zwrotnych i generowanie zdarzeń w kontekście przechwyconych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="49e4d-191">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="49e4d-192">Implementacje> IProgress\<T</span><span class="sxs-lookup"><span data-stu-id="49e4d-192">IProgress\<T> implementations</span></span>  
 <span data-ttu-id="49e4d-193">Program .NET Framework 4.5 <xref:System.IProgress%601> zapewnia <xref:System.Progress%601>jedną implementację: .</span><span class="sxs-lookup"><span data-stu-id="49e4d-193">The .NET Framework 4.5 provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="49e4d-194">Klasa <xref:System.Progress%601> jest zadeklarowana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="49e4d-194">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="49e4d-195">Wystąpienie <xref:System.Progress%601> udostępnia <xref:System.Progress%601.ProgressChanged> zdarzenie, które jest wywoływane za każdym razem, gdy operacja asynchroniczna zgłasza aktualizację postępu.</span><span class="sxs-lookup"><span data-stu-id="49e4d-195">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="49e4d-196">Zdarzenie <xref:System.Progress%601.ProgressChanged> jest wywoływane <xref:System.Threading.SynchronizationContext> na obiekcie, <xref:System.Progress%601> który został przechwycony, gdy wystąpienie zostało uprzedzione.</span><span class="sxs-lookup"><span data-stu-id="49e4d-196">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="49e4d-197">Jeśli kontekst synchronizacji nie był dostępny, używany jest domyślny kontekst ukierunkowany na pulę wątków.</span><span class="sxs-lookup"><span data-stu-id="49e4d-197">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="49e4d-198">Z tym zdarzeniem można zarejestrować programy obsługi.</span><span class="sxs-lookup"><span data-stu-id="49e4d-198">Handlers may be registered with this event.</span></span> <span data-ttu-id="49e4d-199">Pojedynczy program obsługi może również <xref:System.Progress%601> być dostarczone do konstruktora dla wygody <xref:System.Progress%601.ProgressChanged> i zachowuje się podobnie jak program obsługi zdarzeń dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="49e4d-199">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="49e4d-200">Aktualizacje postępu są wywoływane asynchronicznie, aby unikać opóźniania operacji asynchronicznej podczas wykonywania obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="49e4d-200">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="49e4d-201">Inna <xref:System.IProgress%601> implementacja może zdecydować się na zastosowanie różnych semantyki.</span><span class="sxs-lookup"><span data-stu-id="49e4d-201">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="49e4d-202">Wybór przeciążeń w celu zapewnienia</span><span class="sxs-lookup"><span data-stu-id="49e4d-202">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="49e4d-203">Jeśli implementacja TAP używa <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> parametrów <xref:System.IProgress%601> opcjonalnych i opcjonalnych, może potencjalnie wymagać maksymalnie czterech przeciążeń:</span><span class="sxs-lookup"><span data-stu-id="49e4d-203">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="49e4d-204">Wiele implementacji wzorca TAP nie dostarcza jednak możliwości anulowania ani możliwości obsługi postępu, więc wymagają one pojedynczej metody:</span><span class="sxs-lookup"><span data-stu-id="49e4d-204">However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="49e4d-205">Jeżeli implementacja wzorca TAP obsługuje anulowanie lub postęp, ale nie obie te możliwości naraz, może ona dostarczać dwa przeciążenia:</span><span class="sxs-lookup"><span data-stu-id="49e4d-205">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="49e4d-206">Jeśli implementacja wzorca TAP obsługuje zarówno anulowanie, jak i postęp, może uwidaczniać wszystkie cztery przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="49e4d-206">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="49e4d-207">Może jednak dostarczyć tylko następujące dwa:</span><span class="sxs-lookup"><span data-stu-id="49e4d-207">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="49e4d-208">Aby skompensować dwie brakujące kombinacje <xref:System.Threading.CancellationToken.None%2A> pośrednie, <xref:System.Threading.CancellationToken> deweloperzy mogą przekazać lub domyślnie dla parametru `cancellationToken` i `null` parametru. `progress`</span><span class="sxs-lookup"><span data-stu-id="49e4d-208">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="49e4d-209">Jeśli każde użycie metody wzorca TAP ma obsługiwać anulowanie lub postęp, możesz pominąć przeciążenia, które nie akceptują odpowiedniego parametru.</span><span class="sxs-lookup"><span data-stu-id="49e4d-209">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="49e4d-210">Jeśli zdecydujesz się uwidaczniać wiele przeciążeń, aby anulowanie lub postęp były opcjonalne, przeciążenia, które nie obsługują anulowania lub postępu, powinny zachowywać się tak, jakby zostały przekazane <xref:System.Threading.CancellationToken.None%2A> do anulowania lub `null` postępu do przeciążenia, które obsługuje te.</span><span class="sxs-lookup"><span data-stu-id="49e4d-210">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="49e4d-211">Powiązane tematy</span><span class="sxs-lookup"><span data-stu-id="49e4d-211">Related topics</span></span>  
  
|<span data-ttu-id="49e4d-212">Tytuł</span><span class="sxs-lookup"><span data-stu-id="49e4d-212">Title</span></span>|<span data-ttu-id="49e4d-213">Opis</span><span class="sxs-lookup"><span data-stu-id="49e4d-213">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="49e4d-214">Wzorce programowania asynchronicznego</span><span class="sxs-lookup"><span data-stu-id="49e4d-214">Asynchronous Programming Patterns</span></span>](../../../docs/standard/asynchronous-programming-patterns/index.md)|<span data-ttu-id="49e4d-215">Wprowadza trzy wzorce do wykonywania operacji asynchronicznych: asynchroniczny wzorzec oparty na zadaniach (TAP), asynchroniczny model programowania (APM) i asynchroniczny wzorzec oparty na zdarzeniach (EAP).</span><span class="sxs-lookup"><span data-stu-id="49e4d-215">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="49e4d-216">Implementacja wzorca asynchronicznego opartego na zadaniach</span><span class="sxs-lookup"><span data-stu-id="49e4d-216">Implementing the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="49e4d-217">Opis sposobu implementacji asynchronicznego wzorca opartego na zadaniach (TAP), którą można przeprowadzić na trzy sposoby: za pomocą kompilatorów języków C# i Visual Basic w programie Visual Studio, ręcznie lub za pomocą kombinacji metod kompilatora i manualnych.</span><span class="sxs-lookup"><span data-stu-id="49e4d-217">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="49e4d-218">Wykorzystywanie wzorca asynchronicznego opartego na zadaniach</span><span class="sxs-lookup"><span data-stu-id="49e4d-218">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="49e4d-219">Opis sposobu używania zadań i wywołań zwrotnych w celu osiągnięcia oczekiwania bez blokowania.</span><span class="sxs-lookup"><span data-stu-id="49e4d-219">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="49e4d-220">Współdziałanie z innymi wzorcami asynchronicznymi i typami</span><span class="sxs-lookup"><span data-stu-id="49e4d-220">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="49e4d-221">Opis sposobu używania asynchronicznego wzorca opartego na zadaniach (TAP) w celu implementacji asynchronicznego modelu programowania (APM) i asynchronicznego wzorca opartego na zdarzeniach (EAP).</span><span class="sxs-lookup"><span data-stu-id="49e4d-221">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
