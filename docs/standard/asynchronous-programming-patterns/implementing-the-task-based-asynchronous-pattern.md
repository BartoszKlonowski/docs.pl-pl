---
title: Implementacja wzorca asynchronicznego opartego na zadaniach
ms.date: 06/14/2017
ms.prod: .net
ms.technology: dotnet-clr
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 238f164fec78fe5e6dae9e7880fabc0a386bf399
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/23/2017
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="e95d2-102">Implementacja wzorca asynchronicznego opartego na zadaniach</span><span class="sxs-lookup"><span data-stu-id="e95d2-102">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="e95d2-103">Oparty na zadaniach asynchronicznej wzorca (TAP) można wdrożyć na trzy sposoby: za pomocą Kompilatory języka C# i Visual Basic w programie Visual Studio, ręcznie lub za pomocą kombinacji metod kompilatora i ręcznie.</span><span class="sxs-lookup"><span data-stu-id="e95d2-103">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="e95d2-104">W poniższych sekcjach omówiono każdej metody szczegółowo.</span><span class="sxs-lookup"><span data-stu-id="e95d2-104">The following sections discuss each method in detail.</span></span> <span data-ttu-id="e95d2-105">Wzorzec NACIŚNIJ umożliwia implementować zarówno powiązane z obliczeń, jak i I/E-powiązane z operacji asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="e95d2-105">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="e95d2-106">[Obciążeń](#workloads) sekcji omówiono każdego typu działania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-106">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="e95d2-107">Generowanie wybranie metody</span><span class="sxs-lookup"><span data-stu-id="e95d2-107">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="e95d2-108">Przy użyciu kompilatory</span><span class="sxs-lookup"><span data-stu-id="e95d2-108">Using the compilers</span></span>
<span data-ttu-id="e95d2-109">Począwszy od [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], dowolnej metody, która ma atrybut `async` — słowo kluczowe (`Async` w języku Visual Basic) jest uznawany za metody asynchronicznej i Kompilatory języka C# i Visual Basic wykonać transformacje niezbędne do wdrożenia metody asynchroniczne, używając NACIŚNIJ.</span><span class="sxs-lookup"><span data-stu-id="e95d2-109">Starting with [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="e95d2-110">Metody asynchronicznej powinien zwrócić albo <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> obiektu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-110">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="e95d2-111">W przypadku drugiego nagłówka, powinien zwrócić treści funkcji `TResult`, i kompilator zapewnia wynik jest udostępnione za pośrednictwem wynikowego obiektu zadania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-111">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="e95d2-112">Podobnie, wszelkie wyjątki, które go nieobsługiwany w treści metody są przekazywane do danych wyjściowych zadania i spowodować wynikowy zadania kończyć się <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> stanu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-112">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="e95d2-113">Wyjątek stanowi, kiedy <xref:System.OperationCanceledException> (lub typu pochodnego) nieobsługiwany umieszczane, w którym to przypadku zadaniu wynikowym kończy się <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> stanu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-113">The exception is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="e95d2-114">Generowanie metody NACIŚNIJ ręcznie</span><span class="sxs-lookup"><span data-stu-id="e95d2-114">Generating TAP methods manually</span></span>
<span data-ttu-id="e95d2-115">Może wdrożyć wzorcem NACIŚNIJ ręcznie lepszą kontrolę nad implementacji.</span><span class="sxs-lookup"><span data-stu-id="e95d2-115">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="e95d2-116">Kompilator zależy od uwidaczniać jej w publicznej powierzchni <xref:System.Threading.Tasks?displayProperty=nameWithType> przestrzeni nazw i obsługi typów w <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e95d2-116">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="e95d2-117">Aby zaimplementować PRZYŁOŻENIU samodzielnie, należy utworzyć <xref:System.Threading.Tasks.TaskCompletionSource%601> obiektu, wykonaj operację asynchroniczną i po jego ukończeniu, należy wywołać <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, lub <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> metody, lub `Try` wersji jednej z tych metod.</span><span class="sxs-lookup"><span data-stu-id="e95d2-117">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="e95d2-118">Gdy ręcznie zaimplementować metodę NACIŚNIJ zadaniu wynikowym należy wykonać po zakończeniu operacji asynchronicznej reprezentowanego.</span><span class="sxs-lookup"><span data-stu-id="e95d2-118">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="e95d2-119">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="e95d2-119">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="e95d2-120">Podejście hybrydowego</span><span class="sxs-lookup"><span data-stu-id="e95d2-120">Hybrid approach</span></span>
 <span data-ttu-id="e95d2-121">Mogą być przydatne, aby ręcznie zaimplementować wzorzec NACIŚNIJ, ale aby delegować logiki core do wykonania w kompilatorze.</span><span class="sxs-lookup"><span data-stu-id="e95d2-121">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="e95d2-122">Na przykład można użyć metody hybrydowych, gdy chcesz zweryfikować argumenty poza generowane przez kompilator metody asynchronicznej, dzięki czemu można escape wyjątki, aby metody bezpośredniego wywołującego, a nie są dostępne za pośrednictwem <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> obiektu:</span><span class="sxs-lookup"><span data-stu-id="e95d2-122">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="e95d2-123">Jest innym przypadku, gdy taki delegowania jest przydatne w przypadku jest implementacja optymalizacji fast-path i chcesz zwracać buforowane zadania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-123">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="e95d2-124">Obciążeń</span><span class="sxs-lookup"><span data-stu-id="e95d2-124">Workloads</span></span>
<span data-ttu-id="e95d2-125">Zarówno powiązane z obliczeń, jak i I/E-powiązane z operacji asynchronicznych może wdrożyć jako wybranie metody.</span><span class="sxs-lookup"><span data-stu-id="e95d2-125">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="e95d2-126">Jednak gdy wybranie metody są udostępniane publicznie z biblioteki, powinny one dostępne tylko dla obciążeń, które obejmują operacje I/E-granica (one mogą również obejmować obliczeń, ale nie może być całkowicie obliczeniową).</span><span class="sxs-lookup"><span data-stu-id="e95d2-126">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="e95d2-127">Jeśli metoda jest wyłącznie obliczeń wiązaniem, powinny zostać ujawnione tylko jako synchroniczne implementacji.</span><span class="sxs-lookup"><span data-stu-id="e95d2-127">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="e95d2-128">Kod, który wykorzystuje ona może następnie wybrać, czy powodującą otoczenie wywołania tej metody synchroniczne zadanie odciążania pracy do innego wątku lub osiągnięcie równoległości.</span><span class="sxs-lookup"><span data-stu-id="e95d2-128">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="e95d2-129">A jeśli metoda jest związany z we/wy, powinny zostać ujawnione tylko jako implementacja asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="e95d2-129">And if a method is IO-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="e95d2-130">Zadania powiązane z obliczeń</span><span class="sxs-lookup"><span data-stu-id="e95d2-130">Compute-bound tasks</span></span>
<span data-ttu-id="e95d2-131"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> Klasy doskonale nadaje się do reprezentujący praktyce intensywne operacje.</span><span class="sxs-lookup"><span data-stu-id="e95d2-131">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="e95d2-132">Domyślnie, jego zalet specjalną obsługę w <xref:System.Threading.ThreadPool> klasy aby zapewnić efektywne wykonanie, a także zapewnia znaczną kontrolę nad tym, kiedy, jak i gdzie wykonywanie obliczeń asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="e95d2-132">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="e95d2-133">Może wygenerować zadań powiązanych z obliczeń w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="e95d2-133">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="e95d2-134">W .NET Framework 4, użyj <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodę, która akceptuje delegata (zazwyczaj <xref:System.Action%601> lub <xref:System.Func%601>) ma być wykonywana w sposób asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="e95d2-134">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="e95d2-135">Jeśli podasz <xref:System.Action%601> delegować, metoda zwraca <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> obiekt, który reprezentuje asynchroniczne wykonywanie tego delegata.</span><span class="sxs-lookup"><span data-stu-id="e95d2-135">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="e95d2-136">Jeśli podasz <xref:System.Func%601> delegować, metoda zwraca <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> obiektu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-136">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="e95d2-137">Overloads z <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metoda akceptuje token anulowania (<xref:System.Threading.CancellationToken>), opcje tworzenia zadań (<xref:System.Threading.Tasks.TaskCreationOptions>) i harmonogram zadań (<xref:System.Threading.Tasks.TaskScheduler>), które zapewniają precyzyjną kontrolę nad planowania i wykonywania zadania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-137">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="e95d2-138">Wystąpienia fabryki, przeznaczonego dla bieżącego harmonogramu zadań jest dostępna jako właściwość statyczna (<xref:System.Threading.Tasks.Task.Factory%2A>) z <xref:System.Threading.Tasks.Task> klasy; na przykład: `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="e95d2-138">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="e95d2-139">W [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] i nowszych wersjach (w tym oprogramowanie .NET Core i .NET Standard), użyj statycznych <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metody w celu szybkiego <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e95d2-139">In the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e95d2-140">Możesz użyć <xref:System.Threading.Tasks.Task.Run%2A> można łatwo uruchomić zadań powiązanych z obliczeń, przeznaczonego dla puli wątków.</span><span class="sxs-lookup"><span data-stu-id="e95d2-140">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="e95d2-141">W [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] i nowszych wersjach, jest to preferowany sposób uruchamiania zadań powiązanych z obliczeń.</span><span class="sxs-lookup"><span data-stu-id="e95d2-141">In the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="e95d2-142">Użyj `StartNew` bezpośrednio tylko jeśli chcesz bardziej precyzyjną kontrolę nad zadania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-142">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="e95d2-143">Użyj konstruktorów `Task` typu lub `Start` metodę, jeśli chcesz wygenerować i Zaplanuj zadanie oddzielnie.</span><span class="sxs-lookup"><span data-stu-id="e95d2-143">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="e95d2-144">Metody publiczne musi zwracać tylko zadania, które zostało już rozpoczęte.</span><span class="sxs-lookup"><span data-stu-id="e95d2-144">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="e95d2-145">Użyj przeciążeń <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="e95d2-145">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e95d2-146">Ta metoda tworzy nowe zadanie, które jest zaplanowane po zakończeniu inne zadanie.</span><span class="sxs-lookup"><span data-stu-id="e95d2-146">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="e95d2-147">Niektóre <xref:System.Threading.Tasks.Task.ContinueWith%2A> przeciążenia zaakceptować token anulowania, opcje kontynuacji i harmonogram zadań, aby uzyskać lepszą kontrolę nad planowania i wykonywania zadania kontynuacji.</span><span class="sxs-lookup"><span data-stu-id="e95d2-147">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="e95d2-148">Użyj <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> i <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="e95d2-148">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="e95d2-149">Te metody utworzyć nowe zadanie, które jest zaplanowane po zakończeniu wszystkie lub niektóre podane zestaw zadań.</span><span class="sxs-lookup"><span data-stu-id="e95d2-149">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="e95d2-150">Te metody Podaj także przeciążenia do kontrolowania, planowania i wykonywania tych zadań.</span><span class="sxs-lookup"><span data-stu-id="e95d2-150">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="e95d2-151">W zadań powiązanych z obliczeń system można uniemożliwić uruchomienia zaplanowanego zadania, jeśli odbiera żądanie anulowania, przed rozpoczęciem wykonywania zadania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-151">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="e95d2-152">Działa w taki sposób, jeśli podasz token anulowania (<xref:System.Threading.CancellationToken> obiektu), można przekazać tokenu do asynchronicznego kod, który monitoruje tokenu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-152">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="e95d2-153">Można też podać token do jednej z metod opisanych powyżej takich jak `StartNew` lub `Run` , aby `Task` środowiska uruchomieniowego może także monitorować tokenu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-153">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="e95d2-154">Rozważmy na przykład metoda asynchroniczna, który renderuje obraz.</span><span class="sxs-lookup"><span data-stu-id="e95d2-154">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="e95d2-155">Treść zadania można sondować token anulowania, dzięki czemu kod może zakończyć wcześniej, jeśli żądanie anulowania podczas renderowania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-155">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="e95d2-156">Ponadto jeśli żądanie anulowania przed rozpoczęciem renderowania, należy operacja renderowania:</span><span class="sxs-lookup"><span data-stu-id="e95d2-156">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="e95d2-157">Zadań powiązanych z obliczeń kończyć się <xref:System.Threading.Tasks.TaskStatus.Canceled> stan, jeśli wartość true, jest co najmniej jeden z następujących warunków:</span><span class="sxs-lookup"><span data-stu-id="e95d2-157">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="e95d2-158">Żądanie anulowania dociera do <xref:System.Threading.CancellationToken> obiektu, który jest dostarczany jako argument do metody tworzenia (na przykład `StartNew` lub `Run`) przed przejścia zadań do <xref:System.Threading.Tasks.TaskStatus.Running> stanu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-158">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="e95d2-159"><xref:System.OperationCanceledException> Wyjątków przechodzi nieobsługiwany w treści takie zadania, czy wyjątek zawiera takie same <xref:System.Threading.CancellationToken> przekazanego do zadania, a token zawiera zażądano anulowania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-159">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="e95d2-160">Jeśli nie jest nieobsługiwany w treści zadania kolejny wyjątek, zadanie kończy się <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu i wszelkie próby oczekiwanie na zadanie lub zostać zgłoszony wyjątek powoduje jego wynik dostępu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-160">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="e95d2-161">Zadania I/E-granica</span><span class="sxs-lookup"><span data-stu-id="e95d2-161">I/O-bound tasks</span></span>
<span data-ttu-id="e95d2-162">Aby utworzyć zadanie, które nie powinny być bezpośrednio kopii przez wątek dla całości jego wykonywania, użyj <xref:System.Threading.Tasks.TaskCompletionSource%601> typu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-162">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="e95d2-163">Ten typ przedstawia <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> właściwości, która zwraca skojarzony <xref:System.Threading.Tasks.Task%601> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="e95d2-163">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="e95d2-164">Cykl życia to zadanie jest kontrolowany przez <xref:System.Threading.Tasks.TaskCompletionSource%601> metod, takich jak <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>i ich `TrySet` wariantów.</span><span class="sxs-lookup"><span data-stu-id="e95d2-164">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="e95d2-165">Załóżmy, że chcesz utworzyć zadanie, które zostanie ukończona po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="e95d2-165">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="e95d2-166">Na przykład można opóźnić działanie w interfejsie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e95d2-166">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="e95d2-167"><xref:System.Threading.Timer?displayProperty=nameWithType> Klasy już umożliwia asynchroniczne wywołanie delegata po upływie określonego czasu i za pomocą <xref:System.Threading.Tasks.TaskCompletionSource%601> można umieścić <xref:System.Threading.Tasks.Task%601> FrontPage na zegarze, na przykład:</span><span class="sxs-lookup"><span data-stu-id="e95d2-167">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="e95d2-168">Począwszy od [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> metoda znajduje się w tym celu i umożliwia wewnątrz innej metody asynchroniczne, na przykład do zaimplementowania pętli asynchroniczne sondowania:</span><span class="sxs-lookup"><span data-stu-id="e95d2-168">Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="e95d2-169"><xref:System.Threading.Tasks.TaskCompletionSource%601> Klasa nie ma odpowiednika nierodzajową.</span><span class="sxs-lookup"><span data-stu-id="e95d2-169">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="e95d2-170">Jednak <xref:System.Threading.Tasks.Task%601> pochodną <xref:System.Threading.Tasks.Task>, dzięki czemu można używać ogólnych <xref:System.Threading.Tasks.TaskCompletionSource%601> obiektu dla metody I/E-granica, po prostu zwracające zadania.</span><span class="sxs-lookup"><span data-stu-id="e95d2-170">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="e95d2-171">Aby to zrobić, można używać źródła z manekina `TResult` (<xref:System.Boolean> jest wybór domyślny dobry, ale jeśli masz obawy użytkownik <xref:System.Threading.Tasks.Task> rzutowanie w dół go do <xref:System.Threading.Tasks.Task%601>, można użyć prywatnych `TResult` zamiast tego wpisz).</span><span class="sxs-lookup"><span data-stu-id="e95d2-171">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="e95d2-172">Na przykład `Delay` metoda w poprzednim przykładzie zwraca bieżącą godzinę wraz z powstałe w ten sposób przesunięcia (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="e95d2-172">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="e95d2-173">Jeśli wartość wyniku nie jest konieczne, metoda może być zamiast tego kodowane w następujący sposób (zmiany zwracanego typu i zmiana argumentu <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="e95d2-173">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="e95d2-174">Mieszane zadań powiązanych z obliczeń i I/E-powiązane z</span><span class="sxs-lookup"><span data-stu-id="e95d2-174">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="e95d2-175">Nie są ograniczone do operacji tylko powiązane z obliczeń lub I/E-powiązane z metod asynchronicznych, ale może reprezentować kombinację dwa.</span><span class="sxs-lookup"><span data-stu-id="e95d2-175">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="e95d2-176">W rzeczywistości wiele operacji asynchronicznych często są łączone w większych mieszanych operacji.</span><span class="sxs-lookup"><span data-stu-id="e95d2-176">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="e95d2-177">Na przykład `RenderAsync` praktyce intensywna operacja by renderować obraz oparty na niektórych danych wejściowych wykonywane w poprzednim przykładzie metody `imageData`.</span><span class="sxs-lookup"><span data-stu-id="e95d2-177">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="e95d2-178">To `imageData` może pochodzić z usługi sieci web, do którego dostęp asynchronicznie:</span><span class="sxs-lookup"><span data-stu-id="e95d2-178">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="e95d2-179">Również w tym przykładzie pokazano, jak token anulowania pojedynczego może wątków za pomocą wielu operacji asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="e95d2-179">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="e95d2-180">Aby uzyskać więcej informacji, zobacz sekcję użycia anulowania w [wykorzystywanie wzorca asynchronicznego opartego na zadaniach](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="e95d2-180">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e95d2-181">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="e95d2-181">See also</span></span>
 [<span data-ttu-id="e95d2-182">Wzorzec asynchroniczny oparty na zadaniach (TAP)</span><span class="sxs-lookup"><span data-stu-id="e95d2-182">Task-based Asynchronous Pattern (TAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)  
 [<span data-ttu-id="e95d2-183">Wykorzystywanie wzorca asynchronicznego opartego na zadaniach</span><span class="sxs-lookup"><span data-stu-id="e95d2-183">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)  
 [<span data-ttu-id="e95d2-184">Współdziałanie z innymi wzorcami asynchronicznymi i typami</span><span class="sxs-lookup"><span data-stu-id="e95d2-184">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)  
