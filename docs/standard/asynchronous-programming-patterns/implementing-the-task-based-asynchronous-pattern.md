---
title: Implementacja wzorca asynchronicznego opartego na zadaniach
description: W tym artykule wyjaśniono, jak zaimplementować wzorzec asynchroniczny oparty na zadaniach. Służy do implementowania operacji asynchronicznych powiązanych z obliczeniami i we/wy.
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 8bac9d265211d2f266db634d4bcebb87c2debd9a
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/28/2020
ms.locfileid: "92888779"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="54ddb-104">Implementacja wzorca asynchronicznego opartego na zadaniach</span><span class="sxs-lookup"><span data-stu-id="54ddb-104">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="54ddb-105">Wzorzec asynchroniczny oparty na zadaniach (TAP) można zaimplementować na trzy sposoby: za pomocą kompilatorów C# i Visual Basic w programie Visual Studio, ręcznie lub za pomocą kombinacji kompilatora i metod ręcznych.</span><span class="sxs-lookup"><span data-stu-id="54ddb-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="54ddb-106">W poniższych sekcjach szczegółowo omówiono każdą metodę.</span><span class="sxs-lookup"><span data-stu-id="54ddb-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="54ddb-107">Możesz użyć wzorca TAP, aby zaimplementować operacje asynchroniczne powiązane z obliczaniem i we/wy.</span><span class="sxs-lookup"><span data-stu-id="54ddb-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="54ddb-108">W sekcji [obciążenia](#workloads) omówiono każdy typ operacji.</span><span class="sxs-lookup"><span data-stu-id="54ddb-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="54ddb-109">Generowanie metod TAP</span><span class="sxs-lookup"><span data-stu-id="54ddb-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="54ddb-110">Korzystanie z kompilatorów</span><span class="sxs-lookup"><span data-stu-id="54ddb-110">Using the compilers</span></span>
<span data-ttu-id="54ddb-111">Począwszy od .NET Framework 4,5, każda metoda, która jest przypisana za pomocą `async` słowa kluczowego ( `Async` w Visual Basic) jest uznawana za metodę asynchroniczną, a kompilatory C# i Visual Basic wykonują wymagane przekształcenia w celu asynchronicznego zaimplementowania metody przy użyciu narzędzia TAP.</span><span class="sxs-lookup"><span data-stu-id="54ddb-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="54ddb-112">Metoda asynchroniczna powinna zwracać albo <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> obiekt.</span><span class="sxs-lookup"><span data-stu-id="54ddb-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="54ddb-113">Dla tej ostatniej, treść funkcji powinna zwracać `TResult` i kompilator zapewnia, że wynik jest udostępniany przez wynikowy obiekt zadania.</span><span class="sxs-lookup"><span data-stu-id="54ddb-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="54ddb-114">Podobnie wszystkie wyjątki, które nie są obsługiwane w treści metody są przekazywane do zadania wyjściowego i powodują, że wynikowe zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> stanie.</span><span class="sxs-lookup"><span data-stu-id="54ddb-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="54ddb-115">Wyjątkiem od tej reguły jest <xref:System.OperationCanceledException> nieobsłużony (lub typ pochodny), w którym przypadku wyniki zadania kończą się w <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> stanie.</span><span class="sxs-lookup"><span data-stu-id="54ddb-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="54ddb-116">Ręczne generowanie metod TAP</span><span class="sxs-lookup"><span data-stu-id="54ddb-116">Generating TAP methods manually</span></span>
<span data-ttu-id="54ddb-117">Wzorzec TAP można zaimplementować ręcznie w celu zapewnienia lepszej kontroli nad implementacją.</span><span class="sxs-lookup"><span data-stu-id="54ddb-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="54ddb-118">Kompilator opiera się na obszarze powierzchni publicznej uwidocznionej z <xref:System.Threading.Tasks?displayProperty=nameWithType> przestrzeni nazw i typów pomocniczych w <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="54ddb-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="54ddb-119">Aby zaimplementować samodzielne wybieranie, należy utworzyć <xref:System.Threading.Tasks.TaskCompletionSource%601> obiekt, wykonać operację asynchroniczną i po jego zakończeniu wywołać <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A> <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> metodę,, lub <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> lub `Try` wersję jednej z tych metod.</span><span class="sxs-lookup"><span data-stu-id="54ddb-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="54ddb-120">W przypadku ręcznego zaimplementowania metody TAP należy wykonać zadanie podrzędne, gdy zostanie ukończona operacja asynchroniczna.</span><span class="sxs-lookup"><span data-stu-id="54ddb-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="54ddb-121">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="54ddb-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="54ddb-122">Podejście hybrydowe</span><span class="sxs-lookup"><span data-stu-id="54ddb-122">Hybrid approach</span></span>
 <span data-ttu-id="54ddb-123">Przydatne może okazać się ręczne wdrożenie wzorca TAP, ale w celu delegowania podstawowej logiki implementacji do kompilatora.</span><span class="sxs-lookup"><span data-stu-id="54ddb-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="54ddb-124">Na przykład możesz chcieć użyć podejścia hybrydowego, gdy chcesz zweryfikować argumenty poza metodę asynchroniczną wygenerowaną przez kompilator, aby wyjątki mogły wyjść bezpośrednio do obiektu wywołującego metody, a nie ujawniać go za pośrednictwem <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="54ddb-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method's direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="54ddb-125">Innym przypadkiem, gdy takie delegowanie jest przydatne, jest wdrożenie szybkiej optymalizacji ścieżki i zwrócenie zadania w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="54ddb-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="54ddb-126">Obciążenia</span><span class="sxs-lookup"><span data-stu-id="54ddb-126">Workloads</span></span>
<span data-ttu-id="54ddb-127">Można zaimplementować operacje asynchroniczne powiązane z obliczeniami i we/wy jako metody TAP.</span><span class="sxs-lookup"><span data-stu-id="54ddb-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="54ddb-128">Mimo że metody TAP są ujawniane publicznie z biblioteki, powinny być dostarczane tylko w przypadku obciążeń obejmujących operacje we/wy (mogą także dotyczyć obliczeń, ale nie powinny być czyste).</span><span class="sxs-lookup"><span data-stu-id="54ddb-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="54ddb-129">Jeśli metoda ma charakter wyłącznie obliczeniowy, powinno być uwidoczniona tylko jako implementacja synchroniczna.</span><span class="sxs-lookup"><span data-stu-id="54ddb-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="54ddb-130">Kod, który go zużywa, może następnie zdecydować, czy należy otoczyć wywołanie tej metody synchronicznej do zadania w celu odciążenia pracy do innego wątku lub osiągnięcia równoległości.</span><span class="sxs-lookup"><span data-stu-id="54ddb-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="54ddb-131">A jeśli metoda jest powiązana we/wy, powinna być udostępniona tylko jako implementacja asynchroniczna.</span><span class="sxs-lookup"><span data-stu-id="54ddb-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="54ddb-132">Zadania związane z obliczeniami</span><span class="sxs-lookup"><span data-stu-id="54ddb-132">Compute-bound tasks</span></span>
<span data-ttu-id="54ddb-133"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType>Klasa doskonale nadaje się do reprezentowania operacji intensywnie korzystających z obliczeń.</span><span class="sxs-lookup"><span data-stu-id="54ddb-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="54ddb-134">Domyślnie wykorzystuje ona specjalną pomoc techniczną w ramach <xref:System.Threading.ThreadPool> klasy w celu zapewnienia wydajnego wykonania i zapewnia znaczącą kontrolę nad tym, gdzie i jak są wykonywane asynchroniczne obliczenia.</span><span class="sxs-lookup"><span data-stu-id="54ddb-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="54ddb-135">Zadania związane z obliczeniami można generować w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="54ddb-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="54ddb-136">W .NET Framework 4,5 i nowszych wersjach (w tym .NET Core i .NET 5 +) Użyj metody statycznej <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> jako skrótu do <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="54ddb-136">In .NET Framework 4.5 and later versions (including .NET Core and .NET 5+), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="54ddb-137">Można użyć, <xref:System.Threading.Tasks.Task.Run%2A> Aby łatwo uruchomić zadanie powiązane z obliczeniami, które jest przeznaczone dla puli wątków.</span><span class="sxs-lookup"><span data-stu-id="54ddb-137">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="54ddb-138">Jest to preferowany mechanizm uruchamiania zadania związanego z obliczaniem.</span><span class="sxs-lookup"><span data-stu-id="54ddb-138">This is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="54ddb-139">Używaj `StartNew` bezpośrednio tylko wtedy, gdy potrzebujesz bardziej precyzyjnej kontroli nad zadaniem.</span><span class="sxs-lookup"><span data-stu-id="54ddb-139">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="54ddb-140">W .NET Framework 4 Użyj <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody, która akceptuje obiekt delegowany (zwykle <xref:System.Action%601> lub a), który <xref:System.Func%601> ma być wykonywany asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="54ddb-140">In .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="54ddb-141">W przypadku podania <xref:System.Action%601> delegata Metoda zwraca <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> obiekt, który reprezentuje asynchroniczne wykonywanie tego delegata.</span><span class="sxs-lookup"><span data-stu-id="54ddb-141">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="54ddb-142">W przypadku podania <xref:System.Func%601> delegata Metoda zwraca <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> obiekt.</span><span class="sxs-lookup"><span data-stu-id="54ddb-142">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="54ddb-143">Przeciążenia <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metody akceptują token anulowania ( <xref:System.Threading.CancellationToken> ), opcje tworzenia zadań ( <xref:System.Threading.Tasks.TaskCreationOptions> ) i harmonogram zadań ( <xref:System.Threading.Tasks.TaskScheduler> ), które zapewniają szczegółową kontrolę nad planowaniem i wykonywaniem zadania.</span><span class="sxs-lookup"><span data-stu-id="54ddb-143">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="54ddb-144">Wystąpienie fabryki, które jest celem bieżącego harmonogramu zadań, jest dostępne jako właściwość statyczna ( <xref:System.Threading.Tasks.Task.Factory%2A> ) <xref:System.Threading.Tasks.Task> klasy; na przykład: `Task.Factory.StartNew(…)` .</span><span class="sxs-lookup"><span data-stu-id="54ddb-144">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="54ddb-145">Użyj konstruktorów `Task` typu lub `Start` metody, jeśli chcesz generować i planować zadanie osobno.</span><span class="sxs-lookup"><span data-stu-id="54ddb-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="54ddb-146">Metody publiczne muszą zwracać tylko zadania, które zostały już uruchomione.</span><span class="sxs-lookup"><span data-stu-id="54ddb-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="54ddb-147">Użyj przeciążenia <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="54ddb-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="54ddb-148">Ta metoda tworzy nowe zadanie zaplanowane po zakończeniu innego zadania.</span><span class="sxs-lookup"><span data-stu-id="54ddb-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="54ddb-149">Niektóre <xref:System.Threading.Tasks.Task.ContinueWith%2A> przeciążenia akceptują token anulowania, opcje kontynuacji i harmonogram zadań, aby zapewnić lepszą kontrolę nad planowaniem i wykonywaniem zadania kontynuacji.</span><span class="sxs-lookup"><span data-stu-id="54ddb-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="54ddb-150">Użyj <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> metod i <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="54ddb-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="54ddb-151">Te metody tworzą nowe zadanie zaplanowane po zakończeniu wszystkich lub dowolnego dostarczonego zestawu zadań.</span><span class="sxs-lookup"><span data-stu-id="54ddb-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="54ddb-152">Te metody zapewniają również przeciążenia umożliwiające sterowanie planowaniem i wykonywaniem tych zadań.</span><span class="sxs-lookup"><span data-stu-id="54ddb-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="54ddb-153">W zadaniach związanych z obliczaniem, system może uniemożliwić wykonanie zaplanowanego zadania, Jeśli odbierze żądanie anulowania przed uruchomieniem zadania.</span><span class="sxs-lookup"><span data-stu-id="54ddb-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="54ddb-154">W związku z tym, jeśli podajesz token anulowania ( <xref:System.Threading.CancellationToken> Object), możesz przekazać ten token do kodu asynchronicznego, który monitoruje token.</span><span class="sxs-lookup"><span data-stu-id="54ddb-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="54ddb-155">Możesz również podać token dla jednej z wymienionych wcześniej metod, takich jak lub, `StartNew` Aby `Run` `Task` środowisko uruchomieniowe mogło również monitorować token.</span><span class="sxs-lookup"><span data-stu-id="54ddb-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="54ddb-156">Rozważmy na przykład metodę asynchroniczną, która renderuje obraz.</span><span class="sxs-lookup"><span data-stu-id="54ddb-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="54ddb-157">Treść zadania może sondować token anulowania, dzięki czemu kod może zakończyć się wczesne w przypadku odebrania żądania anulowania podczas renderowania.</span><span class="sxs-lookup"><span data-stu-id="54ddb-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="54ddb-158">Ponadto, jeśli żądanie anulowania dociera przed rozpoczęciem renderowania, należy zapobiec operacji renderowania:</span><span class="sxs-lookup"><span data-stu-id="54ddb-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="54ddb-159">Zadania powiązane z obliczeniami kończą się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanie, jeśli co najmniej jeden z następujących warunków jest spełniony:</span><span class="sxs-lookup"><span data-stu-id="54ddb-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="54ddb-160">Żądanie anulowania dociera do <xref:System.Threading.CancellationToken> obiektu, który jest dostarczany jako argument metody tworzenia (na przykład `StartNew` lub `Run` ) przed przejściem do <xref:System.Threading.Tasks.TaskStatus.Running> stanu zadania.</span><span class="sxs-lookup"><span data-stu-id="54ddb-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="54ddb-161"><xref:System.OperationCanceledException>Wyjątek nie jest obsługiwany w treści tego zadania, ten wyjątek zawiera te same dane, <xref:System.Threading.CancellationToken> które są przesyłane do zadania, a ten token pokazuje, że żądanie anulowania jest wymagane.</span><span class="sxs-lookup"><span data-stu-id="54ddb-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="54ddb-162">Jeśli inny wyjątek nie jest obsługiwany w treści zadania, zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanie, a wszystkie próby oczekiwania na zadanie lub uzyskania dostępu do wyniku spowodują wystąpienie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="54ddb-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="54ddb-163">Operacje we/wy — powiązane zadania</span><span class="sxs-lookup"><span data-stu-id="54ddb-163">I/O-bound tasks</span></span>
<span data-ttu-id="54ddb-164">Aby utworzyć zadanie, które nie powinno być bezpośrednio wykonywane przez wątek dla całości jego wykonywania, użyj <xref:System.Threading.Tasks.TaskCompletionSource%601> typu.</span><span class="sxs-lookup"><span data-stu-id="54ddb-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="54ddb-165">Ten typ uwidacznia <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> Właściwość, która zwraca skojarzone <xref:System.Threading.Tasks.Task%601> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="54ddb-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="54ddb-166">Cykl życia tego zadania jest kontrolowany przy użyciu <xref:System.Threading.Tasks.TaskCompletionSource%601> metod takich jak <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A> ,, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> i ich `TrySet` wariantów.</span><span class="sxs-lookup"><span data-stu-id="54ddb-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="54ddb-167">Załóżmy, że chcesz utworzyć zadanie, które zostanie ukończone po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="54ddb-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="54ddb-168">Na przykład możesz chcieć opóźnić działanie w interfejsie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="54ddb-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="54ddb-169"><xref:System.Threading.Timer?displayProperty=nameWithType>Klasa umożliwia już Asynchroniczne wywoływanie delegata po określonym czasie, a przy użyciu <xref:System.Threading.Tasks.TaskCompletionSource%601> można umieścić <xref:System.Threading.Tasks.Task%601> na nim przód, na przykład:</span><span class="sxs-lookup"><span data-stu-id="54ddb-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="54ddb-170"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType>Ta metoda jest dostępna do tego celu i można jej użyć w innej metodzie asynchronicznej, na przykład w celu zaimplementowania asynchronicznej pętli sondowania:</span><span class="sxs-lookup"><span data-stu-id="54ddb-170">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="54ddb-171"><xref:System.Threading.Tasks.TaskCompletionSource%601>Klasa nie ma nieogólnego odpowiednika.</span><span class="sxs-lookup"><span data-stu-id="54ddb-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="54ddb-172">Jednak <xref:System.Threading.Tasks.Task%601> pochodzi z <xref:System.Threading.Tasks.Task> , więc można użyć obiektu generycznego <xref:System.Threading.Tasks.TaskCompletionSource%601> dla metod powiązanych we/wy, które po prostu zwracają zadanie.</span><span class="sxs-lookup"><span data-stu-id="54ddb-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="54ddb-173">W tym celu można użyć źródła z manekinem `TResult` ( <xref:System.Boolean> jest to dobry wybór domyślny, ale jeśli użytkownik ma informacje o użytkowniku <xref:System.Threading.Tasks.Task> rzutowanie go do <xref:System.Threading.Tasks.Task%601> , `TResult` zamiast tego można użyć typu prywatnego).</span><span class="sxs-lookup"><span data-stu-id="54ddb-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="54ddb-174">Na przykład `Delay` Metoda w poprzednim przykładzie zwraca bieżący czas wraz z wynikowym przesunięciem ( `Task<DateTimeOffset>` ).</span><span class="sxs-lookup"><span data-stu-id="54ddb-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="54ddb-175">Jeśli taka wartość wynikowa jest niezbędna, Metoda może być zakodowana w następujący sposób (należy zwrócić uwagę na zmianę typu zwracanego i zmianę argumentu na <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A> ):</span><span class="sxs-lookup"><span data-stu-id="54ddb-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="54ddb-176">Mieszane zadania powiązane z obliczeniami i operacje we/wy</span><span class="sxs-lookup"><span data-stu-id="54ddb-176">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="54ddb-177">Metody asynchroniczne nie są ograniczone do operacji tylko powiązanych z obliczeniami lub we/wy, ale mogą reprezentować kombinację dwóch.</span><span class="sxs-lookup"><span data-stu-id="54ddb-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="54ddb-178">W rzeczywistości wiele operacji asynchronicznych często są łączone w większe operacje mieszane.</span><span class="sxs-lookup"><span data-stu-id="54ddb-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="54ddb-179">Na przykład `RenderAsync` Metoda w poprzednim przykładzie wykonała operację obliczeniową intensywnie, aby renderować obraz na podstawie niektórych danych wejściowych `imageData` .</span><span class="sxs-lookup"><span data-stu-id="54ddb-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="54ddb-180">`imageData`Może to być z usługi sieci Web, do której masz dostęp asynchroniczny:</span><span class="sxs-lookup"><span data-stu-id="54ddb-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="54ddb-181">W tym przykładzie pokazano również, jak pojedynczy token anulowania może być wielowątkowy przez wiele operacji asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="54ddb-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="54ddb-182">Aby uzyskać więcej informacji, zobacz sekcję użycie anulowania w temacie [Używanie wzorca asynchronicznego opartego na zadaniach](consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="54ddb-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="54ddb-183">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="54ddb-183">See also</span></span>

- [<span data-ttu-id="54ddb-184">Wzorzec asynchroniczny oparty na zadaniach (TAP)</span><span class="sxs-lookup"><span data-stu-id="54ddb-184">Task-based Asynchronous Pattern (TAP)</span></span>](task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="54ddb-185">Wykorzystywanie wzorca asynchronicznego opartego na zadaniach</span><span class="sxs-lookup"><span data-stu-id="54ddb-185">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="54ddb-186">Współdziałanie z innymi wzorcami asynchronicznymi i typami</span><span class="sxs-lookup"><span data-stu-id="54ddb-186">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)
