---
title: Strategie dotyczące obsługi częściowych niepowodzeń
description: Ustal, jakimi kilka strategii obsługi częściowych niepowodzeń bezpiecznie.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/16/2018
ms.openlocfilehash: 63c6764d18ee0a8990cf669a8cdc824dea79aac8
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "62020177"
---
# <a name="strategies-to-handle-partial-failure"></a><span data-ttu-id="648a9-103">Strategie do obsługi częściowych niepowodzeń</span><span class="sxs-lookup"><span data-stu-id="648a9-103">Strategies to handle partial failure</span></span>

<span data-ttu-id="648a9-104">Strategie dotyczące postępowania z błędami częściowe są następujące.</span><span class="sxs-lookup"><span data-stu-id="648a9-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="648a9-105">**Użyj asynchronicznej komunikacji (na przykład, oparta na komunikatach) na wewnętrznej mikrousług**.</span><span class="sxs-lookup"><span data-stu-id="648a9-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="648a9-106">Zaleca się wysoce nie utworzyć długie łańcuchy synchroniczne wywołania HTTP między wewnętrznego mikrousług, ponieważ niepoprawne projektu staną się ostatecznie główną przyczynę awarii zła.</span><span class="sxs-lookup"><span data-stu-id="648a9-106">It's highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="648a9-107">Przeciwnie, z wyjątkiem frontonu komunikację między aplikacjami klienta i pierwszy poziom mikrousług lub szczegółowe bramy interfejsu API, zaleca się komunikacji przy użyciu tylko asynchroniczne (oparta na komunikatach) jeden raz w przeszłości początkowego żądania / Cykl odpowiedzi na wewnętrzny mikrousług.</span><span class="sxs-lookup"><span data-stu-id="648a9-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it's recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="648a9-108">Aby zminimalizować wpływ ripple pomoże oparte na zdarzeniach architektury i spójności ostatecznej.</span><span class="sxs-lookup"><span data-stu-id="648a9-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="648a9-109">Te metody wymuszania wyższego poziomu autonomii mikrousług i w związku z tym zapobiec problem oznaczane w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="648a9-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="648a9-110">**Użyj ponownych prób z wykorzystaniem wykładniczego wycofywania**.</span><span class="sxs-lookup"><span data-stu-id="648a9-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="648a9-111">Ta technika pozwala uniknąć krótki i sporadycznych błędów, wykonując wywołanie ponawia próbę kilka razy, w przypadku, gdy usługa nie jest dostępna tylko przez krótki czas.</span><span class="sxs-lookup"><span data-stu-id="648a9-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="648a9-112">Taka sytuacja może wystąpić z powodu problemów z sieciowych okresowymi lub mikrousług/kontenera zostanie przeniesiony do innego węzła w klastrze.</span><span class="sxs-lookup"><span data-stu-id="648a9-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="648a9-113">Jednak jeśli te ponownych prób nie są zaprojektowane prawidłowo w przypadku wyłączników, jego pogłębić skutki ripple ostatecznie nawet powodujące [przeprowadzenie ataku typu "odmowa usługi" (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="648a9-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="648a9-114">**Obejście sieci przekroczeń limitu czasu**.</span><span class="sxs-lookup"><span data-stu-id="648a9-114">**Work around network timeouts**.</span></span> <span data-ttu-id="648a9-115">Ogólnie rzecz biorąc klientów powinny zaprojektowana, aby nie blokować w sposób ciągły i zawsze używaj przekroczeń limitu czasu podczas oczekiwania na odpowiedź.</span><span class="sxs-lookup"><span data-stu-id="648a9-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="648a9-116">Korzystanie z limitów czasu zapewnia, że zasoby są nigdy nie blokowana przez czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="648a9-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="648a9-117">**Użyj wzorca wyłącznika**.</span><span class="sxs-lookup"><span data-stu-id="648a9-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="648a9-118">W tym podejściu procesu klienta śledzi liczbę żądań zakończonych niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="648a9-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="648a9-119">Jeśli tak, aby dalszych prób od razu zakończyć się niepowodzeniem, współczynnik błędów przekracza skonfigurowany limit wycieczek "wyłącznik".</span><span class="sxs-lookup"><span data-stu-id="648a9-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="648a9-120">(Jeśli dużą liczbę żądań kończą się niepowodzeniem, umożliwiającej wyświetlanie sugerowanych usługa jest niedostępna i że wysyłania żądań jest sensu.) Po upływie limitu czasu klient powinien ponownie i, jeśli nowe żądania się pomyślnie, zamykając wyłącznik.</span><span class="sxs-lookup"><span data-stu-id="648a9-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="648a9-121">**Podaj planów awaryjnych**.</span><span class="sxs-lookup"><span data-stu-id="648a9-121">**Provide fallbacks**.</span></span> <span data-ttu-id="648a9-122">W tym podejściu procesu klienta sprawdza logiki rezerwowej, gdy żądanie zakończy się niepowodzeniem, takie jak przekazywania danych z pamięci podręcznej lub wartość domyślną.</span><span class="sxs-lookup"><span data-stu-id="648a9-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="648a9-123">To podejście jest odpowiednie dla zapytań i jest bardziej złożona dla aktualizacji lub poleceń.</span><span class="sxs-lookup"><span data-stu-id="648a9-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="648a9-124">**Ogranicz liczbę żądań w kolejce**.</span><span class="sxs-lookup"><span data-stu-id="648a9-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="648a9-125">Klienci także powinny nakładać górnej granicy liczby oczekujących żądań, które mikrousług klienta mogą wysyłać do określonej usługi.</span><span class="sxs-lookup"><span data-stu-id="648a9-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="648a9-126">Jeśli zostanie osiągnięty limit jest prawdopodobnie sensu dodatkowych żądań i tych prób powinna zakończyć się niepowodzeniem natychmiast.</span><span class="sxs-lookup"><span data-stu-id="648a9-126">If the limit has been reached, it's probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="648a9-127">Pod względem implementacji Polly [izolacji grodziowym](https://github.com/App-vNext/Polly/wiki/Bulkhead) zasady mogą służyć do spełnienia tego wymagania.</span><span class="sxs-lookup"><span data-stu-id="648a9-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="648a9-128">To podejście jest zasadniczo ograniczania przetwarzania równoległego przy użyciu <xref:System.Threading.SemaphoreSlim> jako implementacja.</span><span class="sxs-lookup"><span data-stu-id="648a9-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="648a9-129">Umożliwia on również poza grodzi "kolejki".</span><span class="sxs-lookup"><span data-stu-id="648a9-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="648a9-130">Możesz proaktywnie zmniejszenia nadmiernego obciążenia, nawet przed wykonaniem, (na przykład, ponieważ za pojemność jest pełna).</span><span class="sxs-lookup"><span data-stu-id="648a9-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="648a9-131">Dzięki temu swojej odpowiedzi do pewnych scenariuszy awarii szybciej, niż byłoby wyłącznika, ponieważ wyłącznik czeka, aż po awarii.</span><span class="sxs-lookup"><span data-stu-id="648a9-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="648a9-132">Obiekt BulkheadPolicy [Polly](http://www.thepollyproject.org/) są ujawnia jak Pełna grodziowym i kolejki, a oferty zdarzenia przy przepełnieniu tak może także służyć do kierowania, automatyczne skalowanie w poziomie.</span><span class="sxs-lookup"><span data-stu-id="648a9-132">The BulkheadPolicy object in [Polly](http://www.thepollyproject.org/) exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="648a9-133">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="648a9-133">Additional resources</span></span>

- <span data-ttu-id="648a9-134">**Wzorce odporności**\\</span><span class="sxs-lookup"><span data-stu-id="648a9-134">**Resiliency patterns**\\</span></span>
  [https://docs.microsoft.com/azure/architecture/patterns/category/resiliency](/azure/architecture/patterns/category/resiliency)

- <span data-ttu-id="648a9-135">**Dodawanie odporności i optymalizacji wydajności**\\</span><span class="sxs-lookup"><span data-stu-id="648a9-135">**Adding Resilience and Optimizing Performance**\\</span></span>
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591574(v=pandp.10)>

- <span data-ttu-id="648a9-136">**Bulkhead.**</span><span class="sxs-lookup"><span data-stu-id="648a9-136">**Bulkhead.**</span></span> <span data-ttu-id="648a9-137">Repozytorium GitHub.</span><span class="sxs-lookup"><span data-stu-id="648a9-137">GitHub repo.</span></span> <span data-ttu-id="648a9-138">Implementacja za pomocą zasad Polly. \\</span><span class="sxs-lookup"><span data-stu-id="648a9-138">Implementation with Polly policy.\\</span></span>
  <https://github.com/App-vNext/Polly/wiki/Bulkhead>

- <span data-ttu-id="648a9-139">**Projektowanie aplikacji odpornych na błędy dla platformy Azure**\\</span><span class="sxs-lookup"><span data-stu-id="648a9-139">**Designing resilient applications for Azure**\\</span></span>
  [https://docs.microsoft.com/azure/architecture/resiliency/](/azure/architecture/resiliency/)

- <span data-ttu-id="648a9-140">**Obsługa błędu przejściowego**\\</span><span class="sxs-lookup"><span data-stu-id="648a9-140">**Transient fault handling**\\</span></span>
  [https://docs.microsoft.com/azure/architecture/best-practices/transient-faults](/azure/architecture/best-practices/transient-faults)

>[!div class="step-by-step"]
><span data-ttu-id="648a9-141">[Poprzednie](handle-partial-failure.md)
>[dalej](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="648a9-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
