---
title: Strategie dotyczące postępowania z częściowa awarii
description: Architektura Mikrousług .NET dla aplikacji .NET konteneryzowanych | Strategie dotyczące postępowania z częściowa awarii
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: c36ea31ad19b02fb02bc8e7185bfe8687b87764f
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/29/2018
ms.locfileid: "37104212"
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="0ea46-103">Strategie dotyczące postępowania z częściowa awarii</span><span class="sxs-lookup"><span data-stu-id="0ea46-103">Strategies for handling partial failure</span></span>

<span data-ttu-id="0ea46-104">Strategie dotyczące postępowania z błędami częściowe są następujące.</span><span class="sxs-lookup"><span data-stu-id="0ea46-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="0ea46-105">**Użyj asynchroniczne komunikacji (na przykład oparta na komunikatach) na wewnętrznej mikrousług**.</span><span class="sxs-lookup"><span data-stu-id="0ea46-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="0ea46-106">Stanowczo zaleca nie, aby utworzyć długie łańcuchy synchroniczne wywołania HTTP w wewnętrznych mikrousług, ponieważ tego projektu niepoprawne będzie przestać główną przyczynę awarii zła.</span><span class="sxs-lookup"><span data-stu-id="0ea46-106">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="0ea46-107">Przeciwnie, z wyjątkiem frontonu komunikacji między aplikacjami klienta i pierwszy poziom mikrousług lub szczegółowych bramy interfejsu API, zaleca się do użycia tylko (oparta na komunikatach) komunikacji asynchronicznej raz osiągnęła początkowej żądania / Cykl odpowiedzi przez wewnętrzny mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0ea46-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="0ea46-108">Spójność ostateczna i architektur sterowane zdarzeniami pomogą zminimalizować wpływ ripple.</span><span class="sxs-lookup"><span data-stu-id="0ea46-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="0ea46-109">Tych metod wymuszania wyższego poziomu Autonomia mikrousługi i w związku z tym zapobiegać problem oznaczane w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="0ea46-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="0ea46-110">**Ponowne próby za pomocą wykładniczego wycofywania**.</span><span class="sxs-lookup"><span data-stu-id="0ea46-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="0ea46-111">Ta technika pozwala uniknąć krótki i błędami okresowymi, wykonując wywołanie ponowi próbę kilka razy, w przypadku, gdy usługa nie jest dostępna tylko w przypadku przez krótki czas.</span><span class="sxs-lookup"><span data-stu-id="0ea46-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="0ea46-112">Może to być spowodowane problemami z siecią tymczasowymi lub mikrousługi/kontenera jest przenoszona do innego węzła w klastrze.</span><span class="sxs-lookup"><span data-stu-id="0ea46-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="0ea46-113">Jednak jeśli te ponownych prób nie są prawidłowo zaprojektowane z obwodem podziałów, jego pogłębić efekty ripple ostatecznie nawet powodując [przeprowadzenie ataku typu "odmowa usługi" (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="0ea46-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="0ea46-114">**Obejść limity czasu sieci**.</span><span class="sxs-lookup"><span data-stu-id="0ea46-114">**Work around network timeouts**.</span></span> <span data-ttu-id="0ea46-115">Ogólnie rzecz biorąc klientów należy tak zaprojektować nie blokuj nieograniczony czas i zawsze używaj przekroczeń limitu czasu podczas oczekiwania na odpowiedź.</span><span class="sxs-lookup"><span data-stu-id="0ea46-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="0ea46-116">Korzystanie z limitów czasu zapewnia, że zasoby są nigdy nie blokowana przez nieograniczony czas.</span><span class="sxs-lookup"><span data-stu-id="0ea46-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="0ea46-117">**Użyj wzorca wyłącznika**.</span><span class="sxs-lookup"><span data-stu-id="0ea46-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="0ea46-118">W tym podejście procesu klienta śledzi liczbę niepomyślnych żądań.</span><span class="sxs-lookup"><span data-stu-id="0ea46-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="0ea46-119">Jeśli częstotliwość błędów przekracza skonfigurowany limit, rund "wyłącznika", aby dalszych prób natychmiast się nie powieść.</span><span class="sxs-lookup"><span data-stu-id="0ea46-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="0ea46-120">(Jeśli duża liczba żądań, które kończą się niepowodzeniem, które sugeruje usługa jest niedostępna i że wysyłania żądań jest bezcelowe.) Po upływie limitu czasu klienta należy ponownie i, jeśli nowych żądań nie powiodło się, zamknij wyłącznik.</span><span class="sxs-lookup"><span data-stu-id="0ea46-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="0ea46-121">**Podaj przejścia**.</span><span class="sxs-lookup"><span data-stu-id="0ea46-121">**Provide fallbacks**.</span></span> <span data-ttu-id="0ea46-122">W takie podejście proces klienta sprawdza logiki rezerwowej, gdy żądanie zakończy się niepowodzeniem, takich jak przekazywania danych z pamięci podręcznej lub wartość domyślną.</span><span class="sxs-lookup"><span data-stu-id="0ea46-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="0ea46-123">Jest to podejście, które są odpowiednie dla zapytań i jest bardziej złożony dla aktualizacji lub poleceń.</span><span class="sxs-lookup"><span data-stu-id="0ea46-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="0ea46-124">**Ogranicz liczbę żądań w kolejce**.</span><span class="sxs-lookup"><span data-stu-id="0ea46-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="0ea46-125">Klienci także powinna nałożyć górnej granicy liczby oczekujących żądań, które mikrousługi klienta mogą wysyłać do określonej usługi.</span><span class="sxs-lookup"><span data-stu-id="0ea46-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="0ea46-126">Jeśli został osiągnięty limit, jest prawdopodobnie bezcelowe dokonanie dodatkowych żądań i tymi próbami powinna zakończyć się niepowodzeniem natychmiast.</span><span class="sxs-lookup"><span data-stu-id="0ea46-126">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="0ea46-127">W implementacji, Polly [izolacji grodziowego](https://github.com/App-vNext/Polly/wiki/Bulkhead) zasad może służyć do spełnienia tego wymagania.</span><span class="sxs-lookup"><span data-stu-id="0ea46-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="0ea46-128">Ta metoda jest zasadniczo ograniczania paralelizacja z <xref:System.Threading.SemaphoreSlim> jako implementacja.</span><span class="sxs-lookup"><span data-stu-id="0ea46-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="0ea46-129">Umożliwia on również "kolejki" poza grodzi.</span><span class="sxs-lookup"><span data-stu-id="0ea46-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="0ea46-130">Nadmiarowe obciążenia nawet przed wykonaniem można pozostawia aktywnego, (na przykład, ponieważ za pojemność jest pełna).</span><span class="sxs-lookup"><span data-stu-id="0ea46-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="0ea46-131">Dzięki temu można szybciej niż wyłącznika, ponieważ oczekuje wyłącznik niepowodzeń swojej odpowiedzi do pewnych scenariuszy awarii.</span><span class="sxs-lookup"><span data-stu-id="0ea46-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="0ea46-132">Obiekt BulkheadPolicy w Polly udostępnia jak Pełna grodziowego są kolejki i zdarzenia oferty na przepełnienie tak mogą służyć do kierowania automatyczne skalowanie w poziomie.</span><span class="sxs-lookup"><span data-stu-id="0ea46-132">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="0ea46-133">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="0ea46-133">Additional resources</span></span>

-   <span data-ttu-id="0ea46-134">**Wzorce odporności**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="0ea46-134">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="0ea46-135">**Dodawanie odporności i optymalizacji wydajności**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="0ea46-135">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="0ea46-136">**Bulkhead.**</span><span class="sxs-lookup"><span data-stu-id="0ea46-136">**Bulkhead.**</span></span> <span data-ttu-id="0ea46-137">Repozytorium GitHub.</span><span class="sxs-lookup"><span data-stu-id="0ea46-137">GitHub repo.</span></span> <span data-ttu-id="0ea46-138">Wdrożenia z zasadami Polly. \\</span><span class="sxs-lookup"><span data-stu-id="0ea46-138">Implementation with Polly policy.\\</span></span>
    [*https://github.com/App-vNext/Polly/wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="0ea46-139">**Projektowanie aplikacji odporne na platformie Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="0ea46-139">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="0ea46-140">**Obsługa błędu przejściowego**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="0ea46-140">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="0ea46-141">[Poprzednie](handle-partial-failure.md)
[dalej](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="0ea46-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
