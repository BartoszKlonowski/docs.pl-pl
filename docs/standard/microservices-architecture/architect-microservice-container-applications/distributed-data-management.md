---
title: Problemy i rozwiązania dotyczące rozproszonego zarządzania danymi
description: Dowiedz się, jakie są problemy i rozwiązania dotyczące rozproszonego zarządzania danymi w świecie mikrousług.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/20/2018
ms.openlocfilehash: 3e683044ea6a31116f1e7da6d690fc32ad87bd76
ms.sourcegitcommit: 438919211260bb415fc8f96ca3eabc33cf2d681d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/16/2019
ms.locfileid: "59613708"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="dc57a-103">Problemy i rozwiązania dotyczące rozproszonego zarządzania danymi</span><span class="sxs-lookup"><span data-stu-id="dc57a-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="dc57a-104">Wyzwanie \#1: Jak zdefiniować granice poszczególne mikrousługi</span><span class="sxs-lookup"><span data-stu-id="dc57a-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="dc57a-105">Definiowanie granic mikrousługi prawdopodobnie jest pierwsze wyzwanie, z których każda osoba napotka.</span><span class="sxs-lookup"><span data-stu-id="dc57a-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="dc57a-106">Każda mikrousługa musi być częścią aplikacji, a każda mikrousługa powinna być autonomicznego przy użyciu wszystkich korzyści i problemy, które wywołuje.</span><span class="sxs-lookup"><span data-stu-id="dc57a-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="dc57a-107">Ale jak można zidentyfikować te granice?</span><span class="sxs-lookup"><span data-stu-id="dc57a-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="dc57a-108">Najpierw należy skoncentrować się na modeli domeny logiczne i powiązane dane aplikacji.</span><span class="sxs-lookup"><span data-stu-id="dc57a-108">First, you need to focus on the application's logical domain models and related data.</span></span> <span data-ttu-id="dc57a-109">Spróbuj zidentyfikować Wyspy rozdzieleniu danych i kontekstów w tej samej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="dc57a-109">Try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="dc57a-110">W każdym kontekście może mieć różnych firm język (warunki różnych firm).</span><span class="sxs-lookup"><span data-stu-id="dc57a-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="dc57a-111">Konteksty powinien być zdefiniowane i zarządzane niezależnie.</span><span class="sxs-lookup"><span data-stu-id="dc57a-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="dc57a-112">Warunki i jednostek, które są używane w tych różnych kontekstach może brzmią podobnie, ale może być odnajdywanie, że w szczególnym kontekście koncepcji biznesowych z jedną służy do różnych celów w innym kontekście, a nawet może mieć inną nazwę.</span><span class="sxs-lookup"><span data-stu-id="dc57a-112">The terms and entities that are used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="dc57a-113">Na przykład przez użytkownika mogą być określane jako użytkownika w tożsamości lub członkostwo w kontekście jako klient w kontekście CRM kupującym w kontekście sortowania i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="dc57a-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="dc57a-114">Sposób identyfikacji granic między wiele kontekstów aplikacji z innej domeny, dla każdego kontekstu jest dokładnie, jak można zidentyfikować granice poszczególne mikrousługi firmy i jej powiązane danych i modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="dc57a-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="dc57a-115">Zawsze próbować zminimalizować sprzężenie między tymi mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="dc57a-116">Ten przewodnik zawiera bardziej szczegółowe o ten projekt modelu identyfikacji i domeny w sekcji [identyfikowanie ograniczeń modelu domeny dla poszczególnych mikrousług](identify-microservice-domain-model-boundaries.md) później.</span><span class="sxs-lookup"><span data-stu-id="dc57a-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="dc57a-117">Wyzwanie \#2: Jak tworzyć zapytania, które pobierają dane z wielu mikrousług</span><span class="sxs-lookup"><span data-stu-id="dc57a-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="dc57a-118">Drugi wyzwaniem jest sposób implementacji zapytań, które pobierają dane z wielu mikrousług, unikając do mikrousług nasilenie komunikacji z klientem zdalnym aplikacji.</span><span class="sxs-lookup"><span data-stu-id="dc57a-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="dc57a-119">Przykładem może być jednego ekranu z aplikacji mobilnej, który wymaga, aby wyświetlić informacje o użytkowniku, który jest własnością mikrousług tożsamości koszyka, wykazu i użytkownika.</span><span class="sxs-lookup"><span data-stu-id="dc57a-119">An example could be a single screen from a mobile app that needs to show user information that's owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="dc57a-120">Innym przykładem może być złożonych raportów, obejmujących wiele tabel znajdujących się w wielu mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="dc57a-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="dc57a-121">Rozwiązanie zaspokajające zależy od złożoności zapytania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="dc57a-122">Ale w każdym przypadku, będziesz potrzebować sposób agregują informacje, jeśli chcesz zwiększyć wydajność w komunikacji systemu.</span><span class="sxs-lookup"><span data-stu-id="dc57a-122">But in any case, you'll need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="dc57a-123">Najbardziej popularne rozwiązania są następujące.</span><span class="sxs-lookup"><span data-stu-id="dc57a-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="dc57a-124">**Brama interfejsu API.**</span><span class="sxs-lookup"><span data-stu-id="dc57a-124">**API Gateway.**</span></span> <span data-ttu-id="dc57a-125">Agregacji proste dane z wielu mikrousług, którego właścicielem różnych baz danych Zalecanym podejściem jest mikrousług agregacji, określany jako bramy interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="dc57a-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="dc57a-126">Jednak należy zachować ostrożność w przypadku implementowania tego wzorca, ponieważ może być punktem urządzenie rozruchowe w systemie, a jej naruszać zasady Autonomia mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="dc57a-127">Aby uniknąć tej możliwości, może mieć wiele bram API karę szczegółowej każdy jeden koncentrujące się na "wycinka" w pionie lub obszar działalności systemu.</span><span class="sxs-lookup"><span data-stu-id="dc57a-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical "slice" or business area of the system.</span></span> <span data-ttu-id="dc57a-128">Wzorzec bramy interfejsu API jest omówione bardziej szczegółowo w [sekcji bramy interfejsu API](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) później.</span><span class="sxs-lookup"><span data-stu-id="dc57a-128">The API Gateway pattern is explained in more detail in the [API Gateway section](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) later.</span></span>

<span data-ttu-id="dc57a-129">**Podejście CQRS z tabelami w operacji zapytania/odczytu.**</span><span class="sxs-lookup"><span data-stu-id="dc57a-129">**CQRS with query/reads tables.**</span></span> <span data-ttu-id="dc57a-130">Innym rozwiązaniem do agregowania danych z wielu mikrousług jest [użycia wzorca zmaterializowanego widoku](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="dc57a-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="dc57a-131">W tym podejściu użytkownik Generowanie z wyprzedzeniem (przygotować dane denormalizowane, przed wystąpieniem rzeczywiste zapytań), tylko do odczytu tabelę z danymi, która jest właścicielem przez wiele mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that's owned by multiple microservices.</span></span> <span data-ttu-id="dc57a-132">Tabela ma format, dostosowane do potrzeb aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="dc57a-132">The table has a format suited to the client app's needs.</span></span>

<span data-ttu-id="dc57a-133">Należy wziąć pod uwagę podobny ekran dla aplikacji mobilnej.</span><span class="sxs-lookup"><span data-stu-id="dc57a-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="dc57a-134">W przypadku pojedynczej bazy danych, użytkownik może zebrane dane dla tego ekranu przy użyciu zapytania SQL, który wykonuje złożone sprzężeniem obejmującym wiele tabel.</span><span class="sxs-lookup"><span data-stu-id="dc57a-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="dc57a-135">Jednak zawierać wiele baz danych, gdy każda baza danych jest własnością innego mikrousług, nie można zbadać tych baz danych i Utwórz sprzężenie SQL.</span><span class="sxs-lookup"><span data-stu-id="dc57a-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="dc57a-136">Zapytanie złożone staje się wyzwaniem.</span><span class="sxs-lookup"><span data-stu-id="dc57a-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="dc57a-137">Można rozwiązać wymagań przy użyciu podejścia CQRS — Utwórz tabelę nieznormalizowany w innej bazie danych, która jest używana tylko dla zapytania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that's used just for queries.</span></span> <span data-ttu-id="dc57a-138">Tabeli może być zaprojektowane specjalnie dla danych, czego potrzebujesz do złożonego zapytania, z relacją między polami wymagane przez ekran aplikacji i kolumn w tabeli zapytania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application's screen and the columns in the query table.</span></span> <span data-ttu-id="dc57a-139">Można go również służyć do celów raportowania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="dc57a-140">To podejście nie tylko rozwiązuje problem oryginalnego (jak wykonywać zapytania i sprzężenia między mikrousług), ale również poprawiasz jej wydajność znacznie w porównaniu ze sprzężeniem złożone, ponieważ masz już dane, które są wymagane przez aplikację w tabeli zapytania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-140">This approach not only solves the original problem (how to query and join across microservices), but it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="dc57a-141">Oczywiście używając polecenia i podział odpowiedzialności zapytania (CQRS) z tabelami w operacji zapytania/odczytu oznacza, że dodatkowe prace i konieczne będzie Uwzględniaj spójność ostateczną.</span><span class="sxs-lookup"><span data-stu-id="dc57a-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you'll need to embrace eventual consistency.</span></span> <span data-ttu-id="dc57a-142">Niemniej jednak wymagania dotyczące wydajności i wysokiej skalowalności w [scenariuszach współpracy](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (lub konkurencyjnych scenariuszy, w zależności od punktu widzenia) są, gdzie należy zastosować podejście CQRS z wieloma bazami danych.</span><span class="sxs-lookup"><span data-stu-id="dc57a-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) are where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="dc57a-143">**"Zimnych danych" centralnej bazy danych.**</span><span class="sxs-lookup"><span data-stu-id="dc57a-143">**"Cold data" in central databases.**</span></span> <span data-ttu-id="dc57a-144">Dla złożonych raportów i zapytań, które mogą nie wymagać danych w czasie rzeczywistym, typowym podejściem jest Eksportuj swoje oznaczenie "gorące dane" (dane transakcyjne z mikrousług) jako "zimnych danych" w dużych baz danych, które są używane tylko w przypadku raportowania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-144">For complex reports and queries that might not require real-time data, a common approach is to export your "hot data" (transactional data from the microservices) as "cold data" into large databases that are used only for reporting.</span></span> <span data-ttu-id="dc57a-145">Czy system centralnej bazy danych może być systemu opartego na danych Big Data, takich jak Hadoop, magazynu danych, takich jak oparty na usłudze Azure SQL Data Warehouse lub nawet pojedynczej bazy danych SQL używaną tylko w przypadku raportów (Jeśli rozmiar nie będzie problem).</span><span class="sxs-lookup"><span data-stu-id="dc57a-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database that's used just for reports (if size won't be an issue).</span></span>

<span data-ttu-id="dc57a-146">Należy pamiętać, że ta scentralizowanej bazie danych będzie używana tylko dla zapytań i raportów, które nie są w czasie rzeczywistym danych.</span><span class="sxs-lookup"><span data-stu-id="dc57a-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="dc57a-147">Oryginalny aktualizacje i transakcji jako źródło prawdziwych danych, muszą znajdować się w danych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="dc57a-148">Sposób będą synchronizować dane będą przy użyciu oparte na zdarzeniach komunikacji (co omówiono w kolejnych sekcjach) lub przy użyciu innych narzędzi importu/eksportu infrastruktury bazy danych.</span><span class="sxs-lookup"><span data-stu-id="dc57a-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="dc57a-149">Jeśli używasz komunikacji oparte na zdarzeniach, procesu integracji mogą być podobne do sposób propagowanie danych zgodnie z wcześniejszym opisem CQRS zapytania tabel.</span><span class="sxs-lookup"><span data-stu-id="dc57a-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="dc57a-150">Jednak jeśli projektu aplikacji obejmuje stale agregując informacje z wielu mikrousług w przypadku złożonych zapytań, może być objawem nieprawidłowy projekt - mikrousługi powinien być izolowana możliwie z innych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design -a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="dc57a-151">(Z wyłączeniem raporty/analizę, która zawsze należy używać bazy danych centralnej zimne dane.) Często wystąpienia tego problemu może być powód do scalenia mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="dc57a-152">Musisz równoważenie autonomii ewolucji i wdrożenia, poszczególne mikrousługi przy użyciu silnego zależności, spójności i agregacja danych.</span><span class="sxs-lookup"><span data-stu-id="dc57a-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="dc57a-153">Wyzwanie \#3: Jak ujednolicenia wyglądu wiele mikrousług</span><span class="sxs-lookup"><span data-stu-id="dc57a-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="dc57a-154">Jak wspomniano wcześniej, dane należące do poszczególnych mikrousług są prywatne tego mikrousług i może zostać oceniony jedynie przy użyciu jego mikrousług interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="dc57a-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="dc57a-155">Dlatego żądanie prezentowane jest sposób implementacji procesów biznesowych end-to-end przy jednoczesnym zachowaniu spójności w wielu mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="dc57a-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="dc57a-156">Aby analizować ten problem, Spójrzmy na przykład z [ramach aplikacji eShopOnContainers odwołania aplikacji](https://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="dc57a-156">To analyze this problem, let's look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="dc57a-157">Mikrousługi katalogu przechowuje informacje o wszystkich produktów, w tym cena produktu.</span><span class="sxs-lookup"><span data-stu-id="dc57a-157">The Catalog microservice maintains information about all the products, including the product price.</span></span> <span data-ttu-id="dc57a-158">Mikrousługi koszyka zarządza danych czasowych danych o elementach produktu, które Przystępując do dodawania użytkowników do ich koszyki zakupów, w tym ceny elementy w czasie, które zostały dodane do koszyka.</span><span class="sxs-lookup"><span data-stu-id="dc57a-158">The Basket microservice manages temporal data about product items that users are adding to their shopping baskets, which includes the price of the items at the time they were added to the basket.</span></span> <span data-ttu-id="dc57a-159">Po zaktualizowaniu cena produktu w katalogu można również zaktualizować cena, w aktywny koszyki, zawierających tego samego produktu, a także system prawdopodobnie należy ostrzec użytkowników, informujący o tym, że cena określonego elementu zmieniła się od ich dodania do koszyka.</span><span class="sxs-lookup"><span data-stu-id="dc57a-159">When a product's price is updated in the catalog, that price should also be updated in the active baskets that hold that same product, plus the system should probably warn the user saying that a particular item's price has changed since they added it to their basket.</span></span>

<span data-ttu-id="dc57a-160">Hipotetyczny monolityczne wersji tej aplikacji zmianie cen w tabeli Produkty w podsystemie katalogu można służy do aktualizowania bieżąca cena w tabeli koszyka po prostu transakcji ACID.</span><span class="sxs-lookup"><span data-stu-id="dc57a-160">In a hypothetical monolithic version of this application, when the price changes in the products table, the catalog subsystem could simply use an ACID transaction to update the current price in the Basket table.</span></span>

<span data-ttu-id="dc57a-161">Jednak w przypadku aplikacji opartych na mikrousługach tabel Product i koszyka są własnością ich odpowiednich mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-161">However, in a microservices-based application, the Product and Basket tables are owned by their respective microservices.</span></span> <span data-ttu-id="dc57a-162">Nie mikrousług nigdy nie powinna zawierać własnością innego mikrousług w jego własnej transakcji, nawet w przypadku zapytania bezpośredniego, tabele i magazynowania, jak pokazano w rysunek 4 – 9.</span><span class="sxs-lookup"><span data-stu-id="dc57a-162">No microservice should ever include tables/storage owned by another microservice in its own transactions, not even in direct queries, as shown in Figure 4-9.</span></span>

![Mikrousługi nie może uzyskać bezpośredni dostęp do tabeli w innym mikrousług, spójność ostateczną, muszą być używane do synchronizacji danych.](./media/image9.png)

<span data-ttu-id="dc57a-164">**Rysunek 4 – 9**.</span><span class="sxs-lookup"><span data-stu-id="dc57a-164">**Figure 4-9**.</span></span> <span data-ttu-id="dc57a-165">Mikrousługi nie może uzyskać bezpośredni dostęp do tabeli w innej mikrousług</span><span class="sxs-lookup"><span data-stu-id="dc57a-165">A microservice can't directly access a table in another microservice</span></span>

<span data-ttu-id="dc57a-166">Mikrousług katalogu nie należy bezpośrednio zaktualizować tabeli koszyka, ponieważ tabeli koszyka jest własnością mikrousług koszyka.</span><span class="sxs-lookup"><span data-stu-id="dc57a-166">The Catalog microservice shouldn't update the Basket table directly, because the Basket table is owned by the Basket microservice.</span></span> <span data-ttu-id="dc57a-167">Aby dokonać aktualizacji mikrousług koszyka, mikrousługi katalogu należy używać spójność ostateczną, prawdopodobnie oparte na komunikacji asynchronicznej, takich jak zdarzenia integracji (wiadomości i komunikacji oparte na zdarzeniu).</span><span class="sxs-lookup"><span data-stu-id="dc57a-167">To make an update to the Basket microservice, the Catalog microservice should use eventual consistency probably based on asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="dc57a-168">Jest to sposób, w jaki [ramach aplikacji eShopOnContainers](https://aka.ms/eshoponcontainers) odwołania aplikacja wykonuje ten typ spójności między mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-168">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of consistency across microservices.</span></span>

<span data-ttu-id="dc57a-169">Podane przez [kolejnego elementu teorii CAP](https://en.wikipedia.org/wiki/CAP_theorem), musisz wybrać między dostępnością i ACID silnej spójności.</span><span class="sxs-lookup"><span data-stu-id="dc57a-169">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="dc57a-170">Większość scenariuszy opartych na mikrousługach wymaga dostępności i wysokiej skalowalności w przeciwieństwie do silnej spójności.</span><span class="sxs-lookup"><span data-stu-id="dc57a-170">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="dc57a-171">Aplikacji o krytycznym znaczeniu musi znajdować się, a następnie uruchomiona i deweloperów można obejść wysoki poziom spójności przy użyciu technik do pracy z słabych lub ostateczną spójność.</span><span class="sxs-lookup"><span data-stu-id="dc57a-171">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="dc57a-172">To podejście stosowane przez większość opartych na mikrousługach architektury.</span><span class="sxs-lookup"><span data-stu-id="dc57a-172">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="dc57a-173">Ponadto ACID stylu lub dwufazowe zatwierdzanie transakcji nie są tylko względem zasad mikrousług. Większość baz danych NoSQL (np. usługi Azure Cosmos DB, bazy danych MongoDB itp.) nie obsługują transakcji dwufazowego, zwykle w scenariuszach rozproszonych baz danych.</span><span class="sxs-lookup"><span data-stu-id="dc57a-173">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions, typical in distributed databases scenarios.</span></span> <span data-ttu-id="dc57a-174">Obsługa danych spójności w różnych usługach i baz danych jest jednak niezbędne.</span><span class="sxs-lookup"><span data-stu-id="dc57a-174">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="dc57a-175">Temu wyzwaniu dotyczy również zapytania dotyczące propagujące zmiany w wielu mikrousług, gdy konieczne jest nadmiarowy niektórych danych — na przykład, gdy musisz mieć nazwę produktu lub opis w mikrousługach wykazu i koszyka mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="dc57a-175">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product's name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="dc57a-176">Dobrym rozwiązaniem tego problemu jest używać spójności ostatecznej między mikrousługami przegubowe za pośrednictwem komunikacji oparte na zdarzeniach i systemem publikowania i subskrybowania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-176">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="dc57a-177">Te tematy zostały omówione w sekcji [komunikacji asynchronicznej oparte na zdarzeniach](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) później w tym przewodniku.</span><span class="sxs-lookup"><span data-stu-id="dc57a-177">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="dc57a-178">Wyzwanie \#4: Jak projektować komunikacji między granicami mikrousług</span><span class="sxs-lookup"><span data-stu-id="dc57a-178">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="dc57a-179">Granice, komunikacji za pośrednictwem mikrousług jest rzeczywistym wyzwaniem.</span><span class="sxs-lookup"><span data-stu-id="dc57a-179">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="dc57a-180">W tym kontekście komunikacji nie odwołuje się do który protokół powinien używać (protokół HTTP i REST, AMQP, obsługi wiadomości i tak dalej).</span><span class="sxs-lookup"><span data-stu-id="dc57a-180">In this context, communication doesn't refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="dc57a-181">Zamiast tego usuwa styl komunikacji należy użyć, a zwłaszcza jak sprzężonych mikrousługi powinno być.</span><span class="sxs-lookup"><span data-stu-id="dc57a-181">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="dc57a-182">W zależności od poziomu sprzężenia gdy wystąpi błąd, wpływ tej awarii w systemie różni się znacznie.</span><span class="sxs-lookup"><span data-stu-id="dc57a-182">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="dc57a-183">W rozproszonym systemie, takie jak opartych na mikrousługach aplikacji z artefaktów tak wiele poruszanie się i usługi rozproszone między wiele serwerów lub hosty składniki po pewnym czasie nie powiedzie.</span><span class="sxs-lookup"><span data-stu-id="dc57a-183">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="dc57a-184">Częściowych niepowodzeń i jeszcze większym awarii nastąpi, więc należy projektować mikrousługi i komunikację między nimi analizie ryzyka wspólnej w rozproszonym systemie tego typu.</span><span class="sxs-lookup"><span data-stu-id="dc57a-184">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them considering the common risks in this type of distributed system.</span></span>

<span data-ttu-id="dc57a-185">Popularne podejście jest mikrousługi oparty na protokole REST protokołu HTTP, ze względu na ich prostotę.</span><span class="sxs-lookup"><span data-stu-id="dc57a-185">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="dc57a-186">Podejście oparte na protokole HTTP jest idealnie dopuszczalne; Ten problem, w tym miejscu dotyczą sposobu ich używania.</span><span class="sxs-lookup"><span data-stu-id="dc57a-186">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="dc57a-187">Jeśli używasz żądań i odpowiedzi HTTP, tylko w celu interakcji z mikrousługi z aplikacji klienckich lub bramy interfejsu API, który jest poprawne.</span><span class="sxs-lookup"><span data-stu-id="dc57a-187">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that's fine.</span></span> <span data-ttu-id="dc57a-188">Ale jeśli tworzysz długie łańcuchy synchroniczne wywołania HTTP na mikrousługach, komunikacji za pośrednictwem ich granice tak, jakby mikrousługi były obiektami w aplikacji monolitycznej aplikacji będzie po pewnym czasie.</span><span class="sxs-lookup"><span data-stu-id="dc57a-188">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="dc57a-189">Na przykład załóżmy, że Twoja aplikacja kliencka sprawia, że wywołania interfejsu API protokołu HTTP w taki sposób, aby jedna mikrousługa, takie jak mikrousługi porządkowanie.</span><span class="sxs-lookup"><span data-stu-id="dc57a-189">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="dc57a-190">Mikrousługi porządkowanie z kolei wywołuje dodatkowe cyklu mikrousług przy użyciu protokołu HTTP w ramach tego samego żądania/odpowiedzi, tworzysz łańcuch połączeń HTTP.</span><span class="sxs-lookup"><span data-stu-id="dc57a-190">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you're creating a chain of HTTP calls.</span></span> <span data-ttu-id="dc57a-191">Może być brzmi uzasadnione początkowo.</span><span class="sxs-lookup"><span data-stu-id="dc57a-191">It might sound reasonable initially.</span></span> <span data-ttu-id="dc57a-192">Jednakże istnieją ważne punkty, które należy wziąć pod uwagę w przypadku wyłączenia tej ścieżki:</span><span class="sxs-lookup"><span data-stu-id="dc57a-192">However, there are important points to consider when going down this path:</span></span>

- <span data-ttu-id="dc57a-193">Blokowanie i niskiej wydajności.</span><span class="sxs-lookup"><span data-stu-id="dc57a-193">Blocking and low performance.</span></span> <span data-ttu-id="dc57a-194">Ze względu na charakter synchroniczne HTTP oryginalne żądanie nie uzyska odpowiedzi zakończenie wszystkich wewnętrznych wywołań HTTP.</span><span class="sxs-lookup"><span data-stu-id="dc57a-194">Due to the synchronous nature of HTTP, the original request doesn't get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="dc57a-195">Wyobraź sobie, jeśli liczbę tych wywołań znacznie zwiększa i w tym samym czasie, wywoływanych jeden pośrednich HTTP mikrousługa jest zablokowany.</span><span class="sxs-lookup"><span data-stu-id="dc57a-195">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="dc57a-196">Wynik jest, że to wpływ na wydajność i skalowalność ogólną wykładniczo wpłynie na jako dodatkowe zwiększenie żądania HTTP.</span><span class="sxs-lookup"><span data-stu-id="dc57a-196">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

- <span data-ttu-id="dc57a-197">Sprzężenie mikrousług za pośrednictwem protokołu HTTP.</span><span class="sxs-lookup"><span data-stu-id="dc57a-197">Coupling microservices with HTTP.</span></span> <span data-ttu-id="dc57a-198">Mikrousług biznesowych nie powinny być połączone z mikrousług innych firm.</span><span class="sxs-lookup"><span data-stu-id="dc57a-198">Business microservices shouldn't be coupled with other business microservices.</span></span> <span data-ttu-id="dc57a-199">Najlepiej, jeśli ich nie powinny "know" o istnieniu innych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-199">Ideally, they shouldn't "know" about the existence of other microservices.</span></span> <span data-ttu-id="dc57a-200">Jeśli aplikacja zależy od tego, sprzężenia mikrousług, tak jak w przykładzie, osiągnięcia Autonomia poszczególnych mikrousług jest prawie niemożliwe.</span><span class="sxs-lookup"><span data-stu-id="dc57a-200">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

- <span data-ttu-id="dc57a-201">Błąd w dowolnej jeden mikrousług.</span><span class="sxs-lookup"><span data-stu-id="dc57a-201">Failure in any one microservice.</span></span> <span data-ttu-id="dc57a-202">Jeśli zaimplementowano łańcuch mikrousług połączone przez wywołania HTTP, w którym dowolnego mikrousługi nie powiedzie się (i ostatecznie zakończy się niepowodzeniem) całego łańcucha mikrousług zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="dc57a-202">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="dc57a-203">System opartych na mikrousługach, powinny zostać tak zaprojektowane, aby kontynuować pracę oraz możliwości częściowej awarii.</span><span class="sxs-lookup"><span data-stu-id="dc57a-203">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="dc57a-204">Nawet w przypadku zastosowania logiki klienta, która używa ponownych prób z wykorzystaniem wykładniczego wycofywania lub mechanizmy wyłącznika, więcej łańcuchy wywołania HTTP złożone są bardziej złożone, które można zaimplementować strategię błędu HTTP.</span><span class="sxs-lookup"><span data-stu-id="dc57a-204">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is to implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="dc57a-205">W rzeczywistości Jeśli wewnętrznego mikrousługi komunikują się przez utworzenie łańcucha żądań HTTP, zgodnie z opisem, może być podniesiono czy masz aplikacji monolitycznej, ale go w oparciu HTTP między procesami, zamiast mechanizmów komunikacji wewnątrzprocesową.</span><span class="sxs-lookup"><span data-stu-id="dc57a-205">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intra-process communication mechanisms.</span></span>

<span data-ttu-id="dc57a-206">W związku z tym aby wymusić Autonomia mikrousług i mieć większą odporność, należy zminimalizować użycie łańcuchów komunikacji żądania/odpowiedzi na mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="dc57a-206">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="dc57a-207">Zaleca się używać interakcji tylko asynchronicznych do komunikacji między mikrousług przy użyciu asynchronicznych komunikatów i zdarzenie oparte na komunikacji lub (asynchroniczny) sondowania HTTP niezależnie od oryginalnego żądania HTTP / Cykl odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="dc57a-207">It's recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="dc57a-208">Korzystanie z komunikacji asynchronicznej zostało wyjaśnione z dodatkowymi szczegółami w dalszej części tego przewodnika, w sekcjach [integracji asynchroniczne mikrousług wymusza autonomię w mikrousługach](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) i [asynchroniczne Komunikacja oparta na komunikatach](asynchronous-message-based-communication.md).</span><span class="sxs-lookup"><span data-stu-id="dc57a-208">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice's autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="dc57a-209">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="dc57a-209">Additional resources</span></span>

- <span data-ttu-id="dc57a-210">**Kolejnego elementu teorii CAP** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-210">**CAP theorem** \\</span></span>
  <https://en.wikipedia.org/wiki/CAP_theorem>

- <span data-ttu-id="dc57a-211">**Spójność ostateczna** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-211">**Eventual consistency** \\</span></span>
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="dc57a-212">**Podstawy spójności danych** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-212">**Data Consistency Primer** \\</span></span>
  <https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)>

- <span data-ttu-id="dc57a-213">**Martin Fowler. Podejście CQRS (Command and Query Responsibility Segregation)** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-213">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)** \\</span></span>
  <https://martinfowler.com/bliki/CQRS.html>

- <span data-ttu-id="dc57a-214">**Zmaterializowany widok** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-214">**Materialized View** \\</span></span>
  <https://docs.microsoft.com/azure/architecture/patterns/materialized-view>

- <span data-ttu-id="dc57a-215">**Charles wiersz. ACID programu vs. PODSTAWOWA: PH Shifting przetwarzania transakcji bazy danych** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-215">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing** \\</span></span>
  <https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/>

- <span data-ttu-id="dc57a-216">**Transakcja wyrównująca** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-216">**Compensating Transaction** \\</span></span>
  <https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction>

- <span data-ttu-id="dc57a-217">**Udi Dahan. Kompozycja korzystający z usługi** \\</span><span class="sxs-lookup"><span data-stu-id="dc57a-217">**Udi Dahan. Service Oriented Composition** \\</span></span>
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

>[!div class="step-by-step"]
><span data-ttu-id="dc57a-218">[Poprzednie](logical-versus-physical-architecture.md)
>[dalej](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="dc57a-218">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
