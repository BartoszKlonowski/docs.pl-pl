---
title: Problemy i rozwiązania do zarządzania danymi rozproszonych
description: Architektura Mikrousług .NET dla aplikacji .NET konteneryzowanych | Problemy i rozwiązania do zarządzania danymi rozproszonych
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 1d079dc7eef2f4abfbdec5a01b4233c8504d449d
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106492"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="0abdc-103">Problemy i rozwiązania do zarządzania danymi rozproszonych</span><span class="sxs-lookup"><span data-stu-id="0abdc-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="0abdc-104">Żądanie \#1: sposób definiowania granice każdej mikrousługi</span><span class="sxs-lookup"><span data-stu-id="0abdc-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="0abdc-105">Definiowanie granic mikrousługi prawdopodobnie pierwszego wyzwania, które każda osoba, która wystąpi.</span><span class="sxs-lookup"><span data-stu-id="0abdc-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="0abdc-106">Każdy mikrousługi należy autonomicznego ze wszystkimi korzyści i problemy, które wywołuje i każdego mikrousługi musi być częścią aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0abdc-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="0abdc-107">Jednak sposób można zidentyfikować te granice?</span><span class="sxs-lookup"><span data-stu-id="0abdc-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="0abdc-108">Najpierw należy się skoncentrować modeli domeny logiczne i dane dotyczące aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0abdc-108">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="0abdc-109">Należy spróbować ponownie zidentyfikować rozdzielonymi Wyspy danych i kontekstów w tej samej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0abdc-109">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="0abdc-110">Każdy kontekst może mieć język biznesowej (warunki biznesowej).</span><span class="sxs-lookup"><span data-stu-id="0abdc-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="0abdc-111">Konteksty należy określić i zarządzane niezależnie.</span><span class="sxs-lookup"><span data-stu-id="0abdc-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="0abdc-112">Warunki i jednostek używane w tych różnych kontekstach mogą dźwiękowej podobne, ale może wykryć, czy dla danego kontekstu koncepcja firmy, z jednym jest używana w innym celu w innym kontekście, a nawet może mieć inną nazwę.</span><span class="sxs-lookup"><span data-stu-id="0abdc-112">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="0abdc-113">Na przykład użytkownika mogą być określane jako użytkownik w kontekście tożsamości lub członkostwa odbiorcy w kontekście CRM, jako nabywców w kontekście porządkowania i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="0abdc-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="0abdc-114">Sposób identyfikacji granicę między wielu kontekstów aplikacji z innej domeny dla każdego kontekstu jest dokładnie, jak rozpoznać granice dla każdej mikrousługi biznesowych i jej powiązane danych i modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="0abdc-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="0abdc-115">Zawsze próba zminimalizować sprzężenia między tymi mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="0abdc-116">W tym przewodniku przechodzi w stan więcej szczegółów dotyczących tego projektu modelu identyfikacji i domeny w sekcji [identyfikujące model domeny granice dla każdej mikrousługi](#identifying-domain-model-boundaries-for-each-microservice) później.</span><span class="sxs-lookup"><span data-stu-id="0abdc-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="0abdc-117">Żądanie \#2: jak tworzyć zapytania, które służą do pobierania danych z kilku mikrousług</span><span class="sxs-lookup"><span data-stu-id="0abdc-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="0abdc-118">Drugi wyzwaniem jest implementowania kwerendy pobierające dane z kilku mikrousług, unikając do mikrousług chatty komunikacji z klientami zdalnymi aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0abdc-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="0abdc-119">Przykładem może być jednym ekranie z aplikacji mobilnej, który wymaga, aby wyświetlić informacje o użytkowniku, którego właścicielem jest koszyka, katalogu i mikrousług tożsamości użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0abdc-119">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="0abdc-120">Innym przykładem może być złożonego raportu obejmujące wiele tabel znajdujących się w wielu mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="0abdc-121">Odpowiednim rozwiązaniem jest zależna od złożoności kwerend.</span><span class="sxs-lookup"><span data-stu-id="0abdc-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="0abdc-122">Jednak w każdym przypadku należy sposób agregują informacje, aby zwiększyć wydajność w komunikacji systemu.</span><span class="sxs-lookup"><span data-stu-id="0abdc-122">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="0abdc-123">Najbardziej popularnych rozwiązań są następujące.</span><span class="sxs-lookup"><span data-stu-id="0abdc-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="0abdc-124">**Interfejs API bramy**.</span><span class="sxs-lookup"><span data-stu-id="0abdc-124">**API Gateway**.</span></span> <span data-ttu-id="0abdc-125">Agregacji proste danych z wielu mikrousług, którego właścicielem różnych baz danych Zalecanym podejściem jest mikrousługi agregacji, określany jako bramę interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="0abdc-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="0abdc-126">Jednak należy zachować ostrożność implementacja tego wzorca, ponieważ w systemie może być punktem urządzenie rozruchowe, a może naruszyć zasady Autonomia mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="0abdc-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="0abdc-127">Aby uniknąć tej możliwości, może mieć wielu bram interfejsu API dopasowanymi grzywną każdego jeden koncentrujących się na pionowym "fragment" lub obszar działalności systemu.</span><span class="sxs-lookup"><span data-stu-id="0abdc-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="0abdc-128">Wzorzec bramy interfejsu API jest co omówiono bardziej szczegółowo w sekcji Używanie interfejsu API bramy później.</span><span class="sxs-lookup"><span data-stu-id="0abdc-128">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="0abdc-129">**CQRS z tabelami zapytania/odczyty**.</span><span class="sxs-lookup"><span data-stu-id="0abdc-129">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="0abdc-130">Innym rozwiązaniem do agregowania danych z wielu mikrousług jest [Zmaterializowany widok wzorca](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="0abdc-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="0abdc-131">W takie podejście, należy wygenerować, wcześniej (przygotowanie nieznormalizowany danych, przed stanie rzeczywiste zapytań), tylko do odczytu tabelę z danymi, którego właścicielem jest wiele mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="0abdc-132">Tabela ma format dostosowane do potrzeb aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="0abdc-132">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="0abdc-133">Należy wziąć pod uwagę przypominać ekranu dla aplikacji mobilnej.</span><span class="sxs-lookup"><span data-stu-id="0abdc-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="0abdc-134">Jeśli masz pojedynczej bazy danych, użytkownik może pobierać razem danych dla tego ekranu przy użyciu zapytania SQL, który wykonuje sprzężenie złożonych obejmujące wiele tabel.</span><span class="sxs-lookup"><span data-stu-id="0abdc-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="0abdc-135">Jednak jeśli masz wiele baz danych, a każda baza danych jest własnością innego mikrousługi, nie można kwerendy tych baz danych i tworzenie sprzężenia SQL.</span><span class="sxs-lookup"><span data-stu-id="0abdc-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="0abdc-136">Złożone kwerendy staje się żądanie.</span><span class="sxs-lookup"><span data-stu-id="0abdc-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="0abdc-137">Można rozwiązać wymaganie podejście CQRS — tworzenie nieznormalizowany tabeli w innej bazy danych, która jest używana tylko dla zapytania.</span><span class="sxs-lookup"><span data-stu-id="0abdc-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="0abdc-138">Tabela może być zaprojektowana specjalnie z myślą o danych potrzebnych do złożonego zapytania, z relacją między polami wymaganej przez ekranu aplikacji i kolumn w tabeli zapytania.</span><span class="sxs-lookup"><span data-stu-id="0abdc-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="0abdc-139">Można go również służyć do celów raportowania.</span><span class="sxs-lookup"><span data-stu-id="0abdc-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="0abdc-140">Takie podejście nie tylko rozwiązuje problem oryginalnego (jak zapytań i sprzężenia między mikrousług); zwiększa również wydajności znacznie w porównaniu z złożonych sprzężenia, ponieważ masz już dane, które są wymagane przez aplikację w tabeli zapytania.</span><span class="sxs-lookup"><span data-stu-id="0abdc-140">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="0abdc-141">Oczywiście przy użyciu polecenia i podział odpowiedzialności kwerendy (CQRS) z zapytania/odczyty tabel oznacza dodatkowe prace i konieczne będzie obejmować spójność ostateczna.</span><span class="sxs-lookup"><span data-stu-id="0abdc-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="0abdc-142">Niemniej jednak wymagania dotyczące wydajności i skalowalności wysokiej w [współpracy scenariusze](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (lub konkurencyjnych scenariuszy, w zależności od punktu widzenia) jest, gdzie należy zastosować CQRS z wieloma bazami danych.</span><span class="sxs-lookup"><span data-stu-id="0abdc-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="0abdc-143">**"Zimnych danych" w bazach danych centralnej**.</span><span class="sxs-lookup"><span data-stu-id="0abdc-143">**“Cold data” in central databases**.</span></span> <span data-ttu-id="0abdc-144">Złożonych raportów i zapytań, które nie mogą wymagać danych w czasie rzeczywistym typowym podejściem jest wyeksportowanie Twojej "gorących danych" (danych transakcyjnych z mikrousług) jako "zimnych danych" w dużych baz danych, które są używane tylko do raportowania.</span><span class="sxs-lookup"><span data-stu-id="0abdc-144">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="0abdc-145">Tego systemu centralnej bazie danych może być danych Big Data systemu, takich jak Hadoop, Magazyn danych podobny do opartych na magazyn danych SQL Azure lub nawet jednej bazy danych SQL używane tylko dla raportów (Jeśli rozmiar nie będzie problemu).</span><span class="sxs-lookup"><span data-stu-id="0abdc-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="0abdc-146">Należy pamiętać, że ta scentralizowanej bazie danych mają być używane tylko do kwerendy i raporty, które nie są dane w czasie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="0abdc-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="0abdc-147">Oryginalne aktualizacje i transakcje jako źródła PRAWDA, muszą być danych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="0abdc-148">Sposób może synchronizować dane będą za pomocą komunikacji sterowane zdarzeniami (opisane w kolejnych sekcjach) lub przy użyciu innych narzędzi importu/eksportu infrastruktury bazy danych.</span><span class="sxs-lookup"><span data-stu-id="0abdc-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="0abdc-149">Jeśli użytkownik korzysta z komunikacji sterowane zdarzeniami, ten proces integracji będzie podobny do sposób propagację danych zgodnie z wcześniejszym opisem dla CQRS badania tabel.</span><span class="sxs-lookup"><span data-stu-id="0abdc-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="0abdc-150">Jednak jeśli projektu aplikacji obejmuje stale agregowanie informacji z wielu mikrousług złożonych zapytań, może być objawem zły projektu — mikrousługi należy jako izolowanych, jak to możliwe z innych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="0abdc-151">(Wyklucza raporty/analytics, która zawsze powinna być używana danych chłodni centralnej bazy danych). Ten problem często może być powodem do scalenia mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="0abdc-152">Musisz autonomię rozwoju i wdrażania każdej mikrousługi z silną zależności, spójność i agregacja danych.</span><span class="sxs-lookup"><span data-stu-id="0abdc-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="0abdc-153">Żądanie \#3: jak w celu ujednolicenia wielu mikrousług</span><span class="sxs-lookup"><span data-stu-id="0abdc-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="0abdc-154">Jak wspomniano wcześniej, danych należących do każdego mikrousługi jest oznaczony jako prywatny tego mikrousługi i można uzyskać tylko za pomocą jego mikrousługi interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="0abdc-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="0abdc-155">Dlatego żądanie przedstawiony jest implementowania procesów biznesowych na trasie przy zachowaniu spójności między wieloma mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="0abdc-156">Aby analizować ten problem, Przyjrzyjmy się przykładem z [eShopOnContainers odwołania aplikacji](http://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="0abdc-156">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="0abdc-157">Mikrousługi katalogu przechowuje informacje o wszystkich produktów, w tym ich poziomu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="0abdc-157">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="0abdc-158">Mikrousługi porządkowanie zarządza zleceń i należy sprawdzić nową kolejność nie przekracza dostępne katalogu podstawowego produktu.</span><span class="sxs-lookup"><span data-stu-id="0abdc-158">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="0abdc-159">(Lub scenariusza mogą dotyczyć logikę, która obsługuje produkty wycofane.) Hipotetyczny wbudowanymi wersji tej aplikacji porządkowania podsystemu można po prostu użyć transakcji ACID do sprawdzania dostępności zasobów, tworzenia kolejności w tabeli poleceń i aktualizacji dostępnych zasobów w tabeli Produkty.</span><span class="sxs-lookup"><span data-stu-id="0abdc-159">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="0abdc-160">Jednak w aplikacji oparte na mikrousług tabeli kolejności i produktu są własnością ich odpowiednich mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-160">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="0abdc-161">Nie mikrousługi kiedykolwiek powinna zawierać baz danych należących do innego mikrousługi w tej samej transakcji lub kwerend, jak pokazano w rysunek 4-9.</span><span class="sxs-lookup"><span data-stu-id="0abdc-161">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="0abdc-162">**Rysunek 4-9**.</span><span class="sxs-lookup"><span data-stu-id="0abdc-162">**Figure 4-9**.</span></span> <span data-ttu-id="0abdc-163">Mikrousługi bezpośrednio nie może uzyskać dostępu do tabeli w innym mikrousługi</span><span class="sxs-lookup"><span data-stu-id="0abdc-163">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="0abdc-164">Mikrousługi porządkowanie powinien nie zaktualizować tabeli produkty bezpośrednio, ponieważ w tabeli Produkty jest własnością mikrousługi katalogu.</span><span class="sxs-lookup"><span data-stu-id="0abdc-164">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="0abdc-165">Aby dokonać aktualizacji mikrousługi katalogu, mikrousługi porządkowanie należy używać tylko komunikacji asynchronicznej, takich jak zdarzenia integracji (wiadomości i komunikacji oparte na zdarzeniu).</span><span class="sxs-lookup"><span data-stu-id="0abdc-165">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="0abdc-166">Jest to sposób [eShopOnContainers](http://aka.ms/eshoponcontainers) odwołania aplikacji wykonuje ten typ aktualizacji.</span><span class="sxs-lookup"><span data-stu-id="0abdc-166">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="0abdc-167">Podane przez [Newtona zakończenia](https://en.wikipedia.org/wiki/CAP_theorem), musisz wybrać między dostępności i ACID wysoki poziom spójności.</span><span class="sxs-lookup"><span data-stu-id="0abdc-167">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="0abdc-168">Większość scenariuszy opartych na mikrousługi wymaga dostępności i wysoką skalowalność, w przeciwieństwie do wysoki poziom spójności.</span><span class="sxs-lookup"><span data-stu-id="0abdc-168">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="0abdc-169">Kluczowych aplikacji musi znajdować się, a następnie uruchomiona i deweloperów można obejść wysoki poziom spójności za pomocą techniki do pracy z słabych lub ostatecznego spójności.</span><span class="sxs-lookup"><span data-stu-id="0abdc-169">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="0abdc-170">To podejście przez większość architektury mikrousługi na podstawie.</span><span class="sxs-lookup"><span data-stu-id="0abdc-170">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="0abdc-171">Ponadto kwasu stylu lub dwufazowe zatwierdzanie transakcji nie są tylko względem mikrousług zasad. Większość bazy danych NoSQL (np. Azure DB rozwiązania Cosmos bazy danych MongoDB, itp.) nie obsługują dwufazowe zatwierdzanie transakcji.</span><span class="sxs-lookup"><span data-stu-id="0abdc-171">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="0abdc-172">Jednak zachowanie danych spójności między usługami i baz danych jest niezbędne.</span><span class="sxs-lookup"><span data-stu-id="0abdc-172">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="0abdc-173">Ten problem również jest powiązany z zapytania sposobu Propaguj zmiany do wszystkich mikrousług wielu w przypadku niektórych danych musi być nadmiarowe — na przykład, gdy musisz mieć nazwy lub opisu mikrousługi katalogu i koszyka produktu mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="0abdc-173">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="0abdc-174">Dobre rozwiązanie tego problemu jest Użyj spójność ostateczna między mikrousług przegubowe za pośrednictwem komunikacji sterowane zdarzeniami i systemem publikowania i subskrybowania.</span><span class="sxs-lookup"><span data-stu-id="0abdc-174">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="0abdc-175">Te tematy w sekcji [komunikacji asynchronicznej sterowane zdarzeniami](#async_event_driven_communication) dalszej części tego przewodnika.</span><span class="sxs-lookup"><span data-stu-id="0abdc-175">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="0abdc-176">Żądanie \#4: sposób projektowania komunikacji między granicami mikrousługi</span><span class="sxs-lookup"><span data-stu-id="0abdc-176">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="0abdc-177">Granice komunikacji za pośrednictwem mikrousługi jest rzeczywistym wyzwaniem.</span><span class="sxs-lookup"><span data-stu-id="0abdc-177">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="0abdc-178">W tym kontekście komunikacji nie odwołuje się który protokół powinien używać (HTTP i REST, protokołu AMQP obsługi wiadomości i tak dalej).</span><span class="sxs-lookup"><span data-stu-id="0abdc-178">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="0abdc-179">Zamiast tego adresów styl komunikacji należy używać, i jak sprzężonego z mikrousług powinno się.</span><span class="sxs-lookup"><span data-stu-id="0abdc-179">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="0abdc-180">W zależności od poziomu sprzężenia gdy wystąpi błąd, wpływ awarii w systemie różni się znacząco.</span><span class="sxs-lookup"><span data-stu-id="0abdc-180">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="0abdc-181">W Rozproszony system, takich jak mikrousług aplikacji sieci, z tylu artefakty przenoszenia i usługi rozproszone między wiele serwerów lub hostów nie zostanie ostatecznie składników.</span><span class="sxs-lookup"><span data-stu-id="0abdc-181">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="0abdc-182">Niepowodzenie częściowe i awarie jeszcze większym nastąpi, więc należy projektować Twojej mikrousług i komunikację między nimi biorąc pod uwagę ryzyko typowe w tym typie Rozproszony system.</span><span class="sxs-lookup"><span data-stu-id="0abdc-182">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="0abdc-183">Popularne podejście jest zaimplementowanie HTTP (REST) — na podstawie mikrousług ze względu na prostotę ich.</span><span class="sxs-lookup"><span data-stu-id="0abdc-183">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="0abdc-184">Podejście oparte na protokole HTTP jest dopuszczalne doskonale; w tym miejscu problem jest związany sposobu ich używania.</span><span class="sxs-lookup"><span data-stu-id="0abdc-184">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="0abdc-185">Jeśli używasz żądań i odpowiedzi HTTP tylko w celu interakcji z Twojej mikrousług z aplikacji klienckich lub bram interfejsu API, który jest poprawne.</span><span class="sxs-lookup"><span data-stu-id="0abdc-185">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="0abdc-186">Ale jeśli tworzysz długie łańcuchy synchroniczne wywołania HTTP między mikrousług komunikacji za pośrednictwem ich granic tak, jakby mikrousług był obiektów w aplikacji wbudowanymi aplikacji zostanie ostatecznie wystąpiły problemy.</span><span class="sxs-lookup"><span data-stu-id="0abdc-186">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="0abdc-187">Na przykład załóżmy, że aplikacja kliencka wykonuje wywołanie interfejsu API HTTP poszczególnych mikrousługi jak mikrousługi porządkowanie.</span><span class="sxs-lookup"><span data-stu-id="0abdc-187">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="0abdc-188">Mikrousługi porządkowanie z kolei wywołuje dodatkowe cykl mikrousług przy użyciu protokołu HTTP w ramach tego samego żądania/odpowiedzi, tworzenia łańcucha wywołań HTTP.</span><span class="sxs-lookup"><span data-stu-id="0abdc-188">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="0abdc-189">Może być brzmi uzasadnione początkowo.</span><span class="sxs-lookup"><span data-stu-id="0abdc-189">It might sound reasonable initially.</span></span> <span data-ttu-id="0abdc-190">Istnieją jednak ważne kwestie do rozważenia podczas przechodzenia w dół tej ścieżki:</span><span class="sxs-lookup"><span data-stu-id="0abdc-190">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="0abdc-191">Blokowania i niskiej wydajności.</span><span class="sxs-lookup"><span data-stu-id="0abdc-191">Blocking and low performance.</span></span> <span data-ttu-id="0abdc-192">Ze względu na specyfikę synchroniczne HTTP oryginalne żądanie nie otrzyma odpowiedź, zakończenie wszystkich wewnętrzny połączeń HTTP.</span><span class="sxs-lookup"><span data-stu-id="0abdc-192">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="0abdc-193">Załóżmy, jeśli liczba tych wywołań znacznie zwiększa i w tym samym czasie, jedną HTTP pośredniego wywołania do mikrousługi jest zablokowana.</span><span class="sxs-lookup"><span data-stu-id="0abdc-193">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="0abdc-194">Wynik jest to wpływ na wydajność, czy wykładniczo wpłynie ogólnej skalowalności jako dodatkowe zwiększenie żądania HTTP.</span><span class="sxs-lookup"><span data-stu-id="0abdc-194">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="0abdc-195">Sprzężenia mikrousług protokołu HTTP.</span><span class="sxs-lookup"><span data-stu-id="0abdc-195">Coupling microservices with HTTP.</span></span> <span data-ttu-id="0abdc-196">Mikrousług biznesowych nie powinny być połączone z mikrousług innych firm.</span><span class="sxs-lookup"><span data-stu-id="0abdc-196">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="0abdc-197">Najlepiej, jeśli ich nie "informacje" o istnienie innych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-197">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="0abdc-198">Jeśli aplikacja opiera się na sprzężenia mikrousług, jak pokazano w przykładzie, uzyskanie Autonomia na mikrousługi będzie niemożliwe.</span><span class="sxs-lookup"><span data-stu-id="0abdc-198">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="0abdc-199">Błąd w żadnych jeden mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="0abdc-199">Failure in any one microservice.</span></span> <span data-ttu-id="0abdc-200">Jeśli zaimplementowano łańcucha mikrousług połączone połączenia HTTP, gdy dowolne mikrousług nie powiedzie się (i ostatecznie zakończy się niepowodzeniem) całego łańcucha mikrousług zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="0abdc-200">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="0abdc-201">Systemu mikrousługi należy tak zaprojektować, aby kontynuować pracę oraz możliwości podczas częściowej awarii.</span><span class="sxs-lookup"><span data-stu-id="0abdc-201">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="0abdc-202">Nawet w przypadku implementowania logiki klienta, która używa ponownych prób z wykładniczego wycofywania lub mechanizmy wyłącznika więcej łańcuchów wywołania złożone HTTP są bardziej złożone jest zaimplementować strategię błędu HTTP w oparciu.</span><span class="sxs-lookup"><span data-stu-id="0abdc-202">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="0abdc-203">W rzeczywistości Jeśli Twoje wewnętrzny mikrousług komunikują się przez utworzenie łańcucha żądań HTTP, zgodnie z opisem, go może być utrzymywał, czy masz wbudowanymi aplikacji, ale oparty na HTTP między procesami zamiast mechanizmy komunikacji intraprocess.</span><span class="sxs-lookup"><span data-stu-id="0abdc-203">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="0abdc-204">W związku z tym aby wymusić Autonomia mikrousługi i mieć większą elastyczność, należy zminimalizować użycie łańcucha żądań i odpowiedzi komunikacji między mikrousług.</span><span class="sxs-lookup"><span data-stu-id="0abdc-204">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="0abdc-205">Zaleca się używać tylko asynchroniczne interakcji dla komunikacji między mikrousługi za pomocą komunikacji asynchronicznej wiadomości - i oparty na zdarzeniach lub sondowania HTTP niezależnie od oryginalnej cyklu żądań i odpowiedzi HTTP.</span><span class="sxs-lookup"><span data-stu-id="0abdc-205">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="0abdc-206">Użycie komunikacji asynchronicznej jest wyjaśnione w dokumencie o dodatkowe informacje w dalszej części tego przewodnika w sekcjach [integracji asynchroniczne mikrousługi wymusza Autonomia w mikrousługi](#asynchronous-microservice-integration-enforce-microservices-autonomy) i [asynchronicznym Komunikacja oparta na komunikat](#asynchronous-message-based-communication).</span><span class="sxs-lookup"><span data-stu-id="0abdc-206">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="0abdc-207">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="0abdc-207">Additional resources</span></span>

-   <span data-ttu-id="0abdc-208">**Newtona centralnych zasad dostępu**
    [*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="0abdc-208">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="0abdc-209">**Spójność ostateczna**
    [*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="0abdc-209">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="0abdc-210">**Elementarz spójność danych**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="0abdc-210">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="0abdc-211">**Pole Fowler. CQRS (polecenia i podział odpowiedzialności zapytania)**
    [*https://martinfowler.com/bliki/CQRS.html*](https://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="0abdc-211">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*https://martinfowler.com/bliki/CQRS.html*](https://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="0abdc-212">**Zmaterializowanym widoku**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="0abdc-212">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="0abdc-213">**Charlesa wiersza. ACID vs. PODSTAWOWA: Ciąg Shifting przetwarzania transakcji bazy danych**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="0abdc-213">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="0abdc-214">**Kompensowanie transakcji**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="0abdc-214">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="0abdc-215">**Udi Dahan. Kompozycja zorientowane na usługę**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="0abdc-215">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="0abdc-216">[Poprzednie](logical-versus-physical-architecture.md)
[dalej](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="0abdc-216">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
