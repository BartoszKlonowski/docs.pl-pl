---
title: Komunikacja w ramach architektury mikrousługi
description: Poznaj różne sposoby komunikacji między mikrousługami, zrozumienia konsekwencji synchroniczne i asynchroniczne metody.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/20/2018
ms.openlocfilehash: 1e8f15e2a02c8f6e7456a2e3a2f6756277ec6314
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/10/2018
ms.locfileid: "53127176"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="e81ef-103">Komunikacja w ramach architektury mikrousługi</span><span class="sxs-lookup"><span data-stu-id="e81ef-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="e81ef-104">W aplikacji monolitycznej, uruchomiony w ramach jednego procesu składniki wywołać za pomocą metody poziomu języka lub wywołania funkcji.</span><span class="sxs-lookup"><span data-stu-id="e81ef-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="e81ef-105">Te mogą zostać zdecydowanie dołączone Jeśli tworzysz obiektów przy użyciu kodu (na przykład `new ClassName()`), lub może być wywoływany w sposób odłączony, jeśli używasz wstrzykiwanie zależności, odwołując się do abstrakcje zamiast konkretnych obiektów.</span><span class="sxs-lookup"><span data-stu-id="e81ef-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="e81ef-106">W obu przypadkach obiekty są uruchamiane w ramach tego samego procesu.</span><span class="sxs-lookup"><span data-stu-id="e81ef-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="e81ef-107">Największe wyzwanie w przypadku zmiany z poziomu aplikacji monolitycznych aplikacji opartych na mikrousługach znajduje się podczas zmieniania mechanizm komunikacji.</span><span class="sxs-lookup"><span data-stu-id="e81ef-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="e81ef-108">Bezpośrednia konwersji z wywołania metody w trakcie do wywołań RPC usługi spowoduje, że duża liczba i nie sprawną komunikację, która nie wykonuje również w rozproszonych środowisk.</span><span class="sxs-lookup"><span data-stu-id="e81ef-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="e81ef-109">Wyzwania związane z prawidłowo projektowania Rozproszony system wystarczająco dobrze wiadomo, czy jest parzysta canon, znane jako [błędne przekonania dotyczące przetwarzania rozproszonego](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) , zawiera listę założeń, które deweloperzy mogą stosować często podczas przenoszenia z monolitycznego projekty do rozproszonego.</span><span class="sxs-lookup"><span data-stu-id="e81ef-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="e81ef-110">Nie ma jednego rozwiązania, ale kilka.</span><span class="sxs-lookup"><span data-stu-id="e81ef-110">There isn't one solution, but several.</span></span> <span data-ttu-id="e81ef-111">Jedno rozwiązanie polega na izolowanie możliwie mikrousług biznesowych.</span><span class="sxs-lookup"><span data-stu-id="e81ef-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="e81ef-112">Następnie użyj komunikacji asynchronicznej między mikrousługami wewnętrzny i Zastąp szczegółowych komunikacji, który jest typowy wewnątrzprocesową komunikacji między obiektami za pomocą gruboziarnisty szczegółowej komunikacji.</span><span class="sxs-lookup"><span data-stu-id="e81ef-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="e81ef-113">Można to zrobić przez grupowanie połączeń i zwracanie danych, która agreguje wyniki wielu wywołań wewnętrznego, do klienta.</span><span class="sxs-lookup"><span data-stu-id="e81ef-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="e81ef-114">Aplikacją opartą na mikrousługach to Rozproszony system działających w wielu procesów lub usług, zwykle nawet między wieloma serwerami lub hostów.</span><span class="sxs-lookup"><span data-stu-id="e81ef-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="e81ef-115">Każde wystąpienie usługi jest zwykle procesem.</span><span class="sxs-lookup"><span data-stu-id="e81ef-115">Each service instance is typically a process.</span></span> <span data-ttu-id="e81ef-116">W związku z tym usług muszą wchodzić w interakcje za pomocą protokołu komunikacji między procesami, takich jak HTTP, AMQP lub binarny protokołu takich jak TCP, w zależności od charakteru każdej usługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="e81ef-117">Społeczność mikrousług promuje ideę "[inteligentne punkty końcowe i potoków bez](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" to slogan zachęca do projektu, który jest całkowicie niezależny możliwie między mikrousługami i jak spójnego, jak to możliwe w jednej mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="e81ef-118">Jak wyjaśniono wcześniej, każda mikrousługa jest właścicielem własnych danych i własnej logiki domeny.</span><span class="sxs-lookup"><span data-stu-id="e81ef-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="e81ef-119">Ale mikrousług, aplikacja end-to-end redagowania są zazwyczaj po prostu choreographed przy użyciu komunikacji REST, a nie złożoną protokołów, takich jak usługi WS -\* i elastyczne komunikacji oparte na zdarzeniach, zamiast scentralizowane Business — proces koordynatorów.</span><span class="sxs-lookup"><span data-stu-id="e81ef-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="e81ef-120">Dwa najczęściej używane protokoły są żądania/odpowiedzi HTTP przy użyciu interfejsów API (podczas wykonywania zapytania większość wszystkich) zasobów i uproszczone asynchronicznej obsługi komunikatów podczas komunikowania się aktualizuje przez wiele mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e81ef-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="e81ef-121">Omówiona bardziej szczegółowo w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="e81ef-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="e81ef-122">Typy komunikacji</span><span class="sxs-lookup"><span data-stu-id="e81ef-122">Communication types</span></span>

<span data-ttu-id="e81ef-123">Klienta i usługi mogą komunikować się za pośrednictwem wiele różnych typów komunikacji, każdy z nich przeznaczone dla różnych scenariuszy i cele.</span><span class="sxs-lookup"><span data-stu-id="e81ef-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="e81ef-124">Początkowo tych typów komunikacji mogą być klasyfikowane w dwóch osi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="e81ef-125">Pierwsza oś Określa, czy protokół jest synchroniczna lub asynchroniczna:</span><span class="sxs-lookup"><span data-stu-id="e81ef-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="e81ef-126">Protokół synchroniczne.</span><span class="sxs-lookup"><span data-stu-id="e81ef-126">Synchronous protocol.</span></span> <span data-ttu-id="e81ef-127">Protokół HTTP jest protokół synchroniczne.</span><span class="sxs-lookup"><span data-stu-id="e81ef-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="e81ef-128">Klient wysyła żądanie i czeka na odpowiedź z usługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="e81ef-129">Który jest niezależny od wykonania kodu klienta, który może być synchroniczna (wątek jest zablokowany) lub asynchroniczną (wątek nie jest zablokowany, i odpowiedź osiągną wywołanie zwrotne po pewnym czasie).</span><span class="sxs-lookup"><span data-stu-id="e81ef-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="e81ef-130">Należy koniecznie zwrócić uwagę, jest protokół (HTTP/HTTPS) jest synchroniczne i kod klienta można kontynuować tylko jej zadania, po otrzymaniu odpowiedzi serwera HTTP.</span><span class="sxs-lookup"><span data-stu-id="e81ef-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="e81ef-131">Protokół asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="e81ef-131">Asynchronous protocol.</span></span> <span data-ttu-id="e81ef-132">Inne protokoły, takie jak protokół AMQP (protokół obsługiwany przez wiele systemów operacyjnych i środowisk w chmurze) używają komunikatów asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="e81ef-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="e81ef-133">Nadawca kodu lub komunikat klienta zazwyczaj nie czeka na odpowiedź.</span><span class="sxs-lookup"><span data-stu-id="e81ef-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="e81ef-134">Po prostu wysyła wiadomość jako podczas wysyłania komunikatu do kolejki RabbitMQ lub innych brokera komunikatów.</span><span class="sxs-lookup"><span data-stu-id="e81ef-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="e81ef-135">Drugą oś Określa, czy komunikacja nie ma jednego odbiornika lub wieloma odbiornikami:</span><span class="sxs-lookup"><span data-stu-id="e81ef-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="e81ef-136">Jednego odbiornika.</span><span class="sxs-lookup"><span data-stu-id="e81ef-136">Single receiver.</span></span> <span data-ttu-id="e81ef-137">Każde żądanie muszą zostać przetworzone przez dokładnie jednego odbiornika lub usługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="e81ef-138">Na przykład ta komunikacja [wzorzec polecenia](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="e81ef-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="e81ef-139">Wiele odbiorników.</span><span class="sxs-lookup"><span data-stu-id="e81ef-139">Multiple receivers.</span></span> <span data-ttu-id="e81ef-140">Każde żądanie mogą być przetwarzane przez zero do wielu odbiorników.</span><span class="sxs-lookup"><span data-stu-id="e81ef-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="e81ef-141">Ten typ komunikacji musi być asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="e81ef-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="e81ef-142">Na przykład [publikowania/subskrybowania](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanizm używany w wzorców, takich jak [architektura sterowana zdarzeniami](https://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="e81ef-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="e81ef-143">Zależy to interfejs lub komunikatów brokera magistrali zdarzeń podczas propagowania aktualizacje danych między wiele mikrousług za pomocą zdarzeń; Zazwyczaj jest implementowany przy użyciu usługi service bus lub podobne artefaktu, takie jak [usługi Azure Service Bus](https://azure.microsoft.com/services/service-bus/) przy użyciu [tematy i subskrypcje](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="e81ef-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="e81ef-144">Aplikacją opartą na mikrousługach często używają kombinacji tych stylów komunikacji.</span><span class="sxs-lookup"><span data-stu-id="e81ef-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="e81ef-145">Najczęściej spotykanym typem jest jednego odbiornika protokołu synchroniczne, takich jak HTTP/HTTPS podczas wywoływania regularnej HTTP dla interfejsu API sieci Web.</span><span class="sxs-lookup"><span data-stu-id="e81ef-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="e81ef-146">Mikrousługi zwykle także używać protokołów obsługi komunikatów dla komunikacji asynchronicznej między mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="e81ef-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="e81ef-147">Te osi są dobre wiedzieć, dzięki czemu masz w celu uściślenia na mechanizmy komunikacji możliwe, ale nie są istotne problemy podczas tworzenia mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e81ef-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="e81ef-148">Rodzaj asynchroniczne wykonywanie wątków klienta ani asynchronicznego charakter wybranego protokołu są ważne punkty podczas integrowania mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e81ef-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="e81ef-149">Co *jest* ważna jest możliwość integracji mikrousługi asynchronicznie przy zachowaniu niezależność mikrousług, zgodnie z opisem w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e81ef-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="e81ef-150">Integracja asynchroniczne mikrousług wymusza autonomię w mikrousługach</span><span class="sxs-lookup"><span data-stu-id="e81ef-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="e81ef-151">Jak wspomniano wcześniej, istotne podczas kompilowania aplikacji mikrousług jest to sposób zintegrować mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="e81ef-152">W idealnym przypadku należy spróbować zminimalizować komunikacji między mikrousługami wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="e81ef-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="e81ef-153">Mniej komunikacji między mikrousługami, tym lepiej.</span><span class="sxs-lookup"><span data-stu-id="e81ef-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="e81ef-154">Jednak w wielu przypadkach, będziesz mieć dostęp do jakiś sposób integracji mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e81ef-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="e81ef-155">Gdy trzeba to zrobić, w tym miejscu reguła krytycznego jest komunikacji między mikrousług należy asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="e81ef-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="e81ef-156">Nie oznacza, trzeba użyć określonego protokołu, (na przykład asynchronicznej obsługi komunikatów i synchroniczne HTTP).</span><span class="sxs-lookup"><span data-stu-id="e81ef-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="e81ef-157">Po prostu oznacza to, że komunikacji między mikrousługami powinno być wykonywane tylko przez propagowanie danych asynchronicznie, ale Staraj się nie są zależne od innych wewnętrznych mikrousługi w ramach operacji żądania/odpowiedzi HTTP początkowej usługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="e81ef-158">Jeśli to możliwe nigdy nie są zależne od synchroniczną komunikację (żądania/odpowiedzi) między wiele mikrousług, nawet w przypadku zapytań.</span><span class="sxs-lookup"><span data-stu-id="e81ef-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="e81ef-159">Celem każda mikrousługa jest jako autonomiczne i konsumenta klienta, nawet jeśli są inne usługi, które są częścią aplikacji end-to-end w dół lub w złej kondycji.</span><span class="sxs-lookup"><span data-stu-id="e81ef-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="e81ef-160">Jeśli sądzisz, musisz wprowadzić wywołanie jednej mikrousług innych mikrousługi (np. wykonywania żądaniem HTTP kwerendy danych), aby można było podać odpowiedzi do aplikacji klienta, masz architekturę, która nie być odporny, gdy niektóre mikrousług się nie powieść.</span><span class="sxs-lookup"><span data-stu-id="e81ef-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="e81ef-161">Ponadto mających zależności HTTP między mikrousług, takich jak podczas tworzenia długie cykle żądania/odpowiedzi HTTP z żądania łańcuchów, jak pokazano w pierwszej części 4 rysunek-15, nie tylko sprawia, że mikrousługi nie autonomicznego, ale również ich wydajność jest wpływ, jak tylko jednej z usług w tym łańcuchu nie działa poprawnie.</span><span class="sxs-lookup"><span data-stu-id="e81ef-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="e81ef-162">Bardziej Dodaj synchroniczne zależności między mikrousług, takich jak żądania zapytania, niższa pobiera całkowity czas odpowiedzi dla aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="e81ef-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![W komunikacie synchroniczne "łańcucha" żądania jest tworzony między mikrousługami przy jednoczesnej obsłudze żądania klienta.](./media/image15.png)

<span data-ttu-id="e81ef-166">**Rysunek 4 – 15**.</span><span class="sxs-lookup"><span data-stu-id="e81ef-166">**Figure 4-15**.</span></span> <span data-ttu-id="e81ef-167">Niezalecane wzorce i wzorców w ramach komunikacji między mikrousługami</span><span class="sxs-lookup"><span data-stu-id="e81ef-167">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="e81ef-168">Jeśli Twoje mikrousług musi zgłosić dodatkowych akcji w innym mikrousług, jeśli to możliwe, nie wykonuj tę akcję synchronicznie, w ramach mikrousług żądania i odpowiedzi operacji pierwotnej.</span><span class="sxs-lookup"><span data-stu-id="e81ef-168">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="e81ef-169">Zamiast tego asynchronicznie (za pomocą asynchronicznej obsługi komunikatów lub zdarzeń integracji, kolejki, itd.).</span><span class="sxs-lookup"><span data-stu-id="e81ef-169">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="e81ef-170">Jednak w miarę możliwości, nie wywołać akcję synchronicznie w ramach oryginalnego synchronicznych operacji żądania i odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-170">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="e81ef-171">A na koniec i jest to, gdzie większość problemów wystąpić podczas tworzenia mikrousług, jeśli Twoje początkowe mikrousług wymaga danych, który pierwotnie jest własnością innych mikrousług, nie należy polegać na synchroniczne żądania dla tych danych.</span><span class="sxs-lookup"><span data-stu-id="e81ef-171">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="e81ef-172">Zamiast tego należy replikować lub propagować dane (tylko atrybuty, które są potrzebne) w bazie danych usługi początkowej spójność ostateczną (zazwyczaj przy użyciu zdarzenia integracji, jak wyjaśniono w kolejnych sekcjach).</span><span class="sxs-lookup"><span data-stu-id="e81ef-172">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="e81ef-173">Jak wspomniano wcześniej w sekcji [identyfikowanie ograniczeń modelu domeny dla poszczególnych mikrousług](identify-microservice-domain-model-boundaries.md), powielanie niektórych danych między kilka mikrousług jest nieprawidłowy projekt — przeciwnie, podczas wykonywania, które można tłumaczyć danych określonego język lub warunki tej dodatkowe domeny lub ograniczone do kontekstu.</span><span class="sxs-lookup"><span data-stu-id="e81ef-173">As noted earlier in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md), duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="e81ef-174">Na przykład w [aplikacji w ramach aplikacji eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) masz mikrousługi o nazwie identity.api, który jest odpowiedzialny za większość danych użytkownika za pomocą jednostki o nazwie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e81ef-174">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named identity.api that's in charge of most of the user's data with an entity named User.</span></span> <span data-ttu-id="e81ef-175">Jednak jeśli potrzebujesz do przechowywania danych o użytkowniku w mikrousługach porządkowanie, są przechowywane go jako inny element o nazwie kupujący.</span><span class="sxs-lookup"><span data-stu-id="e81ef-175">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="e81ef-176">Jednostki nabywcy udostępni oryginalnej jednostki użytkownika tej samej tożsamości, ale może mieć tylko kilka atrybutów wymaganych przez domenę porządkowanie i nie profilu użytkownika całego.</span><span class="sxs-lookup"><span data-stu-id="e81ef-176">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="e81ef-177">Do komunikacji i propagowanie danych asynchronicznie mikrousług, aby mogła mieć spójność ostateczną, może korzystać z dowolnego protokołu.</span><span class="sxs-lookup"><span data-stu-id="e81ef-177">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="e81ef-178">Jak wspomniano wcześniej, można użyć zdarzenia integracji przy użyciu magistrali zdarzeń lub broker lub możesz nawet użyć HTTP przez sondowanie innych usług, zamiast tego komunikatu.</span><span class="sxs-lookup"><span data-stu-id="e81ef-178">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="e81ef-179">Nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="e81ef-179">It doesn't matter.</span></span> <span data-ttu-id="e81ef-180">Jest ważne zasada nie chcesz tworzyć synchroniczne zależności między mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-180">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="e81ef-181">W poniższych sekcjach opisano wiele stylów komunikacji, można rozważyć użycie w aplikacji opartych na mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="e81ef-181">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="e81ef-182">Style komunikacji</span><span class="sxs-lookup"><span data-stu-id="e81ef-182">Communication styles</span></span>

<span data-ttu-id="e81ef-183">Istnieje wiele protokołów i opcji, których można użyć do komunikacji, w zależności od typu komunikacji, którego chcesz użyć.</span><span class="sxs-lookup"><span data-stu-id="e81ef-183">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="e81ef-184">Jeśli używasz mechanizm komunikacji/odpowiedzi na podstawie żądań synchronicznych protokoły, takie jak metody HTTP i REST są najbardziej typowy, zwłaszcza, jeśli podczas publikowania usług poza klaster hosta lub mikrousług platformy Docker.</span><span class="sxs-lookup"><span data-stu-id="e81ef-184">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="e81ef-185">Jeśli masz podczas komunikacji między usługami wewnętrznie (w klastrze hosta lub mikrousług platformy Docker), można również użyć mechanizmów komunikacji format binarny (na przykład WCF, za pomocą protokołu TCP i format binarny i komunikacji zdalnej usługi Service Fabric).</span><span class="sxs-lookup"><span data-stu-id="e81ef-185">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="e81ef-186">Alternatywnie można użyć mechanizmów komunikacji asynchronicznej, oparta na komunikatach na przykład protokół AMQP.</span><span class="sxs-lookup"><span data-stu-id="e81ef-186">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="e81ef-187">Dostępne są także wiele formatów wiadomości, takich jak JSON lub XML lub nawet binarne formatach, które mogą być bardziej wydajne.</span><span class="sxs-lookup"><span data-stu-id="e81ef-187">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="e81ef-188">Jeśli Twoje wybrany format binarny nie jest to standard, prawdopodobnie nie jest dobrym pomysłem jest publicznie publikowania usług z wykorzystaniem tego formatu.</span><span class="sxs-lookup"><span data-stu-id="e81ef-188">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="e81ef-189">Można użyć formatu niestandardowego dla wewnętrznej komunikacji między mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-189">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="e81ef-190">Można to zrobić, podczas komunikacji między mikrousługami w ramach platformy Docker lub mikrousług hosta klastra (koordynatorów platformy Docker lub Azure Service Fabric) lub dla aplikacji klienckich własności, komunikujące się z mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e81ef-190">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="e81ef-191">Żądanie/odpowiedź komunikacji przy użyciu tych protokołów REST</span><span class="sxs-lookup"><span data-stu-id="e81ef-191">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="e81ef-192">Kiedy klient używa komunikacji żądanie/odpowiedź, wysyła żądanie do usługi, a następnie procesów informatycznych żądanie i wysyła odpowiedź z powrotem.</span><span class="sxs-lookup"><span data-stu-id="e81ef-192">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="e81ef-193">Komunikat żądania/odpowiedzi szczególnie dobrze jest odpowiedni dla wykonywanie zapytań o dane w czasie rzeczywistym interfejsu użytkownika (interfejs użytkownika na żywo) z aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="e81ef-193">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="e81ef-194">W związku z tym w ramach architektury mikrousługi prawdopodobnie użyjesz ten mechanizm komunikacji dla większości zapytań, jak pokazano w rysunek 4 – 16.</span><span class="sxs-lookup"><span data-stu-id="e81ef-194">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Może używać komunikacji żądania/odpowiedzi dla zapytań na żywo, gdy klient wysyła żądanie do bramy interfejsu API, przy założeniu, że odpowiedź z mikrousług zostaną odebrane w bardzo krótkim czasie.](./media/image16.png)

<span data-ttu-id="e81ef-196">**Rysunek 4 – 16**.</span><span class="sxs-lookup"><span data-stu-id="e81ef-196">**Figure 4-16**.</span></span> <span data-ttu-id="e81ef-197">Za pomocą komunikacji żądania/odpowiedzi HTTP (synchronicznego lub asynchronicznego)</span><span class="sxs-lookup"><span data-stu-id="e81ef-197">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="e81ef-198">Kiedy klient używa komunikacji żądanie/odpowiedź, zakłada się, że odpowiedzi zostaną dostarczone w krótkim czasie, zwykle niecałej sekundy lub kilka sekund co najwyżej.</span><span class="sxs-lookup"><span data-stu-id="e81ef-198">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="e81ef-199">Opóźnione odpowiedzi potrzebne do zaimplementowania komunikacji asynchronicznej w oparciu o [wzorców obsługi komunikatów](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) i [komunikatów technologii](https://en.wikipedia.org/wiki/Message-oriented_middleware), który jest różne podejście, które firma Microsoft opisano w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e81ef-199">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="e81ef-200">Popularnym stylem architektury do komunikacji żądania/odpowiedzi jest [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="e81ef-200">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="e81ef-201">To podejście jest oparty na i ściśle sprzężonych, [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protokół, stosujących zleceń HTTP, takich jak GET, POST i umieścić.</span><span class="sxs-lookup"><span data-stu-id="e81ef-201">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="e81ef-202">POZOSTAŁE elementy są najczęściej używane podejście architektoniczne komunikacji podczas tworzenia usługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-202">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="e81ef-203">Podczas tworzenia usługi internetowego interfejsu API platformy ASP.NET Core, można zaimplementować usług REST.</span><span class="sxs-lookup"><span data-stu-id="e81ef-203">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="e81ef-204">Brak dodatkowych wartości podczas korzystania z usług REST protokołu HTTP jako języka definicji interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e81ef-204">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="e81ef-205">Na przykład jeśli używasz [metadanych Swagger](https://swagger.io/) do opisania interfejsu API usługi, można użyć narzędzia, które generują wycinków klienta, które można bezpośrednio odkrycie i używanie usługi.</span><span class="sxs-lookup"><span data-stu-id="e81ef-205">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="e81ef-206">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="e81ef-206">Additional resources</span></span>

- <span data-ttu-id="e81ef-207">**Martina Fowlera. Model dojrzałości Leonard** opis modelu REST.</span><span class="sxs-lookup"><span data-stu-id="e81ef-207">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  [*https://martinfowler.com/articles/richardsonMaturityModel.html*](https://martinfowler.com/articles/richardsonMaturityModel.html)

- <span data-ttu-id="e81ef-208">**Struktury swagger** oficjalna witryna.</span><span class="sxs-lookup"><span data-stu-id="e81ef-208">**Swagger** The official site.</span></span> \
  [*https://swagger.io/*](https://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="e81ef-209">Wypychania i komunikację w czasie rzeczywistym, w oparciu o HTTP</span><span class="sxs-lookup"><span data-stu-id="e81ef-209">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="e81ef-210">Inną możliwością (zwykle dla różnych celów niż REST) jest w czasie rzeczywistym i jeden do wielu komunikacji z platformami wyższego poziomu, takich jak [ASP.NET SignalR](https://www.asp.net/signalr) i protokoły, takie jak [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="e81ef-210">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="e81ef-211">Jak pokazano na rysunku 4-17, w czasie rzeczywistym komunikacji HTTP oznacza, że można do kodu serwera wypychania zawartości do połączonych klientów, jak dane będą dostępne, zamiast serwera oczekiwania dla klientów dane nowego żądania.</span><span class="sxs-lookup"><span data-stu-id="e81ef-211">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![SignalR to dobry sposób osiągnięcia komunikację w czasie rzeczywistym do wypychania zawartości do klientów z serwerów zaplecza.](./media/image17.png)

<span data-ttu-id="e81ef-213">**Rysunek 4-17**.</span><span class="sxs-lookup"><span data-stu-id="e81ef-213">**Figure 4-17**.</span></span> <span data-ttu-id="e81ef-214">Jeden do jednego komunikatów asynchronicznych w czasie rzeczywistym komunikacji</span><span class="sxs-lookup"><span data-stu-id="e81ef-214">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="e81ef-215">Ponieważ komunikacji w czasie rzeczywistym, aplikacje klienckie niemal natychmiast wyświetlić zmiany.</span><span class="sxs-lookup"><span data-stu-id="e81ef-215">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="e81ef-216">Zazwyczaj jest to obsługiwane przez protokół, takich jak funkcja WebSockets, za pomocą wielu połączeń funkcji WebSockets (po jednej na klienta).</span><span class="sxs-lookup"><span data-stu-id="e81ef-216">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="e81ef-217">Typowym przykładem jest, gdy usługa jednocześnie komunikuje się zmian w wyniku gry sportowe, aby wiele aplikacji sieci web klienta.</span><span class="sxs-lookup"><span data-stu-id="e81ef-217">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e81ef-218">[Poprzednie](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[dalej](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="e81ef-218">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>