---
title: "Zdarzenia domeny. Projektowanie i wdrażanie"
description: "Architektura Mikrousług .NET dla aplikacji .NET konteneryzowanych | Zdarzenia domeny, projektowanie i wdrażanie"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 12/11/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 5840c2f7692d81f193c7d659aea6eb42a431369e
ms.sourcegitcommit: f28752eab00d2bd97e971542c0f49ce63cfbc239
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/29/2018
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="e0ae2-105">Zdarzenia domeny: projektowanie i wdrażanie</span><span class="sxs-lookup"><span data-stu-id="e0ae2-105">Domain events: design and implementation</span></span>

<span data-ttu-id="e0ae2-106">Zdarzenia domeny umożliwia jawne Implementowanie skutków ubocznych zmiany w swojej domenie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="e0ae2-107">W innych wyrazów i za pomocą terminologii DDD umożliwia jawne Implementowanie skutków ubocznych między Agreguje wiele zdarzeń domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="e0ae2-108">Opcjonalnie lepszą skalowalność i mniej wpływ zablokowanie bazy danych, należy użyć spójność ostateczna między zagregowanych zakresu umieszczonych w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="e0ae2-109">Co to jest zdarzenie domeny?</span><span class="sxs-lookup"><span data-stu-id="e0ae2-109">What is a domain event?</span></span>

<span data-ttu-id="e0ae2-110">Zdarzenie jest coś, co ma przypada w przeszłości.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="e0ae2-111">Zdarzenie w domenie jest, logicznie, czegoś, co się stało w określonej domenie i coś ma inne części tej samej domeny (w trakcie), należy pamiętać o i potencjalnie reagowania na.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="e0ae2-112">Ważne korzyści zdarzeń domeny jest, że efekty uboczne po coś się stało w domenie może zostać wyrażona jawnie zamiast niejawnie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="e0ae2-113">Te strony efekty muszą być zgodne, tak się zdarzyć, albo wszystkie operacje związane z zadań biznesowych lub żadna z nich.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="e0ae2-114">Ponadto zdarzenia domeny umożliwiają lepsze separacji między klas w ramach tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="e0ae2-115">Na przykład jeśli tylko korzystania z programu Entity Framework i jednostek lub nawet agregacje, jeśli ma być efekty uboczne znacznej w przypadku użycia, te będą realizowane jako niejawne koncepcji w kodzie sprzężonego po coś się stało.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-115">For example, if you're just using Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="e0ae2-116">Jednak jeśli właśnie widzisz ten kod może być niemożliwe kodu (ubocznym) jest częścią operacji głównego lub naprawdę jest efektem.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="e0ae2-117">Z drugiej strony w przypadku używania zdarzeń domeny sprawia, że pojęcie jawne i część powszechny języka.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="e0ae2-118">Na przykład w aplikacji eShopOnContainers tworzenie kolejność nie jest chodzi o kolejność; jego aktualizuje lub tworzy nabywców agregacji, na podstawie oryginalnego użytkownika, ponieważ użytkownik nie jest kupujący, dopóki jest zamówienia.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="e0ae2-119">Jeśli używasz zdarzenia domeny, można jawnie express tej zasady domeny, na podstawie języka powszechny zapewniana przez ekspertów domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="e0ae2-120">Zdarzenia domeny są nieco podobne do stylu komunikatów zdarzeń, z jedną istotną różnicą.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="e0ae2-121">Z rzeczywistych komunikatów usługi kolejkowania komunikatów, brokerzy komunikat albo usługi service bus przy użyciu AMPQ wiadomość jest zawsze wysyłane asynchronicznie i przekazywane między procesami i maszyny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="e0ae2-122">Jest to przydatne w przypadku integrowania wielu kontekstów ograniczone, mikrousług lub nawet różnych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="e0ae2-123">Jednak ze zdarzeniami domeny, aby wywołać zdarzenie z operacji domeny, które są aktualnie uruchomione, ale ma wszystkie efekty uboczne w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="e0ae2-124">Zdarzenia domeny i ich efekty uboczne (akcje po wyzwoleniu zarządzanych przez programy obsługi zdarzeń) powinien wystąpić niemal natychmiast, zwykle w procesie, a w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="e0ae2-125">W związku z tym zdarzenia domeny może być synchroniczna lub asynchroniczna.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="e0ae2-126">Zdarzenia integracji, zawsze należy jednak asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="e0ae2-127">Zdarzenia domeny i zdarzeń integracji</span><span class="sxs-lookup"><span data-stu-id="e0ae2-127">Domain events versus integration events</span></span>

<span data-ttu-id="e0ae2-128">Semantycznie, domeny i integracja z zdarzenia to samo: powiadomienia dotyczące coś, które wystąpiły po prostu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="e0ae2-129">Jednak ich realizacji muszą się różnić.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-129">However, their implementation must be different.</span></span> <span data-ttu-id="e0ae2-130">Zdarzenia domeny są tylko komunikatów wypchniętych do dyspozytora zdarzeń domeny, która może być zaimplementowany jako mediatora w pamięci na podstawie kontenera IoC lub innej metody.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="e0ae2-131">Z drugiej strony celem zdarzeń integracji jest propagację zatwierdzone transakcje i aktualizacje podsystemów dodatkowe, czy są one innych mikrousług, ograniczone kontekstów lub nawet zewnętrznych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="e0ae2-132">W związku z tym powinien wystąpić tylko jeśli jednostka pomyślnie jest trwały, od momentu w wielu scenariuszach w przypadku niepowodzenia całą operację skutecznie nigdy nie wystąpiły.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="e0ae2-133">Ponadto i jak już wspomniano, integracja zdarzenia musi być oparta na komunikacji asynchronicznej między wieloma mikrousług (innych ograniczonych kontekstach) lub nawet zewnętrznych systemów/aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="e0ae2-134">W związku z tym interfejs magistrali zdarzenia musi niektórych infrastrukturę, która umożliwia między procesu i rozproszonych komunikacji między usługami potencjalnie zdalnego.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="e0ae2-135">Może opierać się na magistrali usługi komercyjnych, kolejek, udostępnionej bazy danych używane jako skrzynki pocztowej lub inne rozproszonych, a w idealnym przypadku push oparte na system obsługi wiadomości.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="e0ae2-136">Zdarzenia domeny jako preferowany sposób, aby wyzwolić efekty uboczne w wielu wartości zagregowanych w tej samej domenie</span><span class="sxs-lookup"><span data-stu-id="e0ae2-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="e0ae2-137">Jeśli wykonywania polecenia związane z jednego wystąpienia agregacji wymaga dodatkową domenę reguł do uruchomienia na jeden lub więcej dodatkowych wartości zagregowanych powinien projektowania i wdrażania tych efekty uboczne, które będą wyzwalane przez zdarzenia domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="e0ae2-138">Jak pokazano w rysunek 9-14 i jako jedną z najważniejszych zastosowań, zdarzenie domeny powinny być używane do zmiany stanu są propagowane na wiele wartości zagregowanych w ramach tego samego modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="e0ae2-139">**Rysunek 9-14**.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-139">**Figure 9-14**.</span></span> <span data-ttu-id="e0ae2-140">Zdarzenia domeny, aby wymusić spójność wielu wartości zagregowanych w tej samej domenie</span><span class="sxs-lookup"><span data-stu-id="e0ae2-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="e0ae2-141">Na ilustracji, gdy użytkownik inicjuje kolejności OrderStarted domeny zdarzenie jest wyzwalane utworzenia obiektu nabywców w porządkowania mikrousługi, oparte na oryginalne informacje o użytkowniku z mikrousługi tożsamość (z informacji podanych w poleceniu CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="e0ae2-142">Zdarzenie w domenie jest generowany przez agregacji kolejności podczas jego tworzenia w pierwszej kolejności.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="e0ae2-143">Alternatywnie można mieć głównego agregacji subskrybuje zdarzenia generowane przez członków jego agregacji (jednostek podrzędnych).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="e0ae2-144">Każdy obiekt podrzędny OrderItem można na przykład wywołaj zdarzenie, kiedy cenę jest wyższy niż określoną kwotę lub jest zbyt duża wartość elementu produktu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="e0ae2-145">Łączny głównego można otrzymywać te zdarzenia i wykonywanie obliczeń globalnych lub agregacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="e0ae2-146">Ważne jest, aby zrozumieć, oparty na zdarzeniach komunikacji nie jest zaimplementowana bezpośrednio z poziomu agregacji; należy wdrożyć procedury obsługi zdarzeń domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="e0ae2-147">Obsługa zdarzeń domeny jest kwestią aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="e0ae2-148">Warstwa modelu domeny tylko skoncentrować się logika domeny — nie aplikacji infrastruktury, takich jak programy obsługi i trwałości efekt uboczny akcji przy użyciu repozytoriów, rzeczy, które ekspert domeny czy zrozumieć.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="e0ae2-149">W związku z tym na poziomie warstwy aplikacji jest, gdzie powinien mieć obsługi zdarzeń domeny wyzwalają akcje w przypadku zdarzenia domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="e0ae2-150">Zdarzenia domeny można także służyć do wyzwolenia dowolną liczbę akcji aplikacji, a co to jest ważniejsze, musi być otwarty, aby zwiększyć w przyszłości tego numeru w sposób rozdzielonymi.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="e0ae2-151">Na przykład po uruchomieniu kolejności, można opublikować zdarzenie w domenie Propaguj tej informacji do innych wartości zagregowanych, a nawet podnieść akcji aplikacji, takich jak powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="e0ae2-152">Punkt klucza jest otwarte liczbę akcji do wykonania po wystąpieniu zdarzenia domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="e0ae2-153">Po pewnym czasie działania i zasad w domenie i aplikacja będzie rosnąć.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="e0ae2-154">Złożoność lub liczbę akcji efekt uboczny, gdy wydarzy się coś wzrośnie, ale jeśli kodu zostały połączone z "sklejki" (oznacza to po prostu Tworzenie wystąpień obiektów z słowo kluczowe "new" w języku C\#), a następnie za każdym razem, gdy trzeba było dodać nową akcję należy Zmień oryginalnego kodu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="e0ae2-155">Może to spowodować nowych usterek, ponieważ z każdym nowe wymaganie trzeba zmienić oryginalnego przepływu kodu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="e0ae2-156">Taka strategia przed [zasady Open/zamknięty](https://en.wikipedia.org/wiki/Open/closed_principle) z [stałe](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="e0ae2-157">Nie tylko że, oryginalnej klasy, która została organizowanie operacje czy wzrostu i rozwoju, który znajduje się przed [jednej zasady odpowiedzialność (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="e0ae2-158">Z drugiej strony użycie zdarzeń domeny, można utworzyć szczegółowych i rozdzielonymi wdrożenia przez umieszczenie odpowiedzialności za pomocą tej metody:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="e0ae2-159">Wyślij polecenie (na przykład CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="e0ae2-160">Odbierać polecenia programu obsługi poleceń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="e0ae2-161">Wykonaj transakcję pojedynczego agregacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="e0ae2-162">(Opcjonalnie) Wywoływanie zdarzeń domeny dla efekty uboczne (na przykład OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
1.  <span data-ttu-id="e0ae2-163">Obsługi zdarzeń domeny (w ramach bieżącego procesu) wykona Otwórz liczba efekty uboczne w wielu wartości zagregowanych lub działania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-163">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="e0ae2-164">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-164">For example:</span></span>
    -   <span data-ttu-id="e0ae2-165">Sprawdź lub utwórz metody nabywców i płatności.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="e0ae2-166">Tworzenie i wysyłanie zdarzeń powiązanych integracji magistrali zdarzeń do stanów są propagowane na mikrousług lub wyzwalacza zewnętrznego akcji, takich jak wysyłanie wiadomości e-mail kupującemu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="e0ae2-167">Obsługa inne efekty uboczne.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-167">Handle other side effects.</span></span>

<span data-ttu-id="e0ae2-168">Jak pokazano w rysunek 9-15, począwszy od tego samego zdarzenia domeny można obsługiwać wielu akcji związanych z innych wartości zagregowanych w domenie lub aplikacji dodatkowe czynności, które należy wykonać w mikrousług nawiązywania połączenia z zdarzeń integracji i bus zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="e0ae2-169">**Rysunek 9 – 15**.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-169">**Figure 9-15**.</span></span> <span data-ttu-id="e0ae2-170">Obsługa wielu akcji dla domeny</span><span class="sxs-lookup"><span data-stu-id="e0ae2-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="e0ae2-171">Programy obsługi zdarzeń są zwykle w warstwie aplikacji, ponieważ korzystasz z obiektów infrastruktury, takich jak repozytoria lub aplikacji interfejsu API dla zachowania mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="e0ae2-172">W tym sensie procedury obsługi zdarzeń są podobne do programy obsługi poleceń, więc obie należą do warstwy aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="e0ae2-173">Istotną różnicą jest to, że polecenie powinny być przetwarzane tylko raz.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="e0ae2-174">Zdarzenie domeny mogą być przetwarzane zero lub  *n*  razy, ponieważ jeśli może zostać odebrany przez wiele odbiorników lub programów obsługi zdarzeń z różnych cel każdy program obsługi.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="e0ae2-175">Możliwość Otwórz liczby programów obsługi na zdarzenie domeny umożliwia dodanie dużo więcej reguł domeny bez wpływu na bieżącego kodu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="e0ae2-176">Na przykład Implementowanie następujące reguły biznesowej, który ma mieć miejsce prawo po zdarzeniu może być tak proste, jak dodać kilka programów obsługi zdarzeń (lub nawet co najmniej jeden):</span><span class="sxs-lookup"><span data-stu-id="e0ae2-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="e0ae2-177">Suma zakupione w sklepie na dowolną liczbę zamówień, przekroczenia $6000 dotyczą 10% od rabat co nową kolejność i powiadomić klienta o wiadomość e-mail o tym rabatów dla przyszłych zleceń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="e0ae2-178">Implementowanie zdarzeń domeny</span><span class="sxs-lookup"><span data-stu-id="e0ae2-178">Implementing domain events</span></span>

<span data-ttu-id="e0ae2-179">W języku C# zdarzenie w domenie jest po prostu używane do przechowywania danych struktury lub klasy, jak DTO, wszystkie informacje związane z naturę tylko w domenie, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; private set; }
    public int CardTypeId { get; private set; }
    public string CardNumber { get; private set; }
    public string CardSecurityNumber { get; private set; }
    public string CardHolderName { get; private set; }
    public DateTime CardExpiration { get; private set; }
    public Order Order { get; private set; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="e0ae2-180">Jest to zasadniczo klasę, która przechowuje wszystkie dane dotyczące zdarzeń OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="e0ae2-181">W języku powszechny domeny ponieważ zdarzenie jest to przypada w przeszłości, nazwa klasy zdarzenia powinny być reprezentowane jako przeszłego zlecenia, takie jak OrderStartedDomainEvent lub OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="e0ae2-182">To zdarzenie w domenie jest implementowania porządkowania mikrousługi w eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="e0ae2-183">Jak wspomniano wcześniej, ważną cechą zdarzenia jest to, że zdarzenie jest coś, które wystąpiły w przeszłości, nie należy zmieniać.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-183">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="e0ae2-184">W związku z tym musi być klasą niezmienialny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="e0ae2-185">Widać w poprzednim kodzie, którego właściwości są tylko do odczytu z poza obiekt.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-185">You can see in the previous code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="e0ae2-186">Za pomocą konstruktora jest jedynym sposobem, aby zaktualizować obiekt, podczas tworzenia obiektu zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="e0ae2-187">Wywoływanie zdarzeń domeny</span><span class="sxs-lookup"><span data-stu-id="e0ae2-187">Raising domain events</span></span>

<span data-ttu-id="e0ae2-188">Następne pytanie jest jak wywoływanie zdarzeń domeny dzięki osiągnie jego programy obsługi zdarzeń powiązanych.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="e0ae2-189">Można użyć kilku metod.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-189">You can use multiple approaches.</span></span>

<span data-ttu-id="e0ae2-190">Proponowana pierwotnie Udi Dahan (na przykład w kilku związanych z wpisów, takich jak [zdarzenia domeny — potrwać 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) do zarządzania i wywoływanie zdarzeń przy użyciu klasy statycznej.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="e0ae2-191">Może to być klasy statycznej o nazwie DomainEvents, który może wywoływać zdarzeń domeny natychmiast, gdy jest wywoływana, przy użyciu składni, takich jak DomainEvents.Raise (Event myEvent).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="e0ae2-192">Jimmy Bogard zapisano w blogu ([wzmocnienia domenę: zdarzenia domeny](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) zaleca się podejście podobne.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="e0ae2-193">Jednak w przypadku statycznej klasy zdarzenia domeny również wywołuje do obsługi natychmiast.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="e0ae2-194">To utrudnia testowania i debugowania, ponieważ programy obsługi zdarzeń z logiką efekty uboczne są wykonywane bezpośrednio po wywołaniu zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="e0ae2-195">Podczas testowania i debugowania, chcesz skupić się na i po prostu co dzieje się w bieżącej klasy agregacji; Czy chcesz nagle przekierowanie do innych programów obsługi zdarzeń dla efektów ubocznych dotyczących innych wartości zagregowanych lub logiki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="e0ae2-196">Dlatego właśnie usprawnionych inne podejścia, zgodnie z objaśnieniem w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="e0ae2-197">Odroczone podejście do podnoszenia i wywoływanie zdarzeń</span><span class="sxs-lookup"><span data-stu-id="e0ae2-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="e0ae2-198">Zamiast wysyłania do obsługi zdarzeń domeny natychmiast, lepszym rozwiązaniem jest dodanie zdarzenia domeny do kolekcji, a następnie wysłać te zdarzenia domeny *bezpośrednio poprzedzający* lub *prawo*  *Po* zatwierdzania transakcji (podobnie jak w przypadku metody SaveChanges w EF).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="e0ae2-199">(To rozwiązanie zostało opisanego przez Jimmy Bogard w tym wpisie [lepsze wzorzec zdarzenia domeny](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="e0ae2-200">Po wysłaniu zdarzenia domeny prawo przed lub po prawej stronie po zatwierdzania transakcji jest zazwyczaj ważne, ponieważ określa, czy będzie zawierać efekty uboczne w ramach tej samej transakcji lub w innej transakcji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="e0ae2-201">W drugim przypadku należy uwzględniać spójność ostateczna między wiele wartości zagregowanych.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="e0ae2-202">W tym temacie omówiono w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="e0ae2-203">Odroczone podejście jest, jakie eShopOnContainers używa.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="e0ae2-204">Najpierw należy dodać zdarzenia wykonywane w jednostki w kolekcji lub listę zdarzeń na jednostkę.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="e0ae2-205">Tę listę powinny być obiektu jednostki, nawet lepiej części lub klasy podstawowej jednostki, jak pokazano w poniższym przykładzie klasa podstawowa jednostka:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //... 
    private List<INotification> _domainEvents;
    public List<INotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<INotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(INotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="e0ae2-206">Jeśli chcesz zgłosić zdarzenie, możesz po prostu dodaj go do zbierania zdarzeń z kodu w dowolnej metody jednostki głównego agregacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-206">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="e0ae2-207">Poniższy kod, część [kolejność agregate głównego na eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), przedstawiono przykład:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-207">The following code, part of the [Order agregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="e0ae2-208">Zwróć uwagę, że jedynym elementem, który wykonuje metodę AddDomainEvent jest dodawanie zdarzenia do listy.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-208">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="e0ae2-209">Zdarzenie nie jest jeszcze wysłane i bez obsługi zdarzeń jest wywoływany jeszcze.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-209">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="e0ae2-210">Konieczne jest wysłanie zdarzenia później podczas zatwierdzania transakcji do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-210">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="e0ae2-211">Jeśli korzystasz z programu Entity Framework Core, oznacza to metody SaveChanges Twojej DbContext EF, zgodnie z poniższym kodem:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-211">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.        
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="e0ae2-212">O tym kodzie są wysyłania zdarzeń jednostki do ich odpowiednich procedur obsługi.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-212">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="e0ae2-213">Wynik ogólny jest, że użytkownik ma całkowicie niezależna wywoływanie zdarzenia domeny (prosty, Dodaj do listy w pamięci) od wysyła go do programu obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-213">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="e0ae2-214">Ponadto w zależności od tego, jakiego rodzaju dyspozytora używasz, możesz można wysyłania zdarzeń synchronicznie lub asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-214">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="e0ae2-215">Należy pamiętać, tutaj odtwarzania transakcyjne granice wchodzą w znaczący.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-215">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="e0ae2-216">Jeśli urządzenia w pracy i transakcja może obejmować więcej niż jeden agregacji (jak w przypadku EF Core i relacyjnej bazy danych), to również działać.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-216">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="e0ae2-217">Jednak jeśli transakcja nie może obejmować agregacje, takie jak w przypadku używania bazą danych NoSQL, takie jak usługi Azure DocumentDB, musisz zaimplementować dodatkowe kroki w celu osiągnięcia spójności.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-217">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="e0ae2-218">Jest to kolejny powód, dlaczego nieznajomości trwałości nie jest uniwersalny; To zależy od używanego systemu magazynowania.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-218">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="e0ae2-219">Pojedynczej transakcji przez wartości zagregowanych i spójność ostateczna między agregacji</span><span class="sxs-lookup"><span data-stu-id="e0ae2-219">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="e0ae2-220">Pytanie, czy ma być przeprowadzane pojedynczej transakcji przez wartości zagregowanych i zależne spójność ostateczna w tych agregacji jest kontrowersyjna.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-220">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="e0ae2-221">Wielu autorów DDD jak Evans marek i Vaughn Vernon wspierają reguły tego jedna transakcja = co agregacji i w związku z tym argumentowało za spójność ostateczna między agregacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-221">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="e0ae2-222">Na przykład w jego książce *projekt Domain-Driven*, marek Evans mówi, że:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-222">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="e0ae2-223">Reguły obejmującej agreguje zostanie nie powinny być aktualne przez cały czas.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-223">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="e0ae2-224">Za pomocą przetwarzania zdarzeń, przetwarzanie wsadowe lub innych mechanizmów aktualizacji innych zależności można rozpoznawać w niektórych określony czas.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-224">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="e0ae2-225">(strona 128)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-225">(page 128)</span></span>

<span data-ttu-id="e0ae2-226">Vaughn Vernon mówi następujące opcje w [efektywnym projektowaniu agregacji. Część II: Tworzenie agreguje pracy ze sobą](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="e0ae2-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="e0ae2-227">W związku z tym, jeśli na jednym agregacji wystąpienia wymaga, że dodatkowe reguły biznesowe są wykonywane na jeden lub więcej wartości zagregowanych wykonywania polecenia użyj spójność ostateczna \[...\] Brak praktycznym sposobem obsługi spójność ostateczna DDD modelu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="e0ae2-228">Metoda agregacji publikuje zdarzenie domeny, które jest w określonym momencie dostarczone do co najmniej jeden subskrybentów asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="e0ae2-229">Ta decyzja została oparta na obejmującego szczegółowe transakcji zamiast transakcjach obejmujących wiele wartości zagregowanych lub jednostek.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="e0ae2-230">Pomysł jest, że w drugim przypadku liczbę blokad bazy danych zostaną istotne w aplikacji na dużą skalę o potrzebach wysoką skalowalność.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="e0ae2-231">Korzystają z faktu, że wysokiej skalowalne aplikacje wymagają ma błyskawicznych spójności transakcyjnej między Agreguje wiele ułatwia akceptowanie pojęcie spójność ostateczna.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="e0ae2-232">Zmiany Atomic często nie są wymagane przez firmę, a w każdym przypadku jest odpowiedzialny za ekspertów domeny znaczy czy określonych operacji wymagają atomic transakcji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="e0ae2-233">Jeśli operacja zawsze musi atomic transakcji między wiele wartości zagregowanych, może poprosić o czy Twoje agregacji powinna być większa lub nie została poprawnie zaprojektowana.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="e0ae2-234">Jednak inne deweloperzy i architektów, takich jak Jimmy Bogard są zgadzasz się na spanning pojedynczej transakcji między kilka wartości zagregowanych —, ale tylko, gdy te dodatkowe wartości zagregowane są związane z efekty uboczne dla tego samego polecenia oryginalnego.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="e0ae2-235">Na przykład w [lepsze wzorzec zdarzenia domeny](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard mówi, że:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="e0ae2-236">Zwykle ma efekty uboczne zdarzenia domeny występuje w ramach tej samej logicznej transakcji, ale niekoniecznie w tym samym zakresie wywołaniem zdarzenia domeny \[...\] Tuż przed możemy zatwierdzić naszych transakcji, możemy wysyłania naszych zdarzenia do ich odpowiednich programów obsługi.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="e0ae2-237">Jeśli wysyłania prawo zdarzenia domeny *przed* zatwierdzania oryginalnej transakcji, oznacza to, że ma efekty uboczne tych zdarzeń, które mają zostać uwzględnione w tej samej transakcji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="e0ae2-238">Na przykład w przypadku niepowodzenia metody EF DbContext SaveChanges transakcji cofnie wszystkie zmiany, w tym wynik żadnych operacji ubocznym implementowane przez programy obsługi zdarzeń powiązanych domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="e0ae2-239">To jest ponieważ zakres życia DbContext jest domyślnie zdefiniowany jako "zakresu."</span><span class="sxs-lookup"><span data-stu-id="e0ae2-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="e0ae2-240">W związku z tym obiektu DbContext jest współużytkowany przez wiele obiektów repozytorium uruchamianiu w tym samym zakresie lub wykres obiektu.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="e0ae2-241">Pokrywa się to z zakresem HttpRequest podczas opracowywania aplikacji interfejsu API sieci Web lub MVC.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="e0ae2-242">W rzeczywistości obu podejść (pojedynczej Atomowej transakcji i spójność ostateczna) może być prawo.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="e0ae2-243">To naprawdę zależy wymagań domeny lub biznesowych i co ekspertów domeny informujące.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="e0ae2-244">Także od tego, jak skalowalne potrzebna usługa można (bardziej szczegółowego transakcje wpływają mniej względem blokady bazy danych).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="e0ae2-245">I zależy on ile inwestycji podejmowanie dokonanie w kodzie, ponieważ spójność ostateczna wymaga bardziej złożonego kodu w celu wykrycia możliwych niespójności między wartości zagregowanych i trzeba zaimplementować wyrównawczych akcje.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="e0ae2-246">Wziąć pod uwagę, że jeśli można przekazać zmian do oryginalnego agregacji i później, gdy są wysyłane zdarzenia istnieje problem i obsługi zdarzeń nie może zatwierdzić ich efekty uboczne, trzeba będzie niespójności między wartości zagregowanych.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="e0ae2-247">Sposób wyrównawczych akcji zezwalania byłoby przechowywania zdarzeń domeny w tabelach z dodatkowej bazy danych, tak aby były częścią oryginalnej transakcji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="e0ae2-248">Później można mieć przetwarzania wsadowego, która wykrywa niespójności i wyrównawczych akcje uruchamiane przez porównanie listę zdarzeń z bieżącym stanem agregacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="e0ae2-249">Wyrównawczych akcje są częścią złożonych temat, który będzie wymagać szczegółowa analiza z Twojej strony, w tym dyskutować go z biznesowych użytkownika i domena ekspertów.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="e0ae2-250">W każdym przypadku można podejście, które są potrzebne.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="e0ae2-251">Ale początkowej odroczone podejście — wywoływanie zdarzeń przed zatwierdzeniem, więc należy używaj jednej transakcji — jest najprostsza metoda, korzystając z EF Core i relacyjnej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="e0ae2-252">Jest łatwiejsze do wdrożenia i prawidłowy w wielu przypadkach biznesowych.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="e0ae2-253">Jest również używane w porządkowania mikrousługi w eShopOnContainers podejście.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="e0ae2-254">Jednak jak zostanie faktycznie wysyłania tych zdarzeń do ich odpowiednich procedur obsługi?</span><span class="sxs-lookup"><span data-stu-id="e0ae2-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="e0ae2-255">Co to jest \_mediatora obiekt, który zostanie wyświetlony w poprzednim przykładzie?</span><span class="sxs-lookup"><span data-stu-id="e0ae2-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="e0ae2-256">Musi wykonać za pomocą techniki i artefakty, który służy do mapowania zdarzeń i ich obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="e0ae2-257">Dyspozytor zdarzeń domeny: mapowanie ze zdarzeń do obsługi zdarzeń</span><span class="sxs-lookup"><span data-stu-id="e0ae2-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="e0ae2-258">Po będziesz mieć możliwość wysyłania lub opublikować zdarzenia, należy niektórych rodzaj artefaktu, która będzie publikować zdarzenia, dzięki czemu co obsługi pokrewne można pobrać go i przetwarzanie efekty uboczne, na podstawie tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-258">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="e0ae2-259">Jednym z podejść jest rzeczywistym komunikatów systemu lub nawet zdarzeń magistrali, najlepiej jest oparta na magistrali usług, w przeciwieństwie do zdarzeń w pamięci.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="e0ae2-260">Jednakże w pierwszym przypadku rzeczywistych wiadomości może być zbyt obszerne w przypadku przetwarzania zdarzeń domeny, ponieważ wystarczy do przetwarzania tych zdarzeń w ramach tego samego procesu (to znaczy w ramach tej samej warstwie domeny i aplikacji).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="e0ae2-261">Innym sposobem mapowania zdarzeń na wielu obsług zdarzeń jest za pomocą rejestracji typów w kontenerze Inwersja kontroli, dzięki czemu można dynamicznie wnioskować where do wysyłania zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="e0ae2-262">Innymi słowy musisz wiedzieć, co potrzebne do pobrania określonego zdarzenia procedury obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="e0ae2-263">Rysunek 9 – 16 zawiera uproszczone podejście do tego.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="e0ae2-264">**Rysunek 9 – 16**.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-264">**Figure 9-16**.</span></span> <span data-ttu-id="e0ae2-265">Dyspozytor zdarzeń domeny przy użyciu Inwersja kontroli</span><span class="sxs-lookup"><span data-stu-id="e0ae2-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="e0ae2-266">Można tworzyć wszystkie żmudne procesy i artefakty do wdrożenia tego podejścia samodzielnie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="e0ae2-267">Jednak można także używać dostępnych bibliotek, takich jak [MediatR](https://github.com/jbogard/MediatR), który poniżej obejmuje korzysta z kontenera IoC.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoC container.</span></span> <span data-ttu-id="e0ae2-268">W związku z tym bezpośrednio można wstępnie zdefiniowanych interfejsów i metod publikowania wysyłania obiektu mediatora.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="e0ae2-269">W kodzie, najpierw należy zarejestrować typy programów obsługi zdarzeń w Twojej kontenera IoC, jak pokazano w poniższym przykładzie w [eShopOnContainers mikrousługi porządkowanie](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="e0ae2-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="e0ae2-270">Kod najpierw identyfikuje zestaw zawierający obsługi zdarzeń domeny dzięki umieszczeniu zestawu, który zawiera wszelkie obsługi (przy użyciu typeof(ValidateOrAddBuyerAggregateWhenXxxx), ale może wybrano inne obsługi zdarzeń, które można zlokalizować zestawu).</span><span class="sxs-lookup"><span data-stu-id="e0ae2-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="e0ae2-271">Ponieważ obsługi zdarzeń implementować interfejs IAsyncNotificationHandler, kod, a następnie wyszukiwanie tylko dla tych typów i rejestruje obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="e0ae2-272">Subskrybowanie zdarzeń domeny</span><span class="sxs-lookup"><span data-stu-id="e0ae2-272">How to subscribe to domain events</span></span>

<span data-ttu-id="e0ae2-273">W przypadku użycia MediatR, każdy program obsługi zdarzeń musi użyć typ zdarzenia, który znajduje się na parametrze ogólnym interfejsu INotificationHandler, jak widać w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="e0ae2-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="e0ae2-274">Na podstawie relacji między zdarzeń i program obsługi zdarzeń, które mogą zostać uwzględnione subskrypcji, artefaktu MediatR mogą odnaleźć obsługi zdarzeń dla każdego zdarzenia i wyzwolić każdego z tych programów obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="e0ae2-275">Sposób obsługi zdarzeń domeny</span><span class="sxs-lookup"><span data-stu-id="e0ae2-275">How to handle domain events</span></span>

<span data-ttu-id="e0ae2-276">Na koniec programu obsługi zdarzeń zwykle implementuje kod warstwy aplikacji, który używa repozytoria infrastruktury, aby uzyskać wymagane dodatkowe wartości zagregowanych i wykonywanie logiki efekt uboczny domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="e0ae2-277">Następujące [kod obsługi zdarzenia domeny na eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), przedstawiono przykład implementacji.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-277">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;        
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) 
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="e0ae2-278">Poprzedni kod obsługi zdarzenia domeny jest uznawany za kod warstwy aplikacji, ponieważ używa repozytoria infrastruktury zgodnie z opisem w następnej sekcji na warstwie infrastrukturze trwałości.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-278">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="e0ae2-279">Programy obsługi zdarzeń można również użyć innych składników infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="e0ae2-280">Zdarzenia domeny może wygenerować zdarzeń integracji publikowane poza granice mikrousługi</span><span class="sxs-lookup"><span data-stu-id="e0ae2-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="e0ae2-281">Na koniec ważne jest, aby wymienić, że czasami warto zdarzenia są propagowane na wiele mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="e0ae2-282">Która jest traktowana jako zdarzenie integracji i mogą być publikowane za pośrednictwem magistrali zdarzeń z obsługi zdarzeń dowolnej określonej domeny.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="e0ae2-283">Wnioski dotyczące zdarzeń domeny</span><span class="sxs-lookup"><span data-stu-id="e0ae2-283">Conclusions on domain events</span></span>

<span data-ttu-id="e0ae2-284">Jak już wspomniano, należy użyć domeny zdarzeń w celu jawne Implementowanie skutków ubocznych zmiany w swojej domenie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="e0ae2-285">Aby użyć terminologii DDD, za pomocą zdarzeń domeny jawne Implementowanie skutków ubocznych przez jednego lub wielu wartości zagregowanych.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="e0ae2-286">Ponadto i lepszą skalowalność i mniej wpływ na blokady bazy danych użyj spójność ostateczna między zagregowanych zakresu umieszczonych w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="e0ae2-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="e0ae2-287">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="e0ae2-287">Additional resources</span></span>

-   <span data-ttu-id="e0ae2-288">**Małych Gregowi. Co to jest zdarzenie domeny? ** 
     [ *http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="e0ae2-289">**Jan Stenberg. Zdarzenia domeny i spójność ostateczna**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="e0ae2-290">**Jimmy Bogard. Lepsze wzorzec zdarzenia domeny**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="e0ae2-291">**Vaughn Vernon. Łączny skuteczne projektowania część II: Tworzenie agreguje pracy ze sobą**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_artykuły/Vernon\_2011\_ 2. pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="e0ae2-292">**Jimmy Bogard. Wzmocnienie domenę: zdarzenia domeny**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>*</span><span class="sxs-lookup"><span data-stu-id="e0ae2-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="e0ae2-293">**Tony Truong. Zdarzenia domeny wzorca przykład**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="e0ae2-294">**Udi Dahan. Jak utworzyć pełni hermetyzowany modeli domeny**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="e0ae2-295">**Udi Dahan. Zdarzenia domeny — potrwać 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="e0ae2-296">**Udi Dahan. Zdarzenia domeny — Salvation**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="e0ae2-297">**Jan Kronquist. Nie Publikuj zdarzenia domeny, zwraca je! ** 
     [ *https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="e0ae2-298">**Torre de la Cesarowi. Vs zdarzenia domeny. Integracja zdarzeń w architektury DDD i mikrousług**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="e0ae2-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="e0ae2-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
