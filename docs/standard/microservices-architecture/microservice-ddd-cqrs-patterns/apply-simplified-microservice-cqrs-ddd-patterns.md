---
title: Stosowanie uproszczonych wzorców CQRS i DDD w mikrousługach
description: Architektura Mikrousług .NET konteneryzowanych aplikacji .NET | Informacje ogólne relacji między wzorców CQRS i DDD.
ms.date: 10/08/2018
ms.openlocfilehash: bdb3f4a87f48a27a7b46b1297a9237af01ffb6b6
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/15/2019
ms.locfileid: "65639813"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="6be66-103">Zastosuj uproszczone wzorców CQRS i DDD w mikrousługach</span><span class="sxs-lookup"><span data-stu-id="6be66-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="6be66-104">CQRS to wzorzec architektoniczny oddzielający modeli do odczytywania i zapisywania danych.</span><span class="sxs-lookup"><span data-stu-id="6be66-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="6be66-105">Powiązane termin [polecenia zapytania separacji (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) została pierwotnie zdefiniowana przez Bertrand Meyer w książce *konstrukcji oprogramowania zorientowanej na obiekt*.</span><span class="sxs-lookup"><span data-stu-id="6be66-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="6be66-106">Podstawowa koncepcja jest dzieli operacje systemu na dwie kategorie gwałtownie rozdzielonych:</span><span class="sxs-lookup"><span data-stu-id="6be66-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

- <span data-ttu-id="6be66-107">Zapytania.</span><span class="sxs-lookup"><span data-stu-id="6be66-107">Queries.</span></span> <span data-ttu-id="6be66-108">Te zwracają wynik i nie zmieniają swojego stanu systemu i są wolne od efektów ubocznych.</span><span class="sxs-lookup"><span data-stu-id="6be66-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="6be66-109">Polecenia.</span><span class="sxs-lookup"><span data-stu-id="6be66-109">Commands.</span></span> <span data-ttu-id="6be66-110">Te zmiany stanu systemu.</span><span class="sxs-lookup"><span data-stu-id="6be66-110">These change the state of a system.</span></span>

<span data-ttu-id="6be66-111">CQS to prosta koncepcja — to kwestia metod w obrębie tego samego obiektu zapytania lub poleceń.</span><span class="sxs-lookup"><span data-stu-id="6be66-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="6be66-112">Każda metoda zwraca stan lub mutuje stanu, ale nie oba.</span><span class="sxs-lookup"><span data-stu-id="6be66-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="6be66-113">Nawet obiekt wzorzec jednym repozytorium może być zgodne z CQS.</span><span class="sxs-lookup"><span data-stu-id="6be66-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="6be66-114">CQS jest uznawana za podstawowe zasady dla CQRS.</span><span class="sxs-lookup"><span data-stu-id="6be66-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="6be66-115">[Polecenie i podział odpowiedzialności zapytania (CQRS)](https://martinfowler.com/bliki/CQRS.html) została wprowadzona przez Grega Younga i zdecydowanie wspierane przez Udi Dahan i innym osobom.</span><span class="sxs-lookup"><span data-stu-id="6be66-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="6be66-116">Jest ona oparta na zasadzie CQS, mimo że jest bardziej szczegółowe.</span><span class="sxs-lookup"><span data-stu-id="6be66-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="6be66-117">Wzorzec oparty na poleceń i zdarzeń oraz opcjonalnie na wiadomości asynchronicznych mogą zostać uwzględnione.</span><span class="sxs-lookup"><span data-stu-id="6be66-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="6be66-118">W wielu przypadkach CQRS jest powiązana z bardziej zaawansowanych scenariuszy, takich jak o innej fizycznej bazy danych dla operacji odczytu (zapytania) niż do zapisu (aktualizacje).</span><span class="sxs-lookup"><span data-stu-id="6be66-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="6be66-119">Ponadto może zaimplementować bardziej wydzielonego system CQRS [określania źródła zdarzeń (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) aktualizacji bazy danych, więc można będzie tylko przechowywania zdarzeń w modelu domeny zamiast przechowywania danych w bieżącym stanie.</span><span class="sxs-lookup"><span data-stu-id="6be66-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="6be66-120">Jednak nie jest to rozwiązanie używane w tym przewodniku; używamy najprostsza metoda CQRS, który składa się z tylko oddzielenie zapytania w poleceniach.</span><span class="sxs-lookup"><span data-stu-id="6be66-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="6be66-121">Aspekt separacji CQRS jest osiągana przez grupowanie operacje zapytań w jednej warstwie i polecenia w innej warstwie.</span><span class="sxs-lookup"><span data-stu-id="6be66-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="6be66-122">Każda warstwa ma swój własny model danych (należy zauważyć, że mówimy modelu, niekoniecznie innej bazy danych) i został skompilowany przy użyciu własnej kombinację wzorców i technologii.</span><span class="sxs-lookup"><span data-stu-id="6be66-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="6be66-123">Co ważniejsze dwie warstwy mogą być w tej samej warstwie lub mikrousług, tak jak w przykładzie (kolejność mikrousług) używane w tym przewodniku.</span><span class="sxs-lookup"><span data-stu-id="6be66-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="6be66-124">Lub może być wdrażany na różne mikrousługi i realizowania innych procesów, dzięki czemu mogą być zoptymalizowane pod kątem i niezależnie skalowana, bez wywierania wpływu na siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="6be66-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="6be66-125">Podejście CQRS oznacza, że masz dwa obiekty dla operacji odczytu/zapisu, gdzie w innych kontekstach jest jednym.</span><span class="sxs-lookup"><span data-stu-id="6be66-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="6be66-126">Istnieją powody, aby nieznormalizowany odczyty bazy danych, można zapoznać się w bardziej zaawansowanych literaturze CQRS.</span><span class="sxs-lookup"><span data-stu-id="6be66-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="6be66-127">Jednak firma Microsoft nie korzystają z tego podejścia, której celem jest zapewnienie mają większą swobodę w zapytaniach zamiast ograniczanie zapytań za pomocą ograniczenia na podstawie wzorców DDD, takich jak zagregowanych danych.</span><span class="sxs-lookup"><span data-stu-id="6be66-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="6be66-128">Przykładem tego rodzaju usługi jest szeregowania mikrousług z aplikacji referencyjnej w ramach aplikacji eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="6be66-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="6be66-129">Ta usługa implementuje mikrousługi opartych na podejściu CQRS uproszczone.</span><span class="sxs-lookup"><span data-stu-id="6be66-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="6be66-130">Używa pojedynczego źródła danych lub bazy danych, ale dwa modele logiczne oraz wzorców DDD transakcyjnych domeny, jak pokazano w rysunek 7-2.</span><span class="sxs-lookup"><span data-stu-id="6be66-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![Logiczne mikrousług porządkowanie obejmuje swojej porządkowanie bazy danych, która może być lub nie znajduje się w tej samej platformy Docker hosta.](./media/image2.png)

<span data-ttu-id="6be66-133">**Rysunek 7-2**.</span><span class="sxs-lookup"><span data-stu-id="6be66-133">**Figure 7-2**.</span></span> <span data-ttu-id="6be66-134">Uproszczone podejście CQRS i DDD oparte na mikrousługach</span><span class="sxs-lookup"><span data-stu-id="6be66-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="6be66-135">Warstwa aplikacji może być sam interfejs API sieci Web.</span><span class="sxs-lookup"><span data-stu-id="6be66-135">The application layer can be the Web API itself.</span></span> <span data-ttu-id="6be66-136">Aspektu ważnych projektu w tym miejscu jest z poleceń, model domeny i transakcje zgodnie ze wzorcem CQRS czy mikrousług został podzielony, zapytania i modele widoków (szczególnie utworzone dla aplikacji klienckich modele danych).</span><span class="sxs-lookup"><span data-stu-id="6be66-136">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="6be66-137">To podejście zapewnia zapytania niezależnie od ograniczenia i ograniczenia pochodzące z wzorców DDD, odpowiednich tylko dla transakcji i aktualizacjami, zgodnie z opisem w kolejnych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="6be66-137">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="6be66-138">[Poprzednie](index.md)
>[dalej](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="6be66-138">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
