---
title: Projektowanie infrastruktury warstwę trwałości
description: Architektura Mikrousług .NET dla aplikacji .NET konteneryzowanych | Projektowanie infrastruktury warstwę trwałości
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/08/2017
ms.openlocfilehash: 2b15fcaeaa8934caceaeab963123650354abf291
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="76caa-103">Projektowanie infrastruktury warstwę trwałości</span><span class="sxs-lookup"><span data-stu-id="76caa-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="76caa-104">Składniki trwałości danych zapewniają dostęp do danych hostowanej w granicach mikrousługi (to znaczy, że baza danych mikrousługi).</span><span class="sxs-lookup"><span data-stu-id="76caa-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="76caa-105">Zawierają one rzeczywistego wykonania składniki, takie jak repozytoria i [jednostki pracy](https://martinfowler.com/eaaCatalog/unitOfWork.html) klas, takich jak niestandardowe DBContexts EF.</span><span class="sxs-lookup"><span data-stu-id="76caa-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="76caa-106">Wzorzec repozytorium</span><span class="sxs-lookup"><span data-stu-id="76caa-106">The Repository pattern</span></span>

<span data-ttu-id="76caa-107">Repozytoria są klasy lub składniki, które hermetyzują logiki wymagany dostęp do źródeł danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="76caa-108">One scentralizowane typowych funkcji dostępu danych, zapewniając lepsze utrzymanie i oddzielenie infrastruktury lub technologii, które umożliwiają dostęp do bazy danych z warstwy modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="76caa-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="76caa-109">Jeśli używasz ORM, takich jak Entity Framework, kod, który musi być implementowana jest uproszczone dzięki użyciu LINQ i silne wpisywanie.</span><span class="sxs-lookup"><span data-stu-id="76caa-109">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="76caa-110">To umożliwia użytkownikowi skupienie się na logice trwałości danych, a nie dane dostępu instalację.</span><span class="sxs-lookup"><span data-stu-id="76caa-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="76caa-111">Wzorzec repozytorium jest to dobrze udokumentowane sposób pracy ze źródłem danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="76caa-112">W książce [wzorce Enterprise architektura](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), pole Fowler opisuje repozytorium w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="76caa-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="76caa-113">Repozytorium jest wykonywane pośrednika między warstwy modelu domeny i mapowanie danych działa w sposób podobny do zestawu obiektów domeny w pamięci.</span><span class="sxs-lookup"><span data-stu-id="76caa-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="76caa-114">Obiekty klienta deklaratywnie tworzyć kwerendy i wyślij je do przechowywania dla odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="76caa-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="76caa-115">Koncepcyjnie repozytorium hermetyzuje zestaw obiektów przechowywanych w bazie danych i operacje, które można wykonywać na nich, dzięki czemu zbliżonej do warstwę trwałości.</span><span class="sxs-lookup"><span data-stu-id="76caa-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="76caa-116">Repozytoriów obsługuje również celem oddzielanie wyraźnie i w jednym kierunku zależności między domeną pracy i alokacji danych lub mapowania.</span><span class="sxs-lookup"><span data-stu-id="76caa-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="76caa-117">Zdefiniuj jednego repozytorium na agregacji</span><span class="sxs-lookup"><span data-stu-id="76caa-117">Define one repository per aggregate</span></span>

<span data-ttu-id="76caa-118">Dla każdego agregacji lub zbiorczej katalogu głównego należy utworzyć jedną klasę repozytorium.</span><span class="sxs-lookup"><span data-stu-id="76caa-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="76caa-119">Mikrousługi, w oparciu o wzorce projektowe opartych na domenie tylko kanału, które powinny być używane do aktualizowania bazy danych powinien być repozytoriów.</span><span class="sxs-lookup"><span data-stu-id="76caa-119">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="76caa-120">Jest tak, ponieważ mają one relacje jeden do jednego z głównym agregacji, który kontroluje invariants i spójności transakcyjnej wartości zagregowanej.</span><span class="sxs-lookup"><span data-stu-id="76caa-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="76caa-121">Można w bazie danych za pośrednictwem innych kanałów (jak następujące podejście CQRS), ponieważ zapytania nie zmieniaj stanu bazy danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-121">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="76caa-122">Jednak obszaru transakcyjne — aktualizacje — zawsze muszą być kontrolowane przez przechowywania i agregacji katalogów głównych.</span><span class="sxs-lookup"><span data-stu-id="76caa-122">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="76caa-123">Zasadniczo repozytorium służy do wypełniania danych w pamięci, która pochodzi z bazy danych w formularzu jednostek domeny.</span><span class="sxs-lookup"><span data-stu-id="76caa-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="76caa-124">Po zatwierdzeniu jednostek w pamięci, można je zmienić i następnie utrwalone w bazie danych za pomocą transakcji.</span><span class="sxs-lookup"><span data-stu-id="76caa-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="76caa-125">Jak wspomniano wcześniej, jeśli używasz wzorzec architektury CQS/CQRS, początkowej kwerendy będą wykonywane przez zapytania po stronie poza modelu domeny, z zastosowaniem prostych instrukcji SQL przy użyciu Dapper.</span><span class="sxs-lookup"><span data-stu-id="76caa-125">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="76caa-126">Takie podejście jest bardziej elastyczne niż repozytoriów, ponieważ może zapytania i Dołącz do żadnych tabel należy, i tych zapytań nie są ograniczone przez zasady z agregacji.</span><span class="sxs-lookup"><span data-stu-id="76caa-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="76caa-127">Te dane będą przejdź do aplikacji klienta lub warstwy prezentacji.</span><span class="sxs-lookup"><span data-stu-id="76caa-127">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="76caa-128">Jeśli użytkownik wprowadzi zmiany, mają być aktualizowane dane będą pobierane z warstwy aplikacji lub prezentacji klienta do warstwy aplikacji (na przykład usługi interfejsu API sieci Web).</span><span class="sxs-lookup"><span data-stu-id="76caa-128">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="76caa-129">Po otrzymaniu programem obsługi polecenia (z danymi) umożliwia repozytoria pobrać dane, które chcesz zaktualizować z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-129">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="76caa-130">Należy zaktualizować w pamięci z informacjami o przekazany za pomocą poleceń, a następnie dodać lub zaktualizować danych (jednostki domeny) w bazie danych za pomocą transakcji.</span><span class="sxs-lookup"><span data-stu-id="76caa-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="76caa-131">Należy pamiętać, że tego repozytorium tylko jeden powinien być zdefiniowany dla każdego katalogu głównego agregacji, jak pokazano na rysunku 9-17.</span><span class="sxs-lookup"><span data-stu-id="76caa-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="76caa-132">Aby osiągnąć głównego agregacji do zapewniania spójności transakcyjnej między wszystkich obiektów w agregacji, nigdy nie należy tworzyć repozytorium dla każdej tabeli w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="76caa-133">**Rysunek 9-17**.</span><span class="sxs-lookup"><span data-stu-id="76caa-133">**Figure 9-17**.</span></span> <span data-ttu-id="76caa-134">Relacja między repozytoriów, agreguje i tabel bazy danych</span><span class="sxs-lookup"><span data-stu-id="76caa-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="76caa-135">Wymuszanie jeden główny agregacji na repozytorium</span><span class="sxs-lookup"><span data-stu-id="76caa-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="76caa-136">Może być przydatna do zaimplementowania projektu repozytorium w taki sposób, że wymusza reguły, że tylko agregacji elementy główne powinny mieć repozytoriów.</span><span class="sxs-lookup"><span data-stu-id="76caa-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="76caa-137">Można utworzyć typu ogólnego lub podstawowym repozytorium, który ogranicza typ jednostek działa z do upewnij się, że mają one IAggregateRoot interfejsu znacznika.</span><span class="sxs-lookup"><span data-stu-id="76caa-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="76caa-138">W związku z tym każda klasa repozytorium zaimplementowana w warstwie infrastruktury implementuje własne umowy lub interfejsu, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="76caa-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="76caa-139">Każdy interfejs określonych repozytorium implementuje interfejs ogólny IRepository:</span><span class="sxs-lookup"><span data-stu-id="76caa-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="76caa-140">Jednak lepszym sposobem kod wymusić Konwencji czy każdego repozytorium musi być powiązana do pojedynczego agregacji byłoby do zaimplementowania typu ogólnego repozytorium, tak aby zawierała jawne, że używasz repozytorium pod kątem określonej agregacji.</span><span class="sxs-lookup"><span data-stu-id="76caa-140">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="76caa-141">Który można łatwo to zrobić wykonania tego ogólny interfejs podstawowy IRepository, zgodnie z poniższym kodem:</span><span class="sxs-lookup"><span data-stu-id="76caa-141">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="76caa-142">Wzorzec repozytorium ułatwia testowanie aplikacji logiki</span><span class="sxs-lookup"><span data-stu-id="76caa-142">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="76caa-143">Wzorca repozytorium umożliwia łatwe testowanie aplikacji przy użyciu testów jednostkowych.</span><span class="sxs-lookup"><span data-stu-id="76caa-143">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="76caa-144">Należy pamiętać, że testy jednostkowe tylko testowe z kodu, nie infrastruktury tak abstrakcje repozytorium ułatwiają osiągnąć ten cel.</span><span class="sxs-lookup"><span data-stu-id="76caa-144">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="76caa-145">Zgodnie z opisem w sekcji wcześniej, zalecane jest definiowanie i umieszczony interfejsy repozytorium warstwy modelu domeny warstwy aplikacji (na przykład mikrousługi z interfejsu API sieci Web) nie zależy od bezpośrednio na warstwie infrastrukturze gdzie masz zaimplementowano klasy rzeczywiste repozytorium.</span><span class="sxs-lookup"><span data-stu-id="76caa-145">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="76caa-146">W ten sposób i użyciem iniekcji zależności w kontrolerów interfejsu API sieci Web, można zaimplementować zasymulować repozytoriów, które zwracają fałszywych danych zamiast danych z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-146">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="76caa-147">Czy rozdzielonymi podejście pozwala na tworzenie i testów jednostkowych wykonywania, który można przetestować tylko logiki aplikacji bez połączenia z bazą danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-147">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="76caa-148">Połączenia z bazami danych może zakończyć się niepowodzeniem i co ważniejsze, działania setki testy w bazie danych jest zła dwóch powodów.</span><span class="sxs-lookup"><span data-stu-id="76caa-148">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="76caa-149">Po pierwsze może zająć dużo czasu z powodu dużej liczby testów.</span><span class="sxs-lookup"><span data-stu-id="76caa-149">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="76caa-150">Po drugie rekordów bazy danych może i wpływu wyniki testów, dzięki czemu nie są zgodne.</span><span class="sxs-lookup"><span data-stu-id="76caa-150">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="76caa-151">Testowanie bazy danych nie jest testów jednostkowych, ale Testowanie integracji.</span><span class="sxs-lookup"><span data-stu-id="76caa-151">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="76caa-152">Powinien mieć wiele testów jednostkowych szybkiego uruchamiania, ale mniej integracji testów względem bazy danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-152">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="76caa-153">Pod względem separacji dla testów jednostkowych logika działa na jednostkach domeny w pamięci.</span><span class="sxs-lookup"><span data-stu-id="76caa-153">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="76caa-154">Zakłada się, że klasa repozytorium wydał te.</span><span class="sxs-lookup"><span data-stu-id="76caa-154">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="76caa-155">Po logiki modyfikuje jednostek domeny, przyjęto założenie, że klasa repozytorium zapisze je poprawnie.</span><span class="sxs-lookup"><span data-stu-id="76caa-155">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="76caa-156">Należy koniecznie zwrócić uwagę jest tworzenia testów jednostkowych przed modelu domeny i jego logika domeny.</span><span class="sxs-lookup"><span data-stu-id="76caa-156">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="76caa-157">Łączny certyfikaty główne są granice głównego spójności w DDD.</span><span class="sxs-lookup"><span data-stu-id="76caa-157">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="76caa-158">Różnica między wzorca repozytorium i starszych wzorzec klasą (DAL) dostęp do danych</span><span class="sxs-lookup"><span data-stu-id="76caa-158">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="76caa-159">Obiekt dostępu do danych bezpośrednio wykonuje operacje dostępu i trwałości danych z magazynu.</span><span class="sxs-lookup"><span data-stu-id="76caa-159">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="76caa-160">Znaczniki repozytorium danych przy użyciu operacje, które należy wykonać w pamięci jednostkę pracy obiektu (jak EF przy użyciu kontekstu DbContext), ale te aktualizacje nie są wykonywane bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="76caa-160">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="76caa-161">Jednostka pracy jest określana jako jedna transakcja, która obejmuje wiele wstawiania, aktualizowania lub usuwania operacji.</span><span class="sxs-lookup"><span data-stu-id="76caa-161">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="76caa-162">Proste warunków oznacza to, że działania określonego użytkownika (na przykład, rejestracja w witrynie sieci Web), insert, update i delete transakcji są obsługiwane w ramach jednej transakcji.</span><span class="sxs-lookup"><span data-stu-id="76caa-162">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="76caa-163">Jest to bardziej efektywne niż Obsługa wielu transakcji bazy danych w sposób chattier.</span><span class="sxs-lookup"><span data-stu-id="76caa-163">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="76caa-164">Te wiele operacji trwałości są wykonywane później w ramach jednej akcji, gdy polecenia kodu z warstwy aplikacji.</span><span class="sxs-lookup"><span data-stu-id="76caa-164">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="76caa-165">Decyzja o wprowadzanie zmian w pamięci do magazynu rzeczywistej bazy danych jest zwykle oparta na [wzorzec jednostki pracy](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="76caa-165">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="76caa-166">W EF wzorzec jednostki pracy jest implementowany jako DBContext.</span><span class="sxs-lookup"><span data-stu-id="76caa-166">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="76caa-167">W wielu przypadkach ten wzorzec lub sposób stosowania operacje magazynu mogą zwiększyć wydajność aplikacji i zmniejszyć ryzyko wystąpienia niespójności.</span><span class="sxs-lookup"><span data-stu-id="76caa-167">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="76caa-168">Ponadto zmniejsza transakcji blokowania w tabelach bazy danych, ponieważ wszystkie operacje przeznaczone są zatwierdzone w ramach jednej transakcji.</span><span class="sxs-lookup"><span data-stu-id="76caa-168">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="76caa-169">Jest to bardziej skuteczne, w odróżnieniu od wykonywania wielu izolowanego operacji w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="76caa-169">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="76caa-170">W związku z tym wybranego ORM jest w stanie zoptymalizować wykonywania w bazie danych przez grupowanie kilka akcji aktualizacji w ramach tej samej transakcji, w przeciwieństwie do wielu wykonaniami małych i oddzielne transakcji.</span><span class="sxs-lookup"><span data-stu-id="76caa-170">Therefore, the selected ORM is able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="76caa-171">Repozytoria nie będą już wymagane</span><span class="sxs-lookup"><span data-stu-id="76caa-171">Repositories should not be mandatory</span></span>

<span data-ttu-id="76caa-172">Niestandardowe repozytoria przydają się z powodów wymienionych wcześniej, a to podejście do porządkowania mikrousługi w eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="76caa-172">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="76caa-173">Jednak nie jest istotne wzorzec do wdrożenia w projekcie DDD lub nawet ogólnie Programowanie w .NET.</span><span class="sxs-lookup"><span data-stu-id="76caa-173">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="76caa-174">Na przykład Jimmy Bogard, podczas tworzenia pobrania tego przewodnika powiedział następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="76caa-174">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="76caa-175">Prawdopodobnie będzie największych opinii.</span><span class="sxs-lookup"><span data-stu-id="76caa-175">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="76caa-176">Naprawdę nie mam wentylator repozytoriów głównie, ponieważ ukrywają szczegóły ważne podstawowego mechanizmu stanu trwałego.</span><span class="sxs-lookup"><span data-stu-id="76caa-176">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="76caa-177">Jego Dlaczego można przejść do MediatR poleceń, zbyt.</span><span class="sxs-lookup"><span data-stu-id="76caa-177">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="76caa-178">I Użyj pełnych możliwości warstwę trwałości i wypchnąć tego zachowania domeny do mojego agregacji katalogów głównych.</span><span class="sxs-lookup"><span data-stu-id="76caa-178">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="76caa-179">Zazwyczaj nie powinny się mock Moje repozytoria — muszę mieć tej integracji testu z czegoś.</span><span class="sxs-lookup"><span data-stu-id="76caa-179">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="76caa-180">Przechodzenie CQRS oznaczało, że firma Microsoft nie naprawdę potrzebują repozytoria więcej.</span><span class="sxs-lookup"><span data-stu-id="76caa-180">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="76caa-181">Znaleźliśmy repozytoria użyteczne, ale możemy potwierdzić, że nie są istotne dla Twojej DDD w taki sposób, łączny wzorca i model domeny sformatowanego.</span><span class="sxs-lookup"><span data-stu-id="76caa-181">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="76caa-182">W związku z tym Użyj wzorca repozytorium, lub nie, jak widać dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76caa-182">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="76caa-183">Wzorzec specyfikacji</span><span class="sxs-lookup"><span data-stu-id="76caa-183">The Specification pattern</span></span>

<span data-ttu-id="76caa-184">Wzorzec specyfikacji (pełną nazwę byłoby wzorzec specyfikacji zapytania) jest zaprojektowany jako miejsce, w którym można umieścić definicji zapytania opcjonalne, sortowanie i stronicowanie logiki wzorca projektowego Domain-Driven.</span><span class="sxs-lookup"><span data-stu-id="76caa-184">The Specification pattern (its full name would be Query-specification pattern) is a Domain-Driven Design pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="76caa-185">Wzorzec specyfikacja definiuje kwerendę w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="76caa-185">The Specification pattern defines a query in an object.</span></span> <span data-ttu-id="76caa-186">Na przykład aby hermetyzować stronicowane zapytanie, które wyszukuje niektórych produktów, można utworzyć specyfikację PagedProduct, która pobiera niezbędne parametry wejściowe (pageNumber pageSize, filtr, itp.).</span><span class="sxs-lookup"><span data-stu-id="76caa-186">For example, in order to encapsulate a paged query that searches for some products, you can create a PagedProduct specification that takes the necessary input parameters (pageNumber, pageSize, filter, etc.).</span></span> <span data-ttu-id="76caa-187">Następnie w dowolnej metody repozytorium (zazwyczaj przeciążenia List()) będzie akceptować ISpecification i uruchomić zapytanie oczekiwanych na podstawie tej specyfikacji.</span><span class="sxs-lookup"><span data-stu-id="76caa-187">Then, within any Repository method (usually a List() overload) it would accept an ISpecification and run the expected query based on that specification.</span></span>

<span data-ttu-id="76caa-188">Istnieje kilka zalety tego podejścia:</span><span class="sxs-lookup"><span data-stu-id="76caa-188">There are several benefits to this approach:</span></span>

* <span data-ttu-id="76caa-189">Specyfikacja ma nazwę (w przeciwieństwie do grupy wyrażenia LINQ) można omawiać temat.</span><span class="sxs-lookup"><span data-stu-id="76caa-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

* <span data-ttu-id="76caa-190">Specyfikacja można jednostki testowane w izolacji upewnij się, że jest ona odpowiednia.</span><span class="sxs-lookup"><span data-stu-id="76caa-190">The specification can be unit tested in isolation to ensure it is right.</span></span> <span data-ttu-id="76caa-191">Można również łatwo ponownie, jeśli potrzebujesz podobne zachowania.</span><span class="sxs-lookup"><span data-stu-id="76caa-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="76caa-192">Na przykład, w widoku MVC akcji i interfejsu API sieci Web, a także w różnych usług.</span><span class="sxs-lookup"><span data-stu-id="76caa-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

* <span data-ttu-id="76caa-193">Specyfikacja mogą służyć do opisywania kształt danych ma zostać zwrócona, tak, aby zapytania mogą zwracać tylko te dane są wymagane.</span><span class="sxs-lookup"><span data-stu-id="76caa-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="76caa-194">Eliminuje to potrzebę opóźnionego ładowania w aplikacji sieci web (która zazwyczaj nie jest dobrym pomysłem) i pomaga zapewnić implementacje repozytorium z staje się przeładowanie Dysponując tymi szczegółowymi informacjami.</span><span class="sxs-lookup"><span data-stu-id="76caa-194">This eliminates the need for lazy loading in web applications (which is usually not a good idea) and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="76caa-195">Przykładowy ogólny interfejs specyfikacji jest następujący kod z [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span><span class="sxs-lookup"><span data-stu-id="76caa-195">An example of a generic Specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb 
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="76caa-196">W kolejnych sekcjach jest wyjaśniono sposób implementacji wzorca specyfikacji Entity Framework Core 2.0 i jak z niego korzystać z dowolnej klasy repozytorium.</span><span class="sxs-lookup"><span data-stu-id="76caa-196">In the upcoming sections, it is explained how to implement the Specification pattern with Entity Framework Core 2.0 and how to use it from any Repository class.</span></span>

<span data-ttu-id="76caa-197">**Ważna Uwaga:** wzorzec specyfikacji jest starego wzorzec, który można zaimplementować wiele różnych sposobów, jak w następujących zasobach dodatkowych.</span><span class="sxs-lookup"><span data-stu-id="76caa-197">**Important note:** The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="76caa-198">Wzorzec/pomysł warto wiedzieć, niemniej jednak starszej implementacji, które są nie wykorzystaniu nowoczesny język funkcji, takich jak Linq i wyrażenia są starsze metod.</span><span class="sxs-lookup"><span data-stu-id="76caa-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="76caa-199">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="76caa-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="76caa-200">Wzorzec repozytorium</span><span class="sxs-lookup"><span data-stu-id="76caa-200">The Repository pattern</span></span>

-   <span data-ttu-id="76caa-201">**Edward Hieatt i Tomasz mnie. Wzorzec repozytorium.**
    [*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="76caa-201">**Edward Hieatt and Rob Mee. Repository pattern.**
[*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="76caa-202">**Wzorzec repozytorium**
    [*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="76caa-202">**The Repository pattern**
[*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="76caa-203">**Wzorzec repozytorium: Danych abstrakcję funkcji trwałości**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="76caa-203">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="76caa-204">**Evans marek. Projektowanie oparte na domenie: Czoła złożoności serca oprogramowania.**</span><span class="sxs-lookup"><span data-stu-id="76caa-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="76caa-205">(Książki; zawiera omówienie wzorca repozytorium) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="76caa-205">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="76caa-206">Jednostka pracy wzorca</span><span class="sxs-lookup"><span data-stu-id="76caa-206">Unit of Work pattern</span></span>

-   <span data-ttu-id="76caa-207">**Pole Fowler. Jednostka pracy wzorca.**
    [*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="76caa-207">**Martin Fowler. Unit of Work pattern.**
[*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="76caa-208">**Implementowanie repozytorium i jednostki pracy w aplikacji platformy ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="76caa-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="76caa-209">Wzorzec specyfikacji</span><span class="sxs-lookup"><span data-stu-id="76caa-209">The Specification pattern</span></span>

-   <span data-ttu-id="76caa-210">**Wzorzec specyfikacji.**
    [*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="76caa-210">**The Specification pattern.**
[*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span></span>

-   <span data-ttu-id="76caa-211">**Evans, marek (2004). Domena zmiennych projektu. Addison-Wesley. str. 224.**</span><span class="sxs-lookup"><span data-stu-id="76caa-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

-   <span data-ttu-id="76caa-212">**Wymagania. Pole Fowler**
    [*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="76caa-212">**Specifications. Martin Fowler**
[*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="76caa-213">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="76caa-213">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
