---
title: Kwantyfikatory w wyrażeniach regularnych
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a982082611760e4f901c427af25a0a49a4e243a1
ms.sourcegitcommit: 213292dfbb0c37d83f62709959ff55c50af5560d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/25/2018
ms.locfileid: "47087611"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="1ff8a-102">Kwantyfikatory w wyrażeniach regularnych</span><span class="sxs-lookup"><span data-stu-id="1ff8a-102">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="1ff8a-103">Kwantyfikatory Określ, ile wystąpień znak, grupa lub Klasa znaków musi znajdować się w danych wejściowych, aby dopasowanie zakończyło się można znaleźć.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-103">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="1ff8a-104">W poniższej tabeli wymieniono kwantyfikatorów poparte .NET.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-104">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="1ff8a-105">Zachłanne kwantyfikator</span><span class="sxs-lookup"><span data-stu-id="1ff8a-105">Greedy quantifier</span></span>|<span data-ttu-id="1ff8a-106">Kwantyfikatorem opóźniającym</span><span class="sxs-lookup"><span data-stu-id="1ff8a-106">Lazy quantifier</span></span>|<span data-ttu-id="1ff8a-107">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-107">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="1ff8a-108">Dopasowuje zero lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-108">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="1ff8a-109">Dopasowuje jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-109">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="1ff8a-110">Dopasowuje zero lub jeden raz.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-110">Match zero or one time.</span></span>|  
|<span data-ttu-id="1ff8a-111">`{` *N* `}`</span><span class="sxs-lookup"><span data-stu-id="1ff8a-111">`{` *n* `}`</span></span>|<span data-ttu-id="1ff8a-112">`{` *N* `}?`</span><span class="sxs-lookup"><span data-stu-id="1ff8a-112">`{` *n* `}?`</span></span>|<span data-ttu-id="1ff8a-113">Dokładnie *n* razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-113">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="1ff8a-114">`{` *N* `,}`</span><span class="sxs-lookup"><span data-stu-id="1ff8a-114">`{` *n* `,}`</span></span>|<span data-ttu-id="1ff8a-115">`{` *N* `,}?`</span><span class="sxs-lookup"><span data-stu-id="1ff8a-115">`{` *n* `,}?`</span></span>|<span data-ttu-id="1ff8a-116">Zgodne z co najmniej *n* razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-116">Match at least *n* times.</span></span>|  
|<span data-ttu-id="1ff8a-117">`{` *n* `,` *m* `}`</span><span class="sxs-lookup"><span data-stu-id="1ff8a-117">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="1ff8a-118">`{` *n* `,` *m* `}?`</span><span class="sxs-lookup"><span data-stu-id="1ff8a-118">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="1ff8a-119">Dopasowuje od *n* do *m* razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-119">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="1ff8a-120">Ilości `n` i `m` są stałe całkowite.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-120">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="1ff8a-121">Zazwyczaj Kwantyfikatory są zachłanne; mogą spowodować, że aparat wyrażenia regularnego dopasowuje dowolną liczbę wystąpień danego wzorców, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-121">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="1ff8a-122">Dołączanie `?` znak kwantyfikator sprawia, że z opóźnieniem; sprawia, że aparat wyrażeń regularnych dopasować jak najmniejszej liczby wystąpień, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-122">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="1ff8a-123">Aby uzyskać pełny opis różnicy między Kwantyfikatory zachłanne i z opóźnieniem, zobacz sekcję [Greedy i Kwantyfikatory opóźniające](#Greedy) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-123">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1ff8a-124">Zagnieżdżanie kwantyfikatory (na przykład, jako wzorca wyrażenia regularnego `(a*)*` jest) można zwiększyć liczbę porównania, które należy wykonać aparat wyrażeń regularnych, jak funkcja wykładnicza liczbę znaków w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-124">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="1ff8a-125">Aby uzyskać więcej informacji dotyczących tego zachowania i jego obejścia, zobacz [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1ff8a-125">For more information about this behavior and its workarounds, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="1ff8a-126">Kwantyfikatory wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="1ff8a-126">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="1ff8a-127">W poniższych sekcjach wymieniono kwantyfikatorów poparte wyrażeń regularnych programu .NET.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-127">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1ff8a-128">Jeśli \*, +,?, {, i} znaki zostaną napotkane we wzorcu wyrażenia regularnego, aparat wyrażeń regularnych interpretuje je jako Kwantyfikatory lub jej część kwantyfikator konstrukcji, chyba że są one uwzględnione w [klasy znaków](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1ff8a-128">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="1ff8a-129">Interpretowanie je jako znaki literału poza klasą znak, możesz je ucieczki poprzedzając je znakiem kreski ułamkowej odwróconej.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-129">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="1ff8a-130">Na przykład ciąg `\*` w wyrażeniu regularnym wzorzec jest interpretowany jako literał gwiazdki ("\*") znaków.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-130">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="1ff8a-131">Odpowiada Zero lub więcej razy: \*</span><span class="sxs-lookup"><span data-stu-id="1ff8a-131">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="1ff8a-132">`*` Kwantyfikator dopasowuje poprzedni element zero lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-132">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="1ff8a-133">Jest to równoważne `{0,}` kwantyfikator.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-133">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="1ff8a-134">`*` jest zachłanne kwantyfikator, którego opóźnieniem odpowiednik to `*?`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-134">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="1ff8a-135">Poniższy przykład ilustruje tego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-135">The following example illustrates this regular expression.</span></span> <span data-ttu-id="1ff8a-136">Dziewięć cyfr w ciągu wejściowym, pięciu pasuje wzorzec i cztery (`95`, `929`, `9129`, i `9919`) nie obsługują.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-136">Of the nine digits in the input string, five match the pattern and four (`95`, `929`, `9129`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="1ff8a-137">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-137">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-138">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-138">Pattern</span></span>|<span data-ttu-id="1ff8a-139">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-139">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-140">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-140">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="1ff8a-141">Dopasowuje "9", po której następuje zero lub więcej znaków "1".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-141">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="1ff8a-142">Dopasowuje zero lub więcej znaków "9".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-142">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="1ff8a-143">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-143">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="1ff8a-144">Dopasuj jeden lub więcej razy: +</span><span class="sxs-lookup"><span data-stu-id="1ff8a-144">Match One or More Times: +</span></span>  
 <span data-ttu-id="1ff8a-145">`+` Kwantyfikator dopasowuje poprzedzający element jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-145">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="1ff8a-146">Jest to równoważne `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-146">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="1ff8a-147">`+` jest zachłanne kwantyfikator, którego opóźnieniem odpowiednik to `+?`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-147">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="1ff8a-148">Na przykład, wyrażenie regularne `\ban+\w*?\b` próbuje dopasować całe wyrazy, które zaczynają się od litery `a` następuje co najmniej jednego wystąpienia litery `n`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-148">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="1ff8a-149">Poniższy przykład ilustruje tego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-149">The following example illustrates this regular expression.</span></span> <span data-ttu-id="1ff8a-150">Wyrażenie regularne dopasowuje wyrazy `an`, `annual`, `announcement`, i `antique`i poprawnie ulegnie awarii dopasować `autumn` i `all`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-150">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="1ff8a-151">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-151">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-152">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-152">Pattern</span></span>|<span data-ttu-id="1ff8a-153">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-153">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-154">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-154">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="1ff8a-155">Uwzględnij wiadomość "" następuje jeden lub więcej znaków "n".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-155">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="1ff8a-156">Dopasuj znak wyrazu, zero lub więcej razy, ale jak tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-156">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="1ff8a-157">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-157">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="1ff8a-158">Odpowiada Zero lub jeden raz:?</span><span class="sxs-lookup"><span data-stu-id="1ff8a-158">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="1ff8a-159">`?` Kwantyfikator dopasowuje poprzedni element zero lub jeden czas.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-159">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="1ff8a-160">Jest to równoważne `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-160">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="1ff8a-161">`?` jest zachłanne kwantyfikator, którego opóźnieniem odpowiednik to `??`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-161">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="1ff8a-162">Na przykład, wyrażenie regularne `\ban?\b` próbuje dopasować całe wyrazy, które zaczynają się od litery `a` następuje zero lub jeden wystąpień litery `n`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-162">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="1ff8a-163">Innymi słowy, próbuje dopasować słów `a` i `an`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-163">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="1ff8a-164">Poniższy przykład ilustruje tego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-164">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="1ff8a-165">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-165">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-166">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-166">Pattern</span></span>|<span data-ttu-id="1ff8a-167">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-167">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-168">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-168">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="1ff8a-169">Uwzględnij wiadomość "" następuje zero lub jeden znak "n".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-169">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="1ff8a-170">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-170">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="1ff8a-171">Dopasuj dokładnie n razy: {n}</span><span class="sxs-lookup"><span data-stu-id="1ff8a-171">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="1ff8a-172">`{` *n* `}` kwantyfikator dopasowuje poprzedzający element dokładnie *n* razy, gdzie *n* jest dowolną liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-172">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="1ff8a-173">`{`*n* `}` jest zachłanne kwantyfikator, którego opóźnieniem odpowiednik to `{` *n*`}?`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-173">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="1ff8a-174">Na przykład, wyrażenie regularne `\b\d+\,\d{3}\b` próbuje dopasować granicę wyrazu, następuje jeden lub więcej cyfr dziesiętnych następują trzy cyfry dziesiętne, następuje granica wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-174">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="1ff8a-175">Poniższy przykład ilustruje tego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-175">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="1ff8a-176">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-176">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-177">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-177">Pattern</span></span>|<span data-ttu-id="1ff8a-178">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-178">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-179">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-179">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="1ff8a-180">Dopasowanie do co najmniej jednej cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-180">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="1ff8a-181">Dopasowuje znak przecinka.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-181">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="1ff8a-182">Dopasowuje trzy cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-182">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="1ff8a-183">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-183">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="1ff8a-184">Dopasowuje co najmniej n razy: {n,}</span><span class="sxs-lookup"><span data-stu-id="1ff8a-184">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="1ff8a-185">`{` *n* `,}` kwantyfikator dopasowuje poprzedni element co najmniej *n* razy, gdzie *n* jest dowolną liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-185">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="1ff8a-186">`{`*n* `,}` jest zachłanne kwantyfikator, którego opóźnieniem odpowiednik to `{` *n*`,}?`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-186">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="1ff8a-187">Na przykład, wyrażenie regularne `\b\d{2,}\b\D+` próbuje dopasować granicę wyrazu, a następnie co najmniej dwie cyfry, następuje granica wyrazu a znak niebędący cyfrą.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-187">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="1ff8a-188">Poniższy przykład ilustruje tego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-188">The following example illustrates this regular expression.</span></span> <span data-ttu-id="1ff8a-189">Wyrażenie regularne nie powiedzie się dopasować frazę `"7 days"` , ponieważ zawiera ona tylko jedną cyfrę dziesiętną, ale pomyślnie odpowiada zwrotów `"10 weeks and 300 years"`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-189">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="1ff8a-190">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-190">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-191">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-191">Pattern</span></span>|<span data-ttu-id="1ff8a-192">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-192">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-193">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-193">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="1ff8a-194">Dopasowuje co najmniej dwie cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-194">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="1ff8a-195">Dopasowuje granicę wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-195">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="1ff8a-196">Dopasowuje co najmniej jedną cyfrę niebędący cyfrą dziesiętną.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-196">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="1ff8a-197">Dopasowanie między wartościami godziny n i m: {n, m}</span><span class="sxs-lookup"><span data-stu-id="1ff8a-197">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="1ff8a-198">`{` *n*`,`*m* `}` kwantyfikator dopasowuje poprzedni element co najmniej *n* razy, ale nie więcej niż *m*  razy, gdzie *n* i *m* są liczbami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-198">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="1ff8a-199">`{`*n*`,`*m* `}` jest zachłanne kwantyfikator, którego opóźnieniem odpowiednik to `{` *n*`,`*m* `}?`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-199">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="1ff8a-200">W poniższym przykładzie, wyrażenie regularne `(00\s){2,4}` próbuje dopasować między dwoma i czterema wystąpieniami dwóch cyfr, zerowego następuje spacja.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-200">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="1ff8a-201">Należy pamiętać, że końcowa część ciąg wejściowy zawiera ten wzorzec pięciokrotnie zamiast maksymalnie cztery.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-201">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="1ff8a-202">Jednak początkowego fragmentu to substring (maksymalnie miejsce i piąty pary zera) pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-202">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="1ff8a-203">Odpowiada Zero lub więcej razy (dopasowanie z opóźnieniem): \*?</span><span class="sxs-lookup"><span data-stu-id="1ff8a-203">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="1ff8a-204">`*?` Kwantyfikator dopasowuje poprzedni element zero lub więcej razy, ale jak tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-204">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="1ff8a-205">Jest powolne odpowiednik metody zachłannego kwantyfikator `*`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-205">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="1ff8a-206">W poniższym przykładzie, wyrażenie regularne `\b\w*?oo\w*?\b` dopasowuje wszystkie wyrazy, które zawierają ciąg `oo`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-206">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="1ff8a-207">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-207">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-208">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-208">Pattern</span></span>|<span data-ttu-id="1ff8a-209">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-209">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-210">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-210">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="1ff8a-211">Dopasowuje zero lub więcej znaków słowa, ale liczbę znaków, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-211">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="1ff8a-212">Pasuje do ciągu "wprowadzaniem".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-212">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="1ff8a-213">Dopasowuje zero lub więcej znaków słowa, ale liczbę znaków, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-213">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="1ff8a-214">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-214">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="1ff8a-215">Odpowiada jednej lub więcej razy (dopasowanie z opóźnieniem): +?</span><span class="sxs-lookup"><span data-stu-id="1ff8a-215">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="1ff8a-216">`+?` Kwantyfikator dopasowuje poprzedzający element jeden lub więcej razy, ale jak tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-216">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="1ff8a-217">Jest powolne odpowiednik metody zachłannego kwantyfikator `+`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-217">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="1ff8a-218">Na przykład, wyrażenie regularne `\b\w+?\b` dopasowuje jeden lub więcej znaków oddzielonych granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-218">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="1ff8a-219">Poniższy przykład ilustruje tego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-219">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="1ff8a-220">Odpowiada Zero lub jeden raz (dopasowanie z opóźnieniem):?</span><span class="sxs-lookup"><span data-stu-id="1ff8a-220">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="1ff8a-221">`??` Kwantyfikator dopasowuje poprzedni element zero lub jeden podczas, ale jak tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-221">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="1ff8a-222">Jest powolne odpowiednik metody zachłannego kwantyfikator `?`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-222">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="1ff8a-223">Na przykład, wyrażenie regularne `^\s*(System.)??Console.Write(Line)??\(??` próbuje dopasować ciągi "Console.Write —" lub "Elementu Console.WriteLine".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-223">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="1ff8a-224">Ciąg może również zawierać "System".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-224">The string can also include "System."</span></span> <span data-ttu-id="1ff8a-225">przed "Konsoli" który może następować nawias otwierający.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-225">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="1ff8a-226">Ciąg musi być na początku wiersza, chociaż może być poprzedzona znakiem odstępu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-226">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="1ff8a-227">Poniższy przykład ilustruje tego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-227">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="1ff8a-228">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-228">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-229">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-229">Pattern</span></span>|<span data-ttu-id="1ff8a-230">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-230">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="1ff8a-231">Dopasowuje początek strumienia wejściowego.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-231">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="1ff8a-232">Dopasowanie do zera lub większej liczby znaków odstępu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-232">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="1ff8a-233">Dopasowuje zero lub jeden wystąpienie ciągu "System.".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-233">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="1ff8a-234">Pasuje do ciągu "Console.Write —".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-234">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="1ff8a-235">Dopasowuje zero lub jeden wystąpienie ciągu "Wiersz".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-235">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="1ff8a-236">Dopasowanie zera lub jednego wystąpienia nawias otwierający.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-236">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="1ff8a-237">Odpowiada dokładnie n razy (dopasowanie z opóźnieniem): {n}?</span><span class="sxs-lookup"><span data-stu-id="1ff8a-237">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="1ff8a-238">`{` *n* `}?` kwantyfikator dopasowuje poprzedzający element dokładnie `n` razy, gdzie *n* jest dowolną liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-238">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="1ff8a-239">Jest powolne odpowiednik metody zachłannego kwantyfikator `{` *n*`}+`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-239">It is the lazy counterpart of the greedy quantifier `{`*n*`}+`.</span></span>  
  
 <span data-ttu-id="1ff8a-240">W poniższym przykładzie, wyrażenie regularne `\b(\w{3,}?\.){2}?\w{3,}?\b` służy do identyfikowania adres witryny sieci Web.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-240">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="1ff8a-241">Należy pamiętać, jego pasuje do "www.microsoft.com" i "msdn.microsoft.com", ale nie pasuje "MojaWitrynaSieciWeb" lub "mycompany.com".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-241">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="1ff8a-242">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-242">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-243">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-243">Pattern</span></span>|<span data-ttu-id="1ff8a-244">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-244">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-245">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-245">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="1ff8a-246">Dopasowuje co najmniej 3 znaków słowa, ale liczbę znaków, jak to możliwe, następuje kropka lub znak kropki.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-246">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="1ff8a-247">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-247">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="1ff8a-248">Pasuje do wzorca, w pierwszej grupie dwa razy, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-248">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="1ff8a-249">Zakończ dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-249">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="1ff8a-250">Dopasowuje co najmniej n razy (dopasowanie z opóźnieniem): {n,}?</span><span class="sxs-lookup"><span data-stu-id="1ff8a-250">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="1ff8a-251">`{` *n* `,}?` kwantyfikator dopasowuje poprzedni element co najmniej `n` razy, gdzie *n* jest dowolną liczbą całkowitą, ale jak tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-251">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="1ff8a-252">Jest powolne odpowiednik metody zachłannego kwantyfikator `{` *n*`,}`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-252">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="1ff8a-253">Zobacz przykład `{` *n* `}?` kwantyfikator w poprzedniej sekcji do celów informacyjnych.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-253">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="1ff8a-254">Używa wyrażenia regularnego, w tym przykładzie `{` *n* `,}` kwantyfikator próby dopasowania ciągu, który ma co najmniej trzy znaki następuje kropka.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-254">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="1ff8a-255">Zgodność między n i m razy (dopasowanie z opóźnieniem): {n, m}?</span><span class="sxs-lookup"><span data-stu-id="1ff8a-255">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="1ff8a-256">`{` *n*`,`*m* `}?` kwantyfikator dopasowuje poprzedni element między `n` i `m` razy, gdzie *n* i *m* są liczbami całkowitymi, ale jak tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-256">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="1ff8a-257">Jest powolne odpowiednik metody zachłannego kwantyfikator `{` *n*`,`*m*`}`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-257">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="1ff8a-258">W poniższym przykładzie, wyrażenie regularne `\b[A-Z](\w*\s+){1,10}?[.!?]` odpowiada zdania zawierające między wyrazami jednego do dziesięciu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-258">In the following example, the regular expression `\b[A-Z](\w*\s+){1,10}?[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="1ff8a-259">Dopasowuje wszystkie zdania w ciągu wejściowym, z wyjątkiem jedno zdanie, które zawiera wyrazy 18.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-259">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="1ff8a-260">Definicję wzorca wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-260">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-261">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-261">Pattern</span></span>|<span data-ttu-id="1ff8a-262">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-262">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="1ff8a-263">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-263">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="1ff8a-264">Dopasowuje znak wielkie litery od A do Z.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-264">Match an uppercase character from A to Z.</span></span>|  
|`(\w*\s+)`|<span data-ttu-id="1ff8a-265">Dopasowuje zero lub więcej znaków słowa, następuje co najmniej jeden znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-265">Match zero or more word characters, followed by one or more white-space characters.</span></span> <span data-ttu-id="1ff8a-266">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-266">This is the first capture group.</span></span>|  
|`{1,10}?`|<span data-ttu-id="1ff8a-267">Dopasowuje poprzedni wzorzec między 1 a 10 razy, ale tyle razy, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-267">Match the previous pattern between 1 and 10 times, but as few times as possible.</span></span>|  
|`[.!?]`|<span data-ttu-id="1ff8a-268">Pasuje do jednej znaków interpunkcyjnych ".","!", lub "?".</span><span class="sxs-lookup"><span data-stu-id="1ff8a-268">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>   
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="1ff8a-269">Kwantyfikatory zachłanne i z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="1ff8a-269">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="1ff8a-270">Liczba Kwantyfikatory są dwie wersje:</span><span class="sxs-lookup"><span data-stu-id="1ff8a-270">A number of the quantifiers have two versions:</span></span>  
  
-   <span data-ttu-id="1ff8a-271">Zachłanne wersji.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-271">A greedy version.</span></span>  
  
     <span data-ttu-id="1ff8a-272">Zachłanne kwantyfikator próbuje dopasować element dowolną liczbę razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-272">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
-   <span data-ttu-id="1ff8a-273">Wersja niezachłanne (lub z opóźnieniem).</span><span class="sxs-lookup"><span data-stu-id="1ff8a-273">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="1ff8a-274">Niezachłanne kwantyfikator próbuje dopasować element tyle razy, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-274">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="1ff8a-275">Można przekształcić w zachłanne kwantyfikator kwantyfikatorem opóźniającym, po prostu dodając `?`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-275">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="1ff8a-276">Należy wziąć pod uwagę prostych wyrażeń regularnych, które ma na celu prowadzenie cztery ostatnie cyfry ciąg liczb, takie jak numer karty kredytowej.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-276">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="1ff8a-277">Wersja wyrażenia regularnego, który używa `*` jest zachłanne kwantyfikator `\b.*([0-9]{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-277">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="1ff8a-278">Jednak jeśli ciąg zawiera dwie liczby, tego wyrażenia regularnego dopasowuje jak w poniższym przykładzie przedstawiono cztery ostatnie cyfry, druga liczba.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-278">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="1ff8a-279">Wyrażenie regularne nie jest zgodna z liczbą pierwszą, ponieważ `*` kwantyfikator próbuje dopasować poprzedni element tyle razy, jak to możliwe w ciągu całego, a więc znajdzie jego dopasowanie na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-279">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="1ff8a-280">Nie jest żądane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-280">This is not the desired behavior.</span></span> <span data-ttu-id="1ff8a-281">Zamiast tego można użyć `*?`kwantyfikatorem opóźniającym wyodrębniania cyfr z obu numerów, co ilustruje poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-281">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="1ff8a-282">W większości przypadków wyrażeń regularnych bez znaczących Kwantyfikatory zachłanne podręczne i leniwa zwracać ten sam dopasowań.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-282">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="1ff8a-283">Najczęściej zwracają różne wyniki, jeśli są używane za pomocą symbolu wieloznacznego (`.`) metaznak, który dopasowuje dowolny znak.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-283">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="1ff8a-284">Kwantyfikatory i puste dopasowań</span><span class="sxs-lookup"><span data-stu-id="1ff8a-284">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="1ff8a-285">Kwantyfikatory `*`, `+`, i `{` *n*`,`*m* `}` i ich odpowiedniki z opóźnieniem nigdy nie Powtórz po pustą pasuje, gdy minimalna Znaleziono wiele przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-285">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="1ff8a-286">Ta zasada uniemożliwia Kwantyfikatory wprowadzania pętli nieskończonej na pusty Podwyrażenie dopasowuje, jeśli maksymalna liczba możliwych grupy przechwytywania to nieskończoną lub w pobliżu nieskończone.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-286">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="1ff8a-287">Na przykład, poniższy kod przedstawia wynik wywołania <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> metody z wzorcem wyrażenia regularnego `(a?)*`, który dopasowuje zero lub jeden "" znak zero lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-287">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="1ff8a-288">Należy pamiętać, że pojedynczej grupy przechwytywania przechwytuje każdego "" jako także <xref:System.String.Empty?displayProperty=nameWithType>, ale nie ma drugi pusty dopasowania, ponieważ pierwsze dopasowanie pusty powoduje kwantyfikator zatrzymać powtarzające się.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-288">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="1ff8a-289">Aby wyświetlić praktyczne różnicę między grupy przechwytywania, który definiuje co najmniej i maksymalną liczbę oraz danych, który definiuje stałą liczbą przechwytywania, należy wziąć pod uwagę wzorce wyrażeń regularnych `(a\1|(?(1)\1)){0,2}` i `(a\1|(?(1)\1)){2}`.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-289">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="1ff8a-290">Oba wyrażenia regularne składa się z pojedynczej grupy przechwytywania, która jest zdefiniowana, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-290">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="1ff8a-291">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="1ff8a-291">Pattern</span></span>|<span data-ttu-id="1ff8a-292">Opis</span><span class="sxs-lookup"><span data-stu-id="1ff8a-292">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="1ff8a-293">Dopasowanie albo "", oraz wartość pierwszej przechwyconej grupy...</span><span class="sxs-lookup"><span data-stu-id="1ff8a-293">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="1ff8a-294">…</span><span class="sxs-lookup"><span data-stu-id="1ff8a-294">…</span></span> <span data-ttu-id="1ff8a-295">lub sprawdzić, czy zdefiniowano pierwszej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-295">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="1ff8a-296">(Należy pamiętać, że `(?(1)` konstrukcja nie definiuje grupę przechwytywania.)</span><span class="sxs-lookup"><span data-stu-id="1ff8a-296">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="1ff8a-297">Jeśli istnieje pierwszej przechwyconej grupy, odpowiada jego wartości.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-297">If the first captured group exists, match its value.</span></span> <span data-ttu-id="1ff8a-298">Jeśli grupa nie istnieje, grupa będzie odpowiadał <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-298">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="1ff8a-299">Pierwsze wyrażenie regularne próbuje dopasować tego wzorca między i cechujące się dwa razy; druga Strona, dokładnie dwa razy.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-299">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="1ff8a-300">Ponieważ pierwszy wzorzec osiągnie jego minimalną liczbę przechwytywania przy użyciu jego pierwszym przechwytywania <xref:System.String.Empty?displayProperty=nameWithType>, nigdy nie jest powtarzany próbuje dopasować `a\1`; `{0,2}` kwantyfikator umożliwia tylko puste dopasowań w ostatniej iteracji.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-300">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="1ff8a-301">Z kolei drugie wyrażenie regularne jest zgodny "", ponieważ był oceniany `a\1` po raz drugi; wymusza minimalną liczbę iteracji, 2, aparat powtórzyć po dopasowaniu puste.</span><span class="sxs-lookup"><span data-stu-id="1ff8a-301">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="1ff8a-302">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="1ff8a-302">See also</span></span>

- [<span data-ttu-id="1ff8a-303">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="1ff8a-303">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
- [<span data-ttu-id="1ff8a-304">Śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="1ff8a-304">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
