---
title: Kwantyfikatory w wyrażeniach regularnych
description: Dowiedz się więcej na temat kwantyfikatorów wyrażeń regularnych, które określają, ile wystąpień znaku, grupy lub klasy znaków musi być obecne w danych wejściowych do dopasowania.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: 361286b992180e1d7fdf18d88022780cc3aa53fc
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/28/2020
ms.locfileid: "92889429"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="c81f7-103">Kwantyfikatory w wyrażeniach regularnych</span><span class="sxs-lookup"><span data-stu-id="c81f7-103">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="c81f7-104">Kwantyfikatory określają, ile wystąpień znaku, grupy lub klasy znaków musi być obecne w danych wejściowych, aby można było znaleźć dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="c81f7-104">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="c81f7-105">W poniższej tabeli wymieniono Kwantyfikatory obsługiwane przez platformę .NET.</span><span class="sxs-lookup"><span data-stu-id="c81f7-105">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="c81f7-106">Kwantyfikator zachłanne</span><span class="sxs-lookup"><span data-stu-id="c81f7-106">Greedy quantifier</span></span>|<span data-ttu-id="c81f7-107">Kwantyfikator z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="c81f7-107">Lazy quantifier</span></span>|<span data-ttu-id="c81f7-108">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-108">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="c81f7-109">Dopasowanie zero lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-109">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="c81f7-110">Dopasowuje jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-110">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="c81f7-111">Dopasowuje zero lub jeden raz.</span><span class="sxs-lookup"><span data-stu-id="c81f7-111">Match zero or one time.</span></span>|  
|<span data-ttu-id="c81f7-112">`{`*n*`}`</span><span class="sxs-lookup"><span data-stu-id="c81f7-112">`{` *n* `}`</span></span>|<span data-ttu-id="c81f7-113">`{`*n*`}?`</span><span class="sxs-lookup"><span data-stu-id="c81f7-113">`{` *n* `}?`</span></span>|<span data-ttu-id="c81f7-114">Dopasowuje dokładnie *n* razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-114">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="c81f7-115">`{`*n*`,}`</span><span class="sxs-lookup"><span data-stu-id="c81f7-115">`{` *n* `,}`</span></span>|<span data-ttu-id="c81f7-116">`{`*n*`,}?`</span><span class="sxs-lookup"><span data-stu-id="c81f7-116">`{` *n* `,}?`</span></span>|<span data-ttu-id="c81f7-117">Dopasowanie co najmniej *n* razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-117">Match at least *n* times.</span></span>|  
|<span data-ttu-id="c81f7-118">`{`*n* `,` *m*`}`</span><span class="sxs-lookup"><span data-stu-id="c81f7-118">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="c81f7-119">`{`*n* `,` *m*`}?`</span><span class="sxs-lookup"><span data-stu-id="c81f7-119">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="c81f7-120">Dopasowuje od *n* do *m* razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-120">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="c81f7-121">Ilości `n` i `m` są stałymi całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="c81f7-121">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="c81f7-122">Zwykle Kwantyfikatory są zachłanne; powodują, że aparat wyrażeń regularnych dopasowuje jako wiele wystąpień określonych wzorców, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-122">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="c81f7-123">Dołączanie `?` znaku do kwantyfikatora powoduje jego odłączenie. powoduje to, że aparat wyrażeń regularnych dopasowuje jak najmniejszej liczby wystąpień.</span><span class="sxs-lookup"><span data-stu-id="c81f7-123">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="c81f7-124">Aby uzyskać pełny opis różnicy między zachłanne i kwantyfikatorami z opóźnieniem, zobacz sekcję [zachłanne i Kwantyfikatory z opóźnieniem](#Greedy) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-124">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="c81f7-125">Zagnieżdżanie kwantyfikatorów (na przykład jako wzorca wyrażenia regularnego `(a*)*` ) może zwiększyć liczbę porównań, które musi wykonać aparat wyrażeń regularnych, jako funkcję wykładniczą liczby znaków w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="c81f7-125">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="c81f7-126">Aby uzyskać więcej informacji na temat tego zachowania i jego obejść [, zobacz](backtracking-in-regular-expressions.md)wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="c81f7-126">For more information about this behavior and its workarounds, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="c81f7-127">Kwantyfikatory wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="c81f7-127">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="c81f7-128">W poniższych sekcjach wymieniono Kwantyfikatory obsługiwane przez wyrażenia regularne programu .NET.</span><span class="sxs-lookup"><span data-stu-id="c81f7-128">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c81f7-129">Jeśli znaki \*, +,?, {i} są napotkane we wzorcu wyrażenia regularnego, aparat wyrażeń regularnych interpretuje je jako Kwantyfikatory lub część konstrukcji kwantyfikatora, chyba że znajdują się w [klasie znaków](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c81f7-129">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="c81f7-130">Aby interpretować te jako znaki literału poza klasą znaków, należy je zmienić, poprzedzając je ukośnikiem odwrotnym.</span><span class="sxs-lookup"><span data-stu-id="c81f7-130">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="c81f7-131">Na przykład ciąg `\*` we wzorcu wyrażenia regularnego jest interpretowany jako literał gwiazdki (" \* ").</span><span class="sxs-lookup"><span data-stu-id="c81f7-131">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="c81f7-132">Dopasowanie zero lub więcej razy: \*</span><span class="sxs-lookup"><span data-stu-id="c81f7-132">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="c81f7-133">`*`Kwantyfikator dopasowuje poprzedni element zero lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-133">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="c81f7-134">Jest to odpowiednik `{0,}` kwantyfikatora.</span><span class="sxs-lookup"><span data-stu-id="c81f7-134">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="c81f7-135">`*` jest kwantyfikatorem zachłanne, którego odpowiednikiem opóźnionym jest `*?` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-135">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="c81f7-136">Poniższy przykład ilustruje to wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-136">The following example illustrates this regular expression.</span></span> <span data-ttu-id="c81f7-137">Dziewięciu grup cyfr w ciągu wejściowym, pięć dopasowuje wzorzec i cztery ( `95` ,,, `929` `9219` i) nie `9919` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-137">Of the nine digit groups in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="c81f7-138">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-138">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-139">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-139">Pattern</span></span>|<span data-ttu-id="c81f7-140">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-140">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-141">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-141">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="c81f7-142">Dopasowuje "9", po którym następuje zero lub więcej znaków "1".</span><span class="sxs-lookup"><span data-stu-id="c81f7-142">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="c81f7-143">Dopasowuje zero lub więcej znaków "9".</span><span class="sxs-lookup"><span data-stu-id="c81f7-143">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="c81f7-144">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-144">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="c81f7-145">Dopasowuje jeden lub więcej razy: +</span><span class="sxs-lookup"><span data-stu-id="c81f7-145">Match One or More Times: +</span></span>  
 <span data-ttu-id="c81f7-146">`+`Kwantyfikator dopasowuje poprzedni element jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-146">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="c81f7-147">Jest równoważne `{1,}` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-147">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="c81f7-148">`+` jest kwantyfikatorem zachłanne, którego odpowiednikiem opóźnionym jest `+?` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-148">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="c81f7-149">Na przykład wyrażenie regularne `\ban+\w*?\b` próbuje dopasować całe wyrazy, które zaczynają się od litery, `a` po którym następuje co najmniej jedno wystąpienie litery `n` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-149">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="c81f7-150">Poniższy przykład ilustruje to wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-150">The following example illustrates this regular expression.</span></span> <span data-ttu-id="c81f7-151">Wyrażenie regularne pasuje do wyrazów `an` , `annual` , `announcement` , i `antique` i prawidłowo nie można dopasować `autumn` i `all` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-151">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="c81f7-152">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-152">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-153">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-153">Pattern</span></span>|<span data-ttu-id="c81f7-154">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-154">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-155">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-155">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="c81f7-156">Dopasowuje "a", po którym następuje co najmniej jeden znak "n".</span><span class="sxs-lookup"><span data-stu-id="c81f7-156">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="c81f7-157">Dopasowuje znak słowa zero lub więcej razy, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-157">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="c81f7-158">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-158">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="c81f7-159">Dopasowanie zero lub jeden raz:?</span><span class="sxs-lookup"><span data-stu-id="c81f7-159">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="c81f7-160">`?`Kwantyfikator dopasowuje poprzedni element zero lub jeden raz.</span><span class="sxs-lookup"><span data-stu-id="c81f7-160">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="c81f7-161">Jest równoważne `{0,1}` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-161">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="c81f7-162">`?` jest kwantyfikatorem zachłanne, którego odpowiednikiem opóźnionym jest `??` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-162">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="c81f7-163">Na przykład wyrażenie regularne `\ban?\b` próbuje dopasować całe wyrazy rozpoczynające się od litery, `a` po której następuje zero lub jedno wystąpienie litery `n` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-163">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="c81f7-164">Innymi słowy, próbuje dopasować słowa `a` i `an` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-164">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="c81f7-165">Poniższy przykład ilustruje to wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-165">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="c81f7-166">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-166">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-167">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-167">Pattern</span></span>|<span data-ttu-id="c81f7-168">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-168">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-169">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-169">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="c81f7-170">Dopasowuje "a", po którym następuje zero lub jeden znak "n".</span><span class="sxs-lookup"><span data-stu-id="c81f7-170">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="c81f7-171">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-171">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="c81f7-172">Dopasuj dokładnie n razy: {n}</span><span class="sxs-lookup"><span data-stu-id="c81f7-172">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="c81f7-173">Kwantyfikator `{` *n* `}` dopasowuje poprzedni element dokładnie *n* razy, gdzie *n* jest dowolną liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="c81f7-173">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="c81f7-174">`{`*n* `}` jest kwantyfikatorem zachłanne, którego odpowiednik opóźniony to `{` *n* `}?` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-174">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="c81f7-175">Na przykład wyrażenie regularne `\b\d+\,\d{3}\b` próbuje dopasować granicę wyrazu, po którym następuje co najmniej jedna cyfra dziesiętna, po której następują trzy cyfry dziesiętne, a po niej granicę wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-175">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="c81f7-176">Poniższy przykład ilustruje to wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-176">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="c81f7-177">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-177">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-178">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-178">Pattern</span></span>|<span data-ttu-id="c81f7-179">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-179">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-180">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-180">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="c81f7-181">Dopasowanie do co najmniej jednej cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="c81f7-181">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="c81f7-182">Dopasowuje znak przecinka.</span><span class="sxs-lookup"><span data-stu-id="c81f7-182">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="c81f7-183">Dopasowuje trzy cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-183">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="c81f7-184">Kończy na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-184">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="c81f7-185">Dopasowuje co najmniej n razy: {n,}</span><span class="sxs-lookup"><span data-stu-id="c81f7-185">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="c81f7-186">Kwantyfikator `{` *n* `,}` dopasowuje poprzedni element co najmniej *n* razy, gdzie *n* jest dowolną liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="c81f7-186">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="c81f7-187">`{`*n* `,}` jest kwantyfikatorem zachłanne, którego odpowiednik opóźniony to `{` *n* `,}?` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-187">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="c81f7-188">Na przykład wyrażenie regularne `\b\d{2,}\b\D+` próbuje dopasować granicę wyrazu, po którym następuje co najmniej dwie cyfry, po których następuje granica słowa i znak niebędący cyfrą.</span><span class="sxs-lookup"><span data-stu-id="c81f7-188">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="c81f7-189">Poniższy przykład ilustruje to wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-189">The following example illustrates this regular expression.</span></span> <span data-ttu-id="c81f7-190">Wyrażenie regularne nie pasuje do frazy `"7 days"` , ponieważ zawiera tylko jedną cyfrę dziesiętną, ale pomyślnie dopasowuje frazy `"10 weeks and 300 years"` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-190">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="c81f7-191">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-191">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-192">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-192">Pattern</span></span>|<span data-ttu-id="c81f7-193">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-193">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-194">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-194">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="c81f7-195">Dopasowuje co najmniej dwie cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-195">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="c81f7-196">Dopasowuje granicę wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-196">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="c81f7-197">Dopasowuje co najmniej jedną cyfrę niedziesiętną.</span><span class="sxs-lookup"><span data-stu-id="c81f7-197">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="c81f7-198">Dopasowanie między n i m razy: {n, m}</span><span class="sxs-lookup"><span data-stu-id="c81f7-198">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="c81f7-199">Kwantyfikator `{` *n* `,` *m* `}` dopasowuje poprzedni element co najmniej *n* razy, ale nie więcej niż *m* razy, gdzie *n* i *m* są liczbami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="c81f7-199">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="c81f7-200">`{`*n* `,` *m* `}` jest kwantyfikatorem zachłanne, którego odpowiednik opóźniony to `{` *n* `,` *m* `}?` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-200">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="c81f7-201">W poniższym przykładzie wyrażenie regularne `(00\s){2,4}` próbuje dopasować między dwoma i czterema wystąpieniami dwóch cyfr zerowych, po których występuje spacja.</span><span class="sxs-lookup"><span data-stu-id="c81f7-201">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="c81f7-202">Należy zauważyć, że końcowa część ciągu wejściowego zawiera ten wzorzec pięć razy, a nie maksymalnie cztery.</span><span class="sxs-lookup"><span data-stu-id="c81f7-202">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="c81f7-203">Jednak tylko początkowa część tego podciągu (do spacji i piąta para zer) pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="c81f7-203">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="c81f7-204">Dopasowuje zero lub więcej razy (dopasowanie z opóźnieniem): \*?</span><span class="sxs-lookup"><span data-stu-id="c81f7-204">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="c81f7-205">`*?`Kwantyfikator dopasowuje poprzedzający element zero lub więcej razy, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-205">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="c81f7-206">Jest odpowiednikiem z opóźnieniem kwantyfikatora zachłanne `*` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-206">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="c81f7-207">W poniższym przykładzie wyrażenie regularne `\b\w*?oo\w*?\b` dopasowuje wszystkie wyrazy, które zawierają ciąg `oo` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-207">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="c81f7-208">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-208">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-209">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-209">Pattern</span></span>|<span data-ttu-id="c81f7-210">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-210">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-211">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-211">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="c81f7-212">Dopasowuje zero lub więcej znaków słowa, ale jak najmniejsza liczba znaków.</span><span class="sxs-lookup"><span data-stu-id="c81f7-212">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="c81f7-213">Dopasowuje ciąg "oo".</span><span class="sxs-lookup"><span data-stu-id="c81f7-213">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="c81f7-214">Dopasowuje zero lub więcej znaków słowa, ale jak najmniejsza liczba znaków.</span><span class="sxs-lookup"><span data-stu-id="c81f7-214">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="c81f7-215">Koniec na granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="c81f7-215">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="c81f7-216">Dopasowuje jeden lub więcej razy (dopasowanie z opóźnieniem): +?</span><span class="sxs-lookup"><span data-stu-id="c81f7-216">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="c81f7-217">`+?`Kwantyfikator dopasowuje poprzedni element jeden lub więcej razy, ale jak najszybciej, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-217">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="c81f7-218">Jest odpowiednikiem z opóźnieniem kwantyfikatora zachłanne `+` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-218">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="c81f7-219">Na przykład wyrażenie regularne `\b\w+?\b` dopasowuje co najmniej jeden znak rozdzielony przez granice słowa.</span><span class="sxs-lookup"><span data-stu-id="c81f7-219">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="c81f7-220">Poniższy przykład ilustruje to wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-220">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="c81f7-221">Dopasowuje zero lub jeden raz (dopasowanie z opóźnieniem):?</span><span class="sxs-lookup"><span data-stu-id="c81f7-221">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="c81f7-222">`??`Kwantyfikator dopasowuje poprzedni element zero lub jeden raz, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-222">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="c81f7-223">Jest odpowiednikiem z opóźnieniem kwantyfikatora zachłanne `?` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-223">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="c81f7-224">Na przykład wyrażenie regularne `^\s*(System.)??Console.Write(Line)??\(??` próbuje dopasować ciągi "Console. Write" lub "Console. WriteLine".</span><span class="sxs-lookup"><span data-stu-id="c81f7-224">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="c81f7-225">Ciąg może również zawierać "system".</span><span class="sxs-lookup"><span data-stu-id="c81f7-225">The string can also include "System."</span></span> <span data-ttu-id="c81f7-226">przed "konsolą" i może następować nawias otwierający.</span><span class="sxs-lookup"><span data-stu-id="c81f7-226">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="c81f7-227">Ciąg musi znajdować się na początku wiersza, chociaż może być poprzedzony białym znakiem.</span><span class="sxs-lookup"><span data-stu-id="c81f7-227">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="c81f7-228">Poniższy przykład ilustruje to wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-228">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="c81f7-229">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-229">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-230">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-230">Pattern</span></span>|<span data-ttu-id="c81f7-231">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-231">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="c81f7-232">Dopasowuje początek strumienia wejściowego.</span><span class="sxs-lookup"><span data-stu-id="c81f7-232">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="c81f7-233">Dopasowanie do zera lub większej liczby znaków odstępu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-233">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="c81f7-234">Dopasowanie do zera lub jednego wystąpienia ciągu "System.".</span><span class="sxs-lookup"><span data-stu-id="c81f7-234">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="c81f7-235">Dopasowuje ciąg "Console. Write".</span><span class="sxs-lookup"><span data-stu-id="c81f7-235">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="c81f7-236">Dopasowanie do zera lub jednego wystąpienia ciągu "line".</span><span class="sxs-lookup"><span data-stu-id="c81f7-236">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="c81f7-237">Dopasowanie do zera lub jednego wystąpienia nawiasu otwierającego.</span><span class="sxs-lookup"><span data-stu-id="c81f7-237">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="c81f7-238">Dopasuj dokładnie n razy (dopasowanie z opóźnieniem): {n}?</span><span class="sxs-lookup"><span data-stu-id="c81f7-238">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="c81f7-239">Kwantyfikator `{` *n* `}?` dopasowuje poprzedni element dokładnie `n` raz, gdzie *n* jest dowolną liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="c81f7-239">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="c81f7-240">Jest to odpowiednik opóźniony kwantyfikatora zachłanne `{` *n* `}` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-240">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="c81f7-241">W poniższym przykładzie wyrażenie regularne `\b(\w{3,}?\.){2}?\w{3,}?\b` służy do identyfikowania adresu witryny sieci Web.</span><span class="sxs-lookup"><span data-stu-id="c81f7-241">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="c81f7-242">Należy pamiętać, że pasuje do "www.microsoft.com" i "msdn.microsoft.com", ale nie pasuje do "Website" lub "mycompany.com".</span><span class="sxs-lookup"><span data-stu-id="c81f7-242">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="c81f7-243">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-243">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-244">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-244">Pattern</span></span>|<span data-ttu-id="c81f7-245">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-245">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-246">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-246">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="c81f7-247">Dopasowuje co najmniej 3 znaki słowa, ale jak najmniejsza liczba znaków, po których następuje znak kropki lub kropki.</span><span class="sxs-lookup"><span data-stu-id="c81f7-247">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="c81f7-248">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="c81f7-248">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="c81f7-249">Dopasowuje wzorzec w pierwszej grupie dwa razy, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-249">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="c81f7-250">Zakończ dopasowanie na granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="c81f7-250">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="c81f7-251">Dopasowuje co najmniej n razy (dopasowanie z opóźnieniem): {n,}?</span><span class="sxs-lookup"><span data-stu-id="c81f7-251">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="c81f7-252">Kwantyfikator `{` *n* `,}?` dopasowuje poprzedni element co najmniej `n` razy, gdzie *n* jest dowolną liczbą całkowitą, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-252">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="c81f7-253">Jest to odpowiednik opóźniony kwantyfikatora zachłanne `{` *n* `,}` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-253">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="c81f7-254">Zobacz przykład dla `{` *n* `}?` kwantyfikatora n w poprzedniej sekcji dla ilustracji.</span><span class="sxs-lookup"><span data-stu-id="c81f7-254">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="c81f7-255">Wyrażenie regularne w tym przykładzie używa `{` *n* `,}` kwantyfikatora n, aby dopasować ciąg, który zawiera co najmniej trzy znaki, po których następuje kropka.</span><span class="sxs-lookup"><span data-stu-id="c81f7-255">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="c81f7-256">Dopasowanie między n i m razy (dopasowanie z opóźnieniem): {n, m}?</span><span class="sxs-lookup"><span data-stu-id="c81f7-256">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="c81f7-257">Kwantyfikator `{` *n* `,` *m* `}?` dopasowuje poprzedni element między `n` i `m` Times, gdzie *n* i *m* są liczbami całkowitymi, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-257">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="c81f7-258">Jest to odpowiednik opóźniony kwantyfikatora zachłanne `{` *n* `,` *m* `}` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-258">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="c81f7-259">W poniższym przykładzie wyrażenie regularne `\b[A-Z](\w*?\s*?){1,10}[.!?]` dopasowuje zdania zawierające od jednego do dziesięciu wyrazów.</span><span class="sxs-lookup"><span data-stu-id="c81f7-259">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="c81f7-260">Dopasowuje wszystkie zdania w ciągu wejściowym z wyjątkiem jednego zdania zawierającego 18 wyrazów.</span><span class="sxs-lookup"><span data-stu-id="c81f7-260">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="c81f7-261">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-261">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-262">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-262">Pattern</span></span>|<span data-ttu-id="c81f7-263">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-263">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c81f7-264">Rozpoczyna na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-264">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="c81f7-265">Dopasowuje wielką literę od A do Z.</span><span class="sxs-lookup"><span data-stu-id="c81f7-265">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="c81f7-266">Dopasowuje zero lub więcej znaków wyrazu, po którym następuje co najmniej jeden znak odstępu, ale tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-266">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="c81f7-267">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="c81f7-267">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="c81f7-268">Dopasowuje poprzedni wzorzec od 1 do 10 razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-268">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="c81f7-269">Dopasowuje dowolny z tych znaków interpunkcyjnych ".", "!" lub "?".</span><span class="sxs-lookup"><span data-stu-id="c81f7-269">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="c81f7-270">Zachłanne i Kwantyfikatory z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="c81f7-270">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="c81f7-271">Liczba kwantyfikatorów ma dwie wersje:</span><span class="sxs-lookup"><span data-stu-id="c81f7-271">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="c81f7-272">Wersja zachłanne.</span><span class="sxs-lookup"><span data-stu-id="c81f7-272">A greedy version.</span></span>  
  
     <span data-ttu-id="c81f7-273">Kwantyfikator zachłanne próbuje dopasować element tyle razy, ile to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-273">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="c81f7-274">Wersja innego typu niż zachłanne (lub z opóźnieniem).</span><span class="sxs-lookup"><span data-stu-id="c81f7-274">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="c81f7-275">Kwantyfikator inny niż zachłanne próbuje dopasować element jak najprawdopodobniej, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c81f7-275">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="c81f7-276">Kwantyfikator zachłanne można przekształcić w kwantyfikator z opóźnieniem, po prostu dodając `?` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-276">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="c81f7-277">Rozważ proste wyrażenie regularne, które jest przeznaczone do wyodrębnienia ostatnich czterech cyfr z ciągu cyfr, takich jak numer karty kredytowej.</span><span class="sxs-lookup"><span data-stu-id="c81f7-277">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="c81f7-278">Wersja wyrażenia regularnego, która używa `*` kwantyfikatora zachłanne `\b.*([0-9]{4})\b` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-278">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="c81f7-279">Jeśli jednak ciąg zawiera dwie liczby, to wyrażenie regularne dopasowuje się do ostatnich czterech cyfr w drugiej liczbie, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="c81f7-279">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="c81f7-280">Wyrażenie regularne nie dopasowuje pierwszej liczby `*` , ponieważ kwantyfikator próbuje dopasować poprzedni element tyle razy, ile jest to możliwe w całym ciągu, i dlatego znalazł jego dopasowanie na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-280">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="c81f7-281">Nie jest to pożądane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="c81f7-281">This is not the desired behavior.</span></span> <span data-ttu-id="c81f7-282">Zamiast tego można użyć `*?` kwantyfikatora opóźnionego do wyodrębnienia cyfr z obu liczb, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="c81f7-282">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="c81f7-283">W większości przypadków wyrażenia regularne z zachłanne i kwantyfikatorów opóźnionych zwracają te same dopasowania.</span><span class="sxs-lookup"><span data-stu-id="c81f7-283">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="c81f7-284">Najczęściej zwracają różne wyniki, gdy są używane z symbolem wieloznacznym ( `.` ), który dopasowuje dowolny znak.</span><span class="sxs-lookup"><span data-stu-id="c81f7-284">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="c81f7-285">Kwantyfikatory i puste dopasowania</span><span class="sxs-lookup"><span data-stu-id="c81f7-285">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="c81f7-286">Kwantyfikatory `*` , `+` i `{` *n* `,` *m* `}` i ich odpowiedniki z opóźnieniem nigdy nie powtarzają się po pustym dopasowaniu po znalezieniu minimalnej liczby przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="c81f7-286">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="c81f7-287">Ta reguła uniemożliwia kwantyfikatorom wprowadzanie nieskończonych pętli przy pustym podrażeniu, gdy maksymalna liczba możliwych przechwycenia grupy jest nieskończona lub bliska nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c81f7-287">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="c81f7-288">Na przykład poniższy kod ilustruje wynik wywołania <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> metody z wzorcem wyrażenia regularnego `(a?)*` , który odpowiada zero lub jeden znak "a" zero lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-288">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="c81f7-289">Należy zauważyć, że pojedyncza grupa przechwytywania przechwytuje każdy "a" <xref:System.String.Empty?displayProperty=nameWithType> , ale nie ma drugiego pustego dopasowania, ponieważ pierwsze puste dopasowanie powoduje, że kwantyfikator przestanie powtarzać się.</span><span class="sxs-lookup"><span data-stu-id="c81f7-289">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="c81f7-290">Aby zobaczyć praktyczną różnicę między grupą przechwytywania, która definiuje minimalną i maksymalną liczbę przechwytywania, i jedną, która definiuje stałą liczbę przechwytywania, należy wziąć pod uwagę wzorce wyrażeń regularnych `(a\1|(?(1)\1)){0,2}` i `(a\1|(?(1)\1)){2}` .</span><span class="sxs-lookup"><span data-stu-id="c81f7-290">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="c81f7-291">Oba wyrażenia regularne składają się z pojedynczej grupy przechwytywania, która jest zdefiniowana w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="c81f7-291">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c81f7-292">Wzorce</span><span class="sxs-lookup"><span data-stu-id="c81f7-292">Pattern</span></span>|<span data-ttu-id="c81f7-293">Opis</span><span class="sxs-lookup"><span data-stu-id="c81f7-293">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="c81f7-294">Dopasowuje wartość "a" wraz z wartością pierwszej przechwyconej grupy...</span><span class="sxs-lookup"><span data-stu-id="c81f7-294">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="c81f7-295">…</span><span class="sxs-lookup"><span data-stu-id="c81f7-295">…</span></span> <span data-ttu-id="c81f7-296">lub Przetestuj, czy pierwsza przechwycona Grupa została zdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="c81f7-296">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="c81f7-297">(Należy zauważyć, że `(?(1)` konstrukcja nie definiuje grupy przechwytywania).</span><span class="sxs-lookup"><span data-stu-id="c81f7-297">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="c81f7-298">W przypadku istnienia pierwszej przechwyconej grupy Dopasuj jej wartość.</span><span class="sxs-lookup"><span data-stu-id="c81f7-298">If the first captured group exists, match its value.</span></span> <span data-ttu-id="c81f7-299">Jeśli grupa nie istnieje, grupa będzie pasować <xref:System.String.Empty?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c81f7-299">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="c81f7-300">Pierwsze wyrażenie regularne próbuje dopasować ten wzorzec od zera do dwóch razy; sekunda, dokładnie dwa razy.</span><span class="sxs-lookup"><span data-stu-id="c81f7-300">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="c81f7-301">Ze względu na to, że pierwszy wzorzec osiągnie swoją minimalną liczbę przechwytywania z pierwszym przechwyceniem <xref:System.String.Empty?displayProperty=nameWithType> , nigdy nie powtarza się, aby spróbować dopasować `a\1` ; `{0,2}` kwantyfikator dopuszcza tylko puste dopasowania w ostatniej iteracji.</span><span class="sxs-lookup"><span data-stu-id="c81f7-301">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="c81f7-302">Natomiast drugie wyrażenie regularne dopasowuje się do "a", ponieważ szacuje `a\1` drugi raz; minimalna liczba iteracji, 2, wymusza powtarzanie aparatu po pustym dopasowaniu.</span><span class="sxs-lookup"><span data-stu-id="c81f7-302">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="c81f7-303">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="c81f7-303">See also</span></span>

- [<span data-ttu-id="c81f7-304">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="c81f7-304">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="c81f7-305">Nawracanie</span><span class="sxs-lookup"><span data-stu-id="c81f7-305">Backtracking</span></span>](backtracking-in-regular-expressions.md)
