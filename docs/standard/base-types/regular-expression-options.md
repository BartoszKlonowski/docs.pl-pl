---
title: "Opcje wyrażeń regularnych"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, options
- constructs, options
- .NET Framework regular expressions, options
- inline option constructs
- options parameter
ms.assetid: c82dc689-7e82-4767-a18d-cd24ce5f05e9
caps.latest.revision: "27"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: a4a1513840d17f2e7b02acf821b5032eaac6e6fc
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/23/2017
---
# <a name="regular-expression-options"></a><span data-ttu-id="33d44-102">Opcje wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="33d44-102">Regular Expression Options</span></span>
<a name="Top"></a><span data-ttu-id="33d44-103">Domyślnie porównanie ciągu wejściowego z dowolnego literał znaków wzorzec wyrażenia regularnego jest rozróżniana wielkość liter, biały znak w wzorzec wyrażenia regularnego jest interpretowana jako literał znaków odstępu i grup przechwytywania w wyrażeniu regularnym są także niejawnie jako jawnie nazwane.</span><span class="sxs-lookup"><span data-stu-id="33d44-103">By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</span></span> <span data-ttu-id="33d44-104">Te i kilka innych aspektów domyślnego zachowania wyrażeń regularnych można zmieniać, określając opcje wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="33d44-104">You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</span></span> <span data-ttu-id="33d44-105">Te opcje, które są wymienione w poniższej tabeli, może być wbudowany dołączone jako część wzorzec wyrażenia regularnego lub mogą być dostarczane do <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> konstruktora klasy lub statyczna wzorca zgodną metodę jako <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> wartości wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="33d44-105">These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static pattern matching method as a <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumeration value.</span></span>  
  
|<span data-ttu-id="33d44-106">Element członkowski RegexOptions</span><span class="sxs-lookup"><span data-stu-id="33d44-106">RegexOptions member</span></span>|<span data-ttu-id="33d44-107">Znak w tekście</span><span class="sxs-lookup"><span data-stu-id="33d44-107">Inline character</span></span>|<span data-ttu-id="33d44-108">Efekt</span><span class="sxs-lookup"><span data-stu-id="33d44-108">Effect</span></span>|  
|-------------------------|----------------------|------------|  
|<xref:System.Text.RegularExpressions.RegexOptions.None>|<span data-ttu-id="33d44-109">Niedostępne</span><span class="sxs-lookup"><span data-stu-id="33d44-109">Not available</span></span>|<span data-ttu-id="33d44-110">Zachowanie domyślne.</span><span class="sxs-lookup"><span data-stu-id="33d44-110">Use default behavior.</span></span> <span data-ttu-id="33d44-111">Aby uzyskać więcej informacji, zobacz [domyślne opcje](#Default).</span><span class="sxs-lookup"><span data-stu-id="33d44-111">For more information, see [Default Options](#Default).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>|`i`|<span data-ttu-id="33d44-112">Używa dopasowywania bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="33d44-112">Use case-insensitive matching.</span></span> <span data-ttu-id="33d44-113">Aby uzyskać więcej informacji, zobacz [dopasowania Case-Insensitive](#Case).</span><span class="sxs-lookup"><span data-stu-id="33d44-113">For more information, see [Case-Insensitive Matching](#Case).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.Multiline>|`m`|<span data-ttu-id="33d44-114">Użyj trybu wielowierszowego, gdzie `^` i `$` odpowiada początek i koniec każdego wiersza (zamiast początek i koniec ciągu wejściowego).</span><span class="sxs-lookup"><span data-stu-id="33d44-114">Use multiline mode, where `^` and `$` match the beginning and end of each line (instead of the beginning and end of the input string).</span></span> <span data-ttu-id="33d44-115">Aby uzyskać więcej informacji, zobacz [trybu wielowierszowego](#Multiline).</span><span class="sxs-lookup"><span data-stu-id="33d44-115">For more information, see [Multiline Mode](#Multiline).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.Singleline>|`s`|<span data-ttu-id="33d44-116">Użyj trybu jeden wiersz, jeśli kropki (.) odpowiada każdego znaku (zamiast każdego znaku z wyjątkiem `\n`).</span><span class="sxs-lookup"><span data-stu-id="33d44-116">Use single-line mode, where the period (.) matches every character (instead of every character except `\n`).</span></span> <span data-ttu-id="33d44-117">Aby uzyskać więcej informacji, zobacz [tryb Singleline](#Singleline).</span><span class="sxs-lookup"><span data-stu-id="33d44-117">For more information, see [Singleline Mode](#Singleline).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>|`n`|<span data-ttu-id="33d44-118">Nie przechwytuje nienazwanych grup.</span><span class="sxs-lookup"><span data-stu-id="33d44-118">Do not capture unnamed groups.</span></span> <span data-ttu-id="33d44-119">Jedyne prawidłowe przechwytywane są jawnie o nazwie lub numerowane grup formularza `(?<` *nazwa* `>` *Podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="33d44-119">The only valid captures are explicitly named or numbered groups of the form `(?<`*name*`>` *subexpression*`)`.</span></span> <span data-ttu-id="33d44-120">Aby uzyskać więcej informacji, zobacz [tylko jawne przechwytuje](#Explicit).</span><span class="sxs-lookup"><span data-stu-id="33d44-120">For more information, see [Explicit Captures Only](#Explicit).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.Compiled>|<span data-ttu-id="33d44-121">Niedostępne</span><span class="sxs-lookup"><span data-stu-id="33d44-121">Not available</span></span>|<span data-ttu-id="33d44-122">Kompiluj wyrażenia regularnego do zestawu.</span><span class="sxs-lookup"><span data-stu-id="33d44-122">Compile the regular expression to an assembly.</span></span> <span data-ttu-id="33d44-123">Aby uzyskać więcej informacji, zobacz [skompilować wyrażeń regularnych](#Compiled).</span><span class="sxs-lookup"><span data-stu-id="33d44-123">For more information, see [Compiled Regular Expressions](#Compiled).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace>|`x`|<span data-ttu-id="33d44-124">Wyklucz niezmienionym znaczeniu biały znak z wzorcem i Włącz komentarze po znaku numeru (`#`).</span><span class="sxs-lookup"><span data-stu-id="33d44-124">Exclude unescaped white space from the pattern, and enable comments after a number sign (`#`).</span></span> <span data-ttu-id="33d44-125">Aby uzyskać więcej informacji, zobacz [Ignoruj odstępem](#Whitespace).</span><span class="sxs-lookup"><span data-stu-id="33d44-125">For more information, see [Ignore Whitespace](#Whitespace).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>|<span data-ttu-id="33d44-126">Niedostępne</span><span class="sxs-lookup"><span data-stu-id="33d44-126">Not available</span></span>|<span data-ttu-id="33d44-127">Umożliwia zmianę kierunku wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="33d44-127">Change the search direction.</span></span> <span data-ttu-id="33d44-128">Wyszukiwanie Przenosi od prawej do lewej strony zamiast od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="33d44-128">Search moves from right to left instead of from left to right.</span></span> <span data-ttu-id="33d44-129">Aby uzyskać więcej informacji, zobacz [tryb od prawej do lewej](#RightToLeft).</span><span class="sxs-lookup"><span data-stu-id="33d44-129">For more information, see [Right-to-Left Mode](#RightToLeft).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.ECMAScript>|<span data-ttu-id="33d44-130">Niedostępne</span><span class="sxs-lookup"><span data-stu-id="33d44-130">Not available</span></span>|<span data-ttu-id="33d44-131">Włącz zgodne ECMAScript zachowanie dla wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="33d44-131">Enable ECMAScript-compliant behavior for the expression.</span></span> <span data-ttu-id="33d44-132">Aby uzyskać więcej informacji, zobacz [zachowanie dopasowania ECMAScript](#ECMAScript).</span><span class="sxs-lookup"><span data-stu-id="33d44-132">For more information, see [ECMAScript Matching Behavior](#ECMAScript).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant>|<span data-ttu-id="33d44-133">Niedostępne</span><span class="sxs-lookup"><span data-stu-id="33d44-133">Not available</span></span>|<span data-ttu-id="33d44-134">Ignoruj kultury różnice w języku.</span><span class="sxs-lookup"><span data-stu-id="33d44-134">Ignore cultural differences in language.</span></span> <span data-ttu-id="33d44-135">Aby uzyskać więcej informacji, zobacz [porównanie przy użyciu Niezmienna kultura](#Invariant).</span><span class="sxs-lookup"><span data-stu-id="33d44-135">For more information, see [Comparison Using the Invariant Culture](#Invariant).</span></span>|  
  
## <a name="specifying-the-options"></a><span data-ttu-id="33d44-136">Określenie opcji</span><span class="sxs-lookup"><span data-stu-id="33d44-136">Specifying the Options</span></span>  
 <span data-ttu-id="33d44-137">Opcje wyrażeń regularnych można określić w jednym z trzech sposobów:</span><span class="sxs-lookup"><span data-stu-id="33d44-137">You can specify options for regular expressions in one of three ways:</span></span>  
  
-   <span data-ttu-id="33d44-138">W `options` parametr <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> konstruktora klasy lub statyczna (`Shared` w języku Visual Basic) dopasowywanie do wzorca metody, takich jak <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33d44-138">In the `options` parameter of a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static (`Shared` in Visual Basic) pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="33d44-139">`options` Parametr jest bitowe połączenie lub <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> wyliczyć wartości.</span><span class="sxs-lookup"><span data-stu-id="33d44-139">The `options` parameter is a bitwise OR combination of <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumerated values.</span></span>  
  
     <span data-ttu-id="33d44-140">Jeśli opcje są dostarczane do <xref:System.Text.RegularExpressions.Regex> wystąpienia przy użyciu `options` parametru konstruktora klasy, dostępne są następujące opcje są przypisane do <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="33d44-140">When options are supplied to a <xref:System.Text.RegularExpressions.Regex> instance by using the `options` parameter of a class constructor, the options are are assigned to the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="33d44-141">Jednak <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> właściwości nie są widoczne opcje wbudowany w samej wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-141">However, the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property does not reflect inline options in the regular expression pattern itself.</span></span>  
  
     <span data-ttu-id="33d44-142">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="33d44-142">The following example provides an illustration.</span></span> <span data-ttu-id="33d44-143">Używa `options` parametr <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody Włącz dopasowywanie bez uwzględniania wielkości liter i Ignoruj wzorzec biały znak podczas identyfikowania wyrazy, które zaczynają się od litery "d".</span><span class="sxs-lookup"><span data-stu-id="33d44-143">It uses the `options` parameter of the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)]
     [!code-vb[Conceptual.Regex.Language.Options#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)]  
  
-   <span data-ttu-id="33d44-144">Stosując opcje wbudowany w wzorzec wyrażenia regularnego przy użyciu składni `(?imnsx-imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="33d44-144">By applying inline options in a regular expression pattern with the syntax `(?imnsx-imnsx)`.</span></span> <span data-ttu-id="33d44-145">Opcja ma zastosowanie do wzorca od punktu zdefiniowania opcji, albo na końcu wzorca lub do punktu, jaką opcję jest niezdefiniowana przez inną opcją wbudowanego.</span><span class="sxs-lookup"><span data-stu-id="33d44-145">The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</span></span> <span data-ttu-id="33d44-146">Należy pamiętać, że <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> właściwość <xref:System.Text.RegularExpressions.Regex> wystąpienia nie odzwierciedla tych opcji w tekście.</span><span class="sxs-lookup"><span data-stu-id="33d44-146">Note that the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property of a <xref:System.Text.RegularExpressions.Regex> instance does not reflect these inline options.</span></span> <span data-ttu-id="33d44-147">Aby uzyskać więcej informacji, zobacz [różne konstrukcje](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="33d44-147">For more information, see the [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md) topic.</span></span>  
  
     <span data-ttu-id="33d44-148">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="33d44-148">The following example provides an illustration.</span></span> <span data-ttu-id="33d44-149">Używa wbudowanego opcji Włącz dopasowywanie bez uwzględniania wielkości liter i Ignoruj wzorzec biały znak podczas identyfikowania wyrazy, które zaczynają się od litery "d".</span><span class="sxs-lookup"><span data-stu-id="33d44-149">It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)]
     [!code-vb[Conceptual.Regex.Language.Options#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)]  
  
-   <span data-ttu-id="33d44-150">Stosując opcje wbudowanego w konkretnym grupowania skonstruować we wzorcu wyrażenia regularnego przy użyciu składni `(?imnsx-imnsx:` *Podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="33d44-150">By applying inline options in a particular grouping construct in a regular expression pattern with the syntax `(?imnsx-imnsx:`*subexpression*`)`.</span></span> <span data-ttu-id="33d44-151">Nie znaku przed zestaw opcji włącza zestaw; znak minus przed zestaw opcji wyłącza zestawu.</span><span class="sxs-lookup"><span data-stu-id="33d44-151">No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</span></span> <span data-ttu-id="33d44-152">(`?` jest stałą część składni konstrukcji języka, który jest wymagany, czy opcje są włączone lub wyłączone.) Opcja ma zastosowanie tylko do tej grupy.</span><span class="sxs-lookup"><span data-stu-id="33d44-152">(`?` is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</span></span> <span data-ttu-id="33d44-153">Aby uzyskać więcej informacji, zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="33d44-153">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
     <span data-ttu-id="33d44-154">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="33d44-154">The following example provides an illustration.</span></span> <span data-ttu-id="33d44-155">Używa wbudowanego opcje w konstrukcji grupowania Włącz dopasowywanie bez uwzględniania wielkości liter i Ignoruj wzorzec biały znak podczas identyfikowania wyrazy, które zaczynają się od litery "d".</span><span class="sxs-lookup"><span data-stu-id="33d44-155">It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
     [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
 <span data-ttu-id="33d44-156">Jeśli opcje są określony w tekście, znak minus (`-`) przed opcji lub zestaw opcji powoduje wyłączenie tych opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-156">If options are specified inline, a minus sign (`-`) before an option or set of options turns off those options.</span></span> <span data-ttu-id="33d44-157">Na przykład utworzyć wbudowanej `(?ix-ms)` włącza <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opcje i wyłącza <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> opcje.</span><span class="sxs-lookup"><span data-stu-id="33d44-157">For example, the inline construct `(?ix-ms)` turns on the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> options and turns off the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="33d44-158">Wszystkie opcje wyrażeń regularnych są domyślnie wyłączone.</span><span class="sxs-lookup"><span data-stu-id="33d44-158">All regular expression options are turned off by default.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33d44-159">Jeśli określone opcje wyrażeń regularnych w `options` określić parametr konflikt wywołanie konstruktora lub metody przy użyciu opcji wbudowanego wzorzec wyrażenia regularnego, opcje w tekście są wykorzystywane.</span><span class="sxs-lookup"><span data-stu-id="33d44-159">If the regular expression options specified in the `options` parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</span></span>  
  
 <span data-ttu-id="33d44-160">Można ustawić następujące pięć opcje wyrażeń regularnych zarówno parametr opcje i wbudowany:</span><span class="sxs-lookup"><span data-stu-id="33d44-160">The following five regular expression options can be set both with the options parameter and inline:</span></span>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>  
  
 <span data-ttu-id="33d44-161">Następujące pięć opcje wyrażeń regularnych można ustawić za pomocą `options` parametru, ale nie można ustawić wbudowany:</span><span class="sxs-lookup"><span data-stu-id="33d44-161">The following five regular expression options can be set using the `options` parameter but cannot be set inline:</span></span>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>  
  
## <a name="determining-the-options"></a><span data-ttu-id="33d44-162">Określanie opcji</span><span class="sxs-lookup"><span data-stu-id="33d44-162">Determining the Options</span></span>  
 <span data-ttu-id="33d44-163">Można określić, które opcje zostały dostarczone do <xref:System.Text.RegularExpressions.Regex> obiektu, gdy utworzono wystąpienie pobierając wartość tylko do odczytu <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="33d44-163">You can determine which options were provided to a <xref:System.Text.RegularExpressions.Regex> object when it was instantiated by retrieving the value of the read-only <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="33d44-164">Ta właściwość jest szczególnie przydatne podczas określania opcje, które są zdefiniowane wyrażenie regularne skompilowanych utworzone przez <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="33d44-164">This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="33d44-165">Aby przetestować obecność każda opcja, z wyjątkiem <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, w trakcie operacji i wartością <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> właściwości i <xref:System.Text.RegularExpressions.RegexOptions> wartość, w której jesteś zainteresowany.</span><span class="sxs-lookup"><span data-stu-id="33d44-165">To test for the presence of any option except <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, perform an AND operation with the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property and the <xref:System.Text.RegularExpressions.RegexOptions> value in which you are interested.</span></span> <span data-ttu-id="33d44-166">Następnie sprawdzić, czy wynik jest równe, który <xref:System.Text.RegularExpressions.RegexOptions> wartość.</span><span class="sxs-lookup"><span data-stu-id="33d44-166">Then test whether the result equals that <xref:System.Text.RegularExpressions.RegexOptions> value.</span></span> <span data-ttu-id="33d44-167">Następujące testy przykład czy <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> została ustawiona opcja.</span><span class="sxs-lookup"><span data-stu-id="33d44-167">The following example tests whether the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option has been set.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)]
 [!code-vb[Conceptual.Regex.Language.Options#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)]  
  
 <span data-ttu-id="33d44-168">Aby przetestować <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, określić, czy wartość <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> właściwości jest równa <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="33d44-168">To test for <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine whether the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property is equal to <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, as the following example illustrates.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)]
 [!code-vb[Conceptual.Regex.Language.Options#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)]  
  
 <span data-ttu-id="33d44-169">W poniższych sekcjach wymieniono opcje obsługiwane przez wyrażenie regularne programu .NET.</span><span class="sxs-lookup"><span data-stu-id="33d44-169">The following sections list the options supported by regular expression in .NET.</span></span>  
  
<a name="Default"></a>   
## <a name="default-options"></a><span data-ttu-id="33d44-170">Domyślne opcje</span><span class="sxs-lookup"><span data-stu-id="33d44-170">Default Options</span></span>  
 <span data-ttu-id="33d44-171"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> Opcja wskazuje, że nie określono żadnych opcji i aparat wyrażeń regularnych używa jego zachowanie domyślne.</span><span class="sxs-lookup"><span data-stu-id="33d44-171">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</span></span> <span data-ttu-id="33d44-172">Obejmuje to następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="33d44-172">This includes the following:</span></span>  
  
-   <span data-ttu-id="33d44-173">Wzorzec jest interpretowany jako canonical zamiast ECMAScript wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-173">The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</span></span>  
  
-   <span data-ttu-id="33d44-174">Wzorzec wyrażenia regularnego jest takie samo w ciągu wejściowym od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="33d44-174">The regular expression pattern is matched in the input string from left to right.</span></span>  
  
-   <span data-ttu-id="33d44-175">Porównania jest rozróżniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="33d44-175">Comparisons are case-sensitive.</span></span>  
  
-   <span data-ttu-id="33d44-176">`^` i `$` elementy języka zgodny początek i koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="33d44-176">The `^` and `$` language elements match the beginning and end of the input string.</span></span>  
  
-   <span data-ttu-id="33d44-177">`.` Każdego znaku z wyjątkiem pasującego elementu języka `\n`.</span><span class="sxs-lookup"><span data-stu-id="33d44-177">The `.` language element matches every character except `\n`.</span></span>  
  
-   <span data-ttu-id="33d44-178">Żadnego odstępu w wzorzec wyrażenia regularnego jest interpretowany jako literału spacją.</span><span class="sxs-lookup"><span data-stu-id="33d44-178">Any white space in a regular expression pattern is interpreted as a literal space character.</span></span>  
  
-   <span data-ttu-id="33d44-179">Konwencje bieżącej kultury są używane podczas porównywania wzorca do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="33d44-179">The conventions of the current culture are used when comparing the pattern to the input string.</span></span>  
  
-   <span data-ttu-id="33d44-180">Niejawne, jak również jawne są przechwytywania grupy wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-180">Capturing groups in the regular expression pattern are implicit as well as explicit.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33d44-181"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> Opcja nie ma żadnych wbudowanego równoważne.</span><span class="sxs-lookup"><span data-stu-id="33d44-181">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option has no inline equivalent.</span></span> <span data-ttu-id="33d44-182">Opcje wyrażeń regularnych są stosowane wbudowanego, domyślne zachowanie został przywrócony na podstawie opcji przez opcję wyłączając jedną z opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-182">When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</span></span> <span data-ttu-id="33d44-183">Na przykład `(?i)` włącza porównania bez uwzględniania wielkości liter, a `(?-i)` przywraca domyślne porównania z uwzględnieniem wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="33d44-183">For example, `(?i)` turns on case-insensitive comparison, and `(?-i)` restores the default case-sensitive comparison.</span></span>  
  
 <span data-ttu-id="33d44-184">Ponieważ <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> opcji reprezentuje domyślne zachowanie aparat wyrażeń regularnych, został on rzadko jawnie określony w wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="33d44-184">Because the <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</span></span> <span data-ttu-id="33d44-185">Konstruktora lub metody statycznej dopasowywanie do wzorca bez `options` parametru jest wywoływana zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="33d44-185">A constructor or static pattern-matching method without an `options` parameter is called instead.</span></span>  
  
 [<span data-ttu-id="33d44-186">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-186">Back to Top</span></span>](#Top)  
  
<a name="Case"></a>   
## <a name="case-insensitive-matching"></a><span data-ttu-id="33d44-187">Dopasowywanie bez uwzględniania wielkości liter</span><span class="sxs-lookup"><span data-stu-id="33d44-187">Case-Insensitive Matching</span></span>  
 <span data-ttu-id="33d44-188"><xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> Opcji lub `i` opcji wbudowanego udostępnia dopasowania bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="33d44-188">The <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> option, or the `i` inline option, provides case-insensitive matching.</span></span> <span data-ttu-id="33d44-189">Domyślnie są używane konwencje wielkość liter w bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="33d44-189">By default, the casing conventions of the current culture are used.</span></span>  
  
 <span data-ttu-id="33d44-190">W poniższym przykładzie zdefiniowano wzorzec wyrażenia regularnego, `\bthe\w*\b`, który dopasowuje wszystkie wyrazy rozpoczynające się od ciągu "".</span><span class="sxs-lookup"><span data-stu-id="33d44-190">The following example defines a regular expression pattern, `\bthe\w*\b`, that matches all words starting with "the".</span></span> <span data-ttu-id="33d44-191">Ponieważ pierwszy wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> metoda używa domyślnym porównaniem z uwzględnieniem wielkości liter, dane wyjściowe wskazuje, że ciąg "" rozpoczyna się zdanie nie jest zgodny.</span><span class="sxs-lookup"><span data-stu-id="33d44-191">Because the first call to the <xref:System.Text.RegularExpressions.Regex.Match%2A> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</span></span> <span data-ttu-id="33d44-192">Jest on zgodny podczas <xref:System.Text.RegularExpressions.Regex.Match%2A> metoda jest wywoływana z opcjami ustawioną <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span><span class="sxs-lookup"><span data-stu-id="33d44-192">It is matched when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with options set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)]
 [!code-vb[Conceptual.Regex.Language.Options#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)]  
  
 <span data-ttu-id="33d44-193">Poniższy przykład modyfikuje wzorzec wyrażenia regularnego z poprzedniego przykładu, aby użyć opcji wbudowanego zamiast `options` parametr, aby zapewnić porównania bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="33d44-193">The following example modifies the regular expression pattern from the previous example to use inline options instead of the `options` parameter to provide case-insensitive comparison.</span></span> <span data-ttu-id="33d44-194">Pierwszy wzorzec definiuje opcję bez uwzględniania wielkości liter w konstrukcji grupowania, która ma zastosowanie tylko do litery "t" w ciągu "".</span><span class="sxs-lookup"><span data-stu-id="33d44-194">The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</span></span> <span data-ttu-id="33d44-195">Ponieważ konstrukcja opcja występuje na początku wzorca, drugi wzorzec dotyczy opcji bez uwzględniania wielkości liter całego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-195">Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)]
 [!code-vb[Conceptual.Regex.Language.Options#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)]  
  
 [<span data-ttu-id="33d44-196">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-196">Back to Top</span></span>](#Top)  
  
<a name="Multiline"></a>   
## <a name="multiline-mode"></a><span data-ttu-id="33d44-197">Wielowierszowy tryb</span><span class="sxs-lookup"><span data-stu-id="33d44-197">Multiline Mode</span></span>  
 <span data-ttu-id="33d44-198"><xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> Opcji lub `m` opcji wbudowanego umożliwia aparat wyrażeń regularnych do obsługi wejściowy ciąg składający się z wielu wierszy.</span><span class="sxs-lookup"><span data-stu-id="33d44-198">The <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, or the `m` inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</span></span> <span data-ttu-id="33d44-199">Zmienia interpretacji `^` i `$` elementy języka aby były one zgodne z początku i końca wiersza, zamiast początek i koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="33d44-199">It changes the interpretation of the `^` and `$` language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</span></span>  
  
 <span data-ttu-id="33d44-200">Domyślnie `$` pasuje do końca ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="33d44-200">By default, `$` matches only the end of the input string.</span></span> <span data-ttu-id="33d44-201">Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opcji odpowiada znaku nowego wiersza (`\n`) lub na końcu ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="33d44-201">If you specify the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, it matches either the newline character (`\n`) or the end of the input string.</span></span> <span data-ttu-id="33d44-202">Nie, jednak odpowiada kombinacji znaków CR/LF.</span><span class="sxs-lookup"><span data-stu-id="33d44-202">It does not, however, match the carriage return/line feed character combination.</span></span> <span data-ttu-id="33d44-203">Aby pomyślnie dopasować je, użyj Podwyrażenie `\r?$` zamiast tylko `$`.</span><span class="sxs-lookup"><span data-stu-id="33d44-203">To successfully match them, use the subexpression `\r?$` instead of just `$`.</span></span>  
  
 <span data-ttu-id="33d44-204">W poniższym przykładzie wyodrębnia bowlers nazwy i wyniki i dodaje je do <xref:System.Collections.Generic.SortedList%602> kolekcji, która sortowane w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="33d44-204">The following example extracts bowlers' names and scores and adds them to a <xref:System.Collections.Generic.SortedList%602> collection that sorts them in descending order.</span></span> <span data-ttu-id="33d44-205"><xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda jest wywoływana dwukrotnie.</span><span class="sxs-lookup"><span data-stu-id="33d44-205">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method is called twice.</span></span> <span data-ttu-id="33d44-206">W pierwszym wywołaniu metody wyrażenie regularne jest `^(\w+)\s(\d+)$` i opcje nie są ustawione.</span><span class="sxs-lookup"><span data-stu-id="33d44-206">In the first method call, the regular expression is `^(\w+)\s(\d+)$` and no options are set.</span></span> <span data-ttu-id="33d44-207">Jako dane wyjściowe zawierają, ponieważ aparat wyrażeń regularnych nie pasuje do wprowadzania wzorzec wraz z początku i na końcu ciągu wejściowego, nieodnalezienia żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="33d44-207">As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</span></span> <span data-ttu-id="33d44-208">W drugim wywołania metody, wyrażenie regularne jest zmieniana na `^(\w+)\s(\d+)\r?$` i opcje są ustawione na <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33d44-208">In the second method call, the regular expression is changed to `^(\w+)\s(\d+)\r?$` and the options are set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span></span> <span data-ttu-id="33d44-209">Jak pokazano na dane wyjściowe, nazwy i wyniki są dopasowane, a wyniki są wyświetlane w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="33d44-209">As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)]
 [!code-vb[Conceptual.Regex.Language.Options#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)]  
  
 <span data-ttu-id="33d44-210">Wzorzec wyrażenia regularnego `^(\w+)\s(\d+)\r*$` jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="33d44-210">The regular expression pattern `^(\w+)\s(\d+)\r*$` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="33d44-211">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="33d44-211">Pattern</span></span>|<span data-ttu-id="33d44-212">Opis</span><span class="sxs-lookup"><span data-stu-id="33d44-212">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="33d44-213">Rozpocznij na początku wiersza.</span><span class="sxs-lookup"><span data-stu-id="33d44-213">Begin at the start of the line.</span></span>|  
|`(\w+)`|<span data-ttu-id="33d44-214">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="33d44-214">Match one or more word characters.</span></span> <span data-ttu-id="33d44-215">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-215">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="33d44-216">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="33d44-216">Match a white-space character.</span></span>|  
|`(\d+)`|<span data-ttu-id="33d44-217">Dopasowanie do co najmniej jednej cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="33d44-217">Match one or more decimal digits.</span></span> <span data-ttu-id="33d44-218">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-218">This is the second capturing group.</span></span>|  
|`\r?`|<span data-ttu-id="33d44-219">Zgodne zero lub jeden znak powrotu karetki.</span><span class="sxs-lookup"><span data-stu-id="33d44-219">Match zero or one carriage return character.</span></span>|  
|`$`|<span data-ttu-id="33d44-220">Końcowy na końcu linii.</span><span class="sxs-lookup"><span data-stu-id="33d44-220">End at the end of the line.</span></span>|  
  
 <span data-ttu-id="33d44-221">Poniższy przykład jest odpowiednikiem poprzedniego, z wyjątkiem tego, że używa opcji wbudowanego `(?m)` można ustawić zaznaczono opcję.</span><span class="sxs-lookup"><span data-stu-id="33d44-221">The following example is equivalent to the previous one, except that it uses the inline option `(?m)` to set the multiline option.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)]
 [!code-vb[Conceptual.Regex.Language.Options#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)]  
  
 [<span data-ttu-id="33d44-222">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-222">Back to Top</span></span>](#Top)  
  
<a name="Singleline"></a>   
## <a name="single-line-mode"></a><span data-ttu-id="33d44-223">Jednowierszowy tryb</span><span class="sxs-lookup"><span data-stu-id="33d44-223">Single-line Mode</span></span>  
 <span data-ttu-id="33d44-224"><xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> Opcji lub `s` opcja wbudowany, powoduje, że aparat wyrażeń regularnych traktować ciąg wejściowy tak, jakby składa się z jednym wierszu.</span><span class="sxs-lookup"><span data-stu-id="33d44-224">The <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option, or the `s` inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</span></span> <span data-ttu-id="33d44-225">Jest to zmiana zachowania okresu (`.`) element języka, którego nie pasuje do każdego znaku, zamiast dopasowywania każdego znaku z wyjątkiem znaku nowego wiersza `\n` lub \u000A.</span><span class="sxs-lookup"><span data-stu-id="33d44-225">It does this by changing the behavior of the period (`.`) language element so that it matches every character, instead of matching every character except for the newline character `\n` or \u000A.</span></span>  
  
 <span data-ttu-id="33d44-226">Poniższy przykład przedstawia sposób zachowania `.` element języka zostanie zmieniona, gdy używasz <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-226">The following example illustrates how the behavior of the `.` language element changes when you use the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="33d44-227">Wyrażenie regularne `^.+` rozpoczyna się od początku ciągu i każdy znak jest zgodna.</span><span class="sxs-lookup"><span data-stu-id="33d44-227">The regular expression `^.+` starts at the beginning of the string and matches every character.</span></span> <span data-ttu-id="33d44-228">Domyślnie dopasowania kończy się na końcu pierwszego wiersza; znak powrotu karetki, jest zgodna ze wzorcem wyrażenia regularnego `\r` lub \u000D, ale nie odpowiada `\n`.</span><span class="sxs-lookup"><span data-stu-id="33d44-228">By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, `\r` or \u000D, but it does not match `\n`.</span></span> <span data-ttu-id="33d44-229">Ponieważ <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> opcji interpretuje cały ciąg wejściowy jako pojedynczy wiersz, jest on zgodny każdego znaku w ciągu wejściowym w tym `\n`.</span><span class="sxs-lookup"><span data-stu-id="33d44-229">Because the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option interprets the entire input string as a single line, it matches every character in the input string, including `\n`.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
 [!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]  
  
 <span data-ttu-id="33d44-230">Poniższy przykład jest odpowiednikiem poprzedniego, z wyjątkiem tego, że używa opcji wbudowanego `(?s)` Aby włączyć tryb pojedynczej linii.</span><span class="sxs-lookup"><span data-stu-id="33d44-230">The following example is equivalent to the previous one, except that it uses the inline option `(?s)` to enable single-line mode.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)]
 [!code-vb[Conceptual.Regex.Language.Options#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)]  
  
 [<span data-ttu-id="33d44-231">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-231">Back to Top</span></span>](#Top)  
  
<a name="Explicit"></a>   
## <a name="explicit-captures-only"></a><span data-ttu-id="33d44-232">Jawne przechwytuje tylko</span><span class="sxs-lookup"><span data-stu-id="33d44-232">Explicit Captures Only</span></span>  
 <span data-ttu-id="33d44-233">Domyślnie przechwytywania grupy są definiowane za pomocą nawiasów w wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-233">By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</span></span> <span data-ttu-id="33d44-234">Grupy nazwane przypisano nazwę lub numer przez `(?<` *nazwa*`>`*Podwyrażenie* `)` opcji języka, są dostępne dla indeksu nazwy grup.</span><span class="sxs-lookup"><span data-stu-id="33d44-234">Named groups are assigned a name or number by the `(?<`*name*`>`*subexpression*`)` language option, whereas unnamed groups are accessible by index.</span></span> <span data-ttu-id="33d44-235">W <xref:System.Text.RegularExpressions.GroupCollection> obiekt bez nazwy grup poprzedzać nazwane grup.</span><span class="sxs-lookup"><span data-stu-id="33d44-235">In the <xref:System.Text.RegularExpressions.GroupCollection> object, unnamed groups precede named groups.</span></span>  
  
 <span data-ttu-id="33d44-236">Konstrukcji grupowania są często używane tylko w celu zastosowania Kwantyfikatory do wielu elementów języka, a przechwycony podciągów są nie zainteresowań.</span><span class="sxs-lookup"><span data-stu-id="33d44-236">Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</span></span> <span data-ttu-id="33d44-237">Na przykład jeśli następującym wyrażeniem regularnym:</span><span class="sxs-lookup"><span data-stu-id="33d44-237">For example, if the following regular expression:</span></span>  
  
```  
\b\(?((\w+),?\s?)+[\.!?]\)?  
```  
  
 <span data-ttu-id="33d44-238">jest przeznaczony tylko do wyodrębniania zdania zawierające kończyć okres, wykrzyknik lub znak zapytania z dokumentu, wynikowy zdanie (reprezentowany przez <xref:System.Text.RegularExpressions.Match> obiektu) ma znaczenie.</span><span class="sxs-lookup"><span data-stu-id="33d44-238">is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <xref:System.Text.RegularExpressions.Match> object) is of interest.</span></span> <span data-ttu-id="33d44-239">Poszczególnych wyrazów w kolekcji nie są.</span><span class="sxs-lookup"><span data-stu-id="33d44-239">The individual words in the collection are not.</span></span>  
  
 <span data-ttu-id="33d44-240">Przechwytywanie grup, które nie są następnie używane może być kosztowne, ponieważ aparat wyrażeń regularnych musi wypełnić zarówno <xref:System.Text.RegularExpressions.GroupCollection> i <xref:System.Text.RegularExpressions.CaptureCollection> kolekcji obiektów.</span><span class="sxs-lookup"><span data-stu-id="33d44-240">Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects.</span></span> <span data-ttu-id="33d44-241">Alternatywnie, można użyć zarówno <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> opcji lub `n` wbudowanego opcję, aby określić jawnie o nazwie lub numerowane grup, które są oznaczane jedyne prawidłowe przechwytywania `(?<` *nazwa* `>` *Podwyrażenie* `)` utworzenia.</span><span class="sxs-lookup"><span data-stu-id="33d44-241">As an alternative, you can use either the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option or the `n` inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the `(?<`*name*`>` *subexpression*`)` construct.</span></span>  
  
 <span data-ttu-id="33d44-242">W poniższym przykładzie przedstawiono informacje o dopasowań zwracana przez `\b\(?((\w+),?\s?)+[\.!?]\)?` wzorzec wyrażenia regularnego, kiedy <xref:System.Text.RegularExpressions.Regex.Match%2A> metoda jest wywoływana z włączonymi i wyłączonymi <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-242">The following example displays information about the matches returned by the `\b\(?((\w+),?\s?)+[\.!?]\)?` regular expression pattern when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with and without the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="33d44-243">Jako dane wyjściowe z pierwszego metody należy wywołać pokazuje, aparat wyrażeń regularnych pełni wypełnia <xref:System.Text.RegularExpressions.GroupCollection> i <xref:System.Text.RegularExpressions.CaptureCollection> kolekcji obiektów z informacjami o przechwyconych podciągów.</span><span class="sxs-lookup"><span data-stu-id="33d44-243">As the output from the first method call shows, the regular expression engine fully populates the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects with information about captured substrings.</span></span> <span data-ttu-id="33d44-244">Ponieważ druga metoda jest wywoływana z `options` ustawioną <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, nie nie przechwytywanie informacji dotyczących grup.</span><span class="sxs-lookup"><span data-stu-id="33d44-244">Because the second method is called with `options` set to <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, it does not capture information on groups.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)]
 [!code-vb[Conceptual.Regex.Language.Options#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)]  
  
 <span data-ttu-id="33d44-245">Wzorzec wyrażenia regularnego`\b\(?((?>\w+),?\s?)+[\.!?]\)?` jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="33d44-245">The regular expression pattern`\b\(?((?>\w+),?\s?)+[\.!?]\)?` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="33d44-246">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="33d44-246">Pattern</span></span>|<span data-ttu-id="33d44-247">Opis</span><span class="sxs-lookup"><span data-stu-id="33d44-247">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="33d44-248">Zaczyna granic programu word.</span><span class="sxs-lookup"><span data-stu-id="33d44-248">Begin at a word boundary.</span></span>|  
|`\(?`|<span data-ttu-id="33d44-249">Zgodne zero lub jeden wystąpień nawias otwierający ("(").</span><span class="sxs-lookup"><span data-stu-id="33d44-249">Match zero or one occurrences of the opening parenthesis ("(").</span></span>|  
|`(?>\w+),?`|<span data-ttu-id="33d44-250">Zgodne z co najmniej jeden znak słowa następuje zero lub jeden przecinkami.</span><span class="sxs-lookup"><span data-stu-id="33d44-250">Match one or more word characters, followed by zero or one commas.</span></span> <span data-ttu-id="33d44-251">Nie cofnąć podczas dopasowywania znaków słów.</span><span class="sxs-lookup"><span data-stu-id="33d44-251">Do not backtrack when matching word characters.</span></span>|  
|`\s?`|<span data-ttu-id="33d44-252">Dopasowanie do zera lub jednego znaku odstępu.</span><span class="sxs-lookup"><span data-stu-id="33d44-252">Match zero or one white-space characters.</span></span>|  
|`((\w+),?\s?)+`|<span data-ttu-id="33d44-253">Zgodne kombinację co najmniej jeden znak słowa, zero lub jeden przecinkami i zero lub jeden białe znaki jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="33d44-253">Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</span></span>|  
|`[\.!?]\)?`|<span data-ttu-id="33d44-254">Pasuje do żadnego z trzech interpunkcyjnych, następuje zero lub jeden nawiasów zamykających (")").</span><span class="sxs-lookup"><span data-stu-id="33d44-254">Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</span></span>|  
  
 <span data-ttu-id="33d44-255">Można również użyć `(?n)` elementu aby pominąć Przechwytywanie automatycznego.</span><span class="sxs-lookup"><span data-stu-id="33d44-255">You can also use the `(?n)` inline element to suppress automatic captures.</span></span> <span data-ttu-id="33d44-256">Poniższy przykład modyfikuje poprzedniej wzorzec wyrażenia regularnego, aby użyć `(?n)` elementu zamiast <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-256">The following example modifies the previous regular expression pattern to use the `(?n)` inline element instead of the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)]
 [!code-vb[Conceptual.Regex.Language.Options#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)]  
  
 <span data-ttu-id="33d44-257">Ponadto można użyć elementu grupy wbudowane `(?n:)` do pomijania automatyczne przechwytywania na podstawie przez grupy.</span><span class="sxs-lookup"><span data-stu-id="33d44-257">Finally, you can use the inline group element `(?n:)` to suppress automatic captures on a group-by-group basis.</span></span> <span data-ttu-id="33d44-258">Poniższy przykład modyfikuje wcześniejszego wzorca do pomijania nienazwane przechwytywania w grupie zewnętrzne `((?>\w+),?\s?)`.</span><span class="sxs-lookup"><span data-stu-id="33d44-258">The following example modifies the previous pattern to suppress unnamed captures in the outer group, `((?>\w+),?\s?)`.</span></span> <span data-ttu-id="33d44-259">Należy pamiętać, że to pomija nienazwane przechwytuje w grupy wewnętrznej.</span><span class="sxs-lookup"><span data-stu-id="33d44-259">Note that this suppresses unnamed captures in the inner group as well.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)]
 [!code-vb[Conceptual.Regex.Language.Options#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)]  
  
 [<span data-ttu-id="33d44-260">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-260">Back to Top</span></span>](#Top)  
  
<a name="Compiled"></a>   
## <a name="compiled-regular-expressions"></a><span data-ttu-id="33d44-261">Skompilowane wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="33d44-261">Compiled Regular Expressions</span></span>  
 <span data-ttu-id="33d44-262">Domyślnie są interpretowane wyrażeń regularnych programu .NET.</span><span class="sxs-lookup"><span data-stu-id="33d44-262">By default, regular expressions in .NET are interpreted.</span></span> <span data-ttu-id="33d44-263">Gdy <xref:System.Text.RegularExpressions.Regex> obiekt jest wystąpień lub statyczna <xref:System.Text.RegularExpressions.Regex> metoda jest wywoływana, wzorzec wyrażenia regularnego jest analizowana w zestawie używa niestandardowych i interpreter używa tych używa do uruchomienia z wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="33d44-263">When a <xref:System.Text.RegularExpressions.Regex> object is instantiated or a static <xref:System.Text.RegularExpressions.Regex> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</span></span> <span data-ttu-id="33d44-264">Obejmuje to zależnościami: koszt inicjowanie aparatu wyrażenie regularne jest zminimalizowany kosztem wydajności w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-264">This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</span></span>  
  
 <span data-ttu-id="33d44-265">Można użyć skompilowany zamiast wyrażeń regularnych interpretowany za pomocą <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-265">You can use compiled instead of interpreted regular expressions by using the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="33d44-266">W tym przypadku jeśli wzorzec jest przekazywany z aparatem wyrażeń regularnych, jest analizowana na zestaw kodów operacji i następnie przekonwertowane na język pośredni firmy Microsoft (MSIL), które mogą zostać przekazane bezpośrednio do środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="33d44-266">In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</span></span> <span data-ttu-id="33d44-267">Skompilowane wyrażenia regularnego zmaksymalizować wydajność środowiska wykonawczego kosztem czas inicjowania.</span><span class="sxs-lookup"><span data-stu-id="33d44-267">Compiled regular expressions maximize run-time performance at the expense of initialization time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33d44-268">Wyrażenie regularne może zostać skompilowany tylko podając <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> do wartości `options` parametr <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub statycznej metody dopasowywanie do wzorca.</span><span class="sxs-lookup"><span data-stu-id="33d44-268">A regular expression can be compiled only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or a static pattern-matching method.</span></span> <span data-ttu-id="33d44-269">Nie jest dostępny jako opcja wbudowanego.</span><span class="sxs-lookup"><span data-stu-id="33d44-269">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="33d44-270">Można użyć skompilowanych wyrażeń regularnych w wywołaniach obu statyczna i wyrażenia regularne wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="33d44-270">You can use compiled regular expressions in calls to both static and instance regular expressions.</span></span> <span data-ttu-id="33d44-271">W wyrażeniach regularnych statycznych <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> opcji jest przekazywana do `options` parametru metody dopasowywanie do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-271">In static regular expressions, the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is passed to the `options` parameter of the regular expression pattern-matching method.</span></span> <span data-ttu-id="33d44-272">W wyrażeniach regularnych wystąpienia, są przekazywane do `options` parametr <xref:System.Text.RegularExpressions.Regex> konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="33d44-272">In instance regular expressions, it is passed to the `options` parameter of the <xref:System.Text.RegularExpressions.Regex> class constructor.</span></span> <span data-ttu-id="33d44-273">W obu przypadkach go powoduje zwiększoną wydajność.</span><span class="sxs-lookup"><span data-stu-id="33d44-273">In both cases, it results in enhanced performance.</span></span>  
  
 <span data-ttu-id="33d44-274">Jednak ta poprawa wydajności występuje tylko w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="33d44-274">However, this improvement in performance occurs only under the following conditions:</span></span>  
  
-   <span data-ttu-id="33d44-275">A <xref:System.Text.RegularExpressions.Regex> obiekt reprezentujący określonego wyrażenia regularnego jest używany w wielu wywołań do metod dopasowywanie do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-275">A <xref:System.Text.RegularExpressions.Regex> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span>  
  
-   <span data-ttu-id="33d44-276"><xref:System.Text.RegularExpressions.Regex> Obiektu nie może znaleźć poza zakresem, dlatego mogą być ponownie używane.</span><span class="sxs-lookup"><span data-stu-id="33d44-276">The <xref:System.Text.RegularExpressions.Regex> object is not allowed to go out of scope, so it can be reused.</span></span>  
  
-   <span data-ttu-id="33d44-277">Statyczne wyrażenia regularnego jest używany w wielu wywołań do metod dopasowywanie do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-277">A static regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span> <span data-ttu-id="33d44-278">(Wzrost wydajności jest możliwa, ponieważ wyrażeń regularnych, używanym w wywołaniach metody statycznej są buforowane przez aparat wyrażeń regularnych).</span><span class="sxs-lookup"><span data-stu-id="33d44-278">(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33d44-279"><xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> Opcji jest niezwiązanych ze sobą <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> metodę, która tworzy zestaw specjalny, który zawiera wstępnie zdefiniowane skompilowane wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-279">The <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is unrelated to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</span></span>  
  
 [<span data-ttu-id="33d44-280">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-280">Back to Top</span></span>](#Top)  
  
<a name="Whitespace"></a>   
## <a name="ignore-white-space"></a><span data-ttu-id="33d44-281">Ignoruj biały znak</span><span class="sxs-lookup"><span data-stu-id="33d44-281">Ignore White Space</span></span>  
 <span data-ttu-id="33d44-282">Domyślnie jest znacząca; biały znak w wzorzec wyrażenia regularnego wymusi aparat wyrażenia regularnego do dopasowania biały znak w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="33d44-282">By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</span></span> <span data-ttu-id="33d44-283">W związku z tym wyrażenie regularne "`\b\w+\s`"i"`\b\w+` " są w przybliżeniu wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="33d44-283">Because of this, the regular expression "`\b\w+\s`" and "`\b\w+` " are roughly equivalent regular expressions.</span></span> <span data-ttu-id="33d44-284">Ponadto w przypadku znak numeru (#) we wzorcu wyrażenia regularnego, jest interpretowany jako literał znaków do dopasowania.</span><span class="sxs-lookup"><span data-stu-id="33d44-284">In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</span></span>  
  
 <span data-ttu-id="33d44-285"><xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Opcji lub `x` opcji wbudowanego zmieni to domyślne zachowanie w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="33d44-285">The <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option, or the `x` inline option, changes this default behavior as follows:</span></span>  
  
-   <span data-ttu-id="33d44-286">Niezmienionym znaczeniu biały znak w wzorzec wyrażenia regularnego jest ignorowana.</span><span class="sxs-lookup"><span data-stu-id="33d44-286">Unescaped white space in the regular expression pattern is ignored.</span></span> <span data-ttu-id="33d44-287">Jako część wyrażenia regularnego, należy użyć znaków ucieczki białe znaki (na przykład jako `\s` lub "`\` ").</span><span class="sxs-lookup"><span data-stu-id="33d44-287">To be part of a regular expression pattern, white-space characters must be escaped (for example, as `\s` or "`\` ").</span></span>  
  
-   <span data-ttu-id="33d44-288">Znak numeru (#) jest interpretowany jako początek wiersza, a nie jako literał znaków.</span><span class="sxs-lookup"><span data-stu-id="33d44-288">The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</span></span> <span data-ttu-id="33d44-289">Cały tekst w wzorzec wyrażenia regularnego z #-znak na końcu ciągu jest interpretowany jako komentarz.</span><span class="sxs-lookup"><span data-stu-id="33d44-289">All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</span></span>  
  
 <span data-ttu-id="33d44-290">Jednak w następujących przypadkach białych znaków w wyrażeniu regularnym nie są ignorowane, nawet jeśli używasz <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opcji:</span><span class="sxs-lookup"><span data-stu-id="33d44-290">However, in the following cases, white space characters in a regular expression aren't ignored, even if you use the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option:</span></span>  
  
-   <span data-ttu-id="33d44-291">Biały znak w klasie znaku zawsze jest interpretowany jako literału.</span><span class="sxs-lookup"><span data-stu-id="33d44-291">White space within a character class is always interpreted literally.</span></span> <span data-ttu-id="33d44-292">Na przykład wzorzec wyrażenia regularnego `[ .,;:]` dopasowuje wszystkie pojedynczy znak odstępu, okres, przecinek, średnik lub dwukropek.</span><span class="sxs-lookup"><span data-stu-id="33d44-292">For example, the regular expression pattern `[ .,;:]` matches any single white-space character, period, comma, semicolon, or colon.</span></span>  
  
-   <span data-ttu-id="33d44-293">Biały znak nie jest dozwolona w nawiasach kwadratowych kwantyfikatora, takich jak `{`  *n*  `}`, `{`  *n*  `,}`i `{`  *n*  `,` *m*`}`.</span><span class="sxs-lookup"><span data-stu-id="33d44-293">White space isn't allowed within a bracketed quantifier, such as `{`*n*`}`, `{`*n*`,}`, and `{`*n*`,`*m*`}`.</span></span> <span data-ttu-id="33d44-294">Na przykład wzorzec wyrażenia regularnego `\d{1. 3}` nie odpowiada dowolnej sekwencji cyfr od jednej do trzech cyfr, ponieważ zawiera biały znak.</span><span class="sxs-lookup"><span data-stu-id="33d44-294">For example, the regular expression pattern `\d{1. 3}` fails to match any sequences of digits from one to three digits because it contains a white-space character.</span></span>  
  
-   <span data-ttu-id="33d44-295">Biały znak nie jest dozwolone w ramach sekwencji znaków, który wprowadzono w elemencie języka.</span><span class="sxs-lookup"><span data-stu-id="33d44-295">White space isn't allowed within a character sequence that introduces a language element.</span></span> <span data-ttu-id="33d44-296">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="33d44-296">For example:</span></span>  
  
    -   <span data-ttu-id="33d44-297">Language element `(?:` *Podwyrażenie* `)` reprezentuje grupę nieprzechwyconej i `(?:` część elementu nie osadzonych spacji.</span><span class="sxs-lookup"><span data-stu-id="33d44-297">The language element `(?:`*subexpression*`)` represents a noncapturing group, and the `(?:` portion of the element can't have embedded spaces.</span></span> <span data-ttu-id="33d44-298">Wzorzec `(? :` *Podwyrażenie* `)` zgłasza <xref:System.ArgumentException> na czas wykonywania, ponieważ aparat wyrażeń regularnych nie można przeanalizować wzoru i `( ?:` *Podwyrażenie*  `)` nie powiedzie się dopasować *Podwyrażenie*.</span><span class="sxs-lookup"><span data-stu-id="33d44-298">The pattern `(? :`*subexpression*`)` throws an <xref:System.ArgumentException> at run time because the regular expression engine can't parse the pattern, and the pattern `( ?:`*subexpression*`)` fails to match *subexpression*.</span></span>  
  
    -   <span data-ttu-id="33d44-299">Language element `\p{` *nazwa*`}`, która reprezentuje kategorię Unicode, lub o nazwie blok, nie może zawierać spacji osadzonych w `\p{` część elementu.</span><span class="sxs-lookup"><span data-stu-id="33d44-299">The language element `\p{`*name*`}`, which represents a Unicode category or named block, can't include embedded spaces in the `\p{` portion of the element.</span></span> <span data-ttu-id="33d44-300">Jeśli dołączysz biały znak, element zgłasza <xref:System.ArgumentException> w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-300">If you do include a white space, the element throws an <xref:System.ArgumentException> at run time.</span></span>  
  
 <span data-ttu-id="33d44-301">Włączenie tej opcji upraszcza wyrażeń regularnych, które są często jest trudne do analizowania i zrozumieć.</span><span class="sxs-lookup"><span data-stu-id="33d44-301">Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</span></span> <span data-ttu-id="33d44-302">Poprawia czytelność, a umożliwia dokumentu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-302">It improves readability, and makes it possible to document a regular expression.</span></span>  
  
 <span data-ttu-id="33d44-303">W poniższym przykładzie zdefiniowano następujące wzorzec wyrażenia regularnego:</span><span class="sxs-lookup"><span data-stu-id="33d44-303">The following example defines the following regular expression pattern:</span></span>  
  
 `\b \(? ( (?>\w+) ,?\s? )+  [\.!?] \)? # Matches an entire sentence.`  
  
 <span data-ttu-id="33d44-304">Ten wzorzec jest podobny do wzorcowi określonemu w [tylko jawne przechwytuje](#Explicit) sekcji z tą różnicą, że używa <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opcji ignorowania wzorzec biały znak.</span><span class="sxs-lookup"><span data-stu-id="33d44-304">This pattern is similar to the pattern defined in the [Explicit Captures Only](#Explicit) section, except that it uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option to ignore pattern white space.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)]
 [!code-vb[Conceptual.Regex.Language.Options#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)]  
  
 <span data-ttu-id="33d44-305">W poniższym przykładzie użyto opcji wbudowanego `(?x)` Ignorowanie wzorca biały znak.</span><span class="sxs-lookup"><span data-stu-id="33d44-305">The following example uses the inline option `(?x)` to ignore pattern white space.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)]
 [!code-vb[Conceptual.Regex.Language.Options#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)]  
  
 [<span data-ttu-id="33d44-306">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-306">Back to Top</span></span>](#Top)  
  
<a name="RightToLeft"></a>   
## <a name="right-to-left-mode"></a><span data-ttu-id="33d44-307">Tryb od prawej do lewej</span><span class="sxs-lookup"><span data-stu-id="33d44-307">Right-to-Left Mode</span></span>  
 <span data-ttu-id="33d44-308">Domyślnie aparat wyrażeń regularnych wyszukiwania od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="33d44-308">By default, the regular expression engine searches from left to right.</span></span> <span data-ttu-id="33d44-309">Można odwrócić kierunek wyszukiwania przy użyciu <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-309">You can reverse the search direction by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="33d44-310">Wyszukiwanie automatycznie rozpoczyna się od ostatniej pozycji znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="33d44-310">The search automatically begins at the last character position of the string.</span></span> <span data-ttu-id="33d44-311">Dla metody dopasowywanie do wzorca, które obejmują początkowy pozycji parametrów, takich jak <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, pozycja początkowa jest indeksem pozycji znaku po prawej stronie, przy którym ma się rozpocząć wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="33d44-311">For pattern-matching methods that include a starting position parameter, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, the starting position is the index of the rightmost character position at which the search is to begin.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33d44-312">Wzorzec od prawej do lewej tryb jest dostępny tylko podając <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> do wartości `options` parametr <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub metody statycznej dopasowywanie do wzorca.</span><span class="sxs-lookup"><span data-stu-id="33d44-312">Right-to-left pattern mode is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="33d44-313">Nie jest dostępny jako opcja wbudowanego.</span><span class="sxs-lookup"><span data-stu-id="33d44-313">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="33d44-314"><xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> Opcja zmian z kierunkiem wyszukiwania; nie ma możliwości interpretowania wzorzec wyrażenia regularnego od prawej do lewej.</span><span class="sxs-lookup"><span data-stu-id="33d44-314">The <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</span></span> <span data-ttu-id="33d44-315">Na przykład, wyrażenie regularne `\bb\w+\s` odpowiada wyrazy, które zaczynają się od litery "b" i następuje biały znak.</span><span class="sxs-lookup"><span data-stu-id="33d44-315">For example, the regular expression `\bb\w+\s` matches words that begin with the letter "b" and are followed by a white-space character.</span></span> <span data-ttu-id="33d44-316">W poniższym przykładzie ciąg wejściowy składa się z trzech słów, które obejmują co najmniej jeden znak "b".</span><span class="sxs-lookup"><span data-stu-id="33d44-316">In the following example, the input string consists of three words that include one or more "b" characters.</span></span> <span data-ttu-id="33d44-317">Pierwsze słowo rozpoczyna się od "b", drugi elementach end, których "b", a trzeci obejmuje dwa znaki "b" w trakcie słowo.</span><span class="sxs-lookup"><span data-stu-id="33d44-317">The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</span></span> <span data-ttu-id="33d44-318">Dane wyjściowe w przykładzie pokazano, tylko pierwsze słowo jest zgodny ze wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="33d44-318">As the output from the example shows, only the first word matches the regular expression pattern.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)]
 [!code-vb[Conceptual.Regex.Language.Options#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)]  
  
 <span data-ttu-id="33d44-319">Należy również zauważyć, że potwierdzenie wyprzedzenia ( `(?=` *Podwyrażenie* `)` element języka) i wybieganie wstecz asercja ( `(?<=` *Podwyrażenie* `)`element języka) nie należy zmieniać kierunku.</span><span class="sxs-lookup"><span data-stu-id="33d44-319">Also note that the lookahead assertion (the `(?=`*subexpression*`)` language element) and the lookbehind assertion (the `(?<=`*subexpression*`)` language element) do not change direction.</span></span> <span data-ttu-id="33d44-320">Szukaj potwierdzenia wyprzedzenia prawo; Szukaj potwierdzenia wybieganie wstecz do lewej strony.</span><span class="sxs-lookup"><span data-stu-id="33d44-320">The lookahead assertions look to the right; the lookbehind assertions look to the left.</span></span> <span data-ttu-id="33d44-321">Na przykład, wyrażenie regularne `(?<=\d{1,2}\s)\w+,?\s\d{4}` używa wybieganie wstecz asercja do testowania z datą poprzedzającą nazwy miesięcy.</span><span class="sxs-lookup"><span data-stu-id="33d44-321">For example, the regular expression `(?<=\d{1,2}\s)\w+,?\s\d{4}` uses the lookbehind assertion to test for a date that precedes a month name.</span></span> <span data-ttu-id="33d44-322">Następnie wyrażenie regularne dopasowuje miesiąca i roku.</span><span class="sxs-lookup"><span data-stu-id="33d44-322">The regular expression then matches the month and the year.</span></span> <span data-ttu-id="33d44-323">Aby uzyskać informacje na assertsions wyprzedzenia i wybieganie wstecz, zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="33d44-323">For information on lookahead and lookbehind assertsions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)]
 [!code-vb[Conceptual.Regex.Language.Options#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)]  
  
 <span data-ttu-id="33d44-324">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="33d44-324">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="33d44-325">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="33d44-325">Pattern</span></span>|<span data-ttu-id="33d44-326">Opis</span><span class="sxs-lookup"><span data-stu-id="33d44-326">Description</span></span>|  
|-------------|-----------------|  
|`(?<=\d{1,2}\s)`|<span data-ttu-id="33d44-327">Na początku dopasowania musi być poprzedzona jednego lub dwóch miejsc dziesiętnych, następuje spacja.</span><span class="sxs-lookup"><span data-stu-id="33d44-327">The beginning of the match must be preceded by one or two decimal digits followed by a space.</span></span>|  
|`\w+`|<span data-ttu-id="33d44-328">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="33d44-328">Match one or more word characters.</span></span>|  
|`,?`|<span data-ttu-id="33d44-329">Zgodne zero lub jeden przecinków.</span><span class="sxs-lookup"><span data-stu-id="33d44-329">Match zero or one comma characters.</span></span>|  
|`\s`|<span data-ttu-id="33d44-330">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="33d44-330">Match a white-space character.</span></span>|  
|`\d{4}`|<span data-ttu-id="33d44-331">Zgodne czterech cyfr dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="33d44-331">Match four decimal digits.</span></span>|  
  
 [<span data-ttu-id="33d44-332">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-332">Back to Top</span></span>](#Top)  
  
<a name="ECMAScript"></a>   
## <a name="ecmascript-matching-behavior"></a><span data-ttu-id="33d44-333">Zachowanie dopasowania ECMAScript</span><span class="sxs-lookup"><span data-stu-id="33d44-333">ECMAScript Matching Behavior</span></span>  
 <span data-ttu-id="33d44-334">Domyślnie aparat wyrażeń regularnych używa canonical zachowanie podczas dopasowywania wzorzec wyrażenia regularnego do wprowadzania tekstu.</span><span class="sxs-lookup"><span data-stu-id="33d44-334">By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</span></span> <span data-ttu-id="33d44-335">Jednak możesz wydać aparat wyrażeń regularnych do używania języka ECMAScript dopasowania zachowanie, określając <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="33d44-335">However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33d44-336">Zachowanie zgodne ECMAScript jest dostępna tylko poprzez dostarczanie <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> do wartości `options` parametr <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub metody statycznej dopasowywanie do wzorca.</span><span class="sxs-lookup"><span data-stu-id="33d44-336">ECMAScript-compliant behavior is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="33d44-337">Nie jest dostępny jako opcja wbudowanego.</span><span class="sxs-lookup"><span data-stu-id="33d44-337">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="33d44-338"><xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> Opcji można połączyć tylko z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opcje.</span><span class="sxs-lookup"><span data-stu-id="33d44-338">The <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option can be combined only with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="33d44-339">Użyj innych opcji w wyrażeniu regularnym powoduje <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="33d44-339">The use of any other option in a regular expression results in an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="33d44-340">Zachowanie języka ECMAScript i wyrażeń regularnych canonical różni się w trzech obszarach: klasa składni, odwołaniem do samego siebie Przechwytywanie grup i ósemkowe i dopasuje interpretacji znaków.</span><span class="sxs-lookup"><span data-stu-id="33d44-340">The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</span></span>  
  
-   <span data-ttu-id="33d44-341">Składnia klasy znaku.</span><span class="sxs-lookup"><span data-stu-id="33d44-341">Character class syntax.</span></span> <span data-ttu-id="33d44-342">Ponieważ canonical wyrażeń regularnych obsługują standardu Unicode, podczas gdy nie jest używany język ECMAScript, klasy znaków w języku ECMAScript ma więcej ograniczeń składnię, a niektóre elementy języka klasy znak ma inne znaczenie.</span><span class="sxs-lookup"><span data-stu-id="33d44-342">Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</span></span> <span data-ttu-id="33d44-343">Na przykład ECMAScript nie obsługuje elementów języka, takich jak elementy kategorii lub blok Unicode `\p` i `\P`.</span><span class="sxs-lookup"><span data-stu-id="33d44-343">For example, ECMAScript does not support language elements such as the Unicode category or block elements `\p` and `\P`.</span></span> <span data-ttu-id="33d44-344">Podobnie `\w` element, który pasuje do znaku słowa, jest odpowiednikiem `[a-zA-Z_0-9]` znak klasy, korzystając z języka ECMAScript i `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` używając zachowanie kanonicznej.</span><span class="sxs-lookup"><span data-stu-id="33d44-344">Similarly, the `\w` element, which matches a word character, is equivalent to the `[a-zA-Z_0-9]` character class when using ECMAScript and `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` when using canonical behavior.</span></span> <span data-ttu-id="33d44-345">Aby uzyskać więcej informacji, zobacz [klas znaków](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="33d44-345">For more information, see [Character Classes](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span>  
  
     <span data-ttu-id="33d44-346">Poniższy przykład przedstawia różnicę między kanonicznej i ECMAScript dopasowywania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="33d44-346">The following example illustrates the difference between canonical and ECMAScript pattern matching.</span></span> <span data-ttu-id="33d44-347">Definiuje wyrażenie regularne `\b(\w+\s*)+`, słowa, po których białe znaki, które odpowiadają.</span><span class="sxs-lookup"><span data-stu-id="33d44-347">It defines a regular expression, `\b(\w+\s*)+`, that matches words followed by white-space characters.</span></span> <span data-ttu-id="33d44-348">Dane wejściowe obejmuje dwa ciągi, który używa zestaw znaków łacińskich i drugiej, który korzysta z zestawu cyrylicy.</span><span class="sxs-lookup"><span data-stu-id="33d44-348">The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</span></span> <span data-ttu-id="33d44-349">Jak przedstawiono na dane wyjściowe, wywołanie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody, która używa języka ECMAScript dopasowania nie powiedzie się do dopasowania słów cyrylicy, natomiast używającej canonical dopasowania wywołania metody odpowiada te słowa.</span><span class="sxs-lookup"><span data-stu-id="33d44-349">As the output shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)]
     [!code-vb[Conceptual.Regex.Language.Options#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)]  
  
-   <span data-ttu-id="33d44-350">Grupuje własnym odwołujące się do przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-350">Self-referencing capturing groups.</span></span> <span data-ttu-id="33d44-351">Klasa przechwytywania wyrażenia regularnego z dopasowań dla samej siebie muszą zostać zaktualizowane każdej iteracji przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-351">A regular expression capture class with a backreference to itself must be updated with each capture iteration.</span></span> <span data-ttu-id="33d44-352">Jak pokazano na poniższym przykładzie, ta funkcja umożliwia wyrażenie regularne `((a+)(\1) ?)+` do dopasowania ciągu wejściowego "aa aaaa aaaaaa", gdy przy użyciu języka ECMAScript, a nie przez dopasowanie kanonicznej.</span><span class="sxs-lookup"><span data-stu-id="33d44-352">As the following example shows, this feature enables the regular expression `((a+)(\1) ?)+` to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#21](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)]
     [!code-vb[Conceptual.Regex.Language.Options#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)]  
  
     <span data-ttu-id="33d44-353">Wyrażenie regularne jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="33d44-353">The regular expression is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="33d44-354">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="33d44-354">Pattern</span></span>|<span data-ttu-id="33d44-355">Opis</span><span class="sxs-lookup"><span data-stu-id="33d44-355">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="33d44-356">(+)</span><span class="sxs-lookup"><span data-stu-id="33d44-356">(a+)</span></span>|<span data-ttu-id="33d44-357">Dopasowuje litery "" jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="33d44-357">Match the letter "a" one or more times.</span></span> <span data-ttu-id="33d44-358">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-358">This is the second capturing group.</span></span>|  
    |<span data-ttu-id="33d44-359">(\1)</span><span class="sxs-lookup"><span data-stu-id="33d44-359">(\1)</span></span>|<span data-ttu-id="33d44-360">Zgodny podciąg przechwycone przez pierwszą grupą przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-360">Match the substring captured by the first capturing group.</span></span> <span data-ttu-id="33d44-361">Jest to trzecia grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-361">This is the third capturing group.</span></span>|  
    |<span data-ttu-id="33d44-362">?</span><span class="sxs-lookup"><span data-stu-id="33d44-362">?</span></span>|<span data-ttu-id="33d44-363">Zgodne zero lub jeden znaków spacji.</span><span class="sxs-lookup"><span data-stu-id="33d44-363">Match zero or one space characters.</span></span>|  
    |<span data-ttu-id="33d44-364">((a+)(\1)?) +</span><span class="sxs-lookup"><span data-stu-id="33d44-364">((a+)(\1) ?)+</span></span>|<span data-ttu-id="33d44-365">Dopasowanie wzorzec co najmniej jeden "" znak następuje ciąg, który odpowiada pierwszej grupy przechwytywania następuje zero lub jeden miejsca znaków jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="33d44-365">Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</span></span> <span data-ttu-id="33d44-366">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-366">This is the first capturing group.</span></span>|  
  
-   <span data-ttu-id="33d44-367">Rozwiązania niejednoznaczności między specjalne ósemkowe i odwołania wstecznego.</span><span class="sxs-lookup"><span data-stu-id="33d44-367">Resolution of ambiguities between octal escapes and backreferences.</span></span> <span data-ttu-id="33d44-368">W poniższej tabeli przedstawiono różnice w ósemkowe i dopasuje interpretacji przez kanonicznej i wyrażeń regularnych języka ECMAScript.</span><span class="sxs-lookup"><span data-stu-id="33d44-368">The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</span></span>  
  
    |<span data-ttu-id="33d44-369">Wyrażenie regularne</span><span class="sxs-lookup"><span data-stu-id="33d44-369">Regular expression</span></span>|<span data-ttu-id="33d44-370">Canonical zachowanie</span><span class="sxs-lookup"><span data-stu-id="33d44-370">Canonical behavior</span></span>|<span data-ttu-id="33d44-371">Zachowanie języka ECMAScript</span><span class="sxs-lookup"><span data-stu-id="33d44-371">ECMAScript behavior</span></span>|  
    |------------------------|------------------------|-------------------------|  
    |<span data-ttu-id="33d44-372">`\0`następuje ósemkowe cyfry 0 do 2</span><span class="sxs-lookup"><span data-stu-id="33d44-372">`\0` followed by 0 to 2 octal digits</span></span>|<span data-ttu-id="33d44-373">Interpretuj jako ósemkowe.</span><span class="sxs-lookup"><span data-stu-id="33d44-373">Interpret as an octal.</span></span> <span data-ttu-id="33d44-374">Na przykład `\044` zawsze jest interpretowana jako wartość ósemkową i oznacza "$".</span><span class="sxs-lookup"><span data-stu-id="33d44-374">For example, `\044` is always interpreted as an octal value and means "$".</span></span>|<span data-ttu-id="33d44-375">Takie samo zachowanie.</span><span class="sxs-lookup"><span data-stu-id="33d44-375">Same behavior.</span></span>|  
    |<span data-ttu-id="33d44-376">`\`następuje cyfrę z zakresu od 1 do 9, i nie dodatkowe cyfr dziesiętnych</span><span class="sxs-lookup"><span data-stu-id="33d44-376">`\` followed by a digit from 1 to 9, followed by no additional decimal digits,</span></span>|<span data-ttu-id="33d44-377">Interpretuj jako dopasowań.</span><span class="sxs-lookup"><span data-stu-id="33d44-377">Interpret as a backreference.</span></span> <span data-ttu-id="33d44-378">Na przykład `\9` zawsze oznacza dopasuje 9, nawet jeśli dziewiąty Przechwytywanie grupa nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="33d44-378">For example, `\9` always means backreference 9, even if a ninth capturing group does not exist.</span></span> <span data-ttu-id="33d44-379">Jeśli przechwytywanie grupa nie istnieje, zgłasza analizatora składni wyrażeń regularnych <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="33d44-379">If the capturing group does not exist, the regular expression parser throws an <xref:System.ArgumentException>.</span></span>|<span data-ttu-id="33d44-380">Jeśli przechwytywanie pojedynczą cyfrą dziesiętną grupa istnieje, dopasuje tego cyfry.</span><span class="sxs-lookup"><span data-stu-id="33d44-380">If a single decimal digit capturing group exists, backreference to that digit.</span></span> <span data-ttu-id="33d44-381">W przeciwnym razie interpretowania wartości jako literału.</span><span class="sxs-lookup"><span data-stu-id="33d44-381">Otherwise, interpret the value as a literal.</span></span>|  
    |<span data-ttu-id="33d44-382">`\`następuje cyfrę z zakresu od 1 do 9, a następnie dodatkowych cyfr dziesiętnych</span><span class="sxs-lookup"><span data-stu-id="33d44-382">`\` followed by a digit from 1 to 9, followed by additional decimal digits</span></span>|<span data-ttu-id="33d44-383">Interpretuj cyfr jako wartości dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="33d44-383">Interpret the digits as a decimal value.</span></span> <span data-ttu-id="33d44-384">Jeśli istnieje tej grupy przechwytywania, zinterpretować wyrażenia jako dopasowań.</span><span class="sxs-lookup"><span data-stu-id="33d44-384">If that capturing group exists, interpret the expression as a backreference.</span></span><br /><br /> <span data-ttu-id="33d44-385">W przeciwnym razie zinterpretować wiodące cyfry ósemkowe maksymalnie ósemkowe 377; oznacza to należy wziąć pod uwagę tylko niski 8 bitów wartość.</span><span class="sxs-lookup"><span data-stu-id="33d44-385">Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</span></span> <span data-ttu-id="33d44-386">Interpretowanie pozostałych znaków jako literały.</span><span class="sxs-lookup"><span data-stu-id="33d44-386">Interpret the remaining digits as literals.</span></span> <span data-ttu-id="33d44-387">Na przykład w wyrażeniu `\3000`, jeśli istnieje grupa 300 przechwytywania, zinterpretować jako dopasuje 300; Jeśli przechwytywanie grupy 300 nie istnieje, zinterpretować jako ósemkowe 300 następuje 0.</span><span class="sxs-lookup"><span data-stu-id="33d44-387">For example, in the expression `\3000`, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</span></span>|<span data-ttu-id="33d44-388">Interpretuj jako dopasowań, konwertując dowolną liczbę cyfr, jak to możliwe wartości dziesiętnej, który może odwoływać się do przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="33d44-388">Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</span></span> <span data-ttu-id="33d44-389">Jeśli można przekonwertować nie cyfr, zinterpretować jako ósemkowe przy użyciu wiodące cyfry ósemkowe maksymalnie ósemkowe 377; Interpretowanie pozostałych znaków jako literały.</span><span class="sxs-lookup"><span data-stu-id="33d44-389">If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</span></span>|  
  
 [<span data-ttu-id="33d44-390">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="33d44-390">Back to Top</span></span>](#Top)  
  
<a name="Invariant"></a>   
## <a name="comparison-using-the-invariant-culture"></a><span data-ttu-id="33d44-391">Porównanie przy użyciu Niezmienna kultura</span><span class="sxs-lookup"><span data-stu-id="33d44-391">Comparison Using the Invariant Culture</span></span>  
 <span data-ttu-id="33d44-392">Domyślnie gdy aparat wyrażeń regularnych wykonuje porównania bez uwzględniania wielkości liter, używa konwencji wielkość liter w bieżącej kultury ustalenie równoważne wielkich i małych liter.</span><span class="sxs-lookup"><span data-stu-id="33d44-392">By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</span></span>  
  
 <span data-ttu-id="33d44-393">Jednak to zachowanie jest niepożądane dla niektórych typów porównań, zwłaszcza w przypadku porównanie danych wejściowych użytkownika do nazw zasobów systemowych, takich jak hasła, plików lub adresów URL.</span><span class="sxs-lookup"><span data-stu-id="33d44-393">However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</span></span> <span data-ttu-id="33d44-394">Poniższy przykład przedstawia przykład scenariusza.</span><span class="sxs-lookup"><span data-stu-id="33d44-394">The following example illustrates such as scenario.</span></span> <span data-ttu-id="33d44-395">Kod jest przeznaczone do blokowania dostępu do dowolnego zasobu, którego adres URL jest poprzedzone znakiem **FILE://**.</span><span class="sxs-lookup"><span data-stu-id="33d44-395">The code is intended to block access to any resource whose URL is prefaced with **FILE://**.</span></span> <span data-ttu-id="33d44-396">Wyrażenie regularne prób bez uwzględniania wielkości liter dopasowanie z ciągiem przy użyciu wyrażenia regularnego `$FILE://`.</span><span class="sxs-lookup"><span data-stu-id="33d44-396">The regular expression attempts a case-insensitive match with the string by using the regular expression `$FILE://`.</span></span> <span data-ttu-id="33d44-397">Jednak gdy bieżącego ustawienia kulturowego systemu jest tr-TR (Turecki Turcja), "I" nie jest odpowiednikiem wielkie "litery i".</span><span class="sxs-lookup"><span data-stu-id="33d44-397">However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</span></span> <span data-ttu-id="33d44-398">W wyniku wywołania <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metoda zwraca `false`, i jest dozwolony dostęp do pliku.</span><span class="sxs-lookup"><span data-stu-id="33d44-398">As a result, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method returns `false`, and access to the file is allowed.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)]
 [!code-vb[Conceptual.Regex.Language.Options#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)]  
  
> [!NOTE]
>  <span data-ttu-id="33d44-399">Aby uzyskać więcej informacji dotyczących porównania ciągu, który jest rozróżniana wielkość liter, które korzystają z kulturą niezmienną, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](../../../docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="33d44-399">For more information about string comparisons that are case-sensitive and that use the invariant culture, see [Best Practices for Using Strings](../../../docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="33d44-400">Zamiast porównania bez uwzględniania wielkości liter bieżącej kultury, określ <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> opcję Ignoruj kultury różnice w języku i użyj Konwencji Niezmienna kultura.</span><span class="sxs-lookup"><span data-stu-id="33d44-400">Instead of using the case-insensitive comparisons of the current culture, you can specify the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> option to ignore cultural differences in language and to use the conventions of the invariant culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33d44-401">Porównanie przy użyciu Niezmienna kultura jest dostępna tylko poprzez dostarczanie <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> do wartości `options` parametr <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub metody statycznej dopasowywanie do wzorca.</span><span class="sxs-lookup"><span data-stu-id="33d44-401">Comparison using the invariant culture is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="33d44-402">Nie jest dostępny jako opcja wbudowanego.</span><span class="sxs-lookup"><span data-stu-id="33d44-402">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="33d44-403">Poniższy przykład jest taki sam jak poprzedni przykład, z wyjątkiem statycznych <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metoda jest wywoływana z opcjami, które obejmują <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33d44-403">The following example is identical to the previous example, except that the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with options that include <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span></span> <span data-ttu-id="33d44-404">Nawet w przypadku bieżącej kultury jest ustawiony na turecki (Turcja), jest w stanie pomyślnie dopasować "FILE" i "file" i zablokowanie dostępu do zasobu pliku aparat wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="33d44-404">Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)]
 [!code-vb[Conceptual.Regex.Language.Options#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)]  
  
## <a name="see-also"></a><span data-ttu-id="33d44-405">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="33d44-405">See Also</span></span>  
 [<span data-ttu-id="33d44-406">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="33d44-406">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
