---
title: Zachowanie wyrażenia regularnego
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 802c84bf93b3821459ab652e69a12fcc50280b9e
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290555"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="62e15-102">Szczegóły zachowania wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="62e15-102">Details of regular expression behavior</span></span>

<span data-ttu-id="62e15-103">Aparat wyrażeń regularnych .NET Framework to wsteczny odpowiednik wyrażenia regularnego, który zawiera tradycyjny, Niedeterministyczny aparat usługi Automation (NFA), taki jak używany przez język Perl, Python, Emacs: i TCL.</span><span class="sxs-lookup"><span data-stu-id="62e15-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="62e15-104">Odróżnia to od szybszego, ale bardziej ograniczone, czyste wyrażenie regularne deterministycznie skończone usługi Automation (DFA), takie jak te, które znajdują się w AWK, egrep lub Lex.</span><span class="sxs-lookup"><span data-stu-id="62e15-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="62e15-105">Odróżnia to również od standaryzacji, ale wolniejsze, NFAs POSIX.</span><span class="sxs-lookup"><span data-stu-id="62e15-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="62e15-106">W poniższej sekcji opisano trzy typy aparatów wyrażeń regularnych i wyjaśniono, dlaczego wyrażenia regularne w .NET Framework są implementowane przy użyciu tradycyjnego aparatu NFA.</span><span class="sxs-lookup"><span data-stu-id="62e15-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="62e15-107">Zalety aparatu NFA</span><span class="sxs-lookup"><span data-stu-id="62e15-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="62e15-108">Gdy aparaty DFA wykonują dopasowanie do wzorca, ich kolejność przetwarzania jest określana przez ciąg wejściowy.</span><span class="sxs-lookup"><span data-stu-id="62e15-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="62e15-109">Aparat rozpoczyna się na początku ciągu wejściowego i przechodzi sekwencyjnie, aby określić, czy następny znak jest zgodny ze wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="62e15-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="62e15-110">Mogą one zagwarantować, że najdłuższy ciąg będzie możliwy.</span><span class="sxs-lookup"><span data-stu-id="62e15-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="62e15-111">Ponieważ nigdy nie testują tego samego znaku dwa razy, aparaty DFA nie obsługują wycofywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="62e15-112">Jednak ponieważ aparat DFA zawiera tylko skończoną wartość, nie może pasować do wzorca z odwołaniami wstecznymi i ponieważ nie konstruuje jawnego rozszerzania, nie może przechwycić podwyrażeń.</span><span class="sxs-lookup"><span data-stu-id="62e15-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="62e15-113">W przeciwieństwie do aparatów DFA, gdy tradycyjne aparaty NFA wykonują dopasowywanie do wzorców, ich kolejność przetwarzania jest oparta na wzorcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="62e15-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="62e15-114">Ponieważ przetwarza określony element języka, aparat używa dopasowywania zachłanne; oznacza to, że jest ona zgodna ze zbyt dużą ilością ciągu wejściowego, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="62e15-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="62e15-115">Ale również zapisuje swój stan po pomyślnym dopasowaniu podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="62e15-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="62e15-116">Jeśli dopasowanie zakończyło się niepowodzeniem, aparat może powrócić do zapisanego stanu, aby umożliwić wypróbowanie dodatkowych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="62e15-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="62e15-117">Ten proces porzucania dopasowania podwyrażenia powiodło się, aby późniejsze elementy języka w wyrażeniu regularnym mogły być również zgodne *z wycofywaniem.*</span><span class="sxs-lookup"><span data-stu-id="62e15-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="62e15-118">Silniki NFA używają wycofywania do testowania wszystkich możliwych rozszerzeń wyrażenia regularnego w określonej kolejności i akceptują pierwsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="62e15-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="62e15-119">Ze względu na to, że tradycyjny aparat NFA konstruuje określone rozszerzenie wyrażenia regularnego dla sukcesu, może przechwycić dopasowania podwyrażenia i pasujące odwołania wsteczne.</span><span class="sxs-lookup"><span data-stu-id="62e15-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="62e15-120">Jednak ze względu na to, że tradycyjne NFA, mogą odwiedzać ten sam stan wielokrotnie, jeśli dociera do stanu dla różnych ścieżek.</span><span class="sxs-lookup"><span data-stu-id="62e15-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="62e15-121">W związku z tym może działać wykładniczo powoli w najgorszym przypadku.</span><span class="sxs-lookup"><span data-stu-id="62e15-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="62e15-122">Ze względu na to, że tradycyjny aparat NFA akceptuje pierwsze znalezione dopasowanie, może również pozostawić inne (prawdopodobnie dłużej) dopasowania niewykrywalne.</span><span class="sxs-lookup"><span data-stu-id="62e15-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="62e15-123">Aparaty NFA POSIX są podobne do tradycyjnych aparatów NFA, z tą różnicą, że nadal są nawrotu, dopóki nie będą mogły zagwarantować, że wystąpiły najdłuższe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="62e15-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="62e15-124">W efekcie aparat NFA systemu POSIX jest wolniejszy niż tradycyjny aparat NFA i w przypadku korzystania z aparatu NFA POSIX nie można preferować krótszego dopasowania przez zmianę kolejności wyszukiwania wycofywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="62e15-125">Tradycyjne aparaty NFA są preferowane przez programistów, ponieważ oferują większą kontrolę nad dopasowaniem ciągu niż aparaty DFA lub POSIX NFA.</span><span class="sxs-lookup"><span data-stu-id="62e15-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="62e15-126">Mimo że w najgorszym przypadku mogą one działać wolno, można przełączać je, aby znaleźć dopasowania w liniowym lub wieloznacznym czasie, używając wzorców, które zmniejszają niejasności i ograniczają wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="62e15-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="62e15-127">Innymi słowy, chociaż silniki NFAją wydajność wymiany dla mocy i elastyczności, w większości przypadków zapewnia ona akceptowalną wydajność, jeśli wyrażenie regularne jest dobrze zapisywane i unika przypadków, w których wycofywanie obniża wydajność.</span><span class="sxs-lookup"><span data-stu-id="62e15-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="62e15-128">Aby uzyskać informacje o tym, jak spadek wydajności spowodowany przez nadmierne wycofywanie i sposoby [rozłożenia wyrażenia](backtracking-in-regular-expressions.md)regularnego do obejść, zobacz wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="62e15-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="62e15-129">Możliwości aparatu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="62e15-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="62e15-130">Aby skorzystać z zalet tradycyjnego aparatu NFA, aparat wyrażeń regularnych .NET Framework zawiera kompletny zestaw konstrukcji umożliwiających programistom sterownie aparatem wycofywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="62e15-131">Konstrukcje te mogą służyć do szybszego znajdowania dopasowania lub w celu uzyskania określonych rozszerzeń dla innych.</span><span class="sxs-lookup"><span data-stu-id="62e15-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="62e15-132">Inne funkcje aparatu wyrażeń regularnych .NET Framework są następujące:</span><span class="sxs-lookup"><span data-stu-id="62e15-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="62e15-133">Kwantyfikatory opóźnione: `??` , `*?` , `+?` , `{` *n* `,` *m* `}?` .</span><span class="sxs-lookup"><span data-stu-id="62e15-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="62e15-134">Te konstrukcje informują aparat wycofywania, aby najpierw przeszukać minimalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="62e15-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="62e15-135">W przeciwieństwie do zwykłych kwantyfikatorów zachłanne spróbuj najpierw dopasować maksymalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="62e15-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="62e15-136">Poniższy przykład ilustruje różnicę między nimi.</span><span class="sxs-lookup"><span data-stu-id="62e15-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="62e15-137">Wyrażenie regularne dopasowuje zdanie kończące się na liczbie, a grupa przechwytywania jest przeznaczona do wyodrębnienia tej liczby.</span><span class="sxs-lookup"><span data-stu-id="62e15-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="62e15-138">Wyrażenie regularne `.+(\d+)\.` zawiera kwantyfikator zachłanne `.+` , które powoduje, że aparat wyrażeń regularnych przechwytuje tylko ostatnią cyfrę liczby.</span><span class="sxs-lookup"><span data-stu-id="62e15-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="62e15-139">Z kolei wyrażenie regularne `.+?(\d+)\.` zawiera kwantyfikator z opóźnieniem `.+?` , który powoduje, że aparat wyrażeń regularnych przechwytuje całą liczbę.</span><span class="sxs-lookup"><span data-stu-id="62e15-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="62e15-140">Wersje zachłanne i z opóźnieniem tego wyrażenia regularnego są zdefiniowane, jak pokazano w poniższej tabeli:</span><span class="sxs-lookup"><span data-stu-id="62e15-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="62e15-141">Wzorce</span><span class="sxs-lookup"><span data-stu-id="62e15-141">Pattern</span></span>|<span data-ttu-id="62e15-142">Opis</span><span class="sxs-lookup"><span data-stu-id="62e15-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="62e15-143">`.+`(kwantyfikator zachłanne)</span><span class="sxs-lookup"><span data-stu-id="62e15-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="62e15-144">Dopasowuje co najmniej jedno wystąpienie dowolnego znaku.</span><span class="sxs-lookup"><span data-stu-id="62e15-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="62e15-145">Powoduje to, że aparat wyrażeń regularnych dopasowuje cały ciąg, a następnie do nawrotu w razie potrzeby dopasowania do pozostałej części wzorca.</span><span class="sxs-lookup"><span data-stu-id="62e15-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="62e15-146">`.+?`(kwantyfikator opóźniony)</span><span class="sxs-lookup"><span data-stu-id="62e15-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="62e15-147">Dopasowuje co najmniej jedno wystąpienie dowolnego znaku, ale dopasowanie jak najmniejszej liczby.</span><span class="sxs-lookup"><span data-stu-id="62e15-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="62e15-148">Dopasowuje co najmniej jeden znak liczbowy i przypisuje go do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="62e15-149">Dopasowuje okres.</span><span class="sxs-lookup"><span data-stu-id="62e15-149">Match a period.</span></span>|

     <span data-ttu-id="62e15-150">Aby uzyskać więcej informacji na temat kwantyfikatorów z opóźnieniem, zobacz [Kwantyfikatory](quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-150">For more information about lazy quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="62e15-151">Pozytywne naprzód: `(?=` *Podwyrażenie* `)` .</span><span class="sxs-lookup"><span data-stu-id="62e15-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="62e15-152">Ta funkcja pozwala aparatowi wycofywania na powrót do tego samego miejsca w tekście po dopasowaniu podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="62e15-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="62e15-153">Jest to przydatne do wyszukiwania w całym tekście przez zweryfikowanie wielu wzorców, które zaczynają się od tego samego położenia.</span><span class="sxs-lookup"><span data-stu-id="62e15-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="62e15-154">Umożliwia także aparatowi sprawdzenie, czy podciąg istnieje na końcu dopasowania bez uwzględniania podciągu w dopasowanym tekście.</span><span class="sxs-lookup"><span data-stu-id="62e15-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="62e15-155">W poniższym przykładzie użyto pozytywnego naprzód w celu wyodrębnienia wyrazów w zdaniu, które nie poprzedzają symboli interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="62e15-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="62e15-156">Wyrażenie regularne `\b[A-Z]+\b(?=\P{P})` jest zdefiniowane, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="62e15-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="62e15-157">Wzorce</span><span class="sxs-lookup"><span data-stu-id="62e15-157">Pattern</span></span>|<span data-ttu-id="62e15-158">Opis</span><span class="sxs-lookup"><span data-stu-id="62e15-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="62e15-159">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="62e15-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="62e15-160">Dopasowuje dowolny znak alfabetyczny jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="62e15-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="62e15-161">Ponieważ <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> Metoda jest wywoływana z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcją, porównanie nie uwzględnia wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="62e15-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="62e15-162">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="62e15-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="62e15-163">Zapoznaj się z wyprzedzeniem, aby określić, czy następny znak jest symbolem interpunkcji.</span><span class="sxs-lookup"><span data-stu-id="62e15-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="62e15-164">Jeśli tak nie jest, dopasowanie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="62e15-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="62e15-165">Aby uzyskać więcej informacji na temat pozytywnych potwierdzeń z wyprzedzeniem, zobacz [Grouping konstrukcjes](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-165">For more information about positive lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="62e15-166">Ujemne naprzód: `(?!` *Podwyrażenie* `)` .</span><span class="sxs-lookup"><span data-stu-id="62e15-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="62e15-167">Ta funkcja dodaje możliwość dopasowania wyrażenia tylko w przypadku niepowodzenia dopasowania podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="62e15-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="62e15-168">Jest to wydajne w przypadku oczyszczania wyszukiwania, ponieważ często jest prostsze, aby podać wyrażenie dla przypadku, które należy wyeliminować niż wyrażenie dla przypadków, które muszą być uwzględnione.</span><span class="sxs-lookup"><span data-stu-id="62e15-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="62e15-169">Na przykład trudno jest napisać wyrażenie dla słów, które nie zaczynają się od "non".</span><span class="sxs-lookup"><span data-stu-id="62e15-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="62e15-170">W poniższym przykładzie zastosowano ujemne naprzód, aby je wykluczyć.</span><span class="sxs-lookup"><span data-stu-id="62e15-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="62e15-171">Wzorzec wyrażenia regularnego `\b(?!non)\w+\b` jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="62e15-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="62e15-172">Wzorce</span><span class="sxs-lookup"><span data-stu-id="62e15-172">Pattern</span></span>|<span data-ttu-id="62e15-173">Opis</span><span class="sxs-lookup"><span data-stu-id="62e15-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="62e15-174">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="62e15-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="62e15-175">Sprawdź w przód, aby upewnić się, że bieżący ciąg nie zaczyna się od "non".</span><span class="sxs-lookup"><span data-stu-id="62e15-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="62e15-176">W przeciwnym razie dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="62e15-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="62e15-177">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="62e15-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="62e15-178">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="62e15-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="62e15-179">Aby uzyskać więcej informacji na temat negatywnych potwierdzeń naprzód, zobacz [grupowanie konstrukcji](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-179">For more information about negative lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="62e15-180">Ocena warunkowa: `(?(` *wyrażenie* `)` *tak* `|` *nie* `)` i `(?(` *Nazwa* `)` *tak* `|` *nie* `)` , gdzie *wyrażenie* jest zgodne z wyrażeniem, *name* to nazwa grupy przechwytywania, *tak* jest ciąg do dopasowania, jeśli wyrażenie jest dopasowane lub *expression* *Nazwa* jest prawidłową, niepustą grupą, a *nie* jest wyrażeniem, które ma być zgodne, jeśli *wyrażenie* nie jest dopasowane lub *Nazwa* nie jest prawidłową, niepustą grupą przechwyconą.</span><span class="sxs-lookup"><span data-stu-id="62e15-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="62e15-181">Ta funkcja umożliwia aparatowi wyszukiwanie przy użyciu więcej niż jednego wzorca alternatywnego, w zależności od wyniku poprzedniego dopasowania podwyrażenia lub wyniku potwierdzeń o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="62e15-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="62e15-182">Pozwala to na bardziej wydajną postać odwołania, która pozwala na przykład dopasować Podwyrażenie w zależności od tego, czy poprzednie Podwyrażenie zostało dopasowane.</span><span class="sxs-lookup"><span data-stu-id="62e15-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="62e15-183">Wyrażenie regularne w poniższym przykładzie dopasowuje akapity, które są przeznaczone do użytku publicznego i wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="62e15-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="62e15-184">Akapity przeznaczone tylko do użytku wewnętrznego zaczynają się od `<PRIVATE>` tagu.</span><span class="sxs-lookup"><span data-stu-id="62e15-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="62e15-185">Wzorzec wyrażenia regularnego `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` używa oceny warunkowej do przypisywania zawartości akapitów przeznaczonych do użytku publicznego i wewnętrznych do oddzielania grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="62e15-186">Te akapity mogą być następnie obsługiwane inaczej.</span><span class="sxs-lookup"><span data-stu-id="62e15-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="62e15-187">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="62e15-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="62e15-188">Wzorce</span><span class="sxs-lookup"><span data-stu-id="62e15-188">Pattern</span></span>|<span data-ttu-id="62e15-189">Opis</span><span class="sxs-lookup"><span data-stu-id="62e15-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="62e15-190">Rozpocznij dopasowanie na początku wiersza.</span><span class="sxs-lookup"><span data-stu-id="62e15-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="62e15-191">Dopasowanie do zera lub jednego wystąpienia ciągu, `<PRIVATE>` po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="62e15-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="62e15-192">Przypisz dopasowanie do grupy przechwytywania o nazwie `Pvt` .</span><span class="sxs-lookup"><span data-stu-id="62e15-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="62e15-193">Jeśli `Pvt` Grupa przechwytywania istnieje, dopasowuje jedno lub więcej wystąpień jednego lub większej liczby znaków słowa, po których następuje zero lub jeden separator interpunkcji, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="62e15-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="62e15-194">Przypisz podciąg do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="62e15-195">Jeśli `Pvt` Grupa przechwytywania nie istnieje, dopasowuje jedno lub więcej wystąpień jednego lub większej liczby znaków słowa, po których następuje zero lub jeden separator interpunkcji, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="62e15-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="62e15-196">Przypisz podciąg do trzeciej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="62e15-197">Dopasowuje koniec wiersza lub koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="62e15-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="62e15-198">Aby uzyskać więcej informacji na temat oceny warunkowej, zobacz [konstrukcje warunkowe](alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-198">For more information about conditional evaluation, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="62e15-199">Definicje grup równoważenia: `(?<` *Name1* `-` *NAME2* `>` *subexpression* `)` .</span><span class="sxs-lookup"><span data-stu-id="62e15-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="62e15-200">Ta funkcja umożliwia aparatowi wyrażeń regularnych śledzenie zagnieżdżonych konstrukcji, takich jak nawiasy, otwierające i zamykające nawiasy klamrowe.</span><span class="sxs-lookup"><span data-stu-id="62e15-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="62e15-201">Aby zapoznać się z przykładem, zobacz [grupowanie konstrukcji](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-201">For an example, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="62e15-202">Grupy niepodzielne: `(?>` *Podwyrażenie* `)` .</span><span class="sxs-lookup"><span data-stu-id="62e15-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="62e15-203">Ta funkcja umożliwia aparatowi wycofywania w celu zagwarantowania, że Podwyrażenie dopasowuje tylko pierwsze dopasowanie znalezione dla tego podwyrażenia, tak jakby wyrażenie było uruchomione niezależnie od jego wyrażenia zawierającego.</span><span class="sxs-lookup"><span data-stu-id="62e15-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="62e15-204">Jeśli ta konstrukcja nie jest używana, wyszukiwanie wsteczne z większego wyrażenia może zmienić zachowanie podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="62e15-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="62e15-205">Na przykład wyrażenie regularne `(a+)\w` dopasowuje jeden lub więcej znaków "a", wraz ze znakiem słowa, które następuje po sekwencji znaków "a" i przypisuje sekwencję znaków "a" do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="62e15-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="62e15-206">Jednakże, jeśli końcowy znak ciągu wejściowego jest również "a", jest dopasowywany przez `\w` element języka i nie jest uwzględniony w przechwyconej grupie.</span><span class="sxs-lookup"><span data-stu-id="62e15-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="62e15-207">Wyrażenie regularne `((?>a+))\w` uniemożliwia takie zachowanie.</span><span class="sxs-lookup"><span data-stu-id="62e15-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="62e15-208">Ponieważ wszystkie kolejne znaki "a" są dopasowywane bez wycofywania, pierwsza grupa przechwytywania zawiera wszystkie kolejne znaki "a".</span><span class="sxs-lookup"><span data-stu-id="62e15-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="62e15-209">Jeśli po znaku "a" nie występuje co najmniej jeden znak inny niż "a", dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="62e15-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="62e15-210">Aby uzyskać więcej informacji na temat grup niepodzielnych, zobacz [Grouping konstrukcjes](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-210">For more information about atomic groups, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="62e15-211">Dopasowanie od prawej do lewej, które jest określone przez dostarczenie <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcji do <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub statycznej metody dopasowywania wystąpień.</span><span class="sxs-lookup"><span data-stu-id="62e15-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="62e15-212">Ta funkcja jest przydatna podczas wyszukiwania od prawej do lewej zamiast od lewej do prawej lub w przypadkach, gdy jest bardziej wydajna, aby zacząć dopasowywanie do prawej części wzorca zamiast z lewej strony.</span><span class="sxs-lookup"><span data-stu-id="62e15-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="62e15-213">Jak pokazano na poniższym przykładzie, użycie dopasowania od prawej do lewej może zmienić zachowanie kwantyfikatorów zachłanne.</span><span class="sxs-lookup"><span data-stu-id="62e15-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="62e15-214">Przykład wykonuje dwa wyszukiwania zdania kończącego się na liczbie.</span><span class="sxs-lookup"><span data-stu-id="62e15-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="62e15-215">Wyszukiwanie od lewej do prawej, które używa kwantyfikatora zachłanne `+` , dopasowuje jeden z sześciu cyfr w zdaniu, podczas gdy wyszukiwanie od prawej do lewej jest zgodne ze wszystkimi sześcioma cyframi.</span><span class="sxs-lookup"><span data-stu-id="62e15-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="62e15-216">Aby uzyskać opis wzorca wyrażenia regularnego, zobacz przykład, który ilustruje liczbę kwantyfikatorów opóźnionych wcześniej w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="62e15-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="62e15-217">Aby uzyskać więcej informacji na temat dopasowywania do prawej strony, zobacz [Opcje wyrażenia regularnego](regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-217">For more information about right-to-left matching, see [Regular Expression Options](regular-expression-options.md).</span></span>

- <span data-ttu-id="62e15-218">Pozytywne i ujemne asercja wsteczna: `(?<=` *Podwyrażenie* `)` dla pozytywnej asercja wsteczna i `(?<!` *Podwyrażenie* `)` dla negatywnej asercja wsteczna.</span><span class="sxs-lookup"><span data-stu-id="62e15-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="62e15-219">Ta funkcja jest podobna do wyprzedzenia, która została omówiona wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="62e15-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="62e15-220">Ponieważ aparat wyrażeń regularnych umożliwia pełne dopasowywanie do prawej strony, wyrażenia regularne zezwalają na nieograniczony lookbehinds.</span><span class="sxs-lookup"><span data-stu-id="62e15-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="62e15-221">Można również użyć asercja wsteczna pozytywnej i ujemnej, aby uniknąć zagnieżdżania kwantyfikatorów, gdy zagnieżdżone Podwyrażenie jest nadzbiorem wyrażenia zewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="62e15-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="62e15-222">Wyrażenia regularne z takimi kwantyfikatorami zagnieżdżonymi często zapewniają niską wydajność.</span><span class="sxs-lookup"><span data-stu-id="62e15-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="62e15-223">Na przykład poniższy przykład sprawdza, czy ciąg rozpoczyna się i zamyka znak alfanumeryczny, a każdy inny znak w ciągu jest jednym z większego podzbioru.</span><span class="sxs-lookup"><span data-stu-id="62e15-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="62e15-224">Stanowi część wyrażenia regularnego służącego do sprawdzania poprawności adresów e-mail. Aby uzyskać więcej informacji, zobacz [How to: Verify, czy ciągi są w prawidłowym formacie poczty e-mail](how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="62e15-225">Wyrażenie regularne ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` jest zdefiniowane, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="62e15-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="62e15-226">Wzorce</span><span class="sxs-lookup"><span data-stu-id="62e15-226">Pattern</span></span>|<span data-ttu-id="62e15-227">Opis</span><span class="sxs-lookup"><span data-stu-id="62e15-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="62e15-228">Rozpocznij dopasowanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="62e15-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="62e15-229">Dopasowuje dowolny znak liczbowy lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="62e15-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="62e15-230">(W porównaniu z rozróżnianiem wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="62e15-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="62e15-231">Dopasowuje zero lub więcej wystąpień dowolnego znaku słowa albo dowolnego z następujących znaków:-,!, #, $,%, &, ",., \* , +,/, =,?, ^, &#96;, {,}, &#124; lub ~.</span><span class="sxs-lookup"><span data-stu-id="62e15-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="62e15-232">Odszukaj w powyższym znaku, który musi być numeryczny lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="62e15-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="62e15-233">(W porównaniu z rozróżnianiem wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="62e15-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="62e15-234">Zakończ dopasowanie na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="62e15-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="62e15-235">Aby uzyskać więcej informacji na temat pozytywnych i negatywnych asercja wsteczna, zobacz [Grouping konstrukcjes](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="62e15-235">For more information about positive and negative lookbehind, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="62e15-236">Pokrewne artykuły:</span><span class="sxs-lookup"><span data-stu-id="62e15-236">Related articles</span></span>

|<span data-ttu-id="62e15-237">Tytuł</span><span class="sxs-lookup"><span data-stu-id="62e15-237">Title</span></span>|<span data-ttu-id="62e15-238">Opis</span><span class="sxs-lookup"><span data-stu-id="62e15-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="62e15-239">Nawracanie</span><span class="sxs-lookup"><span data-stu-id="62e15-239">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="62e15-240">Zawiera informacje dotyczące sposobu, w jaki rozgałęzienia wyrażenia regularnego do znajdowania alternatywnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="62e15-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="62e15-241">Kompilacja i ponowne użycie</span><span class="sxs-lookup"><span data-stu-id="62e15-241">Compilation and Reuse</span></span>](compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="62e15-242">Zawiera informacje dotyczące kompilowania i ponownego używania wyrażeń regularnych w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="62e15-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="62e15-243">Bezpieczeństwo wątkowe</span><span class="sxs-lookup"><span data-stu-id="62e15-243">Thread Safety</span></span>](thread-safety-in-regular-expressions.md)|<span data-ttu-id="62e15-244">Zawiera informacje na temat bezpieczeństwa wątku wyrażeń regularnych i wyjaśnia, kiedy należy synchronizować dostęp do obiektów wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="62e15-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="62e15-245">.NET Framework — Wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="62e15-245">.NET Framework Regular Expressions</span></span>](regular-expressions.md)|<span data-ttu-id="62e15-246">Zawiera omówienie aspektu języka programowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="62e15-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="62e15-247">Model obiektów wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="62e15-247">The Regular Expression Object Model</span></span>](the-regular-expression-object-model.md)|<span data-ttu-id="62e15-248">Zawiera informacje i przykłady kodu ilustrujące sposób użycia klas wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="62e15-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="62e15-249">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="62e15-249">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="62e15-250">Zawiera informacje dotyczące zestawu znaków, operatorów i konstrukcji, których można użyć do definiowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="62e15-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="62e15-251">Tematy pomocy</span><span class="sxs-lookup"><span data-stu-id="62e15-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
