---
title: "Szczegóły zachowania dotyczącego wyrażeń regularnych"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: c574ab8ddf506802fb42f53b5212dcb4a3bd9d34
ms.sourcegitcommit: cf22b29db780e532e1090c6e755aa52d28273fa6
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/01/2018
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="0b464-102">Szczegóły zachowania dotyczącego wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="0b464-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="0b464-103">Aparat wyrażenia regularnego programu .NET Framework jest backtracking dopasowania wyrażenia regularnego, uwzględniająca tradycyjnych aparat niedeterministyczne skończoną Automaton ds takim Perl, Python, Emacs i Tcl.</span><span class="sxs-lookup"><span data-stu-id="0b464-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="0b464-104">To odróżnia go od szybsze, ale bardziej ograniczone, czysty wyrażenia regularnego aparaty deterministyczne Automaton ograniczone (DFA) takich jak awk, egrep lub lex.</span><span class="sxs-lookup"><span data-stu-id="0b464-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="0b464-105">Ma to również odróżniać z znormalizowanych, ale wolniej, POSIX NFAs.</span><span class="sxs-lookup"><span data-stu-id="0b464-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="0b464-106">Poniższej sekcji opisano trzy typy aparatów wyrażenia regularnego i objaśniono, dlaczego wyrażeń regularnych w programie .NET Framework są implementowane przy użyciu tradycyjnych aparat NFA.</span><span class="sxs-lookup"><span data-stu-id="0b464-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="0b464-107">Korzyści wynikające z aparatu NFA</span><span class="sxs-lookup"><span data-stu-id="0b464-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="0b464-108">Podczas dopasowywania do wzorca aparaty DFA, ich kolejność przetwarzania jest wymuszany przez ciąg wejściowy.</span><span class="sxs-lookup"><span data-stu-id="0b464-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="0b464-109">Aparat zaczyna się od początku ciągu wejściowego i będzie kontynuowana sekwencyjnie, aby określić, czy następny znak jest zgodny ze wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="0b464-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="0b464-110">Gwarantują można zgodny z ciągiem najdłuższym możliwe.</span><span class="sxs-lookup"><span data-stu-id="0b464-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="0b464-111">Ponieważ nigdy nie sprawdzają one ten sam znak dwa razy, aparaty DFA nie obsługują śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="0b464-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="0b464-112">Jednak ponieważ aparat DFA zawiera tylko skończoną stanu, nie można dopasować wzorca zawierającego odwołania wstecznego, a ponieważ go nie skonstruować jawne rozszerzenie, zakresie nie przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="0b464-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="0b464-113">W odróżnieniu od aparaty DFA tradycyjnych NFA aparatów wykonywania dopasowywania do wzorca ich kolejność przetwarzania jest wymuszany przez wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="0b464-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="0b464-114">Podczas przetwarzania elementu konkretnego języka, aparat używa intensywnie dopasowania; oznacza to, że jest on zgodny tyle ciąg wejściowy jako prawdopodobnie można.</span><span class="sxs-lookup"><span data-stu-id="0b464-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="0b464-115">Jednak również zapisuje swój stan po pomyślnie dopasowywania podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="0b464-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="0b464-116">Jeśli dopasowanie ostatecznie zakończy się niepowodzeniem, aparat można powrócić do zapisanego stanu, można spróbować dodatkowe dopasowań.</span><span class="sxs-lookup"><span data-stu-id="0b464-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="0b464-117">Porzucanie dopasowanie pomyślnie Podwyrażenie tak, aby nowsze elementy języka w wyrażeniu regularnym może być również zgodna ten proces nazywa się *śledzenie wsteczne*.</span><span class="sxs-lookup"><span data-stu-id="0b464-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="0b464-118">Aparaty NFA umożliwia śledzenie wsteczne przetestować wszystkie możliwe rozszerzenia wyrażeń regularnych w określonej kolejności i zaakceptuj pierwsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="0b464-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="0b464-119">Ponieważ tradycyjnych aparat NFA konstruuje rozwinięciem określonego wyrażenia regularnego dopasowanie się pomyślnie, go przechwycić dopasowań Podwyrażenie i pasującego odwołania wstecznego.</span><span class="sxs-lookup"><span data-stu-id="0b464-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="0b464-120">Jednak ponieważ tradycyjnych NFA zapoznawanie, jego mogą odwiedzać takim samym stanie wielokrotnie jeśli dociera stan przez różne ścieżki.</span><span class="sxs-lookup"><span data-stu-id="0b464-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="0b464-121">W związku z tym można go uruchomić wykładniczo powoli w najgorszym przypadku.</span><span class="sxs-lookup"><span data-stu-id="0b464-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="0b464-122">Ponieważ tradycyjnych aparat NFA akceptuje pierwszy znalezione dopasowanie, można także pozostawić innych niewykrytych dopasowań (prawdopodobnie dłużej).</span><span class="sxs-lookup"><span data-stu-id="0b464-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="0b464-123">Aparaty POSIX NFA przypominają tradycyjnych aparaty NFA, z tą różnicą, że nadal śledzenie wsteczne, dopóki nie może zagwarantować, że zostały uznane najdłuższe dopasowanie możliwe.</span><span class="sxs-lookup"><span data-stu-id="0b464-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="0b464-124">W związku z tym aparat POSIX NFA jest mniejsza niż tradycyjne aparat NFA i korzystając z aparatu POSIX NFA, za pośrednictwem dłużej jeden, zmieniając ich kolejność wyszukiwania backtracking nie Preferuj krótszą dopasowania.</span><span class="sxs-lookup"><span data-stu-id="0b464-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="0b464-125">Tradycyjny aparaty NFA są ich drużyna jest faworytem przez programistów ponieważ oferują one większą kontrolę nad ciąg dopasowania niż aparaty DFA lub POSIX NFA.</span><span class="sxs-lookup"><span data-stu-id="0b464-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="0b464-126">Mimo że w najgorszym przypadku mogą uruchamiać powoli, można je, aby znaleźć dopasowań w czasie liniowego lub wielomianu za pomocą wzorców, które zmniejszyć niejednoznaczności i ograniczyć śledzenie wsteczne kierowania.</span><span class="sxs-lookup"><span data-stu-id="0b464-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="0b464-127">Innymi słowy mimo że aparaty NFA handlu wydajność możliwościach i elastyczności, w większości przypadków oferują dobrej na akceptowalną wydajność, jeśli wyrażenie regularne jest dobrze napisane i pozwala uniknąć przypadkach, w których śledzenie wsteczne powoduje spadek wydajności wykładniczo.</span><span class="sxs-lookup"><span data-stu-id="0b464-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0b464-128">Informacje o spadek wydajności spowodowany nadmiernym wykorzystaniem algorytmu wycofywania i sposoby sformułować wyrażenia regularnego do nich obejść, zobacz [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="0b464-129">Możliwości aparatu programu .NET framework</span><span class="sxs-lookup"><span data-stu-id="0b464-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="0b464-130">Aby skorzystać z zalet tradycyjnych aparat NFA, aparatu wyrażeń regularnych programu .NET Framework zawiera kompletny zestaw konstrukcji umożliwiają deweloperom kierowania backtracking aparatu.</span><span class="sxs-lookup"><span data-stu-id="0b464-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="0b464-131">Tych konstrukcji można odnaleźć dopasowań szybciej lub preferować rozszerzenia określonych przez innych użytkowników.</span><span class="sxs-lookup"><span data-stu-id="0b464-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="0b464-132">Inne funkcje aparatu wyrażeń regularnych programu .NET Framework są następujące:</span><span class="sxs-lookup"><span data-stu-id="0b464-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
-   <span data-ttu-id="0b464-133">Kwantyfikatory opóźniające: `??`, `*?`, `+?`, `{`  *n*  `,` *m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="0b464-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="0b464-134">Te konstrukcje Poinformuj backtracking aparat wyszukiwania z minimalną liczbą powtórzeń najpierw.</span><span class="sxs-lookup"><span data-stu-id="0b464-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="0b464-135">Z kolei zwykłej Kwantyfikatory intensywnie spróbuj odpowiadające maksymalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="0b464-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="0b464-136">Poniższy przykład przedstawia różnice między nimi.</span><span class="sxs-lookup"><span data-stu-id="0b464-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="0b464-137">Wyrażenie regularne dopasowuje zdania, które kończy się liczbą i przechwytywania grupy jest przeznaczony do wyodrębnienia ten numer.</span><span class="sxs-lookup"><span data-stu-id="0b464-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="0b464-138">Wyrażenie regularne `.+(\d+)\.` obejmuje intensywnie kwantyfikatora `.+`, co powoduje, że aparat wyrażeń regularnych do przechwytywania tylko ostatnich cyfr numeru.</span><span class="sxs-lookup"><span data-stu-id="0b464-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="0b464-139">Z drugiej strony, wyrażenie regularne `.+?(\d+)\.` obejmuje opóźnieniem kwantyfikatora `.+?`, co powoduje, że aparat wyrażeń regularnych do przechwytywania całą liczbę.</span><span class="sxs-lookup"><span data-stu-id="0b464-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="0b464-140">Wersje intensywnie i opóźnieniem tego wyrażenia regularnego są zdefiniowane zgodnie z poniższą tabelą. "</span><span class="sxs-lookup"><span data-stu-id="0b464-140">The greedy and lazy versions of this regular expression are defined as shown in the following table.\`</span></span>  
  
    |<span data-ttu-id="0b464-141">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="0b464-141">Pattern</span></span>|<span data-ttu-id="0b464-142">Opis</span><span class="sxs-lookup"><span data-stu-id="0b464-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="0b464-143">`.+`(intensywnie kwantyfikatora)</span><span class="sxs-lookup"><span data-stu-id="0b464-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="0b464-144">Zgodne z co najmniej jednego wystąpienia dowolnego znaku.</span><span class="sxs-lookup"><span data-stu-id="0b464-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="0b464-145">Powoduje to, że aparat wyrażenia regularnego do dopasowania cały ciąg, a następnie Aby cofnąć jako potrzebne do pozostałej części wzorca dopasowania.</span><span class="sxs-lookup"><span data-stu-id="0b464-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="0b464-146">`.+?`(tzw)</span><span class="sxs-lookup"><span data-stu-id="0b464-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="0b464-147">Dopasować co najmniej jedno wystąpienie dowolny znak, ale odpowiadać jak kupić.</span><span class="sxs-lookup"><span data-stu-id="0b464-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="0b464-148">Zgodne z co najmniej jednego znaku numerycznego i przypisz je do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="0b464-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="0b464-149">Odpowiada danym okresie.</span><span class="sxs-lookup"><span data-stu-id="0b464-149">Match a period.</span></span>|  
  
     <span data-ttu-id="0b464-150">Aby uzyskać więcej informacji na temat Kwantyfikatory opóźniające, zobacz [Kwantyfikatory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="0b464-151">Dodatnia wyprzedzenia: `(?=` *Podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="0b464-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="0b464-152">Ta funkcja umożliwia backtracking aparatu powrócić do tego samego miejsca w tekście po odpowiadającym podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="0b464-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="0b464-153">Jest to przydatne w przypadku wyszukiwania w całym tekście weryfikując wielu wzorców, uruchamianych z tej samej pozycji.</span><span class="sxs-lookup"><span data-stu-id="0b464-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="0b464-154">Umożliwia także aparat Sprawdź, czy podciągu istnieje na końcu dopasowania, bez uwzględniania podciąg w tekście dopasowany.</span><span class="sxs-lookup"><span data-stu-id="0b464-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="0b464-155">W poniższym przykładzie użyto wyprzedzenia dodatnią, aby wyodrębnić wyrazów w zdaniu, które nie są wykonywane przez znaki interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="0b464-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="0b464-156">Wyrażenie regularne `\b[A-Z]+\b(?=\P{P})` jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0b464-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="0b464-157">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="0b464-157">Pattern</span></span>|<span data-ttu-id="0b464-158">Opis</span><span class="sxs-lookup"><span data-stu-id="0b464-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="0b464-159">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="0b464-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="0b464-160">Dopasowuje dowolny znak alfabetyczne jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="0b464-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="0b464-161">Ponieważ <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metoda jest wywoływana z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcja porównanie jest rozróżniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="0b464-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="0b464-162">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="0b464-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="0b464-163">Wyszukiwać czy następny znak jest symbol interpunkcyjny.</span><span class="sxs-lookup"><span data-stu-id="0b464-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="0b464-164">Jeśli nie jest, dopasowania zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0b464-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="0b464-165">Aby uzyskać więcej informacji na temat potwierdzenia dodatnią wyprzedzenia zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="0b464-166">Ujemna wyprzedzenia: `(?!` *Podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="0b464-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="0b464-167">Ta funkcja dodaje możliwość pasuje do wyrażenia tylko wtedy, gdy Podwyrażenie nie odpowiada.</span><span class="sxs-lookup"><span data-stu-id="0b464-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="0b464-168">Jest to szczególnie wydajna do usunięcia wyszukiwania, ponieważ często jest prostsze zapewnienie wyrażenia dla przypadek, który powinien zostać usunięte niż wyrażenia dla przypadków, które muszą być włączone.</span><span class="sxs-lookup"><span data-stu-id="0b464-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="0b464-169">Na przykład jest trudne do wyrażenia słowa, które nie rozpoczynają się "nie".</span><span class="sxs-lookup"><span data-stu-id="0b464-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="0b464-170">W poniższym przykładzie użyto wyprzedzenia ujemna, aby wykluczyć je.</span><span class="sxs-lookup"><span data-stu-id="0b464-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="0b464-171">Wzorzec wyrażenia regularnego `\b(?!non)\w+\b` jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0b464-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="0b464-172">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="0b464-172">Pattern</span></span>|<span data-ttu-id="0b464-173">Opis</span><span class="sxs-lookup"><span data-stu-id="0b464-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="0b464-174">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="0b464-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="0b464-175">Szukaj dalej, aby upewnić się, że bieżący ciąg nie zaczyna się od "nie".</span><span class="sxs-lookup"><span data-stu-id="0b464-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="0b464-176">Jeśli tak, dopasowania kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="0b464-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="0b464-177">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="0b464-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="0b464-178">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="0b464-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="0b464-179">Aby uzyskać więcej informacji o potwierdzenia wyprzedzenia ujemna, zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="0b464-180">Ocena warunkowe: `(?(` *wyrażenie*`)`*tak*`|`*nie* `)` i `(?(` *nazwa*`)`*tak*`|`*nie*`)`, gdzie *wyrażenie* jest Podwyrażenie do dopasowania, *nazwa* jest nazwą grupy przechwytywania *tak* ciągu do dopasowania, jeśli jest *wyrażenie* dopasowaniu lub *nazwa* jest prawidłowy, pusty przechwyconej grupy i *nie* Podwyrażenie do dopasowania, jeśli jest *wyrażenia* jest niezgodne lub *nazwa* nie jest prawidłowe, niepuste pole przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="0b464-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="0b464-181">Ta funkcja umożliwia aparat wyszukiwania przy użyciu więcej niż jeden wzorzec alternatywne, w zależności od wyniku poprzedniego dopasowania Podwyrażenie lub wynik potwierdzenia zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="0b464-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="0b464-182">Umożliwia to bardziej zaawansowanych formę dopasowań, która pozwala na przykład dopasowywania podwyrażenia oparte na czy poprzedniej Podwyrażenie został uzyskany.</span><span class="sxs-lookup"><span data-stu-id="0b464-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="0b464-183">Wyrażenie regularne w poniższym przykładzie dopasowuje akapitów, które są przeznaczone dla publicznych i wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="0b464-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="0b464-184">Zaczynać akapitów przeznaczone tylko do użytku wewnętrznego `<PRIVATE>` tagu.</span><span class="sxs-lookup"><span data-stu-id="0b464-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="0b464-185">Wzorzec wyrażenia regularnego `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` używa warunkowego oceny można przypisać zawartość akapitów przeznaczonych do publicznego do użytku wewnętrznego oddzielić grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="0b464-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="0b464-186">Te akapitów następnie mogą być obsługiwane inaczej.</span><span class="sxs-lookup"><span data-stu-id="0b464-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="0b464-187">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0b464-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="0b464-188">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="0b464-188">Pattern</span></span>|<span data-ttu-id="0b464-189">Opis</span><span class="sxs-lookup"><span data-stu-id="0b464-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="0b464-190">Rozpocznij dopasowania na początku wiersza.</span><span class="sxs-lookup"><span data-stu-id="0b464-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="0b464-191">Zgodne zero lub jeden wystąpienie ciągu `<PRIVATE>` następuje biały znak.</span><span class="sxs-lookup"><span data-stu-id="0b464-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="0b464-192">Przypisz dopasowania do przechwytywania grupę o nazwie `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="0b464-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="0b464-193">Jeśli `Pvt` Przechwytywanie grupy istnieje, zgodne z jednego lub więcej wystąpień co najmniej jeden znak słowa następuje zero lub jeden separatora znaki interpunkcyjne, następuje biały znak.</span><span class="sxs-lookup"><span data-stu-id="0b464-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="0b464-194">Przypisz podciąg do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="0b464-194">Assign the substring to the first capturing group.</span></span>|  
    |`&#124;((\w+\p{P}?\s)+))`|<span data-ttu-id="0b464-195">Jeśli `Pvt` Przechwytywanie grupa nie istnieje, pasuje do jednej lub więcej wystąpień co najmniej jeden znak słowa następuje zero lub jeden separatora znaki interpunkcyjne, następuje biały znak.</span><span class="sxs-lookup"><span data-stu-id="0b464-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="0b464-196">Przypisz podciąg do trzeciego grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="0b464-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="0b464-197">Zgodne koniec wiersza lub końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="0b464-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="0b464-198">Aby uzyskać więcej informacji na temat oceny warunkowego zobacz [konstrukcje Alternacyjne](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="0b464-199">Równoważenie definicje grup: `(?<` *Nazwa1*`-`*Nazwa2* `>` *Podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="0b464-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="0b464-200">Ta funkcja umożliwia aparat wyrażeń regularnych do śledzenia zagnieżdżonych elementów składowych, takich jak nawiasy lub otwierające i zamykające nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="0b464-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="0b464-201">Na przykład zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="0b464-202">Użyto nonbacktracking (znanej także jako intensywnie użyto): `(?>` *Podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="0b464-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="0b464-203">Ta funkcja umożliwia aparat backtracking zagwarantowanie, czy Podwyrażenie jest zgodna tylko pierwszego dopasowania znaleziono dla tego podwyrażenia tak, jakby wyrażenie, które były uruchomione niezależnie od jej zawierające wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="0b464-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="0b464-204">Jeśli ta konstrukcja nie jest używany, śledzenie wsteczne wyszukiwania z większego wyrażenia można zmienić to zachowanie podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="0b464-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="0b464-205">Na przykład, wyrażenie regularne `(a+)\w` odpowiada co najmniej jeden "" znaków, wraz z literą, sekwencja znaków "", i przypisuje sekwencja znaków "" do pierwszej grupy przechwytywania, jednak, jeśli ostatni znak Ciąg wejściowy jest również "," it równoważona `\w` element języka, a nie jest uwzględniony w przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="0b464-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="0b464-206">Wyrażenie regularne `((?>a+))\w` zapobiega to zachowanie.</span><span class="sxs-lookup"><span data-stu-id="0b464-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="0b464-207">Ponieważ wszystkich kolejnych znaków "" są dopasowywane bez śledzenie wsteczne, pierwsza grupa Przechwytywanie obejmuje wszystkie kolejne znaki "".</span><span class="sxs-lookup"><span data-stu-id="0b464-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="0b464-208">Jeśli znaki "", nie zostaną wykonane przez co najmniej jeden znak więcej niż "", dopasowania kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="0b464-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="0b464-209">Aby uzyskać więcej informacji o zakresie nonbacktracking, zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="0b464-210">Prawo do lewej dopasowania, które jest określone, podając <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcji w celu <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub statyczna metoda zgodnego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="0b464-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="0b464-211">Ta funkcja jest przydatna podczas wyszukiwania od prawej do lewej strony zamiast od lewej do prawej lub w przypadkach, gdy jest bardziej wydajne, aby rozpocząć dopasowania w prawej części wzorca zamiast po lewej stronie.</span><span class="sxs-lookup"><span data-stu-id="0b464-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="0b464-212">Jak pokazano w poniższym przykładzie, zachowanie intensywnie Kwantyfikatory można zmieniać za pomocą dopasowywania od prawej do lewej.</span><span class="sxs-lookup"><span data-stu-id="0b464-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="0b464-213">Przykład prowadzi dwóch wyszukuje zdania, które kończy się liczbą.</span><span class="sxs-lookup"><span data-stu-id="0b464-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="0b464-214">Wyszukiwanie od lewej do prawej, które używa intensywnie kwantyfikatora `+` zgodny z jednym z sześciu cyfr w zdaniu, natomiast wyszukiwanie od prawej do lewej dopasowuje wszystkie sześć cyfr.</span><span class="sxs-lookup"><span data-stu-id="0b464-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="0b464-215">Aby uzyskać opis wzorzec wyrażenia regularnego Zobacz przykład ilustrujący Kwantyfikatory opóźniające we wcześniejszej części tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="0b464-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="0b464-216">Aby uzyskać więcej informacji na temat dopasowywania od prawej do lewej, zobacz [opcje wyrażeń regularnych](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
-   <span data-ttu-id="0b464-217">Dodatnie i ujemne wybieganie wstecz: `(?<=` *Podwyrażenie* `)` dla dodatnie wybieganie wstecz, i `(?<!` *Podwyrażenie* `)` dla ujemne wybieganie wstecz.</span><span class="sxs-lookup"><span data-stu-id="0b464-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="0b464-218">Ta funkcja jest podobny do wyprzedzenia, który został omówiony wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="0b464-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="0b464-219">Ponieważ aparat wyrażeń regularnych umożliwia pełne dopasowanie od prawej do lewej, wyrażenia regularne umożliwiają nieograniczony wybieganie wstecz.</span><span class="sxs-lookup"><span data-stu-id="0b464-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="0b464-220">Dodatnie i ujemne wybieganie wstecz można także uniknąć zagnieżdżenia Kwantyfikatory zagnieżdżonych Podwyrażenie jest nadzbiorem zewnętrzne wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="0b464-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="0b464-221">Wyrażenia regularne z takich kwantyfikatorami zagnieżdżonymi często oferują pogorszenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0b464-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="0b464-222">Na przykład poniższy przykład sprawdza, czy ciąg rozpoczyna się i kończy się znakiem alfanumerycznym i innych znaków w ciągu jest jedną z podzbioru większy.</span><span class="sxs-lookup"><span data-stu-id="0b464-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="0b464-223">Stanowi ona część wyrażenie regularne służące do sprawdzania poprawności adresów e-mail; Aby uzyskać więcej informacji, zobacz [porady: Sprawdź, czy ciągów jest prawidłowy Format wiadomości E-mail](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="0b464-224">Wyrażenie regularne `^[A-Z0-9]([-!#$%&'.*+/=?^`{} | ~ \w])* (? < = [A-Z0-9]) $"jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0b464-224">The regular expression `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])\*(?<=[A-Z0-9])$\` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="0b464-225">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="0b464-225">Pattern</span></span>|<span data-ttu-id="0b464-226">Opis</span><span class="sxs-lookup"><span data-stu-id="0b464-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="0b464-227">Rozpocznij dopasowania na początku ciąg.</span><span class="sxs-lookup"><span data-stu-id="0b464-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="0b464-228">Dopasowuje dowolny znak numeryczne lub alfanumeryczne.</span><span class="sxs-lookup"><span data-stu-id="0b464-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="0b464-229">(Porównanie jest bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="0b464-229">(The comparison is case-insensitive.)</span></span>|  
    |<span data-ttu-id="0b464-230">`([-!#$%&'.*+/=?^`{}&#124;~\w])\*\`</span><span class="sxs-lookup"><span data-stu-id="0b464-230">`([-!#$%&'.*+/=?^`{}&#124;~\w])\*\`</span></span>|<span data-ttu-id="0b464-231">Zgodne zero lub więcej wystąpień dowolny znak słowa lub dowolny z następujących znaków:-,!, #, $, % &, ',., \*, +, /, =,?, ^, ", {,}, &#124; lub ~.</span><span class="sxs-lookup"><span data-stu-id="0b464-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, \`, {, }, &#124;, or ~.</span></span>|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="0b464-232">Szukaj za do poprzedniego znaku, który musi być numeryczne lub alfanumeryczne.</span><span class="sxs-lookup"><span data-stu-id="0b464-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="0b464-233">(Porównanie jest bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="0b464-233">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="0b464-234">Zakończenie dopasowuje koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="0b464-234">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="0b464-235">Aby uzyskać więcej informacji na temat dodatnie i ujemne wybieganie wstecz, zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0b464-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="0b464-236">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="0b464-236">Related Topics</span></span>  
  
|<span data-ttu-id="0b464-237">Tytuł</span><span class="sxs-lookup"><span data-stu-id="0b464-237">Title</span></span>|<span data-ttu-id="0b464-238">Opis</span><span class="sxs-lookup"><span data-stu-id="0b464-238">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="0b464-239">Śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="0b464-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="0b464-240">Zawiera informacje dotyczące sposobu wyrażenie_regularne śledzenie wsteczne gałęzie, które mają znaleźć alternatywne dopasowania.</span><span class="sxs-lookup"><span data-stu-id="0b464-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="0b464-241">Kompilacja i ponowne używanie</span><span class="sxs-lookup"><span data-stu-id="0b464-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="0b464-242">Zawiera informacje dotyczące kompilowania i ponowne używanie wyrażeń regularnych w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="0b464-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="0b464-243">Bezpieczeństwo wątków</span><span class="sxs-lookup"><span data-stu-id="0b464-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="0b464-244">Zawiera informacje o bezpieczeństwo wątków wyrażenia regularnego wraz z wyjaśnieniem, kiedy należy synchronizować dostęp do obiektów wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="0b464-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="0b464-245">.NET framework — nieprawidłowe wyrażenia</span><span class="sxs-lookup"><span data-stu-id="0b464-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="0b464-246">Omówienie programowania aspekt język wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="0b464-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="0b464-247">Model obiektów wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="0b464-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="0b464-248">Zawiera informacje i przykłady kodu, pokazujący sposób użycia klasy wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="0b464-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="0b464-249">Przykłady wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="0b464-249">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="0b464-250">Zawiera przykłady kodu, ilustrujące używanie wyrażeń regularnych w typowych zastosowań.</span><span class="sxs-lookup"><span data-stu-id="0b464-250">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="0b464-251">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="0b464-251">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="0b464-252">Zawiera informacje o zestawie znaków, Operatorzy i konstrukcji, których można użyć do zdefiniowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="0b464-252">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="0b464-253">Tematy pomocy</span><span class="sxs-lookup"><span data-stu-id="0b464-253">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
