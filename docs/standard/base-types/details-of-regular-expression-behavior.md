---
title: Zachowanie wyrażenia regularnego
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 0273d16028315452e35f83086dbc134d6fcb66c6
ms.sourcegitcommit: 1c1a1f9ec0bd1efb3040d86a79f7ee94e207cca5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/03/2020
ms.locfileid: "80635987"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="003ad-102">Szczegóły zachowania wyrażenia regularnego</span><span class="sxs-lookup"><span data-stu-id="003ad-102">Details of regular expression behavior</span></span>

<span data-ttu-id="003ad-103">Aparat wyrażeń regularnych .NET Framework jest backtracking matcher wyrażenia regularnego, który zawiera tradycyjne nondeterministic Skończony Automaton (NFA) aparat, takich jak używane przez Perl, Python, Emacs i Tcl.</span><span class="sxs-lookup"><span data-stu-id="003ad-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="003ad-104">To odróżnia go od szybszych, ale bardziej ograniczonych, czystych ekspresji regularnej Deterministic Finite Automaton (DFA) silników, takich jak te znalezione w awk, egrep lub lex.</span><span class="sxs-lookup"><span data-stu-id="003ad-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="003ad-105">To również odróżnia go od standardowych, ale wolniej, POSIX NFA.</span><span class="sxs-lookup"><span data-stu-id="003ad-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="003ad-106">W poniższej sekcji opisano trzy typy aparatów wyrażeń regularnych i wyjaśniono, dlaczego wyrażenia regularne w .NET Framework są implementowane przy użyciu tradycyjnego aparatu NFA.</span><span class="sxs-lookup"><span data-stu-id="003ad-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="003ad-107">Zalety silnika NFA</span><span class="sxs-lookup"><span data-stu-id="003ad-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="003ad-108">Gdy aparaty DFA wykonać dopasowanie wzorca, ich kolejność przetwarzania jest napędzany przez ciąg wejściowy.</span><span class="sxs-lookup"><span data-stu-id="003ad-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="003ad-109">Aparat rozpoczyna się na początku ciągu wejściowego i przechodzi sekwencyjnie, aby określić, czy następny znak pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="003ad-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="003ad-110">Mogą one zagwarantować, aby dopasować najdłuższy ciąg możliwe.</span><span class="sxs-lookup"><span data-stu-id="003ad-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="003ad-111">Ponieważ nigdy nie testują tego samego znaku dwa razy, aparaty DFA nie obsługują wycofywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="003ad-112">Jednak ponieważ aparat DFA zawiera tylko stan skończony, nie może dopasować wzorzec z backreferences i ponieważ nie konstruuje jawne rozszerzenie, nie może przechwytywać podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="003ad-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="003ad-113">W przeciwieństwie do aparatów DFA, gdy tradycyjne aparaty NFA wykonać dopasowanie wzorców, ich kolejność przetwarzania jest napędzany przez wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="003ad-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="003ad-114">Podczas przetwarzania określonego elementu języka, aparat używa chciwy dopasowania; oznacza to, że pasuje do tyle ciągu wejściowego, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="003ad-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="003ad-115">Ale również zapisuje swój stan po pomyślnym dopasowaniu podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="003ad-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="003ad-116">Jeśli dopasowanie ostatecznie zakończy się niepowodzeniem, aparat może powrócić do zapisanego stanu, dzięki czemu może wypróbować dodatkowe dopasowania.</span><span class="sxs-lookup"><span data-stu-id="003ad-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="003ad-117">Ten proces porzucania pomyślnego dopasowania wyrażenia podrzędnego, tak aby późniejsze elementy języka w wyrażeniu regularnym również były zgodne, jest znane jako *wycofywanie.*</span><span class="sxs-lookup"><span data-stu-id="003ad-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="003ad-118">Aparaty NFA używają wycofywania do testowania wszystkich możliwych rozszerzeń wyrażenia regularnego w określonej kolejności i akceptowania pierwszego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="003ad-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="003ad-119">Ponieważ tradycyjny aparat NFA konstruuje określone rozszerzenie wyrażenia regularnego dla pomyślnego dopasowania, może przechwytywać dopasowania wyrażenia podrzędnego i pasujące wnioski wsteczne.</span><span class="sxs-lookup"><span data-stu-id="003ad-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="003ad-120">Jednak ponieważ tradycyjne backtracks NFA, może odwiedzić ten sam stan wiele razy, jeśli dotrze do stanu na różnych ścieżkach.</span><span class="sxs-lookup"><span data-stu-id="003ad-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="003ad-121">W rezultacie może działać wykładniczo powoli w najgorszym przypadku.</span><span class="sxs-lookup"><span data-stu-id="003ad-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="003ad-122">Ponieważ tradycyjny aparat NFA akceptuje pierwsze dopasowanie, które znajdzie, może również pozostawić inne (prawdopodobnie dłuższe) dopasowania nieodkryte.</span><span class="sxs-lookup"><span data-stu-id="003ad-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="003ad-123">Silniki POSIX NFA są jak tradycyjne silniki NFA, z tą różnicą, że nadal się cofają, dopóki nie zagwarantują, że znalazły jak najdłuższy możliwy mecz.</span><span class="sxs-lookup"><span data-stu-id="003ad-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="003ad-124">W rezultacie silnik POSIX NFA jest wolniejszy niż tradycyjny silnik NFA, a gdy używasz silnika POSIX NFA, nie możesz faworyzować krótszego dopasowania na dłuższy, zmieniając kolejność wyszukiwania wycofywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="003ad-125">Tradycyjne silniki NFA są preferowane przez programistów, ponieważ oferują większą kontrolę nad dopasowywaniem ciągów niż silniki DFA lub POSIX NFA.</span><span class="sxs-lookup"><span data-stu-id="003ad-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="003ad-126">Chociaż w najgorszym przypadku mogą działać wolno, można kierować je do znalezienia dopasowań w czasie liniowym lub wielomianowym za pomocą wzorców, które zmniejszają niejednoznaczności i ograniczają wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="003ad-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="003ad-127">Innymi słowy, chociaż silniki NFA handlu wydajnością mocy i elastyczności, w większości przypadków oferują one dobre do akceptowalnej wydajności, jeśli wyrażenie regularne jest dobrze napisane i unika przypadków, w których wycofywanie obniża wydajność wykładniczo.</span><span class="sxs-lookup"><span data-stu-id="003ad-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="003ad-128">Aby uzyskać informacje na temat kary za wydajność spowodowane nadmiernym wycofywaniem i sposobami tworzenia wyrażenia regularnego w celu obejść je, zobacz [Wycofywanie](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="003ad-129">Możliwości aparatu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="003ad-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="003ad-130">Aby skorzystać z zalet tradycyjnego aparatu NFA, aparat wyrażeń regularnych programu .NET Framework zawiera kompletny zestaw konstrukcji, aby umożliwić programistom kierowanie aparatem wycofywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="003ad-131">Konstrukcje te mogą służyć do szybszego znajdowania dopasowań lub faworyzowania określonych rozszerzeń nad innymi.</span><span class="sxs-lookup"><span data-stu-id="003ad-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="003ad-132">Inne funkcje aparatu wyrażeń regularnych programu .NET Framework są następujące:</span><span class="sxs-lookup"><span data-stu-id="003ad-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="003ad-133">Lazy kwantyfikatory: `??`, `*?`, `+?` `{` *n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="003ad-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="003ad-134">Konstrukcje te informują silnik wycofywania, aby najpierw przeszukał minimalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="003ad-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="003ad-135">Natomiast zwykłe chciwe kwantyfikatory starają się najpierw dopasować maksymalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="003ad-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="003ad-136">Poniższy przykład ilustruje różnicę między tymi dwoma.</span><span class="sxs-lookup"><span data-stu-id="003ad-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="003ad-137">Wyrażenie regularne pasuje do zdania, które kończy się liczbą, a grupa przechwytywania jest przeznaczona do wyodrębniania tej liczby.</span><span class="sxs-lookup"><span data-stu-id="003ad-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="003ad-138">Wyrażenie regularne `.+(\d+)\.` zawiera kwantyfikator `.+`chciwy , co powoduje, że aparat wyrażeń regularnych do przechwytywania tylko ostatnią cyfrę liczby.</span><span class="sxs-lookup"><span data-stu-id="003ad-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="003ad-139">Natomiast wyrażenie `.+?(\d+)\.` regularne zawiera kwantyfikator `.+?`leniwy , co powoduje, że aparat wyrażeń regularnych do przechwytywania całej liczby.</span><span class="sxs-lookup"><span data-stu-id="003ad-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="003ad-140">Chciwi i leniwe wersje tego wyrażenia regularnego są zdefiniowane w sposób pokazany w poniższej tabeli:</span><span class="sxs-lookup"><span data-stu-id="003ad-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="003ad-141">Wzorce</span><span class="sxs-lookup"><span data-stu-id="003ad-141">Pattern</span></span>|<span data-ttu-id="003ad-142">Opis</span><span class="sxs-lookup"><span data-stu-id="003ad-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="003ad-143">`.+`(chciwy kwantyfikator)</span><span class="sxs-lookup"><span data-stu-id="003ad-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="003ad-144">Dopasuj co najmniej jedno wystąpienie dowolnego znaku.</span><span class="sxs-lookup"><span data-stu-id="003ad-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="003ad-145">Powoduje to, że aparat wyrażeń regularnych, aby dopasować cały ciąg, a następnie do wycofywania w razie potrzeby, aby dopasować pozostałą część wzorca.</span><span class="sxs-lookup"><span data-stu-id="003ad-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="003ad-146">`.+?`(leniwy kwantyfikator)</span><span class="sxs-lookup"><span data-stu-id="003ad-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="003ad-147">Dopasuj co najmniej jedno wystąpienie dowolnego znaku, ale dopasuj jak najmniej.</span><span class="sxs-lookup"><span data-stu-id="003ad-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="003ad-148">Dopasuj co najmniej jeden znak liczbowy i przypisz go do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="003ad-149">Dopasuj okres.</span><span class="sxs-lookup"><span data-stu-id="003ad-149">Match a period.</span></span>|

     <span data-ttu-id="003ad-150">Aby uzyskać więcej informacji na temat leniwych kwantyfikatorów, zobacz [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="003ad-151">Pozytywne wysuw: `(?=` *subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="003ad-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="003ad-152">Ta funkcja umożliwia aparat wycofywania, aby powrócić do tego samego miejsca w tekście po dopasowaniu subexpression.</span><span class="sxs-lookup"><span data-stu-id="003ad-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="003ad-153">Jest to przydatne do wyszukiwania w całym tekście, weryfikując wiele wzorców, które zaczynają się od tej samej pozycji.</span><span class="sxs-lookup"><span data-stu-id="003ad-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="003ad-154">Umożliwia również aparatowi sprawdzenie, czy podciąg istnieje na końcu dopasowania bez uwzględniania podciągu w dopasowanym tekście.</span><span class="sxs-lookup"><span data-stu-id="003ad-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="003ad-155">W poniższym przykładzie użyto dodatniego wysuwu, aby wyodrębnić wyrazy w zdaniu, po którym nie następują symbole interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="003ad-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="003ad-156">Wyrażenie regularne `\b[A-Z]+\b(?=\P{P})` jest zdefiniowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="003ad-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="003ad-157">Wzorce</span><span class="sxs-lookup"><span data-stu-id="003ad-157">Pattern</span></span>|<span data-ttu-id="003ad-158">Opis</span><span class="sxs-lookup"><span data-stu-id="003ad-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="003ad-159">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="003ad-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="003ad-160">Dopasuj dowolny znak alfabetyczny jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="003ad-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="003ad-161">Ponieważ <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metoda jest wywoływana z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcją, porównanie jest bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="003ad-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="003ad-162">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="003ad-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="003ad-163">Spójrz w przyszłość, aby ustalić, czy następny znak jest symbolem interpunkcyjnym.</span><span class="sxs-lookup"><span data-stu-id="003ad-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="003ad-164">Jeśli tak nie jest, mecz zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="003ad-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="003ad-165">Aby uzyskać więcej informacji na temat pozytywnych potwierdzeń wyczekiwania, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="003ad-166">Negatywne wysuw: `(?!` *subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="003ad-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="003ad-167">Ta funkcja dodaje możliwość dopasowania wyrażenia tylko wtedy, gdy wyrażenie podrzędne nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="003ad-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="003ad-168">Jest to zaawansowane do przycinania wyszukiwania, ponieważ często jest prostsze, aby zapewnić wyrażenie dla sprawy, które powinny zostać wyeliminowane niż wyrażenie dla przypadków, które muszą być uwzględnione.</span><span class="sxs-lookup"><span data-stu-id="003ad-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="003ad-169">Na przykład trudno jest napisać wyrażenie dla słów, które nie zaczynają się od "non".</span><span class="sxs-lookup"><span data-stu-id="003ad-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="003ad-170">W poniższym przykładzie użyto negatywnego wysuwu, aby je wykluczyć.</span><span class="sxs-lookup"><span data-stu-id="003ad-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="003ad-171">Wzorzec `\b(?!non)\w+\b` wyrażenia regularnego jest zdefiniowany w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="003ad-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="003ad-172">Wzorce</span><span class="sxs-lookup"><span data-stu-id="003ad-172">Pattern</span></span>|<span data-ttu-id="003ad-173">Opis</span><span class="sxs-lookup"><span data-stu-id="003ad-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="003ad-174">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="003ad-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="003ad-175">Spójrz w przyszłość, aby upewnić się, że bieżący ciąg nie zaczyna się od "non".</span><span class="sxs-lookup"><span data-stu-id="003ad-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="003ad-176">Jeśli tak, dopasowanie zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="003ad-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="003ad-177">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="003ad-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="003ad-178">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="003ad-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="003ad-179">Aby uzyskać więcej informacji na temat negatywnych potwierdzeń wyprzedzających, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="003ad-180">Ocena warunkowa: `(?(` *wyrażenie*`)` `(?(`*tak*`|`*nie* `)` i *nazwa*`)`*tak*`|`*nie*`)`, gdzie *wyrażenie* jest wyrażeniem podrzędnym, aby dopasować, *nazwa* jest nazwą grupy przechwytywania, *tak* jest ciągiem do dopasowania, jeśli *wyrażenie* jest dopasowane lub *nazwa* jest prawidłową, niepustą grupą przechwyconą, a *nie* jest wyrażeniem podrzędnym, aby dopasować, jeśli *wyrażenie* nie jest dopasowane lub *nazwa* nie jest prawidłową, niepustą przechwyconą grupą.</span><span class="sxs-lookup"><span data-stu-id="003ad-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="003ad-181">Ta funkcja umożliwia aparatowi wyszukiwanie przy użyciu więcej niż jednego alternatywnego wzorca, w zależności od wyniku poprzedniego dopasowania podwyrażenia lub wyniku potwierdzenia o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="003ad-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="003ad-182">Pozwala to na bardziej zaawansowana forma wstecznego odniesienia, która pozwala na przykład na dopasowanie podwyrażenia na podstawie tego, czy poprzednie podwyrażenie zostało dopasowane.</span><span class="sxs-lookup"><span data-stu-id="003ad-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="003ad-183">Wyrażenie regularne w poniższym przykładzie pasuje do akapitów, które są przeznaczone zarówno do użytku publicznego, jak i wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="003ad-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="003ad-184">Akapity przeznaczone tylko do `<PRIVATE>` użytku wewnętrznego zaczynają się od znacznika.</span><span class="sxs-lookup"><span data-stu-id="003ad-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="003ad-185">Wzorzec `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` wyrażenia regularnego używa oceny warunkowej do przypisywania zawartości akapitów przeznaczonych do użytku publicznego i do użytku wewnętrznego w celu oddzielenia grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="003ad-186">Akapity te mogą być następnie traktowane inaczej.</span><span class="sxs-lookup"><span data-stu-id="003ad-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="003ad-187">Wzorzec wyrażenia regularnego jest zdefiniowany w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="003ad-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="003ad-188">Wzorce</span><span class="sxs-lookup"><span data-stu-id="003ad-188">Pattern</span></span>|<span data-ttu-id="003ad-189">Opis</span><span class="sxs-lookup"><span data-stu-id="003ad-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="003ad-190">Rozpocznij mecz na początku wiersza.</span><span class="sxs-lookup"><span data-stu-id="003ad-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="003ad-191">Dopasuj zero lub `<PRIVATE>` jedno wystąpienie ciągu, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="003ad-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="003ad-192">Przypisz dopasowanie do grupy `Pvt`przechwytywania o nazwie .</span><span class="sxs-lookup"><span data-stu-id="003ad-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="003ad-193">Jeśli `Pvt` grupa przechwytywania istnieje, dopasuj jedno lub więcej wystąpień jednego lub więcej znaków wyrazu, po których następuje zero lub jeden separator interpunkcyjny, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="003ad-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="003ad-194">Przypisz podciąg do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="003ad-195">Jeśli `Pvt` grupa przechwytywania nie istnieje, dopasuj jedno lub więcej wystąpień jednego lub więcej znaków wyrazu, po których następuje zero lub jeden separator interpunkcyjny, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="003ad-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="003ad-196">Przypisz podciąg do trzeciej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="003ad-197">Dopasuj koniec wiersza lub koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="003ad-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="003ad-198">Aby uzyskać więcej informacji na temat oceny warunkowej, zobacz [Konstrukcje alternacji](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="003ad-199">Definicje grup równoważących: `(?<` *nazwa1*`-`*name2* `>` *podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="003ad-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="003ad-200">Ta funkcja umożliwia aparatowi wyrażeń regularnych śledzenie zagnieżdżonych konstrukcji, takich jak nawiasy lub nawiasy otwierające i zamykające.</span><span class="sxs-lookup"><span data-stu-id="003ad-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="003ad-201">Na przykład zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="003ad-202">Grupy atomowe: `(?>` *podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="003ad-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="003ad-203">Ta funkcja umożliwia aparat wycofywania, aby zagwarantować, że wyrażenie podrzędne pasuje tylko do pierwszego dopasowania znalezionego dla tego wyrażenia podrzędnego, tak jakby wyrażenie działało niezależnie od jego wyrażenia zawierającego.</span><span class="sxs-lookup"><span data-stu-id="003ad-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="003ad-204">Jeśli nie używasz tej konstrukcji, wycofywanie wyszukiwań z większego wyrażenia może zmienić zachowanie wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="003ad-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="003ad-205">Na przykład wyrażenie `(a+)\w` regularne pasuje do jednego lub więcej znaków "a" wraz ze znakiem wyrazu, który następuje po sekwencji znaków "a" i przypisuje sekwencję znaków "a" do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="003ad-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="003ad-206">Jednak jeśli końcowy znak ciągu wejściowego jest również "a", jest `\w` dopasowywany przez element języka i nie jest uwzględniony w grupie przechwycone.</span><span class="sxs-lookup"><span data-stu-id="003ad-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="003ad-207">Wyrażenie regularne `((?>a+))\w` zapobiega temu zachowaniu.</span><span class="sxs-lookup"><span data-stu-id="003ad-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="003ad-208">Ponieważ wszystkie kolejne znaki "a" są dopasowywały się bez wycofywania, pierwsza grupa przechwytywania zawiera wszystkie kolejne znaki "a".</span><span class="sxs-lookup"><span data-stu-id="003ad-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="003ad-209">Jeśli po znakach "a" nie następuje co najmniej jeden znak inny niż "a", dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="003ad-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="003ad-210">Aby uzyskać więcej informacji na temat grup atomowych, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="003ad-211">Dopasowywanie od prawej do lewej, <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> które jest <xref:System.Text.RegularExpressions.Regex> określone przez podanie opcji do konstruktora klasy lub metody dopasowywania wystąpienia statycznego.</span><span class="sxs-lookup"><span data-stu-id="003ad-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="003ad-212">Ta funkcja jest przydatna podczas wyszukiwania od prawej do lewej, a nie od lewej do prawej lub w przypadkach, gdy jest bardziej efektywne, aby rozpocząć dopasowanie w prawej części wzorca, a nie po lewej stronie.</span><span class="sxs-lookup"><span data-stu-id="003ad-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="003ad-213">Jak pokazano w poniższym przykładzie, za pomocą dopasowywania od prawej do lewej można zmienić zachowanie chciwych kwantyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="003ad-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="003ad-214">W przykładzie przeprowadza dwa wyszukiwania dla zdania, które kończy się liczbą.</span><span class="sxs-lookup"><span data-stu-id="003ad-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="003ad-215">Wyszukiwanie od lewej do prawej, które używa chciwego kwantyfikatora, `+` pasuje do jednej z sześciu cyfr w zdaniu, podczas gdy wyszukiwanie od prawej do lewej pasuje do wszystkich sześciu cyfr.</span><span class="sxs-lookup"><span data-stu-id="003ad-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="003ad-216">Aby zapoznać się z opisem wzorca wyrażenia regularnego, zobacz przykład ilustruje ilośćdychorazowe wcześniej w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="003ad-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="003ad-217">Aby uzyskać więcej informacji na temat dopasowywania od prawej do lewej, zobacz [Opcje wyrażenia regularnego](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="003ad-218">Pozytywny i negatywny wygląd: `(?<=` *podwyrażenie* `)` dla pozytywnego wyglądu i `(?<!` *subexpresion* `)` dla negatywnego wyglądu.</span><span class="sxs-lookup"><span data-stu-id="003ad-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="003ad-219">Ta funkcja jest podobna do lookahead, która jest omawiana wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="003ad-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="003ad-220">Ponieważ aparat wyrażeń regularnych umożliwia pełne dopasowywanie od prawej do lewej, wyrażenia regularne umożliwiają nieograniczone wyglądy.</span><span class="sxs-lookup"><span data-stu-id="003ad-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="003ad-221">Pozytywne i negatywne spojrzenie może być również używane w celu uniknięcia zagnieżdżania kwantyfikatorów, gdy zagnieżdżone wyrażenie podrzędne jest nadzbiorem wyrażenia zewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="003ad-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="003ad-222">Wyrażenia regularne z takimi zagnieżdżonych kwantyfikatorów często oferują niską wydajność.</span><span class="sxs-lookup"><span data-stu-id="003ad-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="003ad-223">Na przykład poniższy przykład sprawdza, czy ciąg zaczyna się i kończy znak alfanumeryczny i że każdy inny znak w ciągu jest jednym z większego podzbioru.</span><span class="sxs-lookup"><span data-stu-id="003ad-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="003ad-224">Stanowi część wyrażenia regularnego używanego do sprawdzania poprawności adresów e-mail; Aby uzyskać więcej informacji, zobacz [Jak: Sprawdź, czy ciągi są w prawidłowym formacie wiadomości e-mail](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="003ad-225">Wyrażenie regularne ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` jest zdefiniowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="003ad-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="003ad-226">Wzorce</span><span class="sxs-lookup"><span data-stu-id="003ad-226">Pattern</span></span>|<span data-ttu-id="003ad-227">Opis</span><span class="sxs-lookup"><span data-stu-id="003ad-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="003ad-228">Rozpocznij dopasowanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="003ad-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="003ad-229">Dopasuj dowolny znak numeryczny lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="003ad-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="003ad-230">(Porównanie jest niewrażliwe na argumenty).</span><span class="sxs-lookup"><span data-stu-id="003ad-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="003ad-231">Dopasuj zero lub więcej wystąpień dowolnego znaku wyrazu lub dowolnego z następujących znaków: -, !, #, \*$, %, &, ', ., ,,,,/, =, ?, ^, &#96;, {, }, &#124; lub ~.</span><span class="sxs-lookup"><span data-stu-id="003ad-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="003ad-232">Spójrz za poprzedni znak, który musi być numeryczny lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="003ad-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="003ad-233">(Porównanie jest niewrażliwe na argumenty).</span><span class="sxs-lookup"><span data-stu-id="003ad-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="003ad-234">Zakończ dopasowanie na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="003ad-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="003ad-235">Aby uzyskać więcej informacji na temat pozytywnych i negatywnych spojrzeń, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="003ad-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="003ad-236">Pokrewne artykuły:</span><span class="sxs-lookup"><span data-stu-id="003ad-236">Related articles</span></span>

|<span data-ttu-id="003ad-237">Tytuł</span><span class="sxs-lookup"><span data-stu-id="003ad-237">Title</span></span>|<span data-ttu-id="003ad-238">Opis</span><span class="sxs-lookup"><span data-stu-id="003ad-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="003ad-239">Nawracanie</span><span class="sxs-lookup"><span data-stu-id="003ad-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="003ad-240">Zawiera informacje o tym, jak wyrażeń regularnych wycofywania oddziałów, aby znaleźć alternatywne dopasowania.</span><span class="sxs-lookup"><span data-stu-id="003ad-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="003ad-241">Kompilacja i ponowne użycie</span><span class="sxs-lookup"><span data-stu-id="003ad-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="003ad-242">Zawiera informacje dotyczące kompilowania i ponownego żyk wyrażeń regularnych w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="003ad-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="003ad-243">Bezpieczeństwo wątków</span><span class="sxs-lookup"><span data-stu-id="003ad-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="003ad-244">Zawiera informacje o bezpieczeństwie wątku wyrażenia regularnego i wyjaśnia, kiedy należy synchronizować dostęp do obiektów wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="003ad-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="003ad-245">.NET Framework — Wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="003ad-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="003ad-246">Zawiera omówienie aspektu języka programowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="003ad-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="003ad-247">Model obiektów wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="003ad-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="003ad-248">Zawiera informacje i przykłady kodu ilustrujące sposób używania klas wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="003ad-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="003ad-249">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="003ad-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="003ad-250">Zawiera informacje o zestawie znaków, operatorów i konstrukcji, których można użyć do definiowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="003ad-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="003ad-251">Dokumentacja</span><span class="sxs-lookup"><span data-stu-id="003ad-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
