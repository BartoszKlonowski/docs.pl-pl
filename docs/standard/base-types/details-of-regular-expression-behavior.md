---
title: Zachowanie wyrażenia regularnego
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 504e315dda4e76f56a88d97149b1515b6743668b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "77124354"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="05497-102">Szczegóły zachowania wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="05497-102">Details of regular expression behavior</span></span>

<span data-ttu-id="05497-103">Aparat wyrażeń regularnych .NET Framework jest wstecznym dopasowanie wyrażenia regularnego, który zawiera tradycyjne nondeterministic Finite Automaton (NFA) aparat, takich jak używane przez Perl, Python, Emacs i Tcl.</span><span class="sxs-lookup"><span data-stu-id="05497-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="05497-104">To odróżnia go od szybszych, ale bardziej ograniczone, czystego wyrażenia regularnego Deterministic Finite Automaton (DFA) silników, takich jak te znalezione w awk, egrep, lub lex.</span><span class="sxs-lookup"><span data-stu-id="05497-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="05497-105">To również odróżnia go od standaryzowanych, ale wolniej, POSIX NFAs.</span><span class="sxs-lookup"><span data-stu-id="05497-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="05497-106">W poniższej sekcji opisano trzy typy aparatów wyrażeń regularnych i wyjaśniono, dlaczego wyrażenia regularne w platformie .NET Framework są implementowane przy użyciu tradycyjnego aparatu NFA.</span><span class="sxs-lookup"><span data-stu-id="05497-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="05497-107">Zalety silnika NFA</span><span class="sxs-lookup"><span data-stu-id="05497-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="05497-108">Gdy aparaty DFA wykonać dopasowanie wzorca, ich kolejność przetwarzania jest napędzany przez ciąg wejściowy.</span><span class="sxs-lookup"><span data-stu-id="05497-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="05497-109">Aparat rozpoczyna się na początku ciągu wejściowego i przebiega sekwencyjnie, aby ustalić, czy następny znak pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="05497-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="05497-110">Mogą zagwarantować, aby dopasować najdłuższy ciąg możliwe.</span><span class="sxs-lookup"><span data-stu-id="05497-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="05497-111">Ponieważ nigdy nie testują tego samego znaku dwa razy, aparaty DFA nie obsługują wycofywania.</span><span class="sxs-lookup"><span data-stu-id="05497-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="05497-112">Jednak ponieważ aparat DFA zawiera tylko stan skończony, nie może dopasować wzorca z odwołaniami wstecznymi, a ponieważ nie tworzy jawnego rozszerzenia, nie może przechwytywać wyrażeń podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="05497-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="05497-113">W przeciwieństwie do aparatów DFA, gdy tradycyjne aparaty NFA wykonują dopasowywanie wzorców, ich kolejność przetwarzania jest sterowane przez wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="05497-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="05497-114">Podczas przetwarzania określonego elementu języka aparat używa chciwego dopasowania; oznacza to, że pasuje jak najwięcej ciągu wejściowego, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="05497-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="05497-115">Ale również zapisuje jego stan po pomyślnym dopasowaniu wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="05497-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="05497-116">Jeśli dopasowanie ostatecznie nie powiedzie się, aparat może powrócić do stanu zapisanego, dzięki czemu można spróbować dodatkowych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="05497-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="05497-117">Ten proces porzucania pomyślnego dopasowania wyrażenia podrzędnego, tak aby późniejsze elementy języka w wyrażeniu regularnym można również dopasować jest znany jako *wycofywania*.</span><span class="sxs-lookup"><span data-stu-id="05497-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="05497-118">Aparaty NFA używają wycofywania do testowania wszystkich możliwych rozszerzeń wyrażenia regularnego w określonej kolejności i akceptowania pierwszego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="05497-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="05497-119">Ponieważ tradycyjny aparat NFA konstruuje określone rozszerzenie wyrażenia regularnego dla pomyślnego dopasowania, może przechwytywać dopasowania wyrażeń podrzędnych i pasujące odwołania wsteczne.</span><span class="sxs-lookup"><span data-stu-id="05497-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="05497-120">Jednak ponieważ tradycyjne backtracks NFA, może odwiedzić ten sam stan wiele razy, jeśli dociera do stanu na różnych ścieżkach.</span><span class="sxs-lookup"><span data-stu-id="05497-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="05497-121">W rezultacie można uruchomić wykładniczo powoli w najgorszym przypadku.</span><span class="sxs-lookup"><span data-stu-id="05497-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="05497-122">Ponieważ tradycyjny aparat NFA akceptuje pierwsze dopasowanie, które znajdzie, może również pozostawić inne (być może dłuższe) dopasowania nieodkryte.</span><span class="sxs-lookup"><span data-stu-id="05497-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="05497-123">Silniki POSIX NFA są jak tradycyjne silniki NFA, z tą różnicą, że nadal cofają się, dopóki nie zagwarantują, że znaleźli najdłuższy możliwy mecz.</span><span class="sxs-lookup"><span data-stu-id="05497-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="05497-124">W rezultacie silnik POSIX NFA jest wolniejszy niż tradycyjny aparat NFA, a podczas korzystania z silnika POSIX NFA nie można preferować krótszego dopasowania przez dłuższy, zmieniając kolejność wyszukiwania wstecznego.</span><span class="sxs-lookup"><span data-stu-id="05497-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="05497-125">Tradycyjne silniki NFA są preferowane przez programistów, ponieważ oferują większą kontrolę nad dopasowywaniem ciągów niż silniki DFA lub POSIX NFA.</span><span class="sxs-lookup"><span data-stu-id="05497-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="05497-126">Chociaż w najgorszym przypadku mogą działać powoli, można sterować nimi, aby znaleźć dopasowania w czasie liniowym lub wielomianowym za pomocą wzorców, które zmniejszają niejasności i ograniczają wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="05497-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="05497-127">Innymi słowy, chociaż silniki NFA handlu wydajności dla mocy i elastyczności, w większości przypadków oferują one dobre do akceptowalnej wydajności, jeśli wyrażenie regularne jest dobrze napisane i pozwala uniknąć przypadków, w których wycofywanie obniża wydajność wykładniczo.</span><span class="sxs-lookup"><span data-stu-id="05497-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="05497-128">Aby uzyskać informacje na temat kary za wykonanie spowodowane przez nadmierne wycofywanie i sposobów tworzenia wyrażenia regularnego, aby obejść je, zobacz [Wycofywanie](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="05497-129">Możliwości aparatu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="05497-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="05497-130">Aby skorzystać z zalet tradycyjnego aparatu NFA, aparat wyrażeń regularnych .NET Framework zawiera kompletny zestaw konstrukcji umożliwiających programistom kierowanie aparatem wycofywania.</span><span class="sxs-lookup"><span data-stu-id="05497-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="05497-131">Konstrukcje te mogą być używane do szybszego znajdowania dopasowań lub faworyzowania określonych rozszerzeń nad innymi.</span><span class="sxs-lookup"><span data-stu-id="05497-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="05497-132">Inne funkcje aparatu wyrażeń regularnych .NET Framework są następujące:</span><span class="sxs-lookup"><span data-stu-id="05497-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="05497-133">Kwantyfikatory `??` `*?`leniwe: , , `+?` `{` *n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="05497-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="05497-134">Te konstrukcje informują wyszukiwarkę wycofywania, aby najpierw przeszukać minimalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="05497-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="05497-135">Natomiast zwykłe chciwe kwantyfikatory próbują najpierw dopasować maksymalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="05497-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="05497-136">Poniższy przykład ilustruje różnicę między tymi dwoma.</span><span class="sxs-lookup"><span data-stu-id="05497-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="05497-137">Wyrażenie regularne pasuje do zdania, które kończy się liczbą, a grupa przechwytywania jest przeznaczona do wyodrębnienia tego numeru.</span><span class="sxs-lookup"><span data-stu-id="05497-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="05497-138">Wyrażenie `.+(\d+)\.` regularne zawiera kwantyfikator `.+`chciwy , co powoduje, że aparat wyrażeń regularnych do przechwytywania tylko ostatnią cyfrę liczby.</span><span class="sxs-lookup"><span data-stu-id="05497-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="05497-139">Natomiast wyrażenie `.+?(\d+)\.` regularne zawiera kwantyfikator `.+?`leniwy , co powoduje, że aparat wyrażeń regularnych do przechwytywania całej liczby.</span><span class="sxs-lookup"><span data-stu-id="05497-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="05497-140">Chciwi i leniwy wersje tego wyrażenia regularnego są zdefiniowane w sposób pokazany w poniższej tabeli:</span><span class="sxs-lookup"><span data-stu-id="05497-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="05497-141">Wzorce</span><span class="sxs-lookup"><span data-stu-id="05497-141">Pattern</span></span>|<span data-ttu-id="05497-142">Opis</span><span class="sxs-lookup"><span data-stu-id="05497-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="05497-143">`.+`(chciwy kwantyfikator)</span><span class="sxs-lookup"><span data-stu-id="05497-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="05497-144">Dopasuj co najmniej jedno wystąpienie dowolnego znaku.</span><span class="sxs-lookup"><span data-stu-id="05497-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="05497-145">Powoduje to, że aparat wyrażeń regularnych, aby dopasować cały ciąg, a następnie do backtrack zgodnie z potrzebami, aby dopasować pozostałą część wzorca.</span><span class="sxs-lookup"><span data-stu-id="05497-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="05497-146">`.+?`(kwantyfikator leniwy)</span><span class="sxs-lookup"><span data-stu-id="05497-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="05497-147">Dopasuj co najmniej jedno wystąpienie dowolnej postaci, ale dopasuj jak najmniej.</span><span class="sxs-lookup"><span data-stu-id="05497-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="05497-148">Dopasuj co najmniej jeden znak liczbowy i przypisz go do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="05497-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="05497-149">Dopasuj kropkę.</span><span class="sxs-lookup"><span data-stu-id="05497-149">Match a period.</span></span>|

     <span data-ttu-id="05497-150">Aby uzyskać więcej informacji na temat kwantyfikatorów leniwych, zobacz [Kwantyfikatory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="05497-151">Pozytywne spojrzenie `(?=`w przyszłość: *podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="05497-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="05497-152">Ta funkcja umożliwia aparatowi wycofywania powrót do tego samego miejsca w tekście po dopasowaniu wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="05497-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="05497-153">Jest to przydatne do wyszukiwania w całym tekście, weryfikując wiele wzorców, które zaczynają się od tej samej pozycji.</span><span class="sxs-lookup"><span data-stu-id="05497-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="05497-154">Umożliwia również aparatowi sprawdzenie, czy podciąg istnieje na końcu dopasowania bez uwzględniania podciągu w dopasowanym tekście.</span><span class="sxs-lookup"><span data-stu-id="05497-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="05497-155">W poniższym przykładzie użyto pozytywnego punktu wyjrzenia w przyszłość, aby wyodrębnić wyrazy w zdaniu, po których nie następują symbole interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="05497-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="05497-156">Wyrażenie `\b[A-Z]+\b(?=\P{P})` regularne jest zdefiniowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="05497-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="05497-157">Wzorce</span><span class="sxs-lookup"><span data-stu-id="05497-157">Pattern</span></span>|<span data-ttu-id="05497-158">Opis</span><span class="sxs-lookup"><span data-stu-id="05497-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="05497-159">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="05497-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="05497-160">Dopasuj dowolny znak alfabetyczny jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="05497-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="05497-161">Ponieważ <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metoda jest wywoływana z opcją, <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> porównanie jest bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="05497-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="05497-162">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="05497-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="05497-163">Spójrz w przyszłość, aby ustalić, czy następny znak jest symbolem interpunkcyjnym.</span><span class="sxs-lookup"><span data-stu-id="05497-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="05497-164">Jeśli tak nie jest, dopasowanie zakończy się powodzeniem.</span><span class="sxs-lookup"><span data-stu-id="05497-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="05497-165">Aby uzyskać więcej informacji na temat pozytywnych potwierdzeń wyszukiwania, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="05497-166">Negatywne spojrzenie `(?!`w przyszłość: *podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="05497-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="05497-167">Ta funkcja dodaje możliwość dopasowania wyrażenia tylko wtedy, gdy wyrażenie podrzędne nie pasuje.</span><span class="sxs-lookup"><span data-stu-id="05497-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="05497-168">Jest to szczególnie skuteczne w przypadku przycinania wyszukiwania, ponieważ często jest to prostsze, aby zapewnić wyrażenie dla sprawy, która powinna zostać wyeliminowana niż wyrażenie w przypadkach, które muszą zostać uwzględnione.</span><span class="sxs-lookup"><span data-stu-id="05497-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="05497-169">Na przykład trudno jest napisać wyrażenie dla słów, które nie zaczynają się od "non".</span><span class="sxs-lookup"><span data-stu-id="05497-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="05497-170">W poniższym przykładzie użyto negatywnego wyglądu, aby je wykluczyć.</span><span class="sxs-lookup"><span data-stu-id="05497-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="05497-171">Wzorzec `\b(?!non)\w+\b` wyrażenia regularnego jest zdefiniowany w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="05497-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="05497-172">Wzorce</span><span class="sxs-lookup"><span data-stu-id="05497-172">Pattern</span></span>|<span data-ttu-id="05497-173">Opis</span><span class="sxs-lookup"><span data-stu-id="05497-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="05497-174">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="05497-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="05497-175">Spójrz w przyszłość, aby upewnić się, że bieżący ciąg nie zaczyna się od "non".</span><span class="sxs-lookup"><span data-stu-id="05497-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="05497-176">Jeśli tak, dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="05497-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="05497-177">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="05497-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="05497-178">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="05497-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="05497-179">Aby uzyskać więcej informacji na temat negatywnych potwierdzeń wyszukiwania, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="05497-180">`(?(`Ocena warunkowa: `(?(` *wyrażenie*`)`*tak*`|`*nie* `)` i *nazwa*`)`*tak*`|`*nie*`)`, gdzie *wyrażenie* jest wyrażeniem podrzędnym do dopasowania, *nazwa* jest nazwą grupy przechwytywania, *tak* jest ciągiem do dopasowania, jeśli *wyrażenie* jest dopasowane lub *nazwa* jest prawidłową, niepustą przechwyconą grupą, a *nie* jest to wyrażenie podrzędne, które ma być zgodne, jeśli wyrażenie jest zgodne, jeśli \*wyrażenie \*nie jest dopasowana lub *nazwa* nie jest prawidłową, niepustą przechwyconą grupą.</span><span class="sxs-lookup"><span data-stu-id="05497-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="05497-181">Ta funkcja umożliwia wyszukiwarce wyszukiwanie przy użyciu więcej niż jednego wzorca alternatywnego, w zależności od wyniku poprzedniego dopasowania wyrażenia podrzędnego lub wyniku potwierdzenia o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="05497-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="05497-182">Dzięki temu bardziej zaawansowana forma backreference, która pozwala, na przykład, dopasowanie wyrażenia podrzędnego na podstawie tego, czy poprzednie wyrażenie podrzędne zostało dopasowane.</span><span class="sxs-lookup"><span data-stu-id="05497-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="05497-183">Wyrażenie regularne w poniższym przykładzie pasuje do akapitów, które są przeznaczone zarówno do użytku publicznego, jak i wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="05497-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="05497-184">Akapity przeznaczone tylko do użytku `<PRIVATE>` wewnętrznego zaczynają się od znacznika.</span><span class="sxs-lookup"><span data-stu-id="05497-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="05497-185">Wzorzec `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` wyrażenia regularnego używa oceny warunkowej do przypisywania zawartości akapitów przeznaczonych do publicznego i do użytku wewnętrznego do oddzielania grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="05497-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="05497-186">Następnie te akapity mogą być traktowane inaczej.</span><span class="sxs-lookup"><span data-stu-id="05497-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="05497-187">Wzorzec wyrażenia regularnego jest zdefiniowany w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="05497-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="05497-188">Wzorce</span><span class="sxs-lookup"><span data-stu-id="05497-188">Pattern</span></span>|<span data-ttu-id="05497-189">Opis</span><span class="sxs-lookup"><span data-stu-id="05497-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="05497-190">Rozpocznij mecz na początku linii.</span><span class="sxs-lookup"><span data-stu-id="05497-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="05497-191">Dopasuj zero lub `<PRIVATE>` jedno wystąpienie ciągu, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="05497-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="05497-192">Przypisz dopasowanie do grupy `Pvt`przechwytywania o nazwie .</span><span class="sxs-lookup"><span data-stu-id="05497-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="05497-193">Jeśli `Pvt` istnieje grupa przechwytywania, dopasuj jedno lub więcej wystąpień jednego lub więcej znaków wyrazu, po których następuje separator zero lub jeden znak interpunkcyjny, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="05497-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="05497-194">Przypisz podciąg do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="05497-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="05497-195">Jeśli `Pvt` grupa przechwytywania nie istnieje, dopasuj jedno lub więcej wystąpień jednego lub więcej znaków wyrazu, po których następuje separator zero lub jeden znak interpunkcyjny, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="05497-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="05497-196">Przypisz podciąg do trzeciej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="05497-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="05497-197">Dopasuj koniec wiersza lub koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="05497-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="05497-198">Aby uzyskać więcej informacji na temat oceny warunkowej, zobacz [Konstrukcje zmienne](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="05497-199">Definicje grup bilansujących: `(?<` *name1*`-`*name2* `>` *podwyrażenie*`)`.</span><span class="sxs-lookup"><span data-stu-id="05497-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="05497-200">Ta funkcja umożliwia aparatowi wyrażeń regularnych śledzenie zagnieżdżonych konstrukcji, takich jak nawiasy lub nawiasy otwierające i zamykające.</span><span class="sxs-lookup"><span data-stu-id="05497-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="05497-201">Na przykład zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="05497-202">Grupy atomowe: `(?>` *wyrażenie podrzędne*`)`.</span><span class="sxs-lookup"><span data-stu-id="05497-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="05497-203">Ta funkcja umożliwia aparatowi wycofywania zagwarantowanie, że wyrażenie podrzędne pasuje tylko do pierwszego dopasowania znalezionego dla tego wyrażenia podrzędnego, tak jakby wyrażenie było uruchomione niezależnie od jego wyrażenia zawierającego.</span><span class="sxs-lookup"><span data-stu-id="05497-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="05497-204">Jeśli ta konstrukcja nie zostanie użyje, wycofywanie wyszukiwań z większego wyrażenia może zmienić zachowanie wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="05497-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="05497-205">Na przykład wyrażenie `(a+)\w` regularne pasuje do jednego lub więcej znaków "a" wraz ze znakiem słownym, który następuje po sekwencji znaków "a" i przypisuje sekwencję znaków "a" do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="05497-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="05497-206">Jednak jeśli końcowy znak ciągu wejściowego jest również "a", `\w` jest dopasowywany przez element języka i nie jest uwzględniony w grupie przechwyconych.</span><span class="sxs-lookup"><span data-stu-id="05497-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="05497-207">Wyrażenie `((?>a+))\w` regularne zapobiega takiemu zachowaniu.</span><span class="sxs-lookup"><span data-stu-id="05497-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="05497-208">Ponieważ wszystkie kolejne znaki "a" są dopasowywane bez wycofywania, pierwsza grupa przechwytywania zawiera wszystkie kolejne znaki "a".</span><span class="sxs-lookup"><span data-stu-id="05497-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="05497-209">Jeśli po znakach "a" nie następuje co najmniej jeden znak inny niż "a", dopasowanie kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="05497-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="05497-210">Aby uzyskać więcej informacji na temat grup atomowych, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="05497-211">Dopasowanie od prawej do lewej, które jest <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> określone przez <xref:System.Text.RegularExpressions.Regex> dostarczenie opcji do konstruktora klasy lub metody dopasowywania wystąpienia statycznego.</span><span class="sxs-lookup"><span data-stu-id="05497-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="05497-212">Ta funkcja jest przydatna podczas wyszukiwania od prawej do lewej, a nie od lewej do prawej, lub w przypadkach, gdy bardziej efektywne jest rozpoczęcie dopasowania w prawej części wzorca zamiast w lewo.</span><span class="sxs-lookup"><span data-stu-id="05497-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="05497-213">Jak pokazano w poniższym przykładzie, przy użyciu dopasowania od prawej do lewej można zmienić zachowanie chciwych kwantyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="05497-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="05497-214">Przykład prowadzi dwa wyszukiwania dla zdania, które kończy się liczbą.</span><span class="sxs-lookup"><span data-stu-id="05497-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="05497-215">Wyszukiwanie od lewej do prawej, które używa kwantyfikatora `+` chciwego, pasuje do jednej z sześciu cyfr w zdaniu, podczas gdy wyszukiwanie od prawej do lewej odpowiada wszystkim sześciu cyfrom.</span><span class="sxs-lookup"><span data-stu-id="05497-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="05497-216">Aby uzyskać opis wzorca wyrażenia regularnego, zobacz przykład, który ilustruje kwantyfikatory leniwy wcześniej w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="05497-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="05497-217">Aby uzyskać więcej informacji na temat dopasowywania od prawej do lewej, zobacz [Opcje wyrażenia regularnego](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="05497-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="05497-218">Pozytywne i negatywne `(?<=`spojrzenie za: *podwyrażenie* `)` `(?<!`dla pozytywnego lookbehind i *podwyrażenie* `)` dla negatywnego lookbehind.</span><span class="sxs-lookup"><span data-stu-id="05497-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="05497-219">Ta funkcja jest podobna do przyszłości, która została omówiona wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="05497-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="05497-220">Ponieważ aparat wyrażeń regularnych umożliwia pełne dopasowanie od prawej do lewej, wyrażenia regularne umożliwiają nieograniczone lookbehinds.</span><span class="sxs-lookup"><span data-stu-id="05497-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="05497-221">Dodatnie i negatywne lookbehind można również użyć, aby uniknąć zagnieżdżania kwantyfikatorów, gdy zagnieżdżone podwyrażenie jest nadzbiorem wyrażenia zewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="05497-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="05497-222">Wyrażenia regularne z takimi kwantyfikatorami zagnieżdżonymi często oferują słabą wydajność.</span><span class="sxs-lookup"><span data-stu-id="05497-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="05497-223">Na przykład w poniższym przykładzie sprawdza, czy ciąg zaczyna się i kończy znakiem alfanumerycznym i że każdy inny znak w ciągu jest jednym z większych podzbioru.</span><span class="sxs-lookup"><span data-stu-id="05497-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="05497-224">Stanowi część wyrażenia regularnego używanego do sprawdzania poprawności adresów e-mail; Aby uzyskać więcej informacji, zobacz [Jak: Sprawdź, czy ciągi są w prawidłowym formacie wiadomości e-mail](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="05497-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="05497-225">Wyrażenie ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` regularne jest zdefiniowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="05497-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="05497-226">Wzorce</span><span class="sxs-lookup"><span data-stu-id="05497-226">Pattern</span></span>|<span data-ttu-id="05497-227">Opis</span><span class="sxs-lookup"><span data-stu-id="05497-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="05497-228">Rozpocznij dopasowanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="05497-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="05497-229">Dopasuj dowolny znak numeryczny lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="05497-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="05497-230">(W porównaniu jest bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="05497-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="05497-231">Dopasuj zero lub więcej wystąpień dowolnego znaku wyrazu lub dowolnego z następujących znaków: \*-, !, #, $, %, &, ', ., ,,+, /, =, ?, ^, &#96;, {, }, &#124; lub ~.</span><span class="sxs-lookup"><span data-stu-id="05497-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="05497-232">Spójrz z tyłu na poprzedni znak, który musi być numeryczny lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="05497-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="05497-233">(W porównaniu jest bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="05497-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="05497-234">Zakończ dopasowanie na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="05497-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="05497-235">Aby uzyskać więcej informacji na temat pozytywnych i negatywnych lookbehind, zobacz [Grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="05497-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="05497-236">Pokrewne artykuły:</span><span class="sxs-lookup"><span data-stu-id="05497-236">Related articles</span></span>

|<span data-ttu-id="05497-237">Tytuł</span><span class="sxs-lookup"><span data-stu-id="05497-237">Title</span></span>|<span data-ttu-id="05497-238">Opis</span><span class="sxs-lookup"><span data-stu-id="05497-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="05497-239">Nawracanie</span><span class="sxs-lookup"><span data-stu-id="05497-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="05497-240">Zawiera informacje o tym, jak wyrażenie regularne wycofywania gałęzi, aby znaleźć alternatywne dopasowania.</span><span class="sxs-lookup"><span data-stu-id="05497-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="05497-241">Kompilacja i ponowne używanie</span><span class="sxs-lookup"><span data-stu-id="05497-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="05497-242">Zawiera informacje dotyczące kompilowania i ponownego używania wyrażeń regularnych w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="05497-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="05497-243">Bezpieczeństwo wątków</span><span class="sxs-lookup"><span data-stu-id="05497-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="05497-244">Zawiera informacje o bezpieczeństwie wątków wyrażenia regularnego i wyjaśnia, kiedy należy synchronizować dostęp do obiektów wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="05497-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="05497-245">.NET Framework — Wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="05497-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="05497-246">Zawiera omówienie aspektu języka programowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="05497-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="05497-247">Model obiektów wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="05497-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="05497-248">Zawiera informacje i przykłady kodu ilustrujące sposób używania klas wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="05497-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="05497-249">Przykłady wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="05497-249">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="05497-250">Zawiera przykłady kodu, które ilustrują użycie wyrażeń regularnych w typowych aplikacjach.</span><span class="sxs-lookup"><span data-stu-id="05497-250">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|
|[<span data-ttu-id="05497-251">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="05497-251">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="05497-252">Zawiera informacje o zestawie znaków, operatorów i konstrukcji, których można użyć do definiowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="05497-252">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="05497-253">Dokumentacja</span><span class="sxs-lookup"><span data-stu-id="05497-253">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
