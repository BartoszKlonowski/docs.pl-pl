---
title: Szczegóły zachowania dotyczącego wyrażeń regularnych
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bb43554d53051ce02a296f225c68c74352add5ed
ms.sourcegitcommit: 29a9b29d8b7d07b9c59d46628da754a8bff57fa4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/17/2019
ms.locfileid: "69567482"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="78ef7-102">Szczegóły zachowania dotyczącego wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="78ef7-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="78ef7-103">Aparat wyrażeń regularnych .NET Framework to wsteczny odpowiednik wyrażenia regularnego, który zawiera tradycyjny, Niedeterministyczny aparat usługi Automation (NFA), taki jak używany przez język Perl, Python, Emacs: i TCL.</span><span class="sxs-lookup"><span data-stu-id="78ef7-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="78ef7-104">Odróżnia to od szybszego, ale bardziej ograniczone, czyste wyrażenie regularne deterministycznie skończone usługi Automation (DFA), takie jak te, które znajdują się w AWK, egrep lub Lex.</span><span class="sxs-lookup"><span data-stu-id="78ef7-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="78ef7-105">Odróżnia to również od standaryzacji, ale wolniejsze, NFAs POSIX.</span><span class="sxs-lookup"><span data-stu-id="78ef7-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="78ef7-106">W poniższej sekcji opisano trzy typy aparatów wyrażeń regularnych i wyjaśniono, dlaczego wyrażenia regularne w .NET Framework są implementowane przy użyciu tradycyjnego aparatu NFA.</span><span class="sxs-lookup"><span data-stu-id="78ef7-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="78ef7-107">Zalety aparatu NFA</span><span class="sxs-lookup"><span data-stu-id="78ef7-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="78ef7-108">Gdy aparaty DFA wykonują dopasowanie do wzorca, ich kolejność przetwarzania jest określana przez ciąg wejściowy.</span><span class="sxs-lookup"><span data-stu-id="78ef7-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="78ef7-109">Aparat rozpoczyna się na początku ciągu wejściowego i przechodzi sekwencyjnie, aby określić, czy następny znak jest zgodny ze wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="78ef7-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="78ef7-110">Mogą one zagwarantować, że najdłuższy ciąg będzie możliwy.</span><span class="sxs-lookup"><span data-stu-id="78ef7-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="78ef7-111">Ponieważ nigdy nie testują tego samego znaku dwa razy, aparaty DFA nie obsługują wycofywania.</span><span class="sxs-lookup"><span data-stu-id="78ef7-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="78ef7-112">Jednak ponieważ aparat DFA zawiera tylko skończoną wartość, nie może pasować do wzorca z odwołaniami wstecznymi i ponieważ nie konstruuje jawnego rozszerzania, nie może przechwycić podwyrażeń.</span><span class="sxs-lookup"><span data-stu-id="78ef7-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="78ef7-113">W przeciwieństwie do aparatów DFA, gdy tradycyjne aparaty NFA wykonują dopasowywanie do wzorców, ich kolejność przetwarzania jest oparta na wzorcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="78ef7-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="78ef7-114">Ponieważ przetwarza określony element języka, aparat używa dopasowywania zachłanne; oznacza to, że jest ona zgodna ze zbyt dużą ilością ciągu wejściowego, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="78ef7-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="78ef7-115">Ale również zapisuje swój stan po pomyślnym dopasowaniu podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="78ef7-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="78ef7-116">Jeśli dopasowanie zakończyło się niepowodzeniem, aparat może powrócić do zapisanego stanu, aby umożliwić wypróbowanie dodatkowych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="78ef7-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="78ef7-117">Ten proces porzucania dopasowania podwyrażenia powiodło się, aby późniejsze elementy języka w wyrażeniu regularnym mogły być również zgodnez wycofywaniem.</span><span class="sxs-lookup"><span data-stu-id="78ef7-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="78ef7-118">Silniki NFA używają wycofywania do testowania wszystkich możliwych rozszerzeń wyrażenia regularnego w określonej kolejności i akceptują pierwsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="78ef7-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="78ef7-119">Ze względu na to, że tradycyjny aparat NFA konstruuje określone rozszerzenie wyrażenia regularnego dla sukcesu, może przechwycić dopasowania podwyrażenia i pasujące odwołania wsteczne.</span><span class="sxs-lookup"><span data-stu-id="78ef7-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="78ef7-120">Jednak ze względu na to, że tradycyjne NFA, mogą odwiedzać ten sam stan wielokrotnie, jeśli dociera do stanu dla różnych ścieżek.</span><span class="sxs-lookup"><span data-stu-id="78ef7-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="78ef7-121">W związku z tym może działać wykładniczo powoli w najgorszym przypadku.</span><span class="sxs-lookup"><span data-stu-id="78ef7-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="78ef7-122">Ze względu na to, że tradycyjny aparat NFA akceptuje pierwsze znalezione dopasowanie, może również pozostawić inne (prawdopodobnie dłużej) dopasowania niewykrywalne.</span><span class="sxs-lookup"><span data-stu-id="78ef7-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="78ef7-123">Aparaty NFA POSIX są podobne do tradycyjnych aparatów NFA, z tą różnicą, że nadal są nawrotu, dopóki nie będą mogły zagwarantować, że wystąpiły najdłuższe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="78ef7-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="78ef7-124">W efekcie aparat NFA systemu POSIX jest wolniejszy niż tradycyjny aparat NFA i w przypadku korzystania z aparatu NFA POSIX nie można preferować krótszego dopasowania przez zmianę kolejności wyszukiwania wycofywania.</span><span class="sxs-lookup"><span data-stu-id="78ef7-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="78ef7-125">Tradycyjne aparaty NFA są preferowane przez programistów, ponieważ oferują większą kontrolę nad dopasowaniem ciągu niż aparaty DFA lub POSIX NFA.</span><span class="sxs-lookup"><span data-stu-id="78ef7-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="78ef7-126">Mimo że w najgorszym przypadku mogą one działać wolno, można przełączać je, aby znaleźć dopasowania w liniowym lub wieloznacznym czasie, używając wzorców, które zmniejszają niejasności i ograniczają wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="78ef7-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="78ef7-127">Inaczej mówiąc, chociaż silniki NFAją wydajność wymiany dla mocy i elastyczności, w większości przypadków oferuje ona akceptowalną wydajność, jeśli wyrażenie regularne jest dobrze zapisywane i unika przypadków, w których wycofywanie obniża wydajność.</span><span class="sxs-lookup"><span data-stu-id="78ef7-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78ef7-128">Aby uzyskać informacje o tym, jak spadek wydajności spowodowany przez nadmierne wycofywanie i sposoby rozłożenia wyrażenia regularnego do obejść, zobacz wycofywanie. [](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)</span><span class="sxs-lookup"><span data-stu-id="78ef7-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="78ef7-129">Możliwości aparatu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="78ef7-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="78ef7-130">Aby skorzystać z zalet tradycyjnego aparatu NFA, aparat wyrażeń regularnych .NET Framework zawiera kompletny zestaw konstrukcji umożliwiających programistom sterownie aparatem wycofywania.</span><span class="sxs-lookup"><span data-stu-id="78ef7-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="78ef7-131">Konstrukcje te mogą służyć do szybszego znajdowania dopasowania lub w celu uzyskania określonych rozszerzeń dla innych.</span><span class="sxs-lookup"><span data-stu-id="78ef7-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="78ef7-132">Inne funkcje aparatu wyrażeń regularnych .NET Framework są następujące:</span><span class="sxs-lookup"><span data-stu-id="78ef7-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
- <span data-ttu-id="78ef7-133">Kwantyfikatory opóźnione `??`: `*?`, `+?`, `{`, *n*`,`*m*.`}?`</span><span class="sxs-lookup"><span data-stu-id="78ef7-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="78ef7-134">Te konstrukcje informują aparat wycofywania, aby najpierw przeszukać minimalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="78ef7-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="78ef7-135">W przeciwieństwie do zwykłych kwantyfikatorów zachłanne spróbuj najpierw dopasować maksymalną liczbę powtórzeń.</span><span class="sxs-lookup"><span data-stu-id="78ef7-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="78ef7-136">Poniższy przykład ilustruje różnicę między nimi.</span><span class="sxs-lookup"><span data-stu-id="78ef7-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="78ef7-137">Wyrażenie regularne dopasowuje zdanie kończące się na liczbie, a grupa przechwytywania jest przeznaczona do wyodrębnienia tej liczby.</span><span class="sxs-lookup"><span data-stu-id="78ef7-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="78ef7-138">Wyrażenie `.+(\d+)\.` regularne zawiera `.+`kwantyfikator zachłanne, które powoduje, że aparat wyrażeń regularnych przechwytuje tylko ostatnią cyfrę liczby.</span><span class="sxs-lookup"><span data-stu-id="78ef7-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="78ef7-139">Z kolei wyrażenie `.+?(\d+)\.` regularne zawiera `.+?`kwantyfikator z opóźnieniem, który powoduje, że aparat wyrażeń regularnych przechwytuje całą liczbę.</span><span class="sxs-lookup"><span data-stu-id="78ef7-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="78ef7-140">Wersje zachłanne i z opóźnieniem tego wyrażenia regularnego są zdefiniowane, jak pokazano w poniższej tabeli:</span><span class="sxs-lookup"><span data-stu-id="78ef7-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>
  
    |<span data-ttu-id="78ef7-141">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="78ef7-141">Pattern</span></span>|<span data-ttu-id="78ef7-142">Opis</span><span class="sxs-lookup"><span data-stu-id="78ef7-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="78ef7-143">`.+`(kwantyfikator zachłanne)</span><span class="sxs-lookup"><span data-stu-id="78ef7-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="78ef7-144">Dopasowuje co najmniej jedno wystąpienie dowolnego znaku.</span><span class="sxs-lookup"><span data-stu-id="78ef7-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="78ef7-145">Powoduje to, że aparat wyrażeń regularnych dopasowuje cały ciąg, a następnie do nawrotu w razie potrzeby dopasowania do pozostałej części wzorca.</span><span class="sxs-lookup"><span data-stu-id="78ef7-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="78ef7-146">`.+?`(kwantyfikator opóźniony)</span><span class="sxs-lookup"><span data-stu-id="78ef7-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="78ef7-147">Dopasowuje co najmniej jedno wystąpienie dowolnego znaku, ale dopasowanie jak najmniejszej liczby.</span><span class="sxs-lookup"><span data-stu-id="78ef7-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="78ef7-148">Dopasowuje co najmniej jeden znak liczbowy i przypisuje go do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="78ef7-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="78ef7-149">Dopasowuje okres.</span><span class="sxs-lookup"><span data-stu-id="78ef7-149">Match a period.</span></span>|  
  
     <span data-ttu-id="78ef7-150">Aby uzyskać więcej informacji na temat kwantyfikatorów z [](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)opóźnieniem, zobacz Kwantyfikatory.</span><span class="sxs-lookup"><span data-stu-id="78ef7-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="78ef7-151">Pozytywne naprzód `(?=`: Podwyrażenie.`)`</span><span class="sxs-lookup"><span data-stu-id="78ef7-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="78ef7-152">Ta funkcja pozwala aparatowi wycofywania na powrót do tego samego miejsca w tekście po dopasowaniu podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="78ef7-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="78ef7-153">Jest to przydatne do wyszukiwania w całym tekście przez zweryfikowanie wielu wzorców, które zaczynają się od tego samego położenia.</span><span class="sxs-lookup"><span data-stu-id="78ef7-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="78ef7-154">Umożliwia także aparatowi sprawdzenie, czy podciąg istnieje na końcu dopasowania bez uwzględniania podciągu w dopasowanym tekście.</span><span class="sxs-lookup"><span data-stu-id="78ef7-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="78ef7-155">W poniższym przykładzie użyto pozytywnego naprzód w celu wyodrębnienia wyrazów w zdaniu, które nie poprzedzają symboli interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="78ef7-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="78ef7-156">Wyrażenie `\b[A-Z]+\b(?=\P{P})` regularne jest zdefiniowane, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="78ef7-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="78ef7-157">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="78ef7-157">Pattern</span></span>|<span data-ttu-id="78ef7-158">Opis</span><span class="sxs-lookup"><span data-stu-id="78ef7-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="78ef7-159">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="78ef7-160">Dopasowuje dowolny znak alfabetyczny jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="78ef7-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="78ef7-161">Ponieważ metoda jest wywoływana z opcją, porównanie nie uwzględnia wielkości liter. <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="78ef7-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="78ef7-162">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="78ef7-163">Zapoznaj się z wyprzedzeniem, aby określić, czy następny znak jest symbolem interpunkcji.</span><span class="sxs-lookup"><span data-stu-id="78ef7-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="78ef7-164">Jeśli tak nie jest, dopasowanie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="78ef7-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="78ef7-165">Aby uzyskać więcej informacji na temat pozytywnych potwierdzeń z wyprzedzeniem, zobacz [Grouping konstrukcjes](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="78ef7-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="78ef7-166">Ujemne naprzód `(?!`: Podwyrażenie.`)`</span><span class="sxs-lookup"><span data-stu-id="78ef7-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="78ef7-167">Ta funkcja dodaje możliwość dopasowania wyrażenia tylko w przypadku niepowodzenia dopasowania podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="78ef7-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="78ef7-168">Jest to szczególnie zaawansowane w przypadku oczyszczania wyszukiwania, ponieważ często jest prostsze, aby podać wyrażenie dla przypadku, które należy wyeliminować niż wyrażenie dla przypadków, które muszą być uwzględnione.</span><span class="sxs-lookup"><span data-stu-id="78ef7-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="78ef7-169">Na przykład trudno jest napisać wyrażenie dla słów, które nie zaczynają się od "non".</span><span class="sxs-lookup"><span data-stu-id="78ef7-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="78ef7-170">W poniższym przykładzie zastosowano ujemne naprzód, aby je wykluczyć.</span><span class="sxs-lookup"><span data-stu-id="78ef7-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="78ef7-171">Wzorzec `\b(?!non)\w+\b` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="78ef7-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="78ef7-172">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="78ef7-172">Pattern</span></span>|<span data-ttu-id="78ef7-173">Opis</span><span class="sxs-lookup"><span data-stu-id="78ef7-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="78ef7-174">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="78ef7-175">Sprawdź w przód, aby upewnić się, że bieżący ciąg nie zaczyna się od "non".</span><span class="sxs-lookup"><span data-stu-id="78ef7-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="78ef7-176">W przeciwnym razie dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="78ef7-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="78ef7-177">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="78ef7-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="78ef7-178">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="78ef7-179">Aby uzyskać więcej informacji na temat negatywnych potwierdzeń naprzód, zobacz [grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="78ef7-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="78ef7-180">Ocena warunkowa: `(?(` *wyrażenie*`)`*tak*nie i nazwa tak nie`|``)` `(?(``)` `|``)`, gdzie *wyrażenie* jest podwyrażeniem do dopasowania, *name* to nazwa grupy przechwytywania, *tak* jest ciąg do dopasowania, jeśli *wyrażenie* jest dopasowane lub *Nazwa* jest prawidłową, niepustą grupą przechwyconą i *nie* jest podwyrażeniem do dopasowania, jeśli *wyrażenie* nie jest dopasowane lub *Nazwa* nie jest prawidłową, niepustą grupą przechwyconą.</span><span class="sxs-lookup"><span data-stu-id="78ef7-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="78ef7-181">Ta funkcja umożliwia aparatowi wyszukiwanie przy użyciu więcej niż jednego wzorca alternatywnego, w zależności od wyniku poprzedniego dopasowania podwyrażenia lub wyniku potwierdzeń o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="78ef7-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="78ef7-182">Pozwala to na bardziej wydajną postać odwołania, która pozwala na przykład dopasować Podwyrażenie w zależności od tego, czy poprzednie Podwyrażenie zostało dopasowane.</span><span class="sxs-lookup"><span data-stu-id="78ef7-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="78ef7-183">Wyrażenie regularne w poniższym przykładzie dopasowuje akapity, które są przeznaczone do użytku publicznego i wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="78ef7-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="78ef7-184">Akapity przeznaczone tylko do użytku wewnętrznego zaczynają `<PRIVATE>` się od tagu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="78ef7-185">Wzorzec `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` wyrażenia regularnego używa oceny warunkowej do przypisywania zawartości akapitów przeznaczonych do użytku publicznego i wewnętrznych do oddzielania grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="78ef7-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="78ef7-186">Te akapity mogą być następnie obsługiwane inaczej.</span><span class="sxs-lookup"><span data-stu-id="78ef7-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="78ef7-187">Wzorzec wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="78ef7-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="78ef7-188">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="78ef7-188">Pattern</span></span>|<span data-ttu-id="78ef7-189">Opis</span><span class="sxs-lookup"><span data-stu-id="78ef7-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="78ef7-190">Rozpocznij dopasowanie na początku wiersza.</span><span class="sxs-lookup"><span data-stu-id="78ef7-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="78ef7-191">Dopasowanie do zera lub jednego wystąpienia ciągu `<PRIVATE>` , po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="78ef7-192">Przypisz dopasowanie do grupy przechwytywania o nazwie `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="78ef7-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="78ef7-193">Jeśli grupa `Pvt` przechwytywania istnieje, dopasowuje jedno lub więcej wystąpień jednego lub większej liczby znaków słowa, po których następuje zero lub jeden separator interpunkcji, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="78ef7-194">Przypisz podciąg do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="78ef7-194">Assign the substring to the first capturing group.</span></span>|  
    |<code>&#124;((\w+\p{P}?\s)+))<code>|<span data-ttu-id="78ef7-195">Jeśli grupa `Pvt` przechwytywania nie istnieje, dopasowuje jedno lub więcej wystąpień jednego lub większej liczby znaków słowa, po których następuje zero lub jeden separator interpunkcji, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="78ef7-196">Przypisz podciąg do trzeciej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="78ef7-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="78ef7-197">Dopasowuje koniec wiersza lub koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="78ef7-198">Aby uzyskać więcej informacji na temat oceny warunkowej, zobacz [konstrukcje warunkowe](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="78ef7-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="78ef7-199">Definicje grup równoważenia: `(?<` *Name1*`-`*NAME2* `>` subexpression.`)`</span><span class="sxs-lookup"><span data-stu-id="78ef7-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="78ef7-200">Ta funkcja umożliwia aparatowi wyrażeń regularnych śledzenie zagnieżdżonych konstrukcji, takich jak nawiasy, otwierające i zamykające nawiasy klamrowe.</span><span class="sxs-lookup"><span data-stu-id="78ef7-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="78ef7-201">Aby zapoznać się z przykładem, zobacz [grupowanie konstrukcji](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="78ef7-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="78ef7-202">Podwyrażenia Podwyrażenie (znane również jako zachłanne subexpressions): `(?>`subexpression.`)`</span><span class="sxs-lookup"><span data-stu-id="78ef7-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="78ef7-203">Ta funkcja umożliwia aparatowi wycofywania w celu zagwarantowania, że Podwyrażenie dopasowuje tylko pierwsze dopasowanie znalezione dla tego podwyrażenia, tak jakby wyrażenie było uruchomione niezależnie od jego wyrażenia zawierającego.</span><span class="sxs-lookup"><span data-stu-id="78ef7-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="78ef7-204">Jeśli ta konstrukcja nie jest używana, wyszukiwanie wsteczne z większego wyrażenia może zmienić zachowanie podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="78ef7-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="78ef7-205">Na przykład wyrażenie `(a+)\w` regularne dopasowuje jeden lub więcej znaków "a", wraz ze znakiem słowa, które następuje po sekwencji znaków "a" i przypisuje sekwencję znaków "a" do pierwszej grupy przechwytywania, jednak jeśli znak końcowy ciąg wejściowy jest również "a", jest dopasowywany przez `\w` element języka i nie jest uwzględniony w przechwyconej grupie.</span><span class="sxs-lookup"><span data-stu-id="78ef7-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="78ef7-206">Wyrażenie `((?>a+))\w` regularne uniemożliwia takie zachowanie.</span><span class="sxs-lookup"><span data-stu-id="78ef7-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="78ef7-207">Ponieważ wszystkie kolejne znaki "a" są dopasowywane bez wycofywania, pierwsza grupa przechwytywania zawiera wszystkie kolejne znaki "a".</span><span class="sxs-lookup"><span data-stu-id="78ef7-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="78ef7-208">Jeśli po znaku "a" nie występuje co najmniej jeden znak inny niż "a", dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="78ef7-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="78ef7-209">Aby uzyskać więcej informacji o podwyrażeniach Podwyrażenie, [](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)zobacz Grouping konstrukcjes.</span><span class="sxs-lookup"><span data-stu-id="78ef7-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="78ef7-210">Dopasowanie od prawej do lewej, które jest określone przez dostarczenie <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcji <xref:System.Text.RegularExpressions.Regex> do konstruktora klasy lub statycznej metody dopasowywania wystąpień.</span><span class="sxs-lookup"><span data-stu-id="78ef7-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="78ef7-211">Ta funkcja jest przydatna podczas wyszukiwania od prawej do lewej zamiast od lewej do prawej lub w przypadkach, gdy jest bardziej wydajna, aby zacząć dopasowywanie do prawej części wzorca zamiast z lewej strony.</span><span class="sxs-lookup"><span data-stu-id="78ef7-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="78ef7-212">Jak pokazano na poniższym przykładzie, użycie dopasowania od prawej do lewej może zmienić zachowanie kwantyfikatorów zachłanne.</span><span class="sxs-lookup"><span data-stu-id="78ef7-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="78ef7-213">Przykład wykonuje dwa wyszukiwania zdania kończącego się na liczbie.</span><span class="sxs-lookup"><span data-stu-id="78ef7-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="78ef7-214">Wyszukiwanie od lewej do prawej, które używa kwantyfikatora `+` zachłanne, dopasowuje jeden z sześciu cyfr w zdaniu, podczas gdy wyszukiwanie od prawej do lewej jest zgodne ze wszystkimi sześcioma cyframi.</span><span class="sxs-lookup"><span data-stu-id="78ef7-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="78ef7-215">Aby uzyskać opis wzorca wyrażenia regularnego, zobacz przykład, który ilustruje liczbę kwantyfikatorów opóźnionych wcześniej w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="78ef7-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="78ef7-216">Aby uzyskać więcej informacji na temat dopasowywania do prawej strony, zobacz [Opcje wyrażenia regularnego](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="78ef7-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
- <span data-ttu-id="78ef7-217">Pozytywne i ujemne asercja wsteczna: `(?<=`Podwyrażenie `)` dla pozytywnej asercja wsteczna i `(?<!` *Podwyrażenie* `)` dla negatywnej asercja wsteczna.</span><span class="sxs-lookup"><span data-stu-id="78ef7-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="78ef7-218">Ta funkcja jest podobna do wyprzedzenia, która została omówiona wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="78ef7-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="78ef7-219">Ponieważ aparat wyrażeń regularnych umożliwia pełne dopasowywanie do prawej strony, wyrażenia regularne zezwalają na nieograniczony lookbehinds.</span><span class="sxs-lookup"><span data-stu-id="78ef7-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="78ef7-220">Można również użyć asercja wsteczna pozytywnej i ujemnej, aby uniknąć zagnieżdżania kwantyfikatorów, gdy zagnieżdżone Podwyrażenie jest nadzbiorem wyrażenia zewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="78ef7-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="78ef7-221">Wyrażenia regularne z takimi kwantyfikatorami zagnieżdżonymi często zapewniają niską wydajność.</span><span class="sxs-lookup"><span data-stu-id="78ef7-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="78ef7-222">Na przykład poniższy przykład sprawdza, czy ciąg rozpoczyna się i zamyka znak alfanumeryczny, a każdy inny znak w ciągu jest jednym z większego podzbioru.</span><span class="sxs-lookup"><span data-stu-id="78ef7-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="78ef7-223">Stanowi część wyrażenia regularnego służącego do sprawdzania poprawności adresów e-mail. Aby uzyskać więcej informacji, [zobacz How to: Sprawdź, czy ciągi są w prawidłowym](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md)formacie poczty e-mail.</span><span class="sxs-lookup"><span data-stu-id="78ef7-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="78ef7-224">Wyrażenie ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` regularne jest zdefiniowane, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="78ef7-224">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="78ef7-225">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="78ef7-225">Pattern</span></span>|<span data-ttu-id="78ef7-226">Opis</span><span class="sxs-lookup"><span data-stu-id="78ef7-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="78ef7-227">Rozpocznij dopasowanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="78ef7-228">Dopasowuje dowolny znak liczbowy lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="78ef7-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="78ef7-229">(W porównaniu z rozróżnianiem wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="78ef7-229">(The comparison is case-insensitive.)</span></span>|  
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="78ef7-230">Dopasowuje zero lub więcej wystąpień dowolnego znaku słowa albo dowolnego z następujących znaków:-,!, #, $,%, &, ",., \*, +,/, =,?, ^, \`, {,}, &#124;lub ~.</span><span class="sxs-lookup"><span data-stu-id="78ef7-230">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, \`, {, }, &#124;, or ~.</span></span>|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="78ef7-231">Odszukaj w powyższym znaku, który musi być numeryczny lub alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="78ef7-231">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="78ef7-232">(W porównaniu z rozróżnianiem wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="78ef7-232">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="78ef7-233">Zakończ dopasowanie na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="78ef7-233">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="78ef7-234">Aby uzyskać więcej informacji na temat pozytywnych i negatywnych asercja wsteczna, zobacz [Grouping konstrukcjes](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="78ef7-234">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="78ef7-235">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="78ef7-235">Related Topics</span></span>  
  
|<span data-ttu-id="78ef7-236">Tytuł</span><span class="sxs-lookup"><span data-stu-id="78ef7-236">Title</span></span>|<span data-ttu-id="78ef7-237">Opis</span><span class="sxs-lookup"><span data-stu-id="78ef7-237">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="78ef7-238">Śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="78ef7-238">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="78ef7-239">Zawiera informacje dotyczące sposobu, w jaki rozgałęzienia wyrażenia regularnego do znajdowania alternatywnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="78ef7-239">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="78ef7-240">Kompilacja i ponowne używanie</span><span class="sxs-lookup"><span data-stu-id="78ef7-240">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="78ef7-241">Zawiera informacje dotyczące kompilowania i ponownego używania wyrażeń regularnych w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="78ef7-241">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="78ef7-242">Bezpieczeństwo wątków</span><span class="sxs-lookup"><span data-stu-id="78ef7-242">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="78ef7-243">Zawiera informacje na temat bezpieczeństwa wątku wyrażeń regularnych i wyjaśnia, kiedy należy synchronizować dostęp do obiektów wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="78ef7-243">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="78ef7-244">.NET Framework wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="78ef7-244">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="78ef7-245">Zawiera omówienie aspektu języka programowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="78ef7-245">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="78ef7-246">Model obiektów wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="78ef7-246">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="78ef7-247">Zawiera informacje i przykłady kodu ilustrujące sposób użycia klas wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="78ef7-247">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="78ef7-248">Przykłady wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="78ef7-248">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="78ef7-249">Zawiera przykłady kodu, które ilustrują użycie wyrażeń regularnych we wspólnych aplikacjach.</span><span class="sxs-lookup"><span data-stu-id="78ef7-249">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="78ef7-250">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="78ef7-250">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="78ef7-251">Zawiera informacje dotyczące zestawu znaków, operatorów i konstrukcji, których można użyć do definiowania wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="78ef7-251">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="78ef7-252">Tematy pomocy</span><span class="sxs-lookup"><span data-stu-id="78ef7-252">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
