---
title: System typu wspólnego
description: Dowiedz się więcej o systemie typów w programie .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- type system
- common type system
- assemblies [.NET Framework], types
- reference types
- value types
- cross-language interoperability
- namespaces [.NET Framework], types
- types, about types
ms.assetid: 53c57c96-83e1-4ee3-9543-9ac832671a89
ms.custom: seodec18
ms.openlocfilehash: 5590bb07c3927ba50000d7f9d99f11e30373343d
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/30/2019
ms.locfileid: "73105707"
---
# <a name="common-type-system"></a><span data-ttu-id="e8b13-103">System typu wspólnego</span><span class="sxs-lookup"><span data-stu-id="e8b13-103">Common Type System</span></span>
<span data-ttu-id="e8b13-104">Wspólny system typów definiuje, w jaki sposób typy są zadeklarowane, używane i zarządzane w środowisku uruchomieniowym języka wspólnego, i jest również ważną częścią obsługi integracji wielu języków przez środowisko uruchomieniowe.</span><span class="sxs-lookup"><span data-stu-id="e8b13-104">The common type system defines how types are declared, used, and managed in the common language runtime, and is also an important part of the runtime's support for cross-language integration.</span></span> <span data-ttu-id="e8b13-105">Wspólny system typów wykonuje następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="e8b13-105">The common type system performs the following functions:</span></span>  
  
- <span data-ttu-id="e8b13-106">Ustanawia strukturę ułatwiającą integrację między językami, bezpieczeństwo typów i wykonywanie kodu o wysokiej wydajności.</span><span class="sxs-lookup"><span data-stu-id="e8b13-106">Establishes a framework that helps enable cross-language integration, type safety, and high-performance code execution.</span></span>  
  
- <span data-ttu-id="e8b13-107">Oferuje model zorientowany obiektowo, który obsługuje kompletną implementację wielu języków programowania.</span><span class="sxs-lookup"><span data-stu-id="e8b13-107">Provides an object-oriented model that supports the complete implementation of many programming languages.</span></span>  
  
- <span data-ttu-id="e8b13-108">Definiuje reguły, które Języki muszą spełniać, co pomaga zapewnić, że obiekty w różnych językach mogą współistnieć ze sobą.</span><span class="sxs-lookup"><span data-stu-id="e8b13-108">Defines rules that languages must follow, which helps ensure that objects written in different languages can interact with each other.</span></span>  
  
- <span data-ttu-id="e8b13-109">Udostępnia bibliotekę zawierającą typy danych pierwotnych (takie jak <xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Int32>i <xref:System.UInt64>) używane podczas tworzenia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8b13-109">Provides a library that contains the primitive data types (such as <xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Int32>, and <xref:System.UInt64>) used in application development.</span></span>  
  
 <span data-ttu-id="e8b13-110">Ten temat zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="e8b13-110">This topic contains the following sections:</span></span>  
  
- [<span data-ttu-id="e8b13-111">Typy w programie .NET</span><span class="sxs-lookup"><span data-stu-id="e8b13-111">Types in .NET</span></span>](#types_in_the_net_framework)  
  
- [<span data-ttu-id="e8b13-112">Definicje typu</span><span class="sxs-lookup"><span data-stu-id="e8b13-112">Type Definitions</span></span>](#type_definitions)  
  
- [<span data-ttu-id="e8b13-113">Elementy członkowskie typu</span><span class="sxs-lookup"><span data-stu-id="e8b13-113">Type Members</span></span>](#type_members)  
  
- [<span data-ttu-id="e8b13-114">Charakterystyka elementów członkowskich typu</span><span class="sxs-lookup"><span data-stu-id="e8b13-114">Characteristics of Type Members</span></span>](#characteristics_of_type_members)  
  
<a name="types_in_the_net_framework"></a>   
## <a name="types-in-net"></a><span data-ttu-id="e8b13-115">Typy w programie .NET</span><span class="sxs-lookup"><span data-stu-id="e8b13-115">Types in .NET</span></span>  
 <span data-ttu-id="e8b13-116">Wszystkie typy w .NET są typami wartości lub typami referencyjnymi.</span><span class="sxs-lookup"><span data-stu-id="e8b13-116">All types in .NET are either value types or reference types.</span></span>  
  
 <span data-ttu-id="e8b13-117">Typy wartości są typami danych, których obiekty są reprezentowane przez rzeczywistą wartość obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-117">Value types are data types whose objects are represented by the object's actual value.</span></span> <span data-ttu-id="e8b13-118">Jeśli wystąpienie typu wartości jest przypisane do zmiennej, ta zmienna otrzymuje świeżą kopię wartości.</span><span class="sxs-lookup"><span data-stu-id="e8b13-118">If an instance of a value type is assigned to a variable, that variable is given a fresh copy of the value.</span></span>  
  
 <span data-ttu-id="e8b13-119">Typy odwołań to typy danych, których obiekty są reprezentowane przez odwołanie (podobne do wskaźnika) do rzeczywistej wartości obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-119">Reference types are data types whose objects are represented by a reference (similar to a pointer) to the object's actual value.</span></span> <span data-ttu-id="e8b13-120">Jeśli typ odwołania jest przypisany do zmiennej, ta zmienna odwołuje się do oryginalnej wartości.</span><span class="sxs-lookup"><span data-stu-id="e8b13-120">If a reference type is assigned to a variable, that variable references (points to) the original value.</span></span> <span data-ttu-id="e8b13-121">Nie wykonano żadnej kopii.</span><span class="sxs-lookup"><span data-stu-id="e8b13-121">No copy is made.</span></span>  
  
 <span data-ttu-id="e8b13-122">Wspólny system typów w programie .NET obsługuje następujące pięć kategorii typów:</span><span class="sxs-lookup"><span data-stu-id="e8b13-122">The common type system in .NET supports the following five categories of types:</span></span>  
  
- [<span data-ttu-id="e8b13-123">Klasy</span><span class="sxs-lookup"><span data-stu-id="e8b13-123">Classes</span></span>](#Classes)  
  
- [<span data-ttu-id="e8b13-124">Struktury</span><span class="sxs-lookup"><span data-stu-id="e8b13-124">Structures</span></span>](#Structures)  
  
- [<span data-ttu-id="e8b13-125">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-125">Enumerations</span></span>](#Enumerations)  
  
- [<span data-ttu-id="e8b13-126">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="e8b13-126">Interfaces</span></span>](#Interfaces)  
  
- [<span data-ttu-id="e8b13-127">Delegaci</span><span class="sxs-lookup"><span data-stu-id="e8b13-127">Delegates</span></span>](#Delegates)  
  
<a name="Classes"></a>   
### <a name="classes"></a><span data-ttu-id="e8b13-128">Klasy</span><span class="sxs-lookup"><span data-stu-id="e8b13-128">Classes</span></span>  
 <span data-ttu-id="e8b13-129">Klasa jest typem referencyjnym, który może być pochodny bezpośrednio z innej klasy i jest pochodną niejawnie z <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-129">A class is a reference type that can be derived directly from another class and that is derived implicitly from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8b13-130">Klasa definiuje operacje, które obiekt (który jest wystąpieniem klasy) może wykonać (metody, zdarzenia lub właściwości) i dane, które zawiera obiekt (pola).</span><span class="sxs-lookup"><span data-stu-id="e8b13-130">The class defines the operations that an object (which is an instance of the class) can perform (methods, events, or properties) and the data that the object contains (fields).</span></span> <span data-ttu-id="e8b13-131">Chociaż Klasa zazwyczaj obejmuje zarówno definicję, jak i implementację (w przeciwieństwie do interfejsów, na przykład, które zawierają tylko definicje bez implementacji), może mieć co najmniej jednego członka, który nie ma implementacji.</span><span class="sxs-lookup"><span data-stu-id="e8b13-131">Although a class generally includes both definition and implementation (unlike interfaces, for example, which contain only definition without implementation), it can have one or more members that have no implementation.</span></span>  
  
 <span data-ttu-id="e8b13-132">W poniższej tabeli opisano niektóre cechy, które może mieć Klasa.</span><span class="sxs-lookup"><span data-stu-id="e8b13-132">The following table describes some of the characteristics that a class may have.</span></span> <span data-ttu-id="e8b13-133">Każdy język, który obsługuje środowisko uruchomieniowe, zapewnia sposób wskazujący, że Klasa lub członek klasy ma jedną lub więcej z tych cech.</span><span class="sxs-lookup"><span data-stu-id="e8b13-133">Each language that supports the runtime provides a way to indicate that a class or class member has one or more of these characteristics.</span></span> <span data-ttu-id="e8b13-134">Jednak poszczególne Języki programowania, które są przeznaczone dla platformy .NET, mogą nie udostępniać wszystkich tych cech.</span><span class="sxs-lookup"><span data-stu-id="e8b13-134">However, individual programming languages that target .NET may not make all these characteristics available.</span></span>  
  
|<span data-ttu-id="e8b13-135">Charakterystyk</span><span class="sxs-lookup"><span data-stu-id="e8b13-135">Characteristic</span></span>|<span data-ttu-id="e8b13-136">Opis</span><span class="sxs-lookup"><span data-stu-id="e8b13-136">Description</span></span>|  
|--------------------|-----------------|  
|<span data-ttu-id="e8b13-137">sealed</span><span class="sxs-lookup"><span data-stu-id="e8b13-137">sealed</span></span>|<span data-ttu-id="e8b13-138">Określa, że nie można dziedziczyć innej klasy z tego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-138">Specifies that another class cannot be derived from this type.</span></span>|  
|<span data-ttu-id="e8b13-139">implements</span><span class="sxs-lookup"><span data-stu-id="e8b13-139">implements</span></span>|<span data-ttu-id="e8b13-140">Wskazuje, że Klasa używa jednego lub więcej interfejsów, dostarczając implementacje elementów członkowskich interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-140">Indicates that the class uses one or more interfaces by providing implementations of interface members.</span></span>|  
|<span data-ttu-id="e8b13-141">abstract</span><span class="sxs-lookup"><span data-stu-id="e8b13-141">abstract</span></span>|<span data-ttu-id="e8b13-142">Wskazuje, że nie można utworzyć wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="e8b13-142">Indicates that the class cannot be instantiated.</span></span> <span data-ttu-id="e8b13-143">Aby go użyć, należy utworzyć inną klasę od niej.</span><span class="sxs-lookup"><span data-stu-id="e8b13-143">To use it, you must derive another class from it.</span></span>|  
|<span data-ttu-id="e8b13-144">inherit</span><span class="sxs-lookup"><span data-stu-id="e8b13-144">inherits</span></span>|<span data-ttu-id="e8b13-145">Wskazuje, że wystąpienia klasy mogą być używane wszędzie tam, gdzie określona jest klasa bazowa.</span><span class="sxs-lookup"><span data-stu-id="e8b13-145">Indicates that instances of the class can be used anywhere the base class is specified.</span></span> <span data-ttu-id="e8b13-146">Klasa pochodna, która dziedziczy z klasy bazowej, może korzystać z implementacji wszelkich publicznych składowych dostarczonych przez klasę bazową lub Klasa pochodna może zastąpić implementację publicznych członków własnym implementacją.</span><span class="sxs-lookup"><span data-stu-id="e8b13-146">A derived class that inherits from a base class can use the implementation of any public members provided by the base class, or the derived class can override the implementation of the public members with its own implementation.</span></span>|  
|<span data-ttu-id="e8b13-147">wyeksportowany lub nie wyeksportowany</span><span class="sxs-lookup"><span data-stu-id="e8b13-147">exported or not exported</span></span>|<span data-ttu-id="e8b13-148">Wskazuje, czy Klasa jest widoczna poza zestawem, w którym jest zdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="e8b13-148">Indicates whether a class is visible outside the assembly in which it is defined.</span></span> <span data-ttu-id="e8b13-149">Ta cecha ma zastosowanie tylko do klas najwyższego poziomu, a nie do klas zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="e8b13-149">This characteristic applies only to top-level classes and not to nested classes.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="e8b13-150">Klasa może być również zagnieżdżona w klasie nadrzędnej lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="e8b13-150">A class can also be nested in a parent class or structure.</span></span> <span data-ttu-id="e8b13-151">Klasy zagnieżdżone mają również charakterystykę elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-151">Nested classes also have member characteristics.</span></span> <span data-ttu-id="e8b13-152">Aby uzyskać więcej informacji, zobacz [typy zagnieżdżone](#NestedTypes).</span><span class="sxs-lookup"><span data-stu-id="e8b13-152">For more information, see [Nested Types](#NestedTypes).</span></span>  
  
 <span data-ttu-id="e8b13-153">Elementy członkowskie klasy, które nie mają implementacji, są abstrakcyjnymi elementami członkowskimi.</span><span class="sxs-lookup"><span data-stu-id="e8b13-153">Class members that have no implementation are abstract members.</span></span> <span data-ttu-id="e8b13-154">Klasa, która ma co najmniej jeden abstrakcyjny element członkowski, jest sama abstrakcyjna; nie można utworzyć nowych wystąpień tego elementu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-154">A class that has one or more abstract members is itself abstract; new instances of it cannot be created.</span></span> <span data-ttu-id="e8b13-155">Niektóre języki, które są przeznaczone dla środowiska uruchomieniowego, umożliwiają oznaczenie klasy jako abstrakcyjnej, nawet jeśli żaden z jej elementów członkowskich nie jest abstrakcyjny.</span><span class="sxs-lookup"><span data-stu-id="e8b13-155">Some languages that target the runtime let you mark a class as abstract even if none of its members are abstract.</span></span> <span data-ttu-id="e8b13-156">Klasy abstrakcyjnej można użyć do hermetyzacji podstawowego zestawu funkcji, które klasy pochodne mogą dziedziczyć lub przesłaniać w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="e8b13-156">You can use an abstract class when you want to encapsulate a basic set of functionality that derived classes can inherit or override when appropriate.</span></span> <span data-ttu-id="e8b13-157">Klasy, które nie są abstrakcyjne, są nazywane klasami konkretnymi.</span><span class="sxs-lookup"><span data-stu-id="e8b13-157">Classes that are not abstract are referred to as concrete classes.</span></span>  
  
 <span data-ttu-id="e8b13-158">Klasa może implementować dowolną liczbę interfejsów, ale może dziedziczyć tylko po jednej klasie bazowej oprócz <xref:System.Object?displayProperty=nameWithType>, z której wszystkie klasy dziedziczą niejawnie.</span><span class="sxs-lookup"><span data-stu-id="e8b13-158">A class can implement any number of interfaces, but it can inherit from only one base class in addition to <xref:System.Object?displayProperty=nameWithType>, from which all classes inherit implicitly.</span></span> <span data-ttu-id="e8b13-159">Wszystkie klasy muszą mieć co najmniej jeden Konstruktor, który inicjuje nowe wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="e8b13-159">All classes must have at least one constructor, which initializes new instances of the class.</span></span> <span data-ttu-id="e8b13-160">Jeśli Konstruktor nie zostanie jawnie zdefiniowany, większość kompilatorów automatycznie udostępni konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-160">If you do not explicitly define a constructor, most compilers will automatically provide a parameterless constructor.</span></span>  
  
<a name="Structures"></a>   
### <a name="structures"></a><span data-ttu-id="e8b13-161">Struktury</span><span class="sxs-lookup"><span data-stu-id="e8b13-161">Structures</span></span>  
 <span data-ttu-id="e8b13-162">Struktura jest typem wartości, który dziedziczy niejawnie z <xref:System.ValueType?displayProperty=nameWithType>, który z kolei jest wyprowadzany z <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-162">A structure is a value type that derives implicitly from <xref:System.ValueType?displayProperty=nameWithType>, which in turn is derived from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8b13-163">Struktura jest bardzo przydatna do reprezentowania wartości, których wymagania dotyczące pamięci są małe, oraz przekazywania wartości jako parametrów przez wartość do metod, które mają parametry o jednoznacznie określonym typie.</span><span class="sxs-lookup"><span data-stu-id="e8b13-163">A structure is very useful for representing values whose memory requirements are small, and for passing values as by-value parameters to methods that have strongly typed parameters.</span></span> <span data-ttu-id="e8b13-164">W programie .NET wszystkie typy danych pierwotnych (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.Single>, <xref:System.UInt16>, <xref:System.UInt32>i <xref:System.UInt64>) są zdefiniowane jako struktury.</span><span class="sxs-lookup"><span data-stu-id="e8b13-164">In .NET, all primitive data types (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.Single>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64>) are defined as structures.</span></span>  
  
 <span data-ttu-id="e8b13-165">Podobnie jak klasy, struktury definiują zarówno dane (pola struktury), jak i operacje, które mogą być wykonywane na tych danych (metody struktury).</span><span class="sxs-lookup"><span data-stu-id="e8b13-165">Like classes, structures define both data (the fields of the structure) and the operations that can be performed on that data (the methods of the structure).</span></span> <span data-ttu-id="e8b13-166">Oznacza to, że można wywołać metody dla struktur, w tym metody wirtualne zdefiniowane w klasach <xref:System.Object?displayProperty=nameWithType> i <xref:System.ValueType?displayProperty=nameWithType>, a także wszelkie metody zdefiniowane dla samego typu wartości.</span><span class="sxs-lookup"><span data-stu-id="e8b13-166">This means that you can call methods on structures, including the virtual methods defined on the <xref:System.Object?displayProperty=nameWithType> and <xref:System.ValueType?displayProperty=nameWithType> classes, and any methods defined on the value type itself.</span></span> <span data-ttu-id="e8b13-167">Inaczej mówiąc, struktury mogą mieć pola, właściwości i zdarzenia, a także metody statyczne i niestatyczne.</span><span class="sxs-lookup"><span data-stu-id="e8b13-167">In other words, structures can have fields, properties, and events, as well as static and nonstatic methods.</span></span> <span data-ttu-id="e8b13-168">Można utworzyć wystąpienia struktur, przekazać je jako parametry, zapisać je jako zmienne lokalne lub zapisać je w polu innego typu wartości lub typu odwołania.</span><span class="sxs-lookup"><span data-stu-id="e8b13-168">You can create instances of structures, pass them as parameters, store them as local variables, or store them in a field of another value type or reference type.</span></span> <span data-ttu-id="e8b13-169">Struktury mogą również implementować interfejsy.</span><span class="sxs-lookup"><span data-stu-id="e8b13-169">Structures can also implement interfaces.</span></span>  
  
 <span data-ttu-id="e8b13-170">Typy wartości różnią się także od klas w kilku aspektach.</span><span class="sxs-lookup"><span data-stu-id="e8b13-170">Value types also differ from classes in several respects.</span></span> <span data-ttu-id="e8b13-171">Po pierwsze, chociaż niejawnie dziedziczą z <xref:System.ValueType?displayProperty=nameWithType>, nie mogą dziedziczyć bezpośrednio z dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-171">First, although they implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, they cannot directly inherit from any type.</span></span> <span data-ttu-id="e8b13-172">Podobnie wszystkie typy wartości są zapieczętowane, co oznacza, że żaden inny typ nie może być uzyskany z nich.</span><span class="sxs-lookup"><span data-stu-id="e8b13-172">Similarly, all value types are sealed, which means that no other type can be derived from them.</span></span> <span data-ttu-id="e8b13-173">Nie wymagają również konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-173">They also do not require constructors.</span></span>  
  
 <span data-ttu-id="e8b13-174">Dla każdego typu wartości środowisko uruchomieniowe języka wspólnego dostarcza odpowiedni typ opakowany, który jest klasą, która ma ten sam stan i zachowanie co typ wartości.</span><span class="sxs-lookup"><span data-stu-id="e8b13-174">For each value type, the common language runtime supplies a corresponding boxed type, which is a class that has the same state and behavior as the value type.</span></span> <span data-ttu-id="e8b13-175">Wystąpienie typu wartości jest opakowane, gdy zostanie przesłane do metody, która akceptuje parametr typu <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-175">An instance of a value type is boxed when it is passed to a method that accepts a parameter of type <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8b13-176">Jest on nieopakowany (czyli konwertowany z wystąpienia klasy z powrotem do wystąpienia typu wartości), gdy sterowanie zwraca z wywołania metody, które akceptuje typ wartości jako parametr przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="e8b13-176">It is unboxed (that is, converted from an instance of a class back to an instance of a value type) when control returns from a method call that accepts a value type as a by-reference parameter.</span></span> <span data-ttu-id="e8b13-177">Niektóre języki wymagają użycia specjalnej składni, gdy wymagany jest typ opakowany; inne osoby automatycznie używają typu opakowanego, gdy jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="e8b13-177">Some languages require that you use special syntax when the boxed type is required; others automatically use the boxed type when it is needed.</span></span> <span data-ttu-id="e8b13-178">Podczas definiowania typu wartości, definiuje się zarówno opakowany, jak i nieopakowany typ.</span><span class="sxs-lookup"><span data-stu-id="e8b13-178">When you define a value type, you are defining both the boxed and the unboxed type.</span></span>  
  
<a name="Enumerations"></a>   
### <a name="enumerations"></a><span data-ttu-id="e8b13-179">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-179">Enumerations</span></span>  
 <span data-ttu-id="e8b13-180">Wyliczenie (Wyliczenie) jest typem wartości, który dziedziczy bezpośrednio z <xref:System.Enum?displayProperty=nameWithType> i dostarcza alternatywne nazwy dla wartości podstawowego typu pierwotnego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-180">An enumeration (enum) is a value type that inherits directly from <xref:System.Enum?displayProperty=nameWithType> and that supplies alternate names for the values of an underlying primitive type.</span></span> <span data-ttu-id="e8b13-181">Typ wyliczenia ma nazwę, typ podstawowy, który musi być jednym z wbudowanych typów liczb całkowitych ze znakiem lub bez znaku (takich jak <xref:System.Byte>, <xref:System.Int32>lub <xref:System.UInt64>) i zestaw pól.</span><span class="sxs-lookup"><span data-stu-id="e8b13-181">An enumeration type has a name, an underlying type that must be one of the built-in signed or unsigned integer types (such as <xref:System.Byte>, <xref:System.Int32>, or <xref:System.UInt64>), and a set of fields.</span></span> <span data-ttu-id="e8b13-182">Pola to statyczne pola literału, z których każdy reprezentuje stałą.</span><span class="sxs-lookup"><span data-stu-id="e8b13-182">The fields are static literal fields, each of which represents a constant.</span></span> <span data-ttu-id="e8b13-183">Tę samą wartość można przypisać do wielu pól.</span><span class="sxs-lookup"><span data-stu-id="e8b13-183">The same value can be assigned to multiple fields.</span></span> <span data-ttu-id="e8b13-184">W takim przypadku należy oznaczyć jedną z wartości jako podstawową wartość wyliczenia dla odbicia i konwersji ciągów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-184">When this occurs, you must mark one of the values as the primary enumeration value for reflection and string conversion.</span></span>  
  
 <span data-ttu-id="e8b13-185">Do wyliczenia i na odwrót można przypisać wartość typu podstawowego (w czasie wykonywania nie jest wymagane rzutowanie).</span><span class="sxs-lookup"><span data-stu-id="e8b13-185">You can assign a value of the underlying type to an enumeration and vice versa (no cast is required by the runtime).</span></span> <span data-ttu-id="e8b13-186">Można utworzyć wystąpienie wyliczenia i wywołać metody <xref:System.Enum?displayProperty=nameWithType>, a także wszelkie metody zdefiniowane w typie podstawowym wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="e8b13-186">You can create an instance of an enumeration and call the methods of <xref:System.Enum?displayProperty=nameWithType>, as well as any methods defined on the enumeration's underlying type.</span></span> <span data-ttu-id="e8b13-187">Jednak niektóre języki mogą nie zezwalać na przekazywanie wyliczenia jako parametru, gdy wymagane jest wystąpienie typu podstawowego (lub odwrotnie).</span><span class="sxs-lookup"><span data-stu-id="e8b13-187">However, some languages might not let you pass an enumeration as a parameter when an instance of the underlying type is required (or vice versa).</span></span>  
  
 <span data-ttu-id="e8b13-188">Następujące dodatkowe ograniczenia dotyczą wyliczeń:</span><span class="sxs-lookup"><span data-stu-id="e8b13-188">The following additional restrictions apply to enumerations:</span></span>  
  
- <span data-ttu-id="e8b13-189">Nie mogą definiować własnych metod.</span><span class="sxs-lookup"><span data-stu-id="e8b13-189">They cannot define their own methods.</span></span>  
  
- <span data-ttu-id="e8b13-190">Nie mogą implementować interfejsów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-190">They cannot implement interfaces.</span></span>  
  
- <span data-ttu-id="e8b13-191">Nie mogą definiować właściwości ani zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e8b13-191">They cannot define properties or events.</span></span>  
  
- <span data-ttu-id="e8b13-192">Nie mogą one być ogólne, chyba że są ogólne tylko, ponieważ są zagnieżdżone w obrębie typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-192">They cannot be generic, unless they are generic only because they are nested within a generic type.</span></span> <span data-ttu-id="e8b13-193">Oznacza to, że Wyliczenie nie może mieć własnych parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-193">That is, an enumeration cannot have type parameters of its own.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="e8b13-194">Zagnieżdżone typy (w tym wyliczenia) utworzone za pomocą Visual Basic C#, i C++ obejmują parametry typu wszystkich otaczających typów ogólnych i dlatego są ogólne, nawet jeśli nie mają własnych parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-194">Nested types (including enumerations) created with Visual Basic, C#, and C++ include the type parameters of all enclosing generic types, and are therefore generic even if they do not have type parameters of their own.</span></span> <span data-ttu-id="e8b13-195">Aby uzyskać więcej informacji, zobacz "typy zagnieżdżone" w temacie <xref:System.Type.MakeGenericType%2A?displayProperty=nameWithType> Reference.</span><span class="sxs-lookup"><span data-stu-id="e8b13-195">For more information, see "Nested Types" in the <xref:System.Type.MakeGenericType%2A?displayProperty=nameWithType> reference topic.</span></span>  
  
 <span data-ttu-id="e8b13-196">Atrybut <xref:System.FlagsAttribute> oznacza specjalny rodzaj wyliczenia nazywany polem bitowym.</span><span class="sxs-lookup"><span data-stu-id="e8b13-196">The <xref:System.FlagsAttribute> attribute denotes a special kind of enumeration called a bit field.</span></span> <span data-ttu-id="e8b13-197">Samo środowisko uruchomieniowe nie rozróżnia tradycyjnych wyliczeń i pól bitowych, ale język może to zrobić.</span><span class="sxs-lookup"><span data-stu-id="e8b13-197">The runtime itself does not distinguish between traditional enumerations and bit fields, but your language might do so.</span></span> <span data-ttu-id="e8b13-198">Po wykonaniu tego rozróżnienia operatory bitowe mogą być używane w polach bitowych, ale nie w wyliczeniach, aby generować wartości nienazwanych.</span><span class="sxs-lookup"><span data-stu-id="e8b13-198">When this distinction is made, bitwise operators can be used on bit fields, but not on enumerations, to generate unnamed values.</span></span> <span data-ttu-id="e8b13-199">Wyliczenia są zwykle używane dla list unikatowych elementów, takich jak dni tygodnia, nazwy kraju lub regionu i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="e8b13-199">Enumerations are generally used for lists of unique elements, such as days of the week, country or region names, and so on.</span></span> <span data-ttu-id="e8b13-200">Pola bitowe są zwykle używane dla list jakości lub ilości, które mogą wystąpić w połączeniu, takich jak `Red And Big And Fast`.</span><span class="sxs-lookup"><span data-stu-id="e8b13-200">Bit fields are generally used for lists of qualities or quantities that might occur in combination, such as `Red And Big And Fast`.</span></span>  
  
 <span data-ttu-id="e8b13-201">Poniższy przykład pokazuje, jak używać pól bitowych i tradycyjnych wyliczeń.</span><span class="sxs-lookup"><span data-stu-id="e8b13-201">The following example shows how to use both bit fields and traditional enumerations.</span></span>  
  
 [!code-csharp[Conceptual.Types.Enum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.enum/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Enum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.enum/vb/example.vb#1)]  
  
<a name="Interfaces"></a>   
### <a name="interfaces"></a><span data-ttu-id="e8b13-202">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="e8b13-202">Interfaces</span></span>  
 <span data-ttu-id="e8b13-203">Interfejs definiuje kontrakt, który określa relację "może być" lub "ma".</span><span class="sxs-lookup"><span data-stu-id="e8b13-203">An interface defines a contract that specifies a "can do" relationship or a "has a" relationship.</span></span> <span data-ttu-id="e8b13-204">Interfejsy są często używane do implementowania funkcji, takich jak porównywanie i sortowanie (interfejsy <xref:System.IComparable> i <xref:System.IComparable%601>), testowanie pod kątem równości (interfejs <xref:System.IEquatable%601>) lub wyliczanie elementów w kolekcji (<xref:System.Collections.IEnumerable> i <xref:System.Collections.Generic.IEnumerable%601> interfejsy).</span><span class="sxs-lookup"><span data-stu-id="e8b13-204">Interfaces are often used to implement functionality, such as comparing and sorting (the <xref:System.IComparable> and <xref:System.IComparable%601> interfaces), testing for equality (the <xref:System.IEquatable%601> interface), or enumerating items in a collection (the <xref:System.Collections.IEnumerable> and <xref:System.Collections.Generic.IEnumerable%601> interfaces).</span></span> <span data-ttu-id="e8b13-205">Interfejsy mogą mieć właściwości, metody i zdarzenia, z których wszystkie są abstrakcyjnymi elementami członkowskimi; oznacza to, że chociaż interfejs definiuje elementy członkowskie i ich podpisy, opuszcza typ, który implementuje interfejs, aby zdefiniować funkcje każdego elementu członkowskiego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-205">Interfaces can have properties, methods, and events, all of which are abstract members; that is, although the interface defines the members and their signatures, it leaves it to the type that implements the interface to define the functionality of each interface member.</span></span> <span data-ttu-id="e8b13-206">Oznacza to, że każda klasa lub struktura implementująca interfejs musi podawać definicje dla abstrakcyjnych elementów członkowskich zadeklarowanych w interfejsie.</span><span class="sxs-lookup"><span data-stu-id="e8b13-206">This means that any class or structure that implements an interface must supply definitions for the abstract members declared in the interface.</span></span> <span data-ttu-id="e8b13-207">Interfejs może wymagać dowolnej klasy lub struktury implementującej w celu zaimplementowania co najmniej jednego innego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-207">An interface can require any implementing class or structure to also implement one or more other interfaces.</span></span>  
  
 <span data-ttu-id="e8b13-208">Do interfejsów stosowane są następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="e8b13-208">The following restrictions apply to interfaces:</span></span>  
  
- <span data-ttu-id="e8b13-209">Interfejs można zadeklarować z dowolnym ułatwieniam dostępu, ale wszystkie elementy członkowskie interfejsu muszą mieć dostęp publiczny.</span><span class="sxs-lookup"><span data-stu-id="e8b13-209">An interface can be declared with any accessibility, but interface members must all have public accessibility.</span></span>  
  
- <span data-ttu-id="e8b13-210">Interfejsy nie mogą definiować konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-210">Interfaces cannot define constructors.</span></span>  
  
- <span data-ttu-id="e8b13-211">Interfejsy nie mogą definiować pól.</span><span class="sxs-lookup"><span data-stu-id="e8b13-211">Interfaces cannot define fields.</span></span>  
  
- <span data-ttu-id="e8b13-212">Interfejsy mogą definiować tylko elementy członkowskie wystąpień.</span><span class="sxs-lookup"><span data-stu-id="e8b13-212">Interfaces can define only instance members.</span></span> <span data-ttu-id="e8b13-213">Nie mogą definiować statycznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="e8b13-213">They cannot define static members.</span></span>  
  
 <span data-ttu-id="e8b13-214">Każdy język musi dostarczyć reguły mapowania implementacji do interfejsu, który wymaga elementu członkowskiego, ponieważ więcej niż jeden interfejs może deklarować składową z tym samym podpisem, a te elementy członkowskie mogą mieć oddzielne implementacje.</span><span class="sxs-lookup"><span data-stu-id="e8b13-214">Each language must provide rules for mapping an implementation to the interface that requires the member, because more than one interface can declare a member with the same signature, and these members can have separate implementations.</span></span>  
  
<a name="Delegates"></a>   
### <a name="delegates"></a><span data-ttu-id="e8b13-215">Delegaty</span><span class="sxs-lookup"><span data-stu-id="e8b13-215">Delegates</span></span>  
 <span data-ttu-id="e8b13-216">Delegaty są typami odwołań, które służą do celów podobnych do wskaźników funkcji C++w.</span><span class="sxs-lookup"><span data-stu-id="e8b13-216">Delegates are reference types that serve a purpose similar to that of function pointers in C++.</span></span> <span data-ttu-id="e8b13-217">Są one używane na potrzeby obsługi zdarzeń i funkcji wywołania zwrotnego w programie .NET.</span><span class="sxs-lookup"><span data-stu-id="e8b13-217">They are used for event handlers and callback functions in .NET.</span></span> <span data-ttu-id="e8b13-218">W przeciwieństwie do wskaźników funkcji Delegaty są bezpieczne, sprawdzalne i typu bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="e8b13-218">Unlike function pointers, delegates are secure, verifiable, and type safe.</span></span> <span data-ttu-id="e8b13-219">Typ delegata może reprezentować każdą metodę wystąpienia lub metodę statyczną, która ma zgodną sygnaturę.</span><span class="sxs-lookup"><span data-stu-id="e8b13-219">A delegate type can represent any instance method or static method that has a compatible signature.</span></span>  
  
 <span data-ttu-id="e8b13-220">Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.</span><span class="sxs-lookup"><span data-stu-id="e8b13-220">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="e8b13-221">Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.</span><span class="sxs-lookup"><span data-stu-id="e8b13-221">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="e8b13-222">Na przykład delegat, który ma parametr typu <xref:System.Collections.IEnumerable> i zwracany typ <xref:System.Object> może reprezentować metodę, która ma parametr typu <xref:System.Object> i wartość zwracaną typu <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-222">For example, a delegate that has a parameter of type <xref:System.Collections.IEnumerable> and a return type of <xref:System.Object> can represent a method that has a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.IEnumerable>.</span></span> <span data-ttu-id="e8b13-223">Aby uzyskać więcej informacji i przykładowy kod, zobacz <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-223">For more information and example code, see <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e8b13-224">Delegat jest określany jako powiązany z metodą, która reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="e8b13-224">A delegate is said to be bound to the method it represents.</span></span> <span data-ttu-id="e8b13-225">Oprócz powiązania z metodą delegata można powiązać z obiektem.</span><span class="sxs-lookup"><span data-stu-id="e8b13-225">In addition to being bound to the method, a delegate can be bound to an object.</span></span> <span data-ttu-id="e8b13-226">Obiekt reprezentuje pierwszy parametr metody i jest przenoszona do metody za każdym razem, gdy obiekt delegowany jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="e8b13-226">The object represents the first parameter of the method, and is passed to the method every time the delegate is invoked.</span></span> <span data-ttu-id="e8b13-227">Jeśli metoda jest metodą wystąpienia, obiektem związanym jest przekazanie jako niejawny parametr `this` (`Me` w Visual Basic). Jeśli metoda jest statyczna, obiekt jest przenoszona jako pierwszy parametr formalny metody, a sygnatura delegata musi być zgodna z pozostałymi parametrami.</span><span class="sxs-lookup"><span data-stu-id="e8b13-227">If the method is an instance method, the bound object is passed as the implicit `this` parameter (`Me` in Visual Basic); if the method is static, the object is passed as the first formal parameter of the method, and the delegate signature must match the remaining parameters.</span></span> <span data-ttu-id="e8b13-228">Aby uzyskać więcej informacji i przykładowy kod, zobacz <xref:System.Delegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-228">For more information and example code, see <xref:System.Delegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e8b13-229">Wszystkie Delegaty dziedziczą po <xref:System.MulticastDelegate?displayProperty=nameWithType>, który dziedziczy po <xref:System.Delegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-229">All delegates inherit from <xref:System.MulticastDelegate?displayProperty=nameWithType>, which inherits from <xref:System.Delegate?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8b13-230">Języki C#, Visual Basic i C++ nie zezwalają na dziedziczenie z tych typów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-230">The C#, Visual Basic, and C++ languages do not allow inheritance from these types.</span></span> <span data-ttu-id="e8b13-231">Zamiast tego dostarczają słowa kluczowe do deklarowania delegatów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-231">Instead, they provide keywords for declaring delegates.</span></span>  
  
 <span data-ttu-id="e8b13-232">Ponieważ obiekty delegowane dziedziczą z <xref:System.MulticastDelegate>, delegat ma listę wywołań, która jest listą metod, które reprezentuje delegat i które są wykonywane, gdy obiekt delegowany jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="e8b13-232">Because delegates inherit from <xref:System.MulticastDelegate>, a delegate has an invocation list, which is a list of methods that the delegate represents and that are executed when the delegate is invoked.</span></span> <span data-ttu-id="e8b13-233">Wszystkie metody na liście odbierają argumenty dostarczone, gdy obiekt delegowany jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="e8b13-233">All methods in the list receive the arguments supplied when the delegate is invoked.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e8b13-234">Wartość zwracana nie jest zdefiniowana dla delegata, który ma więcej niż jedną metodę na liście wywołań, nawet jeśli delegat ma zwracany typ.</span><span class="sxs-lookup"><span data-stu-id="e8b13-234">The return value is not defined for a delegate that has more than one method in its invocation list, even if the delegate has a return type.</span></span>  
  
 <span data-ttu-id="e8b13-235">W wielu przypadkach, takich jak metody wywołania zwrotnego, delegat reprezentuje tylko jedną metodę, a jedyne akcje, które należy wykonać, tworzą delegata i wywołującego go.</span><span class="sxs-lookup"><span data-stu-id="e8b13-235">In many cases, such as with callback methods, a delegate represents only one method, and the only actions you have to take are creating the delegate and invoking it.</span></span>  
  
 <span data-ttu-id="e8b13-236">W przypadku delegatów reprezentujących wiele metod platforma .NET udostępnia metody <xref:System.Delegate> i <xref:System.MulticastDelegate> klasy delegatów do obsługi operacji, takich jak dodawanie metody do listy wywołań delegata (Metoda <xref:System.Delegate.Combine%2A?displayProperty=nameWithType>), usuwanie metody (Metoda <xref:System.Delegate.Remove%2A?displayProperty=nameWithType>). i pobierając listę wywołań (Metoda <xref:System.Delegate.GetInvocationList%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="e8b13-236">For delegates that represent multiple methods, .NET provides methods of the <xref:System.Delegate> and <xref:System.MulticastDelegate> delegate classes to support operations such as adding a method to a delegate's invocation list (the <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> method), removing a method (the <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> method), and getting the invocation list (the <xref:System.Delegate.GetInvocationList%2A?displayProperty=nameWithType> method).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e8b13-237">Nie jest konieczne używanie tych metod w przypadku delegatów obsługi zdarzeń w C#, C++, i Visual Basic, ponieważ Języki te zawierają składnię do dodawania i usuwania programów obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e8b13-237">It is not necessary to use these methods for event-handler delegates in C#, C++, and Visual Basic, because these languages provide syntax for adding and removing event handlers.</span></span>  

<a name="type_definitions"></a>   
## <a name="type-definitions"></a><span data-ttu-id="e8b13-238">Definicje typu</span><span class="sxs-lookup"><span data-stu-id="e8b13-238">Type Definitions</span></span>  
 <span data-ttu-id="e8b13-239">Definicja typu zawiera następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="e8b13-239">A type definition includes the following:</span></span>  
  
- <span data-ttu-id="e8b13-240">Wszystkie atrybuty zdefiniowane w typie.</span><span class="sxs-lookup"><span data-stu-id="e8b13-240">Any attributes defined on the type.</span></span>  
  
- <span data-ttu-id="e8b13-241">Dostępność typu (widoczność).</span><span class="sxs-lookup"><span data-stu-id="e8b13-241">The type's accessibility (visibility).</span></span>  
  
- <span data-ttu-id="e8b13-242">Nazwa typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-242">The type's name.</span></span>  
  
- <span data-ttu-id="e8b13-243">Typ podstawowy typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-243">The type's base type.</span></span>  
  
- <span data-ttu-id="e8b13-244">Wszystkie interfejsy zaimplementowane przez typ.</span><span class="sxs-lookup"><span data-stu-id="e8b13-244">Any interfaces implemented by the type.</span></span>  
  
- <span data-ttu-id="e8b13-245">Definicje dla każdego elementu członkowskiego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-245">Definitions for each of the type's members.</span></span>  
  
### <a name="attributes"></a><span data-ttu-id="e8b13-246">Atrybuty</span><span class="sxs-lookup"><span data-stu-id="e8b13-246">Attributes</span></span>  
 <span data-ttu-id="e8b13-247">Atrybuty zapewniają dodatkowe metadane zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e8b13-247">Attributes provide additional user-defined metadata.</span></span> <span data-ttu-id="e8b13-248">Najczęściej są one używane do przechowywania dodatkowych informacji o typie w zestawie lub do modyfikacji zachowania elementu członkowskiego typu w środowisku czasu projektowania lub czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="e8b13-248">Most commonly, they are used to store additional information about a type in its assembly, or to modify the behavior of a type member in either the design-time or run-time environment.</span></span>  
  
 <span data-ttu-id="e8b13-249">Atrybuty są same klas, które dziedziczą z <xref:System.Attribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-249">Attributes are themselves classes that inherit from <xref:System.Attribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8b13-250">Języki, które obsługują korzystanie z atrybutów, mają własną składnię stosowania atrybutów do elementu języka.</span><span class="sxs-lookup"><span data-stu-id="e8b13-250">Languages that support the use of attributes each have their own syntax for applying attributes to a language element.</span></span> <span data-ttu-id="e8b13-251">Atrybuty mogą być stosowane do niemal dowolnego elementu języka; określone elementy, do których można zastosować atrybut, są definiowane przez <xref:System.AttributeUsageAttribute>, które są stosowane do tej klasy atrybutu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-251">Attributes can be applied to almost any language element; the specific elements to which an attribute can be applied are defined by the <xref:System.AttributeUsageAttribute> that is applied to that attribute class.</span></span>  
  
### <a name="type-accessibility"></a><span data-ttu-id="e8b13-252">Ułatwienia dostępu typu</span><span class="sxs-lookup"><span data-stu-id="e8b13-252">Type Accessibility</span></span>  
 <span data-ttu-id="e8b13-253">Wszystkie typy mają modyfikator, który reguluje dostępność z innych typów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-253">All types have a modifier that governs their accessibility from other types.</span></span> <span data-ttu-id="e8b13-254">W poniższej tabeli opisano typ podano obsługiwany przez środowisko uruchomieniowe.</span><span class="sxs-lookup"><span data-stu-id="e8b13-254">The following table describes the type accessibilities supported by the runtime.</span></span>  
  
|<span data-ttu-id="e8b13-255">Ułatwienia dostępu</span><span class="sxs-lookup"><span data-stu-id="e8b13-255">Accessibility</span></span>|<span data-ttu-id="e8b13-256">Opis</span><span class="sxs-lookup"><span data-stu-id="e8b13-256">Description</span></span>|  
|-------------------|-----------------|  
|<span data-ttu-id="e8b13-257">public</span><span class="sxs-lookup"><span data-stu-id="e8b13-257">public</span></span>|<span data-ttu-id="e8b13-258">Typ jest dostępny dla wszystkich zestawów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-258">The type is accessible by all assemblies.</span></span>|  
|<span data-ttu-id="e8b13-259">zestaw</span><span class="sxs-lookup"><span data-stu-id="e8b13-259">assembly</span></span>|<span data-ttu-id="e8b13-260">Typ jest dostępny tylko w obrębie swojego zestawu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-260">The type is accessible only from within its assembly.</span></span>|  
  
 <span data-ttu-id="e8b13-261">Dostępność typu zagnieżdżonego zależy od jego domeny dostępności, który jest określany przez zadeklarowaną dostępność elementu członkowskiego i domenę dostępności typu natychmiastowego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-261">The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type.</span></span> <span data-ttu-id="e8b13-262">Jednak domena dostępności typu zagnieżdżonego nie może przekroczyć tego typu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-262">However, the accessibility domain of a nested type cannot exceed that of the containing type.</span></span>  
  
 <span data-ttu-id="e8b13-263">Domena dostępności zagnieżdżonego elementu członkowskiego `M` zadeklarowana w typie `T` w programie `P` jest zdefiniowana w następujący sposób (zwracając uwagę, że `M` może być typem):</span><span class="sxs-lookup"><span data-stu-id="e8b13-263">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` might itself be a type):</span></span>  
  
- <span data-ttu-id="e8b13-264">Jeśli deklarowana dostępność `M` jest `public`, domena dostępności `M` jest domeną dostępności `T`.</span><span class="sxs-lookup"><span data-stu-id="e8b13-264">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>  
  
- <span data-ttu-id="e8b13-265">Jeśli deklarowana dostępność `M` jest `protected internal`, domena dostępności `M` jest częścią wspólną domeny dostępności `T` z tekstem programu `P` i tekstem programu dowolnego typu pochodzącego od `T` zadeklarowane poza `P`.</span><span class="sxs-lookup"><span data-stu-id="e8b13-265">If the declared accessibility of `M` is `protected internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P` and the program text of any type derived from `T` declared outside `P`.</span></span>  
  
- <span data-ttu-id="e8b13-266">Jeśli deklarowana dostępność `M` jest `protected`, domena dostępności `M` jest częścią wspólną domeny dostępności `T` z tekstem programu `T` i dowolnym typem uzyskanym z `T`.</span><span class="sxs-lookup"><span data-stu-id="e8b13-266">If the declared accessibility of `M` is `protected`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `T` and any type derived from `T`.</span></span>  
  
- <span data-ttu-id="e8b13-267">Jeśli deklarowana dostępność `M` jest `internal`, domena dostępności `M` jest częścią wspólną domeny dostępności `T` z tekstem programu `P`.</span><span class="sxs-lookup"><span data-stu-id="e8b13-267">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>  
  
- <span data-ttu-id="e8b13-268">Jeśli deklarowana dostępność `M` jest `private`, domena dostępności `M` jest tekstem programu `T`.</span><span class="sxs-lookup"><span data-stu-id="e8b13-268">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>  
  
### <a name="type-names"></a><span data-ttu-id="e8b13-269">Nazwy typów</span><span class="sxs-lookup"><span data-stu-id="e8b13-269">Type Names</span></span>  
 <span data-ttu-id="e8b13-270">Wspólny system typów nakłada tylko dwa ograniczenia dotyczące nazw:</span><span class="sxs-lookup"><span data-stu-id="e8b13-270">The common type system imposes only two restrictions on names:</span></span>  
  
- <span data-ttu-id="e8b13-271">Wszystkie nazwy są kodowane jako ciągi znaków Unicode (16-bitowych).</span><span class="sxs-lookup"><span data-stu-id="e8b13-271">All names are encoded as strings of Unicode (16-bit) characters.</span></span>  
  
- <span data-ttu-id="e8b13-272">Nazwy nie mogą mieć osadzonej wartości (16-bitowej) 0x0000.</span><span class="sxs-lookup"><span data-stu-id="e8b13-272">Names are not permitted to have an embedded (16-bit) value of 0x0000.</span></span>  
  
 <span data-ttu-id="e8b13-273">Jednak większość języków nakłada dodatkowe ograniczenia dotyczące nazw typów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-273">However, most languages impose additional restrictions on type names.</span></span> <span data-ttu-id="e8b13-274">Wszystkie porównania są wykonywane w oparciu o bajt po bajcie i dlatego są zależne od wielkości liter i dla ustawień regionalnych.</span><span class="sxs-lookup"><span data-stu-id="e8b13-274">All comparisons are done on a byte-by-byte basis, and are therefore case-sensitive and locale-independent.</span></span>  
  
 <span data-ttu-id="e8b13-275">Chociaż typ może odwoływać się do typów z innych modułów i zestawów, typ musi być w pełni zdefiniowany w obrębie jednego modułu .NET.</span><span class="sxs-lookup"><span data-stu-id="e8b13-275">Although a type might reference types from other modules and assemblies, a type must be fully defined within one .NET module.</span></span> <span data-ttu-id="e8b13-276">(W zależności od obsługi kompilatora można jednak podzielić je na wiele plików kodu źródłowego). Nazwy typów muszą być unikatowe tylko w obrębie przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e8b13-276">(Depending on compiler support, however, it can be divided into multiple source code files.) Type names need be unique only within a namespace.</span></span> <span data-ttu-id="e8b13-277">Aby w pełni identyfikować typ, nazwa typu musi być kwalifikowana według przestrzeni nazw zawierającej implementację typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-277">To fully identify a type, the type name must be qualified by the namespace that contains the implementation of the type.</span></span>  
  
### <a name="base-types-and-interfaces"></a><span data-ttu-id="e8b13-278">Typy podstawowe i interfejsy</span><span class="sxs-lookup"><span data-stu-id="e8b13-278">Base Types and Interfaces</span></span>  
 <span data-ttu-id="e8b13-279">Typ może dziedziczyć wartości i zachowania z innego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-279">A type can inherit values and behaviors from another type.</span></span> <span data-ttu-id="e8b13-280">Wspólny system typów nie zezwala na dziedziczenie typów z więcej niż jednego typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-280">The common type system does not allow types to inherit from more than one base type.</span></span>  
  
 <span data-ttu-id="e8b13-281">Typ może implementować dowolną liczbę interfejsów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-281">A type can implement any number of interfaces.</span></span> <span data-ttu-id="e8b13-282">Aby zaimplementować interfejs, typ musi implementować wszystkie wirtualne elementy członkowskie tego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-282">To implement an interface, a type must implement all the virtual members of that interface.</span></span> <span data-ttu-id="e8b13-283">Metoda wirtualna może być implementowana przez typ pochodny i może być wywoływana statycznie lub dynamicznie.</span><span class="sxs-lookup"><span data-stu-id="e8b13-283">A virtual method can be implemented by a derived type and can be invoked either statically or dynamically.</span></span>  

<a name="type_members"></a>   
## <a name="type-members"></a><span data-ttu-id="e8b13-284">Składowe typu</span><span class="sxs-lookup"><span data-stu-id="e8b13-284">Type Members</span></span>  
 <span data-ttu-id="e8b13-285">Środowisko uruchomieniowe umożliwia definiowanie elementów członkowskich typu, które określają zachowanie i stan typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-285">The runtime enables you to define members of your type, which specifies the behavior and state of a type.</span></span> <span data-ttu-id="e8b13-286">Elementy członkowskie typu są następujące:</span><span class="sxs-lookup"><span data-stu-id="e8b13-286">Type members include the following:</span></span>  
  
- [<span data-ttu-id="e8b13-287">Pola</span><span class="sxs-lookup"><span data-stu-id="e8b13-287">Fields</span></span>](#Fields)  
  
- [<span data-ttu-id="e8b13-288">Właściwości</span><span class="sxs-lookup"><span data-stu-id="e8b13-288">Properties</span></span>](#Properties)  
  
- [<span data-ttu-id="e8b13-289">Metody</span><span class="sxs-lookup"><span data-stu-id="e8b13-289">Methods</span></span>](#Methods)  
  
- [<span data-ttu-id="e8b13-290">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="e8b13-290">Constructors</span></span>](#Constructors)  
  
- [<span data-ttu-id="e8b13-291">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-291">Events</span></span>](#Events)  
  
- [<span data-ttu-id="e8b13-292">Typy zagnieżdżone</span><span class="sxs-lookup"><span data-stu-id="e8b13-292">Nested types</span></span>](#NestedTypes)  
  
<a name="Fields"></a>   
### <a name="fields"></a><span data-ttu-id="e8b13-293">Pola</span><span class="sxs-lookup"><span data-stu-id="e8b13-293">Fields</span></span>  
 <span data-ttu-id="e8b13-294">Pole opisuje i zawiera część stanu typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-294">A field describes and contains part of the type's state.</span></span> <span data-ttu-id="e8b13-295">Pola mogą być dowolnego typu obsługiwanego przez środowisko uruchomieniowe.</span><span class="sxs-lookup"><span data-stu-id="e8b13-295">Fields can be of any type supported by the runtime.</span></span> <span data-ttu-id="e8b13-296">Najczęściej są to pola `private` lub `protected`, dzięki czemu są dostępne tylko z poziomu klasy lub z klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="e8b13-296">Most commonly, fields are either `private` or `protected`, so that they are accessible only from within the class or from a derived class.</span></span> <span data-ttu-id="e8b13-297">Jeśli wartość pola można zmodyfikować spoza jego typu, zwykle jest używana metoda dostępu do zestawu właściwości.</span><span class="sxs-lookup"><span data-stu-id="e8b13-297">If the value of a field can be modified from outside its type, a property set accessor is typically used.</span></span> <span data-ttu-id="e8b13-298">Dostępne publicznie pola są zwykle tylko do odczytu i mogą być dwoma typami:</span><span class="sxs-lookup"><span data-stu-id="e8b13-298">Publicly exposed fields are usually read-only and can be of two types:</span></span>  
  
- <span data-ttu-id="e8b13-299">Stałe, których wartość jest przypisana w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="e8b13-299">Constants, whose value is assigned at design time.</span></span> <span data-ttu-id="e8b13-300">Są to statyczne elementy członkowskie klasy, chociaż nie są zdefiniowane za pomocą słowa kluczowego `static` (`Shared` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e8b13-300">These are static members of a class, although they are not defined using the `static` (`Shared` in Visual Basic) keyword.</span></span>  
  
- <span data-ttu-id="e8b13-301">Zmienne tylko do odczytu, których wartości można przypisać w konstruktorze klasy.</span><span class="sxs-lookup"><span data-stu-id="e8b13-301">Read-only variables, whose values can be assigned in the class constructor.</span></span>  
  
 <span data-ttu-id="e8b13-302">Poniższy przykład ilustruje te dwa sposoby użycia pól tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-302">The following example illustrates these two usages of read-only fields.</span></span>  
  
 [!code-csharp[Conceptual.Types.Members.Fields#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.members.fields/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Members.Fields#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.members.fields/vb/example.vb#1)]  
  
<a name="Properties"></a>   
### <a name="properties"></a><span data-ttu-id="e8b13-303">Właściwości</span><span class="sxs-lookup"><span data-stu-id="e8b13-303">Properties</span></span>  
 <span data-ttu-id="e8b13-304">Właściwość zawiera nazwę wartości lub stanu typu i definiuje metody pobierania lub ustawiania wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="e8b13-304">A property names a value or state of the type and defines methods for getting or setting the property's value.</span></span> <span data-ttu-id="e8b13-305">Właściwości mogą być typami pierwotnymi, kolekcjami typów pierwotnych, typami zdefiniowanymi przez użytkownika lub kolekcjami typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e8b13-305">Properties can be primitive types, collections of primitive types, user-defined types, or collections of user-defined types.</span></span> <span data-ttu-id="e8b13-306">Właściwości są często używane, aby zachować publiczny interfejs typu niezależny od rzeczywistej reprezentacji typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-306">Properties are often used to keep the public interface of a type independent from the type's actual representation.</span></span> <span data-ttu-id="e8b13-307">Dzięki temu właściwości mogą odzwierciedlać wartości, które nie są bezpośrednio przechowywane w klasie (na przykład gdy właściwość zwraca obliczoną wartość) lub aby przeprowadzić walidację przed przypisaniem wartości do pól prywatnych.</span><span class="sxs-lookup"><span data-stu-id="e8b13-307">This enables properties to reflect values that are not directly stored in the class (for example, when a property returns a computed value) or to perform validation before values are assigned to private fields.</span></span> <span data-ttu-id="e8b13-308">Poniższy przykład ilustruje ten ostatni wzorzec.</span><span class="sxs-lookup"><span data-stu-id="e8b13-308">The following example illustrates the latter pattern.</span></span>  
  
 [!code-csharp[Conceptual.Types.Members.Properties#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.members.properties/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Members.Properties#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.members.properties/vb/example.vb#1)]  
  
 <span data-ttu-id="e8b13-309">Oprócz dołączania samej właściwości, język pośredni (MSIL) firmy Microsoft dla typu, który zawiera właściwość do odczytu, zawiera metodę `get_`*PropertyName* , a MSIL dla typu, który zawiera właściwość z możliwością zapisu, zawiera `set_`Metoda *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="e8b13-309">In addition to including the property itself, the Microsoft intermediate language (MSIL) for a type that contains a readable property includes a `get_`*propertyname* method, and the MSIL for a type that contains a writable property includes a `set_`*propertyname* method.</span></span>  
  
<a name="Methods"></a>   
### <a name="methods"></a><span data-ttu-id="e8b13-310">Metody</span><span class="sxs-lookup"><span data-stu-id="e8b13-310">Methods</span></span>  
 <span data-ttu-id="e8b13-311">Metoda opisuje operacje, które są dostępne dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-311">A method describes operations that are available on the type.</span></span> <span data-ttu-id="e8b13-312">Sygnatura metody Określa dozwolone typy wszystkich jej parametrów i wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="e8b13-312">A method's signature specifies the allowable types of all its parameters and of its return value.</span></span>  
  
 <span data-ttu-id="e8b13-313">Chociaż większość metod definiuje dokładną liczbę parametrów wymaganych dla wywołań metod, niektóre metody obsługują zmienną liczbę parametrów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-313">Although most methods define the precise number of parameters required for method calls, some methods support a variable number of parameters.</span></span> <span data-ttu-id="e8b13-314">Końcowy zadeklarowany parametr tych metod jest oznaczony atrybutem <xref:System.ParamArrayAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-314">The final declared parameter of these methods is marked with the <xref:System.ParamArrayAttribute> attribute.</span></span> <span data-ttu-id="e8b13-315">Kompilatory języka zwykle dostarczają słowa kluczowego, takiego jak `params` C# in i `ParamArray` w Visual Basic, co sprawia, że jawne użycie <xref:System.ParamArrayAttribute> niepotrzebne.</span><span class="sxs-lookup"><span data-stu-id="e8b13-315">Language compilers typically provide a keyword, such as `params` in C# and `ParamArray` in Visual Basic, that makes explicit use of <xref:System.ParamArrayAttribute> unnecessary.</span></span>  
  
<a name="Constructors"></a>   
### <a name="constructors"></a><span data-ttu-id="e8b13-316">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="e8b13-316">Constructors</span></span>  
 <span data-ttu-id="e8b13-317">Konstruktor jest specjalnym rodzajem metody, która tworzy nowe wystąpienia klasy lub struktury.</span><span class="sxs-lookup"><span data-stu-id="e8b13-317">A constructor is a special kind of method that creates new instances of a class or structure.</span></span> <span data-ttu-id="e8b13-318">Podobnie jak w przypadku każdej innej metody, Konstruktor może zawierać parametry; jednak konstruktory nie mają zwracanych wartości (oznacza to, że zwracają `void`).</span><span class="sxs-lookup"><span data-stu-id="e8b13-318">Like any other method, a constructor can include parameters; however, constructors have no return value (that is, they return `void`).</span></span>  
  
 <span data-ttu-id="e8b13-319">Jeśli kod źródłowy dla klasy nie definiuje jawnie konstruktora, kompilator zawiera konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-319">If the source code for a class does not explicitly define a constructor, the compiler includes a parameterless constructor.</span></span> <span data-ttu-id="e8b13-320">Jeśli jednak kod źródłowy klasy definiuje tylko konstruktory sparametryzowane, Visual Basic i C# kompilatory nie generują konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-320">However, if the source code for a class defines only parameterized constructors, the Visual Basic and C# compilers do not generate a parameterless constructor.</span></span>  
  
 <span data-ttu-id="e8b13-321">Jeśli kod źródłowy struktury definiuje konstruktory, muszą one być sparametryzowane; Struktura nie może definiować konstruktora bez parametrów, a kompilatory nie generują konstruktorów bezparametrów dla struktur lub innych typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e8b13-321">If the source code for a structure defines constructors, they must be parameterized; a structure cannot define a parameterless constructor, and compilers do not generate parameterless constructors for structures or other value types.</span></span> <span data-ttu-id="e8b13-322">Wszystkie typy wartości mają niejawny Konstruktor bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="e8b13-322">All value types do have an implicit parameterless constructor.</span></span> <span data-ttu-id="e8b13-323">Ten konstruktor jest implementowany przez środowisko uruchomieniowe języka wspólnego i inicjuje wszystkie pola struktury do ich wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="e8b13-323">This constructor is implemented by the common language runtime and initializes all fields of the structure to their default values.</span></span>  
  
<a name="Events"></a>   
### <a name="events"></a><span data-ttu-id="e8b13-324">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-324">Events</span></span>  
 <span data-ttu-id="e8b13-325">Zdarzenie definiuje zdarzenie, do którego można odpowiedzieć, i definiuje metody subskrybowania, anulowania subskrypcji i podnoszenia zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="e8b13-325">An event defines an incident that can be responded to, and defines methods for subscribing to, unsubscribing from, and raising the event.</span></span> <span data-ttu-id="e8b13-326">Zdarzenia są często używane do informowania o zmianach stanu innego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-326">Events are often used to inform other types of state changes.</span></span> <span data-ttu-id="e8b13-327">Aby uzyskać więcej informacji, zobacz [zdarzenia](../../../docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="e8b13-327">For more information, see [Events](../../../docs/standard/events/index.md).</span></span>  
  
<a name="NestedTypes"></a>   
### <a name="nested-types"></a><span data-ttu-id="e8b13-328">Zagnieżdżone typy</span><span class="sxs-lookup"><span data-stu-id="e8b13-328">Nested Types</span></span>  
 <span data-ttu-id="e8b13-329">Typ zagnieżdżony jest typem, który jest elementem członkowskim innego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-329">A nested type is a type that is a member of some other type.</span></span> <span data-ttu-id="e8b13-330">Zagnieżdżone typy powinny być ściśle sprzężone z ich typem zawierającym i nie mogą być przydatne jako typ ogólnego przeznaczenia.</span><span class="sxs-lookup"><span data-stu-id="e8b13-330">Nested types should be tightly coupled to their containing type and must not be useful as a general-purpose type.</span></span> <span data-ttu-id="e8b13-331">Zagnieżdżone typy są przydatne, gdy typ deklarujący używa i tworzy wystąpienia typu zagnieżdżonego, a użycie typu zagnieżdżonego nie jest ujawniane w publicznych składowych.</span><span class="sxs-lookup"><span data-stu-id="e8b13-331">Nested types are useful when the declaring type uses and creates instances of the nested type, and use of the nested type is not exposed in public members.</span></span>  
  
 <span data-ttu-id="e8b13-332">Zagnieżdżone typy są mylące dla niektórych deweloperów i nie powinny być publicznie widoczne, chyba że istnieje istotny powód widoczności.</span><span class="sxs-lookup"><span data-stu-id="e8b13-332">Nested types are confusing to some developers and should not be publicly visible unless there is a compelling reason for visibility.</span></span> <span data-ttu-id="e8b13-333">W dobrze zaprojektowanej bibliotece deweloperzy rzadko muszą używać zagnieżdżonych typów do tworzenia wystąpień obiektów lub deklarowania zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e8b13-333">In a well-designed library, developers should rarely have to use nested types to instantiate objects or declare variables.</span></span>  

<a name="characteristics_of_type_members"></a>   
## <a name="characteristics-of-type-members"></a><span data-ttu-id="e8b13-334">Charakterystyka elementów członkowskich typu</span><span class="sxs-lookup"><span data-stu-id="e8b13-334">Characteristics of Type Members</span></span>  
 <span data-ttu-id="e8b13-335">Wspólny system typów pozwala członkom typu mieć różne cechy; jednak języki nie są wymagane do obsługi wszystkich tych cech.</span><span class="sxs-lookup"><span data-stu-id="e8b13-335">The common type system allows type members to have a variety of characteristics; however, languages are not required to support all these characteristics.</span></span> <span data-ttu-id="e8b13-336">W poniższej tabeli opisano charakterystyki elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-336">The following table describes member characteristics.</span></span>  
  
|<span data-ttu-id="e8b13-337">Charakterystyk</span><span class="sxs-lookup"><span data-stu-id="e8b13-337">Characteristic</span></span>|<span data-ttu-id="e8b13-338">Może dotyczyć</span><span class="sxs-lookup"><span data-stu-id="e8b13-338">Can apply to</span></span>|<span data-ttu-id="e8b13-339">Opis</span><span class="sxs-lookup"><span data-stu-id="e8b13-339">Description</span></span>|  
|--------------------|------------------|-----------------|  
|<span data-ttu-id="e8b13-340">abstract</span><span class="sxs-lookup"><span data-stu-id="e8b13-340">abstract</span></span>|<span data-ttu-id="e8b13-341">Metody, właściwości i zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-341">Methods, properties, and events</span></span>|<span data-ttu-id="e8b13-342">Typ nie dostarcza implementacji metody.</span><span class="sxs-lookup"><span data-stu-id="e8b13-342">The type does not supply the method's implementation.</span></span> <span data-ttu-id="e8b13-343">Typy dziedziczące lub implementujące metody abstrakcyjne muszą dostarczać implementację metody.</span><span class="sxs-lookup"><span data-stu-id="e8b13-343">Types that inherit or implement abstract methods must supply an implementation for the method.</span></span> <span data-ttu-id="e8b13-344">Jedyny wyjątek polega na tym, że typ pochodny jest własnym typem abstrakcyjnym.</span><span class="sxs-lookup"><span data-stu-id="e8b13-344">The only exception is when the derived type is itself an abstract type.</span></span> <span data-ttu-id="e8b13-345">Wszystkie metody abstrakcyjne są wirtualne.</span><span class="sxs-lookup"><span data-stu-id="e8b13-345">All abstract methods are virtual.</span></span>|  
|<span data-ttu-id="e8b13-346">prywatna, Rodzina, zestaw, Rodzina i zestaw, Rodzina lub zestaw lub publiczne</span><span class="sxs-lookup"><span data-stu-id="e8b13-346">private, family, assembly, family and assembly, family or assembly, or public</span></span>|<span data-ttu-id="e8b13-347">Wszystkie</span><span class="sxs-lookup"><span data-stu-id="e8b13-347">All</span></span>|<span data-ttu-id="e8b13-348">Definiuje dostępność elementu członkowskiego:</span><span class="sxs-lookup"><span data-stu-id="e8b13-348">Defines the accessibility of the member:</span></span><br /><br /> <span data-ttu-id="e8b13-349">private</span><span class="sxs-lookup"><span data-stu-id="e8b13-349">private</span></span><br /> <span data-ttu-id="e8b13-350">Dostępne tylko z tego samego typu co element członkowski lub w obrębie typu zagnieżdżonego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-350">Accessible only from within the same type as the member, or within a nested type.</span></span><br /><br /> <span data-ttu-id="e8b13-351">rodziny</span><span class="sxs-lookup"><span data-stu-id="e8b13-351">family</span></span><br /> <span data-ttu-id="e8b13-352">Dostępne z tego samego typu co element członkowski oraz z typów pochodnych, które dziedziczą z niego.</span><span class="sxs-lookup"><span data-stu-id="e8b13-352">Accessible from within the same type as the member, and from derived types that inherit from it.</span></span><br /><br /> <span data-ttu-id="e8b13-353">zestaw</span><span class="sxs-lookup"><span data-stu-id="e8b13-353">assembly</span></span><br /> <span data-ttu-id="e8b13-354">Dostępne tylko w zestawie, w którym jest zdefiniowany typ.</span><span class="sxs-lookup"><span data-stu-id="e8b13-354">Accessible only in the assembly in which the type is defined.</span></span><br /><br /> <span data-ttu-id="e8b13-355">Rodzina i zestaw</span><span class="sxs-lookup"><span data-stu-id="e8b13-355">family and assembly</span></span><br /> <span data-ttu-id="e8b13-356">Dostępne tylko z typów, które kwalifikują się do dostępu do rodziny i zestawu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-356">Accessible only from types that qualify for both family and assembly access.</span></span><br /><br /> <span data-ttu-id="e8b13-357">Rodzina lub zestaw</span><span class="sxs-lookup"><span data-stu-id="e8b13-357">family or assembly</span></span><br /> <span data-ttu-id="e8b13-358">Dostępne tylko z typów, które kwalifikują się do dostępu do rodziny lub zestawu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-358">Accessible only from types that qualify for either family or assembly access.</span></span><br /><br /> <span data-ttu-id="e8b13-359">public</span><span class="sxs-lookup"><span data-stu-id="e8b13-359">public</span></span><br /> <span data-ttu-id="e8b13-360">Dostępne z dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-360">Accessible from any type.</span></span>|  
|<span data-ttu-id="e8b13-361">końcowe</span><span class="sxs-lookup"><span data-stu-id="e8b13-361">final</span></span>|<span data-ttu-id="e8b13-362">Metody, właściwości i zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-362">Methods, properties, and events</span></span>|<span data-ttu-id="e8b13-363">Nie można zastąpić metody wirtualnej w typie pochodnym.</span><span class="sxs-lookup"><span data-stu-id="e8b13-363">The virtual method cannot be overridden in a derived type.</span></span>|  
|<span data-ttu-id="e8b13-364">tylko Inicjalizacja</span><span class="sxs-lookup"><span data-stu-id="e8b13-364">initialize-only</span></span>|<span data-ttu-id="e8b13-365">Pola</span><span class="sxs-lookup"><span data-stu-id="e8b13-365">Fields</span></span>|<span data-ttu-id="e8b13-366">Wartość może zostać zainicjowana i nie można jej zapisać po zainicjowaniu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-366">The value can only be initialized, and cannot be written after initialization.</span></span>|  
|<span data-ttu-id="e8b13-367">np</span><span class="sxs-lookup"><span data-stu-id="e8b13-367">instance</span></span>|<span data-ttu-id="e8b13-368">Pola, metody, właściwości i zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-368">Fields, methods, properties, and events</span></span>|<span data-ttu-id="e8b13-369">Jeśli element członkowski nie jest oznaczony jako `static` (C# i C++), `Shared` (Visual Basic), `virtual` (C# i C++) lub `Overridable` (Visual Basic), jest to element członkowski wystąpienia (brak słowa kluczowego wystąpienia).</span><span class="sxs-lookup"><span data-stu-id="e8b13-369">If a member is not marked as `static` (C# and C++), `Shared` (Visual Basic), `virtual` (C# and C++), or `Overridable` (Visual Basic), it is an instance member (there is no instance keyword).</span></span> <span data-ttu-id="e8b13-370">Istnieje wiele kopii takich członków w pamięci, ponieważ istnieją obiekty, które go używają.</span><span class="sxs-lookup"><span data-stu-id="e8b13-370">There will be as many copies of such members in memory as there are objects that use it.</span></span>|  
|<span data-ttu-id="e8b13-371">literal</span><span class="sxs-lookup"><span data-stu-id="e8b13-371">literal</span></span>|<span data-ttu-id="e8b13-372">Pola</span><span class="sxs-lookup"><span data-stu-id="e8b13-372">Fields</span></span>|<span data-ttu-id="e8b13-373">Wartość przypisana do pola to stała wartość, znana w czasie kompilacji, typu wartości wbudowanej.</span><span class="sxs-lookup"><span data-stu-id="e8b13-373">The value assigned to the field is a fixed value, known at compile time, of a built-in value type.</span></span> <span data-ttu-id="e8b13-374">Pola literału są czasami określane jako stałe.</span><span class="sxs-lookup"><span data-stu-id="e8b13-374">Literal fields are sometimes referred to as constants.</span></span>|  
|<span data-ttu-id="e8b13-375">NewSlot lub Przesłoń</span><span class="sxs-lookup"><span data-stu-id="e8b13-375">newslot or override</span></span>|<span data-ttu-id="e8b13-376">Wszystkie</span><span class="sxs-lookup"><span data-stu-id="e8b13-376">All</span></span>|<span data-ttu-id="e8b13-377">Definiuje sposób interakcji elementu członkowskiego z dziedziczonymi elementami członkowskimi, które mają taki sam podpis:</span><span class="sxs-lookup"><span data-stu-id="e8b13-377">Defines how the member interacts with inherited members that have the same signature:</span></span><br /><br /> <span data-ttu-id="e8b13-378">NewSlot</span><span class="sxs-lookup"><span data-stu-id="e8b13-378">newslot</span></span><br /> <span data-ttu-id="e8b13-379">Ukrywa dziedziczone elementy członkowskie, które mają taki sam podpis.</span><span class="sxs-lookup"><span data-stu-id="e8b13-379">Hides inherited members that have the same signature.</span></span><br /><br /> <span data-ttu-id="e8b13-380">override</span><span class="sxs-lookup"><span data-stu-id="e8b13-380">override</span></span><br /> <span data-ttu-id="e8b13-381">Zastępuje definicję dziedziczonej metody wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="e8b13-381">Replaces the definition of an inherited virtual method.</span></span><br /><br /> <span data-ttu-id="e8b13-382">Wartość domyślna to NewSlot.</span><span class="sxs-lookup"><span data-stu-id="e8b13-382">The default is newslot.</span></span>|  
|<span data-ttu-id="e8b13-383">static</span><span class="sxs-lookup"><span data-stu-id="e8b13-383">static</span></span>|<span data-ttu-id="e8b13-384">Pola, metody, właściwości i zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-384">Fields, methods, properties, and events</span></span>|<span data-ttu-id="e8b13-385">Element członkowski należy do typu, który jest zdefiniowany w, a nie do określonego wystąpienia typu; element członkowski istnieje, nawet jeśli wystąpienie typu nie zostało utworzone i jest udostępniane między wszystkimi wystąpieniami tego typu.</span><span class="sxs-lookup"><span data-stu-id="e8b13-385">The member belongs to the type it is defined on, not to a particular instance of the type; the member exists even if an instance of the type is not created, and it is shared among all instances of the type.</span></span>|  
|<span data-ttu-id="e8b13-386">virtual</span><span class="sxs-lookup"><span data-stu-id="e8b13-386">virtual</span></span>|<span data-ttu-id="e8b13-387">Metody, właściwości i zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8b13-387">Methods, properties, and events</span></span>|<span data-ttu-id="e8b13-388">Metoda może być implementowana przez typ pochodny i może być wywoływana statycznie lub dynamicznie.</span><span class="sxs-lookup"><span data-stu-id="e8b13-388">The method can be implemented by a derived type and can be invoked either statically or dynamically.</span></span> <span data-ttu-id="e8b13-389">W przypadku użycia wywołania dynamicznego typ wystąpienia, które wywołuje wywołanie w czasie wykonywania (a nie typ znany w czasie kompilacji) określa, która implementacja metody jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="e8b13-389">If dynamic invocation is used, the type of the instance that makes the call at run time (rather than the type known at compile time) determines which implementation of the method is called.</span></span> <span data-ttu-id="e8b13-390">Aby wywołać metodę wirtualną statycznie, zmienna może być musiała być rzutowana na typ, który używa odpowiedniej wersji metody.</span><span class="sxs-lookup"><span data-stu-id="e8b13-390">To invoke a virtual method statically, the variable might have to be cast to a type that uses the desired version of the method.</span></span>|  
  
### <a name="overloading"></a><span data-ttu-id="e8b13-391">Przeciążenie</span><span class="sxs-lookup"><span data-stu-id="e8b13-391">Overloading</span></span>  
 <span data-ttu-id="e8b13-392">Każdy element członkowski typu ma unikatowy podpis.</span><span class="sxs-lookup"><span data-stu-id="e8b13-392">Each type member has a unique signature.</span></span> <span data-ttu-id="e8b13-393">Sygnatury metod składają się z nazwy metody i listy parametrów (kolejność i typy argumentów metody).</span><span class="sxs-lookup"><span data-stu-id="e8b13-393">Method signatures consist of the method name and a parameter list (the order and types of the method's arguments).</span></span> <span data-ttu-id="e8b13-394">Wiele metod o tej samej nazwie można zdefiniować w obrębie typu, tak długo, jak ich podpisy różnią się.</span><span class="sxs-lookup"><span data-stu-id="e8b13-394">Multiple methods with the same name can be defined within a type as long as their signatures differ.</span></span> <span data-ttu-id="e8b13-395">Gdy zdefiniowane są dwie lub więcej metod o tej samej nazwie, metoda jest określana jako przeciążona.</span><span class="sxs-lookup"><span data-stu-id="e8b13-395">When two or more methods with the same name are defined, the method is said to be overloaded.</span></span> <span data-ttu-id="e8b13-396">Na przykład, w <xref:System.Char?displayProperty=nameWithType>, Metoda <xref:System.Char.IsDigit%2A> jest przeciążona.</span><span class="sxs-lookup"><span data-stu-id="e8b13-396">For example, in <xref:System.Char?displayProperty=nameWithType>, the <xref:System.Char.IsDigit%2A> method is overloaded.</span></span> <span data-ttu-id="e8b13-397">Jedna metoda przyjmuje <xref:System.Char>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-397">One method takes a <xref:System.Char>.</span></span> <span data-ttu-id="e8b13-398">Druga metoda przyjmuje <xref:System.String> i <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="e8b13-398">The other method takes a <xref:System.String> and an <xref:System.Int32>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e8b13-399">Zwracany typ nie jest uważany za część podpisu metody.</span><span class="sxs-lookup"><span data-stu-id="e8b13-399">The return type is not considered part of a method's signature.</span></span> <span data-ttu-id="e8b13-400">Oznacza to, że metody nie mogą być przeciążone, jeśli różnią się tylko zwracanym typem.</span><span class="sxs-lookup"><span data-stu-id="e8b13-400">That is, methods cannot be overloaded if they differ only by return type.</span></span>  
  
### <a name="inheriting-overriding-and-hiding-members"></a><span data-ttu-id="e8b13-401">Dziedziczenie, zastępowanie i ukrywanie elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="e8b13-401">Inheriting, Overriding, and Hiding Members</span></span>  
 <span data-ttu-id="e8b13-402">Typ pochodny dziedziczy wszystkie elementy członkowskie jego typu podstawowego; oznacza to, że te składowe są zdefiniowane w, i dostępne dla, typ pochodny.</span><span class="sxs-lookup"><span data-stu-id="e8b13-402">A derived type inherits all members of its base type; that is, these members are defined on, and available to, the derived type.</span></span> <span data-ttu-id="e8b13-403">Zachowanie lub jakość dziedziczonych elementów członkowskich można modyfikować na dwa sposoby:</span><span class="sxs-lookup"><span data-stu-id="e8b13-403">The behavior or qualities of inherited members can be modified in two ways:</span></span>  
  
- <span data-ttu-id="e8b13-404">Typ pochodny może ukryć Dziedziczony element członkowski przez zdefiniowanie nowego elementu członkowskiego o tej samej sygnaturze.</span><span class="sxs-lookup"><span data-stu-id="e8b13-404">A derived type can hide an inherited member by defining a new member with the same signature.</span></span> <span data-ttu-id="e8b13-405">Może to być zrobione, aby wcześniej publiczny element członkowski był prywatny lub definiować nowe zachowanie dla dziedziczonej metody, która jest oznaczona jako `final`.</span><span class="sxs-lookup"><span data-stu-id="e8b13-405">This might be done to make a previously public member private or to define new behavior for an inherited method that is marked as `final`.</span></span>  
  
- <span data-ttu-id="e8b13-406">Typ pochodny może przesłonić dziedziczonej metody wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="e8b13-406">A derived type can override an inherited virtual method.</span></span> <span data-ttu-id="e8b13-407">Metoda przesłaniania zapewnia nową definicję metody, która będzie wywoływana na podstawie typu wartości w czasie wykonywania, a nie typu zmiennej znanej w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="e8b13-407">The overriding method provides a new definition of the method that will be invoked based on the type of the value at run time rather than the type of the variable known at compile time.</span></span> <span data-ttu-id="e8b13-408">Metoda może przesłonić metodę wirtualną tylko wtedy, gdy metoda wirtualna nie jest oznaczona jako `final` a nowa metoda jest co najmniej równa dostępności jako metoda wirtualna.</span><span class="sxs-lookup"><span data-stu-id="e8b13-408">A method can override a virtual method only if the virtual method is not marked as `final` and the new method is at least as accessible as the virtual method.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e8b13-409">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="e8b13-409">See also</span></span>

- [<span data-ttu-id="e8b13-410">Przeglądarka interfejsów API platformy .NET</span><span class="sxs-lookup"><span data-stu-id="e8b13-410">.NET API Browser</span></span>](/dotnet/api)
- [<span data-ttu-id="e8b13-411">Środowisko uruchomieniowe języka wspólnego</span><span class="sxs-lookup"><span data-stu-id="e8b13-411">Common Language Runtime</span></span>](../../../docs/standard/clr.md)
- [<span data-ttu-id="e8b13-412">Konwersja typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="e8b13-412">Type Conversion in .NET</span></span>](../../../docs/standard/base-types/type-conversion.md)
