---
title: Najlepsze praktyki dotyczące prawidłowych wyrażeń w .NET
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 2bb1d9bdbd0874875939010ea5503fe791a2cd1b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="75d9d-102">Najlepsze praktyki dotyczące prawidłowych wyrażeń w .NET</span><span class="sxs-lookup"><span data-stu-id="75d9d-102">Best Practices for Regular Expressions in .NET</span></span>
<a name="top"></a> <span data-ttu-id="75d9d-103">Aparat wyrażeń regularnych programu .NET to narzędzie zaawansowane, oferujący wszystkie funkcje, które przetwarza tekst w dopasowaniach wzorców, a nie na dopasowanie literały tekstowe i porównywanie.</span><span class="sxs-lookup"><span data-stu-id="75d9d-103">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="75d9d-104">W większości przypadków dopasowanie do wzorca przebiega szybko i skutecznie.</span><span class="sxs-lookup"><span data-stu-id="75d9d-104">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="75d9d-105">Jednak w niektórych przypadkach aparat wyrażeń regularnych może okazać się bardzo wolny.</span><span class="sxs-lookup"><span data-stu-id="75d9d-105">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="75d9d-106">W skrajnych przypadkach może nawet pozornie przestać odpowiadać, ponieważ przetwarza stosunkowo mało danych wejściowych w ciągu kilku godzin lub nawet dni.</span><span class="sxs-lookup"><span data-stu-id="75d9d-106">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>  
  
 <span data-ttu-id="75d9d-107">W tym temacie przedstawiono kilka najlepszych rozwiązań, które deweloperzy mogą zaadoptować w celu osiągnięcia optymalnej wydajności przetwarzania własnych wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-107">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span> <span data-ttu-id="75d9d-108">Ten temat zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="75d9d-108">It contains the following sections:</span></span>  
  
-   [<span data-ttu-id="75d9d-109">Należy wziąć pod uwagę źródła danych wejściowych</span><span class="sxs-lookup"><span data-stu-id="75d9d-109">Consider the Input Source</span></span>](#InputSource)  
  
-   [<span data-ttu-id="75d9d-110">Odpowiednią obsługę tworzenia wystąpienia obiektu</span><span class="sxs-lookup"><span data-stu-id="75d9d-110">Handle Object Instantiation Appropriately</span></span>](#ObjectInstantiation)  
  
-   [<span data-ttu-id="75d9d-111">Przejęcie śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="75d9d-111">Take Charge of Backtracking</span></span>](#Backtracking)  
  
-   [<span data-ttu-id="75d9d-112">Użyj wartości limitów czasu</span><span class="sxs-lookup"><span data-stu-id="75d9d-112">Use Time-out Values</span></span>](#Timeouts)  
  
-   [<span data-ttu-id="75d9d-113">Przechwyć tylko wtedy, gdy jest to konieczne</span><span class="sxs-lookup"><span data-stu-id="75d9d-113">Capture Only When Necessary</span></span>](#Capture)  
  
-   [<span data-ttu-id="75d9d-114">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="75d9d-114">Related Topics</span></span>](#RelatedTopics)  
  
<a name="InputSource"></a>   
## <a name="consider-the-input-source"></a><span data-ttu-id="75d9d-115">Wybieranie źródła danych wejściowych</span><span class="sxs-lookup"><span data-stu-id="75d9d-115">Consider the Input Source</span></span>  
 <span data-ttu-id="75d9d-116">Ogólnie rzecz biorąc, wyrażenia regularne mogą przyjmować dwa typy danych wejściowych: ograniczone i nieograniczone.</span><span class="sxs-lookup"><span data-stu-id="75d9d-116">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="75d9d-117">Ograniczone dane wejściowe to tekst pochodzący ze znanego lub wiarygodnego źródła, który ma wstępnie zdefiniowany format.</span><span class="sxs-lookup"><span data-stu-id="75d9d-117">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="75d9d-118">Nieograniczone dane wejściowe to tekst pochodzący z niepewnego źródła, takiego jak użytkownik sieci web, mogący nie mieć wstępnie zdefiniowanego lub oczekiwanego formatu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-118">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>  
  
 <span data-ttu-id="75d9d-119">Wzorce wyrażeń regularnych są zazwyczaj pisane w taki sposób, aby dopasowywały prawidłowe dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="75d9d-119">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="75d9d-120">Oznacza to, że deweloperzy sprawdzają tekst, który chcą dopasować, a następnie piszą wzorzec wyrażenia regularnego, który mu odpowiada.</span><span class="sxs-lookup"><span data-stu-id="75d9d-120">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="75d9d-121">Następnie deweloperzy określają, czy wzorzec wymaga poprawek, testując go dla wielu prawidłowych elementów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-121">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="75d9d-122">Gdy wzorzec pasuje do wszystkich przypuszczalnie prawidłowych danych wejściowych, jest uznawany za gotowy do produkcji i można go dołączyć do wydawanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-122">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="75d9d-123">Dzięki temu wzorzec wyrażenia regularnego nadaje się do dopasowywania ograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-123">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="75d9d-124">Jednak nie powoduje to, że wzorzec ten jest odpowiedni do porównywania nieograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-124">However, it does not make it suitable for matching unconstrained input.</span></span>  
  
 <span data-ttu-id="75d9d-125">Aby dopasować nieograniczone dane wejściowe, wyrażenie regularne musi być w stanie efektywnie obsłużyć trzy rodzaje tekstu:</span><span class="sxs-lookup"><span data-stu-id="75d9d-125">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>  
  
-   <span data-ttu-id="75d9d-126">Tekst, który pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-126">Text that matches the regular expression pattern.</span></span>  
  
-   <span data-ttu-id="75d9d-127">Tekst, który nie pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-127">Text that does not match the regular expression pattern.</span></span>  
  
-   <span data-ttu-id="75d9d-128">Tekst, który prawie pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-128">Text that nearly matches the regular expression pattern.</span></span>  
  
 <span data-ttu-id="75d9d-129">Ostatni typ tekstu jest szczególnie problematyczny dla wyrażeń regularnych, które zostały napisane do obsługi ograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-129">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="75d9d-130">Jeśli tego wyrażenia regularnego również jest oparta na szeroką gamę [śledzenie wsteczne](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), aparat wyrażeń regularnych może przeznaczyć długi ilość czasu (w niektórych przypadkach wiele godzin lub dni) przetwarzania pozornie nieszkodliwe tekstu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-130">If that regular expression also relies on extensive [backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="75d9d-131">W poniższym przykładzie użyto wyrażenia regularnego, które jest podatne na nadmierne korzystanie z wycofywania, przez co istnieje duże prawdopodobieństwo odrzucenia prawidłowych adresów e-mail.</span><span class="sxs-lookup"><span data-stu-id="75d9d-131">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="75d9d-132">Nie należy stosować go w procedurze weryfikacji adresów e-mail.</span><span class="sxs-lookup"><span data-stu-id="75d9d-132">You should not use it in an email validation routine.</span></span> <span data-ttu-id="75d9d-133">Jeśli chcesz wyrażenie regularne, która weryfikuje adresów e-mail, zobacz [porady: Sprawdź, czy ciągów jest prawidłowy Format wiadomości E-mail](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="75d9d-133">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
 <span data-ttu-id="75d9d-134">Rozważmy na przykład bardzo często używane, ale wyjątkowo problematyczne wyrażenie regularne służące do weryfikacji aliasów adresów e-mail.</span><span class="sxs-lookup"><span data-stu-id="75d9d-134">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="75d9d-135">Wyrażenie regularne `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` są zapisywane do przetworzenia, co jest uważany za prawidłowy adres e-mail, które składa się ze znaków alfanumerycznych, następuje zero lub więcej znaków, które mogą być alfanumeryczne, kropki i łączniki.</span><span class="sxs-lookup"><span data-stu-id="75d9d-135">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="75d9d-136">Wyrażenie regularne musi być zakończone znakiem alfanumerycznym.</span><span class="sxs-lookup"><span data-stu-id="75d9d-136">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="75d9d-137">Jednak, jak pokazuje poniższy przykład, mimo że wyrażenie regularne obsługuje z łatwością prawidłowe dane wejściowe, jego wydajność jest nieefektywna podczas przetwarzania niemal prawidłowych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-137">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]  
  
 <span data-ttu-id="75d9d-138">Dane wyjściowe z przykładu pokazują, że aparat wyrażeń regularnych przetwarza prawidłowe aliasy adresów e-mail w prawie takim samym interwale czasowym, niezależnie od ich długości.</span><span class="sxs-lookup"><span data-stu-id="75d9d-138">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="75d9d-139">Z drugiej strony, kiedy niemal prawidłowy adres e-mail zawiera więcej niż pięć znaków, dla każdego dodatkowego znaku w ciągu czas przetwarzania w przybliżeniu wzrasta dwukrotnie.</span><span class="sxs-lookup"><span data-stu-id="75d9d-139">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="75d9d-140">Oznacza to, że przetwarzanie niemal prawidłowego 28-znakowego ciągu będzie trwało prawie godzinę, a przetwarzanie niemal prawidłowego 33-znakowego ciągu będzie trwało prawie cały dzień.</span><span class="sxs-lookup"><span data-stu-id="75d9d-140">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>  
  
 <span data-ttu-id="75d9d-141">Ponieważ wyrażenie regularne zostało opracowane z uwzględnieniem wyłącznie formatu danych wejściowych do dopasowania, wyrażenie regularne nie uwzględnia danych wejściowych, które nie pasują do wzorca.</span><span class="sxs-lookup"><span data-stu-id="75d9d-141">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="75d9d-142">To z kolei może spowodować, że nieograniczone dane wejściowe, które niemal odpowiadają wzorcowi wyrażenia regularnego, znacząco obniżą wydajność.</span><span class="sxs-lookup"><span data-stu-id="75d9d-142">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>  
  
 <span data-ttu-id="75d9d-143">Aby rozwiązać ten problem, można wykonać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="75d9d-143">To solve this problem, you can do the following:</span></span>  
  
-   <span data-ttu-id="75d9d-144">Podczas tworzenia wzorca należy uwzględnić wpływ wycofywania na wydajność aparatu wyrażeń regularnych, szczególnie jeśli wyrażenie regularne jest przeznaczone do przetwarzania nieograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-144">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="75d9d-145">Aby uzyskać więcej informacji, zobacz [zająć bezpłatnie z śledzenie wsteczne](#Backtracking) sekcji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-145">For more information, see the [Take Charge of Backtracking](#Backtracking) section.</span></span>  
  
-   <span data-ttu-id="75d9d-146">Wyrażenie regularne należy dokładnie sprawdzić, używając nieprawidłowych i niemal prawidłowych danych wejściowych, a także prawidłowych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-146">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="75d9d-147">Aby losowo wygenerować danych wejściowych dla określonego wyrażenia regularnego, można użyć [Rafał](https://www.microsoft.com/en-us/research/project/rex-regular-expression-exploration/), który jest narzędziem eksploracji wyrażenia regularnego Microsoft Research.</span><span class="sxs-lookup"><span data-stu-id="75d9d-147">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/en-us/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>  
  
 [<span data-ttu-id="75d9d-148">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="75d9d-148">Back to top</span></span>](#top)  
  
<a name="ObjectInstantiation"></a>   
## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="75d9d-149">Odpowiednia obsługa tworzenia wystąpienia obiektu</span><span class="sxs-lookup"><span data-stu-id="75d9d-149">Handle Object Instantiation Appropriately</span></span>  
 <span data-ttu-id="75d9d-150">Istotą. Model obiektów wyrażeń regularnych w sieci jest <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> klasy, która reprezentuje aparat wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-150">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="75d9d-151">Często jednym największy czynnik, który wpływa na wydajność wyrażenie regularne jest sposobu, w jaki <xref:System.Text.RegularExpressions.Regex> jest używany aparat.</span><span class="sxs-lookup"><span data-stu-id="75d9d-151">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="75d9d-152">Definiowanie wyrażenia regularnego polega na ścisłym sprzęganiu aparatu wyrażeń regularnych z wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-152">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="75d9d-153">Czy sprzężenia procesu, czy obejmuje utworzenie wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu przez przekazanie jej konstruktora wzorzec wyrażenia regularnego lub wywołanie metody statycznej, przekazując wzorzec wyrażenia regularnego wraz z ciągu do analizy, jest konieczność jednego kosztowne.</span><span class="sxs-lookup"><span data-stu-id="75d9d-153">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75d9d-154">Bardziej szczegółowe omówienie skutki wydajności za pomocą wyrażeń regularnych interpretowany i skompilowany, zobacz [optymalizacji wydajności wyrażenie regularne, część II: pobieranie bezpłatnie z śledzenie wsteczne](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) w blogu zespołu BCL.</span><span class="sxs-lookup"><span data-stu-id="75d9d-154">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) in the BCL Team blog.</span></span>  
  
 <span data-ttu-id="75d9d-155">Można sprzęgnąć aparat wyrażeń regularnych z konkretnym wzorcem wyrażenia regularnego, a następnie użyć aparatu, aby dopasować tekst na kilka sposobów:</span><span class="sxs-lookup"><span data-stu-id="75d9d-155">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>  
  
-   <span data-ttu-id="75d9d-156">Należy wywołać dopasowywanie do wzorca metodą statyczną, takich jak <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="75d9d-156">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="75d9d-157">Nie wymaga to tworzenia wystąpienia obiektu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-157">This does not require instantiation of a regular expression object.</span></span>  
  
-   <span data-ttu-id="75d9d-158">Można utworzyć wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu i wywołanie metody wystąpienia dopasowywanie do wzorca interpretowany wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-158">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="75d9d-159">Jest to domyślna metoda do tworzenia powiązania aparatu wyrażeń regularnych z wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-159">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="75d9d-160">Wynika, gdy <xref:System.Text.RegularExpressions.Regex> utworzeniu wystąpienia obiektu bez `options` argument, który zawiera <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flagi.</span><span class="sxs-lookup"><span data-stu-id="75d9d-160">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>  
  
-   <span data-ttu-id="75d9d-161">Można utworzyć wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu i wywołanie metody wystąpienia dopasowywanie do wzorca skompilowane wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-161">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="75d9d-162">Obiektów wyrażeń regularnych stanowią skompilowany wzorców, kiedy <xref:System.Text.RegularExpressions.Regex> o utworzeniu wystąpienia obiektu `options` argument, który zawiera <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flagi.</span><span class="sxs-lookup"><span data-stu-id="75d9d-162">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>  
  
-   <span data-ttu-id="75d9d-163">Możesz utworzyć specjalnych <xref:System.Text.RegularExpressions.Regex> obiekt, który jest ściśle powiązane ze wzorcem wyrażenia regularnego określonego go skompilować i zapisać go do zestawu autonomicznego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-163">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="75d9d-164">Można to zrobić przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="75d9d-164">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="75d9d-165">Sposób, w jaki są wywoływane metody dopasowywania wyrażeń regularnych, może mieć znaczący wpływ na działanie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-165">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="75d9d-166">W poniższych sekcjach omówiono, kiedy używać wywołań metod statycznych oraz interpretowanych i skompilowanych wyrażeń regularnych, aby poprawić wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-166">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="75d9d-167">Jeśli to samo wyrażenie regularne jest używane wielokrotnie w wywołaniach metod lub jeśli obiekty wyrażeń regularnych są często używane w aplikacji, sposób wywoływania metody (statyczny, interpretowany, skompilowany) znacząco wpływa na wydajność.</span><span class="sxs-lookup"><span data-stu-id="75d9d-167">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>  
  
### <a name="static-regular-expressions"></a><span data-ttu-id="75d9d-168">Statyczne wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="75d9d-168">Static Regular Expressions</span></span>  
 <span data-ttu-id="75d9d-169">Statyczne metody wyrażeń regularnych są zalecane jako alternatywa dla wielokrotnego tworzenia wystąpienia obiektu wyrażenia regularnego z tym samym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="75d9d-169">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="75d9d-170">W przeciwieństwie do wzorców wyrażeń regularnych używanych przez obiekty wyrażeń regularnych, kody operacji lub skompilowana składnia języka Microsoft Intermediate Language (MSIL) z wzorców używanych w wywołaniach metod wystąpień są buforowane wewnętrznie przez aparat wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-170">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in instance method calls is cached internally by the regular expression engine.</span></span>  
  
 <span data-ttu-id="75d9d-171">Na przykład program obsługi zdarzeń często wywołuje inną metodę do weryfikacji danych wejściowych użytkownika.</span><span class="sxs-lookup"><span data-stu-id="75d9d-171">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="75d9d-172">Znajduje to odzwierciedlenie w poniższym kodzie, w którym <xref:System.Windows.Forms.Button> formantu <xref:System.Windows.Forms.Control.Click> zdarzenia są używane do wywoływania metody o nazwie `IsValidCurrency`, który sprawdza, czy użytkownik wprowadził symbol waluty, a następnie co najmniej jedną cyfrę.</span><span class="sxs-lookup"><span data-stu-id="75d9d-172">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]  
  
 <span data-ttu-id="75d9d-173">Bardzo mało wydajne implementacja `IsValidCurrency` metody przedstawiono w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="75d9d-173">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="75d9d-174">Należy pamiętać, że każde wywołanie metody reinstantiates <xref:System.Text.RegularExpressions.Regex> obiekt o takim wzorcu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-174">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="75d9d-175">To z kolei oznacza, że wzorzec wyrażenia regularnego należy kompilować podczas każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="75d9d-175">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]  
  
 <span data-ttu-id="75d9d-176">Należy zastąpić ten niewydajny kod z wywołaniem do statycznego <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="75d9d-176">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="75d9d-177">Eliminuje to potrzebę utworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu zawsze ma zostać wywołana metoda dopasowywanie do wzorca i umożliwia aparat wyrażeń regularnych można pobrać wersję skompilowane wyrażenia regularnego z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="75d9d-177">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]  
  
 <span data-ttu-id="75d9d-178">Domyślnie buforowanych jest piętnaście ostatnio używanych statycznych wzorców wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-178">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="75d9d-179">Dla aplikacji, które wymagają większej liczby buforowanych statyczne wyrażenia regularne, można dostosować rozmiar pamięci podręcznej przez ustawienie <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="75d9d-179">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="75d9d-180">Wyrażenie regularne `\p{Sc}+\s*\d+` używany w tym przykładzie sprawdza, czy ciąg wejściowy składa się z symbolu waluty i co najmniej jedną cyfrę.</span><span class="sxs-lookup"><span data-stu-id="75d9d-180">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="75d9d-181">Definicję wzorca pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="75d9d-181">The pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="75d9d-182">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="75d9d-182">Pattern</span></span>|<span data-ttu-id="75d9d-183">Opis</span><span class="sxs-lookup"><span data-stu-id="75d9d-183">Description</span></span>|  
|-------------|-----------------|  
|`\p{Sc}+`|<span data-ttu-id="75d9d-184">Dopasowanie do jednego lub większej liczby symboli Unicode w kategorii Waluta.</span><span class="sxs-lookup"><span data-stu-id="75d9d-184">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|  
|`\s*`|<span data-ttu-id="75d9d-185">Dopasowanie do zera lub większej liczby znaków odstępu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-185">Match zero or more white-space characters.</span></span>|  
|`\d+`|<span data-ttu-id="75d9d-186">Dopasowanie do co najmniej jednej cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="75d9d-186">Match one or more decimal digits.</span></span>|  
  
<a name="Interpreted"></a>   
### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="75d9d-187">Interpretowany vs. Skompilowane wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="75d9d-187">Interpreted vs. Compiled Regular Expressions</span></span>  
 <span data-ttu-id="75d9d-188">Wzorce wyrażenie regularne, które nie są powiązane z aparatu wyrażenia regularnego przy użyciu specyfikacji <xref:System.Text.RegularExpressions.RegexOptions.Compiled> interpretowania opcji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-188">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="75d9d-189">Kiedy tworzone jest wystąpienie obiektu wyrażenia regularnego, aparat wyrażeń regularnych konwertuje wyrażenie regularne na zestaw kodów operacji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-189">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="75d9d-190">Gdy wywoływana jest metoda wystąpienia, kody operacji są konwertowane do języka MSIL i wykonywane przy użyciu kompilatora JIT.</span><span class="sxs-lookup"><span data-stu-id="75d9d-190">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="75d9d-191">Podobnie, kiedy jest wywoływania statyczna metoda wyrażenia regularnego i wyrażenie regularne nie jest znajdowane w pamięci podręcznej, aparat wyrażeń regularnych konwertuje wyrażenie regularne na zestaw kodów operacji i przechowuje je w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="75d9d-191">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="75d9d-192">Następnie konwertuje te kody operacji na język MSIL, dzięki czemu mogą zostać wykonane za pomocą kompilatora JIT.</span><span class="sxs-lookup"><span data-stu-id="75d9d-192">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="75d9d-193">Interpretowane wyrażenia regularne ograniczają czas uruchamiania kosztem wolniejszego czasu wykonania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-193">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="75d9d-194">Z tego powodu najlepiej stosować je, kiedy wyrażenie regularne jest używane w małej liczbie wywołań metod lub jeśli dokładna liczba wywołań metod wyrażenia regularnego jest nieznana, ale oczekuje się, że będzie mała.</span><span class="sxs-lookup"><span data-stu-id="75d9d-194">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="75d9d-195">Wraz ze wzrostem liczby wywołań metod przyrost wydajności związany ze skróceniem czasu uruchamiania jest coraz mniejszy wskutek wolniejszego wykonywania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-195">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>  
  
 <span data-ttu-id="75d9d-196">Wzorce wyrażenie regularne, które są powiązane z aparatu wyrażenia regularnego przy użyciu specyfikacji <xref:System.Text.RegularExpressions.RegexOptions.Compiled> opcji są kompilowane.</span><span class="sxs-lookup"><span data-stu-id="75d9d-196">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="75d9d-197">Oznacza to, że kiedy jest tworzone wystąpienie obiektu wyrażenia regularnego lub kiedy jest wywoływana statyczna metoda wyrażenia regularnego i wyrażenie regularne nie jest znajdowane w pamięci podręcznej, aparat wyrażeń regularnych konwertuje wyrażenie regularne na pośredni zestaw kodów operacji, które następnie konwertuje na język MSIL.</span><span class="sxs-lookup"><span data-stu-id="75d9d-197">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="75d9d-198">Kiedy metoda jest wywoływana, kompilator JIT wykonuje kod języka MSIL.</span><span class="sxs-lookup"><span data-stu-id="75d9d-198">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="75d9d-199">W przeciwieństwie do interpretowanych wyrażeń regularnych, skompilowane wyrażenia regularne wydłużają czas uruchamiania, ale wykonanie pojedynczych metod dopasowania do wzorca jest szybsze.</span><span class="sxs-lookup"><span data-stu-id="75d9d-199">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="75d9d-200">W rezultacie korzyści w zakresie wydajności wynikające z kompilowania wyrażeń regularnych rosną proporcjonalnie do liczby wywoływanych metod wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-200">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>  
  
 <span data-ttu-id="75d9d-201">Podsumowując, zaleca się używać interpretowanych wyrażeń regularnych, kiedy stosunkowo rzadko są wywoływane metody wyrażeń regularnych z określonym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="75d9d-201">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="75d9d-202">Zaleca się używać skompilowanych wyrażeń regularnych, kiedy stosunkowo często są wywoływane metody wyrażeń regularnych z określonym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="75d9d-202">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="75d9d-203">Dokładny próg, przy którym mniejsza szybkość wykonywania interpretowanych wyrażeń regularnych przewyższa korzyści z redukcji czasu uruchamiania, lub próg, przy którym wolniejsze uruchamianie skompilowanych wyrażeń regularnych przewyższa korzyści z większej szybkości wykonywania, jest trudny do określenia.</span><span class="sxs-lookup"><span data-stu-id="75d9d-203">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="75d9d-204">Zależy to od wielu czynników, w tym od złożoności wyrażenia regularnego i konkretnych danych, które to wyrażenie przetwarza.</span><span class="sxs-lookup"><span data-stu-id="75d9d-204">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="75d9d-205">Aby określić, czy interpretowane lub skompilować wyrażeń regularnych oferują najlepszą wydajność dla danego scenariusza określonej aplikacji, można użyć <xref:System.Diagnostics.Stopwatch> klasy do porównania czas wykonywania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-205">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>  
  
 <span data-ttu-id="75d9d-206">Poniższy przykład porównuje wydajności skompilowany i interpretowany wyrażeń regularnych podczas odczytywania pierwszych dziesięciu zdań i podczas odczytywania wszystkich zdań w tekście Theodore Dreiser *Financier*.</span><span class="sxs-lookup"><span data-stu-id="75d9d-206">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="75d9d-207">Dane wyjściowe z przykładu pokazują, że przy zaledwie dziesięciu wywołaniach metod dopasowania wyrażenia regularnego interpretowane wyrażenie regularne oferuje lepszą wydajność niż skompilowane wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="75d9d-207">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="75d9d-208">Jednak skompilowane wyrażenie regularne oferuje lepszą wydajność dla dużej liczby wywołań (w tym przypadku ponad 13 000).</span><span class="sxs-lookup"><span data-stu-id="75d9d-208">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]  
  
 <span data-ttu-id="75d9d-209">Wzorzec wyrażenia regularnego używane w tym przykładzie `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="75d9d-209">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="75d9d-210">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="75d9d-210">Pattern</span></span>|<span data-ttu-id="75d9d-211">Opis</span><span class="sxs-lookup"><span data-stu-id="75d9d-211">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="75d9d-212">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-212">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="75d9d-213">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="75d9d-213">Match one or more word characters.</span></span>|  
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="75d9d-214">Dopasowanie do zera lub jednego znaku powrotu karetki, po którym występuje znak nowego wiersza, albo do zera lub jednego przecinka, po którym występuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-214">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|  
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="75d9d-215">Dopasowanie do zera lub większej liczby wystąpień jednego lub większej liczby znaków słowa, po którym występuje zero albo jeden znak powrotu karetki i znak nowego wiersza lub zero albo jeden przecinek, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-215">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|  
|`\w+`|<span data-ttu-id="75d9d-216">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="75d9d-216">Match one or more word characters.</span></span>|  
|`[.?:;!]`|<span data-ttu-id="75d9d-217">Dopasowanie do kropki, znaku zapytania, dwukropka, średnika lub wykrzyknika.</span><span class="sxs-lookup"><span data-stu-id="75d9d-217">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|  
  
### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="75d9d-218">Wyrażenia regularne: kompilowane do zestawu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-218">Regular Expressions: Compiled to an Assembly</span></span>  
 <span data-ttu-id="75d9d-219">.NET umożliwia również tworzenie zestawu, który zawiera skompilowane wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-219">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="75d9d-220">Przenosi to czynnik wpływający na wydajność kompilowania wyrażeń regularnych z czasu wykonywania na czas projektowania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-220">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="75d9d-221">Jednak to także wiąże się z dodatkową pracą: konieczne jest zdefiniowanie wyrażane regularnych z wyprzedzeniem i skompilowanie ich do zestawu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-221">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="75d9d-222">Kompilator może następnie odwołać się do tego zestawu podczas kompilowania kodu źródłowego, który używa wyrażeń regularnych zestawu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-222">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="75d9d-223">Każdy skompilowane wyrażenia regularnego w zestawie jest reprezentowany przez klasę, która jest pochodną <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="75d9d-223">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>  
  
 <span data-ttu-id="75d9d-224">Aby skompilować wyrażeń regularnych do zestawu, należy wywołać <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> — metoda i przekaż go, tablicy <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiekty reprezentujące wyrażeń regularnych do skompilowania, i <xref:System.Reflection.AssemblyName> obiekt, który zawiera informacje na temat zestawu jako utworzony.</span><span class="sxs-lookup"><span data-stu-id="75d9d-224">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>  
  
 <span data-ttu-id="75d9d-225">Zaleca się, aby kompilować wyrażenia regularne do zestawu w następujących sytuacjach:</span><span class="sxs-lookup"><span data-stu-id="75d9d-225">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>  
  
-   <span data-ttu-id="75d9d-226">Jeśli jesteś deweloperem składników, który chce utworzyć bibliotekę wyrażeń regularnych do wielokrotnego użytku.</span><span class="sxs-lookup"><span data-stu-id="75d9d-226">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>  
  
-   <span data-ttu-id="75d9d-227">Jeśli oczekujesz, że metody dopasowania do wzorca wyrażenia regularnego będą wywoływane nieokreśloną liczbę razy — od jednego lub dwóch wywołań do kilku tysięcy wywołań.</span><span class="sxs-lookup"><span data-stu-id="75d9d-227">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="75d9d-228">W przeciwieństwie do skompilowanych lub interpretowanych wyrażeń regularnych, wyrażenia regularne, które są kompilowane do oddzielnych zestawów, oferują stałą wydajność bez względu na liczbę wywołań metody.</span><span class="sxs-lookup"><span data-stu-id="75d9d-228">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>  
  
 <span data-ttu-id="75d9d-229">Jeśli skompilowane wyrażenia regularne są używane w celu optymalizacji wydajności, nie należy używać odbicia w celu utworzenia zestawu, załadowania aparatu wyrażeń regularnych i wykonania jego metod dopasowania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="75d9d-229">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="75d9d-230">Wymaga to unikania dynamicznego kompilowania wzorców wyrażeń regularnych i określenia wszelkich opcji dopasowania do wzorca (np. z uwzględnieniem wielkości liter) w czasie tworzenia zestawu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-230">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="75d9d-231">Wymaga to również odseparowania kodu, który tworzy zestaw, od kodu, który używa wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-231">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>  
  
 <span data-ttu-id="75d9d-232">W poniższym przykładzie pokazano, w jaki sposób utworzyć zestaw zawierający skompilowane wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="75d9d-232">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="75d9d-233">Tworzy zestaw o nazwie `RegexLib.dll` z klasy pojedyncze wyrażenie regularne, `SentencePattern`, zawierający wyrażenia regularnego dopasowanie zdanie wzorzec używany w [interpretowane vs. Skompilowane wyrażenia regularne](#Interpreted) sekcji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-233">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#Interpreted) section.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]  
  
 <span data-ttu-id="75d9d-234">Podczas kompilowania do pliku wykonywalnego i uruchom przykład tworzy zestaw o nazwie `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="75d9d-234">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="75d9d-235">Wyrażenie regularne jest reprezentowany przez klasę o nazwie `Utilities.RegularExpressions.SentencePattern` która jest pochodną <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="75d9d-235">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="75d9d-236">W poniższym przykładzie użyto następnie skompilowane wyrażenia regularnego do wyodrębnienia zdań w tekście Theodore Dreiser *Financier*.</span><span class="sxs-lookup"><span data-stu-id="75d9d-236">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]  
  
 [<span data-ttu-id="75d9d-237">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="75d9d-237">Back to top</span></span>](#top)  
  
<a name="Backtracking"></a>   
## <a name="take-charge-of-backtracking"></a><span data-ttu-id="75d9d-238">Przejmowanie kontroli nad wycofywaniem</span><span class="sxs-lookup"><span data-stu-id="75d9d-238">Take Charge of Backtracking</span></span>  
 <span data-ttu-id="75d9d-239">Zazwyczaj aparat wyrażeń regularnych używa progresji liniowej do przechodzenia przez ciąg wejściowy i porównywania go ze wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-239">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="75d9d-240">Jednakże, gdy Kwantyfikatory nieokreślony, takie jak `*`, `+`, i `?` są używane w wzorzec wyrażenia regularnego, aparat wyrażeń regularnych może dać część pomyślne wyniki pasujące częściowo i powrócić do poprzednio zapisanego stanu Aby wyszukać pomyślnego dopasowania dla całego wzorca.</span><span class="sxs-lookup"><span data-stu-id="75d9d-240">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="75d9d-241">Proces ten jest znany pod nazwą wycofywania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-241">This process is known as backtracking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75d9d-242">Aby uzyskać więcej informacji na śledzenie wsteczne, zobacz [szczegóły zachowania wyrażeń regularnych](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) i [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="75d9d-242">For more information on backtracking, see [Details of Regular Expression Behavior](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) and [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="75d9d-243">Aby uzyskać szczegółowe omówienie śledzenie wsteczne, zobacz [optymalizacji wydajności wyrażenie regularne, część II: biorąc bezpłatnie z śledzenie wsteczne](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) w blogu zespołu BCL.</span><span class="sxs-lookup"><span data-stu-id="75d9d-243">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) in the BCL Team blog.</span></span>  
  
 <span data-ttu-id="75d9d-244">Obsługa wycofywania daje wyrażeniom regularnym duże możliwości i elastyczność.</span><span class="sxs-lookup"><span data-stu-id="75d9d-244">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="75d9d-245">Dodatkowo odpowiedzialność za kontrolowanie operacji aparatu wyrażeń regularnych spada na deweloperów wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-245">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="75d9d-246">Ponieważ deweloperzy często nie są tego świadomi, błędne użycie wycofywania lub nadmierne poleganie na wycofywaniu często odgrywa najbardziej znaczącą rolę w zmniejszeniu wydajności wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-246">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="75d9d-247">W scenariuszu najgorszego przypadku czas wykonywania może podwajać się dla każdego dodatkowego znaku w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="75d9d-247">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="75d9d-248">W rzeczywistości przy nadmiernym wykorzystaniu wycofywania łatwo jest stworzyć programowy odpowiednik pętli nieskończonej, jeżeli dane wejściowe niemal pasują do wzorca wyrażenia regularnego; przetwarzanie relatywnie krótkiego ciągu wejściowego może zająć aparatowi wyrażeń regularnych kilka godzin, a nawet dni.</span><span class="sxs-lookup"><span data-stu-id="75d9d-248">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>  
  
 <span data-ttu-id="75d9d-249">Często efektem użycia wycofywania jest obniżenie wydajności w aplikacjach, mimo że używanie wycofywania nie jest niezbędne dla dopasowania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-249">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="75d9d-250">Na przykład, wyrażenie regularne `\b\p{Lu}\w*\b` dopasowuje wszystkie słowa zaczynające się wielką literę, jak to pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="75d9d-250">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>  
  
|<span data-ttu-id="75d9d-251">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="75d9d-251">Pattern</span></span>|<span data-ttu-id="75d9d-252">Opis</span><span class="sxs-lookup"><span data-stu-id="75d9d-252">Description</span></span>|  
|-|-|  
|`\b`|<span data-ttu-id="75d9d-253">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-253">Begin the match at a word boundary.</span></span>|  
|`\p{Lu}`|<span data-ttu-id="75d9d-254">Dopasowanie do dowolnej wielkiej litery.</span><span class="sxs-lookup"><span data-stu-id="75d9d-254">Match an uppercase character.</span></span>|  
|`\w*`|<span data-ttu-id="75d9d-255">Dopasowuje zero lub więcej znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="75d9d-255">Match zero or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="75d9d-256">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-256">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="75d9d-257">Ponieważ granica wyrazu nie jest tym samym co znak słowa ani jego podzbiorem, nie ma możliwości, aby aparat wyrażeń regularnych przekroczył granicę wyrazu podczas dopasowywania znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="75d9d-257">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="75d9d-258">Oznacza to, że dla tego wyrażenia regularnego wycofywanie może nigdy nie przyczynić się do sukcesu jakiegokolwiek dopasowania, może za to obniżyć wydajność, ponieważ aparat wyrażeń regularnych musi zapisać swój stan podczas każdego pomyślnie zakończonego wstępnego dopasowania znaku słowa.</span><span class="sxs-lookup"><span data-stu-id="75d9d-258">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>  
  
 <span data-ttu-id="75d9d-259">Jeśli okaże się, że śledzenie wsteczne nie jest konieczne, należy ją wyłączyć za pomocą `(?>``subexpression``)` element języka.</span><span class="sxs-lookup"><span data-stu-id="75d9d-259">If you determine that backtracking is not necessary, you can disable it by using the `(?>``subexpression``)` language element.</span></span> <span data-ttu-id="75d9d-260">W poniższym przykładzie jest analizowana składnia ciągu wejściowego przy użyciu dwóch wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-260">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="75d9d-261">Pierwsza strona, `\b\p{Lu}\w*\b`, opiera się na śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="75d9d-261">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="75d9d-262">Druga Strona, `\b\p{Lu}(?>\w*)\b`, wyłącza śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="75d9d-262">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="75d9d-263">Jak wynika z przykładu, oba wyrażenia regularne dały ten sam wynik.</span><span class="sxs-lookup"><span data-stu-id="75d9d-263">As the output from the example shows, they both produce the same result.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]  
  
 <span data-ttu-id="75d9d-264">W wielu przypadkach wycofywanie jest niezbędne dla dopasowania wzorca wyrażenia regularnego do tekstu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-264">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="75d9d-265">Należy pamiętać, że nadmierne używanie wycofywania może poważnie obniżyć wydajność i stworzyć wrażanie, ze aplikacja przestała odpowiadać.</span><span class="sxs-lookup"><span data-stu-id="75d9d-265">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="75d9d-266">W szczególności ma to miejsce, kiedy kwantyfikatory są zagnieżdżane i tekst, który pasuje do zewnętrznego podwyrażenia, jest podzbiorem tekstu, który pasuje do wewnętrznego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="75d9d-266">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="75d9d-267">Oprócz unikania nadmiernego wykorzystania wycofywania należy używać funkcji limitu czasu, aby zagwarantować, że nadmierne używanie wycofywania nie obniży poważnie wydajności wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-267">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="75d9d-268">Aby uzyskać więcej informacji, zobacz [wartości limitu czasu użycia](#Timeouts) sekcji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-268">For more information, see the [Use Time-out Values](#Timeouts) section.</span></span>  
  
 <span data-ttu-id="75d9d-269">Na przykład wzorzec wyrażenia regularnego `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` jest przeznaczony do dopasowania liczby części, która składa się z co najmniej jeden znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="75d9d-269">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="75d9d-270">Jakiekolwiek dodatkowe znaki mogą być znakami alfanumerycznymi, łącznikami, podkreśleniami lub kropkami, ale ostatni znak musi być alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="75d9d-270">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="75d9d-271">Znak dolara przerywa numer części.</span><span class="sxs-lookup"><span data-stu-id="75d9d-271">A dollar sign terminates the part number.</span></span> <span data-ttu-id="75d9d-272">W niektórych przypadkach ten wzorzec wyrażenia regularnego może pokazać bardzo niską wydajnością, ponieważ są zagnieżdżone Kwantyfikatory i Podwyrażenie `[0-9A-Z]` jest podzbiorem Podwyrażenie `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="75d9d-272">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>  
  
 <span data-ttu-id="75d9d-273">W takich przypadkach można zoptymalizować wydajność wyrażenia regularnego, usuwając zagnieżdżone kwantyfikatory i zastępując zewnętrzne podwyrażenie asercją wyprzedzającą lub wsteczną o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="75d9d-273">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="75d9d-274">Asercje wyprzedzające i wsteczne są kotwicami; nie przesuwają wskaźnika w ciągu wejściowym, ale „patrzą” do przodu lub wstecz, aby sprawdzić, czy określony warunek został spełniony.</span><span class="sxs-lookup"><span data-stu-id="75d9d-274">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="75d9d-275">Na przykład można przepisany wyrażenia regularnego numer części `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span><span class="sxs-lookup"><span data-stu-id="75d9d-275">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="75d9d-276">Definicję tego wzorca wyrażenia regularnego pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="75d9d-276">This regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="75d9d-277">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="75d9d-277">Pattern</span></span>|<span data-ttu-id="75d9d-278">Opis</span><span class="sxs-lookup"><span data-stu-id="75d9d-278">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="75d9d-279">Rozpoczyna dopasowanie na początku ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-279">Begin the match at the beginning of the input string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="75d9d-280">Dopasowuje znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="75d9d-280">Match an alphanumeric character.</span></span> <span data-ttu-id="75d9d-281">Numer części musi zawierać przynajmniej jeden znak.</span><span class="sxs-lookup"><span data-stu-id="75d9d-281">The part number must consist of at least this character.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="75d9d-282">Dopasowanie do zera lub większej liczby wystąpień dowolnego znaku słowa, łącznika lub kropki.</span><span class="sxs-lookup"><span data-stu-id="75d9d-282">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|  
|`\$`|<span data-ttu-id="75d9d-283">Dopasowanie do znaku dolara.</span><span class="sxs-lookup"><span data-stu-id="75d9d-283">Match a dollar sign.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="75d9d-284">Spoglądanie w przód od kończącego znaku dolara, aby się upewnić, że znak poprzedzający jest alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="75d9d-284">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|  
|`$`|<span data-ttu-id="75d9d-285">Dopasowywanie kończy się na końcu ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-285">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="75d9d-286">W poniższym przykładzie pokazano użycie tego wyrażenia regularnego w celu dopasowania tablicy zawierającej możliwe numery części.</span><span class="sxs-lookup"><span data-stu-id="75d9d-286">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]  
  
 <span data-ttu-id="75d9d-287">Język wyrażeń regularnych programu .NET obejmuje następujące elementy języka, których można użyć w celu wyeliminowania kwantyfikatorami zagnieżdżonymi.</span><span class="sxs-lookup"><span data-stu-id="75d9d-287">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="75d9d-288">Aby uzyskać więcej informacji, zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="75d9d-288">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
|<span data-ttu-id="75d9d-289">Element języka</span><span class="sxs-lookup"><span data-stu-id="75d9d-289">Language element</span></span>|<span data-ttu-id="75d9d-290">Opis</span><span class="sxs-lookup"><span data-stu-id="75d9d-290">Description</span></span>|  
|----------------------|-----------------|  
|<span data-ttu-id="75d9d-291">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="75d9d-291">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="75d9d-292">Pozytywna asercja wyprzedzająca o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="75d9d-292">Zero-width positive lookahead.</span></span> <span data-ttu-id="75d9d-293">Szukaj przed bieżącą pozycję, aby określić, czy `subexpression` pasującej do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-293">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|  
|<span data-ttu-id="75d9d-294">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="75d9d-294">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="75d9d-295">Negatywna asercja wyprzedzająca o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="75d9d-295">Zero-width negative lookahead.</span></span> <span data-ttu-id="75d9d-296">Szukaj przed bieżącą pozycję, aby określić, czy `subexpression` nie pasuje do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-296">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|  
|<span data-ttu-id="75d9d-297">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="75d9d-297">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="75d9d-298">Pozytywna asercja wsteczna o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="75d9d-298">Zero-width positive lookbehind.</span></span> <span data-ttu-id="75d9d-299">Szukaj za bieżącą pozycję, aby określić, czy `subexpression` pasującej do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-299">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|  
|<span data-ttu-id="75d9d-300">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="75d9d-300">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="75d9d-301">Negatywna asercja wsteczna o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="75d9d-301">Zero-width negative lookbehind.</span></span> <span data-ttu-id="75d9d-302">Szukaj za bieżącą pozycję, aby określić, czy `subexpression` nie pasuje do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-302">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|  
  
 [<span data-ttu-id="75d9d-303">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="75d9d-303">Back to top</span></span>](#top)  
  
<a name="Timeouts"></a>   
## <a name="use-time-out-values"></a><span data-ttu-id="75d9d-304">Używanie wartości limitu czasu</span><span class="sxs-lookup"><span data-stu-id="75d9d-304">Use Time-out Values</span></span>  
 <span data-ttu-id="75d9d-305">Jeśli wyrażenie regularne przetwarza dane wejściowe, które niemal pasują do wzorca wyrażenia regularnego, często może nadmiernie używać wycofywania, co znacznie wpływa na wydajność.</span><span class="sxs-lookup"><span data-stu-id="75d9d-305">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="75d9d-306">Oprócz dokładnego rozważenia użycia wycofywania i przetestowania wyrażenia regularnego pod kątem niemal dopasowanych danych wejściowych, zawsze należy ustawić wartość limitu czasu, aby zagwarantować, że efekt nadmiernego używania wycofywania, jeżeli wystąpi, będzie jak najmniejszy.</span><span class="sxs-lookup"><span data-stu-id="75d9d-306">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>  
  
 <span data-ttu-id="75d9d-307">Interwał limitu czasu wyrażenia regularnego określa czas, przez jaki aparat wyrażeń regularnych będzie szukał pojedynczego dopasowania, zanim zostanie przekroczony limit czasu. Domyślny limit czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, co oznacza, że wyrażenie regularne zostanie nie upłynął limit czasu. Można zastąpić tę wartość i zdefiniować interwał limitu czasu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="75d9d-307">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>  
  
-   <span data-ttu-id="75d9d-308">Podając wartości limitu czasu podczas tworzenia wystąpienia można <xref:System.Text.RegularExpressions.Regex> obiektu przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="75d9d-308">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="75d9d-309">Przez wywołanie metody statycznej wzorca dopasowania metody, takie jak <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, która zawiera `matchTimeout` parametru.</span><span class="sxs-lookup"><span data-stu-id="75d9d-309">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>  
  
-   <span data-ttu-id="75d9d-310">Dla skompilowanych wyrażeń regularnych, które są tworzone przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> — metoda, przez wywołanie konstruktora, który ma parametr typu <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="75d9d-310">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>  
  
 <span data-ttu-id="75d9d-311">Jeśli zdefiniowano interwał limitu czasu i nie znaleziono dopasowania na końcu tego zakresu, metoda wyrażenia regularnego zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="75d9d-311">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="75d9d-312">W obsłudze wyjątków można wybrać ponowienie próby dopasowywania z dłuższym interwałem limitu czasu, zrezygnować z próby dopasowania i założyć, że dopasowanie nie istnieje, lub zrezygnować z próby dopasowania i zarejestrować informacje o wyjątku na potrzeby późniejszej analizy.</span><span class="sxs-lookup"><span data-stu-id="75d9d-312">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>  
  
 <span data-ttu-id="75d9d-313">W poniższym przykładzie zdefiniowano `GetWordData` metodę, która tworzy wyrażenia regularnego z interwał limitu czasu milisekund 350 do obliczenia liczbę słów i średnia liczba znaków w edytorze w dokumencie tekstowym.</span><span class="sxs-lookup"><span data-stu-id="75d9d-313">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="75d9d-314">Jeśli upłynie limit czasu operacji dopasowywania, interwał limitu czasu jest zwiększana o 350 milisekund i <xref:System.Text.RegularExpressions.Regex> obiekt jest ponownie skonkretyzowanym.</span><span class="sxs-lookup"><span data-stu-id="75d9d-314">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="75d9d-315">Jeżeli nowy interwał limitu czasu przekroczy 1 sekundę, metoda ponownie zgłosi wyjątek do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-315">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]  
  
 [<span data-ttu-id="75d9d-316">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="75d9d-316">Back to top</span></span>](#top)  
  
<a name="Capture"></a>   
## <a name="capture-only-when-necessary"></a><span data-ttu-id="75d9d-317">Przechwytywanie tylko wtedy, gdy jest to konieczne</span><span class="sxs-lookup"><span data-stu-id="75d9d-317">Capture Only When Necessary</span></span>  
 <span data-ttu-id="75d9d-318">Wyrażeń regularnych programu .NET obsługuje wiele konstrukcji grupowania, które pozwalają na grupowanie wzorzec wyrażenia regularnego do użyto jednego lub więcej.</span><span class="sxs-lookup"><span data-stu-id="75d9d-318">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="75d9d-319">Konstrukcji grupowania najczęściej używane w języku wyrażenie regularne .NET jest `(` *Podwyrażenie*`)`, który definiuje grupę przechwyconą numerowane i `(?<` *nazwa* `>` *Podwyrażenie*`)`, który definiuje nazwaną grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-319">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="75d9d-320">Konstrukcje grupujące są niezbędne do tworzenia odwołań wstecznych i do definiowania podwyrażeń, do których jest stosowany kwantyfikator.</span><span class="sxs-lookup"><span data-stu-id="75d9d-320">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>  
  
 <span data-ttu-id="75d9d-321">Jednak zastosowanie tych elementów języka jest kosztowne.</span><span class="sxs-lookup"><span data-stu-id="75d9d-321">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="75d9d-322">Spowodują one <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości można wypełniać za pomocą najnowszej bez nazwy lub o nazwie przechwytywanie, a jeśli przechwyceniu konstrukcji grupowania pojedynczego wiele podciągów w ciągu wejściowym wypełnić również <xref:System.Text.RegularExpressions.CaptureCollection>obiektu zwróconego przez <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> właściwości określonej grupy przechwytywania w wielu <xref:System.Text.RegularExpressions.Capture> obiektów.</span><span class="sxs-lookup"><span data-stu-id="75d9d-322">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 <span data-ttu-id="75d9d-323">Często konstrukcje grupujące są używane w wyrażeniach regularnych tylko po to, aby można było zastosować do nich kwantyfikatory, i grupy przechwytywane przez te podwyrażenia nie są następnie używane.</span><span class="sxs-lookup"><span data-stu-id="75d9d-323">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="75d9d-324">Na przykład, wyrażenie regularne `\b(\w+[;,]?\s?)+[.?!]` zaprojektowano w celu przechwycenia całe zdanie.</span><span class="sxs-lookup"><span data-stu-id="75d9d-324">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="75d9d-325">W poniższej tabeli opisano elementy języka, w tym wzorzec wyrażenia regularnego i ich wpływ na <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-325">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>  
  
|<span data-ttu-id="75d9d-326">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="75d9d-326">Pattern</span></span>|<span data-ttu-id="75d9d-327">Opis</span><span class="sxs-lookup"><span data-stu-id="75d9d-327">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="75d9d-328">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-328">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="75d9d-329">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="75d9d-329">Match one or more word characters.</span></span>|  
|`[;,]?`|<span data-ttu-id="75d9d-330">Dopasowanie do zera lub jednego przecinka albo średnika.</span><span class="sxs-lookup"><span data-stu-id="75d9d-330">Match zero or one comma or semicolon.</span></span>|  
|`\s?`|<span data-ttu-id="75d9d-331">Dopasowuje zero lub jeden znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-331">Match zero or one white-space character.</span></span>|  
|`(\w+[;,]?\s?)+`|<span data-ttu-id="75d9d-332">Dopasowanie do jednego lub większej liczby wystąpień jednego lub większej liczby znaków słowa, po którym następuje opcjonalny przecinek lub średnik, po którym następuje opcjonalny znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-332">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="75d9d-333">To definiuje pierwszą grupę przechwytywania, która jest niezbędna, aby kombinacja wielu znaków słowa (tzn. słowo), po których następuje opcjonalny znak interpunkcyjny, była powtarzana do momentu, kiedy aparat wyrażeń regularnych osiągnie koniec zdania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-333">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|  
|`[.?!]`|<span data-ttu-id="75d9d-334">Dopasowanie do kropki, znaku zapytania lub wykrzyknika.</span><span class="sxs-lookup"><span data-stu-id="75d9d-334">Match a period, question mark, or exclamation point.</span></span>|  
  
 <span data-ttu-id="75d9d-335">Jak przedstawiono na poniższym przykładzie, po znalezieniu dopasowania, zarówno <xref:System.Text.RegularExpressions.GroupCollection> i <xref:System.Text.RegularExpressions.CaptureCollection> obiekty są wypełniane przy użyciu przechwytywane z dopasowania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-335">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="75d9d-336">W takim przypadku grupę przechwyconą `(\w+[;,]?\s?)` istnieje, aby `+` kwantyfikatora może odnosić się do niego, dzięki czemu wzorzec wyrażenia regularnego do dopasowania każdego wyrazu w zdaniu na wyraz.</span><span class="sxs-lookup"><span data-stu-id="75d9d-336">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="75d9d-337">W przeciwnym razie dopasowanie nastąpi dla ostatniego wyrazu w zdaniu.</span><span class="sxs-lookup"><span data-stu-id="75d9d-337">Otherwise, it would match the last word in a sentence.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]  
  
 <span data-ttu-id="75d9d-338">Kiedy używa się podwyrażeń tylko w celu zastosowania do nich kwantyfikatorów, a przechwytywany tekst nie jest ważny, należy wyłączyć przechwytywanie grup.</span><span class="sxs-lookup"><span data-stu-id="75d9d-338">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="75d9d-339">Na przykład `(?:``subexpression``)` element języka uniemożliwia Przechwytywanie podciągów grupy, do którego jest stosowany.</span><span class="sxs-lookup"><span data-stu-id="75d9d-339">For example, the `(?:``subexpression``)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="75d9d-340">W poniższym przykładzie wzorzec wyrażenia regularnego z poprzedniego przykładu jest zmieniana na `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="75d9d-340">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="75d9d-341">Jak pokazano na dane wyjściowe, uniemożliwia aparat wyrażenie regularne wypełnianie <xref:System.Text.RegularExpressions.GroupCollection> i <xref:System.Text.RegularExpressions.CaptureCollection> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-341">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]  
  
 <span data-ttu-id="75d9d-342">Przechwytywanie można wyłączyć na jeden z poniższych sposobów:</span><span class="sxs-lookup"><span data-stu-id="75d9d-342">You can disable captures in one of the following ways:</span></span>  
  
-   <span data-ttu-id="75d9d-343">Użyj `(?:``subexpression``)` element języka.</span><span class="sxs-lookup"><span data-stu-id="75d9d-343">Use the `(?:``subexpression``)` language element.</span></span> <span data-ttu-id="75d9d-344">Ten element zapobiega przechwytywaniu dopasowanych podciągów w grupie, do której jest stosowany.</span><span class="sxs-lookup"><span data-stu-id="75d9d-344">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="75d9d-345">Nie wyłącza przechwytywania podciągów w grupach zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-345">It does not disable substring captures in any nested groups.</span></span>  
  
-   <span data-ttu-id="75d9d-346">Użyj <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> opcji.</span><span class="sxs-lookup"><span data-stu-id="75d9d-346">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="75d9d-347">Wyłącza wszystkie nienazwane lub niejawne przechwytywania we wzorcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="75d9d-347">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="75d9d-348">Tej opcji tylko podciągi zgodnych o nazwie grupy zdefiniowane z `(?<``name``>``subexpression``)` , można przechwycić element języka.</span><span class="sxs-lookup"><span data-stu-id="75d9d-348">When you use this option, only substrings that match named groups defined with the `(?<``name``>``subexpression``)` language element can be captured.</span></span> <span data-ttu-id="75d9d-349"><xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> Flagi mogą zostać przekazane do `options` parametr <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub `options` parametr <xref:System.Text.RegularExpressions.Regex> statycznej metody dopasowania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-349">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>  
  
-   <span data-ttu-id="75d9d-350">Użyj `n` opcji `(?imnsx)` element języka.</span><span class="sxs-lookup"><span data-stu-id="75d9d-350">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="75d9d-351">Powoduje to wyłączenie wszystkich nienazwanych lub niejawnych przechwytywań od miejsca we wzorcu wyrażenia regularnego, w którym znajduje się ten element.</span><span class="sxs-lookup"><span data-stu-id="75d9d-351">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="75d9d-352">Przechwytywane są wyłączone albo aż do zakończenia wzorca lub do czasu `(-n)` opcja umożliwia przechwytywanie bez nazwy ani niejawnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-352">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="75d9d-353">Aby uzyskać więcej informacji, zobacz [różne konstrukcje](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="75d9d-353">For more information, see [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="75d9d-354">Użyj `n` opcji `(?imnsx:``subexpression``)` element języka.</span><span class="sxs-lookup"><span data-stu-id="75d9d-354">Use the `n` option in the `(?imnsx:``subexpression``)` language element.</span></span> <span data-ttu-id="75d9d-355">Ta opcja powoduje wyłączenie wszystkich nienazwanych lub niejawne przechwytywania w `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="75d9d-355">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="75d9d-356">Przechwytywania przez jakiekolwiek nienazwane lub niejawne zagnieżdżone grupy przechwytywania również są wyłączone.</span><span class="sxs-lookup"><span data-stu-id="75d9d-356">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>  
  
 [<span data-ttu-id="75d9d-357">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="75d9d-357">Back to top</span></span>](#top)  
  
<a name="RelatedTopics"></a>   
## <a name="related-topics"></a><span data-ttu-id="75d9d-358">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="75d9d-358">Related Topics</span></span>  
  
|<span data-ttu-id="75d9d-359">Tytuł</span><span class="sxs-lookup"><span data-stu-id="75d9d-359">Title</span></span>|<span data-ttu-id="75d9d-360">Opis</span><span class="sxs-lookup"><span data-stu-id="75d9d-360">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="75d9d-361">Szczegóły dotyczące zachowania wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="75d9d-361">Details of Regular Expression Behavior</span></span>](../../../docs/standard/base-types/details-of-regular-expression-behavior.md)|<span data-ttu-id="75d9d-362">Sprawdza, czy implementacja aparat wyrażeń regularnych programu .NET.</span><span class="sxs-lookup"><span data-stu-id="75d9d-362">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="75d9d-363">W tym temacie skupiono się na elastyczności wyrażeń regularnych i wyjaśniono odpowiedzialność deweloperów za zapewnienie wydajnych i niezawodnych operacji aparatu wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="75d9d-363">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|  
|[<span data-ttu-id="75d9d-364">Śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="75d9d-364">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="75d9d-365">Informacje, co to jest wycofywanie i jak wpływa na wydajność wyrażeń regularnych oraz analiza elementów języka, które dostarczają alternatywy dla wycofywania.</span><span class="sxs-lookup"><span data-stu-id="75d9d-365">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|  
|[<span data-ttu-id="75d9d-366">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="75d9d-366">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="75d9d-367">Zawiera opis elementów języka wyrażeń regularnych programu .NET i łącza do szczegółowa dokumentacja dla każdego elementu języka.</span><span class="sxs-lookup"><span data-stu-id="75d9d-367">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
