---
title: Najlepsze rozwiązania dotyczące wyrażeń regularnych w programie .NET
description: Dowiedz się, jak tworzyć wydajne, efektywne wyrażenia regularne w programie .NET.
ms.date: 06/30/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: 727c3f2b8465c5d69244abe0f441d2a24e84dc5f
ms.sourcegitcommit: ff5a4eb5cffbcac9521bc44a907a118cd7e8638d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/17/2020
ms.locfileid: "92162924"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="26233-103">Najlepsze rozwiązania dotyczące wyrażeń regularnych w programie .NET</span><span class="sxs-lookup"><span data-stu-id="26233-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="26233-104">Aparat wyrażeń regularnych w programie .NET to zaawansowane, w pełni funkcjonalne narzędzie, które przetwarza tekst na podstawie dopasowania do wzorców zamiast porównywania i dopasowywania tekstu w postaci literału.</span><span class="sxs-lookup"><span data-stu-id="26233-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="26233-105">W większości przypadków dopasowanie do wzorca przebiega szybko i skutecznie.</span><span class="sxs-lookup"><span data-stu-id="26233-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="26233-106">Jednak w niektórych przypadkach aparat wyrażeń regularnych może okazać się bardzo wolny.</span><span class="sxs-lookup"><span data-stu-id="26233-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="26233-107">W skrajnych przypadkach może nawet pozornie przestać odpowiadać, ponieważ przetwarza stosunkowo mało danych wejściowych w ciągu kilku godzin lub nawet dni.</span><span class="sxs-lookup"><span data-stu-id="26233-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="26233-108">W tym temacie przedstawiono kilka najlepszych rozwiązań, które deweloperzy mogą zaadoptować w celu osiągnięcia optymalnej wydajności przetwarzania własnych wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

[!INCLUDE [regex](../../../includes/regex.md)]

## <a name="consider-the-input-source"></a><span data-ttu-id="26233-109">Rozważ źródło danych wejściowych</span><span class="sxs-lookup"><span data-stu-id="26233-109">Consider the input source</span></span>

<span data-ttu-id="26233-110">Ogólnie rzecz biorąc, wyrażenia regularne mogą przyjmować dwa typy danych wejściowych: ograniczone i nieograniczone.</span><span class="sxs-lookup"><span data-stu-id="26233-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="26233-111">Ograniczone dane wejściowe to tekst pochodzący ze znanego lub wiarygodnego źródła, który ma wstępnie zdefiniowany format.</span><span class="sxs-lookup"><span data-stu-id="26233-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="26233-112">Nieograniczone dane wejściowe to tekst pochodzący z niepewnego źródła, takiego jak użytkownik sieci web, mogący nie mieć wstępnie zdefiniowanego lub oczekiwanego formatu.</span><span class="sxs-lookup"><span data-stu-id="26233-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="26233-113">Wzorce wyrażeń regularnych są zazwyczaj pisane w taki sposób, aby dopasowywały prawidłowe dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="26233-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="26233-114">Oznacza to, że deweloperzy sprawdzają tekst, który chcą dopasować, a następnie piszą wzorzec wyrażenia regularnego, który mu odpowiada.</span><span class="sxs-lookup"><span data-stu-id="26233-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="26233-115">Następnie deweloperzy określają, czy wzorzec wymaga poprawek, testując go dla wielu prawidłowych elementów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="26233-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="26233-116">Gdy wzorzec pasuje do wszystkich przypuszczalnie prawidłowych danych wejściowych, jest uznawany za gotowy do produkcji i można go dołączyć do wydawanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="26233-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="26233-117">Dzięki temu wzorzec wyrażenia regularnego nadaje się do dopasowywania ograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="26233-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="26233-118">Jednak nie powoduje to, że wzorzec ten jest odpowiedni do porównywania nieograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="26233-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="26233-119">Aby dopasować nieograniczone dane wejściowe, wyrażenie regularne musi być w stanie efektywnie obsłużyć trzy rodzaje tekstu:</span><span class="sxs-lookup"><span data-stu-id="26233-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="26233-120">Tekst, który pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="26233-121">Tekst, który nie pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="26233-122">Tekst, który prawie pasuje do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="26233-123">Ostatni typ tekstu jest szczególnie problematyczny dla wyrażeń regularnych, które zostały napisane do obsługi ograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="26233-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="26233-124">Jeśli to wyrażenie regularne [opiera się również na rozbudowanej](backtracking-in-regular-expressions.md)operacji wycofywania, aparat wyrażeń regularnych może poświęcać niezależny czas (w niektórych przypadkach, wiele godzin lub dni) przetwarzanie pozornie niewielkiej ilości tekstu.</span><span class="sxs-lookup"><span data-stu-id="26233-124">If that regular expression also relies on extensive [backtracking](backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="26233-125">W poniższym przykładzie użyto wyrażenia regularnego, które jest podatne na nadmierne korzystanie z wycofywania, przez co istnieje duże prawdopodobieństwo odrzucenia prawidłowych adresów e-mail.</span><span class="sxs-lookup"><span data-stu-id="26233-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="26233-126">Nie należy stosować go w procedurze weryfikacji adresów e-mail.</span><span class="sxs-lookup"><span data-stu-id="26233-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="26233-127">Jeśli potrzebujesz wyrażenia regularnego weryfikującego adresy e-mail, zobacz [jak to zrobić: Sprawdź, czy ciągi są w prawidłowym formacie poczty e-mail](how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="26233-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="26233-128">Rozważmy na przykład bardzo często używane, ale wyjątkowo problematyczne wyrażenie regularne służące do weryfikacji aliasów adresów e-mail.</span><span class="sxs-lookup"><span data-stu-id="26233-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="26233-129">Wyrażenie regularne `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` jest zapisywane w celu przetworzenia, co oznacza, że jest to prawidłowy adres e-mail, który składa się z znaku alfanumerycznego, po którym następuje zero lub więcej znaków, które mogą być alfanumeryczne, kropki lub łączniki.</span><span class="sxs-lookup"><span data-stu-id="26233-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="26233-130">Wyrażenie regularne musi być zakończone znakiem alfanumerycznym.</span><span class="sxs-lookup"><span data-stu-id="26233-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="26233-131">Jednak, jak pokazuje poniższy przykład, mimo że wyrażenie regularne obsługuje z łatwością prawidłowe dane wejściowe, jego wydajność jest nieefektywna podczas przetwarzania niemal prawidłowych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="26233-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="26233-132">Dane wyjściowe z przykładu pokazują, że aparat wyrażeń regularnych przetwarza prawidłowe aliasy adresów e-mail w prawie takim samym interwale czasowym, niezależnie od ich długości.</span><span class="sxs-lookup"><span data-stu-id="26233-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="26233-133">Z drugiej strony, kiedy niemal prawidłowy adres e-mail zawiera więcej niż pięć znaków, dla każdego dodatkowego znaku w ciągu czas przetwarzania w przybliżeniu wzrasta dwukrotnie.</span><span class="sxs-lookup"><span data-stu-id="26233-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="26233-134">Oznacza to, że przetwarzanie niemal prawidłowego 28-znakowego ciągu będzie trwało prawie godzinę, a przetwarzanie niemal prawidłowego 33-znakowego ciągu będzie trwało prawie cały dzień.</span><span class="sxs-lookup"><span data-stu-id="26233-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="26233-135">Ponieważ wyrażenie regularne zostało opracowane z uwzględnieniem wyłącznie formatu danych wejściowych do dopasowania, wyrażenie regularne nie uwzględnia danych wejściowych, które nie pasują do wzorca.</span><span class="sxs-lookup"><span data-stu-id="26233-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="26233-136">To z kolei może spowodować, że nieograniczone dane wejściowe, które niemal odpowiadają wzorcowi wyrażenia regularnego, znacząco obniżą wydajność.</span><span class="sxs-lookup"><span data-stu-id="26233-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="26233-137">Aby rozwiązać ten problem, można wykonać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="26233-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="26233-138">Podczas tworzenia wzorca należy uwzględnić wpływ wycofywania na wydajność aparatu wyrażeń regularnych, szczególnie jeśli wyrażenie regularne jest przeznaczone do przetwarzania nieograniczonych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="26233-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="26233-139">Aby uzyskać więcej informacji, zobacz sekcję [przejmowanie opłaty za wycofywanie](#take-charge-of-backtracking) .</span><span class="sxs-lookup"><span data-stu-id="26233-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="26233-140">Wyrażenie regularne należy dokładnie sprawdzić, używając nieprawidłowych i niemal prawidłowych danych wejściowych, a także prawidłowych danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="26233-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="26233-141">Aby losowo wygenerować dane wejściowe dla określonego wyrażenia regularnego, możesz użyć [Narzędzia Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), który jest narzędziem do eksploracji wyrażenia regularnego z Microsoft Research.</span><span class="sxs-lookup"><span data-stu-id="26233-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="26233-142">Odpowiednio Obsługuj Tworzenie wystąpienia obiektu</span><span class="sxs-lookup"><span data-stu-id="26233-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="26233-143">W serca. Model obiektów wyrażeń regularnych sieci jest <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> klasą, która reprezentuje aparat wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-143">At the heart of .NET's regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="26233-144">Często jeden największy czynnik wpływający na wydajność wyrażeń regularnych jest sposobem, w jaki <xref:System.Text.RegularExpressions.Regex> aparat jest używany.</span><span class="sxs-lookup"><span data-stu-id="26233-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="26233-145">Definiowanie wyrażenia regularnego polega na ścisłym sprzęganiu aparatu wyrażeń regularnych z wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="26233-146">Ten proces sprzęgania, niezależnie od tego, czy obejmuje tworzenie wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu przez przekazanie jego konstruktora wzorcem wyrażenia regularnego, czy wywoływanie statycznej metody przez przekazanie jej wzorca wyrażenia regularnego wraz z ciągiem, który ma być analizowany, jest zgodnie z koniecznością kosztowną.</span><span class="sxs-lookup"><span data-stu-id="26233-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="26233-147">Aby zapoznać się z bardziej szczegółowym omówieniem implikacji wydajności przy użyciu interpretowanych i skompilowanych wyrażeń regularnych, zobacz [Optymalizowanie wydajności wyrażeń regularnych, część II: Przejmowanie opłaty za wycofywanie](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) w blogu zespołu BCL.</span><span class="sxs-lookup"><span data-stu-id="26233-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="26233-148">Można sprzęgnąć aparat wyrażeń regularnych z konkretnym wzorcem wyrażenia regularnego, a następnie użyć aparatu, aby dopasować tekst na kilka sposobów:</span><span class="sxs-lookup"><span data-stu-id="26233-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="26233-149">Można wywołać statyczną metodę dopasowania do wzorca, taką jak <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="26233-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="26233-150">Nie wymaga to tworzenia wystąpienia obiektu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="26233-151">Można utworzyć wystąpienie <xref:System.Text.RegularExpressions.Regex> obiektu i wywołać metodę dopasowania wystąpienia do wzorca interpretowanego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="26233-152">Jest to domyślna metoda do tworzenia powiązania aparatu wyrażeń regularnych z wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="26233-153">Powstaje po <xref:System.Text.RegularExpressions.Regex> utworzeniu wystąpienia obiektu bez `options` argumentu, który zawiera <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flagę.</span><span class="sxs-lookup"><span data-stu-id="26233-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="26233-154">Można utworzyć wystąpienie <xref:System.Text.RegularExpressions.Regex> obiektu i wywołać metodę dopasowania wystąpienia do wzorca skompilowanego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="26233-155">Obiekty wyrażeń regularnych reprezentują skompilowane wzorce, gdy <xref:System.Text.RegularExpressions.Regex> obiekt jest skonkretyzowany przy użyciu `options` argumentu, który zawiera <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flagę.</span><span class="sxs-lookup"><span data-stu-id="26233-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="26233-156">Można utworzyć obiekt specjalnego przeznaczenia, <xref:System.Text.RegularExpressions.Regex> który jest ściśle połączony z określonym wzorcem wyrażenia regularnego, skompilować go i zapisać w autonomicznym zestawie.</span><span class="sxs-lookup"><span data-stu-id="26233-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="26233-157">W tym celu należy wywołać <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="26233-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="26233-158">Sposób, w jaki są wywoływane metody dopasowywania wyrażeń regularnych, może mieć znaczący wpływ na działanie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="26233-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="26233-159">W poniższych sekcjach omówiono, kiedy używać wywołań metod statycznych oraz interpretowanych i skompilowanych wyrażeń regularnych, aby poprawić wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="26233-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="26233-160">Jeśli to samo wyrażenie regularne jest używane wielokrotnie w wywołaniach metod lub jeśli obiekty wyrażeń regularnych są często używane w aplikacji, sposób wywoływania metody (statyczny, interpretowany, skompilowany) znacząco wpływa na wydajność.</span><span class="sxs-lookup"><span data-stu-id="26233-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="26233-161">Statyczne wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="26233-161">Static regular expressions</span></span>

<span data-ttu-id="26233-162">Statyczne metody wyrażeń regularnych są zalecane jako alternatywa dla wielokrotnego tworzenia wystąpienia obiektu wyrażenia regularnego z tym samym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="26233-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="26233-163">W przeciwieństwie do wzorców wyrażeń regularnych używanych przez obiekty wyrażeń regularnych, kody operacji lub skompilowane języka pośredniego firmy Microsoft (MSIL) z wzorców używanych w wywołaniach metod statycznych są buforowane wewnętrznie przez aparat wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="26233-164">Na przykład program obsługi zdarzeń często wywołuje inną metodę do weryfikacji danych wejściowych użytkownika.</span><span class="sxs-lookup"><span data-stu-id="26233-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="26233-165">Jest to odzwierciedlone w poniższym kodzie, w którym <xref:System.Windows.Forms.Button> zdarzenie kontrolki <xref:System.Windows.Forms.Control.Click> służy do wywołania metody o nazwie `IsValidCurrency` , która sprawdza, czy użytkownik wprowadził symbol waluty, po którym następuje co najmniej jedna cyfra dziesiętna.</span><span class="sxs-lookup"><span data-stu-id="26233-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="26233-166">W poniższym przykładzie pokazano bardzo wydajną implementację `IsValidCurrency` metody.</span><span class="sxs-lookup"><span data-stu-id="26233-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="26233-167">Należy zauważyć, że każde wywołanie metody retworzy wystąpienie <xref:System.Text.RegularExpressions.Regex> obiektu z tym samym wzorcem.</span><span class="sxs-lookup"><span data-stu-id="26233-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="26233-168">To z kolei oznacza, że wzorzec wyrażenia regularnego należy kompilować podczas każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="26233-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="26233-169">Ten nieefektywny kod należy zastąpić wywołaniem metody statycznej <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="26233-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="26233-170">Eliminuje to konieczność tworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu za każdym razem, gdy chcesz wywołać metodę dopasowania do wzorca, i umożliwia aparatowi wyrażeń regularnych pobieranie skompilowanej wersji wyrażenia regularnego z jego pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="26233-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="26233-171">Domyślnie buforowanych jest piętnaście ostatnio używanych statycznych wzorców wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="26233-172">W przypadku aplikacji, które wymagają większej liczby buforowanych statycznych wyrażeń regularnych, rozmiar pamięci podręcznej można dostosować przez ustawienie <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="26233-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="26233-173">Wyrażenie regularne `\p{Sc}+\s*\d+` , które jest używane w tym przykładzie, sprawdza, czy ciąg wejściowy zawiera symbol waluty i co najmniej jedną cyfrę dziesiętną.</span><span class="sxs-lookup"><span data-stu-id="26233-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="26233-174">Definicję wzorca pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="26233-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="26233-175">Wzorce</span><span class="sxs-lookup"><span data-stu-id="26233-175">Pattern</span></span>|<span data-ttu-id="26233-176">Opis</span><span class="sxs-lookup"><span data-stu-id="26233-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="26233-177">Dopasowanie do jednego lub większej liczby symboli Unicode w kategorii Waluta.</span><span class="sxs-lookup"><span data-stu-id="26233-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="26233-178">Dopasowanie do zera lub większej liczby znaków odstępu.</span><span class="sxs-lookup"><span data-stu-id="26233-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="26233-179">Dopasowanie do co najmniej jednej cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="26233-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="26233-180">Interpretowane a skompilowane wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="26233-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="26233-181">Wzorce wyrażeń regularnych, które nie są powiązane z aparatem wyrażeń regularnych przez specyfikację <xref:System.Text.RegularExpressions.RegexOptions.Compiled> opcji, są interpretowane.</span><span class="sxs-lookup"><span data-stu-id="26233-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="26233-182">Kiedy tworzone jest wystąpienie obiektu wyrażenia regularnego, aparat wyrażeń regularnych konwertuje wyrażenie regularne na zestaw kodów operacji.</span><span class="sxs-lookup"><span data-stu-id="26233-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="26233-183">Gdy wywoływana jest metoda wystąpienia, kody operacji są konwertowane do języka MSIL i wykonywane przy użyciu kompilatora JIT.</span><span class="sxs-lookup"><span data-stu-id="26233-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="26233-184">Podobnie, kiedy jest wywoływania statyczna metoda wyrażenia regularnego i wyrażenie regularne nie jest znajdowane w pamięci podręcznej, aparat wyrażeń regularnych konwertuje wyrażenie regularne na zestaw kodów operacji i przechowuje je w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="26233-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="26233-185">Następnie konwertuje te kody operacji na język MSIL, dzięki czemu mogą zostać wykonane za pomocą kompilatora JIT.</span><span class="sxs-lookup"><span data-stu-id="26233-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="26233-186">Interpretowane wyrażenia regularne ograniczają czas uruchamiania kosztem wolniejszego czasu wykonania.</span><span class="sxs-lookup"><span data-stu-id="26233-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="26233-187">Z tego powodu najlepiej stosować je, kiedy wyrażenie regularne jest używane w małej liczbie wywołań metod lub jeśli dokładna liczba wywołań metod wyrażenia regularnego jest nieznana, ale oczekuje się, że będzie mała.</span><span class="sxs-lookup"><span data-stu-id="26233-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="26233-188">Wraz ze wzrostem liczby wywołań metod przyrost wydajności związany ze skróceniem czasu uruchamiania jest coraz mniejszy wskutek wolniejszego wykonywania.</span><span class="sxs-lookup"><span data-stu-id="26233-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="26233-189">Wzorce wyrażeń regularnych, które są powiązane z aparatem wyrażeń regularnych przez specyfikację <xref:System.Text.RegularExpressions.RegexOptions.Compiled> opcji, są kompilowane.</span><span class="sxs-lookup"><span data-stu-id="26233-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="26233-190">Oznacza to, że kiedy jest tworzone wystąpienie obiektu wyrażenia regularnego lub kiedy jest wywoływana statyczna metoda wyrażenia regularnego i wyrażenie regularne nie jest znajdowane w pamięci podręcznej, aparat wyrażeń regularnych konwertuje wyrażenie regularne na pośredni zestaw kodów operacji, które następnie konwertuje na język MSIL.</span><span class="sxs-lookup"><span data-stu-id="26233-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="26233-191">Kiedy metoda jest wywoływana, kompilator JIT wykonuje kod języka MSIL.</span><span class="sxs-lookup"><span data-stu-id="26233-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="26233-192">W przeciwieństwie do interpretowanych wyrażeń regularnych, skompilowane wyrażenia regularne wydłużają czas uruchamiania, ale wykonanie pojedynczych metod dopasowania do wzorca jest szybsze.</span><span class="sxs-lookup"><span data-stu-id="26233-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="26233-193">W rezultacie korzyści w zakresie wydajności wynikające z kompilowania wyrażeń regularnych rosną proporcjonalnie do liczby wywoływanych metod wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="26233-194">Podsumowując, zaleca się używać interpretowanych wyrażeń regularnych, kiedy stosunkowo rzadko są wywoływane metody wyrażeń regularnych z określonym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="26233-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="26233-195">Zaleca się używać skompilowanych wyrażeń regularnych, kiedy stosunkowo często są wywoływane metody wyrażeń regularnych z określonym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="26233-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="26233-196">Dokładny próg, przy którym mniejsza szybkość wykonywania interpretowanych wyrażeń regularnych przewyższa korzyści z redukcji czasu uruchamiania, lub próg, przy którym wolniejsze uruchamianie skompilowanych wyrażeń regularnych przewyższa korzyści z większej szybkości wykonywania, jest trudny do określenia.</span><span class="sxs-lookup"><span data-stu-id="26233-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="26233-197">Zależy to od wielu czynników, w tym od złożoności wyrażenia regularnego i konkretnych danych, które to wyrażenie przetwarza.</span><span class="sxs-lookup"><span data-stu-id="26233-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="26233-198">Aby określić, czy interpretowane lub skompilowane wyrażenia regularne oferują najlepszą wydajność dla konkretnego scenariusza aplikacji, można użyć <xref:System.Diagnostics.Stopwatch> klasy do porównania czasów wykonania.</span><span class="sxs-lookup"><span data-stu-id="26233-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="26233-199">Poniższy przykład porównuje wydajność skompilowanych i interpretowanych wyrażeń regularnych podczas odczytywania pierwszych dziesięciu zdań i odczytuje wszystkie zdania w tekście powieści Theodore'a dreisera Dreiser *Financier*.</span><span class="sxs-lookup"><span data-stu-id="26233-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="26233-200">Dane wyjściowe z przykładu pokazują, że przy zaledwie dziesięciu wywołaniach metod dopasowania wyrażenia regularnego interpretowane wyrażenie regularne oferuje lepszą wydajność niż skompilowane wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="26233-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="26233-201">Jednak skompilowane wyrażenie regularne oferuje lepszą wydajność dla dużej liczby wywołań (w tym przypadku ponad 13 000).</span><span class="sxs-lookup"><span data-stu-id="26233-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="26233-202">Wzorzec wyrażenia regularnego używany w przykładzie, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]` , jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="26233-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="26233-203">Wzorce</span><span class="sxs-lookup"><span data-stu-id="26233-203">Pattern</span></span>|<span data-ttu-id="26233-204">Opis</span><span class="sxs-lookup"><span data-stu-id="26233-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="26233-205">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="26233-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="26233-206">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="26233-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="26233-207">Dopasowanie do zera lub jednego znaku powrotu karetki, po którym występuje znak nowego wiersza, albo do zera lub jednego przecinka, po którym występuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="26233-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="26233-208">Dopasowanie do zera lub większej liczby wystąpień jednego lub większej liczby znaków słowa, po którym występuje zero albo jeden znak powrotu karetki i znak nowego wiersza lub zero albo jeden przecinek, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="26233-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="26233-209">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="26233-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="26233-210">Dopasowanie do kropki, znaku zapytania, dwukropka, średnika lub wykrzyknika.</span><span class="sxs-lookup"><span data-stu-id="26233-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="26233-211">Wyrażenia regularne: skompilowane do zestawu</span><span class="sxs-lookup"><span data-stu-id="26233-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="26233-212">Program .NET umożliwia również tworzenie zestawu zawierającego skompilowane wyrażenia regularne.</span><span class="sxs-lookup"><span data-stu-id="26233-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="26233-213">Przenosi to czynnik wpływający na wydajność kompilowania wyrażeń regularnych z czasu wykonywania na czas projektowania.</span><span class="sxs-lookup"><span data-stu-id="26233-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="26233-214">Jednak to także wiąże się z dodatkową pracą: konieczne jest zdefiniowanie wyrażane regularnych z wyprzedzeniem i skompilowanie ich do zestawu.</span><span class="sxs-lookup"><span data-stu-id="26233-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="26233-215">Kompilator może następnie odwołać się do tego zestawu podczas kompilowania kodu źródłowego, który używa wyrażeń regularnych zestawu.</span><span class="sxs-lookup"><span data-stu-id="26233-215">The compiler can then reference this assembly when compiling source code that uses the assembly's regular expressions.</span></span> <span data-ttu-id="26233-216">Każde skompilowane wyrażenie regularne w zestawie jest reprezentowane przez klasę, która pochodzi od <xref:System.Text.RegularExpressions.Regex> .</span><span class="sxs-lookup"><span data-stu-id="26233-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="26233-217">Aby kompilować wyrażenia regularne do zestawu, należy wywołać <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> metodę i przekazać do niej tablicę <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektów reprezentujących wyrażenia regularne do skompilowania oraz <xref:System.Reflection.AssemblyName> obiekt, który zawiera informacje o zestawie, który ma zostać utworzony.</span><span class="sxs-lookup"><span data-stu-id="26233-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="26233-218">Zaleca się, aby kompilować wyrażenia regularne do zestawu w następujących sytuacjach:</span><span class="sxs-lookup"><span data-stu-id="26233-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="26233-219">Jeśli jesteś deweloperem składników, który chce utworzyć bibliotekę wyrażeń regularnych do wielokrotnego użytku.</span><span class="sxs-lookup"><span data-stu-id="26233-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="26233-220">Jeśli oczekujesz, że metody dopasowania do wzorca wyrażenia regularnego będą wywoływane nieokreśloną liczbę razy — od jednego lub dwóch wywołań do kilku tysięcy wywołań.</span><span class="sxs-lookup"><span data-stu-id="26233-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="26233-221">W przeciwieństwie do skompilowanych lub interpretowanych wyrażeń regularnych, wyrażenia regularne, które są kompilowane do oddzielnych zestawów, oferują stałą wydajność bez względu na liczbę wywołań metody.</span><span class="sxs-lookup"><span data-stu-id="26233-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="26233-222">Jeśli skompilowane wyrażenia regularne są używane w celu optymalizacji wydajności, nie należy używać odbicia w celu utworzenia zestawu, załadowania aparatu wyrażeń regularnych i wykonania jego metod dopasowania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="26233-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="26233-223">Wymaga to unikania dynamicznego kompilowania wzorców wyrażeń regularnych i określenia wszelkich opcji dopasowania do wzorca (np. z uwzględnieniem wielkości liter) w czasie tworzenia zestawu.</span><span class="sxs-lookup"><span data-stu-id="26233-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="26233-224">Wymaga to również odseparowania kodu, który tworzy zestaw, od kodu, który używa wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="26233-225">W poniższym przykładzie pokazano, w jaki sposób utworzyć zestaw zawierający skompilowane wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="26233-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="26233-226">Tworzy zestaw o nazwie `RegexLib.dll` z pojedynczą klasą wyrażenia regularnego, `SentencePattern` która zawiera wzorzec wyrażenia regularnego, który jest używany w sekcji [interpretowane a skompilowane wyrażenia regularne](#interpreted-vs-compiled-regular-expressions) .</span><span class="sxs-lookup"><span data-stu-id="26233-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="26233-227">Gdy przykład jest kompilowany do pliku wykonywalnego i uruchamiany, tworzy zestaw o nazwie `RegexLib.dll` .</span><span class="sxs-lookup"><span data-stu-id="26233-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="26233-228">Wyrażenie regularne jest reprezentowane przez klasę o nazwie `Utilities.RegularExpressions.SentencePattern` , która pochodzi od <xref:System.Text.RegularExpressions.Regex> .</span><span class="sxs-lookup"><span data-stu-id="26233-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="26233-229">Poniższy przykład używa skompilowanego wyrażenia regularnego, aby wyodrębnić zdania z tekstu powieści Theodore'a dreisera Dreiser *Financier*.</span><span class="sxs-lookup"><span data-stu-id="26233-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="26233-230">Przejmowanie opłaty za wycofywanie</span><span class="sxs-lookup"><span data-stu-id="26233-230">Take charge of backtracking</span></span>

<span data-ttu-id="26233-231">Zazwyczaj aparat wyrażeń regularnych używa progresji liniowej do przechodzenia przez ciąg wejściowy i porównywania go ze wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="26233-232">Jednakże, gdy nieokreślone Kwantyfikatory, takie jak `*` , `+` i `?` są używane we wzorcu wyrażenia regularnego, aparat wyrażeń regularnych może dać część udanych częściowych dopasowań i powrócić do wcześniej zapisanego stanu, aby wyszukać pomyślne dopasowanie dla całego wzorca.</span><span class="sxs-lookup"><span data-stu-id="26233-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="26233-233">Proces ten jest znany pod nazwą wycofywania.</span><span class="sxs-lookup"><span data-stu-id="26233-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="26233-234">Aby uzyskać więcej informacji na temat wycofywania, zobacz [Szczegóły zachowania wyrażenia regularnego](details-of-regular-expression-behavior.md) [i](backtracking-in-regular-expressions.md)wycofywania.</span><span class="sxs-lookup"><span data-stu-id="26233-234">For more information on backtracking, see [Details of Regular Expression Behavior](details-of-regular-expression-behavior.md) and [Backtracking](backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="26233-235">Aby zapoznać się ze szczegółową omówieniem wycofywania, zobacz [Optymalizowanie wydajności wyrażeń regularnych, część II: Przejmowanie opłaty za wycofywanie](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) w blogu zespołu BCL.</span><span class="sxs-lookup"><span data-stu-id="26233-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="26233-236">Obsługa wycofywania daje wyrażeniom regularnym duże możliwości i elastyczność.</span><span class="sxs-lookup"><span data-stu-id="26233-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="26233-237">Dodatkowo odpowiedzialność za kontrolowanie operacji aparatu wyrażeń regularnych spada na deweloperów wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="26233-238">Ponieważ deweloperzy często nie są tego świadomi, błędne użycie wycofywania lub nadmierne poleganie na wycofywaniu często odgrywa najbardziej znaczącą rolę w zmniejszeniu wydajności wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="26233-239">W scenariuszu najgorszego przypadku czas wykonywania może podwajać się dla każdego dodatkowego znaku w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="26233-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="26233-240">W rzeczywistości przy nadmiernym wykorzystaniu wycofywania łatwo jest stworzyć programowy odpowiednik pętli nieskończonej, jeżeli dane wejściowe niemal pasują do wzorca wyrażenia regularnego; przetwarzanie relatywnie krótkiego ciągu wejściowego może zająć aparatowi wyrażeń regularnych kilka godzin, a nawet dni.</span><span class="sxs-lookup"><span data-stu-id="26233-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="26233-241">Często efektem użycia wycofywania jest obniżenie wydajności w aplikacjach, mimo że używanie wycofywania nie jest niezbędne dla dopasowania.</span><span class="sxs-lookup"><span data-stu-id="26233-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="26233-242">Na przykład wyrażenie regularne `\b\p{Lu}\w*\b` dopasowuje wszystkie wyrazy rozpoczynające się od wielkiej litery, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="26233-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="26233-243">Wzorce</span><span class="sxs-lookup"><span data-stu-id="26233-243">Pattern</span></span>|<span data-ttu-id="26233-244">Opis</span><span class="sxs-lookup"><span data-stu-id="26233-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="26233-245">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="26233-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="26233-246">Dopasowanie do dowolnej wielkiej litery.</span><span class="sxs-lookup"><span data-stu-id="26233-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="26233-247">Dopasowuje zero lub więcej znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="26233-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="26233-248">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="26233-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="26233-249">Ponieważ granica wyrazu nie jest tym samym co znak słowa ani jego podzbiorem, nie ma możliwości, aby aparat wyrażeń regularnych przekroczył granicę wyrazu podczas dopasowywania znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="26233-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="26233-250">Oznacza to, że dla tego wyrażenia regularnego wycofywanie może nigdy nie przyczynić się do sukcesu jakiegokolwiek dopasowania, może za to obniżyć wydajność, ponieważ aparat wyrażeń regularnych musi zapisać swój stan podczas każdego pomyślnie zakończonego wstępnego dopasowania znaku słowa.</span><span class="sxs-lookup"><span data-stu-id="26233-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="26233-251">Jeśli okaże się, że wycofywanie nie jest konieczne, można je wyłączyć za pomocą `(?>subexpression)` elementu języka, zwanego grupą niepodzielną.</span><span class="sxs-lookup"><span data-stu-id="26233-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="26233-252">W poniższym przykładzie jest analizowana składnia ciągu wejściowego przy użyciu dwóch wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="26233-253">Pierwszy, `\b\p{Lu}\w*\b` , korzysta z wycofywania.</span><span class="sxs-lookup"><span data-stu-id="26233-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="26233-254">Druga, `\b\p{Lu}(?>\w*)\b` , wyłącza wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="26233-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="26233-255">Jak wynika z przykładu, oba wyrażenia regularne dały ten sam wynik.</span><span class="sxs-lookup"><span data-stu-id="26233-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="26233-256">W wielu przypadkach wycofywanie jest niezbędne dla dopasowania wzorca wyrażenia regularnego do tekstu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="26233-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="26233-257">Należy pamiętać, że nadmierne używanie wycofywania może poważnie obniżyć wydajność i stworzyć wrażanie, ze aplikacja przestała odpowiadać.</span><span class="sxs-lookup"><span data-stu-id="26233-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="26233-258">W szczególności ma to miejsce, kiedy kwantyfikatory są zagnieżdżane i tekst, który pasuje do zewnętrznego podwyrażenia, jest podzbiorem tekstu, który pasuje do wewnętrznego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="26233-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="26233-259">Oprócz unikania nadmiernego wykorzystania wycofywania należy używać funkcji limitu czasu, aby zagwarantować, że nadmierne używanie wycofywania nie obniży poważnie wydajności wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="26233-260">Aby uzyskać więcej informacji, zobacz sekcję [użycie wartości limitu czasu](#use-time-out-values) .</span><span class="sxs-lookup"><span data-stu-id="26233-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="26233-261">Na przykład wzorzec wyrażenia regularnego `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` jest przeznaczony do dopasowania do numeru części, który składa się z co najmniej jednego znaku alfanumerycznego.</span><span class="sxs-lookup"><span data-stu-id="26233-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="26233-262">Jakiekolwiek dodatkowe znaki mogą być znakami alfanumerycznymi, łącznikami, podkreśleniami lub kropkami, ale ostatni znak musi być alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="26233-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="26233-263">Znak dolara przerywa numer części.</span><span class="sxs-lookup"><span data-stu-id="26233-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="26233-264">W niektórych przypadkach ten wzorzec wyrażenia regularnego może wykazywać bardzo niską wydajność, ponieważ Kwantyfikatory są zagnieżdżone, a ponieważ Podwyrażenie `[0-9A-Z]` jest podzbiorem podwyrażenia `[-.\w]*` .</span><span class="sxs-lookup"><span data-stu-id="26233-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="26233-265">W takich przypadkach można zoptymalizować wydajność wyrażenia regularnego, usuwając zagnieżdżone kwantyfikatory i zastępując zewnętrzne podwyrażenie asercją wyprzedzającą lub wsteczną o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="26233-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="26233-266">Asercje wyprzedzające i wsteczne są kotwicami; nie przesuwają wskaźnika w ciągu wejściowym, ale „patrzą” do przodu lub wstecz, aby sprawdzić, czy określony warunek został spełniony.</span><span class="sxs-lookup"><span data-stu-id="26233-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="26233-267">Na przykład wyrażenie regularne numeru części można napisać jako `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$` .</span><span class="sxs-lookup"><span data-stu-id="26233-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="26233-268">Definicję tego wzorca wyrażenia regularnego pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="26233-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="26233-269">Wzorce</span><span class="sxs-lookup"><span data-stu-id="26233-269">Pattern</span></span>|<span data-ttu-id="26233-270">Opis</span><span class="sxs-lookup"><span data-stu-id="26233-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="26233-271">Rozpoczyna dopasowanie na początku ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="26233-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="26233-272">Dopasowuje znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="26233-272">Match an alphanumeric character.</span></span> <span data-ttu-id="26233-273">Numer części musi zawierać przynajmniej jeden znak.</span><span class="sxs-lookup"><span data-stu-id="26233-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="26233-274">Dopasowanie do zera lub większej liczby wystąpień dowolnego znaku słowa, łącznika lub kropki.</span><span class="sxs-lookup"><span data-stu-id="26233-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="26233-275">Dopasowanie do znaku dolara.</span><span class="sxs-lookup"><span data-stu-id="26233-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="26233-276">Spoglądanie w przód od kończącego znaku dolara, aby się upewnić, że znak poprzedzający jest alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="26233-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="26233-277">Dopasowywanie kończy się na końcu ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="26233-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="26233-278">W poniższym przykładzie pokazano użycie tego wyrażenia regularnego w celu dopasowania tablicy zawierającej możliwe numery części.</span><span class="sxs-lookup"><span data-stu-id="26233-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="26233-279">Język wyrażeń regularnych w programie .NET zawiera następujące elementy języka, których można użyć w celu wyeliminowania kwantyfikatorów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="26233-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="26233-280">Aby uzyskać więcej informacji, zobacz [grupowanie konstrukcji](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="26233-280">For more information, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="26233-281">Element języka</span><span class="sxs-lookup"><span data-stu-id="26233-281">Language element</span></span>|<span data-ttu-id="26233-282">Opis</span><span class="sxs-lookup"><span data-stu-id="26233-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="26233-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="26233-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="26233-284">Pozytywna asercja wyprzedzająca o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="26233-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="26233-285">Sprawdź przed bieżącą pozycją, aby określić `subexpression` , czy pasuje do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="26233-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="26233-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="26233-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="26233-287">Negatywna asercja wyprzedzająca o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="26233-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="26233-288">Sprawdź przed bieżącą pozycją, aby określić `subexpression` , czy nie pasuje do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="26233-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="26233-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="26233-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="26233-290">Pozytywna asercja wsteczna o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="26233-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="26233-291">Sprawdź za bieżącą pozycję, aby określić `subexpression` , czy pasuje do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="26233-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="26233-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="26233-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="26233-293">Negatywna asercja wsteczna o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="26233-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="26233-294">Sprawdź za bieżącą pozycję, aby określić `subexpression` , czy nie pasuje do ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="26233-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="26233-295">Użyj wartości limitu czasu</span><span class="sxs-lookup"><span data-stu-id="26233-295">Use time-out values</span></span>

<span data-ttu-id="26233-296">Jeśli wyrażenie regularne przetwarza dane wejściowe, które niemal pasują do wzorca wyrażenia regularnego, często może nadmiernie używać wycofywania, co znacznie wpływa na wydajność.</span><span class="sxs-lookup"><span data-stu-id="26233-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="26233-297">Oprócz dokładnego rozważenia użycia wycofywania i przetestowania wyrażenia regularnego pod kątem niemal dopasowanych danych wejściowych, zawsze należy ustawić wartość limitu czasu, aby zagwarantować, że efekt nadmiernego używania wycofywania, jeżeli wystąpi, będzie jak najmniejszy.</span><span class="sxs-lookup"><span data-stu-id="26233-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="26233-298">Interwał limitu czasu wyrażenia regularnego określa czas, przez który aparat wyrażeń regularnych będzie szukał pojedynczego dopasowania, zanim zostanie przekroczony limit czasu. Domyślny limit czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> , co oznacza, że limit czasu wyrażenia regularnego nie zostanie przekroczony. Można zastąpić tę wartość i zdefiniować interwał limitu czasu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="26233-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="26233-299">Przez podanie wartości limitu czasu podczas tworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu przez wywołanie <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="26233-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor.</span></span>

- <span data-ttu-id="26233-300">Wywołując statyczną metodę dopasowania do wzorca, taką jak <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> , która zawiera `matchTimeout` parametr.</span><span class="sxs-lookup"><span data-stu-id="26233-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="26233-301">Dla skompilowanych wyrażeń regularnych, które są tworzone przez wywołanie <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> metody, przez wywołanie konstruktora, który ma parametr typu <xref:System.TimeSpan> .</span><span class="sxs-lookup"><span data-stu-id="26233-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="26233-302">Jeśli zdefiniowano interwał limitu czasu i dopasowanie nie zostanie znalezione na końcu interwału, metoda wyrażenia regularnego zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek.</span><span class="sxs-lookup"><span data-stu-id="26233-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="26233-303">W obsłudze wyjątków można wybrać ponowienie próby dopasowywania z dłuższym interwałem limitu czasu, zrezygnować z próby dopasowania i założyć, że dopasowanie nie istnieje, lub zrezygnować z próby dopasowania i zarejestrować informacje o wyjątku na potrzeby późniejszej analizy.</span><span class="sxs-lookup"><span data-stu-id="26233-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="26233-304">W poniższym przykładzie zdefiniowano `GetWordData` metodę, która tworzy wystąpienie wyrażenia regularnego z interwałem limitu czasu wynoszącym 350 milisekund, aby obliczyć liczbę słów i średnią liczbę znaków w wyrazie w dokumencie tekstowym.</span><span class="sxs-lookup"><span data-stu-id="26233-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="26233-305">W przypadku przekroczenia limitu czasu dla operacji dopasowywania przekroczenie interwału czasowego zwiększa się o 350 milisekund, a <xref:System.Text.RegularExpressions.Regex> obiekt jest ponownie tworzony.</span><span class="sxs-lookup"><span data-stu-id="26233-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="26233-306">Jeżeli nowy interwał limitu czasu przekroczy 1 sekundę, metoda ponownie zgłosi wyjątek do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="26233-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="26233-307">Przechwyć tylko w razie potrzeby</span><span class="sxs-lookup"><span data-stu-id="26233-307">Capture only when necessary</span></span>

<span data-ttu-id="26233-308">Wyrażenia regularne w programie .NET obsługują szereg konstrukcji grupujących, które pozwalają grupować wzorzec wyrażenia regularnego w jedno lub więcej podwyrażeń.</span><span class="sxs-lookup"><span data-stu-id="26233-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="26233-309">Najczęściej używane konstrukcje grupujące w języku wyrażeń regularnych programu .NET to `(` *Podwyrażenie* `)` , które definiuje numerowaną grupę przechwytywania i `(?<` *name* `>` *Podwyrażenie*nazwy `)` , które definiuje nazwaną grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="26233-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="26233-310">Konstrukcje grupujące są niezbędne do tworzenia odwołań wstecznych i do definiowania podwyrażeń, do których jest stosowany kwantyfikator.</span><span class="sxs-lookup"><span data-stu-id="26233-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="26233-311">Jednak zastosowanie tych elementów języka jest kosztowne.</span><span class="sxs-lookup"><span data-stu-id="26233-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="26233-312">Powodują, że <xref:System.Text.RegularExpressions.GroupCollection> obiekt zwracany przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> Właściwość jest wypełniany najnowszymi nienazwanymi lub nazwanymi przechwycenimi, a jeśli jedna konstrukcja grupowania przechwyciła wiele podciągów w ciągu wejściowym, wypełnia również <xref:System.Text.RegularExpressions.CaptureCollection> obiekt zwrócony przez <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> Właściwość określonej grupy przechwytywania z wieloma <xref:System.Text.RegularExpressions.Capture> obiektami.</span><span class="sxs-lookup"><span data-stu-id="26233-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="26233-313">Często konstrukcje grupujące są używane w wyrażeniach regularnych tylko po to, aby można było zastosować do nich kwantyfikatory, i grupy przechwytywane przez te podwyrażenia nie są następnie używane.</span><span class="sxs-lookup"><span data-stu-id="26233-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="26233-314">Na przykład wyrażenie regularne `\b(\w+[;,]?\s?)+[.?!]` służy do przechwytywania całego zdania.</span><span class="sxs-lookup"><span data-stu-id="26233-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="26233-315">W poniższej tabeli opisano elementy języka w tym wzorcu wyrażenia regularnego i ich wpływ na <xref:System.Text.RegularExpressions.Match> obiekty <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekcje.</span><span class="sxs-lookup"><span data-stu-id="26233-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="26233-316">Wzorce</span><span class="sxs-lookup"><span data-stu-id="26233-316">Pattern</span></span>|<span data-ttu-id="26233-317">Opis</span><span class="sxs-lookup"><span data-stu-id="26233-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="26233-318">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="26233-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="26233-319">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="26233-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="26233-320">Dopasowanie do zera lub jednego przecinka albo średnika.</span><span class="sxs-lookup"><span data-stu-id="26233-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="26233-321">Dopasowuje zero lub jeden znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="26233-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="26233-322">Dopasowanie do jednego lub większej liczby wystąpień jednego lub większej liczby znaków słowa, po którym następuje opcjonalny przecinek lub średnik, po którym następuje opcjonalny znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="26233-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="26233-323">To definiuje pierwszą grupę przechwytywania, która jest niezbędna, aby kombinacja wielu znaków słowa (tzn. słowo), po których następuje opcjonalny znak interpunkcyjny, była powtarzana do momentu, kiedy aparat wyrażeń regularnych osiągnie koniec zdania.</span><span class="sxs-lookup"><span data-stu-id="26233-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="26233-324">Dopasowanie do kropki, znaku zapytania lub wykrzyknika.</span><span class="sxs-lookup"><span data-stu-id="26233-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="26233-325">Jak pokazano na poniższym przykładzie, gdy zostanie znalezione dopasowanie, zarówno obiekty, jak <xref:System.Text.RegularExpressions.GroupCollection> i <xref:System.Text.RegularExpressions.CaptureCollection> są wypełniane za pomocą przechwytywania z dopasowania.</span><span class="sxs-lookup"><span data-stu-id="26233-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="26233-326">W takim przypadku grupa przechwytywania istnieje, `(\w+[;,]?\s?)` Aby `+` można było do niej zastosować kwantyfikator, co umożliwia wzorce wyrażenia regularnego dopasowywania każdego wyrazu w zdaniu.</span><span class="sxs-lookup"><span data-stu-id="26233-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="26233-327">W przeciwnym razie dopasowanie nastąpi dla ostatniego wyrazu w zdaniu.</span><span class="sxs-lookup"><span data-stu-id="26233-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="26233-328">Kiedy używa się podwyrażeń tylko w celu zastosowania do nich kwantyfikatorów, a przechwytywany tekst nie jest ważny, należy wyłączyć przechwytywanie grup.</span><span class="sxs-lookup"><span data-stu-id="26233-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="26233-329">Na przykład `(?:subexpression)` element Language uniemożliwia grupę, do której odnosi się przed przechwyceniem dopasowanych podciągów.</span><span class="sxs-lookup"><span data-stu-id="26233-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="26233-330">W poniższym przykładzie wzorzec wyrażenia regularnego z poprzedniego przykładu jest zmieniany na `\b(?:\w+[;,]?\s?)+[.?!]` .</span><span class="sxs-lookup"><span data-stu-id="26233-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="26233-331">Jak widać w danych wyjściowych, uniemożliwia aparatowi wyrażeń regularnych zapełnianie <xref:System.Text.RegularExpressions.GroupCollection> <xref:System.Text.RegularExpressions.CaptureCollection> kolekcji i.</span><span class="sxs-lookup"><span data-stu-id="26233-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="26233-332">Przechwytywanie można wyłączyć na jeden z poniższych sposobów:</span><span class="sxs-lookup"><span data-stu-id="26233-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="26233-333">Użyj `(?:subexpression)` elementu języka.</span><span class="sxs-lookup"><span data-stu-id="26233-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="26233-334">Ten element zapobiega przechwytywaniu dopasowanych podciągów w grupie, do której jest stosowany.</span><span class="sxs-lookup"><span data-stu-id="26233-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="26233-335">Nie wyłącza przechwytywania podciągów w grupach zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="26233-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="26233-336">Użyj <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> opcji.</span><span class="sxs-lookup"><span data-stu-id="26233-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="26233-337">Wyłącza wszystkie nienazwane lub niejawne przechwytywania we wzorcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="26233-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="26233-338">W przypadku korzystania z tej opcji tylko podciągi, które pasują do nazwanych grup zdefiniowanych za pomocą `(?<name>subexpression)` elementu language, mogą być przechwytywane.</span><span class="sxs-lookup"><span data-stu-id="26233-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="26233-339"><xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>Flagę można przesłać do `options` parametru <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub do `options` parametru <xref:System.Text.RegularExpressions.Regex> statycznej metody dopasowywania.</span><span class="sxs-lookup"><span data-stu-id="26233-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="26233-340">Użyj `n` opcji w `(?imnsx)` elemencie języka.</span><span class="sxs-lookup"><span data-stu-id="26233-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="26233-341">Powoduje to wyłączenie wszystkich nienazwanych lub niejawnych przechwytywań od miejsca we wzorcu wyrażenia regularnego, w którym znajduje się ten element.</span><span class="sxs-lookup"><span data-stu-id="26233-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="26233-342">Przechwytywanie jest wyłączone do końca wzorca lub do czasu, gdy `(-n)` opcja włącza nienazwane lub niejawne przechwycenia.</span><span class="sxs-lookup"><span data-stu-id="26233-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="26233-343">Aby uzyskać więcej informacji, zobacz [różne konstrukcje](miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="26233-343">For more information, see [Miscellaneous Constructs](miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="26233-344">Użyj `n` opcji w `(?imnsx:subexpression)` elemencie języka.</span><span class="sxs-lookup"><span data-stu-id="26233-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="26233-345">Ta opcja wyłącza wszystkie nienazwane lub niejawne przechwycenia w `subexpression` .</span><span class="sxs-lookup"><span data-stu-id="26233-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="26233-346">Przechwytywania przez jakiekolwiek nienazwane lub niejawne zagnieżdżone grupy przechwytywania również są wyłączone.</span><span class="sxs-lookup"><span data-stu-id="26233-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="26233-347">Powiązane tematy</span><span class="sxs-lookup"><span data-stu-id="26233-347">Related topics</span></span>

|<span data-ttu-id="26233-348">Tytuł</span><span class="sxs-lookup"><span data-stu-id="26233-348">Title</span></span>|<span data-ttu-id="26233-349">Opis</span><span class="sxs-lookup"><span data-stu-id="26233-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="26233-350">Szczegóły zachowania dotyczącego wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="26233-350">Details of Regular Expression Behavior</span></span>](details-of-regular-expression-behavior.md)|<span data-ttu-id="26233-351">Bada implementację aparatu wyrażeń regularnych w programie .NET.</span><span class="sxs-lookup"><span data-stu-id="26233-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="26233-352">W tym temacie skupiono się na elastyczności wyrażeń regularnych i wyjaśniono odpowiedzialność deweloperów za zapewnienie wydajnych i niezawodnych operacji aparatu wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="26233-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="26233-353">Nawracanie</span><span class="sxs-lookup"><span data-stu-id="26233-353">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="26233-354">Informacje, co to jest wycofywanie i jak wpływa na wydajność wyrażeń regularnych oraz analiza elementów języka, które dostarczają alternatywy dla wycofywania.</span><span class="sxs-lookup"><span data-stu-id="26233-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="26233-355">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="26233-355">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="26233-356">Opisuje elementy języka wyrażeń regularnych w programie .NET i zawiera linki do szczegółowej dokumentacji dla każdego elementu języka.</span><span class="sxs-lookup"><span data-stu-id="26233-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
