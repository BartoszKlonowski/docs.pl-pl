---
title: "Śledzenie wsteczne w wyrażeniach regularnych"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
caps.latest.revision: "20"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 80661b24c35742b57a98b51fe055b0df05b34cad
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2017
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="cd10d-102">Śledzenie wsteczne w wyrażeniach regularnych</span><span class="sxs-lookup"><span data-stu-id="cd10d-102">Backtracking in Regular Expressions</span></span>
<span data-ttu-id="cd10d-103"><a name="top"></a>Śledzenie wsteczne występuje, gdy wzorzec wyrażenia regularnego zawiera opcjonalne [Kwantyfikatory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) lub [konstrukcje alternacyjne](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), i przywraca poprzedni zapisany stan, aby kontynuować aparat wyrażeń regularnych Wyszukiwanie w celu dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-103"><a name="top"></a> Backtracking occurs when a regular expression pattern contains optional [quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) or [alternation constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="cd10d-104">Wycofywanie stanowi podstawę dużych możliwości wyrażeń regularnych, ponieważ dzięki niemu wyrażenia oferują duże możliwości i są elastyczne, a także umożliwiają dopasowywanie bardzo złożonych wzorców.</span><span class="sxs-lookup"><span data-stu-id="cd10d-104">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="cd10d-105">Jednocześnie te możliwości są obciążone kosztami.</span><span class="sxs-lookup"><span data-stu-id="cd10d-105">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="cd10d-106">Wycofywanie często jest najważniejszym czynnikiem wpływającym na wydajność aparatu wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="cd10d-106">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="cd10d-107">Na szczęście deweloper ma kontrolę nad zachowaniem aparatu wyrażeń regularnych i sposobem użycia wycofywania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-107">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="cd10d-108">W tym temacie opisano zasadę działania wycofywania i możliwości sterowania nim.</span><span class="sxs-lookup"><span data-stu-id="cd10d-108">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cd10d-109">Ogólnie rzecz biorąc aparat niedeterministyczne skończoną Automaton DS, jak aparat wyrażenie regularne .NET umieszcza odpowiedzialność za obsługuje tworzenie wydajnych, szybkie regularne wyrażeń dewelopera.</span><span class="sxs-lookup"><span data-stu-id="cd10d-109">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  
  
 <span data-ttu-id="cd10d-110">Ten temat zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="cd10d-110">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="cd10d-111">Porównanie liniowej bez śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="cd10d-111">Linear Comparison Without Backtracking</span></span>](#linear_comparison_without_backtracking)  
  
-   [<span data-ttu-id="cd10d-112">Śledzenie wsteczne opcjonalne Kwantyfikatory lub Alternacyjne konstrukcji</span><span class="sxs-lookup"><span data-stu-id="cd10d-112">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>](#backtracking_with_optional_quantifiers_or_alternation_constructs)  
  
-   [<span data-ttu-id="cd10d-113">Śledzenie wsteczne z kwantyfikatorami zagnieżdżonymi opcjonalne</span><span class="sxs-lookup"><span data-stu-id="cd10d-113">Backtracking with Nested Optional Quantifiers</span></span>](#backtracking_with_nested_optional_quantifiers)  
  
-   [<span data-ttu-id="cd10d-114">Kontrolowanie śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="cd10d-114">Controlling Backtracking</span></span>](#controlling_backtracking)  
  
<a name="linear_comparison_without_backtracking"></a>   
## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="cd10d-115">Porównanie liniowe bez wycofywania</span><span class="sxs-lookup"><span data-stu-id="cd10d-115">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="cd10d-116">Jeśli wzorzec wyrażenia regularnego nie ma opcjonalnych kwantyfikatorów ani konstrukcji zmiany, aparat wyrażeń regularnych wykonuje go liniowo.</span><span class="sxs-lookup"><span data-stu-id="cd10d-116">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="cd10d-117">Oznacza to, że gdy aparat wyrażeń regularnych znajdzie pierwszy element języka ze wzorca w tekście w ciągu wejściowym, próbuje dopasować następny element języka ze wzorca do następnego znaku lub grupy znaków w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-117">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="cd10d-118">Ten proces jest kontynuowany do czasu, aż dopasowywanie zakończy się pomyślnie lub niepomyślnie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-118">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="cd10d-119">W każdym przypadku aparat wyrażeń regularnych przesuwa się w danej chwili o jeden znak do przodu w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-119">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="cd10d-120">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="cd10d-120">The following example provides an illustration.</span></span> <span data-ttu-id="cd10d-121">Wyrażenie regularne `e{2}\w\b` szuka dwa wystąpienia litery "e", po której następuje dowolny znak słowa następuje granic programu word.</span><span class="sxs-lookup"><span data-stu-id="cd10d-121">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="cd10d-122">Mimo że to wyrażenie regularne zawiera kwantyfikator `{2}`, wartość jest szacowana liniowo.</span><span class="sxs-lookup"><span data-stu-id="cd10d-122">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="cd10d-123">Aparat wyrażeń regularnych nie cofnąć, ponieważ `{2}` nie jest opcjonalny kwantyfikatora; określa dokładna liczba i nie zmienną liczbę razy, które poprzedniej Podwyrażenie muszą być zgodne.</span><span class="sxs-lookup"><span data-stu-id="cd10d-123">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="cd10d-124">W wyniku tego aparat wyrażeń regularnych próbuje dopasować wzorzec wyrażenia regularnego do ciągu wejściowego, tak jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="cd10d-124">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="cd10d-125">Operacja</span><span class="sxs-lookup"><span data-stu-id="cd10d-125">Operation</span></span>|<span data-ttu-id="cd10d-126">Pozycja we wzorcu</span><span class="sxs-lookup"><span data-stu-id="cd10d-126">Position in pattern</span></span>|<span data-ttu-id="cd10d-127">Pozycja w ciągu</span><span class="sxs-lookup"><span data-stu-id="cd10d-127">Position in string</span></span>|<span data-ttu-id="cd10d-128">Wynik</span><span class="sxs-lookup"><span data-stu-id="cd10d-128">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="cd10d-129">1</span><span class="sxs-lookup"><span data-stu-id="cd10d-129">1</span></span>|<span data-ttu-id="cd10d-130">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-130">e</span></span>|<span data-ttu-id="cd10d-131">„needing a reed” (indeks 0)</span><span class="sxs-lookup"><span data-stu-id="cd10d-131">"needing a reed" (index 0)</span></span>|<span data-ttu-id="cd10d-132">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-132">No match.</span></span>|  
|<span data-ttu-id="cd10d-133">2</span><span class="sxs-lookup"><span data-stu-id="cd10d-133">2</span></span>|<span data-ttu-id="cd10d-134">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-134">e</span></span>|<span data-ttu-id="cd10d-135">„eeding a reed” (indeks 1)</span><span class="sxs-lookup"><span data-stu-id="cd10d-135">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="cd10d-136">Możliwe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-136">Possible match.</span></span>|  
|<span data-ttu-id="cd10d-137">3</span><span class="sxs-lookup"><span data-stu-id="cd10d-137">3</span></span>|<span data-ttu-id="cd10d-138">e{2}</span><span class="sxs-lookup"><span data-stu-id="cd10d-138">e{2}</span></span>|<span data-ttu-id="cd10d-139">„eding a reed” (indeks 2)</span><span class="sxs-lookup"><span data-stu-id="cd10d-139">"eding a reed" (index 2)</span></span>|<span data-ttu-id="cd10d-140">Możliwe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-140">Possible match.</span></span>|  
|<span data-ttu-id="cd10d-141">4</span><span class="sxs-lookup"><span data-stu-id="cd10d-141">4</span></span>|<span data-ttu-id="cd10d-142">\w</span><span class="sxs-lookup"><span data-stu-id="cd10d-142">\w</span></span>|<span data-ttu-id="cd10d-143">„ding a reed” (indeks 3)</span><span class="sxs-lookup"><span data-stu-id="cd10d-143">"ding a reed" (index 3)</span></span>|<span data-ttu-id="cd10d-144">Możliwe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-144">Possible match.</span></span>|  
|<span data-ttu-id="cd10d-145">5</span><span class="sxs-lookup"><span data-stu-id="cd10d-145">5</span></span>|<span data-ttu-id="cd10d-146">\b</span><span class="sxs-lookup"><span data-stu-id="cd10d-146">\b</span></span>|<span data-ttu-id="cd10d-147">„ing a reed” (indeks 4)</span><span class="sxs-lookup"><span data-stu-id="cd10d-147">"ing a reed" (index 4)</span></span>|<span data-ttu-id="cd10d-148">Możliwe dopasowanie nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="cd10d-148">Possible match fails.</span></span>|  
|<span data-ttu-id="cd10d-149">6</span><span class="sxs-lookup"><span data-stu-id="cd10d-149">6</span></span>|<span data-ttu-id="cd10d-150">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-150">e</span></span>|<span data-ttu-id="cd10d-151">„eding a reed” (indeks 2)</span><span class="sxs-lookup"><span data-stu-id="cd10d-151">"eding a reed" (index 2)</span></span>|<span data-ttu-id="cd10d-152">Możliwe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-152">Possible match.</span></span>|  
|<span data-ttu-id="cd10d-153">7</span><span class="sxs-lookup"><span data-stu-id="cd10d-153">7</span></span>|<span data-ttu-id="cd10d-154">e{2}</span><span class="sxs-lookup"><span data-stu-id="cd10d-154">e{2}</span></span>|<span data-ttu-id="cd10d-155">„ding a reed” (indeks 3)</span><span class="sxs-lookup"><span data-stu-id="cd10d-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="cd10d-156">Możliwe dopasowanie nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="cd10d-156">Possible match fails.</span></span>|  
|<span data-ttu-id="cd10d-157">8</span><span class="sxs-lookup"><span data-stu-id="cd10d-157">8</span></span>|<span data-ttu-id="cd10d-158">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-158">e</span></span>|<span data-ttu-id="cd10d-159">„ding a reed” (indeks 3)</span><span class="sxs-lookup"><span data-stu-id="cd10d-159">"ding a reed" (index 3)</span></span>|<span data-ttu-id="cd10d-160">Dopasowanie nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="cd10d-160">Match fails.</span></span>|  
|<span data-ttu-id="cd10d-161">9</span><span class="sxs-lookup"><span data-stu-id="cd10d-161">9</span></span>|<span data-ttu-id="cd10d-162">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-162">e</span></span>|<span data-ttu-id="cd10d-163">„ing a reed” (indeks 4)</span><span class="sxs-lookup"><span data-stu-id="cd10d-163">"ing a reed" (index 4)</span></span>|<span data-ttu-id="cd10d-164">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-164">No match.</span></span>|  
|<span data-ttu-id="cd10d-165">10</span><span class="sxs-lookup"><span data-stu-id="cd10d-165">10</span></span>|<span data-ttu-id="cd10d-166">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-166">e</span></span>|<span data-ttu-id="cd10d-167">„ng a reed” (indeks 5)</span><span class="sxs-lookup"><span data-stu-id="cd10d-167">"ng a reed" (index 5)</span></span>|<span data-ttu-id="cd10d-168">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-168">No match.</span></span>|  
|<span data-ttu-id="cd10d-169">11</span><span class="sxs-lookup"><span data-stu-id="cd10d-169">11</span></span>|<span data-ttu-id="cd10d-170">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-170">e</span></span>|<span data-ttu-id="cd10d-171">„g a reed” (indeks 6)</span><span class="sxs-lookup"><span data-stu-id="cd10d-171">"g a reed" (index 6)</span></span>|<span data-ttu-id="cd10d-172">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-172">No match.</span></span>|  
|<span data-ttu-id="cd10d-173">12</span><span class="sxs-lookup"><span data-stu-id="cd10d-173">12</span></span>|<span data-ttu-id="cd10d-174">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-174">e</span></span>|<span data-ttu-id="cd10d-175">"reed" (indeks 7)</span><span class="sxs-lookup"><span data-stu-id="cd10d-175">" a reed" (index 7)</span></span>|<span data-ttu-id="cd10d-176">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-176">No match.</span></span>|  
|<span data-ttu-id="cd10d-177">13</span><span class="sxs-lookup"><span data-stu-id="cd10d-177">13</span></span>|<span data-ttu-id="cd10d-178">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-178">e</span></span>|<span data-ttu-id="cd10d-179">"reed" (indeks 8)</span><span class="sxs-lookup"><span data-stu-id="cd10d-179">"a reed" (index 8)</span></span>|<span data-ttu-id="cd10d-180">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-180">No match.</span></span>|  
|<span data-ttu-id="cd10d-181">14</span><span class="sxs-lookup"><span data-stu-id="cd10d-181">14</span></span>|<span data-ttu-id="cd10d-182">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-182">e</span></span>|<span data-ttu-id="cd10d-183">"reed" (indeks 9)</span><span class="sxs-lookup"><span data-stu-id="cd10d-183">" reed" (index 9)</span></span>|<span data-ttu-id="cd10d-184">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-184">No match.</span></span>|  
|<span data-ttu-id="cd10d-185">15</span><span class="sxs-lookup"><span data-stu-id="cd10d-185">15</span></span>|<span data-ttu-id="cd10d-186">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-186">e</span></span>|<span data-ttu-id="cd10d-187">"reed" (indeks 10)</span><span class="sxs-lookup"><span data-stu-id="cd10d-187">"reed" (index 10)</span></span>|<span data-ttu-id="cd10d-188">Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-188">No match</span></span>|  
|<span data-ttu-id="cd10d-189">16</span><span class="sxs-lookup"><span data-stu-id="cd10d-189">16</span></span>|<span data-ttu-id="cd10d-190">e</span><span class="sxs-lookup"><span data-stu-id="cd10d-190">e</span></span>|<span data-ttu-id="cd10d-191">„eed” (indeks 11)</span><span class="sxs-lookup"><span data-stu-id="cd10d-191">"eed" (index 11)</span></span>|<span data-ttu-id="cd10d-192">Możliwe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-192">Possible match.</span></span>|  
|<span data-ttu-id="cd10d-193">17</span><span class="sxs-lookup"><span data-stu-id="cd10d-193">17</span></span>|<span data-ttu-id="cd10d-194">e{2}</span><span class="sxs-lookup"><span data-stu-id="cd10d-194">e{2}</span></span>|<span data-ttu-id="cd10d-195">„ed” (indeks 12)</span><span class="sxs-lookup"><span data-stu-id="cd10d-195">"ed" (index 12)</span></span>|<span data-ttu-id="cd10d-196">Możliwe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-196">Possible match.</span></span>|  
|<span data-ttu-id="cd10d-197">18</span><span class="sxs-lookup"><span data-stu-id="cd10d-197">18</span></span>|<span data-ttu-id="cd10d-198">\w</span><span class="sxs-lookup"><span data-stu-id="cd10d-198">\w</span></span>|<span data-ttu-id="cd10d-199">„d” (indeks 13)</span><span class="sxs-lookup"><span data-stu-id="cd10d-199">"d" (index 13)</span></span>|<span data-ttu-id="cd10d-200">Możliwe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-200">Possible match.</span></span>|  
|<span data-ttu-id="cd10d-201">19</span><span class="sxs-lookup"><span data-stu-id="cd10d-201">19</span></span>|<span data-ttu-id="cd10d-202">\b</span><span class="sxs-lookup"><span data-stu-id="cd10d-202">\b</span></span>|<span data-ttu-id="cd10d-203">„” (indeks 14)</span><span class="sxs-lookup"><span data-stu-id="cd10d-203">"" (index 14)</span></span>|<span data-ttu-id="cd10d-204">Dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-204">Match.</span></span>|  
  
 <span data-ttu-id="cd10d-205">Jeśli wzorzec wyrażenia regularnego nie zawiera opcjonalnych kwantyfikatorów ani konstrukcji zmiany, maksymalna liczba porównań niezbędna do wykonania dopasowania wzorca wyrażenia regularnego do ciągu wejściowego jest w przybliżeniu równa liczbie znaków w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-205">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="cd10d-206">W tym przypadku aparat wyrażeń regularnych wykonuje 19 porównań w celu zidentyfikowania możliwych dopasowań w 13-znakowy ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-206">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="cd10d-207">Innymi słowy, aparat wyrażeń regularnych działa prawie liniowo, jeśli nie zawiera opcjonalnych kwantyfikatorów ani konstrukcji zmiany.</span><span class="sxs-lookup"><span data-stu-id="cd10d-207">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>  
  
 [<span data-ttu-id="cd10d-208">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="cd10d-208">Back to top</span></span>](#top)  
  
<a name="backtracking_with_optional_quantifiers_or_alternation_constructs"></a>   
## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="cd10d-209">Wycofywanie z użyciem opcjonalnych kwantyfikatorów lub konstrukcji zmiany</span><span class="sxs-lookup"><span data-stu-id="cd10d-209">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="cd10d-210">Gdy wyrażenie regularne zawiera opcjonalne kwantyfikatory lub konstrukcje zmiany, obliczenia wykonywane na ciągu wejściowym nie są już liniowe.</span><span class="sxs-lookup"><span data-stu-id="cd10d-210">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="cd10d-211">Dopasowywanie wzorca za pomocą aparatu NFA jest oparte na elementach języka w wyrażeniu regularnym, a nie na znakach, które mają zostać dopasowane w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-211">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="cd10d-212">Dlatego aparat wyrażeń regularnych próbuje w pełni dopasować opcjonalne lub alternatywne podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="cd10d-212">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="cd10d-213">Kiedy aparat wyrażeń regularnych przechodzi do następnego elementu języka w podwyrażeniu i wykonanie dopasowania nie jest możliwe, może porzucić część pomyślnie wykonanego dopasowania i powrócić do wcześniejszego zapisanego stanu dopasowywania wyrażenia regularnego jako całości w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-213">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="cd10d-214">Ten proces wracania do poprzednio zapisanego stanu w celu znalezienia dopasowania jest nazywany wycofywaniem.</span><span class="sxs-lookup"><span data-stu-id="cd10d-214">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="cd10d-215">Rozważmy na przykład wzorzec wyrażenia regularnego `.*(es)`, zgodnej znaków "es" i wszystkie znaki który przed nim.</span><span class="sxs-lookup"><span data-stu-id="cd10d-215">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="cd10d-216">W poniższym przykładzie pokazano, że jeśli ciągiem wejściowym jest ciąg „Essential services are provided by regular expressions.”, wzorzec dopasowuje cały ciąg aż do znaków „es” w wyrazie „expressions” włącznie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-216">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="cd10d-217">W tym celu aparat wyrażeń regularnych używa wycofywania, tak jak opisano poniżej:</span><span class="sxs-lookup"><span data-stu-id="cd10d-217">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
-   <span data-ttu-id="cd10d-218">Jest on zgodny `.*` (który dopasowuje zero, jeden lub więcej wystąpień dowolnego znaku) z cały ciąg wejściowy.</span><span class="sxs-lookup"><span data-stu-id="cd10d-218">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
-   <span data-ttu-id="cd10d-219">Podejmuje próbę dopasowania znaku „e” we wzorcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="cd10d-219">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="cd10d-220">Jednak ciąg wejściowy nie zawiera już znaków, z którymi można by wykonać porównanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-220">However, the input string has no remaining characters available to match.</span></span>  
  
-   <span data-ttu-id="cd10d-221">Aparat wycofuje się więc do ostatniego pomyślnego dopasowania (Essential services are provided by regular expressions) i podejmuje próbę dopasowania litery „e” do kropki na końcu zdania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-221">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="cd10d-222">Nie można utworzyć takiego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-222">The match fails.</span></span>  
  
-   <span data-ttu-id="cd10d-223">Aparat kontynuuje wycofywanie do poprzedniego pomyślnego dopasowania po jednym znaku, aż wykryje, że pasującym podciągiem jest „Essential services are provided by regular expr”.</span><span class="sxs-lookup"><span data-stu-id="cd10d-223">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="cd10d-224">Następnie porównuje znak „e” we wzorcu z drugą literą „e” w wyrazie „expressions” i znajduje dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-224">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
-   <span data-ttu-id="cd10d-225">Porównuje znak „s” we wzorcu z literą „s” występującą po dopasowanym znaku „e” (pierwsza litera „s” w wyrazie „expressions”).</span><span class="sxs-lookup"><span data-stu-id="cd10d-225">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="cd10d-226">Dopasowanie jest wykonywane pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-226">The match is successful.</span></span>  
  
 <span data-ttu-id="cd10d-227">Gdy jest używane wycofywanie, wykonanie dopasowania wzorca wyrażenia regularnego do ciągu wejściowego składającego się z 55 znaków wymaga wykonania 67 operacji porównania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-227">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="cd10d-228">Interesujące jest, że, jeśli jest to tzw, uwzględnione wzorzec wyrażenia regularnego. `*?(es)`, dopasowanie wyrażenia regularnego wymagają dodatkowych porównania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-228">Interestingly, if the regular expression pattern included a lazy quantifier, .`*?(es)`, matching the regular expression would require additional comparisons.</span></span> <span data-ttu-id="cd10d-229">W tym przypadku, zamiast wykonywać wycofywanie od końca ciągu do znaku „r” w wyrazie „expressions”, aparat wyrażeń regularnych musiałby wykonać wycofywanie do początku ciągu, aby wykonać dopasowanie znaków „Es”, i wymagałoby to 113 porównań.</span><span class="sxs-lookup"><span data-stu-id="cd10d-229">In this case, instead of having to backtrack from the end of the string to the "r" in "expressions", the regular expression engine would have to backtrack all the way to the beginning of the string to match "Es" and would require 113 comparisons.</span></span> <span data-ttu-id="cd10d-230">Ogólnie, jeśli wzorzec wyrażenia regularnego zawiera jedną konstrukcję zmiany lub jeden opcjonalny kwantyfikator, liczba operacji porównania wymaganych do wykonania dopasowania wzorca jest ponad dwa razy większa niż liczba znaków w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-230">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>  
  
 [<span data-ttu-id="cd10d-231">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="cd10d-231">Back to top</span></span>](#top)  
  
<a name="backtracking_with_nested_optional_quantifiers"></a>   
## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="cd10d-232">Wycofywanie z użyciem zagnieżdżonych opcjonalnych kwantyfikatorów</span><span class="sxs-lookup"><span data-stu-id="cd10d-232">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="cd10d-233">Liczba operacji porównania wymaganych do wykonania dopasowania wzorca wyrażenia regularnego rośnie wykładniczo, gdy wzorzec zawiera dużą liczbę konstrukcji zmiany, jeśli zawiera zagnieżdżone konstrukcje zmiany lub, co występuje najczęściej, zawiera zagnieżdżone kwantyfikatory opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="cd10d-233">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="cd10d-234">Na przykład wzorzec wyrażenia regularnego `^(a+)+$` służy do dopasowania pełny ciąg, który zawiera co najmniej jeden "" znak.</span><span class="sxs-lookup"><span data-stu-id="cd10d-234">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="cd10d-235">W przykładzie podano dwa ciągi wejściowe o identycznej długości, ale tylko pierwszy ciąg pasuje do wzorca.</span><span class="sxs-lookup"><span data-stu-id="cd10d-235">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="cd10d-236"><xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> Klasa jest używana do określenia, jak długo trwa operacja dopasowania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-236">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="cd10d-237">Jak wynika z danych wyjściowych z przykładu, aparat wyrażeń regularnych potrzebuje prawie dwa razy więcej czasu na ustalenie, że ciąg wejściowy nie pasuje do wzorca, niż na zidentyfikowanie pasującego ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-237">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="cd10d-238">Jest to spowodowane tym, że niepowodzenie tworzenia dopasowania zawsze jest scenariuszem najgorszego przypadku.</span><span class="sxs-lookup"><span data-stu-id="cd10d-238">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="cd10d-239">Aparat wyrażeń regularnych musi użyć wyrażenia regularnego, aby sprawdzić wszystkie możliwe ścieżki w danych, zanim będzie mógł uznać, że nie można wykonać dopasowania, a zagnieżdżone nawiasy powodują powstanie wielu dodatkowych ścieżek w danych.</span><span class="sxs-lookup"><span data-stu-id="cd10d-239">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="cd10d-240">Aparat wyrażeń regularnych dochodzi do wniosku, że drugi ciąg nie pasuje do wzorca, wykonując następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="cd10d-240">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
-   <span data-ttu-id="cd10d-241">Sprawdza, czy znajdowała się na początku ciąg, a następnie dopasowań pierwsze pięć znaków w ciągu przy użyciu wzorca `a+`.</span><span class="sxs-lookup"><span data-stu-id="cd10d-241">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="cd10d-242">Następnie ustala, że w ciągu nie znajdują się dodatkowe grupy liter „a”.</span><span class="sxs-lookup"><span data-stu-id="cd10d-242">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="cd10d-243">Na końcu sprawdza, czy znajduje się na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-243">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="cd10d-244">W ciągu pozostał jeden dodatkowy znak, więc wykonywanie dopasowania kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="cd10d-244">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="cd10d-245">To nieudane dopasowanie wymaga wykonania 9 porównań.</span><span class="sxs-lookup"><span data-stu-id="cd10d-245">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="cd10d-246">Aparat wyrażeń regularnych zapisuje też informacje o stanie swoich dopasowań znaku „a” (dopasowanie 1), znaków „aa” (dopasowanie 2), znaków „aaa” (dopasowanie 3) i znaków „aaaa” (dopasowanie 4).</span><span class="sxs-lookup"><span data-stu-id="cd10d-246">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
-   <span data-ttu-id="cd10d-247">Aparat powraca do uprzednio zapisanego dopasowania 4.</span><span class="sxs-lookup"><span data-stu-id="cd10d-247">It returns to the previously saved match 4.</span></span> <span data-ttu-id="cd10d-248">Ustala, że istnieje jeden dodatkowy znak „a”, który można przypisać do dodatkowej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="cd10d-248">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="cd10d-249">Na końcu sprawdza, czy znajduje się na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-249">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="cd10d-250">W ciągu pozostał jeden dodatkowy znak, więc wykonywanie dopasowania kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="cd10d-250">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="cd10d-251">Ta błędnego dopasowania wymaga 4 porównania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-251">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="cd10d-252">Do tego momentu zostało wykonanych 13 porównań.</span><span class="sxs-lookup"><span data-stu-id="cd10d-252">So far, a total of 13 comparisons have been performed.</span></span>  
  
-   <span data-ttu-id="cd10d-253">Zwraca do poprzednio zapisanych dopasowania 3.</span><span class="sxs-lookup"><span data-stu-id="cd10d-253">It returns to the previously saved match 3.</span></span> <span data-ttu-id="cd10d-254">Ustala, że istnieją dwa dodatkowe znaki „a”, które można przypisać do dodatkowej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="cd10d-254">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="cd10d-255">Jednak test końca ciągu kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="cd10d-255">However, the end-of-string test fails.</span></span> <span data-ttu-id="cd10d-256">Następnie aparat wraca do dopasowania 3 i próbuje dopasować dwa dodatkowe znaki „a” w dwóch dodatkowych przechwyconych grupach.</span><span class="sxs-lookup"><span data-stu-id="cd10d-256">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="cd10d-257">Test końca ciągu nadal kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="cd10d-257">The end-of-string test still fails.</span></span> <span data-ttu-id="cd10d-258">Te nieudane dopasowania wymagały wykonania 12 porównań.</span><span class="sxs-lookup"><span data-stu-id="cd10d-258">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="cd10d-259">Do tej pory łącznie 25 porównania mogły zostać wykonane.</span><span class="sxs-lookup"><span data-stu-id="cd10d-259">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="cd10d-260">Porównywanie ciągu wejściowego z wyrażeniem regularnym w ten sposób będzie kontynuowane, dopóki aparat wyrażeń regularnych nie wypróbuje wszystkich możliwych kombinacji dopasowań, a następnie uzna, że nie istnieje dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-260">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="cd10d-261">Z powodu kwantyfikatorami zagnieżdżonymi, to porównanie jest O (2<sup>n</sup>) lub wykładniczej operacji, gdy  *n*  jest liczba znaków w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-261">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="cd10d-262">Oznacza to, że w najgorszym przypadku ciąg wejściowy o długości 30 znaków będzie wymagał wykonania ok. 1 073 741 824 porównań, a ciąg wejściowy o długości 40 znaków będzie wymagał wykonania ok. 1 099 511 627 776 porównań.</span><span class="sxs-lookup"><span data-stu-id="cd10d-262">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="cd10d-263">Gdy są używane ciągi o takiej lub większej długości, wykonanie metod opartych na wyrażeniach regularnych może trwać niezwykle długo, jeśli w przetwarzanych ciągach nie będą znajdować się dopasowania do wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="cd10d-263">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>  
  
 [<span data-ttu-id="cd10d-264">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="cd10d-264">Back to top</span></span>](#top)  
  
<a name="controlling_backtracking"></a>   
## <a name="controlling-backtracking"></a><span data-ttu-id="cd10d-265">Sterowanie wycofywaniem</span><span class="sxs-lookup"><span data-stu-id="cd10d-265">Controlling Backtracking</span></span>  
 <span data-ttu-id="cd10d-266">Wycofywanie umożliwia tworzenie zaawansowanych, elastycznych wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="cd10d-266">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="cd10d-267">Jednak, tak jak pokazano w poprzedniej sekcji, ich zalety może przesłonić nieakceptowalnie niska wydajność.</span><span class="sxs-lookup"><span data-stu-id="cd10d-267">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="cd10d-268">Aby zapobiec nadmiernym wykorzystaniem algorytmu wycofywania, należy zdefiniować interwał limitu czasu, kiedy można utworzyć wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu lub wywołanie metody dopasowania statyczne wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="cd10d-268">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="cd10d-269">Ta czynność została omówiona w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="cd10d-269">This is discussed in the next section.</span></span> <span data-ttu-id="cd10d-270">Ponadto .NET obsługuje trzy elementy języka wyrażeń regularnych ograniczyć albo pominąć śledzenie wsteczne oraz obsługują złożonych wyrażeń regularnych z żadnych spadek wydajności: [nonbacktracking użyto](#Nonbacktracking), [potwierdzenia wybieganie wstecz](#Lookbehind), i [potwierdzenia wyprzedzenia](#Lookahead).</span><span class="sxs-lookup"><span data-stu-id="cd10d-270">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [nonbacktracking subexpressions](#Nonbacktracking), [lookbehind assertions](#Lookbehind), and [lookahead assertions](#Lookahead).</span></span> <span data-ttu-id="cd10d-271">Aby uzyskać więcej informacji o każdym elemencie języka, zobacz [konstrukcji grupowania](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="cd10d-271">For more information about each language element, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
<a name="Timeout"></a>   
### <a name="defining-a-time-out-interval"></a><span data-ttu-id="cd10d-272">Definiowanie interwału limitu czasu</span><span class="sxs-lookup"><span data-stu-id="cd10d-272">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="cd10d-273">Począwszy od [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], można ustawić wartość limitu czasu, która reprezentuje najdłuższym interwał aparat wyrażeń regularnych wyszuka jedną pasującą przed odstępuje próba i zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="cd10d-273">Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="cd10d-274">Określ interwał limitu czasu podając <xref:System.TimeSpan> do wartości <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor wyrażeń regularnych wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="cd10d-274">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor for instance regular expressions.</span></span> <span data-ttu-id="cd10d-275">Ponadto każdego statycznego wzorzec dopasowany metoda ma przeciążenia z <xref:System.TimeSpan> parametr, który służy do określenia wartości limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-275">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="cd10d-276">Domyślnie interwał limitu czasu jest ustawiony na <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> i aparat wyrażeń regularnych nie upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-276">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cd10d-277">Zalecane jest, aby zawsze ustawić interwał limitu czasu, jeśli w wyrażeniu regularnym jest stosowane wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-277">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="cd10d-278">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek wskazuje, czy aparat wyrażeń regularnych nie może odnaleźć dopasowania w ramach w określony limit czasu, ale nie wskazywać, dlaczego został zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="cd10d-278">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="cd10d-279">Przyczyną może być nadmierne wycofywanie, ale możliwe jest też, że ustawiono zbyt krótki interwał limitu czasu w stosunku do obciążenia systemu w chwili zgłoszenia wyjątku.</span><span class="sxs-lookup"><span data-stu-id="cd10d-279">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="cd10d-280">Podczas obsługi tego wyjątku można określić, że nie mają być wykonywane kolejne porównania z ciągiem wejściowym, albo zwiększyć interwał limitu czasu i ponowić próbę wykonania operacji dopasowywania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-280">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="cd10d-281">Na przykład poniższy kod wywołania <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu o wartość limitu czasu w ciągu sekundy.</span><span class="sxs-lookup"><span data-stu-id="cd10d-281">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="cd10d-282">Wzorzec wyrażenia regularnego `(a+)+$`, podlega zgodnej z co najmniej jeden sekwencji co najmniej jeden "" znak na końcu wiersza, nadmiernym wykorzystaniem algorytmu wycofywania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-282">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="cd10d-283">Jeśli <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> jest generowany, przykładzie zwiększa wartość limitu czasu maksymalnie trzy sekundy maksymalny interwał.</span><span class="sxs-lookup"><span data-stu-id="cd10d-283">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="cd10d-284">Po upływie tego czasu nie będą już podejmowane próby dopasowania wzorca.</span><span class="sxs-lookup"><span data-stu-id="cd10d-284">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
<a name="Nonbacktracking"></a>   
### <a name="nonbacktracking-subexpression"></a><span data-ttu-id="cd10d-285">Podwyrażenie bez wycofywania</span><span class="sxs-lookup"><span data-stu-id="cd10d-285">Nonbacktracking Subexpression</span></span>  
 <span data-ttu-id="cd10d-286">`(?>` *Podwyrażenie* `)` element języka pomija śledzenie wsteczne w podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="cd10d-286">The `(?>` *subexpression*`)` language element suppresses backtracking in a subexpression.</span></span> <span data-ttu-id="cd10d-287">Jest to użyteczne w rozwiązywaniu problemów z wydajnością związanych z nieudanymi dopasowaniami.</span><span class="sxs-lookup"><span data-stu-id="cd10d-287">It is useful for preventing the performance problems associated with failed matches.</span></span>  
  
 <span data-ttu-id="cd10d-288">W poniższym przykładzie pokazano, w jaki sposób pomijanie wycofywania zwiększa wydajność w sytuacji, gdy są używane kwantyfikatory zagnieżdżone.</span><span class="sxs-lookup"><span data-stu-id="cd10d-288">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="cd10d-289">Mierzony jest czas potrzebny aparatowi wyrażeń regularnych na ustalenie, że ciąg wejściowy nie pasuje do dwóch wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="cd10d-289">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="cd10d-290">W pierwszym wyrażeniu regularnym jest używane wycofywanie w celu podjęcia próby dopasowania ciągu zawierającego co najmniej jedno wystąpienie co najmniej jednej cyfry szesnastkowej, po której następuje dwukropek, po którym następuje co najmniej jedna cyfra szesnastkowa, po której następują dwa dwukropki.</span><span class="sxs-lookup"><span data-stu-id="cd10d-290">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="cd10d-291">Drugie wyrażenie regularne jest takie samo jak pierwsze, aby wyłączono w nim wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="cd10d-291">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="cd10d-292">Jak widać w wynikach przykładu, wyłączenie wycofywania przynosi znaczącą poprawę wydajności.</span><span class="sxs-lookup"><span data-stu-id="cd10d-292">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  
  
<a name="Lookbehind"></a>   
### <a name="lookbehind-assertions"></a><span data-ttu-id="cd10d-293">Asercje wsteczne</span><span class="sxs-lookup"><span data-stu-id="cd10d-293">Lookbehind Assertions</span></span>  
 <span data-ttu-id="cd10d-294">.NET zawiera dwa elementy języka, `(?<=` *Podwyrażenie* `)` i `(?<!` *Podwyrażenie*`)`, spełniających poprzedni znak lub znaków w parametrach wejściowych.</span><span class="sxs-lookup"><span data-stu-id="cd10d-294">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="cd10d-295">Oba elementy języka są asercje o zerowej szerokości; oznacza to, określają, czy znak lub znaków, które bezpośrednio poprzedzać bieżący znak można dopasować przez *Podwyrażenie*, bez przesuwania lub śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="cd10d-295">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="cd10d-296">`(?<=`*Podwyrażenie* `)` jest dodatnie wybieganie wstecz asercja; oznacza to znak lub znaki, przed bieżącą pozycję musi być zgodna *Podwyrażenie*.</span><span class="sxs-lookup"><span data-stu-id="cd10d-296">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="cd10d-297">`(?<!`*Podwyrażenie* `)` jest ujemne wybieganie wstecz asercja; oznacza to znak lub znaki przed bieżącą pozycję nie musi odpowiadać *Podwyrażenie*.</span><span class="sxs-lookup"><span data-stu-id="cd10d-297">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="cd10d-298">Zarówno potwierdzenia dodatnie i ujemne wybieganie wstecz są najbardziej przydatne, gdy *Podwyrażenie* jest podzbiorem poprzedniego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="cd10d-298">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="cd10d-299">W poniższym przykładzie są używane dwa równoważne wzorce wyrażenia regularnego sprawdzające nazwę użytkownika w adresie e-mail.</span><span class="sxs-lookup"><span data-stu-id="cd10d-299">The following example uses two equivalent regular expression patterns that validate the user name in an e-mail address.</span></span> <span data-ttu-id="cd10d-300">Pierwszy wzorzec działa z niską wydajnością z powodu nadmiernego wycofywania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-300">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="cd10d-301">Drugi wzorzec modyfikuje pierwsze wyrażenie regularne, zastępując zagnieżdżony kwantyfikator pozytywną asercją wsteczną.</span><span class="sxs-lookup"><span data-stu-id="cd10d-301">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="cd10d-302">Dane wyjściowe z przykładu przedstawia czas wykonywania <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="cd10d-302">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="cd10d-303">Pierwszy wzorzec wyrażenia regularnego, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="cd10d-303">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="cd10d-304">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="cd10d-304">Pattern</span></span>|<span data-ttu-id="cd10d-305">Opis</span><span class="sxs-lookup"><span data-stu-id="cd10d-305">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="cd10d-306">Rozpoczyna dopasowywanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-306">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="cd10d-307">Dopasowuje znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="cd10d-307">Match an alphanumeric character.</span></span> <span data-ttu-id="cd10d-308">To porównanie nie uwzględnia wielkości liter, ponieważ <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metoda jest wywoływana z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="cd10d-308">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="cd10d-309">Dopasowuje zero, jedno lub większą liczbę wystąpień łącznika, kropki lub znaku słowa.</span><span class="sxs-lookup"><span data-stu-id="cd10d-309">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="cd10d-310">Dopasowuje znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="cd10d-310">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="cd10d-311">Dopasowuje zero lub większą liczbę wystąpień kombinacji składających się z zera lub większej liczby łączników, kropek lub znaków słowa, po których występuje znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="cd10d-311">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="cd10d-312">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-312">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="cd10d-313">Dopasowuje znak („@”).</span><span class="sxs-lookup"><span data-stu-id="cd10d-313">Match an at sign ("@").</span></span>|  
  
 <span data-ttu-id="cd10d-314">Drugi wzorzec wyrażenia regularnego, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, używa potwierdzenia dodatnie wybieganie wstecz.</span><span class="sxs-lookup"><span data-stu-id="cd10d-314">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="cd10d-315">Definicję tego wyrażenia pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="cd10d-315">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="cd10d-316">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="cd10d-316">Pattern</span></span>|<span data-ttu-id="cd10d-317">Opis</span><span class="sxs-lookup"><span data-stu-id="cd10d-317">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="cd10d-318">Rozpoczyna dopasowywanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-318">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="cd10d-319">Dopasowuje znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="cd10d-319">Match an alphanumeric character.</span></span> <span data-ttu-id="cd10d-320">To porównanie nie uwzględnia wielkości liter, ponieważ <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metoda jest wywoływana z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="cd10d-320">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="cd10d-321">Dopasowuje zero lub większą liczbę wystąpień łącznika, kropki lub znaku słowa.</span><span class="sxs-lookup"><span data-stu-id="cd10d-321">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="cd10d-322">Sprawdza ostatni dopasowany znak i kontynuuje dopasowywanie, jeśli jest to znak alfanumeryczny.</span><span class="sxs-lookup"><span data-stu-id="cd10d-322">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="cd10d-323">Należy zauważyć, że znaki alfanumeryczne stanowią podzestaw zestawu składającego się z kropek, łączników i wszystkich znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="cd10d-323">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="cd10d-324">Dopasowuje znak („@”).</span><span class="sxs-lookup"><span data-stu-id="cd10d-324">Match an at sign ("@").</span></span>|  
  
<a name="Lookahead"></a>   
### <a name="lookahead-assertions"></a><span data-ttu-id="cd10d-325">Asercje wyprzedzające</span><span class="sxs-lookup"><span data-stu-id="cd10d-325">Lookahead Assertions</span></span>  
 <span data-ttu-id="cd10d-326">.NET zawiera dwa elementy języka, `(?=` *Podwyrażenie* `)` i `(?!` *Podwyrażenie*`)`, spełniających następnej znak lub znaków Ciąg wejściowy.</span><span class="sxs-lookup"><span data-stu-id="cd10d-326">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="cd10d-327">Oba elementy języka są asercje o zerowej szerokości; oznacza to, określają, czy znak lub znaków, które bezpośrednio po bieżący znak można dopasować przez *Podwyrażenie*, bez przesuwania lub śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="cd10d-327">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="cd10d-328">`(?=`*Podwyrażenie* `)` jest potwierdzenie dodatnią wyprzedzenia; oznacza to znak lub znaki po bieżącej pozycji musi być zgodna *Podwyrażenie*.</span><span class="sxs-lookup"><span data-stu-id="cd10d-328">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="cd10d-329">`(?!`*Podwyrażenie* `)` jest potwierdzenie ujemna wyprzedzenia; oznacza to znak lub znaki po bieżącej pozycji nie może być dopasowana *Podwyrażenie*.</span><span class="sxs-lookup"><span data-stu-id="cd10d-329">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="cd10d-330">Zarówno potwierdzenia wyprzedzenia dodatnie i ujemne są najbardziej przydatne, gdy *Podwyrażenie* jest podzbiorem Podwyrażenie dalej.</span><span class="sxs-lookup"><span data-stu-id="cd10d-330">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="cd10d-331">W poniższym przykładzie są używane dwa równoważne wzorce wyrażenia regularnego sprawdzające w pełni kwalifikowaną nazwę typu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-331">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="cd10d-332">Pierwszy wzorzec działa z niską wydajnością z powodu nadmiernego wycofywania.</span><span class="sxs-lookup"><span data-stu-id="cd10d-332">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="cd10d-333">Drugi wzorzec modyfikuje pierwsze wyrażenie regularne, zastępując zagnieżdżony kwantyfikator pozytywną asercją wyprzedzającą.</span><span class="sxs-lookup"><span data-stu-id="cd10d-333">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="cd10d-334">Dane wyjściowe z przykładu przedstawia czas wykonywania <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="cd10d-334">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="cd10d-335">Pierwszy wzorzec wyrażenia regularnego, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="cd10d-335">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="cd10d-336">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="cd10d-336">Pattern</span></span>|<span data-ttu-id="cd10d-337">Opis</span><span class="sxs-lookup"><span data-stu-id="cd10d-337">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="cd10d-338">Rozpoczyna dopasowywanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-338">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="cd10d-339">Dopasowuje znak alfanumeryczny (A–Z), po którym co najmniej raz występuje zero lub większa liczba znaków słowa, po których następuje kropka.</span><span class="sxs-lookup"><span data-stu-id="cd10d-339">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="cd10d-340">To porównanie nie uwzględnia wielkości liter, ponieważ <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metoda jest wywoływana z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="cd10d-340">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="cd10d-341">Dopasowuje poprzedni wzorzec zero lub większą liczbę razy.</span><span class="sxs-lookup"><span data-stu-id="cd10d-341">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="cd10d-342">Dopasowuje znak alfabetyczny, po którym występuje zero lub większa liczba znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="cd10d-342">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="cd10d-343">Dopasowywanie kończy się na końcu ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="cd10d-343">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="cd10d-344">Drugi wzorzec wyrażenia regularnego, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, używa potwierdzenia dodatnią wyprzedzenia.</span><span class="sxs-lookup"><span data-stu-id="cd10d-344">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="cd10d-345">Definicję tego wyrażenia pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="cd10d-345">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="cd10d-346">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="cd10d-346">Pattern</span></span>|<span data-ttu-id="cd10d-347">Opis</span><span class="sxs-lookup"><span data-stu-id="cd10d-347">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="cd10d-348">Rozpoczyna dopasowywanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="cd10d-348">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="cd10d-349">Sprawdza pierwszy następny znak i kontynuuje dopasowywanie, jeśli jest to znak alfabetyczny (A–Z).</span><span class="sxs-lookup"><span data-stu-id="cd10d-349">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="cd10d-350">To porównanie nie uwzględnia wielkości liter, ponieważ <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metoda jest wywoływana z <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="cd10d-350">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="cd10d-351">Dopasowuje co najmniej jeden znak słowa, po którym następuje kropka.</span><span class="sxs-lookup"><span data-stu-id="cd10d-351">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="cd10d-352">Dopasowuje wzorzec składający się z co najmniej jednego znaku słowa, po którym zero lub większą liczbę razy występuje kropka.</span><span class="sxs-lookup"><span data-stu-id="cd10d-352">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="cd10d-353">Początkowy znak słowa musi być znakiem alfabetycznym.</span><span class="sxs-lookup"><span data-stu-id="cd10d-353">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="cd10d-354">Dopasowuje znak alfabetyczny, po którym występuje zero lub większa liczba znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="cd10d-354">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="cd10d-355">Dopasowywanie kończy się na końcu ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="cd10d-355">End the match at the end of the input string.</span></span>|  
  
 [<span data-ttu-id="cd10d-356">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="cd10d-356">Back to top</span></span>](#top)  
  
## <a name="see-also"></a><span data-ttu-id="cd10d-357">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="cd10d-357">See Also</span></span>  
 [<span data-ttu-id="cd10d-358">Wyrażeń regularnych programu .NET</span><span class="sxs-lookup"><span data-stu-id="cd10d-358">.NET Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)  
 [<span data-ttu-id="cd10d-359">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="cd10d-359">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="cd10d-360">Kwantyfikatory</span><span class="sxs-lookup"><span data-stu-id="cd10d-360">Quantifiers</span></span>](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)  
 [<span data-ttu-id="cd10d-361">Konstrukcje alternacyjne</span><span class="sxs-lookup"><span data-stu-id="cd10d-361">Alternation Constructs</span></span>](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)  
 [<span data-ttu-id="cd10d-362">Konstrukcje grupujące</span><span class="sxs-lookup"><span data-stu-id="cd10d-362">Grouping Constructs</span></span>](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
