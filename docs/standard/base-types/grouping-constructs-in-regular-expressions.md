---
title: Konstrukcje grupujące w wyrażeniach regularnych
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
ms.openlocfilehash: 5b2ea110837d9d5b905f97ab706af52a594f1c43
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "78159224"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="8b935-102">Konstrukcje grupujące w wyrażeniach regularnych</span><span class="sxs-lookup"><span data-stu-id="8b935-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="8b935-103">Grupowanie konstrukcji nakreślić podwyrażenia wyrażenia regularnego i przechwycić podciągi ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="8b935-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="8b935-104">Można użyć konstrukcji grupowania, aby wykonać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="8b935-104">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="8b935-105">Dopasuj wyrażenie podrzędne, które jest powtarzane w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8b935-105">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="8b935-106">Zastosuj kwantyfikator do wyrażenia podrzędnego, który ma wiele elementów języka wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="8b935-107">Aby uzyskać więcej informacji na temat kwantyfikatorów, zobacz [Kwantyfikatory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="8b935-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="8b935-108">Dołącz wyrażenie podrzędne w ciągu, <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> który <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> jest zwracany przez i metody.</span><span class="sxs-lookup"><span data-stu-id="8b935-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="8b935-109">Pobierz poszczególne wyrażenia <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> podrzędne z właściwości i przetwórz je oddzielnie od dopasowanego tekstu jako całości.</span><span class="sxs-lookup"><span data-stu-id="8b935-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="8b935-110">W poniższej tabeli wymieniono konstrukcje grupowania obsługiwane przez aparat wyrażeń regularnych .NET i wskazuje, czy są przechwytywane lub nie przechwytywanie.</span><span class="sxs-lookup"><span data-stu-id="8b935-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="8b935-111">Konstrukcja grupująca</span><span class="sxs-lookup"><span data-stu-id="8b935-111">Grouping construct</span></span>|<span data-ttu-id="8b935-112">Przechwytywanie lub nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="8b935-113">Dopasowane wyrażenia podrzędne</span><span class="sxs-lookup"><span data-stu-id="8b935-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="8b935-114">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-114">Capturing</span></span>|  
|[<span data-ttu-id="8b935-115">Nazwane dopasowane wyrażenia podrzędne</span><span class="sxs-lookup"><span data-stu-id="8b935-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="8b935-116">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-116">Capturing</span></span>|  
|[<span data-ttu-id="8b935-117">Definicje grup bilansowania</span><span class="sxs-lookup"><span data-stu-id="8b935-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="8b935-118">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-118">Capturing</span></span>|  
|[<span data-ttu-id="8b935-119">Grupy nieprzechwytujące</span><span class="sxs-lookup"><span data-stu-id="8b935-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="8b935-120">Nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-120">Noncapturing</span></span>|  
|[<span data-ttu-id="8b935-121">Opcje grupy</span><span class="sxs-lookup"><span data-stu-id="8b935-121">Group options</span></span>](#group_options)|<span data-ttu-id="8b935-122">Nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-122">Noncapturing</span></span>|  
|[<span data-ttu-id="8b935-123">Dodatnie potwierdzenia wyjmowania o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="8b935-124">Nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-124">Noncapturing</span></span>|  
|[<span data-ttu-id="8b935-125">Negatywne potwierdzenia wyglądu o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="8b935-126">Nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-126">Noncapturing</span></span>|  
|[<span data-ttu-id="8b935-127">Potwierdzenia dodatnie o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="8b935-128">Nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-128">Noncapturing</span></span>|  
|[<span data-ttu-id="8b935-129">Negatywne twierdzenia o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="8b935-130">Nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-130">Noncapturing</span></span>|  
|[<span data-ttu-id="8b935-131">Grupy atomowe</span><span class="sxs-lookup"><span data-stu-id="8b935-131">Atomic groups</span></span>](#atomic_groups)|<span data-ttu-id="8b935-132">Nieprzechwytywanie</span><span class="sxs-lookup"><span data-stu-id="8b935-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="8b935-133">Aby uzyskać informacje na temat grup i modelu obiektów wyrażenia regularnego, zobacz [Grupowanie konstrukcji i obiektów wyrażenia regularnego](#Objects).</span><span class="sxs-lookup"><span data-stu-id="8b935-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>
## <a name="matched-subexpressions"></a><span data-ttu-id="8b935-134">Dopasowane podwyrażenie</span><span class="sxs-lookup"><span data-stu-id="8b935-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="8b935-135">Następująca konstrukcja grupowania przechwytuje dopasowane wyrażenie podrzędne:</span><span class="sxs-lookup"><span data-stu-id="8b935-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="8b935-136">`(`*wyrażenie podrzędne*`)`</span><span class="sxs-lookup"><span data-stu-id="8b935-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="8b935-137">gdzie *wyrażenie podrzędne* jest prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="8b935-138">Przechwytywanie, które używają nawiasów są numerowane automatycznie od lewej do prawej na podstawie kolejności nawiasów otwarcia w wyrażeniu regularnym, począwszy od jednego.</span><span class="sxs-lookup"><span data-stu-id="8b935-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="8b935-139">Przechwytywanie, które jest ponumerowane zero jest tekstem dopasowanym do całego wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8b935-140">Domyślnie `(`element języka *wyrażenia podrzędnego* `)` przechwytuje dopasowane wyrażenie podrzędne.</span><span class="sxs-lookup"><span data-stu-id="8b935-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="8b935-141">Jeśli jednak <xref:System.Text.RegularExpressions.RegexOptions> parametr metody dopasowywania <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> wzorców wyrażenia `n` regularnego zawiera flagę lub jeśli opcja jest stosowana do tego wyrażenia podrzędnego (zobacz [Opcje grupy](#group_options) w dalszej części tego tematu), dopasowane wyrażenie podrzędne nie jest przechwytywane.</span><span class="sxs-lookup"><span data-stu-id="8b935-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="8b935-142">Dostęp do przechwyconych grup można uzyskać na cztery sposoby:</span><span class="sxs-lookup"><span data-stu-id="8b935-142">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="8b935-143">Za pomocą backreference konstrukcji w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="8b935-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="8b935-144">Dopasowane wyrażenie podrzędne odwołuje się w tym samym `\`wyrażeniu regularnym przy użyciu *liczby*składni , gdzie *liczba* jest liczbą porządkną przechwyconego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="8b935-145">Za pomocą konstrukcji o nazwie backreference w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="8b935-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="8b935-146">Dopasowane podwyrażenie odwołuje się w tym samym wyrażeniu regularnym przy użyciu `\k<` *nazwy*`>`składni `\k<`, gdzie *nazwa* jest nazwą grupy przechwytywania lub *liczbą*`>`, gdzie *liczba* jest liczbą porządkową grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="8b935-147">Grupa przechwytywania ma domyślną nazwę, która jest identyczna z jej liczbą liczbą liczbową.</span><span class="sxs-lookup"><span data-stu-id="8b935-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="8b935-148">Aby uzyskać więcej informacji, zobacz [Nazwane dopasowane wyrażenia podrzędne](#named_matched_subexpression) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="8b935-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="8b935-149">Za pomocą `$`sekwencji zastępowania <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> *numerów* w wywołaniu lub metody, gdzie *numer* jest liczbą porządkową przechwyconego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="8b935-150">Programowo przy użyciu <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="8b935-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8b935-151">Element członkowski w pozycji zero w kolekcji reprezentuje całą dopasowanie wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="8b935-152">Każdy kolejny element członkowski reprezentuje dopasowane wyrażenie podrzędne.</span><span class="sxs-lookup"><span data-stu-id="8b935-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="8b935-153">Aby uzyskać więcej informacji, zobacz [Grouping Konstrukcje i obiekty wyrażenia regularnego](#Objects) sekcji.</span><span class="sxs-lookup"><span data-stu-id="8b935-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="8b935-154">W poniższym przykładzie przedstawiono wyrażenie regularne, które identyfikuje zduplikowane wyrazy w tekście.</span><span class="sxs-lookup"><span data-stu-id="8b935-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="8b935-155">Dwie grupy przechwytywania wyrażenia regularnego reprezentują dwa wystąpienia zduplikowanego wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="8b935-156">Drugie wystąpienie jest przechwytywane w celu raportowania jego pozycji wyjściowej w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8b935-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="8b935-157">Wzorzec wyrażenia regularnego jest następujący:</span><span class="sxs-lookup"><span data-stu-id="8b935-157">The regular expression pattern is the following:</span></span>  
  
`(\w+)\s(\1)\W`  
  
 <span data-ttu-id="8b935-158">W poniższej tabeli pokazano, jak interpretowany jest wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="8b935-159">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-159">Pattern</span></span>|<span data-ttu-id="8b935-160">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="8b935-161">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-161">Match one or more word characters.</span></span> <span data-ttu-id="8b935-162">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="8b935-163">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="8b935-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="8b935-164">Dopasuj ciąg w pierwszej przechwyconej grupie.</span><span class="sxs-lookup"><span data-stu-id="8b935-164">Match the string in the first captured group.</span></span> <span data-ttu-id="8b935-165">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-165">This is the second capturing group.</span></span> <span data-ttu-id="8b935-166">Przykład przypisuje go do przechwyconej grupy, dzięki czemu pozycja `Match.Index` początkowa zduplikowanego wyrazu może zostać pobrana z właściwości.</span><span class="sxs-lookup"><span data-stu-id="8b935-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="8b935-167">Dopasuj znak niebędący wyrazem, w tym biały znak i znaki interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="8b935-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="8b935-168">Zapobiega to dopasowywaniu wzorca wyrażenia regularnego od wyrazu, który zaczyna się od słowa z pierwszej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>
## <a name="named-matched-subexpressions"></a><span data-ttu-id="8b935-169">O nazwie dopasowane podwyrażenia</span><span class="sxs-lookup"><span data-stu-id="8b935-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="8b935-170">Następująca konstrukcja grupowania przechwytuje dopasowane podwyrażenie i umożliwia dostęp do niego według nazwy lub liczby:</span><span class="sxs-lookup"><span data-stu-id="8b935-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
`(?<name>subexpression)`  
  
 <span data-ttu-id="8b935-171">lub:</span><span class="sxs-lookup"><span data-stu-id="8b935-171">or:</span></span>  
  
`(?'name'subexpression)`  
  
 <span data-ttu-id="8b935-172">gdzie *nazwa* jest prawidłową nazwą grupy, a *wyrażenie podrzędne* jest prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="8b935-173">*nazwa* nie może zawierać żadnych znaków interpunkcyjnych i nie może zaczynać się od liczby.</span><span class="sxs-lookup"><span data-stu-id="8b935-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8b935-174">Jeśli <xref:System.Text.RegularExpressions.RegexOptions> parametr metody dopasowywania wzorców wyrażenia regularnego zawiera <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flagę lub jeśli `n` opcja jest stosowana do tego wyrażenia podrzędnego (zobacz Opcje [grupy](#group_options) w dalszej części tego tematu), jedynym sposobem przechwycenia wyrażenia podrzędnego jest jawna nazwanie grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="8b935-175">Dostęp do nazwanych przechwyconych grup można uzyskać w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8b935-175">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="8b935-176">Za pomocą konstrukcji o nazwie backreference w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="8b935-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="8b935-177">Dopasowane wyrażenie podrzędne odwołuje się do tego samego `\k<`wyrażenia regularnego przy użyciu *nazwy*`>`składni , gdzie *nazwa* jest nazwą przechwyconego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="8b935-178">Za pomocą backreference konstrukcji w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="8b935-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="8b935-179">Dopasowane wyrażenie podrzędne odwołuje się w tym samym `\`wyrażeniu regularnym przy użyciu *liczby*składni , gdzie *liczba* jest liczbą porządkną przechwyconego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="8b935-180">Nazwane dopasowane wyrażenia podrzędne są numerowane kolejno od lewej do prawej po dopasowanych wyrażeniach podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="8b935-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="8b935-181">Za pomocą `${`sekwencji zastępowania <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> *nazw* `}` w wywołaniu lub metody, gdzie *nazwa* jest nazwą przechwyconego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="8b935-182">Za pomocą `$`sekwencji zastępowania <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> *numerów* w wywołaniu lub metody, gdzie *numer* jest liczbą porządkową przechwyconego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="8b935-183">Programowo przy użyciu <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="8b935-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8b935-184">Element członkowski w pozycji zero w kolekcji reprezentuje całą dopasowanie wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="8b935-185">Każdy kolejny element członkowski reprezentuje dopasowane wyrażenie podrzędne.</span><span class="sxs-lookup"><span data-stu-id="8b935-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="8b935-186">Nazwane przechwycone grupy są przechowywane w kolekcji po numerowanych przechwyconych grupach.</span><span class="sxs-lookup"><span data-stu-id="8b935-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="8b935-187">Programowo, podając nazwę podwyrażenia indeksatorowi obiektu (w języku <xref:System.Text.RegularExpressions.GroupCollection> C#) lub jego <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> właściwości (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8b935-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="8b935-188">Prosty wzorzec wyrażenia regularnego ilustruje, jak można odwoływać się do ponumerowanych (nienazwanych) i nazwanych grup programowo lub przy użyciu składni języka wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="8b935-189">Wyrażenie `((?<One>abc)\d+)?(?<Two>xyz)(.*)` regularne tworzy następujące grupy przechwytywania według liczby i nazwy.</span><span class="sxs-lookup"><span data-stu-id="8b935-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="8b935-190">Pierwsza grupa przechwytywania (liczba 0) zawsze odnosi się do całego wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="8b935-191">Liczba</span><span class="sxs-lookup"><span data-stu-id="8b935-191">Number</span></span>|<span data-ttu-id="8b935-192">Nazwa</span><span class="sxs-lookup"><span data-stu-id="8b935-192">Name</span></span>|<span data-ttu-id="8b935-193">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="8b935-194">0</span><span class="sxs-lookup"><span data-stu-id="8b935-194">0</span></span>|<span data-ttu-id="8b935-195">0 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="8b935-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="8b935-196">1</span><span class="sxs-lookup"><span data-stu-id="8b935-196">1</span></span>|<span data-ttu-id="8b935-197">1 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="8b935-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="8b935-198">2</span><span class="sxs-lookup"><span data-stu-id="8b935-198">2</span></span>|<span data-ttu-id="8b935-199">2 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="8b935-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="8b935-200">3</span><span class="sxs-lookup"><span data-stu-id="8b935-200">3</span></span>|<span data-ttu-id="8b935-201">Jeden</span><span class="sxs-lookup"><span data-stu-id="8b935-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="8b935-202">4</span><span class="sxs-lookup"><span data-stu-id="8b935-202">4</span></span>|<span data-ttu-id="8b935-203">Dwa</span><span class="sxs-lookup"><span data-stu-id="8b935-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="8b935-204">W poniższym przykładzie przedstawiono wyrażenie regularne, które identyfikuje zduplikowane wyrazy i słowo, które natychmiast następuje po każdym zduplikowanym słowie.</span><span class="sxs-lookup"><span data-stu-id="8b935-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="8b935-205">Wzorzec wyrażenia regularnego definiuje dwa `duplicateWord`nazwane wyrażenia podrzędne: , który reprezentuje zduplikowane słowo; i `nextWord`, który reprezentuje słowo, które następuje po zduplikowanym słowie.</span><span class="sxs-lookup"><span data-stu-id="8b935-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="8b935-206">Wzorzec wyrażenia regularnego jest następujący:</span><span class="sxs-lookup"><span data-stu-id="8b935-206">The regular expression pattern is as follows:</span></span>  
  
`(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)`  
  
 <span data-ttu-id="8b935-207">W poniższej tabeli pokazano, jak interpretowane jest wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="8b935-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="8b935-208">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-208">Pattern</span></span>|<span data-ttu-id="8b935-209">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="8b935-210">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-210">Match one or more word characters.</span></span> <span data-ttu-id="8b935-211">Nazwij tę `duplicateWord`grupę przechwytywania .</span><span class="sxs-lookup"><span data-stu-id="8b935-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="8b935-212">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="8b935-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="8b935-213">Dopasuj ciąg z przechwyconej grupy o nazwie `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="8b935-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="8b935-214">Dopasuj znak niebędący wyrazem, w tym biały znak i znaki interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="8b935-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="8b935-215">Zapobiega to dopasowywaniu wzorca wyrażenia regularnego od wyrazu, który zaczyna się od słowa z pierwszej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="8b935-216">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-216">Match one or more word characters.</span></span> <span data-ttu-id="8b935-217">Nazwij tę `nextWord`grupę przechwytywania .</span><span class="sxs-lookup"><span data-stu-id="8b935-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="8b935-218">Należy zauważyć, że nazwę grupy można powtórzyć w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="8b935-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="8b935-219">Na przykład jest możliwe dla więcej niż `digit`jednej grupy, aby być nazwane , jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8b935-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="8b935-220">W przypadku zduplikowanych nazw <xref:System.Text.RegularExpressions.Group> wartość obiektu jest określana przez ostatnie udane przechwycenie w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8b935-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="8b935-221">Ponadto <xref:System.Text.RegularExpressions.CaptureCollection> jest wypełniona informacjami o każdym przechwyceniu, tak jak byłoby, gdyby nazwa grupy nie została zduplikowana.</span><span class="sxs-lookup"><span data-stu-id="8b935-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="8b935-222">W poniższym przykładzie wyrażenie `\D+(?<digit>\d+)\D+(?<digit>\d+)?` regularne zawiera dwa wystąpienia `digit`grupy o nazwie .</span><span class="sxs-lookup"><span data-stu-id="8b935-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="8b935-223">Pierwsza `digit` nazwana grupa przechwytuje jeden lub więcej znaków cyfr.</span><span class="sxs-lookup"><span data-stu-id="8b935-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="8b935-224">Druga `digit` nazwana grupa przechwytuje zero lub jedno wystąpienie jednego lub więcej znaków cyfr.</span><span class="sxs-lookup"><span data-stu-id="8b935-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="8b935-225">Jak pokazuje dane wyjściowe z przykładu, jeśli druga grupa przechwytywania pomyślnie pasuje do tekstu, <xref:System.Text.RegularExpressions.Group> wartość tego tekstu definiuje wartość obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b935-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="8b935-226">Jeśli druga grupa przechwytywania nie może być zgodna z ciągiem wejściowym, wartość <xref:System.Text.RegularExpressions.Group> ostatniego pomyślnego dopasowania definiuje wartość obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b935-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="8b935-227">W poniższej tabeli pokazano, jak interpretowane jest wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="8b935-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="8b935-228">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-228">Pattern</span></span>|<span data-ttu-id="8b935-229">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="8b935-230">Dopasuj co najmniej jeden znak cyfry niedziesiętne.</span><span class="sxs-lookup"><span data-stu-id="8b935-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="8b935-231">Dopasuj co najmniej jeden znak cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="8b935-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="8b935-232">Przypisz dopasowanie `digit` do nazwanej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-232">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="8b935-233">Dopasuj co najmniej jeden znak cyfry niedziesiętne.</span><span class="sxs-lookup"><span data-stu-id="8b935-233">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="8b935-234">Dopasuj zero lub jedno wystąpienie jednego lub więcej znaków cyfr dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="8b935-234">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="8b935-235">Przypisz dopasowanie `digit` do nazwanej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-235">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>
## <a name="balancing-group-definitions"></a><span data-ttu-id="8b935-236">Równoważenie definicji grup</span><span class="sxs-lookup"><span data-stu-id="8b935-236">Balancing Group Definitions</span></span>  
 <span data-ttu-id="8b935-237">Definicja grupy bilansującej usuwa definicję wcześniej zdefiniowanej grupy i przechowuje w bieżącej grupie interwał między wcześniej zdefiniowaną grupą a bieżącą grupą.</span><span class="sxs-lookup"><span data-stu-id="8b935-237">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="8b935-238">Ta konstrukcja grupowania ma następujący format:</span><span class="sxs-lookup"><span data-stu-id="8b935-238">This grouping construct has the following format:</span></span>  
  
`(?<name1-name2>subexpression)`  
  
 <span data-ttu-id="8b935-239">lub:</span><span class="sxs-lookup"><span data-stu-id="8b935-239">or:</span></span>  
  
`(?'name1-name2' subexpression)`
  
 <span data-ttu-id="8b935-240">gdzie *name1* jest bieżącą grupą (opcjonalnie), *name2* jest wcześniej zdefiniowaną grupą, a *wyrażenie podrzędne* jest prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-240">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="8b935-241">Definicja grupy bilansującej usuwa definicję *nazwy2* i przechowuje interwał między *name2* i *name1* w *nazwie1*.</span><span class="sxs-lookup"><span data-stu-id="8b935-241">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="8b935-242">Jeśli nie zdefiniowano grupy *name2,* backtracks meczu.</span><span class="sxs-lookup"><span data-stu-id="8b935-242">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="8b935-243">Ponieważ usunięcie ostatniej definicji *name2* ujawnia poprzednią definicję *name2*, ta konstrukcja umożliwia użycie stosu przechwytów dla *nazwy grupy2* jako licznika do śledzenia zagnieżdżonych konstrukcji, takich jak nawiasy lub nawiasy otwierające i zamykające.</span><span class="sxs-lookup"><span data-stu-id="8b935-243">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="8b935-244">Definicja grupy równoważenia używa *name2* jako stosu.</span><span class="sxs-lookup"><span data-stu-id="8b935-244">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="8b935-245">Początkowy znak każdej zagnieżdżonej konstrukcji <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> jest umieszczany w grupie i w jej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="8b935-245">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="8b935-246">Po dopasowaniu znaku zamykającego jego odpowiedni znak otwarcia <xref:System.Text.RegularExpressions.Group.Captures%2A> jest usuwany z grupy, a kolekcja jest zmniejszana o jeden.</span><span class="sxs-lookup"><span data-stu-id="8b935-246">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="8b935-247">Po dopasowaniu znaków otwarcia i zamknięcia wszystkich zagnieżdżonych konstrukcji *nazwa2* jest pusta.</span><span class="sxs-lookup"><span data-stu-id="8b935-247">After the opening and closing characters of all nested constructs have been matched, *name2* is empty.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8b935-248">Po zmodyfikowaniu wyrażenia regularnego w poniższym przykładzie, aby użyć odpowiedniego znaku otwarcia i zamknięcia konstrukcji zagnieżdżonej, można go używać do obsługi większości zagnieżdżonych konstrukcji, takich jak wyrażenia matematyczne lub wiersze kodu programu, które zawierają wiele wywołań metody zagnieżdżonej.</span><span class="sxs-lookup"><span data-stu-id="8b935-248">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="8b935-249">W poniższym przykładzie użyto definicji grupy równoważenia, aby dopasować nawiasy kąta lewego i prawego (<>) w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8b935-249">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="8b935-250">W przykładzie zdefiniowano `Open` dwie `Close`nazwane grupy i , które są używane jak stos do śledzenia pasujących par nawiasów kątowych.</span><span class="sxs-lookup"><span data-stu-id="8b935-250">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="8b935-251">Każdy przechwycony lewy nawias `Open` kątowy jest wypychany do kolekcji przechwytywania `Close` grupy, a każdy przechwycony nawias kąta prawego jest wypychany do kolekcji przechwytywania grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-251">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="8b935-252">Definicja grupy wyważania zapewnia, że dla każdego lewego nawiasu kątowego znajduje się pasujący nawias kątowy.</span><span class="sxs-lookup"><span data-stu-id="8b935-252">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="8b935-253">Jeśli nie ma, końcowy podwzorzec , jest obliczana tylko wtedy, `(?(Open)(?!))`gdy `Open` grupa nie jest pusta (i dlatego, jeśli wszystkie zagnieżdżone konstrukcje nie zostały zamknięte).</span><span class="sxs-lookup"><span data-stu-id="8b935-253">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="8b935-254">Jeśli ostateczny podwzorzec jest obliczany, `(?!)` dopasowanie nie powiedzie się, ponieważ podwzorzec jest zero szerokości ujemne wyczekiwanie potwierdzenia, że zawsze nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="8b935-254">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="8b935-255">Wzorzec wyrażenia regularnego jest następujące:</span><span class="sxs-lookup"><span data-stu-id="8b935-255">The regular expression pattern is:</span></span>  
  
`^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$`  
  
 <span data-ttu-id="8b935-256">Wyrażenie regularne jest interpretowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8b935-256">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="8b935-257">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-257">Pattern</span></span>|<span data-ttu-id="8b935-258">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-258">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="8b935-259">Rozpocznij od początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="8b935-259">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="8b935-260">Dopasuj zero lub więcej znaków, które nie są nawiasami kąta lewego lub prawego.</span><span class="sxs-lookup"><span data-stu-id="8b935-260">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="8b935-261">Dopasuj lewy nawias kątowy i `Open`przypisz go do grupy o nazwie .</span><span class="sxs-lookup"><span data-stu-id="8b935-261">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="8b935-262">Dopasuj zero lub więcej znaków, które nie są nawiasami kąta lewego lub prawego.</span><span class="sxs-lookup"><span data-stu-id="8b935-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*)+`|<span data-ttu-id="8b935-263">Dopasuj co najmniej jedno wystąpienie nawiasu kątowego po lewej stronie, po którym następuje zero lub więcej znaków, które nie są nawiasami kąta lewego lub prawego.</span><span class="sxs-lookup"><span data-stu-id="8b935-263">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="8b935-264">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-264">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="8b935-265">Dopasuj nawias kątowy, przypisz podciąg między `Open` `Close` grupą a bieżącą `Open` grupą do grupy i usuń definicję grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-265">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="8b935-266">Dopasuj zero lub więcej wystąpień dowolnego znaku, który nie jest ani lewym, ani prawym kątem.</span><span class="sxs-lookup"><span data-stu-id="8b935-266">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="8b935-267">Dopasuj co najmniej jedno wystąpienie nawiasu kątowego, po którym następuje zero lub więcej wystąpień dowolnego znaku, który nie jest ani lewym, ani prawym kątem.</span><span class="sxs-lookup"><span data-stu-id="8b935-267">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="8b935-268">Podczas dopasowywania nawiasu kąta prostokątnego należy przypisać podciąg między grupą `Open` a bieżącą grupą `Close` do grupy i usunąć definicję `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-268">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="8b935-269">Jest to trzecia grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-269">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="8b935-270">Dopasuj zero lub więcej wystąpień następującego wzorca: jedno lub więcej wystąpień nawiasu kątowego po lewej stronie, po których następuje zero lub więcej znaków nawiasu niekątnego, po których następuje jedno lub więcej wystąpień wnawiasu kątowego, po którym następuje zero lub więcej wystąpień wsporniki niekącowe.</span><span class="sxs-lookup"><span data-stu-id="8b935-270">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="8b935-271">Podczas dopasowywania nawiasu kąta `Open` prostokątnego usuń definicję grupy `Open` i przypisz `Close` podciąg między grupą a bieżącą grupą do grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-271">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="8b935-272">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-272">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="8b935-273">Jeśli `Open` grupa istnieje, porzuć dopasowanie, jeśli można dopasować pusty ciąg, ale nie rozwijaj pozycji aparatu wyrażeń regularnych w ciągu.</span><span class="sxs-lookup"><span data-stu-id="8b935-273">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="8b935-274">Jest to potwierdzenie ujemne o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="8b935-274">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="8b935-275">Ponieważ pusty ciąg jest zawsze niejawnie obecny w ciągu wejściowym, to dopasowanie zawsze kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="8b935-275">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="8b935-276">Niepowodzenie tego dopasowania wskazuje, że nawiasy kątowe nie są zrównoważone.</span><span class="sxs-lookup"><span data-stu-id="8b935-276">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="8b935-277">Dopasowuje koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="8b935-277">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="8b935-278">Ostateczne wyrażenie podrzędne wskazuje, `(?(Open)(?!))`czy konstrukcje zagnieżdżania w ciągu wejściowym są prawidłowo zrównoważone (na przykład, czy każdy lewy nawias kątowy jest dopasowywany przez nawias kątowy).</span><span class="sxs-lookup"><span data-stu-id="8b935-278">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="8b935-279">Używa uzgadniania warunkowego na podstawie prawidłowej przechwyconej grupy; Aby uzyskać więcej informacji, zobacz [Konstrukcje alternacji](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="8b935-279">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="8b935-280">Jeśli `Open` grupa jest zdefiniowana, aparat wyrażeń `(?!)` regularnych próbuje dopasować wyrażenie podrzędne w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8b935-280">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="8b935-281">Grupa `Open` powinna być zdefiniowana tylko wtedy, gdy konstrukcje zagnieżdżania są niezrównoważone.</span><span class="sxs-lookup"><span data-stu-id="8b935-281">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="8b935-282">W związku z tym wzorzec, który ma być dopasowany w ciągu wejściowym powinien być taki, który zawsze powoduje, że dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="8b935-282">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="8b935-283">W takim `(?!)` przypadku jest zero szerokości ujemnego wyglądu twierdzenie, które zawsze kończy się niepowodzeniem, ponieważ pusty ciąg jest zawsze niejawnie obecny w następnej pozycji w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8b935-283">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="8b935-284">W tym przykładzie aparat wyrażeń regularnych\<oblicza ciąg\<wejściowy " abc><mno xyz>>", jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-284">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-285">Krok</span><span class="sxs-lookup"><span data-stu-id="8b935-285">Step</span></span>|<span data-ttu-id="8b935-286">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-286">Pattern</span></span>|<span data-ttu-id="8b935-287">Wynik</span><span class="sxs-lookup"><span data-stu-id="8b935-287">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="8b935-288">1</span><span class="sxs-lookup"><span data-stu-id="8b935-288">1</span></span>|`^`|<span data-ttu-id="8b935-289">Rozpoczyna dopasowanie na początku ciągu wejściowego</span><span class="sxs-lookup"><span data-stu-id="8b935-289">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="8b935-290">2</span><span class="sxs-lookup"><span data-stu-id="8b935-290">2</span></span>|`[^<>]*`|<span data-ttu-id="8b935-291">Wyszukuje znaki nawiasu niekątnego przed lewym nawiasem kątowym;nie znajduje żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="8b935-291">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="8b935-292">3</span><span class="sxs-lookup"><span data-stu-id="8b935-292">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="8b935-293">Pasuje do lewego\<nawiasu kątowego w "abc>" i przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-293">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="8b935-294">4</span><span class="sxs-lookup"><span data-stu-id="8b935-294">4</span></span>|`[^<>]*`|<span data-ttu-id="8b935-295">Pasuje do "abc".</span><span class="sxs-lookup"><span data-stu-id="8b935-295">Matches "abc".</span></span>|  
|<span data-ttu-id="8b935-296">5</span><span class="sxs-lookup"><span data-stu-id="8b935-296">5</span></span>|`)+`|<span data-ttu-id="8b935-297">"<abc" to wartość drugiej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-297">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="8b935-298">Następny znak w ciągu wejściowym nie jest nawiasem kąta lewego, `(?'Open'<)[^<>]*)` więc aparat wyrażeń regularnych nie pętli z powrotem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-298">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-299">6</span><span class="sxs-lookup"><span data-stu-id="8b935-299">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="8b935-300">Dopasowuje nawias kąta prawego w\<"abc>", przypisuje `Open` "abc", który jest podciągiem między grupą a prawym nawiasem kątowym, do `Close` grupy i usuwa bieżącą wartość ("<") `Open` grupy, pozostawiając ją pustą.</span><span class="sxs-lookup"><span data-stu-id="8b935-300">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="8b935-301">7</span><span class="sxs-lookup"><span data-stu-id="8b935-301">7</span></span>|`[^<>]*`|<span data-ttu-id="8b935-302">Wyszna znaków nawiasu niekątnego po nawiasie kąta prostokątnego; nie znajdzie żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="8b935-302">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="8b935-303">8</span><span class="sxs-lookup"><span data-stu-id="8b935-303">8</span></span>|`)+`|<span data-ttu-id="8b935-304">Wartość trzeciej przechwyconej grupy to ">".</span><span class="sxs-lookup"><span data-stu-id="8b935-304">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="8b935-305">Następny znak w ciągu wejściowym nie jest nawiasem kąta prostokątnego, `((?'Close-Open'>)[^<>]*)` więc aparat wyrażeń regularnych nie pętli z powrotem do podwzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-305">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-306">9</span><span class="sxs-lookup"><span data-stu-id="8b935-306">9</span></span>|`)*`|<span data-ttu-id="8b935-307">Wartość pierwszej przechwyconej grupy to "\<abc>".</span><span class="sxs-lookup"><span data-stu-id="8b935-307">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="8b935-308">Następny znak w ciągu wejściowym jest nawiasem kąta po lewej `(((?'Open'<)` stronie, więc aparat wyrażeń regularnych pętli z powrotem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-308">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-309">10</span><span class="sxs-lookup"><span data-stu-id="8b935-309">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="8b935-310">Pasuje do lewego\<nawiasu kątowego w "mno" i przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-310">Matches the left angle bracket in "\<mno" and assigns it to the `Open` group.</span></span> <span data-ttu-id="8b935-311">Jego <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekcja ma teraz jedną wartość, "<".</span><span class="sxs-lookup"><span data-stu-id="8b935-311">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="8b935-312">11</span><span class="sxs-lookup"><span data-stu-id="8b935-312">11</span></span>|`[^<>]*`|<span data-ttu-id="8b935-313">Mecze "mno".</span><span class="sxs-lookup"><span data-stu-id="8b935-313">Matches "mno".</span></span>|  
|<span data-ttu-id="8b935-314">12</span><span class="sxs-lookup"><span data-stu-id="8b935-314">12</span></span>|`)+`|<span data-ttu-id="8b935-315">"<mno" to wartość drugiej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-315">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="8b935-316">Następny znak w ciągu wejściowym jest nawiasem kąta po lewej `(?'Open'<)[^<>]*)` stronie, więc aparat wyrażeń regularnych pętli z powrotem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-316">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-317">13</span><span class="sxs-lookup"><span data-stu-id="8b935-317">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="8b935-318">Pasuje do lewego\<nawiasu kątowego w " xyz>" i przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-318">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="8b935-319">Kolekcja <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> `Open` grupy zawiera teraz dwa ujęcia: lewy wspornik kątowy z "\<\<mno", a lewy wspornik kątowy z " xyz>".</span><span class="sxs-lookup"><span data-stu-id="8b935-319">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="8b935-320">14</span><span class="sxs-lookup"><span data-stu-id="8b935-320">14</span></span>|`[^<>]*`|<span data-ttu-id="8b935-321">Pasuje do "xyz".</span><span class="sxs-lookup"><span data-stu-id="8b935-321">Matches "xyz".</span></span>|  
|<span data-ttu-id="8b935-322">15</span><span class="sxs-lookup"><span data-stu-id="8b935-322">15</span></span>|`)+`|<span data-ttu-id="8b935-323">"<xyz" to wartość drugiej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-323">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="8b935-324">Następny znak w ciągu wejściowym nie jest nawiasem kąta lewego, `(?'Open'<)[^<>]*)` więc aparat wyrażeń regularnych nie pętli z powrotem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-324">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-325">16</span><span class="sxs-lookup"><span data-stu-id="8b935-325">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="8b935-326">Pasuje do nawiasu\<kątowego w " xyz>".</span><span class="sxs-lookup"><span data-stu-id="8b935-326">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="8b935-327">"xyz", przypisuje podciąg między `Open` grupą a prawym `Close` nawiasem kątowym do grupy `Open` i usuwa bieżącą wartość grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-327">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="8b935-328">Wartość poprzedniego przechwytywania (lewy nawias kątowy\<w " mno") staje `Open` się bieżącą wartością grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-328">The value of the previous capture (the left angle bracket in "\<mno") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="8b935-329">Kolekcja <xref:System.Text.RegularExpressions.Group.Captures%2A> `Open` grupy zawiera teraz pojedynczy uchwyt kątowy, lewy\<wspornik kątowy z " xyz>".</span><span class="sxs-lookup"><span data-stu-id="8b935-329">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="8b935-330">17</span><span class="sxs-lookup"><span data-stu-id="8b935-330">17</span></span>|`[^<>]*`|<span data-ttu-id="8b935-331">Wyszna znaków nawiasu niekątnego; nie znajdzie żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="8b935-331">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="8b935-332">18</span><span class="sxs-lookup"><span data-stu-id="8b935-332">18</span></span>|`)+`|<span data-ttu-id="8b935-333">Wartość trzeciej przechwyconej grupy to ">".</span><span class="sxs-lookup"><span data-stu-id="8b935-333">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="8b935-334">Następny znak w ciągu wejściowym jest nawiasem kątowym, więc aparat `((?'Close-Open'>)[^<>]*)` wyrażeń regularnych pętli z powrotem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-334">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-335">19</span><span class="sxs-lookup"><span data-stu-id="8b935-335">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="8b935-336">Dopasowuje ostatni nawias kątowy w "xyz\<>>", przypisuje grupie "mno `Open` xyz>" (podciąg między grupą a nawiasem kąta prostokątnego) `Close` i usuwa bieżącą `Open` wartość grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-336">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="8b935-337">Grupa `Open` jest teraz pusta.</span><span class="sxs-lookup"><span data-stu-id="8b935-337">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="8b935-338">20</span><span class="sxs-lookup"><span data-stu-id="8b935-338">20</span></span>|`[^<>]*`|<span data-ttu-id="8b935-339">Wyszna znaków nawiasu niekątnego; nie znajdzie żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="8b935-339">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="8b935-340">21</span><span class="sxs-lookup"><span data-stu-id="8b935-340">21</span></span>|`)+`|<span data-ttu-id="8b935-341">Wartość trzeciej przechwyconej grupy to ">".</span><span class="sxs-lookup"><span data-stu-id="8b935-341">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="8b935-342">Następny znak w ciągu wejściowym nie jest nawiasem kąta prostokątnego, `((?'Close-Open'>)[^<>]*)` więc aparat wyrażeń regularnych nie pętli z powrotem do podwzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-342">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-343">22</span><span class="sxs-lookup"><span data-stu-id="8b935-343">22</span></span>|`)*`|<span data-ttu-id="8b935-344">Wartość pierwszej przechwyconej\<grupy to "<mno xyz>>".</span><span class="sxs-lookup"><span data-stu-id="8b935-344">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="8b935-345">Następny znak w ciągu wejściowym nie jest nawiasem kąta lewego, `(((?'Open'<)` więc aparat wyrażeń regularnych nie pętli z powrotem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-345">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="8b935-346">23</span><span class="sxs-lookup"><span data-stu-id="8b935-346">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="8b935-347">Grupa `Open` nie jest zdefiniowana, więc nie jest podejmowana żadna relacja.</span><span class="sxs-lookup"><span data-stu-id="8b935-347">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="8b935-348">24</span><span class="sxs-lookup"><span data-stu-id="8b935-348">24</span></span>|`$`|<span data-ttu-id="8b935-349">Dopasowuje koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="8b935-349">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>
## <a name="noncapturing-groups"></a><span data-ttu-id="8b935-350">Grupy niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="8b935-350">Noncapturing Groups</span></span>  
 <span data-ttu-id="8b935-351">Następująca konstrukcja grupowania nie przechwytuje podciągu, który jest dopasowywany przez wyrażenie podrzędne:</span><span class="sxs-lookup"><span data-stu-id="8b935-351">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
`(?:subexpression)`
  
 <span data-ttu-id="8b935-352">gdzie *wyrażenie podrzędne* jest prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-352">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="8b935-353">Konstrukcja grupy nieprzechwytującej jest zwykle używana, gdy kwantyfikator jest stosowany do grupy, ale podciągi przechwycone przez grupę nie są interesujące.</span><span class="sxs-lookup"><span data-stu-id="8b935-353">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8b935-354">Jeśli wyrażenie regularne zawiera zagnieżdżone konstrukcje grupowania, zewnętrzna konstrukcja grupy nieprzechwytującej nie ma zastosowania do konstrukcji grupy zagnieżdżonej wewnętrznie.</span><span class="sxs-lookup"><span data-stu-id="8b935-354">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="8b935-355">W poniższym przykładzie przedstawiono wyrażenie regularne, które zawiera grupy nieprzechwytujące.</span><span class="sxs-lookup"><span data-stu-id="8b935-355">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="8b935-356">Należy zauważyć, że dane wyjściowe nie zawiera żadnych przechwyconych grup.</span><span class="sxs-lookup"><span data-stu-id="8b935-356">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="8b935-357">Wyrażenie `(?:\b(?:\w+)\W*)+\.` regularne jest zgodne z zdaniem zakończonym kropką.</span><span class="sxs-lookup"><span data-stu-id="8b935-357">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="8b935-358">Ponieważ wyrażenie regularne koncentruje się na zdaniach, a nie na poszczególnych wyrazach, konstrukcje grupowania są używane wyłącznie jako kwantyfikatory.</span><span class="sxs-lookup"><span data-stu-id="8b935-358">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="8b935-359">Wzorzec wyrażenia regularnego jest interpretowany w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-359">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-360">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-360">Pattern</span></span>|<span data-ttu-id="8b935-361">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-361">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="8b935-362">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-362">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="8b935-363">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-363">Match one or more word characters.</span></span> <span data-ttu-id="8b935-364">Nie należy przypisywać dopasowanego tekstu do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-364">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="8b935-365">Dopasuj zero lub więcej znaków innych niż word.</span><span class="sxs-lookup"><span data-stu-id="8b935-365">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="8b935-366">Dopasuj wzorzec jednego lub więcej znaków wyrazu rozpoczynających się od granicy wyrazu, po których następuje zero lub więcej znaków innych niż słowa, jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="8b935-366">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="8b935-367">Nie należy przypisywać dopasowanego tekstu do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-367">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="8b935-368">Dopasuj kropkę.</span><span class="sxs-lookup"><span data-stu-id="8b935-368">Match a period.</span></span>|  
  
<a name="group_options"></a>
## <a name="group-options"></a><span data-ttu-id="8b935-369">Opcje grupy</span><span class="sxs-lookup"><span data-stu-id="8b935-369">Group Options</span></span>  
 <span data-ttu-id="8b935-370">Następująca konstrukcja grupowania stosuje lub wyłącza określone opcje w wyrażeniu podrzędnym:</span><span class="sxs-lookup"><span data-stu-id="8b935-370">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="8b935-371">`(?imnsx-imnsx:`*wyrażenie podrzędne*`)`</span><span class="sxs-lookup"><span data-stu-id="8b935-371">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="8b935-372">gdzie *wyrażenie podrzędne* jest prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-372">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="8b935-373">Na przykład `(?i-s:)` włącza niewrażliwość wielkości liter i wyłącza tryb jednowierszowy.</span><span class="sxs-lookup"><span data-stu-id="8b935-373">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="8b935-374">Aby uzyskać więcej informacji na temat opcji wbudowanych, które można określić, zobacz [Opcje wyrażenia regularnego](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="8b935-374">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8b935-375">Można określić opcje, które mają zastosowanie do całego wyrażenia <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> regularnego, a nie wyrażenia podrzędnego przy użyciu konstruktora klasy lub metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="8b935-375">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="8b935-376">Można również określić opcje w wierszu, które mają zastosowanie `(?imnsx-imnsx)` po określonym punkcie w wyrażeniu regularnym przy użyciu konstrukcji języka.</span><span class="sxs-lookup"><span data-stu-id="8b935-376">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="8b935-377">Konstrukcja opcji grupy nie jest grupą przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-377">The group options construct is not a capturing group.</span></span> <span data-ttu-id="8b935-378">Oznacza to, że chociaż dowolna część ciągu przechwycona przez *wyrażenie podrzędne* jest uwzględniona w dopasowaniu, nie jest uwzględniona w przechwyconej grupie ani nie jest używana do wypełniania <xref:System.Text.RegularExpressions.GroupCollection> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b935-378">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="8b935-379">Na przykład wyrażenie `\b(?ix: d \w+)\s` regularne w poniższym przykładzie używa opcji wbudowanych w konstrukcji grupowania, aby umożliwić dopasowanie bez uwzględniania wielkości liter i ignorować biały znak wzorca w identyfikowaniu wszystkich wyrazów, które zaczynają się od litery "d".</span><span class="sxs-lookup"><span data-stu-id="8b935-379">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="8b935-380">Wyrażenie regularne jest zdefiniowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-380">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-381">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-381">Pattern</span></span>|<span data-ttu-id="8b935-382">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-382">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="8b935-383">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-383">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="8b935-384">Używając dopasowywania bez uwzględniania wielkości liter i ignorując biały znak w tym wzorcu, dopasuj literę "d", po której następuje jeden lub więcej znaków wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-384">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="8b935-385">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="8b935-385">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="8b935-386">Dodatnie asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-386">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="8b935-387">Następująca konstrukcja grupowania definiuje potwierdzenie dodatniego oczekiwania o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="8b935-387">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="8b935-388">`(?=`*wyrażenie podrzędne*`)`</span><span class="sxs-lookup"><span data-stu-id="8b935-388">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="8b935-389">gdzie *wyrażenie podrzędne* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-389">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="8b935-390">Aby dopasowanie zakończyło się pomyślnie, ciąg wejściowy musi być zgodny z wzorcem wyrażenia regularnego w *wyrażeniu podrzędnym,* chociaż dopasowany podciąg nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="8b935-390">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="8b935-391">Zero szerokości dodatnie lookahead potwierdzenia nie backtrack.</span><span class="sxs-lookup"><span data-stu-id="8b935-391">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="8b935-392">Zazwyczaj potwierdzenie dodatnie o zerowej szerokości znajduje się na końcu wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-392">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="8b935-393">Definiuje podciąg, który musi znajdować się na końcu ciągu, aby dopasowanie wystąpiło, ale nie powinno być uwzględnione w dopasowaniu.</span><span class="sxs-lookup"><span data-stu-id="8b935-393">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="8b935-394">Jest to również przydatne do zapobiegania nadmiernego wycofywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-394">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="8b935-395">Można użyć potwierdzenia z wyprzedzeniem dodatnim o zerowej szerokości, aby upewnić się, że określona przechwycona grupa zaczyna się od tekstu, który pasuje do podzbioru wzorca zdefiniowanego dla tej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-395">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="8b935-396">Na przykład jeśli grupa przechwytywania pasuje do kolejnych znaków wyrazu, można użyć potwierdzenia z wynikiem dodatnim o zerowej szerokości, aby wymagać, aby pierwszy znak był alfabetycznym wielkimznakiem.</span><span class="sxs-lookup"><span data-stu-id="8b935-396">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="8b935-397">W poniższym przykładzie użyto potwierdzenia dodatniego punktu wyczekiwania o zerowej szerokości, aby dopasować słowo, które poprzedza czasownik "is" w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8b935-397">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="8b935-398">Wyrażenie `\b\w+(?=\sis\b)` regularne jest interpretowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-398">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-399">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-399">Pattern</span></span>|<span data-ttu-id="8b935-400">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-400">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="8b935-401">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-401">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="8b935-402">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-402">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="8b935-403">Określ, czy po znakach wyrazu następuje znak odstępu, a ciąg "is", który kończy się na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-403">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="8b935-404">Jeśli tak, dopasowanie zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8b935-404">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="8b935-405">Ujemne asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-405">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="8b935-406">Następująca konstrukcja grupowania definiuje potwierdzenie ujemnego wyglądu o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="8b935-406">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="8b935-407">`(?!`*wyrażenie podrzędne*`)`</span><span class="sxs-lookup"><span data-stu-id="8b935-407">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="8b935-408">gdzie *wyrażenie podrzędne* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-408">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="8b935-409">Aby dopasowanie zakończyło się pomyślnie, ciąg wejściowy nie może być zgodny z wzorcem wyrażenia regularnego w *wyrażeniu podrzędnym,* chociaż dopasowany ciąg nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="8b935-409">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="8b935-410">Zero szerokości ujemne wygląd potwierdzenia jest zwykle używany na początku lub na końcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-410">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="8b935-411">Na początku wyrażenia regularnego można zdefiniować określony wzorzec, który nie powinien być dopasowywany, gdy początek wyrażenia regularnego definiuje podobny, ale bardziej ogólny wzorzec do dopasowania.</span><span class="sxs-lookup"><span data-stu-id="8b935-411">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="8b935-412">W takim przypadku jest często używany do ograniczenia wycofywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-412">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="8b935-413">Na końcu wyrażenia regularnego można zdefiniować wyrażenie podrzędne, które nie może wystąpić na końcu dopasowania.</span><span class="sxs-lookup"><span data-stu-id="8b935-413">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="8b935-414">W poniższym przykładzie zdefiniowano wyrażenie regularne, które używa potwierdzenia wyszukiwania o zerowej szerokości na początku wyrażenia regularnego, aby dopasować wyrazy, które nie zaczynają się od "un".</span><span class="sxs-lookup"><span data-stu-id="8b935-414">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="8b935-415">Wyrażenie `\b(?!un)\w+\b` regularne jest interpretowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-415">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-416">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-416">Pattern</span></span>|<span data-ttu-id="8b935-417">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-417">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="8b935-418">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-418">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="8b935-419">Określ, czy następne dwa znaki są "un".</span><span class="sxs-lookup"><span data-stu-id="8b935-419">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="8b935-420">Jeśli tak nie jest, dopasowanie jest możliwe.</span><span class="sxs-lookup"><span data-stu-id="8b935-420">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="8b935-421">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-421">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="8b935-422">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-422">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="8b935-423">W poniższym przykładzie zdefiniowano wyrażenie regularne, które używa potwierdzenia wyszukiwania o zerowej szerokości na końcu wyrażenia regularnego, aby dopasować wyrazy, które nie kończą się znakiem interpunkcyjnym.</span><span class="sxs-lookup"><span data-stu-id="8b935-423">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="8b935-424">Wyrażenie `\b\w+\b(?!\p{P})` regularne jest interpretowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-424">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-425">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-425">Pattern</span></span>|<span data-ttu-id="8b935-426">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-426">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="8b935-427">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-427">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="8b935-428">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-428">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="8b935-429">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-429">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="8b935-430">Jeśli następny znak nie jest symbolem interpunkcyjnym (na przykład kropką lub przecinkiem), dopasowanie zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8b935-430">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="8b935-431">Dodatnie asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-431">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="8b935-432">Następująca konstrukcja grupowania definiuje potwierdzenie wyszukiwania dodatniego o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="8b935-432">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="8b935-433">`(?<=`*wyrażenie podrzędne*`)`</span><span class="sxs-lookup"><span data-stu-id="8b935-433">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="8b935-434">gdzie *wyrażenie podrzędne* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-434">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="8b935-435">Aby dopasowanie zakończyło się pomyślnie, *wyrażenie podrzędne* musi występować w `subexpression` ciągu wejściowym po lewej stronie bieżącej pozycji, chociaż nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="8b935-435">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="8b935-436">Zero-width dodatnie lookbehind potwierdzenia nie backtrack.</span><span class="sxs-lookup"><span data-stu-id="8b935-436">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="8b935-437">Zero-width dodatnie lookbehind potwierdzeń są zwykle używane na początku wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="8b935-437">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="8b935-438">Wzorzec, który definiują jest warunkiem wstępnym dla dopasowania, chociaż nie jest częścią wyniku meczu.</span><span class="sxs-lookup"><span data-stu-id="8b935-438">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="8b935-439">Na przykład poniższy przykład pasuje do dwóch ostatnich cyfr roku dla dwudziestego pierwszego wieku (oznacza to, że wymaga, aby cyfry "20" poprzedzały dopasowany ciąg).</span><span class="sxs-lookup"><span data-stu-id="8b935-439">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="8b935-440">Wzorzec `(?<=\b20)\d{2}\b` wyrażenia regularnego jest interpretowany w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-440">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-441">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-441">Pattern</span></span>|<span data-ttu-id="8b935-442">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-442">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="8b935-443">Dopasuj dwie cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="8b935-443">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="8b935-444">Kontynuuj dopasowanie, jeśli dwie cyfry dziesiętne są poprzedzone cyframi dziesiętnymi "20" na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-444">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="8b935-445">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-445">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="8b935-446">Potwierdzenia dodatnie o zerowej szerokości są również używane do ograniczania wycofywania, gdy ostatni znak lub znaki w przechwyconej grupie muszą być podzbiorem znaków, które pasują do wzorca wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-446">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="8b935-447">Na przykład jeśli grupa przechwytuje wszystkie kolejne znaki wyrazu, można użyć potwierdzenia widoku dodatniego o zerowej szerokości, aby wymagać, aby ostatni znak był alfabetyczny.</span><span class="sxs-lookup"><span data-stu-id="8b935-447">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="8b935-448">Ujemne asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="8b935-448">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="8b935-449">Następująca konstrukcja grupowania definiuje potwierdzenie ujemnego lookbehind o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="8b935-449">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="8b935-450">`(?<!`*wyrażenie podrzędne*`)`</span><span class="sxs-lookup"><span data-stu-id="8b935-450">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="8b935-451">gdzie *wyrażenie podrzędne* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-451">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="8b935-452">Aby dopasowanie zakończyło się pomyślnie, *wyrażenie podrzędne* nie może występować w ciągu wejściowym po lewej stronie bieżącej pozycji.</span><span class="sxs-lookup"><span data-stu-id="8b935-452">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="8b935-453">Jednak każdy podciąg, który `subexpression` nie jest zgodny, nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="8b935-453">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="8b935-454">Zero szerokości negatywnych lookbehind potwierdzeń są zwykle używane na początku wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="8b935-454">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="8b935-455">Wzorzec, który definiują wyklucza dopasowanie w ciągu, który następuje.</span><span class="sxs-lookup"><span data-stu-id="8b935-455">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="8b935-456">Są one również używane do ograniczania wycofywania, gdy ostatni znak lub znaki w przechwyconej grupie nie mogą być co najmniej jedną z znaków, które pasują do wzorca wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="8b935-456">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="8b935-457">Na przykład jeśli grupa przechwytuje wszystkie kolejne znaki wyrazu, można użyć potwierdzenia widoku dodatniego o zerowej szerokości, aby wymagać, aby ostatni znak nie był znakiem podkreślenia (\_).</span><span class="sxs-lookup"><span data-stu-id="8b935-457">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (\_).</span></span>  
  
 <span data-ttu-id="8b935-458">Poniższy przykład pasuje do daty dla każdego dnia tygodnia, który nie jest weekendem (to nie jest ani sobota, ani niedziela).</span><span class="sxs-lookup"><span data-stu-id="8b935-458">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="8b935-459">Wzorzec `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` wyrażenia regularnego jest interpretowany w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-459">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-460">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-460">Pattern</span></span>|<span data-ttu-id="8b935-461">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-461">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="8b935-462">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-462">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="8b935-463">Dopasuj jeden lub więcej znaków wyrazu, po których następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="8b935-463">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="8b935-464">Dopasuj jedną lub dwie cyfry dziesiętne, po których następuje znak odstępu i przecinek.</span><span class="sxs-lookup"><span data-stu-id="8b935-464">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="8b935-465">Dopasuj cztery cyfry dziesiętne i zakończ dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-465">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="8b935-466">Jeśli mecz jest poprzedzony czymś innym niż ciągi "sobota" lub "niedziela", po którym następuje spacja, dopasowanie zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8b935-466">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="atomic_groups"></a>
## <a name="atomic-groups"></a><span data-ttu-id="8b935-467">Grupy atomowe</span><span class="sxs-lookup"><span data-stu-id="8b935-467">Atomic groups</span></span>  
 <span data-ttu-id="8b935-468">Następująca konstrukcja grupowania reprezentuje grupę atomową (znaną w niektórych innych aparatach wyrażeń regularnych jako podwyrażenie niezwrotne, podwyrażenie atomowe lub podwyrażenie tylko raz):</span><span class="sxs-lookup"><span data-stu-id="8b935-468">The following grouping construct represents an atomic group (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression):</span></span>
  
 <span data-ttu-id="8b935-469">`(?>`*wyrażenie podrzędne*`)`</span><span class="sxs-lookup"><span data-stu-id="8b935-469">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="8b935-470">gdzie *wyrażenie podrzędne* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="8b935-470">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="8b935-471">Zwykle, jeśli wyrażenie regularne zawiera opcjonalny lub alternatywny wzorc dopasowania i dopasowania nie powiedzie się, aparat wyrażeń regularnych można rozgałęzić w wielu kierunkach, aby dopasować ciąg wejściowy do wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-471">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="8b935-472">Jeśli dopasowanie nie zostanie znaleziony, gdy trwa pierwszej gałęzi, aparat wyrażeń regularnych można z powrotem lub backtrack do punktu, w którym miało pierwsze dopasowanie i spróbuj dopasować przy użyciu drugiej gałęzi.</span><span class="sxs-lookup"><span data-stu-id="8b935-472">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="8b935-473">Ten proces może być kontynuowany, dopóki wszystkie gałęzie nie zostaną wypróbowane.</span><span class="sxs-lookup"><span data-stu-id="8b935-473">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="8b935-474">Konstrukcja `(?>`języka *podwyrażenia* `)` wyłącza wycofywanie.</span><span class="sxs-lookup"><span data-stu-id="8b935-474">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="8b935-475">Aparat wyrażeń regularnych będzie pasować do tylu znaków w ciągu wejściowym, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="8b935-475">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="8b935-476">Gdy nie ma możliwości dalszego dopasowania, nie cofa się, aby próbować alternatywnych dopasowań wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-476">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="8b935-477">(Oznacza to, że wyrażenie podrzędne pasuje tylko do ciągów, które byłyby dopasowane przez wyrażenie podrzędne samodzielnie; nie próbuje dopasować ciąg oparty na wyrażeniu podrzędnym i wszelkich wyrażeniach podrzędnych, które następują po nim.)</span><span class="sxs-lookup"><span data-stu-id="8b935-477">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="8b935-478">Ta opcja jest zalecana, jeśli wiesz, że wycofywanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="8b935-478">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="8b935-479">Uniemożliwienie aparatowi wyrażeń regularnych wykonywania niepotrzebnego wyszukiwania zwiększa wydajność.</span><span class="sxs-lookup"><span data-stu-id="8b935-479">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="8b935-480">W poniższym przykładzie przedstawiono sposób, w jaki grupa atomowa modyfikuje wyniki dopasowania wzorca.</span><span class="sxs-lookup"><span data-stu-id="8b935-480">The following example illustrates how an atomic group modifies the results of a pattern match.</span></span> <span data-ttu-id="8b935-481">Wycofywanie wyrażenia regularnego pomyślnie pasuje do serii powtarzających się znaków, po których następuje jeszcze jedno wystąpienie tego samego znaku na granicy słowa, ale niecofanie wyrażenia regularnego nie.</span><span class="sxs-lookup"><span data-stu-id="8b935-481">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="8b935-482">Wyrażenie `(?>(\w)\1+).\b` regularne nonbacktracking jest zdefiniowane w sposób pokazany w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-482">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-483">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-483">Pattern</span></span>|<span data-ttu-id="8b935-484">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-484">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="8b935-485">Dopasuj pojedynczy znak wyrazu i przypisz go do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-485">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="8b935-486">Dopasuj wartość pierwszego przechwyconego podciągu jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="8b935-486">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="8b935-487">Dopasuj dowolny znak.</span><span class="sxs-lookup"><span data-stu-id="8b935-487">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="8b935-488">Zakończ dopasowanie na granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-488">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="8b935-489">Dopasuj jedno lub więcej wystąpień zduplikowanego znaku wyrazu, ale nie cofaj się, aby dopasować ostatni znak na granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-489">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="8b935-490">Konstrukty grupujące i obiekty wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="8b935-490">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="8b935-491">Podciągi, które są dopasowane przez grupę przechwytywania <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> wyrażenia regularnego są reprezentowane przez <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> obiekty, które mogą <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> być pobierane z obiektu, który jest zwracany przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="8b935-491">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8b935-492">Obiekt <xref:System.Text.RegularExpressions.GroupCollection> jest wypełniany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8b935-492">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="8b935-493">Pierwszy <xref:System.Text.RegularExpressions.Group> obiekt w kolekcji (obiekt na indeksie zero) reprezentuje całe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="8b935-493">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="8b935-494">Następny zestaw <xref:System.Text.RegularExpressions.Group> obiektów reprezentuje nienazwane (numerowane) grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-494">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="8b935-495">Pojawiają się one w kolejności, w jakiej są zdefiniowane w wyrażeniu regularnym, od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="8b935-495">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="8b935-496">Wartości indeksu tych grup wahają się od 1 do liczby nienazwanych grup przechwytywania w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="8b935-496">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="8b935-497">(Indeks określonej grupy jest odpowiednikiem jego numerowane odwołanie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="8b935-497">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="8b935-498">Aby uzyskać więcej informacji na temat odwołań wstecznych, zobacz [Backreference Konstrukcje](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="8b935-498">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="8b935-499">Ostateczny zestaw <xref:System.Text.RegularExpressions.Group> obiektów reprezentuje nazwane grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-499">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="8b935-500">Pojawiają się one w kolejności, w jakiej są zdefiniowane w wyrażeniu regularnym, od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="8b935-500">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="8b935-501">Wartość indeksu pierwszej nazwanej grupy przechwytywania jest większa niż indeks ostatniej nienazwanej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-501">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="8b935-502">Jeśli w wyrażeniu regularnym nie ma żadnych nienazwanych grup przechwytywania, wartość indeksu pierwszej nazwanej grupy przechwytywania jest jedną z nich.</span><span class="sxs-lookup"><span data-stu-id="8b935-502">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="8b935-503">Jeśli kwantyfikator zostanie zastosowany do <xref:System.Text.RegularExpressions.Group> grupy <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>przechwytywania, odpowiedni obiekt , <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>i <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> właściwości odzwierciedlają ostatni podciąg, który jest przechwytywany przez grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-503">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="8b935-504">Można pobrać kompletny zestaw podciągów, które są przechwytywane przez <xref:System.Text.RegularExpressions.CaptureCollection> grupy, które mają <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kwantyfikatory z obiektu, który jest zwracany przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="8b935-504">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="8b935-505">Poniższy przykład wyjaśnia relację <xref:System.Text.RegularExpressions.Group> między <xref:System.Text.RegularExpressions.Capture> obiektami i.</span><span class="sxs-lookup"><span data-stu-id="8b935-505">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="8b935-506">Wzorzec `(\b(\w+)\W+)+` wyrażenia regularnego wyodrębnia poszczególne wyrazy z ciągu.</span><span class="sxs-lookup"><span data-stu-id="8b935-506">The regular expression pattern `(\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="8b935-507">Definicję tego wyrażenia pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8b935-507">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="8b935-508">Wzorce</span><span class="sxs-lookup"><span data-stu-id="8b935-508">Pattern</span></span>|<span data-ttu-id="8b935-509">Opis</span><span class="sxs-lookup"><span data-stu-id="8b935-509">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="8b935-510">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="8b935-510">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="8b935-511">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="8b935-511">Match one or more word characters.</span></span> <span data-ttu-id="8b935-512">Razem te znaki tworzą słowo.</span><span class="sxs-lookup"><span data-stu-id="8b935-512">Together, these characters form a word.</span></span> <span data-ttu-id="8b935-513">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-513">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="8b935-514">Dopasuj jeden lub więcej znaków innych niż word.</span><span class="sxs-lookup"><span data-stu-id="8b935-514">Match one or more non-word characters.</span></span>|  
|`(\b(\w+)\W+)`|<span data-ttu-id="8b935-515">Dopasuj wzorzec jednego lub więcej znaków wyrazu, po którym następuje jeden lub więcej znaków innych niż word jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="8b935-515">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="8b935-516">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-516">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="8b935-517">Druga grupa przechwytywania pasuje do każdego słowa zdania.</span><span class="sxs-lookup"><span data-stu-id="8b935-517">The second capturing group matches each word of the sentence.</span></span> <span data-ttu-id="8b935-518">Pierwsza grupa przechwytywania pasuje do każdego wyrazu wraz z znakiem interpunkcyjnym i białym znakiem, które następują po słowie.</span><span class="sxs-lookup"><span data-stu-id="8b935-518">The first capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="8b935-519">Obiekt, <xref:System.Text.RegularExpressions.Group> którego indeks ma 2 zawiera informacje o tekście dopasowanym przez drugą grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="8b935-519">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="8b935-520">Kompletny zestaw słów przechwyconych przez <xref:System.Text.RegularExpressions.CaptureCollection> grupę przechwytywania są <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> dostępne z obiektu zwróconego przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="8b935-520">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8b935-521">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="8b935-521">See also</span></span>

- [<span data-ttu-id="8b935-522">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="8b935-522">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="8b935-523">Nawracanie</span><span class="sxs-lookup"><span data-stu-id="8b935-523">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
