---
title: Konstrukcje grupujące w wyrażeniach regularnych
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 2aa7c35ebc06fb67d9cf6216233d2bed65ae76ab
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61789275"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="a7e74-102">Konstrukcje grupujące w wyrażeniach regularnych</span><span class="sxs-lookup"><span data-stu-id="a7e74-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="a7e74-103">Konstrukcje grupujące odróżnić podwyrażenia wyrażeń regularnych i przechwytywane podciągi ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="a7e74-104">Można użyć konstrukcji grupowania, wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="a7e74-104">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="a7e74-105">Dopasowuje Wyrażenie cząstkowe powtarzające się w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-105">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="a7e74-106">Zastosować kwantyfikator do podwyrażenia, który ma wiele elementów języka wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="a7e74-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="a7e74-107">Aby uzyskać więcej informacji na temat Kwantyfikatory zobacz [Kwantyfikatory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="a7e74-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="a7e74-108">Dołączyć ciąg, który jest zwracany przez wyrażenie cząstkowe <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a7e74-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="a7e74-109">Pobierz poszczególne podwyrażenia z <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości i przetwarzać je oddzielnie od dopasowany tekst jako całości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="a7e74-110">W poniższej tabeli wymieniono konstrukcje grupujące obsługiwane przez aparat wyrażeń regularnych platformy .NET i wskazuje, czy są one przechwytywania lub nieprzechwytujące.</span><span class="sxs-lookup"><span data-stu-id="a7e74-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="a7e74-111">Konstrukcja grupująca</span><span class="sxs-lookup"><span data-stu-id="a7e74-111">Grouping construct</span></span>|<span data-ttu-id="a7e74-112">Przechwytywania lub niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="a7e74-113">Matched subexpressions</span><span class="sxs-lookup"><span data-stu-id="a7e74-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="a7e74-114">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="a7e74-114">Capturing</span></span>|  
|[<span data-ttu-id="a7e74-115">O nazwie dopasowane podwyrażenia</span><span class="sxs-lookup"><span data-stu-id="a7e74-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="a7e74-116">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="a7e74-116">Capturing</span></span>|  
|[<span data-ttu-id="a7e74-117">Równoważenie definicji grup</span><span class="sxs-lookup"><span data-stu-id="a7e74-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="a7e74-118">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="a7e74-118">Capturing</span></span>|  
|[<span data-ttu-id="a7e74-119">Grupy niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="a7e74-120">Niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-120">Noncapturing</span></span>|  
|[<span data-ttu-id="a7e74-121">Wyświetlone są opcje grupy</span><span class="sxs-lookup"><span data-stu-id="a7e74-121">Group options</span></span>](#group_options)|<span data-ttu-id="a7e74-122">Niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-122">Noncapturing</span></span>|  
|[<span data-ttu-id="a7e74-123">Potwierdzenia pozytywna asercja wyprzedzająca o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="a7e74-124">Niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-124">Noncapturing</span></span>|  
|[<span data-ttu-id="a7e74-125">Potwierdzenia negatywna asercja wyprzedzająca o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="a7e74-126">Niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-126">Noncapturing</span></span>|  
|[<span data-ttu-id="a7e74-127">Potwierdzenia dodatnie asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="a7e74-128">Niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-128">Noncapturing</span></span>|  
|[<span data-ttu-id="a7e74-129">Potwierdzenia negatywna asercja wsteczna o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="a7e74-130">Niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-130">Noncapturing</span></span>|  
|[<span data-ttu-id="a7e74-131">Podwyrażenia bez nawrotów</span><span class="sxs-lookup"><span data-stu-id="a7e74-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="a7e74-132">Niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="a7e74-133">Aby uzyskać informacje na temat grup i model obiektów wyrażeń regularnych, zobacz [konstrukty grupujące i obiekty wyrażeń regularnych](#Objects).</span><span class="sxs-lookup"><span data-stu-id="a7e74-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="a7e74-134">Dopasowane podwyrażenie</span><span class="sxs-lookup"><span data-stu-id="a7e74-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="a7e74-135">Następujące konstrukcja grupująca przechwytuje dopasowane Podwyrażenie:</span><span class="sxs-lookup"><span data-stu-id="a7e74-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="a7e74-136">`(` *Podwyrażenie* `)`</span><span class="sxs-lookup"><span data-stu-id="a7e74-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="a7e74-137">gdzie *Podwyrażenie* jest wzorzec dowolnym prawidłowym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="a7e74-138">Rejestruje, że Użyj nawiasów są numerowane automatycznie od lewej do prawej, na podstawie kolejności nawiasów otwierających w wyrażeniu regularnym, zaczynając od jednego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="a7e74-139">Przechwytywanie, który wynosi zero numerowane jest tekst pasuje wzorzec całego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7e74-140">Domyślnie `(` *Podwyrażenie* `)` element języka przechwytuje dopasowane Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="a7e74-141">Ale w tym przypadku <xref:System.Text.RegularExpressions.RegexOptions> parametr metody dopasowania do wzorca wyrażenia regularnego zawiera <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flagi, lub jeśli `n` opcja jest stosowana do tego podwyrażenia (zobacz [grupie Opcje](#group_options) w dalszej części tego tematu), dopasowane Podwyrażenie nie są przechwytywane.</span><span class="sxs-lookup"><span data-stu-id="a7e74-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="a7e74-142">Aby uzyskać dostęp przechwyconych grupach na cztery sposoby:</span><span class="sxs-lookup"><span data-stu-id="a7e74-142">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="a7e74-143">Za pomocą dopasowywania wstecznego skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="a7e74-144">Dopasowane Podwyrażenie o której mowa w tym samym wyrażeniu regularnym przy użyciu składni `\` *numer*, gdzie *numer* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="a7e74-145">Za pomocą nazwane dopasowanie wsteczne skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="a7e74-146">Dopasowane Podwyrażenie o której mowa w tym samym wyrażeniu regularnym przy użyciu składni `\k<` *nazwa*`>`, gdzie *nazwa* to nazwa grupy przechwytywania, lub `\k<` *numer*`>`, gdzie *numer* jest numerem porządkowym grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="a7e74-147">Grupa przechwytywania ma domyślną nazwę, która jest taka sama na odpowiadającą mu liczbę porządkową.</span><span class="sxs-lookup"><span data-stu-id="a7e74-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="a7e74-148">Aby uzyskać więcej informacji, zobacz [o nazwie dopasowane podwyrażenia](#named_matched_subexpression) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="a7e74-149">Za pomocą `$` *numer* sekwencji zastąpienia w <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> wywołania metody, gdzie *numer* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="a7e74-150">Programowo, za pomocą <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a7e74-151">Element członkowski w pozycji zero w kolekcji reprezentuje dopasowanie całego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="a7e74-152">Każdy członek kolejnych reprezentuje dopasowane Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="a7e74-153">Aby uzyskać więcej informacji, zobacz [Grouping Constructs i obiekty wyrażeń regularnych](#Objects) sekcji.</span><span class="sxs-lookup"><span data-stu-id="a7e74-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="a7e74-154">W poniższym przykładzie pokazano wyrażenie regularne, który identyfikuje zduplikowane wyrazy w tekście.</span><span class="sxs-lookup"><span data-stu-id="a7e74-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="a7e74-155">Wzorzec wyrażenia regularnego dwie grupy przechwytywania reprezentują dwa wystąpienia zduplikowane programu word.</span><span class="sxs-lookup"><span data-stu-id="a7e74-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="a7e74-156">Drugie wystąpienie ciągu są przechwytywane do zgłaszania jego pozycję początkową w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="a7e74-157">Definicję wzorca wyrażenia regularnego jest następująca:</span><span class="sxs-lookup"><span data-stu-id="a7e74-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="a7e74-158">W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.</span><span class="sxs-lookup"><span data-stu-id="a7e74-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="a7e74-159">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-159">Pattern</span></span>|<span data-ttu-id="a7e74-160">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="a7e74-161">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-161">Match one or more word characters.</span></span> <span data-ttu-id="a7e74-162">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="a7e74-163">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="a7e74-164">Pasuje do ciągu w pierwszej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-164">Match the string in the first captured group.</span></span> <span data-ttu-id="a7e74-165">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-165">This is the second capturing group.</span></span> <span data-ttu-id="a7e74-166">Przykład przypisuje go do przechwyconej grupy tak, że pozycja początkowa zduplikowane wyrazu mogą być pobierane z `Match.Index` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="a7e74-167">Dopasowuje znak niebędące znakami słowa, w tym białych znaków i znaków interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="a7e74-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="a7e74-168">Zapobiega to dopasowania wyrazu, który rozpoczyna się od słowa z pierwszej przechwyconej grupy wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="a7e74-169">O nazwie dopasowane podwyrażenia</span><span class="sxs-lookup"><span data-stu-id="a7e74-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="a7e74-170">Następujące konstrukcja grupująca przechwytuje dopasowane Podwyrażenie i pozwala uzyskiwać dostęp do według nazwy lub numeru:</span><span class="sxs-lookup"><span data-stu-id="a7e74-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="a7e74-171">lub:</span><span class="sxs-lookup"><span data-stu-id="a7e74-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="a7e74-172">gdzie *nazwa* jest nazwą prawidłowej grupy i *Podwyrażenie* jest wzorzec dowolnym prawidłowym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="a7e74-173">*Nazwa* nie może zawierać żadnych znaków interpunkcyjnych i nie może zaczynać się liczbą.</span><span class="sxs-lookup"><span data-stu-id="a7e74-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7e74-174">Jeśli <xref:System.Text.RegularExpressions.RegexOptions> parametr metody dopasowania do wzorca wyrażenia regularnego zawiera <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flagi, lub jeśli `n` opcja jest stosowana do tego podwyrażenia (zobacz [grupie Opcje](#group_options) w dalszej części tego tematu), tylko Aby Przechwyć Podwyrażenie należy jawnie nazwę grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="a7e74-175">Nazwane przechwyconych grupach można uzyskać dostęp, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a7e74-175">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="a7e74-176">Za pomocą nazwane dopasowanie wsteczne skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="a7e74-177">Dopasowane Podwyrażenie o której mowa w tym samym wyrażeniu regularnym przy użyciu składni `\k<` *nazwa*`>`, gdzie *nazwa* nazywa się przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="a7e74-178">Za pomocą dopasowywania wstecznego skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="a7e74-179">Dopasowane Podwyrażenie o której mowa w tym samym wyrażeniu regularnym przy użyciu składni `\` *numer*, gdzie *numer* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="a7e74-180">O nazwie dopasowane podwyrażenia są numerowane kolejno od lewej do prawej po dopasowane podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="a7e74-181">Przy użyciu `${` *nazwa* `}` sekwencji zastąpienia w <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> wywołania metody, gdzie *nazwa* nazywa się przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="a7e74-182">Za pomocą `$` *numer* sekwencji zastąpienia w <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> wywołania metody, gdzie *numer* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="a7e74-183">Programowo, za pomocą <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a7e74-184">Element członkowski w pozycji zero w kolekcji reprezentuje dopasowanie całego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="a7e74-185">Każdy członek kolejnych reprezentuje dopasowane Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="a7e74-186">Nazwane przechwyconej grupy są przechowywane w kolekcji po numerowane przechwyconych grupach.</span><span class="sxs-lookup"><span data-stu-id="a7e74-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="a7e74-187">Programowo, podając nazwę Podwyrażenie do <xref:System.Text.RegularExpressions.GroupCollection> indeksatora obiektu (w języku C#) lub jego <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> właściwości (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a7e74-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="a7e74-188">Wzorzec wyrażenia regularnego proste ilustruje sposób ponumerowane (bez nazwy) i nazwanych grup mogą być przywoływane programowo lub za pomocą składni języka wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="a7e74-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="a7e74-189">Wyrażenie regularne `((?<One>abc)\d+)?(?<Two>xyz)(.*)` generuje następujące przechwytywania grupy według numeru i według nazwy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="a7e74-190">Pierwsza grupa (liczba 0) przechwytywania zawsze odwołuje się do całego wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="a7e74-191">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="a7e74-191">Number</span></span>|<span data-ttu-id="a7e74-192">Nazwa</span><span class="sxs-lookup"><span data-stu-id="a7e74-192">Name</span></span>|<span data-ttu-id="a7e74-193">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="a7e74-194">0</span><span class="sxs-lookup"><span data-stu-id="a7e74-194">0</span></span>|<span data-ttu-id="a7e74-195">0 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="a7e74-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="a7e74-196">1</span><span class="sxs-lookup"><span data-stu-id="a7e74-196">1</span></span>|<span data-ttu-id="a7e74-197">1 (domyślna nazwa)</span><span class="sxs-lookup"><span data-stu-id="a7e74-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="a7e74-198">2</span><span class="sxs-lookup"><span data-stu-id="a7e74-198">2</span></span>|<span data-ttu-id="a7e74-199">2 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="a7e74-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="a7e74-200">3</span><span class="sxs-lookup"><span data-stu-id="a7e74-200">3</span></span>|<span data-ttu-id="a7e74-201">Jeden</span><span class="sxs-lookup"><span data-stu-id="a7e74-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="a7e74-202">4</span><span class="sxs-lookup"><span data-stu-id="a7e74-202">4</span></span>|<span data-ttu-id="a7e74-203">Dwa</span><span class="sxs-lookup"><span data-stu-id="a7e74-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="a7e74-204">W poniższym przykładzie pokazano wyrażenie regularne, który identyfikuje zduplikowanych słów i word, który poprzedza każdy wyraz zduplikowane.</span><span class="sxs-lookup"><span data-stu-id="a7e74-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="a7e74-205">Wzorzec wyrażenia regularnego definiuje dwa podwyrażenia o nazwie: `duplicateWord`, która reprezentuje zduplikowany word; i `nextWord`, która reprezentuje wyrazu, który następuje po zduplikowane programu word.</span><span class="sxs-lookup"><span data-stu-id="a7e74-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="a7e74-206">Definicję wzorca wyrażenia regularnego jest następująca:</span><span class="sxs-lookup"><span data-stu-id="a7e74-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="a7e74-207">W poniższej tabeli przedstawiono, jak wyrażenia regularnego jest interpretowany.</span><span class="sxs-lookup"><span data-stu-id="a7e74-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="a7e74-208">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-208">Pattern</span></span>|<span data-ttu-id="a7e74-209">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="a7e74-210">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-210">Match one or more word characters.</span></span> <span data-ttu-id="a7e74-211">Określ nazwę tej grupy przechwytywania `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="a7e74-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="a7e74-212">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="a7e74-213">Pasuje do ciągu z przechwyconej grupy, który nosi nazwę `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="a7e74-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="a7e74-214">Dopasowuje znak niebędące znakami słowa, w tym białych znaków i znaków interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="a7e74-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="a7e74-215">Zapobiega to dopasowania wyrazu, który rozpoczyna się od słowa z pierwszej przechwyconej grupy wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="a7e74-216">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-216">Match one or more word characters.</span></span> <span data-ttu-id="a7e74-217">Określ nazwę tej grupy przechwytywania `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="a7e74-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="a7e74-218">Należy pamiętać, że nazwa grupy można powtarzać w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="a7e74-219">Na przykład, istnieje możliwość przez więcej niż jednej grupy, można go nazwać `digit`, tak jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="a7e74-220">W przypadku takich samych nazwach wartość <xref:System.Text.RegularExpressions.Group> obiekt jest określany przez ostatnie pomyślne przechwytywania w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="a7e74-221">Ponadto <xref:System.Text.RegularExpressions.CaptureCollection> jest wypełniana przy użyciu informacji o każdym przechwytywania tak, jak możesz ją, jeśli nie została zduplikowana nazwa grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="a7e74-222">W poniższym przykładzie, wyrażenie regularne `\D+(?<digit>\d+)\D+(?<digit>\d+)?` obejmuje dwa wystąpienia grupę o nazwie `digit`.</span><span class="sxs-lookup"><span data-stu-id="a7e74-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="a7e74-223">Pierwszy `digit` nazwanymi przechwytywaniami grupy co najmniej jeden znak cyfry.</span><span class="sxs-lookup"><span data-stu-id="a7e74-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="a7e74-224">Drugi `digit` nazwanej grupy przechwytywania zera lub jednego wystąpienia co najmniej jeden znak cyfry.</span><span class="sxs-lookup"><span data-stu-id="a7e74-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="a7e74-225">Jako dane wyjściowe w przykładzie pokazano, jeśli drugi przechwytywania pomyślnie grupy jest zgodna z tekstem, wartość ten tekst Określa wartość <xref:System.Text.RegularExpressions.Group> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="a7e74-226">Jeśli jest to druga grupa przechwytywania nie nie pasuje ciąg wejściowy wartość ostatniego pomyślnego dopasowania definiuje wartość <xref:System.Text.RegularExpressions.Group> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="a7e74-227">W poniższej tabeli przedstawiono, jak wyrażenia regularnego jest interpretowany.</span><span class="sxs-lookup"><span data-stu-id="a7e74-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="a7e74-228">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-228">Pattern</span></span>|<span data-ttu-id="a7e74-229">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="a7e74-230">Dopasowuje jeden lub więcej znaków niż cyfra niebędąca cyfrą dziesiętną.</span><span class="sxs-lookup"><span data-stu-id="a7e74-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="a7e74-231">Dopasowuje co najmniej jeden znak cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="a7e74-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="a7e74-232">Dopasowanie, aby przypisać `digit` o nazwie grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-232">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="a7e74-233">Dopasowuje jeden lub więcej znaków niż cyfra niebędąca cyfrą dziesiętną.</span><span class="sxs-lookup"><span data-stu-id="a7e74-233">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="a7e74-234">Dopasowanie zera lub jednego wystąpienia co najmniej jeden znak cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="a7e74-234">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="a7e74-235">Dopasowanie, aby przypisać `digit` o nazwie grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-235">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="a7e74-236">Równoważenie definicji grup</span><span class="sxs-lookup"><span data-stu-id="a7e74-236">Balancing Group Definitions</span></span>  
 <span data-ttu-id="a7e74-237">Definicję grupy równoważącej usuwa definicję wcześniej zdefiniowanej grupy i magazyny w bieżącej grupie, interwał pomiędzy wcześniej zdefiniowaną grupę i bieżącej grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-237">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="a7e74-238">Ta konstrukcja grupująca ma następujący format:</span><span class="sxs-lookup"><span data-stu-id="a7e74-238">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="a7e74-239">lub:</span><span class="sxs-lookup"><span data-stu-id="a7e74-239">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="a7e74-240">gdzie *Nazwa1* jest bieżącą grupę (opcjonalnie) *Nazwa2* jest wcześniej zdefiniowanej grupy i *Podwyrażenie* jest wzorzec dowolnym prawidłowym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-240">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="a7e74-241">Równoważenie definicji grup usuwa definicję *Nazwa2* i przechowuje odstęp między *Nazwa2* i *Nazwa1* w *Nazwa1*.</span><span class="sxs-lookup"><span data-stu-id="a7e74-241">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="a7e74-242">Jeśli nie *Nazwa2* grupy jest zdefiniowany, provided dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-242">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="a7e74-243">Ponieważ usuwanie ostatnia definicja *Nazwa2* poprzednią definicję, co spowoduje wyświetlenie *Nazwa2*, ta konstrukcja umożliwia używanie stosu przechwyconych obrazów dla grupy *Nazwa2* jako Licznik rejestrowanie informacji o zagnieżdżonej konstrukcji, takich jak nawiasy lub otwierające i zamykające nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="a7e74-243">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="a7e74-244">Równoważenie definicji grup używa *Nazwa2* jako stosu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-244">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="a7e74-245">Znak początku każdej zagnieżdżonej konstrukcji znajduje się w grupie, a w jego <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a7e74-245">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="a7e74-246">Po dopasowaniu znak zamykającego odpowiadającymi mu dostawcami otwierania znaków zostanie usunięty z grupy, a <xref:System.Text.RegularExpressions.Group.Captures%2A> kolekcji zmniejszyła się o jeden.</span><span class="sxs-lookup"><span data-stu-id="a7e74-246">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="a7e74-247">Po otwierającym i znaki zamknięcia wszystkich zagnieżdżonych konstrukcji dopasowane, *Nazwa1* jest pusty.</span><span class="sxs-lookup"><span data-stu-id="a7e74-247">After the opening and closing characters of all nested constructs have been matched, *name1* is empty.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7e74-248">Po użytkownik modyfikuje wyrażenia regularnego w poniższym przykładzie do użycia odpowiednie otwieranie i zamykanie znak zagnieżdżonej konstrukcji, służy do obsługi najbardziej zagnieżdżonej konstrukcji, takich jak wyrażenia matematyczne lub linii kodu programu, które zawierają wiele zagnieżdżonych wywołań metody.</span><span class="sxs-lookup"><span data-stu-id="a7e74-248">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="a7e74-249">W poniższym przykładzie użyto definicję grupy równoważącej, aby dopasować lewy i prawy nawias nawiasów kwadratowych (<>) w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-249">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="a7e74-250">W przykładzie zdefiniowano dwie grupy nazwane `Open` i `Close`, które są używane jak stos do śledzenia pary pasujące nawiasy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-250">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="a7e74-251">Każdy przechwyconych lewy nawias kątowy są przesyłane do przechwytywania zbiór `Open` grupy i wszystkich przechwyconych prawy nawias kątowy są przesyłane do przechwytywania zbiór `Close` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-251">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="a7e74-252">Równoważenie definicji grup gwarantuje, że jest pasujący nawias klamrowy pod kątem dla każdego lewego nawiasu ostrego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-252">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="a7e74-253">Jeśli nie, jest ostatnim podciąg wzorca, `(?(Open)(?!))`, jest oceniane tylko wtedy, gdy `Open` grupy nie jest pusty (a w związku z tym, jeśli wszystkie zagnieżdżone konstrukcje nie zostały zamknięte).</span><span class="sxs-lookup"><span data-stu-id="a7e74-253">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="a7e74-254">Jeśli nie zostało ocenione końcowego podciąg wzorca, dopasowanie zakończy się niepowodzeniem, ponieważ `(?!)` podciąg wzorca jest asercja negatywna asercja wyprzedzająca o zerowej szerokości, która zawsze kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="a7e74-254">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="a7e74-255">Definicję wzorca wyrażenia regularnego jest:</span><span class="sxs-lookup"><span data-stu-id="a7e74-255">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="a7e74-256">Wyrażenia regularnego jest interpretowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a7e74-256">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="a7e74-257">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-257">Pattern</span></span>|<span data-ttu-id="a7e74-258">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-258">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="a7e74-259">Rozpocznij na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-259">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="a7e74-260">Dopasowuje zero lub więcej znaków, które nie są po lewej stronie lub pod kątem nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="a7e74-260">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="a7e74-261">Zgodne z lewego nawiasu ostrego i przypisz je do grupy o nazwie `Open`.</span><span class="sxs-lookup"><span data-stu-id="a7e74-261">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="a7e74-262">Dopasowuje zero lub więcej znaków, które nie są po lewej stronie lub pod kątem nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="a7e74-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*) +`|<span data-ttu-id="a7e74-263">Dopasowuje jeden lub więcej wystąpień lewego nawiasu ostrego następuje zero lub więcej znaków, które nie są po lewej stronie lub pod kątem nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="a7e74-263">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="a7e74-264">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-264">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="a7e74-265">Prawy nawias kątowy odpowiada, należy przypisać podciąg między `Open` grupy i bieżącą grupą do `Close` grupy i usuń definicję `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-265">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="a7e74-266">Dopasowuje zero lub więcej wystąpień dowolnego znaku, który nie jest lewe ani prawy nawias kątowy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-266">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="a7e74-267">Dopasowuje jeden lub więcej wystąpień prawy nawias kątowy, następuje zero lub więcej wystąpień dowolnego znaku jest prawy nawias kątowy ani po lewej stronie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-267">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="a7e74-268">Podczas dopasowywania prawego nawiasu ostrego, przypisz podciąg między `Open` grupy i bieżącą grupą do `Close` grupy i usuń definicję `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-268">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="a7e74-269">Jest to trzecia grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-269">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="a7e74-270">Dopasowuje zero lub więcej wystąpień następującego wzorca: jeden lub więcej wystąpień lewego nawiasu ostrego następuje zero lub więcej znaków nawiasu ostrego następuje jeden lub więcej wystąpień prawy nawias kątowy, następuje zero lub więcej wystąpień inne niż nawiasy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-270">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="a7e74-271">Podczas dopasowywania prawego nawiasu ostrego, usuń definicję `Open` grupy, a następnie przypisz podciąg między `Open` grupy i bieżącą grupą do `Close` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-271">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="a7e74-272">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-272">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="a7e74-273">Jeśli `Open` grupa istnieje, Porzuć dopasowania, jeśli pusty ciąg, który można dopasować, ale nie Przejdź położenie aparat wyrażeń regularnych w ciągu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-273">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="a7e74-274">Jest to asercja negatywna asercja wyprzedzająca o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-274">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="a7e74-275">Ponieważ pusty ciąg jest zawsze niejawnie obecne w ciągu wejściowym, tym dopasowanie nie zawsze powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="a7e74-275">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="a7e74-276">Błąd dopasowania to wskazuje, że nawiasy nie są równoważone.</span><span class="sxs-lookup"><span data-stu-id="a7e74-276">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="a7e74-277">Dopasowuje koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-277">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="a7e74-278">Końcowe Podwyrażenie `(?(Open)(?!))`, wskazuje, czy zagnieżdżania tworzy się w ciągu wejściowym są prawidłowo równoważone, (na przykład, czy każdy lewego nawiasu ostrego dorównuje prawy nawias kątowy).</span><span class="sxs-lookup"><span data-stu-id="a7e74-278">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="a7e74-279">Używa ona dopasowanie warunkowe oparte na prawidłowo przechwyconych grupach; Aby uzyskać więcej informacji, zobacz [konstrukcje](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="a7e74-279">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="a7e74-280">Jeśli `Open` grupy jest zdefiniowany, aparat wyrażeń regularnych próbuje dopasować Podwyrażenie `(?!)` w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-280">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="a7e74-281">`Open` Grupy powinna być zdefiniowana tylko wtedy, gdy niezrównoważone konstrukcje zagnieżdżenia.</span><span class="sxs-lookup"><span data-stu-id="a7e74-281">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="a7e74-282">W związku z tym wzorzec, które mają zostać dopasowane w ciągu wejściowym powinna wynosić 1, który zawsze powoduje, że dopasowanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="a7e74-282">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="a7e74-283">W tym przypadku `(?!)` jest asercja negatywna asercja wyprzedzająca o zerowej szerokości która zawsze kończy się niepowodzeniem, ponieważ ciąg pusty występuje zawsze niejawnie w następnej pozycji w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-283">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="a7e74-284">W przykładzie, aparat wyrażeń regularnych ocenia ciągu wejściowego "\<abc >< mno\<xyz >>" jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-284">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-285">Krok</span><span class="sxs-lookup"><span data-stu-id="a7e74-285">Step</span></span>|<span data-ttu-id="a7e74-286">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-286">Pattern</span></span>|<span data-ttu-id="a7e74-287">Wynik</span><span class="sxs-lookup"><span data-stu-id="a7e74-287">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="a7e74-288">1</span><span class="sxs-lookup"><span data-stu-id="a7e74-288">1</span></span>|`^`|<span data-ttu-id="a7e74-289">Rozpoczyna dopasowanie na początku ciągu wejściowego</span><span class="sxs-lookup"><span data-stu-id="a7e74-289">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="a7e74-290">2</span><span class="sxs-lookup"><span data-stu-id="a7e74-290">2</span></span>|`[^<>]*`|<span data-ttu-id="a7e74-291">Wyszukuje nawiasu ostrego znaków przed lewego nawiasu ostrego; znajdzie żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="a7e74-291">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="a7e74-292">3</span><span class="sxs-lookup"><span data-stu-id="a7e74-292">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="a7e74-293">Pasuje do lewego nawiasu ostrego w "\<abc >" i przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-293">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="a7e74-294">4</span><span class="sxs-lookup"><span data-stu-id="a7e74-294">4</span></span>|`[^<>]*`|<span data-ttu-id="a7e74-295">Pasuje do "abc".</span><span class="sxs-lookup"><span data-stu-id="a7e74-295">Matches "abc".</span></span>|  
|<span data-ttu-id="a7e74-296">5</span><span class="sxs-lookup"><span data-stu-id="a7e74-296">5</span></span>|`)+`|<span data-ttu-id="a7e74-297">"< abc" jest wartością drugiego przechwyconą grupę.</span><span class="sxs-lookup"><span data-stu-id="a7e74-297">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="a7e74-298">Następny znak w ciągu wejściowym nie jest lewy nawias kątowy, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `(?'Open'<)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-298">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-299">6</span><span class="sxs-lookup"><span data-stu-id="a7e74-299">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="a7e74-300">Pasuje do prawego nawiasu ostrego w "\<abc >", "abc", czyli podciąg przypisuje między `Open` grupy i kąt prosty dopasowywanie do `Close` grupę, a następnie usuwa bieżącą wartość ("<") z `Open` grupy, zostawiać je puste.</span><span class="sxs-lookup"><span data-stu-id="a7e74-300">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="a7e74-301">7</span><span class="sxs-lookup"><span data-stu-id="a7e74-301">7</span></span>|`[^<>]*`|<span data-ttu-id="a7e74-302">Wyszukuje nawiasu ostrego znaków od prawego nawiasu ostrego; Umożliwia znalezienie żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="a7e74-302">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="a7e74-303">8</span><span class="sxs-lookup"><span data-stu-id="a7e74-303">8</span></span>|`)+`|<span data-ttu-id="a7e74-304">Wartość trzeciego przechwyconej grupy ">".</span><span class="sxs-lookup"><span data-stu-id="a7e74-304">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="a7e74-305">Następny znak w ciągu wejściowym nie jest prawy nawias kątowy, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `((?'Close-Open'>)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-305">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-306">9</span><span class="sxs-lookup"><span data-stu-id="a7e74-306">9</span></span>|`)*`|<span data-ttu-id="a7e74-307">Wartość pierwszej przechwyconej grupy "\<abc >".</span><span class="sxs-lookup"><span data-stu-id="a7e74-307">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="a7e74-308">Następny znak w ciągu wejściowym jest lewy nawias kątowy, dlatego aparat wyrażeń regularnych w pętli do `(((?'Open'<)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-308">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-309">10</span><span class="sxs-lookup"><span data-stu-id="a7e74-309">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="a7e74-310">Pasuje do lewego nawiasu ostrego w "\<mno >" i przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-310">Matches the left angle bracket in "\<mno>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="a7e74-311">Jego <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> teraz kolekcja zawiera pojedynczą wartość "<".</span><span class="sxs-lookup"><span data-stu-id="a7e74-311">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="a7e74-312">11</span><span class="sxs-lookup"><span data-stu-id="a7e74-312">11</span></span>|`[^<>]*`|<span data-ttu-id="a7e74-313">Dopasowuje "mno".</span><span class="sxs-lookup"><span data-stu-id="a7e74-313">Matches "mno".</span></span>|  
|<span data-ttu-id="a7e74-314">12</span><span class="sxs-lookup"><span data-stu-id="a7e74-314">12</span></span>|`)+`|<span data-ttu-id="a7e74-315">"< mno" jest wartością drugiego przechwyconą grupę.</span><span class="sxs-lookup"><span data-stu-id="a7e74-315">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="a7e74-316">Następny znak w ciągu wejściowym jest lewy nawias kątowy, dlatego aparat wyrażeń regularnych w pętli do `(?'Open'<)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-316">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-317">13</span><span class="sxs-lookup"><span data-stu-id="a7e74-317">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="a7e74-318">Pasuje do lewego nawiasu ostrego w "\<xyz >" i przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-318">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="a7e74-319"><xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> Zbiór `Open` grupy obejmuje teraz dwa przechwytywania: lewy nawias kątowy z "\<mno >" i lewego nawiasu ostrego z "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="a7e74-319">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno>", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="a7e74-320">14</span><span class="sxs-lookup"><span data-stu-id="a7e74-320">14</span></span>|`[^<>]*`|<span data-ttu-id="a7e74-321">Dopasowania "ciągu xyz".</span><span class="sxs-lookup"><span data-stu-id="a7e74-321">Matches "xyz".</span></span>|  
|<span data-ttu-id="a7e74-322">15</span><span class="sxs-lookup"><span data-stu-id="a7e74-322">15</span></span>|`)+`|<span data-ttu-id="a7e74-323">"< xyz" jest wartością drugiego przechwyconą grupę.</span><span class="sxs-lookup"><span data-stu-id="a7e74-323">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="a7e74-324">Następny znak w ciągu wejściowym nie jest lewy nawias kątowy, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `(?'Open'<)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-324">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-325">16</span><span class="sxs-lookup"><span data-stu-id="a7e74-325">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="a7e74-326">Pasuje do prawego nawiasu ostrego w "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="a7e74-326">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="a7e74-327">ciągu "xyz", przypisuje podciąg między `Open` grupy i kąt prosty dopasowywanie do `Close` grupę, a następnie usuwa bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-327">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="a7e74-328">Wartość poprzedniego przechwytywania (lewego nawiasu ostrego w "\<mno >") staje się bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-328">The value of the previous capture (the left angle bracket in "\<mno>") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="a7e74-329"><xref:System.Text.RegularExpressions.Group.Captures%2A> Zbiór `Open` grupa zawiera teraz pojedynczy przechwytywania, lewy nawias kątowy z "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="a7e74-329">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="a7e74-330">17</span><span class="sxs-lookup"><span data-stu-id="a7e74-330">17</span></span>|`[^<>]*`|<span data-ttu-id="a7e74-331">Wyszukuje nawiasu ostrego znaków. Umożliwia znalezienie żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="a7e74-331">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="a7e74-332">18</span><span class="sxs-lookup"><span data-stu-id="a7e74-332">18</span></span>|`)+`|<span data-ttu-id="a7e74-333">Wartość trzeciego przechwyconej grupy ">".</span><span class="sxs-lookup"><span data-stu-id="a7e74-333">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="a7e74-334">Następny znak w ciągu wejściowym jest prawy nawias kątowy, dlatego aparat wyrażeń regularnych w pętli do `((?'Close-Open'>)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-334">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-335">19</span><span class="sxs-lookup"><span data-stu-id="a7e74-335">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="a7e74-336">Pasuje do końcowego prawego nawiasu ostrego w "xyz >>", przypisuje "mno\<xyz >" (podciąg między `Open` grupy i prawego nawiasu ostrego) do `Close` grupę, a następnie usuwa bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-336">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="a7e74-337">`Open` Grupy jest obecnie pusta.</span><span class="sxs-lookup"><span data-stu-id="a7e74-337">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="a7e74-338">20</span><span class="sxs-lookup"><span data-stu-id="a7e74-338">20</span></span>|`[^<>]*`|<span data-ttu-id="a7e74-339">Wyszukuje nawiasu ostrego znaków. Umożliwia znalezienie żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="a7e74-339">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="a7e74-340">21</span><span class="sxs-lookup"><span data-stu-id="a7e74-340">21</span></span>|`)+`|<span data-ttu-id="a7e74-341">Wartość trzeciego przechwyconej grupy ">".</span><span class="sxs-lookup"><span data-stu-id="a7e74-341">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="a7e74-342">Następny znak w ciągu wejściowym nie jest prawy nawias kątowy, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `((?'Close-Open'>)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-342">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-343">22</span><span class="sxs-lookup"><span data-stu-id="a7e74-343">22</span></span>|`)*`|<span data-ttu-id="a7e74-344">Wartość pierwszej przechwyconej grupy "< mno\<xyz >>".</span><span class="sxs-lookup"><span data-stu-id="a7e74-344">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="a7e74-345">Następny znak w ciągu wejściowym nie jest lewy nawias kątowy, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `(((?'Open'<)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-345">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="a7e74-346">23</span><span class="sxs-lookup"><span data-stu-id="a7e74-346">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="a7e74-347">`Open` Grupy nie jest zdefiniowana, więc dopasowanie nie zostanie podjęta.</span><span class="sxs-lookup"><span data-stu-id="a7e74-347">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="a7e74-348">24</span><span class="sxs-lookup"><span data-stu-id="a7e74-348">24</span></span>|`$`|<span data-ttu-id="a7e74-349">Pasuje do końca ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-349">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="a7e74-350">Grupy niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="a7e74-350">Noncapturing Groups</span></span>  
 <span data-ttu-id="a7e74-351">Następujące konstrukcji grupowania nie przechwytuje podciągu, który pasuje podwyrażenia:</span><span class="sxs-lookup"><span data-stu-id="a7e74-351">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="a7e74-352">gdzie *Podwyrażenie* jest wzorzec dowolnym prawidłowym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-352">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="a7e74-353">Konstrukcja nieprzechwytywaną grupę zwykle jest używana, gdy do grupy jest stosowany kwantyfikator, ale podciągów przechwycone przez grupę są nie interesujące.</span><span class="sxs-lookup"><span data-stu-id="a7e74-353">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7e74-354">Wyrażenie regularne zawiera konstrukcje grupujące zagnieżdżonych, konstrukcja zewnętrzne nieprzechwytywaną grupę nie ma zastosowania do konstrukcji wewnętrzny grupach zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="a7e74-354">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="a7e74-355">W poniższym przykładzie pokazano wyrażenie regularne, które obejmuje grupy niezapamiętywane.</span><span class="sxs-lookup"><span data-stu-id="a7e74-355">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="a7e74-356">Należy pamiętać o tym, czy dane wyjściowe nie zawiera żadnych przechwyconych grupach.</span><span class="sxs-lookup"><span data-stu-id="a7e74-356">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="a7e74-357">Wyrażenie regularne `(?:\b(?:\w+)\W*)+\.` odpowiada zdania, który jest kończony kropką.</span><span class="sxs-lookup"><span data-stu-id="a7e74-357">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="a7e74-358">Ponieważ wyrażenie regularne skupia się na zdania, a nie na poszczególnych wyrazów, konstrukcje grupujące są używane wyłącznie jako Kwantyfikatory.</span><span class="sxs-lookup"><span data-stu-id="a7e74-358">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="a7e74-359">Wzorzec wyrażenia regularnego jest interpretowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-359">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-360">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-360">Pattern</span></span>|<span data-ttu-id="a7e74-361">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-361">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7e74-362">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-362">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="a7e74-363">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-363">Match one or more word characters.</span></span> <span data-ttu-id="a7e74-364">Nie należy przypisywać dopasowany tekst do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-364">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="a7e74-365">Dopasowuje zero lub więcej znaki niebędące znakami słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-365">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="a7e74-366">Dopasowuje wzorzec jednego lub więcej znaków słowa, uruchamiania na granicy wyrazu, po której następuje zero lub więcej znaki niebędące znakami słowa, jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-366">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="a7e74-367">Nie należy przypisywać dopasowany tekst do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-367">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="a7e74-368">Dopasowanie kropki.</span><span class="sxs-lookup"><span data-stu-id="a7e74-368">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="a7e74-369">Opcje grupy</span><span class="sxs-lookup"><span data-stu-id="a7e74-369">Group Options</span></span>  
 <span data-ttu-id="a7e74-370">Następujące konstrukcja grupująca stosuje lub wyłącza określone opcje w podwyrażeniu:</span><span class="sxs-lookup"><span data-stu-id="a7e74-370">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="a7e74-371">`(?imnsx-imnsx:` *Podwyrażenie* `)`</span><span class="sxs-lookup"><span data-stu-id="a7e74-371">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="a7e74-372">gdzie *Podwyrażenie* jest wzorzec dowolnym prawidłowym wyrażeniem regularnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-372">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="a7e74-373">Na przykład `(?i-s:)` włącza ignorowanie wielkości liter i wyłączenie trybu jednowierszowego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-373">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="a7e74-374">Aby uzyskać więcej informacji dotyczących opcji wbudowanej, można określić, zobacz [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="a7e74-374">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7e74-375">Można określić opcje, które mają zastosowanie do całego wyrażenia regularnego zamiast podwyrażenia przy użyciu <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> konstruktora klasy lub metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="a7e74-375">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="a7e74-376">Można również określić opcje określane w tekście, które są stosowane po określonego punktu w wyrażeniu regularnym przy użyciu `(?imnsx-imnsx)` konstrukcją języka pierwszej klasy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-376">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="a7e74-377">Konstrukcja opcje grupy nie jest grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-377">The group options construct is not a capturing group.</span></span> <span data-ttu-id="a7e74-378">Oznacza to mimo że jakiejkolwiek jego części ciągu, która jest przechwytywana przez *Podwyrażenie* wchodzi w dopasowanie, są nie zawarte w przechwyconej grupy ani używanych do wypełniania <xref:System.Text.RegularExpressions.GroupCollection> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-378">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="a7e74-379">Na przykład, wyrażenie regularne `\b(?ix: d \w+)\s` w poniższym przykładzie używa opcji wbudowanej w konstrukcję grupującą aby umożliwić dopasowanie bez uwzględniania wielkości liter i Ignorowanie wzorca odstępu przy określaniu wszystkie wyrazy rozpoczynające się od litera "d".</span><span class="sxs-lookup"><span data-stu-id="a7e74-379">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="a7e74-380">Wyrażenie regularne jest zdefiniowane, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-380">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-381">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-381">Pattern</span></span>|<span data-ttu-id="a7e74-382">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-382">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7e74-383">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-383">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="a7e74-384">Za pomocą dopasowanie bez uwzględniania wielkości liter i ignorowanie biały znak w tym wzorcu, dopasowuje "d", po której następuje jeden lub więcej znaków słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-384">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="a7e74-385">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-385">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="a7e74-386">Dodatnie asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-386">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="a7e74-387">Następujące konstrukcja grupująca definiuje asercja pozytywna asercja wyprzedzająca o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="a7e74-387">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="a7e74-388">`(?=` *Podwyrażenie* `)`</span><span class="sxs-lookup"><span data-stu-id="a7e74-388">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="a7e74-389">gdzie *Podwyrażenie* się wszelkie wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-389">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="a7e74-390">Dopasowanie zakończy się powodzeniem, ciąg wejściowy musi być zgodna ze wzorcem wyrażenia regularnego w *Podwyrażenie*, mimo że dopasowany podciąg nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-390">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="a7e74-391">Asercja pozytywna asercja wyprzedzająca o zerowej szerokości nie używa wycofywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-391">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="a7e74-392">Zazwyczaj asercja pozytywna asercja wyprzedzająca o zerowej szerokości znajduje się na końcu wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-392">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="a7e74-393">Definiuje podciąg, muszą znajdować się na końcu ciągu do aby wystąpiło dopasowanie, ale które nie powinny znajdować się dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-393">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="a7e74-394">Jest to również przydatne w celu zapobiegania nadmiernego wycofywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-394">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="a7e74-395">Asercja pozytywna asercja wyprzedzająca o zerowej szerokości można użyć, aby upewnić się, że określonego przechwyconej grupy rozpoczyna się od tekst, który pasuje do podzbioru wzorca określonego przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-395">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="a7e74-396">Na przykład jeśli grupa przechwytywania pasuje do słowa następujących po sobie znaków, umożliwia to asercja pozytywna asercja wyprzedzająca o zerowej szerokości wymagają pierwszym znakiem alfabetycznym, wielką literę.</span><span class="sxs-lookup"><span data-stu-id="a7e74-396">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="a7e74-397">Następujące przykładowe zastosowania asercja pozytywna asercja wyprzedzająca o zerowej szerokości, aby dopasować wyrazu, który poprzedza zlecenie "is" w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-397">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="a7e74-398">Wyrażenie regularne `\b\w+(?=\sis\b)` jest interpretowane tak jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-398">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-399">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-399">Pattern</span></span>|<span data-ttu-id="a7e74-400">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-400">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7e74-401">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-401">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="a7e74-402">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-402">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="a7e74-403">Określ, czy znaków słowa, których następuje znak odstępu lub ciąg "is", której kończy się na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-403">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="a7e74-404">Jeśli tak, dopasowanie zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-404">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="a7e74-405">Ujemne asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-405">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="a7e74-406">Następujące konstrukcja grupująca definiuje asercja negatywna asercja wyprzedzająca o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="a7e74-406">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="a7e74-407">`(?!` *Podwyrażenie* `)`</span><span class="sxs-lookup"><span data-stu-id="a7e74-407">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="a7e74-408">gdzie *Podwyrażenie* się wszelkie wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-408">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="a7e74-409">Dopasowanie zakończy się powodzeniem, ciąg wejściowy nie może odpowiadać wzorzec wyrażenia regularnego w *Podwyrażenie*, mimo że dopasowany ciąg nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-409">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="a7e74-410">Asercja negatywna asercja wyprzedzająca o zerowej szerokości, jest zazwyczaj używany na początku lub na końcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-410">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="a7e74-411">Na początku wyrażenia regularnego, ją zdefiniować określony wzorzec, które nie powinny być dopasowane, gdy na początku wyrażenia regularnego definiuje podobne, ale bardziej ogólnych wzorzec do dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-411">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="a7e74-412">W tym przypadku jest często używane do ograniczania wycofywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-412">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="a7e74-413">Na końcu wyrażenia regularnego ją zdefiniować Podwyrażenie, który nie może wystąpić na końcu dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-413">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="a7e74-414">W poniższym przykładzie zdefiniowano wyrażenie regularne, który używa asercja wyprzedzająca o zerowej szerokości na początku wyrażenia regularnego do dopasowania słów, które nie zaczynają się od "Uruchom".</span><span class="sxs-lookup"><span data-stu-id="a7e74-414">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="a7e74-415">Wyrażenie regularne `\b(?!un)\w+\b` jest interpretowane tak jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-415">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-416">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-416">Pattern</span></span>|<span data-ttu-id="a7e74-417">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-417">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7e74-418">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-418">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="a7e74-419">Określanie, czy następne dwa znaki są "Uruchom".</span><span class="sxs-lookup"><span data-stu-id="a7e74-419">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="a7e74-420">Jeśli nie są one dopasowanie jest możliwe.</span><span class="sxs-lookup"><span data-stu-id="a7e74-420">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="a7e74-421">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-421">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="a7e74-422">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-422">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="a7e74-423">W poniższym przykładzie zdefiniowano wyrażenie regularne, który używa asercja wyprzedzająca o zerowej szerokości na końcu wyrażenia regularnego do dopasowania słów, których nie kończy się znakiem interpunkcyjnym.</span><span class="sxs-lookup"><span data-stu-id="a7e74-423">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="a7e74-424">Wyrażenie regularne `\b\w+\b(?!\p{P})` jest interpretowane tak jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-424">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-425">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-425">Pattern</span></span>|<span data-ttu-id="a7e74-426">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-426">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7e74-427">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-427">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="a7e74-428">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-428">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="a7e74-429">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-429">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="a7e74-430">Jeśli następny znak nie jest symbolem interpunkcji (np. kropki lub przecinka), dopasowanie się powiedzie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-430">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="a7e74-431">Dodatnie asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-431">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="a7e74-432">Następujące konstrukcja grupująca definiuje potwierdzenia dodatnie asercje wsteczne o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="a7e74-432">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="a7e74-433">`(?<=` *Podwyrażenie* `)`</span><span class="sxs-lookup"><span data-stu-id="a7e74-433">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="a7e74-434">gdzie *Podwyrażenie* się wszelkie wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-434">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="a7e74-435">Aby dopasowanie zakończyło się zakończyć się pomyślnie *Podwyrażenie* musi przypadać w ciągu wejściowym na lewo od aktualnej pozycji, mimo że `subexpression` nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-435">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="a7e74-436">Asercja pozytywna asercja wsteczna o zerowej szerokości nie używa wycofywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-436">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="a7e74-437">Potwierdzenia dodatnie asercje wsteczne o zerowej szerokości są zwykle używane na początku wyrażenia regularne.</span><span class="sxs-lookup"><span data-stu-id="a7e74-437">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="a7e74-438">Wzorzec, który określają jest warunkiem wstępnym pod kątem dopasowania, chociaż nie jest częścią wyników dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-438">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="a7e74-439">Na przykład w poniższym przykładzie dopasowywane dwie ostatnie cyfry roku wieku dwudziestego pierwszego (czyli wymaga że cyfr "20" poprzedzać dopasowany ciąg).</span><span class="sxs-lookup"><span data-stu-id="a7e74-439">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="a7e74-440">Definicję wzorca wyrażenia regularnego `(?<=\b20)\d{2}\b` jest interpretowane tak jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-440">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-441">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-441">Pattern</span></span>|<span data-ttu-id="a7e74-442">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-442">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="a7e74-443">Dopasowuje dwie cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="a7e74-443">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="a7e74-444">Kontynuuje dopasowywanie, jeśli dwie cyfry dziesiętne są poprzedzone cyfr dziesiętnych "20" na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-444">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="a7e74-445">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-445">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="a7e74-446">Potwierdzenia dodatnie asercje wsteczne o zerowej szerokości są również używane do ograniczania wycofywania, gdy ostatni znak lub znaki w przechwyconej grupy muszą być podzbiorem znaków, które pasuje do wzorca wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-446">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="a7e74-447">Na przykład jeśli grupa przechwytywania wszystkich znaków słowa kolejnych, umożliwia asercja pozytywna asercja wsteczna o zerowej szerokości wymagać, aby ostatni znak alfabetyczny.</span><span class="sxs-lookup"><span data-stu-id="a7e74-447">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="a7e74-448">Ujemne asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="a7e74-448">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="a7e74-449">Następujące konstrukcja grupująca definiuje asercja negatywna asercja wsteczna o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="a7e74-449">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="a7e74-450">`(?<!` *Podwyrażenie* `)`</span><span class="sxs-lookup"><span data-stu-id="a7e74-450">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="a7e74-451">gdzie *Podwyrażenie* się wszelkie wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-451">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="a7e74-452">Aby dopasowanie zakończyło się zakończyć się pomyślnie *Podwyrażenie* nie może wystąpić w ciągu wejściowym na lewo od bieżącej pozycji.</span><span class="sxs-lookup"><span data-stu-id="a7e74-452">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="a7e74-453">Jednak podciąg, która pasuje do `subexpression` nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-453">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="a7e74-454">Negatywna asercja wsteczna o zerowej szerokości potwierdzenia są zwykle używane na początku wyrażenia regularne.</span><span class="sxs-lookup"><span data-stu-id="a7e74-454">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="a7e74-455">Wzorzec, który określają wykluczającą dopasowania w ciągu, który następuje.</span><span class="sxs-lookup"><span data-stu-id="a7e74-455">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="a7e74-456">Służą one również ograniczyć wycofywania, gdy ostatni znak lub znaki w przechwyconej grupy nie może być jeden lub więcej znaków, które pasują do wzorca wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-456">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="a7e74-457">Na przykład jeśli grupa przechwytywania wszystkich znaków słowa kolejnych, umożliwia to asercja pozytywna asercja wsteczna o zerowej szerokości wymagają ostatni znak nie znaku podkreślenia (_).</span><span class="sxs-lookup"><span data-stu-id="a7e74-457">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</span></span>  
  
 <span data-ttu-id="a7e74-458">W poniższym przykładzie dopasowywane Data dla każdego dnia, tygodnia, który nie jest weekendy (który jest sobota ani niedziela).</span><span class="sxs-lookup"><span data-stu-id="a7e74-458">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="a7e74-459">Definicję wzorca wyrażenia regularnego `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` jest interpretowane tak jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-459">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-460">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-460">Pattern</span></span>|<span data-ttu-id="a7e74-461">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-461">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7e74-462">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-462">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="a7e74-463">Dopasowuje co najmniej jeden znak słowa, następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-463">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="a7e74-464">Dopasowuje co najmniej dwie cyfry dziesiętne, następuje znak odstępu i przecinek.</span><span class="sxs-lookup"><span data-stu-id="a7e74-464">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="a7e74-465">Odpowiada czterem cyfrom po przecinku, a kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-465">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="a7e74-466">Jeśli dopasowanie jest poprzedzony przez coś innego niż ciągi, "Sobota" lub "Niedziela", po której następuje spacja, dopasowanie zakończy się.</span><span class="sxs-lookup"><span data-stu-id="a7e74-466">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="a7e74-467">Podwyrażenia bez nawrotów</span><span class="sxs-lookup"><span data-stu-id="a7e74-467">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="a7e74-468">Następujące konstrukcja grupująca reprezentuje Podwyrażenie (znany także jako Podwyrażenie "zachłanne"):</span><span class="sxs-lookup"><span data-stu-id="a7e74-468">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="a7e74-469">`(?>` *Podwyrażenie* `)`</span><span class="sxs-lookup"><span data-stu-id="a7e74-469">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="a7e74-470">gdzie *Podwyrażenie* się wszelkie wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="a7e74-470">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="a7e74-471">Normalnie Jeśli wyrażenie regularne zawiera opcjonalne lub alternatywne dopasowania wzorca i dopasowanie nie powiedzie się, aparat wyrażeń regularnych można rozgałęziać w wielu kierunkach do dopasowania ciągu wejściowego z wzorcem.</span><span class="sxs-lookup"><span data-stu-id="a7e74-471">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="a7e74-472">Jeśli nie zostanie znalezione dopasowanie, podczas pierwszej gałęzi, aparat wyrażeń regularnych można utworzyć kopię zapasową lub śledzenie wsteczne w punkcie, gdzie zajęło to pierwsze dopasowanie i spróbuj dopasowanie za pomocą drugiego oddziału.</span><span class="sxs-lookup"><span data-stu-id="a7e74-472">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="a7e74-473">Ten proces może być kontynuowany, dopóki nie wykonano wszystkich gałęzi.</span><span class="sxs-lookup"><span data-stu-id="a7e74-473">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="a7e74-474">`(?>` *Podwyrażenie* `)` języka konstruowania wyłącza wycofywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-474">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="a7e74-475">Aparat wyrażeń regularnych będzie odpowiadał tak dużą liczbę znaków w ciągu wejściowym, ponieważ jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="a7e74-475">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="a7e74-476">Żadne dodatkowe dopasowanie jest możliwe, będzie śledzenie wsteczne nie próby dopasowania do wzorca alternatywne.</span><span class="sxs-lookup"><span data-stu-id="a7e74-476">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="a7e74-477">(Czyli Podwyrażenie dopasowuje wyłącznie ciągi, które zostałyby dopasowane przez samo to Podwyrażenie; nie będzie podejmował próby dopasowania ciągu na podstawie Podwyrażenie i wszelkie podwyrażenia, które występują po nim).</span><span class="sxs-lookup"><span data-stu-id="a7e74-477">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="a7e74-478">Ta opcja jest zalecana, jeśli wiesz, że używanie wycofywania nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="a7e74-478">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="a7e74-479">Aparat wyrażeń regularnych uniemożliwia wykonywanie niepotrzebne wyszukiwania poprawia wydajność.</span><span class="sxs-lookup"><span data-stu-id="a7e74-479">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="a7e74-480">W poniższym przykładzie pokazano, jak Podwyrażenie bez wycofywania modyfikuje wyników dopasowania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="a7e74-480">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="a7e74-481">Wycofywania wyrażenie regularne dopasowuje pomyślnie szereg powtarzające się znaki następuje jedno wystąpienie takiego samego znaku na granicy wyrazu, ale bez wyrażenia regularnego nie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-481">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="a7e74-482">Podwyrażenia bez wycofywania wyrażenia regularnego `(?>(\w)\1+).\b` jest zdefiniowany jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-482">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-483">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-483">Pattern</span></span>|<span data-ttu-id="a7e74-484">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-484">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="a7e74-485">Dopasowuje znak słowa i przypisz je do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-485">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="a7e74-486">Odpowiada wartości pierwszego przechwyconego podciągu jedną lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-486">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="a7e74-487">Dopasowuje dowolny znak.</span><span class="sxs-lookup"><span data-stu-id="a7e74-487">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="a7e74-488">Zakończ dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-488">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="a7e74-489">Pasuje jedno lub więcej wystąpień znaku słowa zduplikowane, ale nie wykonuj nawrotu do dopasowania ostatni znak na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-489">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="a7e74-490">Konstrukty grupujące i obiekty wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="a7e74-490">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="a7e74-491">Podciągi, które są dopasowane przez grupę przechwytywania wyrażenia regularnego są reprezentowane przez <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> obiektów, które mogą być pobierane z <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> obiektu, który jest zwracany przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-491">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a7e74-492"><xref:System.Text.RegularExpressions.GroupCollection> Obiektu jest wypełniana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a7e74-492">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="a7e74-493">Pierwszy <xref:System.Text.RegularExpressions.Group> obiektu w kolekcji (object o indeksie zero) reprezentuje całego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-493">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="a7e74-494">Zestaw następnego <xref:System.Text.RegularExpressions.Group> obiekty reprezentują nienazwane grupy przechwytywania (numerowana).</span><span class="sxs-lookup"><span data-stu-id="a7e74-494">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="a7e74-495">Pojawiają się w kolejności, w której są zdefiniowane w wyrażeniu regularnym, od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="a7e74-495">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="a7e74-496">Indeks wartości tych grup w zakresie od 1 do liczby nienazwane przechwytywania grup w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a7e74-496">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="a7e74-497">(Indeks określonej grupy jest równoważne z jej numerowane odwołanie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="a7e74-497">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="a7e74-498">Aby uzyskać więcej informacji dotyczących dopasowywania wstecznego, zobacz [konstrukcje dopasowywania wstecznego](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="a7e74-498">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="a7e74-499">Ostatni zestaw <xref:System.Text.RegularExpressions.Group> obiekty reprezentują nazwanych grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-499">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="a7e74-500">Pojawiają się w kolejności, w której są zdefiniowane w wyrażeniu regularnym, od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="a7e74-500">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="a7e74-501">Wartość indeksu pierwszego nazwanej grupy przechwytywania jest większa o jeden od indeksu ostatniej nienazwanej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-501">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="a7e74-502">W przypadku nie nienazwane przechwytywania grup w wyrażeniu regularnym, wartość indeksu pierwszego nazwanej grupy przechwytywania jest jeden.</span><span class="sxs-lookup"><span data-stu-id="a7e74-502">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="a7e74-503">W przypadku zastosowania kwantyfikator do grupy przechwytywania, odpowiedni <xref:System.Text.RegularExpressions.Group> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, i <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> właściwości odzwierciedlają ostatni podciąg, która jest przechwytywana przez grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-503">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="a7e74-504">Możesz pobrać kompletny zestaw podciągi, które są przechwytywane według grup, które mają Kwantyfikatory z <xref:System.Text.RegularExpressions.CaptureCollection> obiektu, który jest zwracany przez <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-504">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="a7e74-505">Poniższy przykład wyjaśnia stosunek między <xref:System.Text.RegularExpressions.Group> i <xref:System.Text.RegularExpressions.Capture> obiektów.</span><span class="sxs-lookup"><span data-stu-id="a7e74-505">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="a7e74-506">Definicję wzorca wyrażenia regularnego `\b(\w+)\W+)+` wyodrębnia poszczególnych wyrazów z ciągu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-506">The regular expression pattern `\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="a7e74-507">Definicję tego wyrażenia pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a7e74-507">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7e74-508">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="a7e74-508">Pattern</span></span>|<span data-ttu-id="a7e74-509">Opis</span><span class="sxs-lookup"><span data-stu-id="a7e74-509">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7e74-510">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-510">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="a7e74-511">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="a7e74-511">Match one or more word characters.</span></span> <span data-ttu-id="a7e74-512">Te znaki tworzą razem wyrazu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-512">Together, these characters form a word.</span></span> <span data-ttu-id="a7e74-513">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-513">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="a7e74-514">Dopasowuje znaki niebędące znakami słowa jeden lub więcej.</span><span class="sxs-lookup"><span data-stu-id="a7e74-514">Match one or more non-word characters.</span></span>|  
|`(\w+)\W+)+`|<span data-ttu-id="a7e74-515">Dopasowuje wzorzec jednego lub więcej znaków słowa, następuje jedna lub więcej niebędące znakami słowa jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="a7e74-515">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="a7e74-516">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-516">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="a7e74-517">Pierwsza grupa przechwytywania pasuje do każdego wyrazu w zdaniu.</span><span class="sxs-lookup"><span data-stu-id="a7e74-517">The first capturing group matches each word of the sentence.</span></span> <span data-ttu-id="a7e74-518">Druga grupa przechwytywania pasuje do każdego wyrazu oraz znaków interpunkcyjnych i odstęp wyrazie.</span><span class="sxs-lookup"><span data-stu-id="a7e74-518">The second capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="a7e74-519"><xref:System.Text.RegularExpressions.Group> Obiektu, którego indeks to 2 zawiera informacje dotyczące tekst uwzględniony przez to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="a7e74-519">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="a7e74-520">Kompletny zestaw słów przechwycone przez grupę przechwytywania są dostępne z <xref:System.Text.RegularExpressions.CaptureCollection> obiektu zwróconego przez <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7e74-520">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a7e74-521">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a7e74-521">See also</span></span>

- [<span data-ttu-id="a7e74-522">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="a7e74-522">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="a7e74-523">Śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="a7e74-523">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
