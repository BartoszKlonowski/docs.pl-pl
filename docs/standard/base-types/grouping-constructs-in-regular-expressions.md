---
title: "Konstrukcje grupujące w wyrażeniach regularnych"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
caps.latest.revision: "33"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: b6e0b9d3482bbfc3dabeee1f6b7fce7a93364dfb
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/23/2017
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="76f11-102">Konstrukcje grupujące w wyrażeniach regularnych</span><span class="sxs-lookup"><span data-stu-id="76f11-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="76f11-103">Konstrukcje grupujące odróżniać użyto wyrażenia regularnego i przechwytywania podciągów ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="76f11-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="76f11-104">Można użyć konstrukcji grupowania wykonywać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="76f11-104">You can use grouping constructs to do the following:</span></span>  
  
-   <span data-ttu-id="76f11-105">Odpowiada Podwyrażenie, który jest powtarzany w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="76f11-105">Match a subexpression that is repeated in the input string.</span></span>  
  
-   <span data-ttu-id="76f11-106">Zastosowania kwantyfikatora do Podwyrażenie, który ma wiele elementów języka wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="76f11-107">Aby uzyskać więcej informacji na temat Kwantyfikatory, zobacz [Kwantyfikatory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="76f11-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="76f11-108">Dołączyć podwyrażenia ciąg, który jest zwracany przez <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="76f11-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="76f11-109">Pobrać poszczególnych użyto z <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości i przetwarzanie ich oddzielnie od dopasowanego tekstu jako całość.</span><span class="sxs-lookup"><span data-stu-id="76f11-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="76f11-110">Poniższej tabeli wymieniono konstrukcji grupowania obsługiwane przez aparat wyrażeń regularnych .NET oraz wskazuje, czy są Przechwytywanie lub z systemem innym niż przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="76f11-111">Konstrukcja grupująca</span><span class="sxs-lookup"><span data-stu-id="76f11-111">Grouping construct</span></span>|<span data-ttu-id="76f11-112">Przechwytywanie lub nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="76f11-113">Użyto pasujących</span><span class="sxs-lookup"><span data-stu-id="76f11-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="76f11-114">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="76f11-114">Capturing</span></span>|  
|[<span data-ttu-id="76f11-115">Użyto pasujących nazwanego</span><span class="sxs-lookup"><span data-stu-id="76f11-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="76f11-116">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="76f11-116">Capturing</span></span>|  
|[<span data-ttu-id="76f11-117">Równoważenie definicje grup</span><span class="sxs-lookup"><span data-stu-id="76f11-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="76f11-118">Przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="76f11-118">Capturing</span></span>|  
|[<span data-ttu-id="76f11-119">Grup nieprzechwyconych</span><span class="sxs-lookup"><span data-stu-id="76f11-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="76f11-120">Nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-120">Noncapturing</span></span>|  
|[<span data-ttu-id="76f11-121">Opcje grupy</span><span class="sxs-lookup"><span data-stu-id="76f11-121">Group options</span></span>](#group_options)|<span data-ttu-id="76f11-122">Nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-122">Noncapturing</span></span>|  
|[<span data-ttu-id="76f11-123">Potwierdzenia wyprzedzenia dodatnią zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="76f11-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="76f11-124">Nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-124">Noncapturing</span></span>|  
|[<span data-ttu-id="76f11-125">Potwierdzenia wyprzedzenia ujemna zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="76f11-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="76f11-126">Nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-126">Noncapturing</span></span>|  
|[<span data-ttu-id="76f11-127">Asercje o zerowej szerokości dodatnie wybieganie wstecz</span><span class="sxs-lookup"><span data-stu-id="76f11-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="76f11-128">Nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-128">Noncapturing</span></span>|  
|[<span data-ttu-id="76f11-129">Asercje o zerowej szerokości ujemne wybieganie wstecz</span><span class="sxs-lookup"><span data-stu-id="76f11-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="76f11-130">Nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-130">Noncapturing</span></span>|  
|[<span data-ttu-id="76f11-131">Użyto nonbacktracking</span><span class="sxs-lookup"><span data-stu-id="76f11-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="76f11-132">Nieprzechwyconej</span><span class="sxs-lookup"><span data-stu-id="76f11-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="76f11-133">Aby uzyskać informacje dotyczące grup i model obiektów wyrażeń regularnych, zobacz [grupowanie konstrukcje i obiektów wyrażeń regularnych](#Objects).</span><span class="sxs-lookup"><span data-stu-id="76f11-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="76f11-134">Dopasowane podwyrażenie</span><span class="sxs-lookup"><span data-stu-id="76f11-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="76f11-135">Poniższa konstrukcja grupowania przechwytuje Podwyrażenie dopasowane:</span><span class="sxs-lookup"><span data-stu-id="76f11-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="76f11-136">`(`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="76f11-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="76f11-137">gdzie *Podwyrażenie* jest wzorzec wszystkie prawidłowe wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="76f11-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="76f11-138">Przechwytuje, że Użyj nawiasów są numerowane automatycznie od lewej do prawej na podstawie kolejności otwierającymi nawiasami w wyrażeniu regularnym, począwszy od jednej.</span><span class="sxs-lookup"><span data-stu-id="76f11-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="76f11-139">Przechwytywanie, numerowana zero jest uwzględniony przez wzorzec wyrażenia regularnego cały tekst.</span><span class="sxs-lookup"><span data-stu-id="76f11-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76f11-140">Domyślnie `(` *Podwyrażenie* `)` element języka przechwytuje Podwyrażenie dopasowany.</span><span class="sxs-lookup"><span data-stu-id="76f11-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="76f11-141">Ale jeśli <xref:System.Text.RegularExpressions.RegexOptions> zawiera parametr metody dopasowania wzorca wyrażeń regularnych <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flagi, lub jeśli `n` jest stosowana do tego wyrażenia podrzędnego (zobacz [grupy opcje](#group_options) dalszej części tego tematu), nie przechwytuje Podwyrażenie dopasowany.</span><span class="sxs-lookup"><span data-stu-id="76f11-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="76f11-142">Aby dostęp do przechwyconych grup na cztery sposoby:</span><span class="sxs-lookup"><span data-stu-id="76f11-142">You can access captured groups in four ways:</span></span>  
  
-   <span data-ttu-id="76f11-143">Za pomocą dopasuje skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="76f11-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="76f11-144">Dopasowany Podwyrażenie odwołuje się w tym samym wyrażeniu regularnym przy użyciu składni `\` *numer*, gdzie *numer* jest numerem porządkowym przechwycone Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="76f11-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="76f11-145">Przy użyciu nazwanego dopasuje skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="76f11-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="76f11-146">Dopasowany Podwyrażenie odwołuje się w tym samym wyrażeniu regularnym przy użyciu składni `\k<` *nazwa*`>`, gdzie *nazwa* jest nazwą grupy przechwytywania lub `\k<` *numer*`>`, gdzie *numer* jest numerem porządkowym przechwytywania grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="76f11-147">Przechwytywanie grupa ma domyślną nazwę, która jest taka sama jak jego numer porządkowy.</span><span class="sxs-lookup"><span data-stu-id="76f11-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="76f11-148">Aby uzyskać więcej informacji, zobacz [nazwanego dopasowane użyto](#named_matched_subexpression) dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="76f11-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
-   <span data-ttu-id="76f11-149">Za pomocą `$` *numer* sekwencji zastąpienia w <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> wywołania metody, gdzie *numer* jest numerem porządkowym przechwycone Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="76f11-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="76f11-150">Programowo, za pomocą <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="76f11-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="76f11-151">Członek na pozycji zero w kolekcji reprezentuje dopasowania całego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="76f11-152">Każdy członek kolejnych reprezentuje dopasowane wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="76f11-153">Aby uzyskać więcej informacji, zobacz [konstrukcji grupowania i obiektów wyrażeń regularnych](#Objects) sekcji.</span><span class="sxs-lookup"><span data-stu-id="76f11-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="76f11-154">Poniższy przykład przedstawia wyrażenie regularne określające zduplikowanych wyrazów w tekście.</span><span class="sxs-lookup"><span data-stu-id="76f11-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="76f11-155">Wzorzec wyrażenia regularnego dwóch grup przechwytywania reprezentuje dwa wystąpienia zduplikowanych programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="76f11-156">Drugie wystąpienie są przechwytywane do zgłaszania jego położenie początkowe w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="76f11-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="76f11-157">Wzorzec wyrażenia regularnego jest następujący:</span><span class="sxs-lookup"><span data-stu-id="76f11-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="76f11-158">W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="76f11-159">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-159">Pattern</span></span>|<span data-ttu-id="76f11-160">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="76f11-161">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-161">Match one or more word characters.</span></span> <span data-ttu-id="76f11-162">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="76f11-163">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="76f11-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="76f11-164">Zgodny z ciągiem w pierwszym przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-164">Match the string in the first captured group.</span></span> <span data-ttu-id="76f11-165">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-165">This is the second capturing group.</span></span> <span data-ttu-id="76f11-166">Przykład przypisuje go do przechwyconej grupy tak, aby pozycja początkowa zduplikowane Word mogą być pobierane z `Match.Index` właściwości.</span><span class="sxs-lookup"><span data-stu-id="76f11-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="76f11-167">Dopasowuje znak-word, w tym biały znak i znaków interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="76f11-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="76f11-168">Zapobiega to dopasowania wyrazu, który rozpoczyna się od słowa z pierwszego przechwyconej grupy wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="76f11-169">O nazwie dopasowane podwyrażenia</span><span class="sxs-lookup"><span data-stu-id="76f11-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="76f11-170">Poniższa konstrukcja grupowania przechwytuje Podwyrażenie dopasowane i pozwala uzyskiwać dostęp do według nazwy lub numeru:</span><span class="sxs-lookup"><span data-stu-id="76f11-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="76f11-171">lub:</span><span class="sxs-lookup"><span data-stu-id="76f11-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="76f11-172">gdzie *nazwa* jest nazwą prawidłową grupę i *Podwyrażenie* jest wzorzec wszystkie prawidłowe wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="76f11-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="76f11-173">*Nazwa* nie może zawierać żadnych znaków interpunkcyjnych i nie może rozpoczynać się cyfrą.</span><span class="sxs-lookup"><span data-stu-id="76f11-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76f11-174">Jeśli <xref:System.Text.RegularExpressions.RegexOptions> zawiera parametr metody dopasowania wzorca wyrażeń regularnych <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flagi, lub jeśli `n` jest stosowana do tego wyrażenia podrzędnego (zobacz [grupy opcje](#group_options) dalszej części tego tematu), tylko sposobem przechwytuje Podwyrażenie jest jawnie nazwy grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="76f11-175">Aby dostęp do przechwyconej grupy nazwane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="76f11-175">You can access named captured groups in the following ways:</span></span>  
  
-   <span data-ttu-id="76f11-176">Przy użyciu nazwanego dopasuje skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="76f11-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="76f11-177">Dopasowany Podwyrażenie odwołuje się w tym samym wyrażeniu regularnym przy użyciu składni `\k<` *nazwa*`>`, gdzie *nazwa* jest nazwą przechwycone Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="76f11-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="76f11-178">Za pomocą dopasuje skonstruować w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="76f11-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="76f11-179">Dopasowany Podwyrażenie odwołuje się w tym samym wyrażeniu regularnym przy użyciu składni `\` *numer*, gdzie *numer* jest numerem porządkowym przechwycone Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="76f11-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="76f11-180">Nazwane użyto pasujących są numerowane kolejno od lewej do prawej po użyto dopasowany.</span><span class="sxs-lookup"><span data-stu-id="76f11-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
-   <span data-ttu-id="76f11-181">Za pomocą `${` *nazwa* `}` sekwencji zastąpienia w <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> wywołania metody, gdzie *nazwa* jest nazwą przechwycone Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="76f11-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="76f11-182">Za pomocą `$` *numer* sekwencji zastąpienia w <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> lub <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> wywołania metody, gdzie *numer* jest numerem porządkowym przechwycone Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="76f11-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="76f11-183">Programowo, za pomocą <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="76f11-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="76f11-184">Członek na pozycji zero w kolekcji reprezentuje dopasowania całego wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="76f11-185">Każdy członek kolejnych reprezentuje dopasowane wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="76f11-186">Nazwanych grup przechwyconych są przechowywane w kolekcji po numerem grupy przechwycony.</span><span class="sxs-lookup"><span data-stu-id="76f11-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
-   <span data-ttu-id="76f11-187">Programowo, podając nazwę Podwyrażenie <xref:System.Text.RegularExpressions.GroupCollection> indeksatora obiektu (w języku C#) lub jego <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> właściwości (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="76f11-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="76f11-188">Proste wyrażenia regularnego ilustruje sposób numerowane (bez nazwy) i nazwanych grup można odwoływać się programowo lub przy użyciu składni wyrażeń regularnych języka.</span><span class="sxs-lookup"><span data-stu-id="76f11-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="76f11-189">Wyrażenie regularne `((?<One>abc)\d+)?(?<Two>xyz)(.*)` daje następujące przechwytywania grupy według numeru i według nazwy.</span><span class="sxs-lookup"><span data-stu-id="76f11-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="76f11-190">Pierwszy Przechwytywanie grupy (liczba 0) zawsze odwołuje się do całego wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="76f11-191">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="76f11-191">Number</span></span>|<span data-ttu-id="76f11-192">Nazwa</span><span class="sxs-lookup"><span data-stu-id="76f11-192">Name</span></span>|<span data-ttu-id="76f11-193">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="76f11-194">0</span><span class="sxs-lookup"><span data-stu-id="76f11-194">0</span></span>|<span data-ttu-id="76f11-195">0 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="76f11-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="76f11-196">1</span><span class="sxs-lookup"><span data-stu-id="76f11-196">1</span></span>|<span data-ttu-id="76f11-197">1 (domyślna nazwa)</span><span class="sxs-lookup"><span data-stu-id="76f11-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="76f11-198">2</span><span class="sxs-lookup"><span data-stu-id="76f11-198">2</span></span>|<span data-ttu-id="76f11-199">2 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="76f11-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="76f11-200">3</span><span class="sxs-lookup"><span data-stu-id="76f11-200">3</span></span>|<span data-ttu-id="76f11-201">Jeden</span><span class="sxs-lookup"><span data-stu-id="76f11-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="76f11-202">4</span><span class="sxs-lookup"><span data-stu-id="76f11-202">4</span></span>|<span data-ttu-id="76f11-203">dwa</span><span class="sxs-lookup"><span data-stu-id="76f11-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="76f11-204">Poniższy przykład przedstawia identyfikujący zduplikowanych słów i słowem poniższą każdego wyrazu zduplikowanych wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="76f11-205">Wzorzec wyrażenia regularnego definiuje dwie użyto nazwanego: `duplicateWord`, reprezentuje zduplikowany word; i `nextWord`, reprezentuje word, znajdujący się zduplikowane programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="76f11-206">Wzorzec wyrażenia regularnego jest następujący:</span><span class="sxs-lookup"><span data-stu-id="76f11-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="76f11-207">W poniższej tabeli przedstawiono, jak jest interpretowana wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="76f11-208">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-208">Pattern</span></span>|<span data-ttu-id="76f11-209">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="76f11-210">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-210">Match one or more word characters.</span></span> <span data-ttu-id="76f11-211">Określ nazwę tej grupy przechwytywania `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="76f11-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="76f11-212">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="76f11-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="76f11-213">Zgodny z ciągiem z przechwyconej grupy o nazwie `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="76f11-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="76f11-214">Dopasowuje znak-word, w tym biały znak i znaków interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="76f11-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="76f11-215">Zapobiega to dopasowania wyrazu, który rozpoczyna się od słowa z pierwszego przechwyconej grupy wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="76f11-216">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-216">Match one or more word characters.</span></span> <span data-ttu-id="76f11-217">Określ nazwę tej grupy przechwytywania `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="76f11-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="76f11-218">Należy pamiętać, że nazwa grupy można powtarzać w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="76f11-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="76f11-219">Na przykład istnieje możliwość więcej niż jednej grupy do nosić `digit`, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="76f11-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="76f11-220">W przypadku takich samych nazwach, wartość <xref:System.Text.RegularExpressions.Group> obiektu jest określane przez ostatniego pomyślnego przechwytywania w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="76f11-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="76f11-221">Ponadto <xref:System.Text.RegularExpressions.CaptureCollection> jest wypełniane przy użyciu informacji o każdym przechwytywania, tak samo, jak możesz ją, jeśli nazwa grupy nie zostało zduplikowane.</span><span class="sxs-lookup"><span data-stu-id="76f11-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="76f11-222">W poniższym przykładzie, wyrażenie regularne `\D+(?<digit>\d+)\D+(?<digit>\d+)?` obejmuje dwa wystąpienia grupę o nazwie `digit`.</span><span class="sxs-lookup"><span data-stu-id="76f11-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="76f11-223">Pierwszy `digit` o nazwie grupy przechwytywania co najmniej jeden znak cyfr.</span><span class="sxs-lookup"><span data-stu-id="76f11-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="76f11-224">Drugi `digit` nazwaną grupę przechwytuje wystąpienie zero lub jeden lub więcej kolejnych cyfr znaków.</span><span class="sxs-lookup"><span data-stu-id="76f11-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="76f11-225">Jako dane wyjściowe w przykładzie, jeśli drugi Przechwytywanie grupy pomyślnie pasuje do tekstu, wartość lub tekst Określa wartość <xref:System.Text.RegularExpressions.Group> obiektu.</span><span class="sxs-lookup"><span data-stu-id="76f11-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="76f11-226">Jeśli nie drugiej grupy przechwytywania nie odpowiada ciąg wejściowy wartość ostatniego pomyślnego dopasowania definiuje wartość <xref:System.Text.RegularExpressions.Group> obiektu.</span><span class="sxs-lookup"><span data-stu-id="76f11-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="76f11-227">W poniższej tabeli przedstawiono, jak jest interpretowana wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="76f11-228">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-228">Pattern</span></span>|<span data-ttu-id="76f11-229">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="76f11-230">Odpowiada co najmniej jeden znak podawać cyfr.</span><span class="sxs-lookup"><span data-stu-id="76f11-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="76f11-231">Zgodne z co najmniej jeden znak cyfrę.</span><span class="sxs-lookup"><span data-stu-id="76f11-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="76f11-232">Dopasowanie, aby przypisać `digit` o nazwie grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-232">Assign the match to the `digit` named group.</span></span>|  
|<span data-ttu-id="76f11-233">\D+</span><span class="sxs-lookup"><span data-stu-id="76f11-233">\D+</span></span>|<span data-ttu-id="76f11-234">Odpowiada co najmniej jeden znak podawać cyfr.</span><span class="sxs-lookup"><span data-stu-id="76f11-234">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="76f11-235">Wystąpienie dopasowania zero lub jeden co najmniej jeden znak cyfrę.</span><span class="sxs-lookup"><span data-stu-id="76f11-235">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="76f11-236">Dopasowanie, aby przypisać `digit` o nazwie grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-236">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="76f11-237">Równoważenie definicji grup</span><span class="sxs-lookup"><span data-stu-id="76f11-237">Balancing Group Definitions</span></span>  
 <span data-ttu-id="76f11-238">Równoważenia definicja grupy usuwa definicję uprzednio zdefiniowanej grupy i magazynów w bieżącej grupie, interwał między wcześniej zdefiniowanych grup oraz bieżący.</span><span class="sxs-lookup"><span data-stu-id="76f11-238">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="76f11-239">Ta konstrukcja grupowania ma następujący format:</span><span class="sxs-lookup"><span data-stu-id="76f11-239">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="76f11-240">lub:</span><span class="sxs-lookup"><span data-stu-id="76f11-240">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="76f11-241">gdzie *Nazwa1* jest bieżącej grupy (opcjonalnie), *Nazwa2* jest grupą uprzednio zdefiniowany i *Podwyrażenie* jest wzorzec wszystkie prawidłowe wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="76f11-241">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="76f11-242">Definicja grupy równoważenia usuwa definicję *Nazwa2* i zapisze wartość interwału między *Nazwa2* i *Nazwa1* w *Nazwa1*.</span><span class="sxs-lookup"><span data-stu-id="76f11-242">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="76f11-243">Jeśli nie *Nazwa2* grupy jest określona, zapoznawanie dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-243">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="76f11-244">Ponieważ usunięcie ostatniego definicji *Nazwa2* ujawnia poprzednią definicję *Nazwa2*, ta konstrukcja pozwala używać stosu przechwyconych obrazów grupy *Nazwa2* jako Licznik rejestrowanie informacji o zagnieżdżonej konstrukcji, takich jak nawiasy lub otwierające i zamykające nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="76f11-244">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="76f11-245">Używa równoważenia definicja grupy *Nazwa2* jako stosu.</span><span class="sxs-lookup"><span data-stu-id="76f11-245">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="76f11-246">Pierwszy znak każdej zagnieżdżonej konstrukcji znajduje się w grupie, a w jego <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="76f11-246">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="76f11-247">Po dopasowaniu znak zamykającego odpowiadającego znaku otwierania zostanie usunięty z grupy, a <xref:System.Text.RegularExpressions.Group.Captures%2A> kolekcji zostaje zmniejszona o jeden.</span><span class="sxs-lookup"><span data-stu-id="76f11-247">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="76f11-248">Po dopasowaniu otwarcia i zamknięcia znaków konstrukcji wszystkich zagnieżdżonych, *Nazwa1* jest pusta.</span><span class="sxs-lookup"><span data-stu-id="76f11-248">After the opening and closing characters of all nested constructs have been matched, *name1* is empty.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76f11-249">Po zakończeniu modyfikowania wyrażenie regularne w poniższym przykładzie do użycia odpowiedniego otwierania i zamykającego znaku zagnieżdżonej konstrukcji, służy ona do obsługi najbardziej zagnieżdżonej konstrukcji, takich jak wyrażeń matematycznych lub wierszy kodu programu, które obejmują wiele wywołań metody zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="76f11-249">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="76f11-250">W poniższym przykładzie użyto równoważenia definicja grupy, aby dopasować lewy i prawy nawias nawiasy (<>) w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="76f11-250">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="76f11-251">W przykładzie zdefiniowano dwie grupy nazwane `Open` i `Close`, używane do śledzenia pasujących par nawiasy jak stosu.</span><span class="sxs-lookup"><span data-stu-id="76f11-251">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="76f11-252">Każdy przechwyconych lewego nawiasu ostrego zostanie przypisany do kolekcji przechwytywania `Open` grupy i wszystkich przechwyconych prawego nawiasu ostrego zostanie przypisany do kolekcji przechwytywania `Close` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-252">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="76f11-253">Definicja grupy równoważenia gwarantuje, że jest pasujących nawiasów pod kątem dla każdego lewego nawiasu ostrego.</span><span class="sxs-lookup"><span data-stu-id="76f11-253">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="76f11-254">Jeśli nie, jest ostatnim podciąg wzorca, `(?(Open)(?!))`, jest oceniane tylko wtedy, gdy `Open` grupy nie jest pusty (i, w związku z tym, jeśli nie wszystkie konstrukcje zagnieżdżonych zostało zamknięte).</span><span class="sxs-lookup"><span data-stu-id="76f11-254">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="76f11-255">Jeśli oceny końcowego podciąg wzorca dopasowania nie powiedzie się, ponieważ `(?!)` podciąg wzorca jest potwierdzenie wyprzedzenia ujemna zerowej szerokości, która zawsze kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="76f11-255">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="76f11-256">Wzorzec wyrażenia regularnego jest:</span><span class="sxs-lookup"><span data-stu-id="76f11-256">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="76f11-257">Wyrażenie regularne jest interpretowana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="76f11-257">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="76f11-258">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-258">Pattern</span></span>|<span data-ttu-id="76f11-259">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-259">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="76f11-260">Rozpocznij na początku ciąg.</span><span class="sxs-lookup"><span data-stu-id="76f11-260">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="76f11-261">Zgodne zero lub więcej znaków, które nie są w nawiasach lewej lub pod kątem.</span><span class="sxs-lookup"><span data-stu-id="76f11-261">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="76f11-262">Zgodne lewego nawiasu ostrego i przypisz je do grupy o nazwie `Open`.</span><span class="sxs-lookup"><span data-stu-id="76f11-262">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="76f11-263">Zgodne zero lub więcej znaków, które nie są w nawiasach lewej lub pod kątem.</span><span class="sxs-lookup"><span data-stu-id="76f11-263">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*) +`|<span data-ttu-id="76f11-264">Odpowiada jednej lub więcej wystąpień lewego nawiasu ostrego następuje zero lub więcej znaków, które nie są w nawiasach lewej lub pod kątem.</span><span class="sxs-lookup"><span data-stu-id="76f11-264">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="76f11-265">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-265">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="76f11-266">Zgodne prawego nawiasu ostrego, przypisz podciąg między `Open` grupy i bieżącą grupę do `Close` , a następnie usunąć definicji `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-266">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="76f11-267">Zgodne zero lub więcej wystąpień dowolny znak, który nie jest lewe ani prawego nawiasu ostrego.</span><span class="sxs-lookup"><span data-stu-id="76f11-267">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="76f11-268">Jeden lub więcej wystąpień prawego nawiasu ostrego są zgodne, następuje zero lub więcej wystąpień dowolnego znaku, który nie jest lewe ani prawego nawiasu ostrego.</span><span class="sxs-lookup"><span data-stu-id="76f11-268">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="76f11-269">Podczas dopasowywania prawego nawiasu ostrego, przypisz podciąg między `Open` grupy i bieżącą grupę do `Close` , a następnie usunąć definicji `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-269">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="76f11-270">Jest to trzecia grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-270">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="76f11-271">Zgodne zero lub więcej wystąpień następującego wzorca: jeden lub więcej wystąpień lewego nawiasu ostrego następuje zero lub więcej znaków nawiasu ostrego następuje jeden lub więcej wystąpień prawego nawiasu ostrego, a następnie zero lub więcej wystąpień z systemem innym niż — nawiasy.</span><span class="sxs-lookup"><span data-stu-id="76f11-271">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="76f11-272">Podczas dopasowywania prawego nawiasu ostrego, usuń definicję `Open` , a następnie przypisać podciąg między `Open` grupy i bieżącą grupę do `Close` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-272">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="76f11-273">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-273">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="76f11-274">Jeśli `Open` grupa istnieje, Porzuć dopasowania, jeśli ciąg pusty można dopasować, ale nie przekazują pozycja aparat wyrażeń regularnych w ciągu.</span><span class="sxs-lookup"><span data-stu-id="76f11-274">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="76f11-275">Jest to potwierdzenie zerowej szerokości ujemna wyprzedzenia.</span><span class="sxs-lookup"><span data-stu-id="76f11-275">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="76f11-276">Ponieważ ciąg pusty jest zawsze niejawnie występuje w ciągu wejściowym, tego dopasowania nie zawsze powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="76f11-276">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="76f11-277">Błąd tego dopasowania wskazuje, że nawiasy są niezrównoważone.</span><span class="sxs-lookup"><span data-stu-id="76f11-277">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="76f11-278">Dopasowuje koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="76f11-278">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="76f11-279">Końcowe Podwyrażenie `(?(Open)(?!))`, wskazuje, czy zagnieżdżanie konstruuje w ciągu wejściowym prawidłowo równoważy (na przykład, czy każdy lewego nawiasu ostrego są dopasowane wg prawego nawiasu ostrego).</span><span class="sxs-lookup"><span data-stu-id="76f11-279">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="76f11-280">Używa warunkowego dopasowania oparte na prawidłową grupę przechwyconych; Aby uzyskać więcej informacji, zobacz [konstrukcje Alternacyjne](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="76f11-280">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="76f11-281">Jeśli `Open` grupy jest określona, aparat wyrażeń regularnych próbuje dopasować Podwyrażenie `(?!)` w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="76f11-281">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="76f11-282">`Open` Grupy powinien być zdefiniowany tylko wtedy, gdy niezrównoważonej konstrukcje zagnieżdżenia.</span><span class="sxs-lookup"><span data-stu-id="76f11-282">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="76f11-283">W związku z tym wzorzec do dopasowania w ciągu wejściowym należy zawsze powoduje dopasowanie niepowodzenia.</span><span class="sxs-lookup"><span data-stu-id="76f11-283">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="76f11-284">W takim przypadku `(?!)` jest potwierdzenie wyprzedzenia ujemna zerowej szerokości która zawsze kończy się niepowodzeniem, ponieważ ciąg pusty jest zawsze niejawnie obecne w następnej pozycji w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="76f11-284">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="76f11-285">W tym przykładzie aparat wyrażeń regularnych ocenia ciąg wejściowy "\<abc >< mno\<xyz >>" jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-285">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-286">Krok</span><span class="sxs-lookup"><span data-stu-id="76f11-286">Step</span></span>|<span data-ttu-id="76f11-287">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-287">Pattern</span></span>|<span data-ttu-id="76f11-288">Wynik</span><span class="sxs-lookup"><span data-stu-id="76f11-288">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="76f11-289">1</span><span class="sxs-lookup"><span data-stu-id="76f11-289">1</span></span>|`^`|<span data-ttu-id="76f11-290">Rozpoczyna się na początku ciąg wejściowy dopasowania</span><span class="sxs-lookup"><span data-stu-id="76f11-290">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="76f11-291">2</span><span class="sxs-lookup"><span data-stu-id="76f11-291">2</span></span>|`[^<>]*`|<span data-ttu-id="76f11-292">Wyszukuje znaki nawiasu ostrego przed lewego nawiasu ostrego; znajdzie żadnych wyników.</span><span class="sxs-lookup"><span data-stu-id="76f11-292">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="76f11-293">3</span><span class="sxs-lookup"><span data-stu-id="76f11-293">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="76f11-294">Dopasowuje lewego nawiasu ostrego w "\<abc >", a następnie przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-294">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="76f11-295">4</span><span class="sxs-lookup"><span data-stu-id="76f11-295">4</span></span>|`[^<>]*`|<span data-ttu-id="76f11-296">Dopasowuje "abc".</span><span class="sxs-lookup"><span data-stu-id="76f11-296">Matches "abc".</span></span>|  
|<span data-ttu-id="76f11-297">5</span><span class="sxs-lookup"><span data-stu-id="76f11-297">5</span></span>|`)+`|<span data-ttu-id="76f11-298">"< abc" to wartość drugiego przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-298">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="76f11-299">Następny znak w ciągu wejściowym nie jest lewego nawiasu ostrego, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `(?'Open'<)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-299">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-300">6</span><span class="sxs-lookup"><span data-stu-id="76f11-300">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="76f11-301">Odpowiada prawego nawiasu ostrego w "\<abc >", "abc", czyli podciąg przypisuje między `Open` grupy i pod kątem nawiasów do `Close` , a następnie usuwa bieżącą wartość ("<") z `Open` grupy, zostawiać je puste.</span><span class="sxs-lookup"><span data-stu-id="76f11-301">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="76f11-302">7</span><span class="sxs-lookup"><span data-stu-id="76f11-302">7</span></span>|`[^<>]*`|<span data-ttu-id="76f11-303">Wyszukuje znaki nawiasu ostrego po prawego nawiasu ostrego; Umożliwia znalezienie żadnych wyników.</span><span class="sxs-lookup"><span data-stu-id="76f11-303">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="76f11-304">8</span><span class="sxs-lookup"><span data-stu-id="76f11-304">8</span></span>|`)+`|<span data-ttu-id="76f11-305">Wartość trzeciego przechwycone grupy jest ">".</span><span class="sxs-lookup"><span data-stu-id="76f11-305">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="76f11-306">Następny znak w ciągu wejściowym nie jest prawego nawiasu ostrego, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `((?'Close-Open'>)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-306">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-307">9</span><span class="sxs-lookup"><span data-stu-id="76f11-307">9</span></span>|`)*`|<span data-ttu-id="76f11-308">Wartość pierwszego przechwyconej grupy jest "\<abc >".</span><span class="sxs-lookup"><span data-stu-id="76f11-308">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="76f11-309">Następny znak w ciągu wejściowym jest lewego nawiasu ostrego, więc aparat wyrażeń regularnych pętli do `(((?'Open'<)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-309">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-310">10</span><span class="sxs-lookup"><span data-stu-id="76f11-310">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="76f11-311">Dopasowuje lewego nawiasu ostrego w "\<mno >", a następnie przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-311">Matches the left angle bracket in "\<mno>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="76f11-312">Jego <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> teraz kolekcja zawiera pojedynczą wartość, "<".</span><span class="sxs-lookup"><span data-stu-id="76f11-312">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="76f11-313">11</span><span class="sxs-lookup"><span data-stu-id="76f11-313">11</span></span>|`[^<>]*`|<span data-ttu-id="76f11-314">Dopasowuje "mno".</span><span class="sxs-lookup"><span data-stu-id="76f11-314">Matches "mno".</span></span>|  
|<span data-ttu-id="76f11-315">12</span><span class="sxs-lookup"><span data-stu-id="76f11-315">12</span></span>|`)+`|<span data-ttu-id="76f11-316">"< mno" to wartość drugiego przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-316">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="76f11-317">Następny znak w ciągu wejściowym jest lewego nawiasu ostrego, więc aparat wyrażeń regularnych pętli do `(?'Open'<)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-317">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-318">13</span><span class="sxs-lookup"><span data-stu-id="76f11-318">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="76f11-319">Dopasowuje lewego nawiasu ostrego w "\<xyz >", a następnie przypisuje go do `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-319">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="76f11-320"><xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> Kolekcja `Open` grupy zawiera teraz dwa przechwytywania: lewego nawiasu ostrego z "\<mno >" i lewego nawiasu ostrego z "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="76f11-320">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno>", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="76f11-321">14</span><span class="sxs-lookup"><span data-stu-id="76f11-321">14</span></span>|`[^<>]*`|<span data-ttu-id="76f11-322">Dopasowuje "xyz".</span><span class="sxs-lookup"><span data-stu-id="76f11-322">Matches "xyz".</span></span>|  
|<span data-ttu-id="76f11-323">15</span><span class="sxs-lookup"><span data-stu-id="76f11-323">15</span></span>|`)+`|<span data-ttu-id="76f11-324">"< xyz" to wartość drugiego przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-324">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="76f11-325">Następny znak w ciągu wejściowym nie jest lewego nawiasu ostrego, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `(?'Open'<)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-325">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-326">16</span><span class="sxs-lookup"><span data-stu-id="76f11-326">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="76f11-327">Dopasowuje prawego nawiasu ostrego w "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="76f11-327">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="76f11-328">"xyz" przypisuje podciąg między `Open` grupy i pod kątem nawiasów do `Close` , a następnie usuwa bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-328">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="76f11-329">Wartość poprzedniej przechwytywania (lewego nawiasu ostrego w "\<mno >") staje się bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-329">The value of the previous capture (the left angle bracket in "\<mno>") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="76f11-330"><xref:System.Text.RegularExpressions.Group.Captures%2A> Kolekcja `Open` grupy zawiera teraz jeden przechwytywania, lewego nawiasu ostrego z "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="76f11-330">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="76f11-331">17</span><span class="sxs-lookup"><span data-stu-id="76f11-331">17</span></span>|`[^<>]*`|<span data-ttu-id="76f11-332">Wyszukuje znaki nawiasu ostrego; Umożliwia znalezienie żadnych wyników.</span><span class="sxs-lookup"><span data-stu-id="76f11-332">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="76f11-333">18</span><span class="sxs-lookup"><span data-stu-id="76f11-333">18</span></span>|`)+`|<span data-ttu-id="76f11-334">Wartość trzeciego przechwycone grupy jest ">".</span><span class="sxs-lookup"><span data-stu-id="76f11-334">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="76f11-335">Następny znak w ciągu wejściowym jest prawego nawiasu ostrego, więc aparat wyrażeń regularnych pętli do `((?'Close-Open'>)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-335">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-336">19</span><span class="sxs-lookup"><span data-stu-id="76f11-336">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="76f11-337">Dopasowuje końcowego prawego nawiasu ostrego w "xyz >>", przypisuje "mno\<xyz >" (podciąg między `Open` grupy i prawego nawiasu ostrego) do `Close` , a następnie usuwa bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-337">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="76f11-338">`Open` Grupa jest obecnie pusta.</span><span class="sxs-lookup"><span data-stu-id="76f11-338">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="76f11-339">20</span><span class="sxs-lookup"><span data-stu-id="76f11-339">20</span></span>|`[^<>]*`|<span data-ttu-id="76f11-340">Wyszukuje znaki nawiasu ostrego; Umożliwia znalezienie żadnych wyników.</span><span class="sxs-lookup"><span data-stu-id="76f11-340">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="76f11-341">21</span><span class="sxs-lookup"><span data-stu-id="76f11-341">21</span></span>|`)+`|<span data-ttu-id="76f11-342">Wartość trzeciego przechwycone grupy jest ">".</span><span class="sxs-lookup"><span data-stu-id="76f11-342">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="76f11-343">Następny znak w ciągu wejściowym nie jest prawego nawiasu ostrego, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `((?'Close-Open'>)[^<>]*)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-343">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-344">22</span><span class="sxs-lookup"><span data-stu-id="76f11-344">22</span></span>|`)*`|<span data-ttu-id="76f11-345">Wartość pierwszego przechwyconej grupy jest "< mno\<xyz >>".</span><span class="sxs-lookup"><span data-stu-id="76f11-345">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="76f11-346">Następny znak w ciągu wejściowym nie jest lewego nawiasu ostrego, więc aparat wyrażeń regularnych nie sprzężenia zwrotnego `(((?'Open'<)` podciąg wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-346">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="76f11-347">23</span><span class="sxs-lookup"><span data-stu-id="76f11-347">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="76f11-348">`Open` Grupy nie jest zdefiniowany, więc nie zostanie podjęta.</span><span class="sxs-lookup"><span data-stu-id="76f11-348">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="76f11-349">24</span><span class="sxs-lookup"><span data-stu-id="76f11-349">24</span></span>|`$`|<span data-ttu-id="76f11-350">Dopasowuje koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="76f11-350">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="76f11-351">Grupy niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="76f11-351">Noncapturing Groups</span></span>  
 <span data-ttu-id="76f11-352">Poniższa konstrukcja grupowania nie przechwycić podciągu, który jest uwzględniony przez podwyrażenia:</span><span class="sxs-lookup"><span data-stu-id="76f11-352">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="76f11-353">gdzie *Podwyrażenie* jest wzorzec wszystkie prawidłowe wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="76f11-353">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="76f11-354">Konstrukcja grupy nieprzechwyconej jest zwykle używany podczas kwantyfikator jest stosowane do grupy, ale podciągów przechwycone przez grupę są nie zainteresowań.</span><span class="sxs-lookup"><span data-stu-id="76f11-354">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76f11-355">Jeśli wyrażenie regularne zawiera zagnieżdżone grupowanie konstrukcje, grupa zewnętrzna nieprzechwyconej konstrukcja nie dotyczą konstrukcje wewnętrzny grup zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="76f11-355">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="76f11-356">Poniższy przykład przedstawia wyrażenie regularne, która obejmuje grup nieprzechwyconych.</span><span class="sxs-lookup"><span data-stu-id="76f11-356">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="76f11-357">Należy pamiętać, że dane wyjściowe nie zawiera żadnych przechwytywane grup.</span><span class="sxs-lookup"><span data-stu-id="76f11-357">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="76f11-358">Wyrażenie regularne `(?:\b(?:\w+)\W*)+\.` odpowiada zdania, zostanie zakończony kropką.</span><span class="sxs-lookup"><span data-stu-id="76f11-358">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="76f11-359">Ponieważ wyrażenia regularnego koncentruje się na zdania, a nie na poszczególnych wyrazów, konstrukcji grupowania służą wyłącznie jako Kwantyfikatory.</span><span class="sxs-lookup"><span data-stu-id="76f11-359">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="76f11-360">Wzorzec wyrażenia regularnego jest interpretowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-360">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-361">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-361">Pattern</span></span>|<span data-ttu-id="76f11-362">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-362">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="76f11-363">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-363">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="76f11-364">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-364">Match one or more word characters.</span></span> <span data-ttu-id="76f11-365">Nie należy przypisywać dopasowany tekst do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-365">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="76f11-366">Zgodne zero lub więcej znaków niż word.</span><span class="sxs-lookup"><span data-stu-id="76f11-366">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="76f11-367">Zgodne wzorca co najmniej jeden znak word, zaczynając od granicy word, następuje zero lub więcej znaków niż word, jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="76f11-367">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="76f11-368">Nie należy przypisywać dopasowany tekst do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-368">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="76f11-369">Odpowiada danym okresie.</span><span class="sxs-lookup"><span data-stu-id="76f11-369">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="76f11-370">Opcje grupy</span><span class="sxs-lookup"><span data-stu-id="76f11-370">Group Options</span></span>  
 <span data-ttu-id="76f11-371">Poniższa konstrukcja grupowania stosuje lub wyłącza określonych opcji w podwyrażenia:</span><span class="sxs-lookup"><span data-stu-id="76f11-371">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="76f11-372">`(?imnsx-imnsx:`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="76f11-372">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="76f11-373">gdzie *Podwyrażenie* jest wzorzec wszystkie prawidłowe wyrażenie regularne.</span><span class="sxs-lookup"><span data-stu-id="76f11-373">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="76f11-374">Na przykład `(?i-s:)` włącza liter i wyłącza tryb pojedynczej linii.</span><span class="sxs-lookup"><span data-stu-id="76f11-374">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="76f11-375">Aby uzyskać więcej informacji na temat opcji wbudowany, można określić, zobacz [opcje wyrażeń regularnych](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="76f11-375">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76f11-376">Możesz określić opcje, które mają zastosowanie do całego wyrażenia regularnego zamiast podwyrażenia przy użyciu <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> konstruktora klasy lub metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="76f11-376">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="76f11-377">Można również określić opcje wbudowany, które są stosowane po stanie z określonego momentu w wyrażeniu regularnym przy użyciu `(?imnsx-imnsx)` konstrukcji języka.</span><span class="sxs-lookup"><span data-stu-id="76f11-377">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="76f11-378">Konstrukcja opcje grupy nie jest grupą przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-378">The group options construct is not a capturing group.</span></span> <span data-ttu-id="76f11-379">Oznacza to mimo że jakiejkolwiek jego części ciągu przechwycony przez *Podwyrażenie* jest uwzględniona w dopasowania, jest nie zawarte w przechwyconej grupy ani służące do wypełniania <xref:System.Text.RegularExpressions.GroupCollection> obiektu.</span><span class="sxs-lookup"><span data-stu-id="76f11-379">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="76f11-380">Na przykład, wyrażenie regularne `\b(?ix: d \w+)\s` w poniższym przykładzie używa opcji wbudowany w konstrukcji grupowania Włącz dopasowywanie bez uwzględniania wielkości liter i Ignoruj odstępy wzorzec do identyfikowania wszystkie słowa, które zaczynają się od litery "d".</span><span class="sxs-lookup"><span data-stu-id="76f11-380">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="76f11-381">Wyrażenie regularne jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-381">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-382">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-382">Pattern</span></span>|<span data-ttu-id="76f11-383">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-383">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="76f11-384">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-384">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="76f11-385">Za pomocą dopasowywania i zignorowano biały znak w tym wzorcu bez uwzględniania wielkości liter, zgodne "d", po której następuje co najmniej jeden znak programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-385">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="76f11-386">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="76f11-386">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="76f11-387">Dodatnie asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="76f11-387">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="76f11-388">Poniższa konstrukcja grupowanie definiuje potwierdzenia wyprzedzenia dodatnią zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="76f11-388">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="76f11-389">`(?=`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="76f11-389">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="76f11-390">gdzie *Podwyrażenie* jest żadnych wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-390">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="76f11-391">Pod kątem dopasowania do pomyślnego ciąg wejściowy musi być zgodna ze wzorcem wyrażenia regularnego w *Podwyrażenie*, mimo że podciąg nie znajduje się w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-391">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="76f11-392">Potwierdzenie wyprzedzenia dodatnią zerowej szerokości nie śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="76f11-392">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="76f11-393">Zazwyczaj potwierdzenia wyprzedzenia dodatnią zerowej szerokości znajduje się na końcu wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-393">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="76f11-394">Definiuje podciąg, który musi zostać znaleziony na końcu ciągu do dopasowania występuje, ale które nie powinny znajdować się w dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-394">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="76f11-395">Jest również przydatne w przypadku uniemożliwia nadmiernym wykorzystaniem algorytmu wycofywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-395">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="76f11-396">Potwierdzenie wyprzedzenia dodatnią zerowej szerokości umożliwia upewnij się, że określonej grupy przechwyconych rozpoczyna się od tekst, który pasuje podzbiór wzorzec zdefiniowane dla tej grupy przechwycony.</span><span class="sxs-lookup"><span data-stu-id="76f11-396">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="76f11-397">Na przykład jeśli przechwytywania grupy odpowiada word kolejnych znaków, umożliwia potwierdzenie wyprzedzenia dodatnią zerowej szerokości wymagają pierwszego znaku wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="76f11-397">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="76f11-398">Następujące przykładowe zastosowania potwierdzenia wyprzedzenia dodatnią zerowej szerokości, aby dopasować słowo, które zlecenie jest wcześniejsza "is" w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="76f11-398">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="76f11-399">Wyrażenie regularne `\b\w+(?=\sis\b)` jest interpretowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-399">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-400">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-400">Pattern</span></span>|<span data-ttu-id="76f11-401">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-401">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="76f11-402">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-402">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="76f11-403">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-403">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="76f11-404">Określ, czy znaki word następuje biały znak i ciąg "jest", której kończy się na granicy programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-404">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="76f11-405">Jeśli tak, dopasowanie jest pomyślne.</span><span class="sxs-lookup"><span data-stu-id="76f11-405">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="76f11-406">Ujemne asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="76f11-406">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="76f11-407">Poniższa konstrukcja grupowanie definiuje potwierdzenia zerowej szerokości wyprzedzenia ujemna:</span><span class="sxs-lookup"><span data-stu-id="76f11-407">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="76f11-408">`(?!`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="76f11-408">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="76f11-409">gdzie *Podwyrażenie* jest żadnych wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-409">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="76f11-410">Do dopasowania do pomyślnego ciąg wejściowy nie może być zgodna ze wzorcem wyrażenia regularnego w *Podwyrażenie*, mimo że dopasowany ciąg nie jest objęta wynik dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-410">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="76f11-411">Potwierdzenie zerowej szerokości ujemna wyprzedzenia jest zwykle używana na początku lub na końcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-411">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="76f11-412">Na początku wyrażenia regularnego, zdefiniować określony wzorzec, który nie powinny być zgodne, gdy na początku wyrażenia regularnego definiuje podobne, lecz więcej ogólnych wzorzec do dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-412">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="76f11-413">W takim przypadku jest często używany do ograniczania śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="76f11-413">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="76f11-414">Na koniec wyrażenia regularnego zdefiniować Podwyrażenie, który nie może występować na końcu dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-414">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="76f11-415">W poniższym przykładzie zdefiniowano wyrażenie regularne, który używa potwierdzenia wyprzedzenia zerowej szerokości na początku wyrażenia regularnego do dopasowania słowa, które nie rozpoczynają się "un".</span><span class="sxs-lookup"><span data-stu-id="76f11-415">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="76f11-416">Wyrażenie regularne `\b(?!un)\w+\b` jest interpretowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-416">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-417">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-417">Pattern</span></span>|<span data-ttu-id="76f11-418">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-418">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="76f11-419">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-419">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="76f11-420">Określanie, czy obok dwa znaki są "un".</span><span class="sxs-lookup"><span data-stu-id="76f11-420">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="76f11-421">Jeśli nie, możliwe jest dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="76f11-421">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="76f11-422">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-422">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="76f11-423">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-423">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="76f11-424">W poniższym przykładzie zdefiniowano wyrażenie regularne, który używa potwierdzenia wyprzedzenia zerowej szerokości na końcu wyrażenia regularnego do dopasowania słowa, które nie kończą się znak interpunkcyjny.</span><span class="sxs-lookup"><span data-stu-id="76f11-424">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="76f11-425">Wyrażenie regularne `\b\w+\b(?!\p{P})` jest interpretowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-425">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-426">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-426">Pattern</span></span>|<span data-ttu-id="76f11-427">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-427">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="76f11-428">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-428">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="76f11-429">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-429">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="76f11-430">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-430">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="76f11-431">Następny znak nie jest symbol znaki interpunkcyjne (takie jak okres lub przecinkami), dopasowania zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="76f11-431">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="76f11-432">Dodatnie asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="76f11-432">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="76f11-433">Poniższa konstrukcja grupowanie definiuje potwierdzenia dodatnie wybieganie wstecz zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="76f11-433">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="76f11-434">`(?<=`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="76f11-434">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="76f11-435">gdzie *Podwyrażenie* jest żadnych wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-435">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="76f11-436">Dopasowanie do pomyślnej *Podwyrażenie* musi przypadać w ciągu wejściowego na lewo od bieżącego położenia, mimo że `subexpression` nie znajduje się w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-436">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="76f11-437">Potwierdzenie zerowej szerokości dodatnie wybieganie wstecz nie śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="76f11-437">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="76f11-438">Asercje o zerowej szerokości dodatnie wybieganie wstecz są zazwyczaj używane na początku wyrażenia regularne.</span><span class="sxs-lookup"><span data-stu-id="76f11-438">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="76f11-439">Wzorzec, które definiują jest warunkiem wstępnym dopasowania, chociaż nie jest częścią wynik dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-439">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="76f11-440">Na przykład poniższy przykład dopasowuje dwa ostatnie cyfry roku dwudziestego pierwszego wieku (to znaczy wymaga że cyfry "20" poprzedzają dopasowany ciąg).</span><span class="sxs-lookup"><span data-stu-id="76f11-440">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="76f11-441">Wzorzec wyrażenia regularnego `(?<=\b20)\d{2}\b` jest interpretowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-441">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-442">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-442">Pattern</span></span>|<span data-ttu-id="76f11-443">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-443">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="76f11-444">Zgodne dwóch cyfr dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="76f11-444">Match two decimal digits.</span></span>|  
|`{?<=\b20)`|<span data-ttu-id="76f11-445">Nadal dopasowania, jeśli dwa cyfr dziesiętnych są poprzedzone cyfr dziesiętnych "20" na granicy programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-445">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="76f11-446">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-446">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="76f11-447">Asercje o zerowej szerokości dodatnie wybieganie wstecz są również używane do ograniczania śledzenie wsteczne podczas ostatni znak lub znaki w przechwyconej grupy muszą być podzbiorem znaków, który jest zgodny z wzorcem wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-447">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="76f11-448">Na przykład jeśli grupa przechwytuje wszystkie znaki kolejnych word, umożliwia potwierdzenie dodatnie wybieganie wstecz zerowej szerokości wymagają alfabetycznej ostatnim znakiem.</span><span class="sxs-lookup"><span data-stu-id="76f11-448">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="76f11-449">Ujemne asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="76f11-449">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="76f11-450">Poniższa konstrukcja grupowanie definiuje potwierdzenia ujemne wybieganie wstecz zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="76f11-450">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="76f11-451">`(?<!`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="76f11-451">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="76f11-452">gdzie *Podwyrażenie* jest żadnych wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-452">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="76f11-453">Dopasowanie do pomyślnej *Podwyrażenie* nie musi przypadać w ciągu wejściowego na lewo od bieżącego położenia.</span><span class="sxs-lookup"><span data-stu-id="76f11-453">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="76f11-454">Jednak podciąg, które nie odpowiadają `subexpression` nie znajduje się w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-454">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="76f11-455">Asercje o zerowej szerokości ujemne wybieganie wstecz są zazwyczaj używane na początku wyrażenia regularne.</span><span class="sxs-lookup"><span data-stu-id="76f11-455">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="76f11-456">Wzorzec, które definiują wyklucza dopasowania w ciągu, który jest zgodny.</span><span class="sxs-lookup"><span data-stu-id="76f11-456">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="76f11-457">Są one również używane do ograniczenia śledzenie wsteczne podczas ostatni znak lub znaki w przechwyconej grupy nie może być jeden lub więcej znaków, które jest zgodny z wzorcem wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="76f11-457">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="76f11-458">Na przykład jeśli grupa przechwytuje wszystkie znaki kolejnych word, umożliwia potwierdzenie zerowej szerokości dodatnie wybieganie wstecz wymagana ostatni znak podkreślenia (_) nie jest.</span><span class="sxs-lookup"><span data-stu-id="76f11-458">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</span></span>  
  
 <span data-ttu-id="76f11-459">Poniższy przykład pasuje do daty dla dowolnego dzień tygodnia, który nie jest weekendy (oznacza to, że jest sobota ani niedziela).</span><span class="sxs-lookup"><span data-stu-id="76f11-459">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="76f11-460">Wzorzec wyrażenia regularnego `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` jest interpretowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-460">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-461">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-461">Pattern</span></span>|<span data-ttu-id="76f11-462">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-462">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="76f11-463">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-463">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="76f11-464">Zgodne z co najmniej jeden znak word następuje biały znak.</span><span class="sxs-lookup"><span data-stu-id="76f11-464">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="76f11-465">Odpowiada jednej lub dwóch cyfr dziesiętnych, następuje biały znak i przecinkami.</span><span class="sxs-lookup"><span data-stu-id="76f11-465">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="76f11-466">Zgodne cztery cyfry dziesiętne i kończyć dopasowania na granicy programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-466">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|`(?<!(Saturday&#124;Sunday) )`|<span data-ttu-id="76f11-467">Jeśli dopasowanie jest poprzedzony przez inną niż ciągi, "Sobota" i "Niedziela", po którym następuje spacja, dopasowanie jest pomyślne.</span><span class="sxs-lookup"><span data-stu-id="76f11-467">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="76f11-468">Podwyrażenia bez nawrotów</span><span class="sxs-lookup"><span data-stu-id="76f11-468">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="76f11-469">Poniższa konstrukcja grupowania reprezentuje nonbacktracking Podwyrażenie (znanej także jako Podwyrażenie "zachłannego"):</span><span class="sxs-lookup"><span data-stu-id="76f11-469">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="76f11-470">`(?>`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="76f11-470">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="76f11-471">gdzie *Podwyrażenie* jest żadnych wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="76f11-471">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="76f11-472">Zwykle Jeśli wyrażenie regularne zawiera opcjonalny lub alternatywne dopasowania wzorca i dopasowania nie powiedzie się, aparat wyrażeń regularnych można gałęzi w wielu kierunkach do dopasowania ciągu wejściowego z wzorcem.</span><span class="sxs-lookup"><span data-stu-id="76f11-472">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="76f11-473">Jeśli nie znaleziono dopasowania, podczas pierwszej gałęzi, aparat wyrażeń regularnych można utworzyć kopię zapasową lub cofnąć do punktu, w którym zajęło pierwszego dopasowania i spróbuj dopasowania za pomocą drugiego gałęzi.</span><span class="sxs-lookup"><span data-stu-id="76f11-473">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="76f11-474">Ten proces można kontynuować do momentu wykonano wszystkie gałęzie.</span><span class="sxs-lookup"><span data-stu-id="76f11-474">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="76f11-475">`(?>` *Podwyrażenie* `)` języka skonstruować wyłącza śledzenie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="76f11-475">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="76f11-476">Aparat wyrażeń regularnych będzie pasował do dowolnej liczby znaków w ciągu wejściowym może.</span><span class="sxs-lookup"><span data-stu-id="76f11-476">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="76f11-477">Możliwe jest dalsze dopasowania, będzie śledzenie wsteczne nie ma podjąć próbę dopasowania wzorca alternatywny.</span><span class="sxs-lookup"><span data-stu-id="76f11-477">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="76f11-478">(Oznacza to, że Podwyrażenie jest zgodna tylko te ciągi, zgodnych przez samego Podwyrażenie; nie próbuje dopasowanie ciągu na podstawie Podwyrażenie i wszelkie użyto, których przestrzeganie).</span><span class="sxs-lookup"><span data-stu-id="76f11-478">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="76f11-479">Ta opcja jest zalecana, jeśli wiadomo, że śledzenie wsteczne nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="76f11-479">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="76f11-480">Aparat wyrażeń regularnych uniemożliwia wykonywanie niepotrzebnych wyszukiwania poprawia wydajność.</span><span class="sxs-lookup"><span data-stu-id="76f11-480">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="76f11-481">Poniższy przykład przedstawia, jak nonbacktracking Podwyrażenie modyfikuje wyniki dopasowania wzorca.</span><span class="sxs-lookup"><span data-stu-id="76f11-481">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="76f11-482">Backtracking wyrażenie regularne dopasowuje pomyślnie szereg powtarzające się znaki następuje jedno wystąpienie tego samego znaku w granicach word, ale nonbacktracking wyrażenia regularnego nie.</span><span class="sxs-lookup"><span data-stu-id="76f11-482">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="76f11-483">Wyrażenie regularne nonbacktracking `(?>(\w)\1+).\b` jest zdefiniowany, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-483">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-484">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-484">Pattern</span></span>|<span data-ttu-id="76f11-485">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-485">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="76f11-486">Dopasowuje znak pojedynczego wyrazu i przypisz je do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-486">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="76f11-487">Pasuje do wartości pierwszego podciągu przechwyconych jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="76f11-487">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="76f11-488">Dopasowuje dowolny znak.</span><span class="sxs-lookup"><span data-stu-id="76f11-488">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="76f11-489">W celu dopasowania na granicy programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-489">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="76f11-490">Zgodne jedno lub więcej wystąpień znaku słowa zduplikowane, ale nie śledzenie wsteczne odpowiadające ostatni znak w granicach programu word.</span><span class="sxs-lookup"><span data-stu-id="76f11-490">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="76f11-491">Konstrukty grupujące i obiekty wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="76f11-491">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="76f11-492">Podciągi dopasowanych przez wyrażenie regularne Przechwytywanie grupy są reprezentowane przez <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> obiektów, które mogą być pobierane z <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> obiektu, który jest zwracany przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="76f11-492">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="76f11-493"><xref:System.Text.RegularExpressions.GroupCollection> Obiektu jest wypełniana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="76f11-493">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
-   <span data-ttu-id="76f11-494">Pierwszy <xref:System.Text.RegularExpressions.Group> obiektu w kolekcji (obiekt w indeksie zero) reprezentuje cały dopasowania.</span><span class="sxs-lookup"><span data-stu-id="76f11-494">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
-   <span data-ttu-id="76f11-495">Zestaw następnej <xref:System.Text.RegularExpressions.Group> reprezentować bez nazwy grup przechwytywania (numerowana).</span><span class="sxs-lookup"><span data-stu-id="76f11-495">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="76f11-496">Pojawią się one w kolejności, w którym są definiowane w wyrażeniu regularnym od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="76f11-496">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="76f11-497">Indeks wartości tych grup w zakresie od 1 do liczby nienazwane przechwytywania grup w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="76f11-497">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="76f11-498">(Indeks określonej grupy jest odpowiednikiem jego numerowane dopasowań.</span><span class="sxs-lookup"><span data-stu-id="76f11-498">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="76f11-499">Aby uzyskać więcej informacji na temat odwołania wstecznego zobacz [konstrukcje dopasowań](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="76f11-499">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
-   <span data-ttu-id="76f11-500">Ostatni zestaw <xref:System.Text.RegularExpressions.Group> reprezentować nazwanych grup przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-500">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="76f11-501">Pojawią się one w kolejności, w którym są definiowane w wyrażeniu regularnym od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="76f11-501">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="76f11-502">Wartość indeksu pierwszego o nazwie grupy przechwytywania jest jeden większa niż indeks ostatniej grupie przechwytywania bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="76f11-502">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="76f11-503">Jeśli nie ma nie nienazwane Przechwytywanie grup wyrażenie regularne, wartość indeksu pierwszego o nazwie przechwytywania grupy jest jednym.</span><span class="sxs-lookup"><span data-stu-id="76f11-503">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="76f11-504">W przypadku zastosowania do przechwytywania grupy, odpowiednie kwantyfikator <xref:System.Text.RegularExpressions.Group> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, i <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> właściwości odzwierciedlenia ostatnich podciąg przechwycony przez grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-504">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="76f11-505">Możesz pobrać kompletny zestaw podciągów przechwytywanych przez grupy, które mają Kwantyfikatory z <xref:System.Text.RegularExpressions.CaptureCollection> obiektu, który jest zwracany przez <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="76f11-505">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="76f11-506">Poniższy przykład wyjaśnia relacji między <xref:System.Text.RegularExpressions.Group> i <xref:System.Text.RegularExpressions.Capture> obiektów.</span><span class="sxs-lookup"><span data-stu-id="76f11-506">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="76f11-507">Wzorzec wyrażenia regularnego `\b(\w+)\W+)+` wyodrębnia poszczególnych wyrazów z ciągu.</span><span class="sxs-lookup"><span data-stu-id="76f11-507">The regular expression pattern `\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="76f11-508">Definicję tego wyrażenia pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="76f11-508">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="76f11-509">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="76f11-509">Pattern</span></span>|<span data-ttu-id="76f11-510">Opis</span><span class="sxs-lookup"><span data-stu-id="76f11-510">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="76f11-511">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-511">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="76f11-512">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="76f11-512">Match one or more word characters.</span></span> <span data-ttu-id="76f11-513">Te znaki tworzą razem wyrazu.</span><span class="sxs-lookup"><span data-stu-id="76f11-513">Together, these characters form a word.</span></span> <span data-ttu-id="76f11-514">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-514">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="76f11-515">Zgodne z co najmniej jeden znak-word.</span><span class="sxs-lookup"><span data-stu-id="76f11-515">Match one or more non-word characters.</span></span>|  
|`(\w+)\W+)+`|<span data-ttu-id="76f11-516">Pasuje do wzorca co najmniej jeden znak słowa jednego lub więcej z systemem innym niż word znaków jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="76f11-516">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="76f11-517">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-517">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="76f11-518">Pierwsza grupa przechwytywania odpowiada każdego wyrazu zdania.</span><span class="sxs-lookup"><span data-stu-id="76f11-518">The first capturing group matches each word of the sentence.</span></span> <span data-ttu-id="76f11-519">Drugiej grupy przechwytywania odpowiada każdego wyrazu oraz znaki interpunkcyjne i białe, który wyrazie.</span><span class="sxs-lookup"><span data-stu-id="76f11-519">The second capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="76f11-520"><xref:System.Text.RegularExpressions.Group> Obiektu, którego indeks jest 2 zawiera informacje o tekst uwzględniony przez drugiej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="76f11-520">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="76f11-521">Pełny zestaw wyrazów przechwycone przez Przechwytywanie grupy są dostępne z <xref:System.Text.RegularExpressions.CaptureCollection> obiektu zwróconego przez <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="76f11-521">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="76f11-522">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="76f11-522">See Also</span></span>  
 [<span data-ttu-id="76f11-523">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="76f11-523">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="76f11-524">Śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="76f11-524">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
