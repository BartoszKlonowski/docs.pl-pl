---
title: Konstrukcje grupujące w wyrażeniach regularnych
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 57198cb9fb0042a3a74589e2781b3db1a2b829f1
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/22/2019
ms.locfileid: "69963377"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="3f550-102">Konstrukcje grupujące w wyrażeniach regularnych</span><span class="sxs-lookup"><span data-stu-id="3f550-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="3f550-103">Konstrukcje grupujące odróżnić podwyrażenia wyrażenia regularnego i przechwytuje podciągi ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="3f550-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="3f550-104">Można użyć konstrukcji grupowania, aby wykonać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="3f550-104">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="3f550-105">Dopasowuje Podwyrażenie powtarzające się w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="3f550-105">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="3f550-106">Zastosuj kwantyfikator do podwyrażenia, które ma wiele elementów języka wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="3f550-107">Aby uzyskać więcej informacji na temat kwantyfikatorów [](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md), zobacz Kwantyfikatory.</span><span class="sxs-lookup"><span data-stu-id="3f550-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="3f550-108">Uwzględnij Podwyrażenie w ciągu, który jest zwracany przez <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> metody i. <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3f550-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="3f550-109">Pobierz pojedyncze Podwyrażenie z <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości i przetwórz je niezależnie od dopasowanego tekstu jako całości.</span><span class="sxs-lookup"><span data-stu-id="3f550-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="3f550-110">W poniższej tabeli wymieniono konstrukcje grupujące obsługiwane przez aparat wyrażeń regularnych programu .NET i wskazuje, czy są przechwytywane lub nieprzechwytywane.</span><span class="sxs-lookup"><span data-stu-id="3f550-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="3f550-111">Konstrukcja grupująca</span><span class="sxs-lookup"><span data-stu-id="3f550-111">Grouping construct</span></span>|<span data-ttu-id="3f550-112">Przechwytywanie lub przechwytywanie</span><span class="sxs-lookup"><span data-stu-id="3f550-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="3f550-113">Dopasowane podwyrażenia</span><span class="sxs-lookup"><span data-stu-id="3f550-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="3f550-114">Przechwytywania</span><span class="sxs-lookup"><span data-stu-id="3f550-114">Capturing</span></span>|  
|[<span data-ttu-id="3f550-115">Nazwane dopasowane wyrażenia cząstkowe</span><span class="sxs-lookup"><span data-stu-id="3f550-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="3f550-116">Przechwytywania</span><span class="sxs-lookup"><span data-stu-id="3f550-116">Capturing</span></span>|  
|[<span data-ttu-id="3f550-117">Definicje grup równoważenia</span><span class="sxs-lookup"><span data-stu-id="3f550-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="3f550-118">Przechwytywania</span><span class="sxs-lookup"><span data-stu-id="3f550-118">Capturing</span></span>|  
|[<span data-ttu-id="3f550-119">Grupy nieprzechwycone</span><span class="sxs-lookup"><span data-stu-id="3f550-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="3f550-120">Nieprzechwyconą</span><span class="sxs-lookup"><span data-stu-id="3f550-120">Noncapturing</span></span>|  
|[<span data-ttu-id="3f550-121">Opcje grupy</span><span class="sxs-lookup"><span data-stu-id="3f550-121">Group options</span></span>](#group_options)|<span data-ttu-id="3f550-122">Nieprzechwyconą</span><span class="sxs-lookup"><span data-stu-id="3f550-122">Noncapturing</span></span>|  
|[<span data-ttu-id="3f550-123">Pozytywne potwierdzenia naprzód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="3f550-124">Nieprzechwyconą</span><span class="sxs-lookup"><span data-stu-id="3f550-124">Noncapturing</span></span>|  
|[<span data-ttu-id="3f550-125">Negatywne potwierdzenia naprzód w zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="3f550-126">Nieprzechwyconą</span><span class="sxs-lookup"><span data-stu-id="3f550-126">Noncapturing</span></span>|  
|[<span data-ttu-id="3f550-127">Pozytywne potwierdzenia asercja wsteczna o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="3f550-128">Nieprzechwyconą</span><span class="sxs-lookup"><span data-stu-id="3f550-128">Noncapturing</span></span>|  
|[<span data-ttu-id="3f550-129">Negatywne asercja wstecznay o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="3f550-130">Nieprzechwyconą</span><span class="sxs-lookup"><span data-stu-id="3f550-130">Noncapturing</span></span>|  
|[<span data-ttu-id="3f550-131">Podwyrażenia Podwyrażenie</span><span class="sxs-lookup"><span data-stu-id="3f550-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="3f550-132">Nieprzechwyconą</span><span class="sxs-lookup"><span data-stu-id="3f550-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="3f550-133">Aby uzyskać informacje na temat grup i modelu obiektów wyrażeń regularnych, zobacz [Grouping konstrukcjes and Regular Expression Objects](#Objects).</span><span class="sxs-lookup"><span data-stu-id="3f550-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="3f550-134">Dopasowane podwyrażenie</span><span class="sxs-lookup"><span data-stu-id="3f550-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="3f550-135">Następująca konstrukcja grupująca przechwytuje Dopasowane Podwyrażenie:</span><span class="sxs-lookup"><span data-stu-id="3f550-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="3f550-136">`(`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="3f550-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="3f550-137">gdzie *subexpression* jest dowolnym prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="3f550-138">Przechwytuje, że nawiasy są numerowane automatycznie od lewej do prawej na podstawie kolejności nawiasów otwierających w wyrażeniu regularnym, rozpoczynając od jednego.</span><span class="sxs-lookup"><span data-stu-id="3f550-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="3f550-139">Przechwytywanie o numerze zero jest tekstem dopasowanym przez cały wzorzec wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3f550-140">Domyślnie `(`element języka subexpression `)` przechwytuje Dopasowane Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="3f550-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="3f550-141">Ale jeśli <xref:System.Text.RegularExpressions.RegexOptions> parametr metody dopasowania do wzorca wyrażenia regularnego <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> zawiera `n` flagę lub jeśli opcja jest stosowana do tego podwyrażenia (zobacz [Opcje grupy](#group_options) w dalszej części tego tematu), dopasowane Podwyrażenie jest nie przechwycono.</span><span class="sxs-lookup"><span data-stu-id="3f550-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="3f550-142">Dostęp do przechwyconych grup można uzyskać na cztery sposoby:</span><span class="sxs-lookup"><span data-stu-id="3f550-142">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="3f550-143">Za pomocą konstrukcji odwołania wstecznego w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="3f550-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="3f550-144">Dopasowane Podwyrażenie jest przywoływane w tym samym wyrażeniu regularnym przy `\`użyciu *numeru*składni, gdzie *Number* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="3f550-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="3f550-145">Za pomocą nazwanej konstrukcji odwołania wstecznego w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="3f550-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="3f550-146">Dopasowane Podwyrażenie jest przywoływane w tym samym wyrażeniu regularnym przy `\k<`użyciu *nazwy*`>`składni, gdzie *name* to nazwa grupy przechwytywania lub `\k<` *Liczba*`>`, gdzie  *Liczba* jest numerem porządkowym grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="3f550-147">Grupa przechwytywania ma nazwę domyślną, która jest identyczna z numerem porządkowym.</span><span class="sxs-lookup"><span data-stu-id="3f550-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="3f550-148">Aby uzyskać więcej informacji, zobacz [nazwane dopasowane podwyrażenia](#named_matched_subexpression) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="3f550-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="3f550-149">`$`Przy użyciu <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> sekwencji <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> zastępczej *liczb* w wywołaniu metody lub, gdzie *Number* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="3f550-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="3f550-150">Programowo, przy użyciu <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="3f550-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3f550-151">Element członkowski na pozycji zero w kolekcji reprezentuje całe dopasowanie wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="3f550-152">Każdy kolejny element członkowski reprezentuje Dopasowane Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="3f550-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="3f550-153">Aby uzyskać więcej informacji, zobacz sekcję [konstrukcje grupujące i obiekty wyrażeń regularnych](#Objects) .</span><span class="sxs-lookup"><span data-stu-id="3f550-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="3f550-154">Poniższy przykład ilustruje wyrażenie regularne, które identyfikuje duplikaty wyrazów w tekście.</span><span class="sxs-lookup"><span data-stu-id="3f550-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="3f550-155">Dwie grupy przechwytywania wzorca wyrażenia regularnego reprezentują dwa wystąpienia zduplikowanego wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="3f550-156">Drugie wystąpienie jest przechwytywane, aby zgłosić jego pozycję początkową w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="3f550-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="3f550-157">Wzorzec wyrażenia regularnego jest następujący:</span><span class="sxs-lookup"><span data-stu-id="3f550-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="3f550-158">W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="3f550-159">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-159">Pattern</span></span>|<span data-ttu-id="3f550-160">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="3f550-161">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-161">Match one or more word characters.</span></span> <span data-ttu-id="3f550-162">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="3f550-163">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="3f550-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="3f550-164">Dopasowuje ciąg w pierwszej przechwyconej grupie.</span><span class="sxs-lookup"><span data-stu-id="3f550-164">Match the string in the first captured group.</span></span> <span data-ttu-id="3f550-165">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-165">This is the second capturing group.</span></span> <span data-ttu-id="3f550-166">Przykład przypisuje go do przechwyconej grupy, aby można było pobrać początkową pozycję zduplikowanego słowa z `Match.Index` właściwości.</span><span class="sxs-lookup"><span data-stu-id="3f550-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="3f550-167">Dopasowuje znak niebędący słowem, w tym odstępy i znaki interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="3f550-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="3f550-168">Zapobiega to, aby wzorzec wyrażenia regularnego był zgodny z wyrazem rozpoczynającym się od pierwszej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="3f550-169">O nazwie dopasowane podwyrażenia</span><span class="sxs-lookup"><span data-stu-id="3f550-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="3f550-170">Następująca konstrukcja grupująca przechwytuje Dopasowane Podwyrażenie i umożliwia dostęp do niego według nazwy lub liczby:</span><span class="sxs-lookup"><span data-stu-id="3f550-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="3f550-171">lub:</span><span class="sxs-lookup"><span data-stu-id="3f550-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="3f550-172">gdzie *name* jest prawidłową nazwą grupy, a *subexpression* jest dowolnym prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="3f550-173">*Nazwa* nie może zawierać żadnych znaków interpunkcyjnych i nie może rozpoczynać się od cyfry.</span><span class="sxs-lookup"><span data-stu-id="3f550-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3f550-174">Jeśli parametr metody zgodnej z wzorcem wyrażenia regularnego <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> zawiera `n` flagę lub jeśli opcja jest stosowana do tego podwyrażenia (zobacz [Opcje grupy](#group_options) w dalszej części tego tematu), jedynym sposobem przechwycenia <xref:System.Text.RegularExpressions.RegexOptions> Podwyrażenie ma jawnie nazwę przechwytywania grup.</span><span class="sxs-lookup"><span data-stu-id="3f550-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="3f550-175">Można uzyskać dostęp do nazwanych przechwyconych grup w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="3f550-175">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="3f550-176">Za pomocą nazwanej konstrukcji odwołania wstecznego w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="3f550-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="3f550-177">Dopasowane Podwyrażenie jest przywoływane w tym samym wyrażeniu regularnym przy `\k<`użyciu *nazwy*`>`składni, gdzie *name* to nazwa przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="3f550-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="3f550-178">Za pomocą konstrukcji odwołania wstecznego w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="3f550-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="3f550-179">Dopasowane Podwyrażenie jest przywoływane w tym samym wyrażeniu regularnym przy `\`użyciu *numeru*składni, gdzie *Number* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="3f550-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="3f550-180">Nazwane dopasowane podwyrażenia są numerowane kolejno od lewej do prawej po dopasowaniu podwyrażeń.</span><span class="sxs-lookup"><span data-stu-id="3f550-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="3f550-181">Przy użyciu `${`kolejności zamieniania *nazw* `}` w <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> wywołaniu metody <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> lub, gdzie *name* jest nazwą przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="3f550-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="3f550-182">`$`Przy użyciu <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> sekwencji <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> zastępczej *liczb* w wywołaniu metody lub, gdzie *Number* jest numerem porządkowym przechwyconego podwyrażenia.</span><span class="sxs-lookup"><span data-stu-id="3f550-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="3f550-183">Programowo, przy użyciu <xref:System.Text.RegularExpressions.GroupCollection> obiektu zwróconego <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="3f550-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3f550-184">Element członkowski na pozycji zero w kolekcji reprezentuje całe dopasowanie wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="3f550-185">Każdy kolejny element członkowski reprezentuje Dopasowane Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="3f550-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="3f550-186">Nazwane przechwycone grupy są przechowywane w kolekcji po numerowanych przechwyconych grupach.</span><span class="sxs-lookup"><span data-stu-id="3f550-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="3f550-187">Programowo, dostarczając nazwę podwyrażenia do <xref:System.Text.RegularExpressions.GroupCollection> indeksatora obiektu (w programie C#) lub do jego <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> właściwości (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f550-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="3f550-188">Prosty wzorzec wyrażenia regularnego ilustruje, jak numerowane (nienazwane) i nazwane grupy mogą być przywoływane programowo lub za pomocą składni języka wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="3f550-189">Wyrażenie `((?<One>abc)\d+)?(?<Two>xyz)(.*)` regularne generuje następujące grupy przechwytywania według liczby i według nazwy.</span><span class="sxs-lookup"><span data-stu-id="3f550-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="3f550-190">Pierwsza grupa przechwytywania (numer 0) zawsze odwołuje się do całego wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="3f550-191">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="3f550-191">Number</span></span>|<span data-ttu-id="3f550-192">Nazwa</span><span class="sxs-lookup"><span data-stu-id="3f550-192">Name</span></span>|<span data-ttu-id="3f550-193">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="3f550-194">0</span><span class="sxs-lookup"><span data-stu-id="3f550-194">0</span></span>|<span data-ttu-id="3f550-195">0 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="3f550-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="3f550-196">1</span><span class="sxs-lookup"><span data-stu-id="3f550-196">1</span></span>|<span data-ttu-id="3f550-197">1 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="3f550-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="3f550-198">2</span><span class="sxs-lookup"><span data-stu-id="3f550-198">2</span></span>|<span data-ttu-id="3f550-199">2 (nazwa domyślna)</span><span class="sxs-lookup"><span data-stu-id="3f550-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="3f550-200">3</span><span class="sxs-lookup"><span data-stu-id="3f550-200">3</span></span>|<span data-ttu-id="3f550-201">Jeden</span><span class="sxs-lookup"><span data-stu-id="3f550-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="3f550-202">4</span><span class="sxs-lookup"><span data-stu-id="3f550-202">4</span></span>|<span data-ttu-id="3f550-203">Tymi</span><span class="sxs-lookup"><span data-stu-id="3f550-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="3f550-204">Poniższy przykład ilustruje wyrażenie regularne, które identyfikuje zduplikowane wyrazy i słowo, które bezpośrednio następuje po każdym zduplikowanym wyrazie.</span><span class="sxs-lookup"><span data-stu-id="3f550-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="3f550-205">Wzorzec wyrażenia regularnego definiuje dwa nazwane Podwyrażenie: `duplicateWord`, które reprezentuje duplikat wyrazu, i `nextWord`, który reprezentuje wyraz, który następuje po zduplikowanym wyrazie.</span><span class="sxs-lookup"><span data-stu-id="3f550-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="3f550-206">Wzorzec wyrażenia regularnego jest następujący:</span><span class="sxs-lookup"><span data-stu-id="3f550-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="3f550-207">W poniższej tabeli przedstawiono sposób interpretowania wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="3f550-208">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-208">Pattern</span></span>|<span data-ttu-id="3f550-209">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="3f550-210">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-210">Match one or more word characters.</span></span> <span data-ttu-id="3f550-211">Nadaj nazwę tej grupie `duplicateWord`przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="3f550-212">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="3f550-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="3f550-213">Dopasowuje ciąg z przechwyconej grupy o nazwie `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="3f550-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="3f550-214">Dopasowuje znak niebędący słowem, w tym odstępy i znaki interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="3f550-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="3f550-215">Zapobiega to, aby wzorzec wyrażenia regularnego był zgodny z wyrazem rozpoczynającym się od pierwszej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="3f550-216">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-216">Match one or more word characters.</span></span> <span data-ttu-id="3f550-217">Nadaj nazwę tej grupie `nextWord`przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="3f550-218">Należy zauważyć, że nazwa grupy może być powtórzona w wyrażeniu regularnym.</span><span class="sxs-lookup"><span data-stu-id="3f550-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="3f550-219">Na przykład można mieć `digit`więcej niż jedną grupę, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3f550-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="3f550-220">W przypadku zduplikowanych nazw wartość <xref:System.Text.RegularExpressions.Group> obiektu zależy od ostatniego pomyślnego przechwycenia w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="3f550-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="3f550-221">Ponadto <xref:System.Text.RegularExpressions.CaptureCollection> jest wypełniany informacjami o każdym przechwytywaniu, tak jak gdyby nazwa grupy nie była duplikatem.</span><span class="sxs-lookup"><span data-stu-id="3f550-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="3f550-222">W poniższym przykładzie wyrażenie `\D+(?<digit>\d+)\D+(?<digit>\d+)?` regularne zawiera dwa wystąpienia grupy o nazwie. `digit`</span><span class="sxs-lookup"><span data-stu-id="3f550-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="3f550-223">Pierwsza `digit` nazwana grupa przechwytuje co najmniej jeden znak cyfr.</span><span class="sxs-lookup"><span data-stu-id="3f550-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="3f550-224">Druga `digit` nazwana grupa przechwytuje zero lub jedno wystąpienie co najmniej jednego znaku cyfry.</span><span class="sxs-lookup"><span data-stu-id="3f550-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="3f550-225">Jako dane wyjściowe z przykładu pokazują, jeśli druga grupa przechwytywania pomyślnie dopasowuje tekst, wartość tego tekstu definiuje wartość <xref:System.Text.RegularExpressions.Group> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3f550-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="3f550-226">Jeśli druga grupa przechwytywania nie może być zgodna z ciągiem wejściowym, wartość ostatniego pomyślnego dopasowania definiuje wartość <xref:System.Text.RegularExpressions.Group> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3f550-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="3f550-227">W poniższej tabeli przedstawiono sposób interpretowania wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="3f550-228">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-228">Pattern</span></span>|<span data-ttu-id="3f550-229">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="3f550-230">Dopasowuje co najmniej jeden znak niebędący cyfrą dziesiętną.</span><span class="sxs-lookup"><span data-stu-id="3f550-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="3f550-231">Dopasowuje jeden lub więcej cyfr dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="3f550-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="3f550-232">Przypisz dopasowanie do `digit` nazwanej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-232">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="3f550-233">Dopasowuje co najmniej jeden znak niebędący cyfrą dziesiętną.</span><span class="sxs-lookup"><span data-stu-id="3f550-233">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="3f550-234">Dopasowanie do zera lub jednego wystąpienia co najmniej jednego znaku cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="3f550-234">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="3f550-235">Przypisz dopasowanie do `digit` nazwanej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-235">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="3f550-236">Równoważenie definicji grup</span><span class="sxs-lookup"><span data-stu-id="3f550-236">Balancing Group Definitions</span></span>  
 <span data-ttu-id="3f550-237">Definicja grupy równoważenia usuwa definicję wcześniej zdefiniowanej grupy i magazynów w bieżącej grupie, interwał między wcześniej zdefiniowaną grupą a bieżącą grupą.</span><span class="sxs-lookup"><span data-stu-id="3f550-237">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="3f550-238">Ta konstrukcja grupująca ma następujący format:</span><span class="sxs-lookup"><span data-stu-id="3f550-238">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="3f550-239">lub:</span><span class="sxs-lookup"><span data-stu-id="3f550-239">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="3f550-240">gdzie *Name1* jest bieżącą grupą (opcjonalnie), *NAME2* jest wcześniej zdefiniowaną grupą i podwyrażeniem jest dowolnym prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-240">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="3f550-241">Definicja grupy równoważenia usuwa definicję *NAME2* i przechowuje interwał między *NAME2* i *Name1* w *Name1*.</span><span class="sxs-lookup"><span data-stu-id="3f550-241">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="3f550-242">Jeśli nie zdefiniowano żadnej grupy *NAME2* , dopasowanie wsteczne.</span><span class="sxs-lookup"><span data-stu-id="3f550-242">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="3f550-243">Ponieważ usunięcie ostatniej definicji elementu *NAME2* ujawnia poprzednią definicję *NAME2*, Ta konstrukcja umożliwia użycie stosu przechwytywania dla grupy *NAME2* jako licznika do śledzenia zagnieżdżonych konstrukcji, takich jak nawiasy lub otwieranie i zamykające nawiasy klamrowe.</span><span class="sxs-lookup"><span data-stu-id="3f550-243">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="3f550-244">Definicja grupy równoważenia używa *NAME2* jako stosu.</span><span class="sxs-lookup"><span data-stu-id="3f550-244">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="3f550-245">Początkowy znak każdej zagnieżdżonej konstrukcji jest umieszczany w grupie i w swojej <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="3f550-245">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="3f550-246">Po dopasowaniu znaku zamykającego jego odpowiedni znak otwierający jest usuwany z grupy, a <xref:System.Text.RegularExpressions.Group.Captures%2A> kolekcja zostanie zmniejszona o jeden.</span><span class="sxs-lookup"><span data-stu-id="3f550-246">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="3f550-247">Po dopasowaniu i zamykaniu znaków wszystkich zagnieżdżonych konstrukcji *NAME2* jest puste.</span><span class="sxs-lookup"><span data-stu-id="3f550-247">After the opening and closing characters of all nested constructs have been matched, *name2* is empty.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3f550-248">Po zmodyfikowaniu wyrażenia regularnego w poniższym przykładzie, aby użyć odpowiedniego otwierającego i zamykającego znaku zagnieżdżonej konstrukcji, można użyć go do obsługi większości zagnieżdżonych konstrukcji, takich jak wyrażenia matematyczne lub wiersze kodu programu, które obejmują wiele wywołań metod zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="3f550-248">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="3f550-249">W poniższym przykładzie jest stosowana definicja grupy równoważenia do dopasowania do lewego i prawego nawiasu ostrego (< >) w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="3f550-249">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="3f550-250">W przykładzie zdefiniowano dwie nazwane grupy `Open` , `Close`które są używane jak stos do śledzenia dopasowania par nawiasów ostrych.</span><span class="sxs-lookup"><span data-stu-id="3f550-250">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="3f550-251">Każdy przechwycony lewy nawias kątowy jest wypychany do kolekcji `Open` przechwytywania grupy, a każdy przechwycony prawy nawias kątowy jest wypychany do kolekcji `Close` przechwytywania grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-251">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="3f550-252">Definicja grupy równoważenia gwarantuje, że istnieje pasujący prawy nawias kątowy dla każdego lewego nawiasu kątowego.</span><span class="sxs-lookup"><span data-stu-id="3f550-252">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="3f550-253">Jeśli nie istnieje, ostateczny podwzorzec `(?(Open)(?!))`,,, jest oceniany tylko `Open` wtedy, gdy grupa nie jest pusta (i dlatego, jeśli wszystkie zagnieżdżone konstrukcje nie zostały zamknięte).</span><span class="sxs-lookup"><span data-stu-id="3f550-253">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="3f550-254">Jeśli ostateczny wzorzec jest szacowany, dopasowanie nie powiedzie się, ponieważ `(?!)` podwzorzec jest nieprawidłowym pomyślnym wyprzedzeniem o zerowej szerokości, które zawsze kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="3f550-254">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="3f550-255">Wzorzec wyrażenia regularnego:</span><span class="sxs-lookup"><span data-stu-id="3f550-255">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="3f550-256">Wyrażenie regularne jest interpretowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="3f550-256">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="3f550-257">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-257">Pattern</span></span>|<span data-ttu-id="3f550-258">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-258">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="3f550-259">Zacznij od początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="3f550-259">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="3f550-260">Dopasowuje zero lub więcej znaków, które nie są w lewo lub w prawo.</span><span class="sxs-lookup"><span data-stu-id="3f550-260">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="3f550-261">Dopasowuje lewy nawias ostry i przypisuje go do grupy o `Open`nazwie.</span><span class="sxs-lookup"><span data-stu-id="3f550-261">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="3f550-262">Dopasowuje zero lub więcej znaków, które nie są w lewo lub w prawo.</span><span class="sxs-lookup"><span data-stu-id="3f550-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*)+`|<span data-ttu-id="3f550-263">Dopasowuje co najmniej jedno wystąpienie lewego nawiasu kątowego, po którym następuje zero lub więcej znaków, które nie są w lewo lub w prawo.</span><span class="sxs-lookup"><span data-stu-id="3f550-263">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="3f550-264">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-264">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="3f550-265">Dopasowuje prawy nawias kątowy, przypisz podciąg między `Open` grupą i bieżącą grupą `Close` do grupy, a następnie `Open` usuń definicję grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-265">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="3f550-266">Dopasowuje zero lub więcej wystąpień dowolnego znaku, który nie jest lewym ani prawym nawiasem ostrym.</span><span class="sxs-lookup"><span data-stu-id="3f550-266">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="3f550-267">Dopasowuje jedno lub więcej wystąpień prawego nawiasu ostrego, po którym następuje zero lub więcej wystąpień dowolnego znaku, który nie jest lewym ani prawym nawiasem ostrym.</span><span class="sxs-lookup"><span data-stu-id="3f550-267">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="3f550-268">W przypadku dopasowania do prawego nawiasu ostrego Przypisz podciąg `Open` między grupą i bieżącą grupą `Close` do grupy, a następnie `Open` usuń definicję grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-268">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="3f550-269">Jest to trzecia grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-269">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="3f550-270">Dopasowanie do zera lub większej liczby wystąpień następującego wzorca: co najmniej jedno wystąpienie lewego nawiasu kątowego, po którym następuje zero lub więcej znaków nieostrych, po którym następuje jedno lub więcej wystąpień prawego nawiasu ostrego, po którym następuje zero lub więcej wystąpień nawiasy ostre.</span><span class="sxs-lookup"><span data-stu-id="3f550-270">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="3f550-271">W przypadku dopasowania do prawego nawiasu ostrego usuń definicję `Open` grupy i przypisz podciąg `Open` między grupą a bieżącą grupą do `Close` grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-271">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="3f550-272">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-272">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="3f550-273">`Open` Jeśli grupa istnieje, Porzuć dopasowanie, jeśli ciąg pusty można dopasować, ale nie przesuwaj pozycji aparatu wyrażeń regularnych w ciągu.</span><span class="sxs-lookup"><span data-stu-id="3f550-273">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="3f550-274">Jest to nieujemne potwierdzenie o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="3f550-274">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="3f550-275">Ponieważ pusty ciąg jest zawsze niejawnie obecny w ciągu wejściowym, to dopasowanie zawsze kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="3f550-275">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="3f550-276">Niepowodzenie tego dopasowania wskazuje, że nawiasy kątowe nie są zrównoważone.</span><span class="sxs-lookup"><span data-stu-id="3f550-276">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="3f550-277">Dopasowuje koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="3f550-277">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="3f550-278">Ostateczne Podwyrażenie `(?(Open)(?!))`,, wskazuje, czy konstrukcje zagnieżdżania w ciągu wejściowym są prawidłowo zrównoważone (na przykład czy każdy lewy nawias kątowy jest dopasowywany przez prawy nawias kątowy).</span><span class="sxs-lookup"><span data-stu-id="3f550-278">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="3f550-279">Używa dopasowania warunkowego opartego na prawidłowej przechwyconej grupie; Aby uzyskać więcej informacji, zobacz [konstrukcje warunkowe](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="3f550-279">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="3f550-280">Jeśli grupa jest zdefiniowana, aparat wyrażeń regularnych próbuje dopasować Podwyrażenie `(?!)` w ciągu wejściowym. `Open`</span><span class="sxs-lookup"><span data-stu-id="3f550-280">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="3f550-281">Grupę `Open` należy zdefiniować tylko wtedy, gdy konstrukcje zagnieżdżania są niezrównoważone.</span><span class="sxs-lookup"><span data-stu-id="3f550-281">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="3f550-282">W związku z tym wzorzec, który ma zostać dopasowany w ciągu wejściowym powinien być taki, który zawsze powoduje niepowodzenie dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-282">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="3f550-283">W tym przypadku `(?!)` jest to bezwzględne, negatywne potwierdzenie o zerowej szerokości, które zawsze kończy się niepowodzeniem, ponieważ pusty ciąg jest zawsze niejawnie obecny na następnej pozycji w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="3f550-283">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="3f550-284">W przykładzie aparat wyrażeń regularnych oblicza ciąg wejściowy "\<ABC > < MNO\<xyz > >", jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-284">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-285">Krok</span><span class="sxs-lookup"><span data-stu-id="3f550-285">Step</span></span>|<span data-ttu-id="3f550-286">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-286">Pattern</span></span>|<span data-ttu-id="3f550-287">Wynik</span><span class="sxs-lookup"><span data-stu-id="3f550-287">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="3f550-288">1</span><span class="sxs-lookup"><span data-stu-id="3f550-288">1</span></span>|`^`|<span data-ttu-id="3f550-289">Rozpoczyna dopasowanie na początku ciągu wejściowego</span><span class="sxs-lookup"><span data-stu-id="3f550-289">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="3f550-290">2</span><span class="sxs-lookup"><span data-stu-id="3f550-290">2</span></span>|`[^<>]*`|<span data-ttu-id="3f550-291">Wyszukuje znaki niebędące nawiasami ostrymi przed lewym nawiasem ostrym; znajduje brak dopasowań.</span><span class="sxs-lookup"><span data-stu-id="3f550-291">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="3f550-292">3</span><span class="sxs-lookup"><span data-stu-id="3f550-292">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="3f550-293">Dopasowuje lewy nawias ostry w "\<ABC >" i przypisuje go `Open` do grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-293">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="3f550-294">4</span><span class="sxs-lookup"><span data-stu-id="3f550-294">4</span></span>|`[^<>]*`|<span data-ttu-id="3f550-295">Pasuje do "ABC".</span><span class="sxs-lookup"><span data-stu-id="3f550-295">Matches "abc".</span></span>|  
|<span data-ttu-id="3f550-296">5</span><span class="sxs-lookup"><span data-stu-id="3f550-296">5</span></span>|`)+`|<span data-ttu-id="3f550-297">"< ABC" to wartość drugiej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-297">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="3f550-298">Następny znak w ciągu wejściowym nie jest nawiasem ostrym, dlatego aparat wyrażeń regularnych nie jest odtwarzany z powrotem do `(?'Open'<)[^<>]*)` wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-298">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-299">6</span><span class="sxs-lookup"><span data-stu-id="3f550-299">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="3f550-300">Dopasowuje prawy nawias kątowy w\<"ABC >", przypisuje "ABC", który jest podciągiem `Open` między grupą i prawego nawiasu `Close` ostrego, do grupy i usuwa bieżącą `Open` wartość ("<") grupy, pozostawienie go puste.</span><span class="sxs-lookup"><span data-stu-id="3f550-300">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="3f550-301">7</span><span class="sxs-lookup"><span data-stu-id="3f550-301">7</span></span>|`[^<>]*`|<span data-ttu-id="3f550-302">Wyszukuje znaki niebędące nawiasami ostrymi po prawym nawiasie ostrym; nie znaleziono żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="3f550-302">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="3f550-303">8</span><span class="sxs-lookup"><span data-stu-id="3f550-303">8</span></span>|`)+`|<span data-ttu-id="3f550-304">Wartość trzeciej przechwyconej grupy to ">".</span><span class="sxs-lookup"><span data-stu-id="3f550-304">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="3f550-305">Następny znak w ciągu wejściowym nie jest prawym nawiasem ostrym, więc aparat wyrażeń regularnych nie jest w pętli z powrotem do `((?'Close-Open'>)[^<>]*)` wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-305">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-306">9</span><span class="sxs-lookup"><span data-stu-id="3f550-306">9</span></span>|`)*`|<span data-ttu-id="3f550-307">Wartość pierwszej przechwyconej grupy to "\<ABC >".</span><span class="sxs-lookup"><span data-stu-id="3f550-307">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="3f550-308">Następny znak w ciągu wejściowym jest lewym nawiasem ostrym, dlatego aparat wyrażeń regularnych jest odtwarzany z powrotem `(((?'Open'<)` do wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-308">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-309">10</span><span class="sxs-lookup"><span data-stu-id="3f550-309">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="3f550-310">Dopasowuje lewy nawias ostry w "\<MNO" i przypisuje go `Open` do grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-310">Matches the left angle bracket in "\<mno" and assigns it to the `Open` group.</span></span> <span data-ttu-id="3f550-311">Jej <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekcja ma teraz jedną wartość "<".</span><span class="sxs-lookup"><span data-stu-id="3f550-311">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="3f550-312">11</span><span class="sxs-lookup"><span data-stu-id="3f550-312">11</span></span>|`[^<>]*`|<span data-ttu-id="3f550-313">Pasuje do "MNO".</span><span class="sxs-lookup"><span data-stu-id="3f550-313">Matches "mno".</span></span>|  
|<span data-ttu-id="3f550-314">12</span><span class="sxs-lookup"><span data-stu-id="3f550-314">12</span></span>|`)+`|<span data-ttu-id="3f550-315">"< MNO" to wartość drugiej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-315">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="3f550-316">Następny znak w ciągu wejściowym jest lewym nawiasem ostrym, dlatego aparat wyrażeń regularnych jest odtwarzany z powrotem `(?'Open'<)[^<>]*)` do wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-316">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-317">13</span><span class="sxs-lookup"><span data-stu-id="3f550-317">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="3f550-318">Dopasowuje lewy nawias ostry w "\<xyz >" i przypisuje go `Open` do grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-318">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="3f550-319">Kolekcja grup zawiera teraz dwa przechwycenia: lewy nawias kątowy od "\<MNO" i lewy nawias ostry od "\<xyz >". `Open` <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3f550-319">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="3f550-320">14</span><span class="sxs-lookup"><span data-stu-id="3f550-320">14</span></span>|`[^<>]*`|<span data-ttu-id="3f550-321">Dopasowuje "XYZ".</span><span class="sxs-lookup"><span data-stu-id="3f550-321">Matches "xyz".</span></span>|  
|<span data-ttu-id="3f550-322">15</span><span class="sxs-lookup"><span data-stu-id="3f550-322">15</span></span>|`)+`|<span data-ttu-id="3f550-323">"< XYZ" to wartość drugiej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-323">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="3f550-324">Następny znak w ciągu wejściowym nie jest nawiasem ostrym, dlatego aparat wyrażeń regularnych nie jest odtwarzany z powrotem do `(?'Open'<)[^<>]*)` wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-324">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-325">16</span><span class="sxs-lookup"><span data-stu-id="3f550-325">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="3f550-326">Dopasowuje prawy nawias kątowy w\<"xyz >".</span><span class="sxs-lookup"><span data-stu-id="3f550-326">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="3f550-327">"XYZ", przypisuje podciąg między `Open` grupą i prawego nawiasu ostrego `Close` do grupy, a następnie usuwa bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-327">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="3f550-328">Wartość poprzedniego przechwytywania (lewy nawias kątowy w "\<MNO") jest bieżącą wartością `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-328">The value of the previous capture (the left angle bracket in "\<mno") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="3f550-329">Kolekcja grup zawiera teraz pojedyncze przechwycenia, lewy nawias ostry od "\<xyz >". `Open` <xref:System.Text.RegularExpressions.Group.Captures%2A></span><span class="sxs-lookup"><span data-stu-id="3f550-329">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="3f550-330">17</span><span class="sxs-lookup"><span data-stu-id="3f550-330">17</span></span>|`[^<>]*`|<span data-ttu-id="3f550-331">Wyszukuje znaki niebędące nawiasami ostrymi; nie znaleziono żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="3f550-331">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="3f550-332">18</span><span class="sxs-lookup"><span data-stu-id="3f550-332">18</span></span>|`)+`|<span data-ttu-id="3f550-333">Wartość trzeciej przechwyconej grupy to ">".</span><span class="sxs-lookup"><span data-stu-id="3f550-333">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="3f550-334">Następny znak w ciągu wejściowym jest prawym nawiasem kątowym, więc aparat wyrażeń regularnych jest odtwarzany z powrotem `((?'Close-Open'>)[^<>]*)` do wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-334">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-335">19</span><span class="sxs-lookup"><span data-stu-id="3f550-335">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="3f550-336">Dopasowuje prawy nawias ostry w "xyz >\<>", przypisuje do `Close` grupy "MNO xyz >" (podciąg `Open` między grupą i prawego nawiasu ostrego) i usuwa bieżącą wartość `Open` grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-336">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="3f550-337">`Open` Grupa jest teraz pusta.</span><span class="sxs-lookup"><span data-stu-id="3f550-337">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="3f550-338">20</span><span class="sxs-lookup"><span data-stu-id="3f550-338">20</span></span>|`[^<>]*`|<span data-ttu-id="3f550-339">Wyszukuje znaki niebędące nawiasami ostrymi; nie znaleziono żadnych dopasowań.</span><span class="sxs-lookup"><span data-stu-id="3f550-339">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="3f550-340">21</span><span class="sxs-lookup"><span data-stu-id="3f550-340">21</span></span>|`)+`|<span data-ttu-id="3f550-341">Wartość trzeciej przechwyconej grupy to ">".</span><span class="sxs-lookup"><span data-stu-id="3f550-341">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="3f550-342">Następny znak w ciągu wejściowym nie jest prawym nawiasem ostrym, więc aparat wyrażeń regularnych nie jest w pętli z powrotem do `((?'Close-Open'>)[^<>]*)` wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-342">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-343">22</span><span class="sxs-lookup"><span data-stu-id="3f550-343">22</span></span>|`)*`|<span data-ttu-id="3f550-344">Wartość pierwszej przechwyconej grupy to "< MNO\<xyz > >".</span><span class="sxs-lookup"><span data-stu-id="3f550-344">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="3f550-345">Następny znak w ciągu wejściowym nie jest nawiasem ostrym, dlatego aparat wyrażeń regularnych nie jest odtwarzany z powrotem do `(((?'Open'<)` wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-345">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="3f550-346">23</span><span class="sxs-lookup"><span data-stu-id="3f550-346">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="3f550-347">`Open` Grupa nie jest zdefiniowana, więc nie podjęto żadnego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-347">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="3f550-348">24</span><span class="sxs-lookup"><span data-stu-id="3f550-348">24</span></span>|`$`|<span data-ttu-id="3f550-349">Dopasowuje koniec ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="3f550-349">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="3f550-350">Grupy niezapamiętywane</span><span class="sxs-lookup"><span data-stu-id="3f550-350">Noncapturing Groups</span></span>  
 <span data-ttu-id="3f550-351">Następująca konstrukcja grupująca nie przechwytuje podciągu, który jest dopasowany przez Podwyrażenie:</span><span class="sxs-lookup"><span data-stu-id="3f550-351">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="3f550-352">gdzie *subexpression* jest dowolnym prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-352">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="3f550-353">Konstrukcja grupy nieprzechwyconej jest zwykle używana w przypadku zastosowania kwantyfikatora do grupy, ale podciągi przechwycone przez grupę nie są przedmiotem zainteresowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-353">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3f550-354">Jeśli wyrażenie regularne zawiera zagnieżdżone konstrukcje grupowania, zewnętrzna konstrukcja grupy nieprzechwytującej nie ma zastosowania do wewnętrznych zagnieżdżonych konstrukcji grupowych.</span><span class="sxs-lookup"><span data-stu-id="3f550-354">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="3f550-355">Poniższy przykład ilustruje wyrażenie regularne, które zawiera grupy nieprzechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-355">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="3f550-356">Należy zauważyć, że dane wyjściowe nie obejmują żadnych przechwyconych grup.</span><span class="sxs-lookup"><span data-stu-id="3f550-356">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="3f550-357">Wyrażenie `(?:\b(?:\w+)\W*)+\.` regularne dopasowuje zdanie, które zostało zakończone przez okres.</span><span class="sxs-lookup"><span data-stu-id="3f550-357">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="3f550-358">Ponieważ wyrażenie regularne koncentruje się na zdaniach, a nie na pojedynczych słowach, konstrukcje grupujące są używane wyłącznie jako Kwantyfikatory.</span><span class="sxs-lookup"><span data-stu-id="3f550-358">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="3f550-359">Wzorzec wyrażenia regularnego jest interpretowany jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-359">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-360">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-360">Pattern</span></span>|<span data-ttu-id="3f550-361">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-361">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="3f550-362">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-362">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="3f550-363">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-363">Match one or more word characters.</span></span> <span data-ttu-id="3f550-364">Nie przypisuj dopasowanego tekstu do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-364">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="3f550-365">Dopasowuje zero lub więcej znaków niebędących wyrazami.</span><span class="sxs-lookup"><span data-stu-id="3f550-365">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="3f550-366">Dopasowuje wzorzec jednego lub więcej znaków słowa, zaczynając od granicy słowa, po którym następuje zero lub więcej znaków niebędących wyrazami (jeden lub więcej razy).</span><span class="sxs-lookup"><span data-stu-id="3f550-366">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="3f550-367">Nie przypisuj dopasowanego tekstu do przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-367">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="3f550-368">Dopasowuje okres.</span><span class="sxs-lookup"><span data-stu-id="3f550-368">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="3f550-369">Opcje grupy</span><span class="sxs-lookup"><span data-stu-id="3f550-369">Group Options</span></span>  
 <span data-ttu-id="3f550-370">Następująca konstrukcja grupująca stosuje lub wyłącza określone opcje w ramach podwyrażenia:</span><span class="sxs-lookup"><span data-stu-id="3f550-370">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="3f550-371">`(?imnsx-imnsx:`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="3f550-371">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="3f550-372">gdzie *subexpression* jest dowolnym prawidłowym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-372">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="3f550-373">Na przykład włącza `(?i-s:)` opcję nierozróżniania wielkości liter i wyłącza tryb jednowierszowy.</span><span class="sxs-lookup"><span data-stu-id="3f550-373">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="3f550-374">Aby uzyskać więcej informacji na temat opcji wbudowanych, które można określić, zobacz [Opcje wyrażenia regularnego](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="3f550-374">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3f550-375">Można określić opcje, które mają zastosowanie do całego wyrażenia regularnego, a nie podwyrażenia przy użyciu <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> konstruktora klasy lub metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="3f550-375">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="3f550-376">Można również określić opcje wbudowane, które są stosowane po określonym punkcie w wyrażeniu regularnym, za `(?imnsx-imnsx)` pomocą konstrukcji języka.</span><span class="sxs-lookup"><span data-stu-id="3f550-376">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="3f550-377">Konstrukcja opcji grupy nie jest grupą przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-377">The group options construct is not a capturing group.</span></span> <span data-ttu-id="3f550-378">Oznacza to, że mimo że jakakolwiek część ciągu, który jest przechwytywany przez Podwyrażenie jest uwzględniona w dopasowaniu, nie jest uwzględniona w przechwyconej grupie ani <xref:System.Text.RegularExpressions.GroupCollection> użyta do wypełnienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="3f550-378">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="3f550-379">Na przykład w wyrażeniu `\b(?ix: d \w+)\s` regularnym w poniższym przykładzie są używane opcje wbudowane w konstrukcji grupującej, aby umożliwić dopasowanie bez uwzględniania wielkości liter i ignorowanie odstępu wzorca w przypadku identyfikowania wszystkich słów zaczynających się od litery "d".</span><span class="sxs-lookup"><span data-stu-id="3f550-379">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="3f550-380">Wyrażenie regularne jest zdefiniowane, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-380">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-381">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-381">Pattern</span></span>|<span data-ttu-id="3f550-382">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-382">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="3f550-383">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-383">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="3f550-384">Przy użyciu dopasowania bez uwzględniania wielkości liter i ignorowania białego znaku w tym wzorcu dopasowuje znak "d", po którym następuje jeden lub więcej znaków wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-384">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="3f550-385">Dopasowuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="3f550-385">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="3f550-386">Dodatnie asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-386">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="3f550-387">Następująca konstrukcja grupująca definiuje pozytywne potwierdzenie o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="3f550-387">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="3f550-388">`(?=`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="3f550-388">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="3f550-389">gdzie *subexpression* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-389">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="3f550-390">Aby dopasowanie zakończyło się pomyślnie, ciąg wejściowy musi być zgodny ze wzorcemwyrażenia regularnego w podrażeniu, chociaż dopasowany podciąg nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-390">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="3f550-391">Potwierdzenie o zerowej szerokości nie nawrotu.</span><span class="sxs-lookup"><span data-stu-id="3f550-391">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="3f550-392">Zazwyczaj na końcu wzorca wyrażenia regularnego zostanie znalezione pozytywne potwierdzenie o zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="3f550-392">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="3f550-393">Definiuje podciąg, który musi zostać znaleziony na końcu ciągu, aby nastąpiło dopasowanie, ale nie powinien być uwzględniony w dopasowaniu.</span><span class="sxs-lookup"><span data-stu-id="3f550-393">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="3f550-394">Jest on również przydatny do zapobiegania nadmiernemu wycofywaniu.</span><span class="sxs-lookup"><span data-stu-id="3f550-394">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="3f550-395">Możesz użyć pozytywnego potwierdzenia naprzódgo o zerowej szerokości, aby upewnić się, że określona przechwycona Grupa rozpoczyna się od tekstu, który jest zgodny z podzbiorem wzorca zdefiniowanego dla tej przechwyconej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-395">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="3f550-396">Na przykład, jeśli grupa przechwytywania dopasowuje kolejne znaki wyrazu, można użyć pozytywnej wartości zerowej z wyprzedzeniem, aby wymagać, aby pierwszy znak był wielką literą.</span><span class="sxs-lookup"><span data-stu-id="3f550-396">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="3f550-397">W poniższym przykładzie zastosowano dodatnie potwierdzenie o zerowej szerokości, aby dopasować wyraz poprzedzający zlecenie "is" w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="3f550-397">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="3f550-398">Wyrażenie `\b\w+(?=\sis\b)` regularne jest interpretowane jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-398">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-399">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-399">Pattern</span></span>|<span data-ttu-id="3f550-400">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-400">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="3f550-401">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-401">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="3f550-402">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-402">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="3f550-403">Ustal, czy znaki słowa są poprzedzone znakiem odstępu, a ciąg "is", który jest kończący się na granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-403">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="3f550-404">Jeśli tak, dopasowanie zostanie wykonane pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="3f550-404">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="3f550-405">Ujemne asercje z patrzeniem w przód o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-405">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="3f550-406">Następująca konstrukcja grupująca definiuje negatywną Poprzednia wartość zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="3f550-406">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="3f550-407">`(?!`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="3f550-407">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="3f550-408">gdzie *subexpression* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-408">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="3f550-409">Aby dopasowanie zakończyło się pomyślnie, ciąg wejściowy nie może być zgodny ze wzorcemwyrażenia regularnego w podrażeniu, chociaż dopasowany ciąg nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-409">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="3f550-410">Potwierdzenie negatywnej zerowej szerokości jest zwykle używane na początku lub na końcu wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-410">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="3f550-411">Na początku wyrażenia regularnego można zdefiniować konkretny wzorzec, który nie powinien być dopasowany, gdy początek wyrażenia regularnego definiuje podobny, ale bardziej ogólny wzorzec do dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-411">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="3f550-412">W takim przypadku jest często używany do ograniczania wycofywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-412">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="3f550-413">Na końcu wyrażenia regularnego można zdefiniować Podwyrażenie, które nie może wystąpić na końcu dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-413">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="3f550-414">W poniższym przykładzie zdefiniowano wyrażenie regularne, które używa potwierdzenia przeszukiwania zerowej szerokości na początku wyrażenia regularnego w celu dopasowania wyrazów, które nie zaczynają się od "un".</span><span class="sxs-lookup"><span data-stu-id="3f550-414">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="3f550-415">Wyrażenie `\b(?!un)\w+\b` regularne jest interpretowane jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-415">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-416">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-416">Pattern</span></span>|<span data-ttu-id="3f550-417">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-417">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="3f550-418">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-418">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="3f550-419">Ustal, czy dwa następne znaki są "un".</span><span class="sxs-lookup"><span data-stu-id="3f550-419">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="3f550-420">Jeśli tak nie jest, możliwe jest dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="3f550-420">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="3f550-421">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-421">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="3f550-422">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-422">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="3f550-423">W poniższym przykładzie zdefiniowano wyrażenie regularne, które używa potwierdzenia przeszukiwania zerowej szerokości na końcu wyrażenia regularnego, aby dopasować wyrazy, które nie kończą się znakiem interpunkcji.</span><span class="sxs-lookup"><span data-stu-id="3f550-423">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="3f550-424">Wyrażenie `\b\w+\b(?!\p{P})` regularne jest interpretowane jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-424">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-425">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-425">Pattern</span></span>|<span data-ttu-id="3f550-426">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-426">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="3f550-427">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-427">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="3f550-428">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-428">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="3f550-429">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-429">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="3f550-430">Jeśli następny znak nie jest symbolem interpunkcji (na przykład kropką lub przecinkiem), dopasowanie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="3f550-430">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="3f550-431">Dodatnie asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-431">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="3f550-432">Następująca konstrukcja grupująca definiuje asercja wsteczna pozytywnej o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="3f550-432">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="3f550-433">`(?<=`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="3f550-433">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="3f550-434">gdzie *subexpression* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-434">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="3f550-435">Aby dopasowanie powiodło się, Podwyrażenie musi wystąpić w ciągu wejściowym z lewej strony bieżącego położenia, chociaż `subexpression` nie jest uwzględnione w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-435">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="3f550-436">Pozytywna asercja wstecznaa o zerowej szerokości nie nawrotu.</span><span class="sxs-lookup"><span data-stu-id="3f550-436">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="3f550-437">Pozytywne potwierdzenia asercja wsteczna o zerowej szerokości są zwykle używane na początku wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="3f550-437">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="3f550-438">Wzorzec, który definiuje, jest warunkiem wstępnym dla dopasowania, chociaż nie jest częścią wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-438">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="3f550-439">Na przykład poniższy przykład dopasowuje ostatnie dwie cyfry roku dla dwudziestego pierwszego stulecia (czyli wymaga, aby cyfry "20" poprzedzać pasujący ciąg).</span><span class="sxs-lookup"><span data-stu-id="3f550-439">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="3f550-440">Wzorzec `(?<=\b20)\d{2}\b` wyrażenia regularnego jest interpretowany jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-440">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-441">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-441">Pattern</span></span>|<span data-ttu-id="3f550-442">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-442">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="3f550-443">Dopasowuje dwie cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="3f550-443">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="3f550-444">Kontynuuj dopasowanie, jeśli dwie cyfry dziesiętne poprzedzają cyfry dziesiętne "20" na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-444">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="3f550-445">Kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-445">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="3f550-446">Pozytywne potwierdzenia asercja wsteczna o zerowej szerokości są również używane do ograniczania wycofywania, gdy ostatni znak lub znaki w przechwyconej grupie muszą być podzbiorem znaków, które pasują do wzorca wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-446">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="3f550-447">Na przykład jeśli grupa przechwytuje wszystkie kolejne znaki wyrazu, można użyć pozytywnej asercja wsteczna o zerowej szerokości, aby wymagać, aby ostatni znak był alfabetyczny.</span><span class="sxs-lookup"><span data-stu-id="3f550-447">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="3f550-448">Ujemne asercje wsteczne o zerowej szerokości</span><span class="sxs-lookup"><span data-stu-id="3f550-448">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="3f550-449">Następująca konstrukcja grupująca definiuje negatywną asercja wstecznaą o zerowej szerokości:</span><span class="sxs-lookup"><span data-stu-id="3f550-449">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="3f550-450">`(?<!`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="3f550-450">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="3f550-451">gdzie *subexpression* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-451">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="3f550-452">Aby dopasowanie zakończyło się pomyślnie , Podwyrażenie nie może wystąpić w ciągu wejściowym z lewej strony bieżącego położenia.</span><span class="sxs-lookup"><span data-stu-id="3f550-452">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="3f550-453">Jednak dowolny podciąg, który nie jest zgodny `subexpression` , nie jest uwzględniony w wyniku dopasowania.</span><span class="sxs-lookup"><span data-stu-id="3f550-453">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="3f550-454">Ujemne asercja wstecznay o zerowej szerokości są zwykle używane na początku wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="3f550-454">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="3f550-455">Zdefiniowany przez siebie wzorzec wyklucza dopasowanie w ciągu poniżej.</span><span class="sxs-lookup"><span data-stu-id="3f550-455">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="3f550-456">Są one również używane do ograniczania wycofywania, gdy ostatni znak lub znaki w przechwyconej grupie nie mogą być jednym lub więcej znaków, które pasują do wzorca wyrażenia regularnego tej grupy.</span><span class="sxs-lookup"><span data-stu-id="3f550-456">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="3f550-457">Na przykład jeśli grupa przechwytuje wszystkie kolejne znaki wyrazu, można użyć pozytywnej asercja wsteczna o zerowej szerokości, aby wymagać, aby ostatni znak nie był podkreśleniem\_().</span><span class="sxs-lookup"><span data-stu-id="3f550-457">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (\_).</span></span>  
  
 <span data-ttu-id="3f550-458">Poniższy przykład dopasowuje datę dla każdego dnia tygodnia, który nie jest weekendem (czyli nie jest to sobota ani Niedziela).</span><span class="sxs-lookup"><span data-stu-id="3f550-458">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="3f550-459">Wzorzec `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` wyrażenia regularnego jest interpretowany jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-459">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-460">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-460">Pattern</span></span>|<span data-ttu-id="3f550-461">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-461">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="3f550-462">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-462">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="3f550-463">Dopasowuje jeden lub więcej znaków wyrazu, po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="3f550-463">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="3f550-464">Dopasowuje jedną lub dwie cyfry dziesiętne, po których następuje znak odstępu i przecinek.</span><span class="sxs-lookup"><span data-stu-id="3f550-464">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="3f550-465">Dopasowuje cztery cyfry dziesiętne i kończy dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-465">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="3f550-466">Jeśli dopasowanie jest poprzedzone znakiem innym niż ciągi "Sobota" lub "Niedziela", po którym następuje spacja, dopasowanie zostanie wykonane pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="3f550-466">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="3f550-467">Podwyrażenia bez nawrotów</span><span class="sxs-lookup"><span data-stu-id="3f550-467">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="3f550-468">Następująca konstrukcja grupująca reprezentuje Podwyrażenie Podwyrażenie (znane również jako Podwyrażenie "zachłanne"):</span><span class="sxs-lookup"><span data-stu-id="3f550-468">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="3f550-469">`(?>`*Podwyrażenie*`)`</span><span class="sxs-lookup"><span data-stu-id="3f550-469">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="3f550-470">gdzie *subexpression* jest dowolnym wzorcem wyrażenia regularnego.</span><span class="sxs-lookup"><span data-stu-id="3f550-470">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="3f550-471">Zwykle Jeśli wyrażenie regularne zawiera opcjonalny lub alternatywny wzorzec dopasowywania, a dopasowanie nie powiedzie się, aparat wyrażeń regularnych może rozgałęziać się w wielu kierunkach, aby dopasować ciąg wejściowy do wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-471">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="3f550-472">Jeśli dopasowanie nie zostanie znalezione podczas pierwszego rozgałęzienia, aparat wyrażeń regularnych może utworzyć kopię zapasową lub nawrotu do punktu, w którym zajęło pierwsze dopasowanie, i spróbować dopasować przy użyciu drugiego rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="3f550-472">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="3f550-473">Ten proces może być kontynuowany, dopóki nie zostaną wypróbowane wszystkie gałęzie.</span><span class="sxs-lookup"><span data-stu-id="3f550-473">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="3f550-474">Konstrukcja języka`)` subexpression powoduje wyłączenie wycofywania. `(?>`</span><span class="sxs-lookup"><span data-stu-id="3f550-474">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="3f550-475">Aparat wyrażeń regularnych będzie pasował do tylu znaków w ciągu wejściowym, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="3f550-475">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="3f550-476">Gdy nie jest możliwe dalsze dopasowanie, nie będzie nawrotu prób alternatywnej dopasowania wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-476">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="3f550-477">(Oznacza to, że Podwyrażenie dopasowuje tylko ciągi, które byłyby dopasowane tylko przez Podwyrażenie; nie próbuje dopasować ciągu w oparciu o Podwyrażenie i wszystkie Podwyrażenie, które je obserwują).</span><span class="sxs-lookup"><span data-stu-id="3f550-477">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="3f550-478">Ta opcja jest zalecana, Jeśli wiesz, że wycofywanie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="3f550-478">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="3f550-479">Uniemożliwianie aparatowi wyrażeń regularnych wykonywanie niepotrzebnych operacji wyszukiwania poprawia wydajność.</span><span class="sxs-lookup"><span data-stu-id="3f550-479">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="3f550-480">Poniższy przykład ilustruje, jak Podwyrażenie Podwyrażenie modyfikuje wyniki dopasowania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="3f550-480">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="3f550-481">Wyrażenie regularne śledzenia wstecznego pomyślnie dopasowuje serię powtarzających się znaków, a po nim wystąpienie tego samego znaku na granicy wyrazu, ale wyrażenie regularne Podwyrażenie nie.</span><span class="sxs-lookup"><span data-stu-id="3f550-481">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="3f550-482">Wyrażenie `(?>(\w)\1+).\b` regularne Podwyrażenie jest zdefiniowane, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-482">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-483">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-483">Pattern</span></span>|<span data-ttu-id="3f550-484">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-484">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="3f550-485">Dopasowuje pojedynczy znak słowa i przypisuje go do pierwszej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-485">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="3f550-486">Dopasowuje wartość pierwszego przechwyconego podciągu jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="3f550-486">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="3f550-487">Dopasowuje dowolny znak.</span><span class="sxs-lookup"><span data-stu-id="3f550-487">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="3f550-488">Zakończ dopasowanie na granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-488">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="3f550-489">Dopasowuje jedno lub więcej wystąpień zduplikowanego znaku słowa, ale nie nawrotu się w celu dopasowania do ostatniego znaku na granicy słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-489">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="3f550-490">Konstrukty grupujące i obiekty wyrażeń regularnych</span><span class="sxs-lookup"><span data-stu-id="3f550-490">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="3f550-491">Podciągi dopasowane przez grupę przechwyconą wyrażenia regularnego są reprezentowane przez <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> obiekty, które można pobrać <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> z obiektu, <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> który jest zwracany przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="3f550-491">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3f550-492"><xref:System.Text.RegularExpressions.GroupCollection> Obiekt jest wypełniany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="3f550-492">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="3f550-493">Pierwszy <xref:System.Text.RegularExpressions.Group> obiekt w kolekcji (obiekt pod indeksem zero) reprezentuje całe dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="3f550-493">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="3f550-494">Następny zestaw <xref:System.Text.RegularExpressions.Group> obiektów reprezentuje grupy przechwytywania bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="3f550-494">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="3f550-495">Są one wyświetlane w kolejności, w jakiej są zdefiniowane w wyrażeniu regularnym od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="3f550-495">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="3f550-496">Wartości indeksu tych grup należą do zakresu od 1 do liczby nienazwanych grup przechwytywania w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="3f550-496">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="3f550-497">(Indeks określonej grupy jest równoznaczny z numerowanym odwołaniem wstecznym.</span><span class="sxs-lookup"><span data-stu-id="3f550-497">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="3f550-498">Aby uzyskać więcej informacji na temat odwołań wstecznych, zobacz [konstrukcje odwołań wstecznych](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="3f550-498">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="3f550-499">Końcowy zestaw <xref:System.Text.RegularExpressions.Group> obiektów reprezentuje nazwane grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-499">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="3f550-500">Są one wyświetlane w kolejności, w jakiej są zdefiniowane w wyrażeniu regularnym od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="3f550-500">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="3f550-501">Wartość indeksu pierwszej nazwanej grupy przechwytywania jest większa niż indeks ostatniej nienazwanej grupy przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-501">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="3f550-502">Jeśli w wyrażeniu regularnym nie ma grup przechwytywania bez nazwy, wartość indeksu pierwszej nazwanej grupy przechwytywania to jeden.</span><span class="sxs-lookup"><span data-stu-id="3f550-502">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="3f550-503">W przypadku zastosowania kwantyfikatora do grupy przechwytywania odpowiednie <xref:System.Text.RegularExpressions.Group> <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>obiekty, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>i <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> właściwości odzwierciedlają ostatni podciąg, który jest przechwytywany przez grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-503">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="3f550-504">Można pobrać kompletny zestaw podciągów, które są przechwytywane przez grupy, które mają Kwantyfikatory z <xref:System.Text.RegularExpressions.CaptureCollection> obiektu, który jest zwracany <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="3f550-504">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="3f550-505">W poniższym przykładzie wyjaśniono relację między <xref:System.Text.RegularExpressions.Group> obiektami i. <xref:System.Text.RegularExpressions.Capture></span><span class="sxs-lookup"><span data-stu-id="3f550-505">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="3f550-506">Wzorzec `(\b(\w+)\W+)+` wyrażenia regularnego wyodrębnia poszczególne wyrazy z ciągu.</span><span class="sxs-lookup"><span data-stu-id="3f550-506">The regular expression pattern `(\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="3f550-507">Definicję tego wyrażenia pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3f550-507">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="3f550-508">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="3f550-508">Pattern</span></span>|<span data-ttu-id="3f550-509">Opis</span><span class="sxs-lookup"><span data-stu-id="3f550-509">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="3f550-510">Rozpoczyna dopasowanie na granicy wyrazu.</span><span class="sxs-lookup"><span data-stu-id="3f550-510">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="3f550-511">Dopasowuje co najmniej jeden znak słowa.</span><span class="sxs-lookup"><span data-stu-id="3f550-511">Match one or more word characters.</span></span> <span data-ttu-id="3f550-512">Razem te znaki tworzą słowo.</span><span class="sxs-lookup"><span data-stu-id="3f550-512">Together, these characters form a word.</span></span> <span data-ttu-id="3f550-513">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-513">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="3f550-514">Dopasowuje jeden lub więcej znaków niebędących wyrazami.</span><span class="sxs-lookup"><span data-stu-id="3f550-514">Match one or more non-word characters.</span></span>|  
|`(\b(\w+)\W+)`|<span data-ttu-id="3f550-515">Dopasowuje wzorzec jednego lub więcej znaków słowa, po których następuje jeden lub więcej znaków niebędących wyrazami.</span><span class="sxs-lookup"><span data-stu-id="3f550-515">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="3f550-516">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-516">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="3f550-517">Druga grupa przechwytywania dopasowuje każdy wyraz zdania.</span><span class="sxs-lookup"><span data-stu-id="3f550-517">The second capturing group matches each word of the sentence.</span></span> <span data-ttu-id="3f550-518">Pierwsza grupa przechwytywania dopasowuje każdy wyraz wraz z interpunkcją i białym znakiem, który obserwuje wyraz.</span><span class="sxs-lookup"><span data-stu-id="3f550-518">The first capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="3f550-519">Obiekt <xref:System.Text.RegularExpressions.Group> , którego indeks jest 2, zawiera informacje dotyczące tekstu dopasowanego przez drugą grupę przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="3f550-519">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="3f550-520">Pełny zestaw wyrazów przechwytywanych przez grupę przechwytywania jest dostępny z <xref:System.Text.RegularExpressions.CaptureCollection> obiektu zwróconego <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="3f550-520">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3f550-521">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="3f550-521">See also</span></span>

- [<span data-ttu-id="3f550-522">Język wyrażeń regularnych — podręczny wykaz</span><span class="sxs-lookup"><span data-stu-id="3f550-522">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="3f550-523">Śledzenie wsteczne</span><span class="sxs-lookup"><span data-stu-id="3f550-523">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
