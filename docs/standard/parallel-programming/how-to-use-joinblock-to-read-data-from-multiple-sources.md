---
title: "Porady: Korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library, joining blocks in
- dataflow blocks, joining in TPL
ms.assetid: e9c1ada4-ac57-4704-87cb-2f5117f8151d
caps.latest.revision: "7"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: fa5f531257c0593f615e4620b56b2ef581ac143c
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/23/2017
---
# <a name="how-to-use-joinblock-to-read-data-from-multiple-sources"></a><span data-ttu-id="24142-102">Porady: Korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł</span><span class="sxs-lookup"><span data-stu-id="24142-102">How to: Use JoinBlock to Read Data From Multiple Sources</span></span>
<span data-ttu-id="24142-103">W tym dokumencie opisano sposób użycia <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> klasę, aby wykonać operację, gdy dane są dostępne z wielu źródeł.</span><span class="sxs-lookup"><span data-stu-id="24142-103">This document explains how to use the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class to perform an operation when data is available from multiple sources.</span></span> <span data-ttu-id="24142-104">On również pokazano, jak w trybie niezachłanne włączyć wiele bloków sprzężenia wydajniej udostępnianie źródła danych.</span><span class="sxs-lookup"><span data-stu-id="24142-104">It also demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="24142-105">Biblioteka przepływu danych tpl (<xref:System.Threading.Tasks.Dataflow?displayProperty=nameWithType> przestrzeni nazw) nie jest rozpowszechniana z [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].</span><span class="sxs-lookup"><span data-stu-id="24142-105">The TPL Dataflow Library (<xref:System.Threading.Tasks.Dataflow?displayProperty=nameWithType> namespace) is not distributed with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].</span></span> <span data-ttu-id="24142-106">Aby zainstalować <xref:System.Threading.Tasks.Dataflow> przestrzeni nazw, otwórz projekt w [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], wybierz **Zarządzaj pakietami NuGet** z menu projektu i wyszukaj w trybie online `Microsoft.Tpl.Dataflow` pakietu.</span><span class="sxs-lookup"><span data-stu-id="24142-106">To install the <xref:System.Threading.Tasks.Dataflow> namespace, open your project in [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], choose **Manage NuGet Packages** from the Project menu, and search online for the `Microsoft.Tpl.Dataflow` package.</span></span>  
  
## <a name="example"></a><span data-ttu-id="24142-107">Przykład</span><span class="sxs-lookup"><span data-stu-id="24142-107">Example</span></span>  
 <span data-ttu-id="24142-108">W poniższym przykładzie zdefiniowano trzy typy zasobów, `NetworkResource`, `FileResource`, i `MemoryResource`i wykonuje operacje, gdy zasoby będą dostępne.</span><span class="sxs-lookup"><span data-stu-id="24142-108">The following example defines three resource types, `NetworkResource`, `FileResource`, and `MemoryResource`, and performs operations when resources become available.</span></span> <span data-ttu-id="24142-109">W tym przykładzie wymaga `NetworkResource` i `MemoryResource` pary w celu przeprowadzenia pierwszej operacji i `FileResource` i `MemoryResource` pary w celu wykonania drugiej operacji.</span><span class="sxs-lookup"><span data-stu-id="24142-109">This example requires a `NetworkResource` and `MemoryResource` pair in order to perform the first operation and a `FileResource` and `MemoryResource` pair in order to perform the second operation.</span></span> <span data-ttu-id="24142-110">Aby włączyć te operacje nastąpić, gdy wszystkie wymagane zasoby są dostępne, w tym przykładzie użyto <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> klasy.</span><span class="sxs-lookup"><span data-stu-id="24142-110">To enable these operations to occur when all required resources are available, this example uses the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class.</span></span> <span data-ttu-id="24142-111">Gdy <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiektu odbiera dane ze wszystkich źródeł, propaguje on danych do jej obiekt docelowy, który w tym przykładzie jest <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="24142-111">When a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> object receives data from all sources, it propagates that data to its target, which in this example is an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object.</span></span> <span data-ttu-id="24142-112">Zarówno <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> odczytywać obiekty z udostępnionej puli `MemoryResource` obiektów.</span><span class="sxs-lookup"><span data-stu-id="24142-112">Both <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects read from a shared pool of `MemoryResource` objects.</span></span>  
  
 [!code-csharp[TPLDataflow_NonGreedyJoin#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_nongreedyjoin/cs/nongreedyjoin.cs#1)]
 [!code-vb[TPLDataflow_NonGreedyJoin#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_nongreedyjoin/vb/nongreedyjoin.vb#1)]  
  
 <span data-ttu-id="24142-113">Umożliwia efektywne korzystanie z obszaru udostępnionej puli `MemoryResource` obiekty, w tym przykładzie określa <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions> obiektu, który ma <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> ustawioną właściwość `False` utworzyć <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiektów, które działają w trybie niezachłanne.</span><span class="sxs-lookup"><span data-stu-id="24142-113">To enable efficient use of the shared pool of `MemoryResource` objects, this example specifies a <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions> object that has the <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> property set to `False` to create <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects that act in non-greedy mode.</span></span> <span data-ttu-id="24142-114">Blok niezachłanne złączenia odłoży wszystkie wiadomości przychodzących, dopóki nie jest dostępny z każdego źródła.</span><span class="sxs-lookup"><span data-stu-id="24142-114">A non-greedy join block postpones all incoming messages until one is available from each source.</span></span> <span data-ttu-id="24142-115">Jeśli dowolny z komunikatów przełożonych zostały zaakceptowane przez innego bloku, blok sprzężenia powoduje ponowne uruchomienie procesu.</span><span class="sxs-lookup"><span data-stu-id="24142-115">If any of the postponed messages were accepted by another block, the join block restarts the process.</span></span> <span data-ttu-id="24142-116">Zachłanne innym niż tryb umożliwia bloki sprzężenia, które mają co najmniej jeden bloki źródła aby postęp czekać innych bloków danych.</span><span class="sxs-lookup"><span data-stu-id="24142-116">Non-greedy mode enables join blocks that share one or more source blocks to make forward progress as the other blocks wait for data.</span></span> <span data-ttu-id="24142-117">W tym przykładzie Jeśli `MemoryResource` obiekt jest dodawany do `memoryResources` puli sprzężenia pierwszy blok do odbierania drugiego źródła danych można wprowadzić postęp.</span><span class="sxs-lookup"><span data-stu-id="24142-117">In this example, if a `MemoryResource` object is added to the `memoryResources` pool, the first join block to receive its second data source can make forward progress.</span></span> <span data-ttu-id="24142-118">Gdyby w tym przykładzie do używania trybu intensywnie, co jest ustawieniem domyślnym jeden blok sprzężenia może potrwać `MemoryResource` obiektów i poczekaj, aż drugi zasób stanie się dostępne.</span><span class="sxs-lookup"><span data-stu-id="24142-118">If this example were to use greedy mode, which is the default, one join block might take the `MemoryResource` object and wait for the second resource to become available.</span></span> <span data-ttu-id="24142-119">Jednak jeśli bloku sprzężenia drugiego źródła danych dostępne, nie powiedzie się postęp ponieważ `MemoryResource` obiektu jest zajęta przez bloku sprzężenia.</span><span class="sxs-lookup"><span data-stu-id="24142-119">However, if the other join block has its second data source available, it cannot make forward progress because the `MemoryResource` object has been taken by the other join block.</span></span>  
  
## <a name="compiling-the-code"></a><span data-ttu-id="24142-120">Kompilowanie kodu</span><span class="sxs-lookup"><span data-stu-id="24142-120">Compiling the Code</span></span>  
 <span data-ttu-id="24142-121">Skopiuj przykładowy kod i wklej go w projekcie programu Visual Studio lub wklej go w pliku o nazwie `DataflowNonGreedyJoin.cs` (`DataflowNonGreedyJoin.vb` dla [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]), a następnie uruchom następujące polecenie w oknie Wiersz polecenia programu Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="24142-121">Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `DataflowNonGreedyJoin.cs` (`DataflowNonGreedyJoin.vb` for [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]), and then run the following command in a Visual Studio Command Prompt window.</span></span>  
  
 [!INCLUDE[csprcs](../../../includes/csprcs-md.md)]  
  
 <span data-ttu-id="24142-122">**CSC.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.cs**</span><span class="sxs-lookup"><span data-stu-id="24142-122">**csc.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.cs**</span></span>  
  
 [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]  
  
 <span data-ttu-id="24142-123">**vbc.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.vb**</span><span class="sxs-lookup"><span data-stu-id="24142-123">**vbc.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.vb**</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="24142-124">Niezawodne programowanie</span><span class="sxs-lookup"><span data-stu-id="24142-124">Robust Programming</span></span>  
 <span data-ttu-id="24142-125">Użycie złączenia niezachłanne może również pomóc zapobiegać zakleszczenie w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="24142-125">The use of non-greedy joins can also help you prevent deadlock in your application.</span></span> <span data-ttu-id="24142-126">W aplikacji *zakleszczenie* występuje, gdy dwie lub więcej procesów każdego przechowywania zasobu i wzajemnie poczekaj, aż inny proces zwolnić innego zasobu.</span><span class="sxs-lookup"><span data-stu-id="24142-126">In a software application, *deadlock* occurs when two or more processes each hold a resource and mutually wait for another process to release some other resource.</span></span> <span data-ttu-id="24142-127">Należy wziąć pod uwagę aplikacji, który definiuje dwa <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiektów.</span><span class="sxs-lookup"><span data-stu-id="24142-127">Consider an application that defines two <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects.</span></span> <span data-ttu-id="24142-128">Oba obiekty każdego odczytywać dane z dwóch bloków udostępnionego źródła.</span><span class="sxs-lookup"><span data-stu-id="24142-128">Both objects each read data from two shared source blocks.</span></span> <span data-ttu-id="24142-129">W trybie intensywnie Jeśli jeden blok sprzężenia odczytuje z pierwszego źródła, a w drugim bloku sprzężenia odczytuje z drugie źródło aplikacji może do zakleszczenia, ponieważ zarówno bloki sprzężenia wzajemnie oczekiwania dla pozostałych zwolnić jego zasobów.</span><span class="sxs-lookup"><span data-stu-id="24142-129">In greedy mode, if one join block reads from the first source and the second join block reads from the second source, the application might deadlock because both join blocks mutually wait for the other to release its resource.</span></span> <span data-ttu-id="24142-130">W trybie niezachłanne każdy blok sprzężenia odczyty źródła tylko wtedy, gdy wszystkie dane są dostępne i w związku z tym ryzyko zakleszczenia wyeliminowania.</span><span class="sxs-lookup"><span data-stu-id="24142-130">In non-greedy mode, each join block reads from its sources only when all data is available, and therefore, the risk of deadlock is eliminated.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="24142-131">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="24142-131">See Also</span></span>  
 [<span data-ttu-id="24142-132">Przepływ danych</span><span class="sxs-lookup"><span data-stu-id="24142-132">Dataflow</span></span>](../../../docs/standard/parallel-programming/dataflow-task-parallel-library.md)
