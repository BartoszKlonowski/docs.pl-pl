---
title: Programowanie asynchroniczne oparte na zadanie
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 63e1c55aa3aad1923ac34070784e8b4de7251a7c
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/23/2019
ms.locfileid: "54592760"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="81c55-102">Programowanie asynchroniczne oparte na zadanie</span><span class="sxs-lookup"><span data-stu-id="81c55-102">Task-based Asynchronous Programming</span></span>
<span data-ttu-id="81c55-103">Biblioteka zadań równoległych (TPL) opiera się na koncepcji *zadań*, które reprezentuje operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="81c55-103">The Task Parallel Library (TPL) is based on the concept of a *task*, which represents an asynchronous operation.</span></span> <span data-ttu-id="81c55-104">Pod pewnymi względami zadanie jest podobne do wątku lub <xref:System.Threading.ThreadPool> pracy elementu, ale na wyższym poziomie abstrakcji.</span><span class="sxs-lookup"><span data-stu-id="81c55-104">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="81c55-105">Termin *równoległość zadań* odwołuje się do co najmniej jeden niezależnych zadań działających równocześnie.</span><span class="sxs-lookup"><span data-stu-id="81c55-105">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="81c55-106">Zadania zapewniają dwie podstawowe korzyści:</span><span class="sxs-lookup"><span data-stu-id="81c55-106">Tasks provide two primary benefits:</span></span>  
  
-   <span data-ttu-id="81c55-107">Efektywniejsze i bardziej skalowalne wykorzystanie zasobów systemowych.</span><span class="sxs-lookup"><span data-stu-id="81c55-107">More efficient and more scalable use of system resources.</span></span>  
  
     <span data-ttu-id="81c55-108">W tle zadania są umieszczane w kolejce do <xref:System.Threading.ThreadPool>, który został rozszerzony o algorytmy, które określają i dostosowują się do liczby wątków i umożliwiają równoważenie obciążenia w celu zmaksymalizowania wydajności.</span><span class="sxs-lookup"><span data-stu-id="81c55-108">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="81c55-109">Dzięki temu zadania są stosunkowo lekkie i można tworzyć wiele takich zadań, aby włączyć równoległość drobnoziarnistą.</span><span class="sxs-lookup"><span data-stu-id="81c55-109">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>  
  
-   <span data-ttu-id="81c55-110">Większa kontrola programistyczna niż jest to możliwe za pomocą wątku lub elementu roboczego.</span><span class="sxs-lookup"><span data-stu-id="81c55-110">More programmatic control than is possible with a thread or work item.</span></span>  
  
     <span data-ttu-id="81c55-111">Zadania i środowisko zbudowane wokół nich zawierają bogaty zestaw interfejsów API, które obsługują oczekiwanie, anulowanie, kontynuację, niezawodną obsługę wyjątków, szczegółowe informacje o stanie, planowanie niestandardowe i nie tylko.</span><span class="sxs-lookup"><span data-stu-id="81c55-111">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>  
  
 <span data-ttu-id="81c55-112">Dla obu tych powodów w .NET Framework TPL jest preferowanym interfejsem API do pisania kodu wielowątkowego, asynchronicznego i równoległego.</span><span class="sxs-lookup"><span data-stu-id="81c55-112">For both of these reasons, in the .NET Framework, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code.</span></span>  
  
## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="81c55-113">Tworzenie i uruchamianie zadań w sposób niejawny</span><span class="sxs-lookup"><span data-stu-id="81c55-113">Creating and running tasks implicitly</span></span>  
 <span data-ttu-id="81c55-114"><xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> Metoda zapewnia wygodny sposób uruchamiania dowolnej ilości instrukcji umownych jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="81c55-114">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="81c55-115">Po prostu Przekaż <xref:System.Action> delegata dla każdego elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="81c55-115">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="81c55-116">Wyrażenia lambda są najwygodniejszym sposobem na tworzenie tych delegatów.</span><span class="sxs-lookup"><span data-stu-id="81c55-116">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="81c55-117">Wyrażenie lambda może wywołać metodę nazwaną lub zapewnić kod inline.</span><span class="sxs-lookup"><span data-stu-id="81c55-117">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="81c55-118">Poniższy przykład przedstawia podstawowe <xref:System.Threading.Tasks.Parallel.Invoke%2A> wywołania, które tworzy i rozpoczyna dwa zadania, działające równocześnie.</span><span class="sxs-lookup"><span data-stu-id="81c55-118">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="81c55-119">Pierwsze zadanie jest reprezentowane przez wyrażenie lambda, które wywołuje metodę o nazwie `DoSomeWork`, a drugie zadanie jest reprezentowane przez wyrażenie lambda, która wywołuje metodę o nazwie `DoSomeOtherWork`.</span><span class="sxs-lookup"><span data-stu-id="81c55-119">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="81c55-120">Ta dokumentacja używa wyrażeń lambda do definiowania delegatów w TPL.</span><span class="sxs-lookup"><span data-stu-id="81c55-120">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="81c55-121">Jeśli nie znasz wyrażeń lambda w języku C# lub Visual Basic, zobacz [wyrażeń Lambda w PLINQ i TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-121">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span></span>  
  
 [!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
 [!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]  
  
> [!NOTE]
>  <span data-ttu-id="81c55-122">Liczba <xref:System.Threading.Tasks.Task> wystąpień, które są tworzone w tle przez <xref:System.Threading.Tasks.Parallel.Invoke%2A> nie jest zawsze równa liczbie dostarczanych delegatów.</span><span class="sxs-lookup"><span data-stu-id="81c55-122">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="81c55-123">TPL może wykorzystywać różne optymalizacje, zwłaszcza z dużą liczbą obiektów delegowanych.</span><span class="sxs-lookup"><span data-stu-id="81c55-123">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>  
  
 <span data-ttu-id="81c55-124">Aby uzyskać więcej informacji, zobacz [jak: Wykonywanie operacji równoległych za pomocą elementu Parallel.Invoke](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-124">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 <span data-ttu-id="81c55-125">Aby uzyskać większą kontrolę nad wykonywaniem zadań lub w celu zwrócenia wartości z zadania trzeba pracować z <xref:System.Threading.Tasks.Task> obiekty w bardziej jawny sposób.</span><span class="sxs-lookup"><span data-stu-id="81c55-125">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>  
  
## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="81c55-126">Tworzenie i uruchamianie zadań w sposób jawny</span><span class="sxs-lookup"><span data-stu-id="81c55-126">Creating and running tasks explicitly</span></span>  
 <span data-ttu-id="81c55-127">Zadanie, która nie zwraca wartości jest reprezentowane przez <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="81c55-127">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="81c55-128">Zadanie zwracające wartość jest reprezentowany przez <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> klasy, która dziedziczy po elemencie <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="81c55-128">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="81c55-129">Obiekt zadania obsługuje szczegóły infrastruktury i zapewnia metody i właściwości, które są dostępne z wątku wywoływania przez cały okres istnienia zadania.</span><span class="sxs-lookup"><span data-stu-id="81c55-129">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="81c55-130">Na przykład, możesz uzyskać dostęp <xref:System.Threading.Tasks.Task.Status%2A> właściwości zadania w dowolnym momencie, aby ustalić, czy rozpoczęło działanie, zakończyło się, zostało anulowane lub został zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="81c55-130">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="81c55-131">Stan jest reprezentowany przez <xref:System.Threading.Tasks.TaskStatus> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="81c55-131">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>  
  
 <span data-ttu-id="81c55-132">Tworząc zadanie, nadajesz mu delegata użytkownika hermetyzującego kod, który zadanie będzie wykonywało.</span><span class="sxs-lookup"><span data-stu-id="81c55-132">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="81c55-133">Delegat może być wyrażony jako delegat nazwany, metoda anonimowa lub wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="81c55-133">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="81c55-134">Wyrażenia lambda mogą zawierać wywołanie metody nazwanej, jak pokazano w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="81c55-134">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="81c55-135">Należy zauważyć, że przykład zawiera wywołanie <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodę, aby upewnić się, że zadanie kończy wykonywanie przed zakończeniem aplikacji trybu konsoli.</span><span class="sxs-lookup"><span data-stu-id="81c55-135">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
 [!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]  
  
 <span data-ttu-id="81c55-136">Można również użyć <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metody, aby utworzyć i uruchomić zadanie w ramach jednej operacji.</span><span class="sxs-lookup"><span data-stu-id="81c55-136">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="81c55-137">Aby zarządzać zadaniem, <xref:System.Threading.Tasks.Task.Run%2A> metody używają domyślnego harmonogramu zadań, niezależnie od tego, które zadanie harmonogram jest skojarzony z bieżącym wątkiem.</span><span class="sxs-lookup"><span data-stu-id="81c55-137">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="81c55-138"><xref:System.Threading.Tasks.Task.Run%2A> Metody są preferowanym sposobem tworzenia i uruchamiania zadań, gdy nie jest potrzebna większa kontrola nad tworzeniem i planowaniem zadania.</span><span class="sxs-lookup"><span data-stu-id="81c55-138">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
 [!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]  
  
 <span data-ttu-id="81c55-139">Można również użyć <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodę, aby utworzyć i uruchomić zadanie w ramach jednej operacji.</span><span class="sxs-lookup"><span data-stu-id="81c55-139">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="81c55-140">Użyj tej metody, gdy tworzenie i planowanie nie muszą być rozdzielone i wymagasz dodatkowych opcje tworzenia zadań lub użycia określonego harmonogramu, lub gdy potrzebujesz przekazać dodatkowy stan do zadania, które można pobrać przy użyciu jego <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> Właściwość, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="81c55-140">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task that you can retrieve through its <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
 [!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]  
  
 <span data-ttu-id="81c55-141"><xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> ujawniają statyczną <xref:System.Threading.Tasks.Task.Factory%2A> właściwość, która zwraca wystąpienie domyślne <xref:System.Threading.Tasks.TaskFactory>, dzięki czemu można wywołać metodę jako `Task.Factory.StartNew()`.</span><span class="sxs-lookup"><span data-stu-id="81c55-141"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="81c55-142">Ponadto w poniższym przykładzie ponieważ zadania są typu <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, każdy z nich ma publiczną <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> właściwość, która zawiera wynik obliczenia.</span><span class="sxs-lookup"><span data-stu-id="81c55-142">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="81c55-143">Zadania są wykonywane asynchroniczne i mogą być kończone w dowolnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="81c55-143">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="81c55-144">Jeśli <xref:System.Threading.Tasks.Task%601.Result%2A> właściwość odbywa się przed zakończeniem obliczania, właściwość blokuje wątek wywołujący, aż wartość jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="81c55-144">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
 [!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]  
  
 <span data-ttu-id="81c55-145">Aby uzyskać więcej informacji, zobacz [jak: Zwracanie wartości z zadania](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-145">For more information, see [How to: Return a Value from a Task](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md).</span></span>  
  
 <span data-ttu-id="81c55-146">Używając wyrażenia lambda do utworzenia delegata, masz dostęp do wszystkich zmiennych, które są widoczne w tym momencie w kodzie źródłowym.</span><span class="sxs-lookup"><span data-stu-id="81c55-146">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="81c55-147">Jednak w niektórych przypadkach, zwłaszcza w pętlach, lambda nie przechwytuje zmiennej zgodnie z oczekiwaniami.</span><span class="sxs-lookup"><span data-stu-id="81c55-147">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="81c55-148">Przechwytuje tylko wartość końcową, a nie wartość, która mutuje po każdej iteracji.</span><span class="sxs-lookup"><span data-stu-id="81c55-148">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="81c55-149">Poniższy przykład ilustruje ten problem.</span><span class="sxs-lookup"><span data-stu-id="81c55-149">The following example illustrates the problem.</span></span> <span data-ttu-id="81c55-150">Pętla przekazuje licznik do wyrażenia lambda, która tworzy wystąpienie `CustomData` obiektu i używa licznika pętli jako identyfikatora obiektu.</span><span class="sxs-lookup"><span data-stu-id="81c55-150">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="81c55-151">Jak wynika z przykładu pokazują, każdy `CustomData` obiekt ma identyczny identyfikator.</span><span class="sxs-lookup"><span data-stu-id="81c55-151">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
 [!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]  
  
 <span data-ttu-id="81c55-152">Możesz uzyskać dostęp do wartości w każdej iteracji poprzez zapewnienie obiektu stanu do zadania za pośrednictwem jej konstruktora.</span><span class="sxs-lookup"><span data-stu-id="81c55-152">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="81c55-153">Poniższy przykład modyfikuje poprzedni przykład za pomocą licznika pętli przy tworzeniu `CustomData` obiektu, który z kolei jest przekazywany do wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="81c55-153">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="81c55-154">Jak wynika z przykładu pokazują, każdy `CustomData` obiekt ma teraz unikatowy identyfikator na podstawie wartości licznika pętli w momencie wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="81c55-154">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
 [!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]  
  
 <span data-ttu-id="81c55-155">Ten stan jest przekazywany jako argument do delegata zadania, i jest dostępny z obiektu zadania przy użyciu <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="81c55-155">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="81c55-156">Poniższy przykład jest modyfikacją poprzedniego.</span><span class="sxs-lookup"><span data-stu-id="81c55-156">The following example is a variation on the previous example.</span></span> <span data-ttu-id="81c55-157">Używa ona <xref:System.Threading.Tasks.Task.AsyncState%2A> właściwości, aby wyświetlić informacje o `CustomData` przekazywanym do wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="81c55-157">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
 [!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]  
  
## <a name="task-id"></a><span data-ttu-id="81c55-158">Identyfikator zadania</span><span class="sxs-lookup"><span data-stu-id="81c55-158">Task ID</span></span>  
 <span data-ttu-id="81c55-159">Każde zadanie otrzymuje identyfikator całkowitoliczbowy, który unikatowo identyfikuje je w domenie aplikacji i jest możliwy za pomocą <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="81c55-159">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="81c55-160">Identyfikator jest przydatny do wyświetlania informacji o zadaniu w debugerze programu Visual Studio **stosów równoległych** i **zadania** systemu windows.</span><span class="sxs-lookup"><span data-stu-id="81c55-160">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="81c55-161">Identyfikator jest tworzony z opóźnieniem, co oznacza, że nie jest on tworzony do momentu pojawienia się stosownego żądania. Dlatego zadanie może mieć inny identyfikator za każdym razem, gdy program jest uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="81c55-161">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="81c55-162">Aby uzyskać więcej informacji na temat sposobu wyświetlania identyfikatorów zadań w debugerze, zobacz [korzystanie z okna zadań](/visualstudio/debugger/using-the-tasks-window) i [przy użyciu Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span><span class="sxs-lookup"><span data-stu-id="81c55-162">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>  
  
## <a name="task-creation-options"></a><span data-ttu-id="81c55-163">Opcje tworzenia zadań</span><span class="sxs-lookup"><span data-stu-id="81c55-163">Task Creation Options</span></span>  
 <span data-ttu-id="81c55-164">Większość interfejsów API, które tworzą zadania, zapewnienia przeciążenia, które akceptują <xref:System.Threading.Tasks.TaskCreationOptions> parametru.</span><span class="sxs-lookup"><span data-stu-id="81c55-164">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="81c55-165">Określając jedną z poniższych opcji, możesz wskazać harmonogramowi zadań, jak zaplanować zadanie w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="81c55-165">By specifying one of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="81c55-166">Poniższa tabela zawiera różne opcje tworzenia zadania.</span><span class="sxs-lookup"><span data-stu-id="81c55-166">The following table lists the various task creation options.</span></span>  
  
|<span data-ttu-id="81c55-167"><xref:System.Threading.Tasks.TaskCreationOptions> Wartość parametru</span><span class="sxs-lookup"><span data-stu-id="81c55-167"><xref:System.Threading.Tasks.TaskCreationOptions> parameter value</span></span>|<span data-ttu-id="81c55-168">Opis</span><span class="sxs-lookup"><span data-stu-id="81c55-168">Description</span></span>|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|  
|<xref:System.Threading.Tasks.TaskCreationOptions.None>|<span data-ttu-id="81c55-169">Domyślna, gdy nie określono żadnej opcji.</span><span class="sxs-lookup"><span data-stu-id="81c55-169">The default when no option is specified.</span></span> <span data-ttu-id="81c55-170">Harmonogram używa domyślnej heurystyki do zaplanowania zadania.</span><span class="sxs-lookup"><span data-stu-id="81c55-170">The scheduler uses its default heuristics to schedule the task.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>|<span data-ttu-id="81c55-171">Określa, że zadanie powinno zostać zaplanowane tak, aby zadania utworzone wcześniej były wykonywane wcześniej, a zadania utworzone później były wykonywane później.</span><span class="sxs-lookup"><span data-stu-id="81c55-171">Specifies that the task should be scheduled so that tasks created sooner will be more likely to be executed sooner, and tasks created later will be more likely to execute later.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.LongRunning>|<span data-ttu-id="81c55-172">Określa, że zadanie reprezentuje operację długotrwałą.</span><span class="sxs-lookup"><span data-stu-id="81c55-172">Specifies that the task represents a long-running operation.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>|<span data-ttu-id="81c55-173">Określa, że zadanie powinno zostać utworzone jako dołączone zadanie podrzędne do bieżącego zadania, jeśli takie istnieje.</span><span class="sxs-lookup"><span data-stu-id="81c55-173">Specifies that a task should be created as an attached child of the current task, if one exists.</span></span> <span data-ttu-id="81c55-174">Aby uzyskać więcej informacji, zobacz [dołączone i odłączone zadania podrzędne](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-174">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach>|<span data-ttu-id="81c55-175">Określa, że jeśli wewnętrzne zadanie Określa `AttachedToParent` opcji, zadanie to nie stanie się dołączonym zadaniem podrzędnym.</span><span class="sxs-lookup"><span data-stu-id="81c55-175">Specifies that if an inner task specifies the `AttachedToParent` option, that task will not become an attached child task.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.HideScheduler>|<span data-ttu-id="81c55-176">Określa, że harmonogram zadań dla zadań utworzonych przez wywoływanie metod, takich jak <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> z poziomu danego zadania jest harmonogramem domyślnym zamiast harmonogramu, na którym działa zadanie.</span><span class="sxs-lookup"><span data-stu-id="81c55-176">Specifies that the task scheduler for tasks created by calling methods like <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> from within a particular task is the default scheduler instead of the scheduler on which this task is running.</span></span>|  
  
 <span data-ttu-id="81c55-177">Opcje mogą być połączone za pomocą bitowej **lub** operacji.</span><span class="sxs-lookup"><span data-stu-id="81c55-177">The options may be combined by using a bitwise **OR** operation.</span></span> <span data-ttu-id="81c55-178">Poniższy przykład przedstawia zadanie, które ma <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> i <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> opcji.</span><span class="sxs-lookup"><span data-stu-id="81c55-178">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> option.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
 [!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]  
  
## <a name="tasks-threads-and-culture"></a><span data-ttu-id="81c55-179">Zadania, wątki i kultury</span><span class="sxs-lookup"><span data-stu-id="81c55-179">Tasks, threads, and culture</span></span>  
 <span data-ttu-id="81c55-180">Każdy wątek ma skojarzone kultury i kultury UI, która jest zdefiniowana przez <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> i <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> właściwości, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="81c55-180">Each thread has an associated culture and UI culture, which is defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="81c55-181">Kultury wątku jest używana w operacjach, takich jak formatowanie, analizowanie, sortowania i porównywania ciągów.</span><span class="sxs-lookup"><span data-stu-id="81c55-181">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="81c55-182">Kultura interfejsu użytkownika dla wątku jest używany podczas wyszukiwania zasobów.</span><span class="sxs-lookup"><span data-stu-id="81c55-182">A thread's UI culture is used in resource lookup.</span></span> <span data-ttu-id="81c55-183">Zazwyczaj chyba że określisz domyślną kulturę używaną do wszystkich wątków w domenie aplikacji przy użyciu <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> i <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> właściwości domyślnej kultury i kultury wątku interfejsu użytkownika jest definiowany przez kultury systemu.</span><span class="sxs-lookup"><span data-stu-id="81c55-183">Ordinarily, unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="81c55-184">Jeśli jawnie ustawić kultury wątku i uruchomić nowy wątek, nowy wątek nie dziedziczy kultury wątku wywołującego; Zamiast tego jego kultury jest domyślną kulturą systemu.</span><span class="sxs-lookup"><span data-stu-id="81c55-184">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="81c55-185">Modelu programowania opartego na zadaniach dla aplikacji przeznaczonych dla wersji programu .NET Framework w wersjach wcześniejszych niż [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] stosować się do tej praktyką.</span><span class="sxs-lookup"><span data-stu-id="81c55-185">The task-based programming model for apps that target versions of the .NET Framework prior to [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] adhere to this practice.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="81c55-186">Należy zauważyć, że kultury wątku wywołującego jako część kontekstu zadania mają zastosowanie do aplikacji, *docelowej* [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], nie aplikacje, *uruchamiana* [!INCLUDE[net_v46](../../../includes/net-v46-md.md)].</span><span class="sxs-lookup"><span data-stu-id="81c55-186">Note that the calling thread's culture as part of a task's context applies to apps that *target* the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], not apps that *run under* the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)].</span></span> <span data-ttu-id="81c55-187">Możliwe jest określanie konkretnej wersji programu .NET Framework podczas tworzenia projektu w programie Visual Studio, wybierając tę wersję z listy rozwijanej w górnej części **nowy projekt** okno dialogowe lub poza programem Visual Studio, można użyć <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="81c55-187">You can target a particular version of the .NET Framework when you create your project in Visual Studio by selecting that version from the dropdown list at the top of the **New Project** dialog box, or outside of Visual Studio you can use the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute.</span></span> <span data-ttu-id="81c55-188">W przypadku aplikacji przeznaczonych dla wersji programu .NET Framework w wersjach wcześniejszych niż [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], lub nie przeznaczone na platformę określonej wersji programu .NET Framework, kultury podzadania w dalszym ciągu można określić przez kulturę wątku, na którym jest uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="81c55-188">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], or that do not target a specific version of the .NET Framework, a task's culture continues to be determined by the culture of the thread on which it runs.</span></span>  
  
 <span data-ttu-id="81c55-189">Począwszy od aplikacji, których platformą docelową [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], kultury wątku wywołującego jest dziedziczona przez każde zadanie podrzędne, nawet wtedy, gdy zadanie jest uruchamiane asynchronicznie na wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="81c55-189">Starting with apps that target the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], the calling thread's culture is inherited by each task, even if the task runs asynchronously on a thread pool thread.</span></span>  
  
 <span data-ttu-id="81c55-190">W poniższym przykładzie przedstawiono prosty ilustracji.</span><span class="sxs-lookup"><span data-stu-id="81c55-190">The following example provides a simple illustration.</span></span> <span data-ttu-id="81c55-191">Używa ona <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atrybutu do elementu docelowego [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] i zmiany bieżącej kultury aplikacji albo francuski (Francja) lub, jeśli francuski (Francja) jest już bieżącej kultury angielski (Stany Zjednoczone).</span><span class="sxs-lookup"><span data-stu-id="81c55-191">It uses the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute to target the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] and changes the app's current culture to either French (France) or, if French (France) is already the current culture, English (United States).</span></span> <span data-ttu-id="81c55-192">Następnie wywołuje delegata, o nazwie `formatDelegate` zwracającego niektóre numery sformatowane jako wartości waluty w nową kulturą.</span><span class="sxs-lookup"><span data-stu-id="81c55-192">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="81c55-193">Należy pamiętać, że czy delegata jako zadanie synchronicznie lub asynchronicznie, zwraca oczekiwany wynik ponieważ kultura wątku wywołującego jest dziedziczona przez zadanie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="81c55-193">Note that whether the delegate as a task either synchronously or asynchronously, it returns the expected result because the culture of the calling thread is inherited by the asynchronous task.</span></span>  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture1.cs#5)]
 [!code-vb[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture1.vb#5)]  
  
 <span data-ttu-id="81c55-194">Jeśli używasz programu Visual Studio, można pominąć <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atrybutu, a zamiast tego wybierz pozycję .NET Framework 4.6 jako element docelowy, podczas tworzenia projektu w **nowy projekt** okna dialogowego.</span><span class="sxs-lookup"><span data-stu-id="81c55-194">If you are using Visual Studio, you can omit the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute and instead select the .NET Framework 4.6 as the target when you create the project in the **New Project** dialog.</span></span>  
  
 <span data-ttu-id="81c55-195">Dla danych wyjściowych, który odzwierciedla działanie aplikacji w wersji docelowej programu .NET Framework w wersjach wcześniejszych niż [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], Usuń <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atrybutu z kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="81c55-195">For output that reflects the behavior of apps the target versions of the .NET Framework prior to [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], remove the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute from the source code.</span></span> <span data-ttu-id="81c55-196">Dane wyjściowe odzwierciedlają konwencje formatowania domyślna kultura systemu, nie kultury wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="81c55-196">The output will reflect the formatting conventions of the default system culture, not the culture of the calling thread.</span></span>  
  
 <span data-ttu-id="81c55-197">Aby uzyskać więcej informacji na temat zadań asynchronicznych i kultury, zobacz sekcję "Kultury i operacje asynchroniczne opartego na zadaniach" w <xref:System.Globalization.CultureInfo> tematu.</span><span class="sxs-lookup"><span data-stu-id="81c55-197">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>  
  
## <a name="creating-task-continuations"></a><span data-ttu-id="81c55-198">Tworzenie kontynuacji zadań</span><span class="sxs-lookup"><span data-stu-id="81c55-198">Creating task continuations</span></span>  
 <span data-ttu-id="81c55-199"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> i <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> metody umożliwiają określanie zadań do uruchamiania po *zadania poprzedzającego* zakończy się.</span><span class="sxs-lookup"><span data-stu-id="81c55-199">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="81c55-200">Delegat zadania kontynuacji jest przekazywany odwołanie do zadania poprzedzającego, dzięki czemu może sprawdzać stan zadania poprzedzającego i, poprzez pobranie wartości <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> , wykorzystywać dane wyjściowe zadania poprzedzającego jako danych wejściowych kontynuacji.</span><span class="sxs-lookup"><span data-stu-id="81c55-200">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>  
  
 <span data-ttu-id="81c55-201">W poniższym przykładzie `getData` zadanie zostało uruchomione przez wywołanie <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-201">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="81c55-202">`processData` Zadania jest uruchomiane automatycznie po `getData` zakończy pracę, i `displayData` po uruchomieniu `processData` zakończy się.</span><span class="sxs-lookup"><span data-stu-id="81c55-202">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="81c55-203">`getData` generuje tablicę liczb całkowitych, która jest dostępna dla `processData` za pośrednictwem zadań `getData` zadania podrzędnego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="81c55-203">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="81c55-204">`processData` Zadanie przetwarza tę tablicę i zwraca wynik, którego typ jest wnioskowany ze zwracanego typu wyrażenia lambda przekazanego do <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-204">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="81c55-205">`displayData` Zadanie podrzędne jest wykonywane automatycznie po `processData` zakończy pracę i <xref:System.Tuple%603> obiektu zwróconego przez `processData` wyrażenia lambda jest dostępny dla `displayData` za pośrednictwem zadań `processData` zadania podrzędnego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Właściwość.</span><span class="sxs-lookup"><span data-stu-id="81c55-205">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="81c55-206">`displayData` Zadanie pobiera wynik `processData` i produkuje wynik, którego typ jest wnioskowany w podobny sposób i który jest udostępniany programowi we <xref:System.Threading.Tasks.Task%601.Result%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="81c55-206">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
 [!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]  
  
 <span data-ttu-id="81c55-207">Ponieważ <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> jest metodą wystąpienia można połączyć w łańcuch wywołań metody zamiast tworzenia wystąpienia <xref:System.Threading.Tasks.Task%601> obiekt dla każdego zadania poprzedzającego.</span><span class="sxs-lookup"><span data-stu-id="81c55-207">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="81c55-208">Poniższy przykład jest funkcjonalnie identyczny z poprzednim przykładem, z tą różnicą, że łańcuchy wywołania <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-208">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="81c55-209">Należy pamiętać, że <xref:System.Threading.Tasks.Task%601> obiekt zwrócony przez łańcuch wywołań metod jest zadaniem końcowym kontynuacji.</span><span class="sxs-lookup"><span data-stu-id="81c55-209">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
 [!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]  
  
 <span data-ttu-id="81c55-210"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> i <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> metody umożliwiają kontynuowanie z wielu zadań.</span><span class="sxs-lookup"><span data-stu-id="81c55-210">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>  
  
 <span data-ttu-id="81c55-211">Aby uzyskać więcej informacji, zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-211">For more information, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
## <a name="creating-detached-child-tasks"></a><span data-ttu-id="81c55-212">Tworzenie odłączonych zadań podrzędnych</span><span class="sxs-lookup"><span data-stu-id="81c55-212">Creating detached child tasks</span></span>  
 <span data-ttu-id="81c55-213">Gdy kod użytkownika, który jest uruchomiony w zadaniu, tworzy nowe zadanie i nie określa <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> opcji, nowe zadanie nie jest zsynchronizowane z zadaniem nadrzędnym w żaden specjalny sposób.</span><span class="sxs-lookup"><span data-stu-id="81c55-213">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="81c55-214">Ten typ niezsynchronizowanego zadania nosi nazwę *odłączone zadanie zagnieżdżone* lub *odłączone zadanie podrzędne*.</span><span class="sxs-lookup"><span data-stu-id="81c55-214">This type of non-synchronized task is called a *detached nested task* or *detached child task*.</span></span> <span data-ttu-id="81c55-215">Poniższy przykład przedstawia zadanie, które tworzy jedno odłączone zadanie podrzędne.</span><span class="sxs-lookup"><span data-stu-id="81c55-215">The following example shows a task that creates one detached child task.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
 [!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]  
  
 <span data-ttu-id="81c55-216">Należy zauważyć, że zadanie nadrzędne nie czeka na zakończenie odłączonego zadania podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="81c55-216">Note that the parent task does not wait for the detached child task to finish.</span></span>  
  
## <a name="creating-child-tasks"></a><span data-ttu-id="81c55-217">Tworzenie zadań podrzędnych</span><span class="sxs-lookup"><span data-stu-id="81c55-217">Creating child tasks</span></span>  
 <span data-ttu-id="81c55-218">Gdy kod użytkownika, który jest uruchomiony w zadaniu, tworzy zadanie z <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> opcji, nowe zadanie jest znany jako *dołączone zadanie podrzędne* zadania nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="81c55-218">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as a *attached child task* of the parent task.</span></span> <span data-ttu-id="81c55-219">Możesz użyć <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> opcji do wyrażania równoległości zadań strukturalnych, ponieważ zadanie nadrzędne czeka na zakończenie wszystkich zadań dołączonych zadań podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="81c55-219">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="81c55-220">Poniższy przykład przedstawia zadanie nadrzędne, które tworzy dziesięć dołączonych zadań podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="81c55-220">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="81c55-221">Należy pamiętać, że chociaż w przykładzie <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodę, aby czekać na zadanie nadrzędne zakończyć, nie musi jawnie czekać na zakończenie zadań dołączonych zadań podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="81c55-221">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
 [!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]  
  
 <span data-ttu-id="81c55-222">Zadanie nadrzędne może użyć <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> opcję, aby uniemożliwić innym zadaniom dołączanie do zadania nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="81c55-222">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="81c55-223">Aby uzyskać więcej informacji, zobacz [dołączone i odłączone zadania podrzędne](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-223">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="81c55-224">Oczekiwanie na zakończenie zadań</span><span class="sxs-lookup"><span data-stu-id="81c55-224">Waiting for tasks to finish</span></span>  
 <span data-ttu-id="81c55-225"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> i <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> typy zapewniają kilka przeciążeń <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> i <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>--> `System.Threading.Tasks.Task.Wait` metody, które umożliwiają czekanie na zakończenie zadania.</span><span class="sxs-lookup"><span data-stu-id="81c55-225">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> and        <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>--> `System.Threading.Tasks.Task.Wait` methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="81c55-226">Ponadto przeciążenia statycznych <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> metody umożliwiają oczekiwanie poszczególnych lub wszystkich tablicy na zakończenie zadań.</span><span class="sxs-lookup"><span data-stu-id="81c55-226">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>  
  
 <span data-ttu-id="81c55-227">Zazwyczaj użytkownik czeka na zadanie z jednego z poniższych powodów:</span><span class="sxs-lookup"><span data-stu-id="81c55-227">Typically, you would wait for a task for one of these reasons:</span></span>  
  
-   <span data-ttu-id="81c55-228">Główny wątek zależy od wyniku końcowego obliczonego przez zadanie.</span><span class="sxs-lookup"><span data-stu-id="81c55-228">The main thread depends on the final result computed by a task.</span></span>  
  
-   <span data-ttu-id="81c55-229">Trzeba obsługiwać wyjątki, które mogą być zgłoszone przez zadanie.</span><span class="sxs-lookup"><span data-stu-id="81c55-229">You have to handle exceptions that might be thrown from the task.</span></span>  
  
-   <span data-ttu-id="81c55-230">Aplikacja może się zakończyć zanim wszystkie zadania zostaną ukończone.</span><span class="sxs-lookup"><span data-stu-id="81c55-230">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="81c55-231">Na przykład aplikacje konsoli zakończą tak szybko, jak cały synchroniczny kod w `Main` zostało wykonane (punkcie wejścia aplikacji).</span><span class="sxs-lookup"><span data-stu-id="81c55-231">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>  
  
 <span data-ttu-id="81c55-232">Poniższy przykład przedstawia podstawowy wzorzec, który nie wymaga obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="81c55-232">The following example shows the basic pattern that does not involve exception handling.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
 [!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]  
  
 <span data-ttu-id="81c55-233">Na przykład, który przedstawia obsługę wyjątków, zobacz [wyjątków](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-233">For an example that shows exception handling, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="81c55-234">Niektóre przeciążenia pozwalają określać limit czasu, a inne dodatkowo przejąć <xref:System.Threading.CancellationToken> jako parametr wejściowy, tak aby sam czas oczekiwania mógł być anulowany albo programowo, albo w odpowiedzi na użytkownika dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="81c55-234">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>  
  
 <span data-ttu-id="81c55-235">Gdy czekasz na zadanie, poczekasz na wszystkie obiekty podrzędne danego zadania, które zostały utworzone przy użyciu <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> opcji.</span><span class="sxs-lookup"><span data-stu-id="81c55-235">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="81c55-236"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> zwraca niezwłocznie, jeśli zadanie zostało już ukończone.</span><span class="sxs-lookup"><span data-stu-id="81c55-236"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="81c55-237">Wszelkie wyjątki wywoływane przez zadanie zostaną wyrzucone przez <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody, nawet jeśli <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metoda została wywołana po ukończeniu zadania.</span><span class="sxs-lookup"><span data-stu-id="81c55-237">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>  
  
## <a name="composing-tasks"></a><span data-ttu-id="81c55-238">Tworzenie zadań</span><span class="sxs-lookup"><span data-stu-id="81c55-238">Composing tasks</span></span>  
 <span data-ttu-id="81c55-239"><xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> klasy zapewniają kilka metod, które mogą pomóc Ci tworzenie wielu zadań do realizacji typowych wzorców i lepszego wykorzystywania asynchronicznych funkcji języka, które są dostarczane przez C#, Visual Basic i F#.</span><span class="sxs-lookup"><span data-stu-id="81c55-239">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="81c55-240">W tej sekcji opisano <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, i <xref:System.Threading.Tasks.Task.FromResult%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-240">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>  
  
### <a name="taskwhenall"></a><span data-ttu-id="81c55-241">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="81c55-241">Task.WhenAll</span></span>  
 <span data-ttu-id="81c55-242"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> Metoda asynchronicznie czeka na wiele <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> obiektów, aby zakończyć.</span><span class="sxs-lookup"><span data-stu-id="81c55-242">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="81c55-243">Zapewnia przeciążone wersje, które umożliwiają czekanie na niejednolite zestawy zadań.</span><span class="sxs-lookup"><span data-stu-id="81c55-243">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="81c55-244">Na przykład, możesz poczekać, aż wielu <xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> obiektów z jednego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-244">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>  
  
### <a name="taskwhenany"></a><span data-ttu-id="81c55-245">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="81c55-245">Task.WhenAny</span></span>  
 <span data-ttu-id="81c55-246"><xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> Metoda asynchronicznie czeka na jedno z wielu <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> obiektów, aby zakończyć.</span><span class="sxs-lookup"><span data-stu-id="81c55-246">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="81c55-247">Podobnie jak w <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> , ta metoda zapewnia przeciążone wersje, które umożliwiają czekanie na niejednolite zestawy zadań.</span><span class="sxs-lookup"><span data-stu-id="81c55-247">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="81c55-248"><xref:System.Threading.Tasks.Task.WhenAny%2A> Metoda jest szczególnie użyteczna w następujących scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="81c55-248">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>  
  
-   <span data-ttu-id="81c55-249">Operacje nadmiarowe.</span><span class="sxs-lookup"><span data-stu-id="81c55-249">Redundant operations.</span></span> <span data-ttu-id="81c55-250">Należy wziąć pod uwagę algorytm lub operację, które mogą być wykonywane na wiele sposobów.</span><span class="sxs-lookup"><span data-stu-id="81c55-250">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="81c55-251">Możesz użyć <xref:System.Threading.Tasks.Task.WhenAny%2A> metodę, aby wybrać operację, która zakończy się pierwsza, a następnie anulować pozostałe operacje.</span><span class="sxs-lookup"><span data-stu-id="81c55-251">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>  
  
-   <span data-ttu-id="81c55-252">Operacje z przeplotem.</span><span class="sxs-lookup"><span data-stu-id="81c55-252">Interleaved operations.</span></span> <span data-ttu-id="81c55-253">Można uruchomić wiele operacji, które muszą się zakończyć i używać <xref:System.Threading.Tasks.Task.WhenAny%2A> metody do przetwarzania wyników, po zakończeniu każdej operacji.</span><span class="sxs-lookup"><span data-stu-id="81c55-253">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="81c55-254">Po zakończeniu jednej operacji można uruchomić jedno lub więcej dodatkowych zadań.</span><span class="sxs-lookup"><span data-stu-id="81c55-254">After one operation finishes, you can start one or more additional tasks.</span></span>  
  
-   <span data-ttu-id="81c55-255">Operacje ograniczane.</span><span class="sxs-lookup"><span data-stu-id="81c55-255">Throttled operations.</span></span> <span data-ttu-id="81c55-256">Możesz użyć <xref:System.Threading.Tasks.Task.WhenAny%2A> metodę, aby rozszerzyć poprzedni scenariusz poprzez ograniczenie liczby operacji jednoczesnych.</span><span class="sxs-lookup"><span data-stu-id="81c55-256">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>  
  
-   <span data-ttu-id="81c55-257">Wygasłe operacje.</span><span class="sxs-lookup"><span data-stu-id="81c55-257">Expired operations.</span></span> <span data-ttu-id="81c55-258">Możesz użyć <xref:System.Threading.Tasks.Task.WhenAny%2A> metodę, aby wybrać jedno lub więcej zadań i zadań, który kończy się po określonym czasie, takie jak zadanie zwracane przez <xref:System.Threading.Tasks.Task.Delay%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-258">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="81c55-259"><xref:System.Threading.Tasks.Task.Delay%2A> Metoda została opisana w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="81c55-259">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>  
  
### <a name="taskdelay"></a><span data-ttu-id="81c55-260">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="81c55-260">Task.Delay</span></span>  
 <span data-ttu-id="81c55-261"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> Metoda <xref:System.Threading.Tasks.Task> obiektu, który kończy się po określonym czasie.</span><span class="sxs-lookup"><span data-stu-id="81c55-261">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="81c55-262">Możesz użyć tej metoda do tworzenia pętli, które od czasu do czasu pobierają dane, wprowadzają limity czasu, opóźniają obsługę danych wejściowych użytkownika przez wyznaczony czas i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="81c55-262">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>  
  
### <a name="tasktfromresult"></a><span data-ttu-id="81c55-263">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="81c55-263">Task(T).FromResult</span></span>  
 <span data-ttu-id="81c55-264">Za pomocą <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> metody, można utworzyć <xref:System.Threading.Tasks.Task%601> obiekt, który przechowuje wstępnie obliczony wynik.</span><span class="sxs-lookup"><span data-stu-id="81c55-264">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="81c55-265">Ta metoda jest przydatna, gdy wykonujesz operację asynchroniczną, która zwraca <xref:System.Threading.Tasks.Task%601> obiektu, a wynik tego obiektu <xref:System.Threading.Tasks.Task%601> obiektu jest już obliczony.</span><span class="sxs-lookup"><span data-stu-id="81c55-265">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="81c55-266">Aby uzyskać przykład, który używa <xref:System.Threading.Tasks.Task.FromResult%2A> do pobierania wyników asynchronicznych operacji pobrania, które są przechowywane w pamięci podręcznej, zobacz [jak: Tworzenie wstępnie obliczonych zadań](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-266">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md).</span></span>  
  
## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="81c55-267">Obsługa wyjątków w zadaniach</span><span class="sxs-lookup"><span data-stu-id="81c55-267">Handling exceptions in tasks</span></span>  
 <span data-ttu-id="81c55-268">Gdy zadanie wyrzuca jeden lub kilka wyjątków, wyjątki są opakowane w <xref:System.AggregateException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="81c55-268">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="81c55-269">Ten wyjątek jest propagowany z powrotem do wątku, który łączy się z zadaniem, które jest zazwyczaj wątkiem, który oczekuje na zakończenie zadania lub wątkiem, który uzyskuje dostęp do <xref:System.Threading.Tasks.Task%601.Result%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="81c55-269">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="81c55-270">To zachowanie służy do wymuszania zasady .NET Framework, zgodnie z którą wszystkie nieobsłużone wyjątki powinny domyślnie przerywać proces.</span><span class="sxs-lookup"><span data-stu-id="81c55-270">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="81c55-271">Kod wywołujący może obsługiwać wyjątki za pomocą jednej z następujących czynności w `try` / `catch` bloku:</span><span class="sxs-lookup"><span data-stu-id="81c55-271">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>  
  
-   <span data-ttu-id="81c55-272"><xref:System.Threading.Tasks.Task.Wait%2A> — Metoda</span><span class="sxs-lookup"><span data-stu-id="81c55-272">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>  
  
-   <span data-ttu-id="81c55-273"><xref:System.Threading.Tasks.Task.WaitAll%2A> — Metoda</span><span class="sxs-lookup"><span data-stu-id="81c55-273">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>  
  
-   <span data-ttu-id="81c55-274"><xref:System.Threading.Tasks.Task.WaitAny%2A> — Metoda</span><span class="sxs-lookup"><span data-stu-id="81c55-274">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>  
  
-   <span data-ttu-id="81c55-275"><xref:System.Threading.Tasks.Task%601.Result%2A> Właściwości</span><span class="sxs-lookup"><span data-stu-id="81c55-275">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>  
  
 <span data-ttu-id="81c55-276">Przyłączany wątek może również obsługiwać wyjątki, uzyskując dostęp do <xref:System.Threading.Tasks.Task.Exception%2A> właściwości przed usunięciem z zadania zebranych elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="81c55-276">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="81c55-277">Dostęp do tej właściwości zapobiega temu, że nieobsługiwany wyjątek inicjuje zachowanie propagacji wyjątku, które przerywa proces wraz z finalizacją obiektu.</span><span class="sxs-lookup"><span data-stu-id="81c55-277">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>  
  
 <span data-ttu-id="81c55-278">Aby uzyskać więcej informacji dotyczących wyjątków i zadań, zobacz [wyjątków](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-278">For more information about exceptions and tasks, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="canceling-tasks"></a><span data-ttu-id="81c55-279">Anulowanie zadania</span><span class="sxs-lookup"><span data-stu-id="81c55-279">Canceling tasks</span></span>  
 <span data-ttu-id="81c55-280">`Task` Klasy obsługuje kooperatywne anulowanie i jest w pełni zintegrowana z <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> i <xref:System.Threading.CancellationToken?displayProperty=nameWithType> klasy, które zostały wprowadzone w programie .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="81c55-280">The `Task` class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="81c55-281">Wiele konstruktorów w <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> take klasy <xref:System.Threading.CancellationToken> obiekt jako parametr wejściowy.</span><span class="sxs-lookup"><span data-stu-id="81c55-281">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="81c55-282">Wiele <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> i <xref:System.Threading.Tasks.Task.Run%2A> przeciążenia również obejmować <xref:System.Threading.CancellationToken> parametru.</span><span class="sxs-lookup"><span data-stu-id="81c55-282">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>  
  
 <span data-ttu-id="81c55-283">Możesz utworzyć token i wydawać żądanie anulowania w późniejszym czasie, przy użyciu <xref:System.Threading.CancellationTokenSource> klasy.</span><span class="sxs-lookup"><span data-stu-id="81c55-283">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="81c55-284">Przekaż token do <xref:System.Threading.Tasks.Task> jako argument, a także odwołanie do tego samego tokenu w swoim delegacie użytkownika, który wykonuje pracę odpowiadania na żądanie anulowania.</span><span class="sxs-lookup"><span data-stu-id="81c55-284">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>  
  
 <span data-ttu-id="81c55-285">Aby uzyskać więcej informacji, zobacz [anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md) i [jak: Anulowanie zadania i jego elementów podrzędnych](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-285">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
## <a name="the-taskfactory-class"></a><span data-ttu-id="81c55-286">Klasa TaskFactory</span><span class="sxs-lookup"><span data-stu-id="81c55-286">The TaskFactory class</span></span>  
 <span data-ttu-id="81c55-287"><xref:System.Threading.Tasks.TaskFactory> Klasa zawiera metody statyczne, które hermetyzują niektóre typowe wzorce do tworzenia i uruchamiania zadań oraz zadań kontynuacji.</span><span class="sxs-lookup"><span data-stu-id="81c55-287">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>  
  
-   <span data-ttu-id="81c55-288">Najczęstszym wzorcem jest <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, który tworzy i uruchamia zadanie w jednej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="81c55-288">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>  
  
-   <span data-ttu-id="81c55-289">Podczas tworzenia zadań kontynuacji z wielu poprzedników, użyj <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> metody lub <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> lub ich odpowiedników w <xref:System.Threading.Tasks.Task%601> klasy.</span><span class="sxs-lookup"><span data-stu-id="81c55-289">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="81c55-290">Aby uzyskać więcej informacji, zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-290">For more information, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
-   <span data-ttu-id="81c55-291">Do hermetyzacji modelu programowania asynchronicznego `BeginX` i `EndX` metody <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> wystąpienia, należy użyć <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-291">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="81c55-292">Aby uzyskać więcej informacji, zobacz [TPL i tradycyjnym .NET Framework Asynchronous Programming](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-292">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md).</span></span>  
  
 <span data-ttu-id="81c55-293">Wartość domyślna <xref:System.Threading.Tasks.TaskFactory> może być dostępna jako właściwość statyczna w <xref:System.Threading.Tasks.Task> klasy lub <xref:System.Threading.Tasks.Task%601> klasy.</span><span class="sxs-lookup"><span data-stu-id="81c55-293">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="81c55-294">Można również utworzyć wystąpienie <xref:System.Threading.Tasks.TaskFactory> bezpośrednio i określić różne opcje, które obejmują <xref:System.Threading.CancellationToken>, <xref:System.Threading.Tasks.TaskCreationOptions> opcji <xref:System.Threading.Tasks.TaskContinuationOptions> opcji lub <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="81c55-294">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="81c55-295">Niezależnie od opcji określanych podczas tworzenia fabryka zadań zostaną zastosowane do wszystkich zadań, które tworzy, chyba że <xref:System.Threading.Tasks.Task> jest tworzona przy użyciu <xref:System.Threading.Tasks.TaskCreationOptions> wyliczenia, w którym wówczas Opcje zadania zastępują opcje fabryki zadań.</span><span class="sxs-lookup"><span data-stu-id="81c55-295">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>  
  
## <a name="tasks-without-delegates"></a><span data-ttu-id="81c55-296">Zadania bez delegatów</span><span class="sxs-lookup"><span data-stu-id="81c55-296">Tasks without delegates</span></span>  
 <span data-ttu-id="81c55-297">W niektórych przypadkach warto użyć <xref:System.Threading.Tasks.Task> do hermetyzacji pewnej operacji asynchronicznej wykonywaną przez składnik zewnętrzny zamiast delegata użytkownika.</span><span class="sxs-lookup"><span data-stu-id="81c55-297">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="81c55-298">Jeśli operacja jest oparta na wzorcu asynchronicznego programowania początku/końca modelu, można użyć <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="81c55-298">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="81c55-299">Jeśli nie jest tak, możesz użyć <xref:System.Threading.Tasks.TaskCompletionSource%601> obiekt, aby opakować operację w zadanie co pozwala na uzyskanie niektórych korzyści zapewnianych przez <xref:System.Threading.Tasks.Task> programowania, na przykład obsługi propagacji i kontynuacji wyjątków.</span><span class="sxs-lookup"><span data-stu-id="81c55-299">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="81c55-300">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="81c55-300">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>  
  
## <a name="custom-schedulers"></a><span data-ttu-id="81c55-301">Planiści niestandardowi</span><span class="sxs-lookup"><span data-stu-id="81c55-301">Custom schedulers</span></span>  
 <span data-ttu-id="81c55-302">Większość deweloperów aplikacji lub biblioteki nie obchodzi, na którym procesorze zadanie będzie uruchamiane, jak synchronizuje swoją pracę z innymi zadaniami lub jak je zaplanowano w <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="81c55-302">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="81c55-303">Wymagają one tylko, aby było wykonane jak najwydajniej na komputerze-hoście.</span><span class="sxs-lookup"><span data-stu-id="81c55-303">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="81c55-304">Jeśli potrzebna większa kontrola nad szczegółami planowania, biblioteka zadań równoległych pozwala skonfigurować niektóre ustawienia w domyślnym harmonogramie zadań, a nawet pozwala podać niestandardowy harmonogram.</span><span class="sxs-lookup"><span data-stu-id="81c55-304">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="81c55-305">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="81c55-305">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
## <a name="related-data-structures"></a><span data-ttu-id="81c55-306">Pokrewne struktury danych</span><span class="sxs-lookup"><span data-stu-id="81c55-306">Related data structures</span></span>  
 <span data-ttu-id="81c55-307">TPL ma kilka nowych typów publicznych, które są przydatne w scenariuszach równoległych i sekwencyjnych.</span><span class="sxs-lookup"><span data-stu-id="81c55-307">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="81c55-308">Obejmują one kilka klas kolekcji wątkowo, szybkich i skalowalnych przestrzeni <xref:System.Collections.Concurrent?displayProperty=nameWithType> przestrzeni nazw oraz kilka nowych typów synchronizacji, na przykład <xref:System.Threading.Semaphore?displayProperty=nameWithType> i <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, które są bardziej wydajne niż ich starsze wersje dla określonych rodzaje obciążeń.</span><span class="sxs-lookup"><span data-stu-id="81c55-308">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="81c55-309">Inne nowe typy w .NET Framework 4, na przykład <xref:System.Threading.Barrier?displayProperty=nameWithType> i <xref:System.Threading.SpinLock?displayProperty=nameWithType>, oferują funkcje, które nie były dostępne we wcześniejszych wersjach.</span><span class="sxs-lookup"><span data-stu-id="81c55-309">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="81c55-310">Aby uzyskać więcej informacji, zobacz [struktury danych dla programowania równoległego](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-310">For more information, see [Data Structures for Parallel Programming](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md).</span></span>  
  
## <a name="custom-task-types"></a><span data-ttu-id="81c55-311">Niestandardowe typy zadań</span><span class="sxs-lookup"><span data-stu-id="81c55-311">Custom task types</span></span>  
 <span data-ttu-id="81c55-312">Firma Microsoft zaleca, aby nie dziedziczyć z <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="81c55-312">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="81c55-313">Zamiast tego zaleca się używanie <xref:System.Threading.Tasks.Task.AsyncState%2A> właściwości, aby skojarzyć dodatkowe dane lub stan z <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="81c55-313">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="81c55-314">Umożliwia także metod rozszerzających do rozszerzenia funkcji <xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> klasy.</span><span class="sxs-lookup"><span data-stu-id="81c55-314">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="81c55-315">Aby uzyskać więcej informacji dotyczących metod rozszerzających, zobacz [metody rozszerzenia](~/docs/csharp/programming-guide/classes-and-structs/extension-methods.md) i [metody rozszerzenia](~/docs/visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="81c55-315">For more information about extension methods, see [Extension Methods](~/docs/csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](~/docs/visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>  
  
 <span data-ttu-id="81c55-316">Jeśli trzeba dziedziczyć z <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601>, nie można użyć <xref:System.Threading.Tasks.Task.Run%2A>, <xref:System.Threading.Tasks.Task.Run%2A>, lub <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, lub <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> typu klasy, aby utworzyć wystąpienia niestandardowego zadania, ponieważ te mechanizmy tworzą tylko <xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> obiektów.</span><span class="sxs-lookup"><span data-stu-id="81c55-316">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="81c55-317">Ponadto nie można użyć mechanizmów kontynuacji zadań, które są dostarczane przez <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, i <xref:System.Threading.Tasks.TaskFactory%601> do tworzenia wystąpień tego typu niestandardowego zadania, ponieważ te mechanizmy również utworzą tylko <xref:System.Threading.Tasks.Task> i  <xref:System.Threading.Tasks.Task%601> obiektów.</span><span class="sxs-lookup"><span data-stu-id="81c55-317">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="81c55-318">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="81c55-318">Related topics</span></span>  
  
|<span data-ttu-id="81c55-319">Tytuł</span><span class="sxs-lookup"><span data-stu-id="81c55-319">Title</span></span>|<span data-ttu-id="81c55-320">Opis</span><span class="sxs-lookup"><span data-stu-id="81c55-320">Description</span></span>|  
|-|-|  
|[<span data-ttu-id="81c55-321">Tworzenie łańcuchów zadań przy użyciu zadań kontynuacji</span><span class="sxs-lookup"><span data-stu-id="81c55-321">Chaining Tasks by Using Continuation Tasks</span></span>](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="81c55-322">Opisuje, jak działa kontynuacja.</span><span class="sxs-lookup"><span data-stu-id="81c55-322">Describes how continuations work.</span></span>|  
|[<span data-ttu-id="81c55-323">Dołączone i odłączone zadania podrzędne</span><span class="sxs-lookup"><span data-stu-id="81c55-323">Attached and Detached Child Tasks</span></span>](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)|<span data-ttu-id="81c55-324">Opisano różnicę między zadaniami podrzędnymi dołączonymi i odłączonymi.</span><span class="sxs-lookup"><span data-stu-id="81c55-324">Describes the difference between attached and detached child tasks.</span></span>|  
|[<span data-ttu-id="81c55-325">Anulowanie zadania</span><span class="sxs-lookup"><span data-stu-id="81c55-325">Task Cancellation</span></span>](../../../docs/standard/parallel-programming/task-cancellation.md)|<span data-ttu-id="81c55-326">W tym artykule opisano obsługę anulowania, która jest wbudowana w <xref:System.Threading.Tasks.Task> obiektu.</span><span class="sxs-lookup"><span data-stu-id="81c55-326">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|  
|[<span data-ttu-id="81c55-327">Obsługa wyjątków</span><span class="sxs-lookup"><span data-stu-id="81c55-327">Exception Handling</span></span>](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)|<span data-ttu-id="81c55-328">Opisuje sposób obsługi wyjątków w wątkach współbieżnych.</span><span class="sxs-lookup"><span data-stu-id="81c55-328">Describes how exceptions on concurrent threads are handled.</span></span>|  
|[<span data-ttu-id="81c55-329">Instrukcje: Wykonywanie operacji równoległych za pomocą elementu Parallel.Invoke</span><span class="sxs-lookup"><span data-stu-id="81c55-329">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="81c55-330">Opisuje sposób używania <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="81c55-330">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|  
|[<span data-ttu-id="81c55-331">Instrukcje: Zwracanie wartości z zadania</span><span class="sxs-lookup"><span data-stu-id="81c55-331">How to: Return a Value from a Task</span></span>](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)|<span data-ttu-id="81c55-332">Zawiera opis sposobu zwracania wartości z zadań.</span><span class="sxs-lookup"><span data-stu-id="81c55-332">Describes how to return values from tasks.</span></span>|  
|[<span data-ttu-id="81c55-333">Instrukcje: Anulowanie zadania i jego elementów podrzędnych</span><span class="sxs-lookup"><span data-stu-id="81c55-333">How to: Cancel a Task and Its Children</span></span>](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="81c55-334">Opisuje, jak anulować zadania.</span><span class="sxs-lookup"><span data-stu-id="81c55-334">Describes how to cancel tasks.</span></span>|  
|[<span data-ttu-id="81c55-335">Instrukcje: Tworzenie wstępnie obliczonych zadań</span><span class="sxs-lookup"><span data-stu-id="81c55-335">How to: Create Pre-Computed Tasks</span></span>](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md)|<span data-ttu-id="81c55-336">Opisuje sposób używania <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> metody do pobierania wyników asynchronicznych operacji pobrania, które są przechowywane w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="81c55-336">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|  
|[<span data-ttu-id="81c55-337">Instrukcje: Przenoszenie drzewa binarnego z zadaniami równoległymi</span><span class="sxs-lookup"><span data-stu-id="81c55-337">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](../../../docs/standard/parallel-programming/how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="81c55-338">Opisuje używanie zadań do przechodzenia w drzewie binarnym.</span><span class="sxs-lookup"><span data-stu-id="81c55-338">Describes how to use tasks to traverse a binary tree.</span></span>|  
|[<span data-ttu-id="81c55-339">Instrukcje: Dekodowanie zadania zagnieżdżonego</span><span class="sxs-lookup"><span data-stu-id="81c55-339">How to: Unwrap a Nested Task</span></span>](../../../docs/standard/parallel-programming/how-to-unwrap-a-nested-task.md)|<span data-ttu-id="81c55-340">Pokazuje sposób użycia <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> — metoda rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="81c55-340">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|  
|[<span data-ttu-id="81c55-341">Równoległość danych</span><span class="sxs-lookup"><span data-stu-id="81c55-341">Data Parallelism</span></span>](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)|<span data-ttu-id="81c55-342">Opisuje sposób używania <xref:System.Threading.Tasks.Parallel.For%2A> i <xref:System.Threading.Tasks.Parallel.ForEach%2A> do tworzenia pętli równoległych nad danymi.</span><span class="sxs-lookup"><span data-stu-id="81c55-342">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|  
|[<span data-ttu-id="81c55-343">Programowanie równoległe</span><span class="sxs-lookup"><span data-stu-id="81c55-343">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)|<span data-ttu-id="81c55-344">Węzeł najwyższego poziomu dla .NET Framework programowania równoległego.</span><span class="sxs-lookup"><span data-stu-id="81c55-344">Top level node for .NET Framework parallel programming.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="81c55-345">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="81c55-345">See also</span></span>

- [<span data-ttu-id="81c55-346">Programowanie równoległe</span><span class="sxs-lookup"><span data-stu-id="81c55-346">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="81c55-347">Przykłady dotyczące programowania równoległego za pomocą programu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="81c55-347">Samples for Parallel Programming with the .NET Framework</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
