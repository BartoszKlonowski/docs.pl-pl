---
title: Struktury danych dla Programowania równoległego
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 6453e9983086dcb5b97ec134db9d74160d7a47cf
ms.sourcegitcommit: 69229651598b427c550223d3c58aba82e47b3f82
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/04/2018
ms.locfileid: "48779780"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="61a91-102">Struktury danych dla Programowania równoległego</span><span class="sxs-lookup"><span data-stu-id="61a91-102">Data Structures for Parallel Programming</span></span>
<span data-ttu-id="61a91-103">.NET Framework w wersji 4 wprowadza kilka nowych typów, które są przydatne do programowania równoległego, w tym zestaw klas kolekcji współbieżnych, podstawowych uproszczone synchronizacji i typów d inicjowania z opóźnieniem.</span><span class="sxs-lookup"><span data-stu-id="61a91-103">The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="61a91-104">Można użyć tych typów, zawierające kod aplikacji wielowątkowych, w tym w bibliotece równoległych zadań i PLINQ.</span><span class="sxs-lookup"><span data-stu-id="61a91-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="61a91-105">Klas kolekcji współbieżnych</span><span class="sxs-lookup"><span data-stu-id="61a91-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="61a91-106">Kolekcja klas w <xref:System.Collections.Concurrent?displayProperty=nameWithType> przestrzeni nazw podać metodą o bezpiecznych wątkach dodawania i usuwania operacji, które uniknąć blokad, tam gdzie to możliwe oraz Użyj blokowanie szczegółowe, gdzie blokady są niezbędne.</span><span class="sxs-lookup"><span data-stu-id="61a91-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="61a91-107">W przeciwieństwie do kolekcji, które zostały wprowadzone w .NET Framework w wersji 1.0 i 2.0 klasy kolekcji współbieżnych nie wymaga kod użytkownika do podejmowania żadnych blokad, gdy uzyskuje dostęp do elementów.</span><span class="sxs-lookup"><span data-stu-id="61a91-107">Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="61a91-108">Klasy kolekcji współbieżnych może znacznie poprawić wydajność przez typy takie jak <xref:System.Collections.ArrayList?displayProperty=nameWithType> i <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (z blokowanie zaimplementowane przez użytkownika) w scenariuszach, gdzie Dodawanie i usuwanie elementów z kolekcji w wielu wątkach.</span><span class="sxs-lookup"><span data-stu-id="61a91-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="61a91-109">Poniższa tabela zawiera listę nowych klas kolekcji współbieżnych:</span><span class="sxs-lookup"><span data-stu-id="61a91-109">The following table lists the new concurrent collection classes:</span></span>  
  
|<span data-ttu-id="61a91-110">Typ</span><span class="sxs-lookup"><span data-stu-id="61a91-110">Type</span></span>|<span data-ttu-id="61a91-111">Opis</span><span class="sxs-lookup"><span data-stu-id="61a91-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="61a91-112">Zapewnia blokowania i ograniczenia możliwości kolekcje obsługujące wielowątkowość, które implementują <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="61a91-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="61a91-113">Wątki producenta zablokować, jeśli nie ma dostępnych miejsc, lub jeśli kolekcja jest pełna.</span><span class="sxs-lookup"><span data-stu-id="61a91-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="61a91-114">Wątki konsumenta zablokować, jeśli kolekcja jest pusta.</span><span class="sxs-lookup"><span data-stu-id="61a91-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="61a91-115">Ten typ obsługuje również nieblokującej na poziomie dostępu przez konsumentów i producentów.</span><span class="sxs-lookup"><span data-stu-id="61a91-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="61a91-116"><xref:System.Collections.Concurrent.BlockingCollection%601> może służyć jako klasę bazową lub magazyn, aby zapewnić blokowanie i blokujących dla każdej klasy kolekcji, która obsługuje zapasowy <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="61a91-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="61a91-117">Implementację zbiór metodą o bezpiecznych wątkach, która oferuje skalowalne, dodać i operacjami pobierania.</span><span class="sxs-lookup"><span data-stu-id="61a91-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="61a91-118">Typ słownika równocześnie i skalowalne.</span><span class="sxs-lookup"><span data-stu-id="61a91-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="61a91-119">Kolejki FIFO równocześnie i skalowalne.</span><span class="sxs-lookup"><span data-stu-id="61a91-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="61a91-120">Stosu LIFO równocześnie i skalowalne.</span><span class="sxs-lookup"><span data-stu-id="61a91-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="61a91-121">Aby uzyskać więcej informacji, zobacz [kolekcje obsługujące wielowątkowość](../../../docs/standard/collections/thread-safe/index.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-121">For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="61a91-122">Podstawowych synchronizacji</span><span class="sxs-lookup"><span data-stu-id="61a91-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="61a91-123">Nowych elementów podstawowych synchronizacji, w <xref:System.Threading?displayProperty=nameWithType> przestrzeni nazw Włącz współbieżność szczegółową i zwiększyć wydajność dzięki unikaniu kosztownych mechanizmy blokady w starszej wersji kodu wielowątkowości.</span><span class="sxs-lookup"><span data-stu-id="61a91-123">The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span> <span data-ttu-id="61a91-124">Niektóre z nowych typów, takich jak <xref:System.Threading.Barrier?displayProperty=nameWithType> i <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> mają nie odpowiedniki we wcześniejszych wersjach programu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="61a91-124">Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.</span></span>  
  
 <span data-ttu-id="61a91-125">Poniższa tabela zawiera listę nowych typów synchronizacji:</span><span class="sxs-lookup"><span data-stu-id="61a91-125">The following table lists the new synchronization types:</span></span>  
  
|<span data-ttu-id="61a91-126">Typ</span><span class="sxs-lookup"><span data-stu-id="61a91-126">Type</span></span>|<span data-ttu-id="61a91-127">Opis</span><span class="sxs-lookup"><span data-stu-id="61a91-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="61a91-128">Umożliwia wielu wątków do pracy nad algorytmu równoległego, podając punkt, w której każde zadanie podrzędne może sygnalizują jego następnie blokowane, aż już korzystać z niektórych lub wszystkich zadań.</span><span class="sxs-lookup"><span data-stu-id="61a91-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="61a91-129">Aby uzyskać więcej informacji, zobacz [barierę](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-129">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="61a91-130">Upraszcza scenariusze rozwidlenia i sprzężenia, dostarczając mechanizmu łatwego spotkania.</span><span class="sxs-lookup"><span data-stu-id="61a91-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="61a91-131">Aby uzyskać więcej informacji, zobacz [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-131">For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="61a91-132">Element synchronizacji, podobnie jak <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="61a91-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="61a91-133"><xref:System.Threading.ManualResetEventSlim> to lekki, ale można używać tylko do komunikacji wewnątrz procesu.</span><span class="sxs-lookup"><span data-stu-id="61a91-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span> <span data-ttu-id="61a91-134">Aby uzyskać więcej informacji, zobacz [ManualResetEvent i ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-134">For more information, see [ManualResetEvent and ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="61a91-135">Element synchronizacji, która ogranicza liczbę wątków, które można jednocześnie uzyskać dostęp do zasobu lub puli zasobów.</span><span class="sxs-lookup"><span data-stu-id="61a91-135">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="61a91-136">Aby uzyskać więcej informacji, zobacz [Semaphore i SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-136">For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="61a91-137">Podstawowego blokady wzajemne wykluczenie, który powoduje wątku, który próbuje uzyskać blokady oczekiwać w pętli, lub *pokrętła*, okres czasu przed jego quantum reaguje.</span><span class="sxs-lookup"><span data-stu-id="61a91-137">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="61a91-138">W scenariuszach, w którym powinien być krótki, czas oczekiwania na blokadę <xref:System.Threading.SpinLock> zapewnia większą wydajność niż inne formy blokowania.</span><span class="sxs-lookup"><span data-stu-id="61a91-138">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="61a91-139">Aby uzyskać więcej informacji, zobacz [struktury SpinLock](../../../docs/standard/threading/spinlock.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-139">For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="61a91-140">Małe, lekkie typ, który będzie pokrętła przez określony czas i ostatecznie umieścić wątku w stan oczekiwania, po przekroczeniu liczby pokrętła.</span><span class="sxs-lookup"><span data-stu-id="61a91-140">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="61a91-141">Aby uzyskać więcej informacji, zobacz [metody SpinWait](../../../docs/standard/threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-141">For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="61a91-142">Aby uzyskać więcej informacji, zobacz:</span><span class="sxs-lookup"><span data-stu-id="61a91-142">For more information, see:</span></span>  
  
-   [<span data-ttu-id="61a91-143">Instrukcje: używanie struktury SpinLock do synchronizacji niskiego poziomu</span><span class="sxs-lookup"><span data-stu-id="61a91-143">How to: Use SpinLock for Low-Level Synchronization</span></span>](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
-   <span data-ttu-id="61a91-144">[Porady: synchronizacja jednoczesnych operacji za pomocą bariery](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-144">[How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="61a91-145">Inicjalizacja z opóźnieniem klas</span><span class="sxs-lookup"><span data-stu-id="61a91-145">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="61a91-146">Przy użyciu inicjowania z opóźnieniem pamięci dla obiektu nie jest przydzielony, dopóki nie jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="61a91-146">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="61a91-147">Inicjalizacja z opóźnieniem może zwiększyć wydajność przez rozłożenie przydziały obiektów równomiernie na okres istnienia programu.</span><span class="sxs-lookup"><span data-stu-id="61a91-147">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="61a91-148">Można włączyć inicjowania z opóźnieniem dla dowolnego typu niestandardowego przez opakowywanie typ <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="61a91-148">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="61a91-149">Poniższa tabela zawiera listę typów inicjowania z opóźnieniem:</span><span class="sxs-lookup"><span data-stu-id="61a91-149">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="61a91-150">Typ</span><span class="sxs-lookup"><span data-stu-id="61a91-150">Type</span></span>|<span data-ttu-id="61a91-151">Opis</span><span class="sxs-lookup"><span data-stu-id="61a91-151">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="61a91-152">Udostępnia lekki, wątkowo inicjowania z opóźnieniem —.</span><span class="sxs-lookup"><span data-stu-id="61a91-152">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="61a91-153">Zapewnia wartość opóźnieniem zainicjowana na zasadzie na wątek, każdy wątek opóźnieniem wywoływania funkcji inicjowania.</span><span class="sxs-lookup"><span data-stu-id="61a91-153">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="61a91-154">Udostępnia metody statyczne, które uniknąć konieczności przydzielić dedykowane wystąpienie inicjowania z opóźnieniem.</span><span class="sxs-lookup"><span data-stu-id="61a91-154">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="61a91-155">Zamiast tego używają odwołań, aby upewnić się, że elementy docelowe zostały zainicjowane, ponieważ są one używane.</span><span class="sxs-lookup"><span data-stu-id="61a91-155">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="61a91-156">Aby uzyskać więcej informacji, zobacz [inicjowania z opóźnieniem](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-156">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="61a91-157">Wyjątki agregacji</span><span class="sxs-lookup"><span data-stu-id="61a91-157">Aggregate Exceptions</span></span>  
 <span data-ttu-id="61a91-158"><xref:System.AggregateException?displayProperty=nameWithType> Typ może być używany do przechwytywania wielu wyjątków, które są zgłaszane jednocześnie w oddzielnych wątkach i przywrócić je do sąsiadującego wątku pojedynczego wyjątek.</span><span class="sxs-lookup"><span data-stu-id="61a91-158">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="61a91-159"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> i <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> typów i PLINQ używać <xref:System.AggregateException> często w tym celu.</span><span class="sxs-lookup"><span data-stu-id="61a91-159">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="61a91-160">Aby uzyskać więcej informacji, zobacz [wyjątków](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) i [porady: obsługa wyjątków w zapytaniu PLINQ](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="61a91-160">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="61a91-161">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="61a91-161">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
- <xref:System.Threading?displayProperty=nameWithType>  
- [<span data-ttu-id="61a91-162">Programowanie równoległe</span><span class="sxs-lookup"><span data-stu-id="61a91-162">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
