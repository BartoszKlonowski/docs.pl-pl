---
title: Ogólne informacje o przyspieszeniach w PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
ms.openlocfilehash: 07b5027d560a4caccc6c0a516c3f70c11df6be83
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "73139907"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="c4365-102">Ogólne informacje o przyspieszeniach w PLINQ</span><span class="sxs-lookup"><span data-stu-id="c4365-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="c4365-103">Głównym celem PLINQ jest przyspieszenie wykonywania LINQ do obiektów zapytań wykonując delegatów kwerendy równolegle na komputerach wielordzeniowych.</span><span class="sxs-lookup"><span data-stu-id="c4365-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="c4365-104">PLINQ działa najlepiej, gdy przetwarzanie każdego elementu w kolekcji źródłowej jest niezależna, bez współużytkowania stanu zaangażowanych między poszczególnych delegatów.</span><span class="sxs-lookup"><span data-stu-id="c4365-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="c4365-105">Takie operacje są powszechne w LINQ do obiektów i PLINQ, i są często nazywane "*uroczo równolegle*", ponieważ nadają się łatwo do planowania na wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="c4365-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="c4365-106">Jednak nie wszystkie zapytania składają się wyłącznie z niezwykle równoległych operacji; w większości przypadków kwerenda obejmuje niektóre operatory, które albo nie mogą być równoległe lub które spowalniają wykonywanie równoległe.</span><span class="sxs-lookup"><span data-stu-id="c4365-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="c4365-107">I nawet w przypadku zapytań, które są całkowicie uroczo równoległe, PLINQ musi nadal partycjonować źródło danych i zaplanować pracę nad wątkami i zwykle scalić wyniki po zakończeniu kwerendy.</span><span class="sxs-lookup"><span data-stu-id="c4365-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="c4365-108">Wszystkie te operacje dodać do obliczeniowych kosztów równoległości; te koszty dodawania równoległości są nazywane *obciążeniem*.</span><span class="sxs-lookup"><span data-stu-id="c4365-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="c4365-109">Aby osiągnąć optymalną wydajność w kwerendzie PLINQ, celem jest zmaksymalizowanie części, które są uroczo równoległe i zminimalizować części, które wymagają narzutów.</span><span class="sxs-lookup"><span data-stu-id="c4365-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="c4365-110">Ten artykuł zawiera informacje, które pomogą Ci napisać zapytania PLINQ, które są tak wydajne, jak to możliwe, a jednocześnie daje poprawne wyniki.</span><span class="sxs-lookup"><span data-stu-id="c4365-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="c4365-111">Czynniki wpływające na wydajność zapytań PLINQ</span><span class="sxs-lookup"><span data-stu-id="c4365-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="c4365-112">W poniższych sekcjach wymieniono niektóre z najważniejszych czynników, które mają wpływ na wydajność kwerendy równoległej.</span><span class="sxs-lookup"><span data-stu-id="c4365-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="c4365-113">Są to ogólne instrukcje, które same w sobie nie są wystarczające do przewidywania wydajności zapytań we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="c4365-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="c4365-114">Jak zawsze ważne jest, aby zmierzyć rzeczywistą wydajność określonych zapytań na komputerach z szeregiem reprezentatywnych konfiguracji i obciążeń.</span><span class="sxs-lookup"><span data-stu-id="c4365-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1. <span data-ttu-id="c4365-115">Koszt obliczeniowy całej pracy.</span><span class="sxs-lookup"><span data-stu-id="c4365-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="c4365-116">Aby osiągnąć przyspieszenie, zapytanie PLINQ musi mieć wystarczająco dużo uroczo równoległej pracy, aby zrównoważyć obciążenie.</span><span class="sxs-lookup"><span data-stu-id="c4365-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="c4365-117">Praca może być wyrażona jako koszt obliczeniowy każdego delegata pomnożona przez liczbę elementów w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="c4365-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="c4365-118">Zakładając, że operacja może być równoległa, im bardziej kosztowne obliczeniowo jest, tym większa szansa na przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="c4365-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="c4365-119">Na przykład jeśli funkcja trwa jedną milisekundę do wykonania, sekwencyjne zapytanie ponad 1000 elementów zajmie jedną sekundę, aby wykonać tę operację, podczas gdy kwerenda równoległa na komputerze z czterema rdzeniami może potrwać tylko 250 milisekund.</span><span class="sxs-lookup"><span data-stu-id="c4365-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="c4365-120">Daje to przyspieszenie o 750 milisekund.</span><span class="sxs-lookup"><span data-stu-id="c4365-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="c4365-121">Jeśli funkcja wymaga jednej sekundy do wykonania dla każdego elementu, przyspieszenie będzie 750 sekund.</span><span class="sxs-lookup"><span data-stu-id="c4365-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="c4365-122">Jeśli delegat jest bardzo drogie, a następnie PLINQ może zaoferować znaczne przyspieszenie z tylko kilka elementów w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="c4365-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="c4365-123">Z drugiej strony małe kolekcje źródłowe z trywialnymi delegatami zazwyczaj nie są dobrymi kandydatami do PLINQ.</span><span class="sxs-lookup"><span data-stu-id="c4365-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="c4365-124">W poniższym przykładzie queryA jest prawdopodobnie dobrym kandydatem do PLINQ, przy założeniu, że jego Select funkcja wymaga dużo pracy.</span><span class="sxs-lookup"><span data-stu-id="c4365-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="c4365-125">queryB prawdopodobnie nie jest dobrym kandydatem, ponieważ nie ma wystarczającej ilości pracy w Select instrukcji, a obciążenie równoległości zrównoważy większość lub wszystkie przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="c4365-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2. <span data-ttu-id="c4365-126">Liczba rdzeni logicznych w systemie (stopień równoległości).</span><span class="sxs-lookup"><span data-stu-id="c4365-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="c4365-127">Ten punkt jest oczywistym następstwem poprzedniej sekcji, zapytania, które są uroczo równolegle uruchomić szybciej na komputerach z większą liczbą rdzeni, ponieważ praca może być podzielona między bardziej równoczesnych wątków.</span><span class="sxs-lookup"><span data-stu-id="c4365-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="c4365-128">Całkowita ilość przyspieszenia zależy od tego, jaki procent ogólnej pracy kwerendy jest równoległy.</span><span class="sxs-lookup"><span data-stu-id="c4365-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="c4365-129">Jednak nie należy zakładać, że wszystkie kwerendy będą uruchamiane dwa razy szybciej na komputerze ośmiordzeniowym niż czterordzeniowy komputer.</span><span class="sxs-lookup"><span data-stu-id="c4365-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="c4365-130">Podczas dostrajania zapytań w celu uzyskania optymalnej wydajności, ważne jest, aby zmierzyć rzeczywiste wyniki na komputerach z różnych liczb rdzeni.</span><span class="sxs-lookup"><span data-stu-id="c4365-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="c4365-131">Ten punkt jest związany z punktem #1: większe zestawy danych są wymagane do korzystania z większych zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="c4365-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3. <span data-ttu-id="c4365-132">Liczba i rodzaj operacji.</span><span class="sxs-lookup"><span data-stu-id="c4365-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="c4365-133">PLINQ udostępnia AsOrdered operatora dla sytuacji, w których jest konieczne do utrzymania kolejności elementów w sekwencji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="c4365-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="c4365-134">Istnieje koszt związany z zamówieniem, ale koszt ten jest zwykle skromny.</span><span class="sxs-lookup"><span data-stu-id="c4365-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="c4365-135">GroupBy i Join operacji również ponieść obciążenie.</span><span class="sxs-lookup"><span data-stu-id="c4365-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="c4365-136">PLINQ działa najlepiej, gdy jest dozwolone do przetwarzania elementów w kolekcji źródłowej w dowolnej kolejności i przekazać je do następnego operatora, jak tylko są one gotowe.</span><span class="sxs-lookup"><span data-stu-id="c4365-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="c4365-137">Aby uzyskać więcej informacji, zobacz [Zachowanie zamówień w PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="c4365-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4. <span data-ttu-id="c4365-138">Forma wykonywania zapytań.</span><span class="sxs-lookup"><span data-stu-id="c4365-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="c4365-139">Jeśli przechowujesz wyniki kwerendy, wywołując ToArray lub ToList, wyniki ze wszystkich równoległych wątków muszą zostać scalone w strukturę pojedynczych danych.</span><span class="sxs-lookup"><span data-stu-id="c4365-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="c4365-140">Wiąże się to z nieuniknionymi kosztami obliczeniowymi.</span><span class="sxs-lookup"><span data-stu-id="c4365-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="c4365-141">Podobnie jeśli iterate wyniki przy użyciu foreach (For Each w języku Visual Basic) pętli, wyniki z wątków roboczych muszą być serializowane na wątku modułu wyliczania.</span><span class="sxs-lookup"><span data-stu-id="c4365-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="c4365-142">Ale jeśli chcesz po prostu wykonać niektóre działania na podstawie wyniku z każdego wątku, można użyć ForAll metody do wykonywania tej pracy na wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="c4365-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5. <span data-ttu-id="c4365-143">Typ opcji scalania.</span><span class="sxs-lookup"><span data-stu-id="c4365-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="c4365-144">PLINQ można skonfigurować do buforowania jego danych wyjściowych i produkować go w fragmentach lub wszystkie na raz po wygenerowaniu całego zestawu wyników, albo do strumieniowania poszczególnych wyników, ponieważ są one produkowane.</span><span class="sxs-lookup"><span data-stu-id="c4365-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="c4365-145">Pierwsze powoduje skrócenie całkowitego czasu wykonywania, a drugi powoduje zmniejszenie opóźnienia między elementami plonów.</span><span class="sxs-lookup"><span data-stu-id="c4365-145">The former results in decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="c4365-146">Opcje scalania nie zawsze mają duży wpływ na ogólną wydajność zapytań, ale mogą mieć wpływ na postrzeganą wydajność, ponieważ kontrolują, jak długo użytkownik musi czekać, aby zobaczyć wyniki.</span><span class="sxs-lookup"><span data-stu-id="c4365-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="c4365-147">Aby uzyskać więcej informacji, zobacz [Opcje scalania w plinq](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="c4365-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6. <span data-ttu-id="c4365-148">Rodzaj partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="c4365-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="c4365-149">W niektórych przypadkach kwerendy PLINQ za względem indeksowalnej kolekcji źródłowej może spowodować niezrównoważone obciążenie pracą.</span><span class="sxs-lookup"><span data-stu-id="c4365-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="c4365-150">W takim przypadku można zwiększyć wydajność kwerendy, tworząc niestandardowy partycjonator.</span><span class="sxs-lookup"><span data-stu-id="c4365-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="c4365-151">Aby uzyskać więcej informacji, zobacz [Partycjonery niestandardowe dla PLINQ i TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="c4365-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="c4365-152">Kiedy PLINQ wybiera tryb sekwencyjny</span><span class="sxs-lookup"><span data-stu-id="c4365-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="c4365-153">PLINQ zawsze będzie próbował wykonać kwerendę co najmniej tak szybko, jak kwerenda będzie działać sekwencyjnie.</span><span class="sxs-lookup"><span data-stu-id="c4365-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="c4365-154">Mimo że PLINQ nie patrzy na to, jak obliczeniowo drogie są delegaci użytkownika lub jak duże jest źródło danych wejściowych, to nie szukać niektórych zapytań "kształty".</span><span class="sxs-lookup"><span data-stu-id="c4365-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="c4365-155">W szczególności wyszukuje operatorów zapytań lub kombinacji operatorów, które zazwyczaj powodują kwerendy do wykonywania wolniej w trybie równoległym.</span><span class="sxs-lookup"><span data-stu-id="c4365-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="c4365-156">Po znalezieniu takich kształtów funkcja PLINQ domyślnie powraca do trybu sekwencyjnego.</span><span class="sxs-lookup"><span data-stu-id="c4365-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="c4365-157">Jednak po zmierzeniu wydajności określonej kwerendy można określić, że faktycznie działa szybciej w trybie równoległym.</span><span class="sxs-lookup"><span data-stu-id="c4365-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="c4365-158">W takich przypadkach można <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> użyć <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> flagi za pomocą metody, aby poinstruować PLINQ do równoległości kwerendy.</span><span class="sxs-lookup"><span data-stu-id="c4365-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="c4365-159">Aby uzyskać więcej informacji, zobacz [Jak: Określić tryb wykonywania w PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="c4365-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="c4365-160">Na poniższej liście opisano kształty kwerend, które plinq domyślnie będzie wykonywać w trybie sekwencyjnym:</span><span class="sxs-lookup"><span data-stu-id="c4365-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
- <span data-ttu-id="c4365-161">Kwerendy, które zawierają Select, indeksowane Gdzie, indeksowane SelectMany lub ElementAt klauzuli po zamawiania lub filtrowania operatora, który usunął lub zmienił kolejność oryginalnych indeksów.</span><span class="sxs-lookup"><span data-stu-id="c4365-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
- <span data-ttu-id="c4365-162">Zapytania, które zawierają Take, TakeWhile, Skip, SkipWhile operatora i gdzie indeksy w sekwencji źródłowej nie są w oryginalnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="c4365-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
- <span data-ttu-id="c4365-163">Kwerendy zawierające zip lub SequenceEquals, chyba że jedno ze źródeł danych ma pierwotnie uporządkowany indeks, a inne źródło danych jest indeksowalne (tj. tablica lub IList(T)).</span><span class="sxs-lookup"><span data-stu-id="c4365-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
- <span data-ttu-id="c4365-164">Kwerendy, które zawierają Concat, chyba że jest stosowany do indeksowalnych źródeł danych.</span><span class="sxs-lookup"><span data-stu-id="c4365-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
- <span data-ttu-id="c4365-165">Kwerendy, które zawierają Reverse, chyba że stosowane do źródła danych indeksowalny.</span><span class="sxs-lookup"><span data-stu-id="c4365-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c4365-166">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="c4365-166">See also</span></span>

- [<span data-ttu-id="c4365-167">Równoległe LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="c4365-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
