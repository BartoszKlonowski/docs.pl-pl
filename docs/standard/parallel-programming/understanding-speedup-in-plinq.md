---
title: Ogólne informacje o przyspieszeniach w PLINQ
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
ms.openlocfilehash: 64eb346ba57e9af9f5be0cc1b42398c4f539d4d4
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/24/2020
ms.locfileid: "95689904"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="e72ce-102">Ogólne informacje o przyspieszeniach w PLINQ</span><span class="sxs-lookup"><span data-stu-id="e72ce-102">Understanding Speedup in PLINQ</span></span>

<span data-ttu-id="e72ce-103">Głównym celem PLINQ jest przyspieszenie wykonywania zapytań LINQ to Objects przez wykonywanie delegatów zapytań równolegle na komputerach wielordzeniowych.</span><span class="sxs-lookup"><span data-stu-id="e72ce-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="e72ce-104">PLINQ sprawdza się najlepiej, gdy przetwarzanie każdego elementu w kolekcji źródłowej jest niezależne, bez współużytkowanego stanu wśród poszczególnych delegatów.</span><span class="sxs-lookup"><span data-stu-id="e72ce-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="e72ce-105">Takie operacje są typowe w LINQ to Objects i PLINQ i często nazywa się "*delightfully Parallel*", ponieważ ułatwiają one planowanie na wielu wątkach.</span><span class="sxs-lookup"><span data-stu-id="e72ce-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="e72ce-106">Jednak nie wszystkie zapytania składają się wyłącznie z delightfully operacji równoległych; w większości przypadków zapytanie obejmuje niektóre operatory, które nie mogą być równoległe lub spowalniają wykonywanie równoległe.</span><span class="sxs-lookup"><span data-stu-id="e72ce-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="e72ce-107">Mimo że zapytania, które są całkowicie delightfully równolegle, PLINQ muszą nadal dzielić źródło danych i zaplanować pracę w wątkach, a zazwyczaj scalać wyniki po zakończeniu zapytania.</span><span class="sxs-lookup"><span data-stu-id="e72ce-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="e72ce-108">Wszystkie te operacje są dodawane do kosztów obliczeniowych przetwarzanie równoległe; koszty dodawania przetwarzanie równoległe są nazywane *obciążeniem*.</span><span class="sxs-lookup"><span data-stu-id="e72ce-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="e72ce-109">Aby osiągnąć optymalną wydajność zapytania PLINQ, celem jest maksymalizacja części, które są delightfully równoległe i zminimalizowanie części, które wymagają narzutu.</span><span class="sxs-lookup"><span data-stu-id="e72ce-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="e72ce-110">Ten artykuł zawiera informacje, które pomogą w pisaniu PLINQ zapytań, które są tak wydajne, jak to możliwe, przy zachowaniu prawidłowych wyników.</span><span class="sxs-lookup"><span data-stu-id="e72ce-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="e72ce-111">Czynniki wpływające na wydajność zapytań PLINQ</span><span class="sxs-lookup"><span data-stu-id="e72ce-111">Factors that Impact PLINQ Query Performance</span></span>  

 <span data-ttu-id="e72ce-112">W poniższych sekcjach wymieniono najważniejsze czynniki wpływające na wydajność zapytań równoległych.</span><span class="sxs-lookup"><span data-stu-id="e72ce-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="e72ce-113">Są to ogólne instrukcje, które same nie są wystarczające do przewidywania wydajności zapytań we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="e72ce-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="e72ce-114">Tak samo ważne jest, aby mierzyć rzeczywistą wydajność konkretnych zapytań na komputerach z różnymi konfiguracjami i obciążeniami reprezentatywnymi.</span><span class="sxs-lookup"><span data-stu-id="e72ce-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1. <span data-ttu-id="e72ce-115">Koszt obliczeniowy całościowej pracy.</span><span class="sxs-lookup"><span data-stu-id="e72ce-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="e72ce-116">Aby osiągnąć przyspieszenie, zapytanie PLINQ musi mieć wystarczającą liczbę delightfully równoległej pracy, aby przesunąć obciążenie.</span><span class="sxs-lookup"><span data-stu-id="e72ce-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="e72ce-117">Nakład pracy może być wyrażony jako koszt obliczeniowy każdego delegata pomnożony przez liczbę elementów w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="e72ce-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="e72ce-118">Przy założeniu, że operacja może być równoległa, im bardziej kosztowne jest, tym większa szansa dla przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="e72ce-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="e72ce-119">Jeśli na przykład funkcja przyjmuje jedną milisekundę, wykonanie tej operacji przez sekwencyjne zapytanie ponad 1000 elementów zajmie jedną sekundę, podczas gdy zapytanie równoległe na komputerze z czterema rdzeniami może trwać tylko 250 milisekund.</span><span class="sxs-lookup"><span data-stu-id="e72ce-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="e72ce-120">Daje to przyspieszenie o 750 milisekund.</span><span class="sxs-lookup"><span data-stu-id="e72ce-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="e72ce-121">Jeśli funkcja wymagana przez jedną sekundę do wykonania dla każdego elementu, przyspieszenie będzie 750 sekund.</span><span class="sxs-lookup"><span data-stu-id="e72ce-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="e72ce-122">Jeśli delegat jest bardzo kosztowny, PLINQ może oferować znaczący przyspieszenie z tylko kilkoma elementami w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="e72ce-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="e72ce-123">Z kolei małe kolekcje źródłowe z prostymi delegatami zwykle nie są dobrymi kandydatami do PLINQ.</span><span class="sxs-lookup"><span data-stu-id="e72ce-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="e72ce-124">W poniższym przykładzie zapytanie jest prawdopodobnie dobrym kandydatem do PLINQ, przy założeniu, że jego funkcja SELECT obejmuje wiele pracy.</span><span class="sxs-lookup"><span data-stu-id="e72ce-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="e72ce-125">queryB prawdopodobnie nie jest dobrym kandydatem, ponieważ nie ma wystarczającej ilości pracy w instrukcji SELECT, a obciążenie przetwarzanie równoległe będzie przesunięte w większości lub wszystkich przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="e72ce-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2. <span data-ttu-id="e72ce-126">Liczba rdzeni logicznych w systemie (stopień równoległości).</span><span class="sxs-lookup"><span data-stu-id="e72ce-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="e72ce-127">Ten punkt jest oczywistym współrzutem do poprzedniej sekcji zapytania, które są delightfully równoległe na maszynach o większej liczbie rdzeni, ponieważ praca może być dzielona między więcej współbieżnych wątków.</span><span class="sxs-lookup"><span data-stu-id="e72ce-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="e72ce-128">Ogólna ilość przyspieszenie zależy od tego, jaki procent ogólnej pracy zapytania to działania równoległego.</span><span class="sxs-lookup"><span data-stu-id="e72ce-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="e72ce-129">Jednak nie należy zakładać, że wszystkie zapytania będą uruchamiane dwa razy na osiem komputerów Core jako cztery podstawowe komputery.</span><span class="sxs-lookup"><span data-stu-id="e72ce-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="e72ce-130">Podczas dostrajania zapytań w celu uzyskania optymalnej wydajności ważne jest, aby mierzyć rzeczywiste wyniki na komputerach z różnymi liczbami rdzeni.</span><span class="sxs-lookup"><span data-stu-id="e72ce-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="e72ce-131">Ten punkt jest związany z punktem #1: większe zestawy danych są wymagane do wykorzystania większej ilości zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="e72ce-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3. <span data-ttu-id="e72ce-132">Liczba i rodzaj operacji.</span><span class="sxs-lookup"><span data-stu-id="e72ce-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="e72ce-133">PLINQ udostępnia operator operator AsOrdered w sytuacjach, w których konieczne jest zachowanie kolejności elementów w sekwencji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="e72ce-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="e72ce-134">Istnieje koszt związany z porządkowaniem, ale ten koszt jest zazwyczaj Nieumiarkowany.</span><span class="sxs-lookup"><span data-stu-id="e72ce-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="e72ce-135">Operacje GroupBy i Join również powodują naliczanie kosztów.</span><span class="sxs-lookup"><span data-stu-id="e72ce-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="e72ce-136">PLINQ sprawdza się najlepiej, gdy może przetwarzać elementy w kolekcji źródłowej w dowolnej kolejności i przekazywać je do następnego operatora, gdy tylko będą gotowe.</span><span class="sxs-lookup"><span data-stu-id="e72ce-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="e72ce-137">Aby uzyskać więcej informacji, zobacz temat [porządkowania zamówień w PLINQ](order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="e72ce-137">For more information, see [Order Preservation in PLINQ](order-preservation-in-plinq.md).</span></span>  
  
4. <span data-ttu-id="e72ce-138">Forma wykonywania zapytania.</span><span class="sxs-lookup"><span data-stu-id="e72ce-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="e72ce-139">Jeśli przechowujesz wyniki zapytania przez wywołanie ToArray — lub ToList —, wyniki ze wszystkich wątków równoległych muszą zostać scalone w ramach pojedynczej struktury danych.</span><span class="sxs-lookup"><span data-stu-id="e72ce-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="e72ce-140">Dotyczy to niemożliwego do uniknięcia kosztu obliczeniowego.</span><span class="sxs-lookup"><span data-stu-id="e72ce-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="e72ce-141">Podobnie, w przypadku iteracji wyników przy użyciu pętli foreach (dla każdej w Visual Basic), wyniki wątków roboczych muszą być serializowane do wątku modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="e72ce-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="e72ce-142">Jeśli jednak po prostu chcesz wykonać pewne czynności na podstawie wyniku z każdego wątku, możesz użyć metody ForAll, aby wykonać tę czynność na wielu wątkach.</span><span class="sxs-lookup"><span data-stu-id="e72ce-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5. <span data-ttu-id="e72ce-143">Typ opcji scalania.</span><span class="sxs-lookup"><span data-stu-id="e72ce-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="e72ce-144">PLINQ można skonfigurować w taki sposób, aby buforuje swoje dane wyjściowe, i generować go w fragmentach lub wszystkie jednocześnie po utworzeniu całego zestawu wyników lub w innym strumieniu w miarę ich produkcji.</span><span class="sxs-lookup"><span data-stu-id="e72ce-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="e72ce-145">Poprzednie wyniki w skrócie łączny czas wykonywania i ostatnie wyniki zmniejszają opóźnienia między elementami.</span><span class="sxs-lookup"><span data-stu-id="e72ce-145">The former results in decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="e72ce-146">Mimo że opcje scalania nie zawsze mają istotny wpływ na ogólną wydajność zapytań, mogą mieć wpływ na postrzeganą wydajność, ponieważ kontrolują, jak długo użytkownik musi czekać, aby zobaczyć wyniki.</span><span class="sxs-lookup"><span data-stu-id="e72ce-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="e72ce-147">Aby uzyskać więcej informacji, zobacz [Opcje scalania w PLINQ](merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="e72ce-147">For more information, see [Merge Options in PLINQ](merge-options-in-plinq.md).</span></span>  
  
6. <span data-ttu-id="e72ce-148">Rodzaj partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="e72ce-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="e72ce-149">W niektórych przypadkach zapytanie PLINQ w kolekcji źródłowej z indeksem może spowodować niezrównoważone obciążenie pracą.</span><span class="sxs-lookup"><span data-stu-id="e72ce-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="e72ce-150">W takim przypadku może być możliwe zwiększenie wydajności zapytania przez utworzenie niestandardowego programu Partitioner.</span><span class="sxs-lookup"><span data-stu-id="e72ce-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="e72ce-151">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="e72ce-151">For more information, see [Custom Partitioners for PLINQ and TPL](custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="e72ce-152">Gdy PLINQ wybiera tryb sekwencyjny</span><span class="sxs-lookup"><span data-stu-id="e72ce-152">When PLINQ Chooses Sequential Mode</span></span>  

 <span data-ttu-id="e72ce-153">PLINQ zawsze podejmie próbę wykonania zapytania co najmniej tak szybko, jak zapytanie zostanie uruchomione sekwencyjnie.</span><span class="sxs-lookup"><span data-stu-id="e72ce-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="e72ce-154">Mimo że PLINQ nie sprawdza, w jaki sposób wyliczane są Delegaty użytkowników, lub jak duże jest źródło danych wejściowych, szuka określonych zapytań "Shapes".</span><span class="sxs-lookup"><span data-stu-id="e72ce-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="e72ce-155">W odniesieniu do tego szuka operatorów zapytań lub kombinacji operatorów, które zwykle powodują spowolnienie wykonywania zapytania w trybie równoległym.</span><span class="sxs-lookup"><span data-stu-id="e72ce-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="e72ce-156">Po znalezieniu takich kształtów PLINQ domyślnie wraca do trybu sekwencyjnego.</span><span class="sxs-lookup"><span data-stu-id="e72ce-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="e72ce-157">Jednak po pomiarze wydajności określonego zapytania można określić, że faktycznie działa szybciej w trybie równoległym.</span><span class="sxs-lookup"><span data-stu-id="e72ce-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="e72ce-158">W takich przypadkach można użyć <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flagi za pośrednictwem <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> metody, aby poinstruować PLINQ o zrównoleglanie zapytania.</span><span class="sxs-lookup"><span data-stu-id="e72ce-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="e72ce-159">Aby uzyskać więcej informacji, zobacz [How to: Określanie trybu wykonywania w PLINQ](how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="e72ce-159">For more information, see [How to: Specify the Execution Mode in PLINQ](how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="e72ce-160">Na poniższej liście opisano kształty zapytań, które domyślnie PLINQ są wykonywane w trybie sekwencyjnym:</span><span class="sxs-lookup"><span data-stu-id="e72ce-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
- <span data-ttu-id="e72ce-161">Zapytania zawierające klauzulę SELECT, Indexed WHERE, Indexed SelectMany lub ElementAt po operatorze porządkowania lub filtrowania, który usunął lub zmienił rozmieszczenie oryginalnych indeksów.</span><span class="sxs-lookup"><span data-stu-id="e72ce-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
- <span data-ttu-id="e72ce-162">Zapytania zawierające operator Take, TakeWhile —, Skip, SkipWhile — i WHERE indeksów w sekwencji źródłowej nie znajdują się w oryginalnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="e72ce-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
- <span data-ttu-id="e72ce-163">Zapytania zawierające kod zip lub SequenceEquals, chyba że jedno ze źródeł danych ma pierwotnie uporządkowany indeks, a inne źródło danych jest indeksem (tj. tablicą lub IList (T)).</span><span class="sxs-lookup"><span data-stu-id="e72ce-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
- <span data-ttu-id="e72ce-164">Zapytania zawierające element concat, chyba że zostanie zastosowany do indeksowanych źródeł danych.</span><span class="sxs-lookup"><span data-stu-id="e72ce-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
- <span data-ttu-id="e72ce-165">Zapytania, które zawierają zwrot, chyba że zostaną zastosowane do źródła danych z indeksem.</span><span class="sxs-lookup"><span data-stu-id="e72ce-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e72ce-166">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="e72ce-166">See also</span></span>

- [<span data-ttu-id="e72ce-167">Równoległe LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="e72ce-167">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
