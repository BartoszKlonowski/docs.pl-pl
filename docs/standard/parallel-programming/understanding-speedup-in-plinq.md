---
title: Ogólne informacje o przyspieszeniach w PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bc36c926ba81de8a59ff3af69719bec6b7370efc
ms.sourcegitcommit: f513a91160b3fec289dd06646d0d6f81f8fcf910
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/18/2018
ms.locfileid: "46008985"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="0eec9-102">Ogólne informacje o przyspieszeniach w PLINQ</span><span class="sxs-lookup"><span data-stu-id="0eec9-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="0eec9-103">Głównym celem PLINQ jest przyspieszenie wykonywania zapytań LINQ do zapytań obiekt, wykonując delegatów zapytania równolegle na komputerach z wielordzeniowymi procesorami.</span><span class="sxs-lookup"><span data-stu-id="0eec9-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="0eec9-104">Program PLINQ sprawdza się najlepiej, gdy przetwarzania każdego elementu w kolekcji źródłowej jest niezależne, bez udostępnionego stanu związane między poszczególnych obiektów delegowanych.</span><span class="sxs-lookup"><span data-stu-id="0eec9-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="0eec9-105">Operacje takie są wspólne w składniku LINQ do obiektów i PLINQ i są często nazywane "*delightfully równoległe*" ponieważ one nadają się łatwo do planowania w wielu wątkach.</span><span class="sxs-lookup"><span data-stu-id="0eec9-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="0eec9-106">Jednak nie wszystkie kwerendy składać się z samych operacji delightfully równoległych; w większości przypadków zapytanie obejmuje niektóre operatory, albo nie może być przeprowadzana równolegle lub który spowolnić wykonywanie równoległe.</span><span class="sxs-lookup"><span data-stu-id="0eec9-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="0eec9-107">A nawet w przypadku zapytań, które są całkowicie delightfully równoległego, PLINQ musi nadal partycji źródła danych harmonogramu pracy nad wątków i zazwyczaj scalać wyniki po wykonaniu kwerendy.</span><span class="sxs-lookup"><span data-stu-id="0eec9-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="0eec9-108">Wszystkie te operacje dodawania obliczeniową koszty przetwarzania równoległego; te koszty, dodawanie funkcji przetwarzania równoległego, są nazywane *obciążenie*.</span><span class="sxs-lookup"><span data-stu-id="0eec9-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="0eec9-109">Aby uzyskać optymalną wydajność w zapytaniu PLINQ, celem jest maksymalne części, które są delightfully równoległe i zminimalizować części, które wymagają narzutu.</span><span class="sxs-lookup"><span data-stu-id="0eec9-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="0eec9-110">Ten artykuł zawiera informacje, dzięki którym można tworzyć zapytania PLINQ, które są najbardziej efektywne podczas nadal reaguje poprawne wyniki.</span><span class="sxs-lookup"><span data-stu-id="0eec9-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="0eec9-111">Czynniki wpływające na wydajność zapytań PLINQ</span><span class="sxs-lookup"><span data-stu-id="0eec9-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="0eec9-112">W poniższych sekcjach wymieniono niektóre z najważniejszych czynników tego obniżenie wydajności zapytania równolegle.</span><span class="sxs-lookup"><span data-stu-id="0eec9-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="0eec9-113">Są to ogólne instrukcje, które same w sobie nie są wystarczające, aby przewidzieć wydajności zapytań we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="0eec9-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="0eec9-114">Jak zawsze jest ważne, aby zmierzyć wydajność rzeczywistego określonych zapytań na komputerach z szerokim zakresem reprezentatywny konfiguracje i obciążeniami.</span><span class="sxs-lookup"><span data-stu-id="0eec9-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="0eec9-115">Obliczeniową koszty ogólne pracy.</span><span class="sxs-lookup"><span data-stu-id="0eec9-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="0eec9-116">Aby osiągnąć przyspieszenie, zapytanie PLINQ musi mieć wystarczającą ilość delightfully równoległą pracę, aby zrównoważyć obciążenie.</span><span class="sxs-lookup"><span data-stu-id="0eec9-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="0eec9-117">Praca może być wyrażona jako obliczeniową koszt każdego delegata pomnożona przez liczbę elementów w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="0eec9-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="0eec9-118">Przy założeniu, że operacji może odbywać się równolegle, tym bardziej praktyce kosztowne jest, tym większa możliwość przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="0eec9-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="0eec9-119">Na przykład jeśli funkcja przyjmuje jeden milisekund do wykonania, sekwencyjne zapytanie ponad 1000 elementów zajmie 1 sekundy do wykonania tej operacji, natomiast równoległego zapytań na komputerze z cztery rdzenie może zająć tylko 250 milisekund.</span><span class="sxs-lookup"><span data-stu-id="0eec9-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="0eec9-120">Daje to przyspieszenie 750 milisekund.</span><span class="sxs-lookup"><span data-stu-id="0eec9-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="0eec9-121">W razie potrzeby jednej sekundy można wykonać dla każdego elementu funkcji przyspieszenie byłoby 750 sekund.</span><span class="sxs-lookup"><span data-stu-id="0eec9-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="0eec9-122">Jeśli delegat jest bardzo kosztowna, PLINQ może oferować znaczące przyspieszenie za pomocą tylko kilku elementów w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="0eec9-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="0eec9-123">Z drugiej strony kolekcje małych źródła z uproszczonych delegatów zazwyczaj nie są dobrymi kandydatami do PLINQ.</span><span class="sxs-lookup"><span data-stu-id="0eec9-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="0eec9-124">W poniższym przykładzie queryA prawdopodobnie jest dobrym kandydatem do PLINQ, zakładając, że jego funkcja wybierz polega na sporego nakładu pracy.</span><span class="sxs-lookup"><span data-stu-id="0eec9-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="0eec9-125">queryB prawdopodobnie nie jest dobrym kandydatem, ponieważ nie jest wystarczająco dużo pracy w instrukcji Select, a obciążenie związane z przetwarzaniem równoległym spowoduje przesunięcie większości lub wszystkich przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="0eec9-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="0eec9-126">Liczba rdzeni logicznych w systemie (stopień równoległości).</span><span class="sxs-lookup"><span data-stu-id="0eec9-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="0eec9-127">Ten punkt jest oczywisty następstwem w poprzedniej sekcji, zapytania, które są delightfully równoległe działają szybciej na komputerach przy użyciu więcej rdzeni, ponieważ można podzielić pracę między większą liczbę jednoczesnych wątków.</span><span class="sxs-lookup"><span data-stu-id="0eec9-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="0eec9-128">Ogólną ilość przyspieszenie zależy od tego, jaki procent ogólnej pracy kwerendy jest równoległego.</span><span class="sxs-lookup"><span data-stu-id="0eec9-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="0eec9-129">Jednak nie należy zakładać, że wszystkie zapytania będą uruchamiane dwa razy szybkiego na komputerze osiem podstawowe jako komputer cztery podstawowe.</span><span class="sxs-lookup"><span data-stu-id="0eec9-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="0eec9-130">Podczas dostosowywania zapytań, aby uzyskać optymalną wydajność, należy do mierzenia rzeczywiste wyniki na komputerach mających różne liczby rdzeni.</span><span class="sxs-lookup"><span data-stu-id="0eec9-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="0eec9-131">Ten punkt jest powiązany z punktu #1: większych zestawów danych są wymagane, aby móc korzystać z większej zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="0eec9-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="0eec9-132">Liczba i rodzaj operacji.</span><span class="sxs-lookup"><span data-stu-id="0eec9-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="0eec9-133">Program PLINQ zawiera AsOrdered operator w sytuacjach, w których jest to konieczne zachować kolejność elementów w sekwencji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="0eec9-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="0eec9-134">Istnieje koszt związany z kolejności, ale ten koszt jest zwykle niewielkie.</span><span class="sxs-lookup"><span data-stu-id="0eec9-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="0eec9-135">Operacje GroupBy i sprzężenia podobnie naliczone obciążenie.</span><span class="sxs-lookup"><span data-stu-id="0eec9-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="0eec9-136">Program PLINQ sprawdza się najlepiej, gdy jest możliwy do przetwarzania elementów w kolekcji źródłowej, w dowolnej kolejności i przekazywać je dalej operatora, jak są one gotowe.</span><span class="sxs-lookup"><span data-stu-id="0eec9-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="0eec9-137">Aby uzyskać więcej informacji, zobacz [zamawianie zachowywania w PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="0eec9-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="0eec9-138">Formularz wykonywania zapytania.</span><span class="sxs-lookup"><span data-stu-id="0eec9-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="0eec9-139">Jeśli wyniki zapytania są przechowywane przez wywołanie metody ToArray lub tolist —, wyniki ze wszystkich wątków równoległych, muszą zostać połączone w strukturze danych jednego.</span><span class="sxs-lookup"><span data-stu-id="0eec9-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="0eec9-140">Obejmuje to da się uniknąć kosztów obliczeniową.</span><span class="sxs-lookup"><span data-stu-id="0eec9-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="0eec9-141">Podobnie jeśli wyniki iteracji za pomocą pętli foreach (dla każdego w języku Visual Basic), wyniki z wątków roboczych muszą być serializowany na wątek modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="0eec9-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="0eec9-142">Ale jeśli chcesz wykonywać niektórych akcji, na podstawie wyniku z każdego wątku, można użyć metody ForAll do wykonywania tej pracy w wielu wątkach.</span><span class="sxs-lookup"><span data-stu-id="0eec9-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="0eec9-143">Typ opcji scalania.</span><span class="sxs-lookup"><span data-stu-id="0eec9-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="0eec9-144">Program PLINQ można skonfigurować do buforowania danych wyjściowych i przedstawić go we fragmentach, lub wszystkie na raz po cały zestaw wyników jest generowany, lub do poszczególnych wyników strumienia jako są produkowane.</span><span class="sxs-lookup"><span data-stu-id="0eec9-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="0eec9-145">Wynik poprzedniego jest obniżenie całkowity czas wykonywania i ostatnie wyniki zmniejszenia opóźnienia między elementami yielded.</span><span class="sxs-lookup"><span data-stu-id="0eec9-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="0eec9-146">Chociaż opcje scalania nie zawsze mają istotny wpływ na ogólną wydajność zapytań, mogą one wpływać na wydajność ponieważ kontrolują jak długo użytkownik musi czekać, aby zobaczyć wyniki.</span><span class="sxs-lookup"><span data-stu-id="0eec9-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="0eec9-147">Aby uzyskać więcej informacji, zobacz [opcje scalania w PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="0eec9-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="0eec9-148">Rodzaj partycji.</span><span class="sxs-lookup"><span data-stu-id="0eec9-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="0eec9-149">W niektórych przypadkach zapytanie PLINQ przez kolekcję można indeksować źródła może spowodować obciążenia pracą niezrównoważone.</span><span class="sxs-lookup"><span data-stu-id="0eec9-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="0eec9-150">W takiej sytuacji można zwiększyć wydajność zapytań, tworząc niestandardowy partycjoner.</span><span class="sxs-lookup"><span data-stu-id="0eec9-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="0eec9-151">Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="0eec9-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="0eec9-152">Gdy wybierze trybu sekwencyjnego w PLINQ</span><span class="sxs-lookup"><span data-stu-id="0eec9-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="0eec9-153">Program PLINQ zawsze będzie podejmował próbę wykonania kwerendy co najmniej tak szybko, jak uruchomić zapytanie sekwencyjnie.</span><span class="sxs-lookup"><span data-stu-id="0eec9-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="0eec9-154">Mimo, że PLINQ nie wygląda jak praktyce są kosztowne delegatów użytkownika lub jak duże źródło danych wejściowych jest, poszukaj niektórych zapytań "kształty".</span><span class="sxs-lookup"><span data-stu-id="0eec9-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="0eec9-155">W szczególności szuka operatorów zapytań lub kombinacji operatorów, które zazwyczaj powodują zapytanie w celu wykonania wolniej w trybie równoległych.</span><span class="sxs-lookup"><span data-stu-id="0eec9-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="0eec9-156">Po znalezieniu takiego kształty, PLINQ domyślnie powraca do trybu sekwencyjnego.</span><span class="sxs-lookup"><span data-stu-id="0eec9-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="0eec9-157">Jednak po mierzenia wydajności określonej kwerendy, można stwierdzić czy on rzeczywiście działa szybciej w trybie równoległych.</span><span class="sxs-lookup"><span data-stu-id="0eec9-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="0eec9-158">W takich przypadkach można użyć <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> Flaga za pośrednictwem <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> metodę, aby nakazać PLINQ do zrównoleglenia zapytania.</span><span class="sxs-lookup"><span data-stu-id="0eec9-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="0eec9-159">Aby uzyskać więcej informacji, zobacz [porady: Określanie trybu wykonywania w PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="0eec9-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="0eec9-160">Na poniższej liście opisano kształty zapytanie PLINQ domyślnie będą wykonywane w trybie sekwencyjnego:</span><span class="sxs-lookup"><span data-stu-id="0eec9-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="0eec9-161">Zapytania, które zawierają Select, Where, indeksowane indeksowanych SelectMany lub klauzuli ElementAt po operatorze sortowania lub filtrowania, który został usunięty lub przestawiać, oryginalnym indeksów.</span><span class="sxs-lookup"><span data-stu-id="0eec9-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="0eec9-162">Zapytania zawierające Pomiń Take, takewhile —, skipwhile — operator i której indeksów w sekwencji źródłowej nie są w kolejności, oryginalnym.</span><span class="sxs-lookup"><span data-stu-id="0eec9-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="0eec9-163">Zapytania, które zawierają Zip lub SequenceEquals, chyba że jest to jedno ze źródeł danych i inne źródła danych jest można indeksować zamówiony indeksu (czyli tablicy lub IList(T)).</span><span class="sxs-lookup"><span data-stu-id="0eec9-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="0eec9-164">Zapytania, które zawierają Concat, chyba że zostanie zastosowany do źródeł danych można indeksować.</span><span class="sxs-lookup"><span data-stu-id="0eec9-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="0eec9-165">Zapytania, które zawierają odwrócić, chyba że stosowane do źródła danych można indeksować.</span><span class="sxs-lookup"><span data-stu-id="0eec9-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0eec9-166">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="0eec9-166">See also</span></span>

- [<span data-ttu-id="0eec9-167">Równoległe LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="0eec9-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
