---
title: Ogólne informacje o przyspieszeniach w PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 2c2e7d5ce170feecaf69aa5dd9785346de0375d2
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="f561b-102">Ogólne informacje o przyspieszeniach w PLINQ</span><span class="sxs-lookup"><span data-stu-id="f561b-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="f561b-103">Głównym celem PLINQ ma przyspieszyć wykonywanie LINQ do obiektów zapytań, wykonując delegatów zapytania równolegle na komputerach z procesorami wielordzeniowymi.</span><span class="sxs-lookup"><span data-stu-id="f561b-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="f561b-104">PLINQ sprawdza się najlepiej, gdy przetwarzania każdego elementu w kolekcji źródłowej jest niezależny, bez udostępnionych stanu związane między poszczególnych obiektów delegowanych.</span><span class="sxs-lookup"><span data-stu-id="f561b-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="f561b-105">Takie operacje są często używane w LINQ do obiektów i PLINQ i są często nazywane "*delightfully równoległe*" ponieważ możliwa jest łatwo planowania na wiele wątków.</span><span class="sxs-lookup"><span data-stu-id="f561b-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="f561b-106">Jednak nie wszystkie zapytania składa się wyłącznie z operacji równoległych delightfully; w większości przypadków zapytania obejmuje niektóre operatory, które albo nie może być zarządzana z przetwarzaniem lub który spowolnić przetwarzania równoległego.</span><span class="sxs-lookup"><span data-stu-id="f561b-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="f561b-107">I nawet w przypadku zapytań, które są całkowicie delightfully równoległe, PLINQ i musi być nadal partycji źródła danych i harmonogramu pracy nad wątki, zwykle scalania wyniki po wykonaniu kwerendy.</span><span class="sxs-lookup"><span data-stu-id="f561b-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="f561b-108">Dodaj te operacje obliczeniową koszty równoległości; Dodawanie paralelizacja koszty są nazywane *koszty*.</span><span class="sxs-lookup"><span data-stu-id="f561b-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="f561b-109">Aby osiągnąć optymalną wydajność w zapytaniu PLINQ, celem jest zmaksymalizować części, które są delightfully równoległe i zminimalizować części, które wymagają obciążenia.</span><span class="sxs-lookup"><span data-stu-id="f561b-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="f561b-110">Ten artykuł zawiera informacje, dzięki którym można pisać zapytania PLINQ, które są najbardziej efektywne podczas nadal reaguje poprawnych wyników.</span><span class="sxs-lookup"><span data-stu-id="f561b-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="f561b-111">Czynniki wpływające na wydajność zapytań PLINQ</span><span class="sxs-lookup"><span data-stu-id="f561b-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="f561b-112">Poniższe sekcje wymieniono najważniejsze czynniki tego wydajność zapytań równoległych wpływ.</span><span class="sxs-lookup"><span data-stu-id="f561b-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="f561b-113">Są to ogólne instrukcje, które same nie są wystarczające do prognozowania wydajność zapytań we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="f561b-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="f561b-114">Jak zawsze należy do mierzenia Rzeczywista wydajność kwerend określonych na komputerach z zakresem reprezentatywny konfiguracji i obciążeń.</span><span class="sxs-lookup"><span data-stu-id="f561b-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="f561b-115">Obliczeniowa koszt ogólną pracy.</span><span class="sxs-lookup"><span data-stu-id="f561b-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="f561b-116">Umożliwia przyspieszenie zapytań PLINQ musi mieć wystarczająco dużo pracy delightfully równoległych do przesunięcia obciążenie.</span><span class="sxs-lookup"><span data-stu-id="f561b-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="f561b-117">Pracy może zostać wyrażona jako obliczeniową koszt każdej delegata pomnożona przez liczbę elementów w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="f561b-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="f561b-118">Przy założeniu, że operacja może być zarządzana z przetwarzaniem, im bardziej praktyce kosztowne jest, tym większa możliwości przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="f561b-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="f561b-119">Na przykład jeśli funkcja przyjmuje jeden milisekund do wykonania, kolejne zapytanie ponad 1000 elementów potrwa jednej sekundy do wykonania tej operacji, natomiast równoległego zapytania na komputerze z czterech rdzeni może potrwać tylko 250 milisekund.</span><span class="sxs-lookup"><span data-stu-id="f561b-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="f561b-120">Daje to przyspieszenie 750 milisekund.</span><span class="sxs-lookup"><span data-stu-id="f561b-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="f561b-121">W razie potrzeby jednej sekundy można wykonać dla każdego elementu funkcji przyspieszenie byłoby 750 sekund.</span><span class="sxs-lookup"><span data-stu-id="f561b-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="f561b-122">Jeśli delegat jest bardzo kosztowna, PLINQ może oferować znaczące przyspieszenie tylko kilka elementów w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="f561b-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="f561b-123">Z drugiej strony kolekcje małych źródła z trivial delegatów zazwyczaj nie są odpowiednimi obiektami do PLINQ.</span><span class="sxs-lookup"><span data-stu-id="f561b-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="f561b-124">W poniższym przykładzie queryA prawdopodobnie są odpowiednimi kandydatami do PLINQ, przy założeniu, że wybierz funkcji obejmuje wiele pracy.</span><span class="sxs-lookup"><span data-stu-id="f561b-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="f561b-125">queryB prawdopodobnie nie jest dobrym wyborem, ponieważ nie jest wystarczająco dużo pracy w instrukcji Select, a obciążenie równoległości zostanie przesunięty większość lub wszystkie przyspieszenie.</span><span class="sxs-lookup"><span data-stu-id="f561b-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="f561b-126">Liczba rdzeni logicznych w systemie (stopień równoległości).</span><span class="sxs-lookup"><span data-stu-id="f561b-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="f561b-127">Ten punkt jest następstwem widocznych w poprzedniej sekcji, zapytania, które są delightfully równoległe szybsze na maszynach z większej liczby rdzeni ponieważ pracy można podzielić między większą liczbę jednoczesnych wątków.</span><span class="sxs-lookup"><span data-stu-id="f561b-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="f561b-128">Ogólną ilość przyspieszenie zależy od tego, jaki procent ogólnej pracy zapytania jest działania równoległego.</span><span class="sxs-lookup"><span data-stu-id="f561b-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="f561b-129">Jednak nie należy zakładać, że wszystkie zapytania zostanie uruchomiony dwukrotnie jako szybkiego na komputerze osiem rdzeni jako komputer cztery podstawowe.</span><span class="sxs-lookup"><span data-stu-id="f561b-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="f561b-130">Dostrajanie zapytania, aby zapewnić optymalną wydajność, koniecznie mierzyć rzeczywiste wyniki na komputerach z różnych liczby rdzeni.</span><span class="sxs-lookup"><span data-stu-id="f561b-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="f561b-131">Ten punkt jest powiązany z punktu #1: większych zestawów danych są wymagane, aby móc korzystać z większej zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="f561b-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="f561b-132">Liczba i rodzaj operacji.</span><span class="sxs-lookup"><span data-stu-id="f561b-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="f561b-133">PLINQ zawiera operator operator AsOrdered w sytuacjach, w których jest wymagane do zachowania kolejności elementów w sekwencji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="f561b-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="f561b-134">Jest koszt związany z kolejności, ale jest to zazwyczaj niewielkie.</span><span class="sxs-lookup"><span data-stu-id="f561b-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="f561b-135">Operacje GroupBy i sprzężenia podobnie nakładu.</span><span class="sxs-lookup"><span data-stu-id="f561b-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="f561b-136">PLINQ sprawdza się najlepiej, gdy jest możliwy do przetwarzania elementów w kolekcji źródłowej w dowolnej kolejności i przekazują je do następnego operatora, jak będą gotowe.</span><span class="sxs-lookup"><span data-stu-id="f561b-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="f561b-137">Aby uzyskać więcej informacji, zobacz [zamawianie zachowywania w PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="f561b-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="f561b-138">Formularz wykonywania zapytania.</span><span class="sxs-lookup"><span data-stu-id="f561b-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="f561b-139">Jeśli wyniki zapytania są przechowywane przez wywołanie metody ToArray lub tolist —, wyniki ze wszystkich równoległych wątków muszą zostać połączone w strukturze danych jednego.</span><span class="sxs-lookup"><span data-stu-id="f561b-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="f561b-140">Obejmuje to nieuniknione koszt obliczeniową.</span><span class="sxs-lookup"><span data-stu-id="f561b-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="f561b-141">Podobnie jeśli wyniki są Iterowanie za pomocą pętli foreach (dla każdej z nich w Visual Basic), wyniki z wątków roboczych konieczne można serializować na wątku modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="f561b-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="f561b-142">Jednak po prostu chcesz wykonanie akcji na podstawie wyniku z każdy wątek, należy użyć metody ForAll — do wykonywania tej pracy w wielu wątkach.</span><span class="sxs-lookup"><span data-stu-id="f561b-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="f561b-143">Typ opcji scalania.</span><span class="sxs-lookup"><span data-stu-id="f561b-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="f561b-144">PLINQ można skonfigurować do albo buforować dane wyjściowe i tworzenia go w fragmentów lub jednorazowo po cały zestaw wyników jest generowany, w przeciwnym razie wyniki poszczególnych strumienia, ponieważ są one tworzone.</span><span class="sxs-lookup"><span data-stu-id="f561b-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="f561b-145">Poprzedni wynik jest zmniejszyć całkowity czas wykonywania i drugie wyniki zmniejszyć opóźnienia między elementami zwróciło.</span><span class="sxs-lookup"><span data-stu-id="f561b-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="f561b-146">Gdy opcji scalania nie zawsze mają istotny wpływ na ogólną wydajność zapytań, ich może wpłynąć na wydajność, ponieważ decydować, jak długo użytkownik musi czekać, aby wyświetlić wyniki.</span><span class="sxs-lookup"><span data-stu-id="f561b-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="f561b-147">Aby uzyskać więcej informacji, zobacz [opcje scalania w PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="f561b-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="f561b-148">Rodzaj partycji.</span><span class="sxs-lookup"><span data-stu-id="f561b-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="f561b-149">W niektórych przypadkach PLINQ zapytanie dotyczące kolekcji można indeksować źródło może skutkować obciążenia pracą równowagi.</span><span class="sxs-lookup"><span data-stu-id="f561b-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="f561b-150">W takim przypadku można zwiększyć wydajność zapytań, tworząc niestandardowe partycjonera.</span><span class="sxs-lookup"><span data-stu-id="f561b-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="f561b-151">Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="f561b-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="f561b-152">Gdy PLINQ wybierze tryb sekwencyjne</span><span class="sxs-lookup"><span data-stu-id="f561b-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="f561b-153">PLINQ zawsze będzie podejmować próby wykonania kwerendy co najmniej tak szybko, jak zapytanie będzie wykonywane sekwencyjnie.</span><span class="sxs-lookup"><span data-stu-id="f561b-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="f561b-154">Mimo że PLINQ nie wygląda jak praktyce są kosztowne delegatów użytkownika lub jak źródło danych wejściowych jest duży, wyszukaj niektórych zapytania "kształtów."</span><span class="sxs-lookup"><span data-stu-id="f561b-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="f561b-155">W szczególności szuka operatorów zapytań lub kombinacje operatorów, które zazwyczaj powodują zapytanie w celu wykonania wolniej w trybie równoległym.</span><span class="sxs-lookup"><span data-stu-id="f561b-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="f561b-156">Po znalezieniu takiego kształtów, PLINQ domyślnie powraca do trybu sekwencyjnych.</span><span class="sxs-lookup"><span data-stu-id="f561b-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="f561b-157">Jednak po pomiaru wydajności określonej kwerendy, należy może określić, że faktycznie działa szybciej w trybie równoległym.</span><span class="sxs-lookup"><span data-stu-id="f561b-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="f561b-158">W takich przypadkach można użyć <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> Flaga za pośrednictwem <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> metody nakazać programowi PLINQ do parallelize zapytania.</span><span class="sxs-lookup"><span data-stu-id="f561b-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="f561b-159">Aby uzyskać więcej informacji, zobacz [porady: Określanie trybu wykonywania w PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="f561b-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="f561b-160">Poniższa lista zawiera opis kształty zapytania PLINQ domyślnie będą wykonywane w trybie sekwencyjnych:</span><span class="sxs-lookup"><span data-stu-id="f561b-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="f561b-161">Zapytania, które zawierają Select, Where, indeksowane indeksowanego operacja SelectMany, lub klauzuli ElementAt po operatorze sortowania i filtrowania, usunąć lub ponownie rozmieszczać oryginalnego indeksów.</span><span class="sxs-lookup"><span data-stu-id="f561b-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="f561b-162">Zapytań zawierających Pomiń podjęcia, TakeWhile, SkipWhile — operator, i gdy indeksy w sekwencji źródłowej nie są w kolejności.</span><span class="sxs-lookup"><span data-stu-id="f561b-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="f561b-163">Zapytania zawierające Zip lub SequenceEquals, chyba że ma jedno ze źródeł danych pierwotnie uporządkowanej indeks i źródło danych jest można indeksować (tj. tablica lub IList(T)).</span><span class="sxs-lookup"><span data-stu-id="f561b-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="f561b-164">Zapytania, które zawierają Concat, chyba że jest ono stosowane do źródeł danych można indeksować.</span><span class="sxs-lookup"><span data-stu-id="f561b-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="f561b-165">Zapytania, które zawierają odwrócić, o ile nie dotyczy źródła danych można indeksować.</span><span class="sxs-lookup"><span data-stu-id="f561b-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f561b-166">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f561b-166">See Also</span></span>  
 [<span data-ttu-id="f561b-167">Równoległe LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="f561b-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
