---
title: Niestandardowe partycjonery dla PLINQ i TPL
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 8caea6d8a97b8c0daf7c59718479ea2e12a52d78
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/30/2019
ms.locfileid: "73141566"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="d4c0b-102">Niestandardowe partycjonery dla PLINQ i TPL</span><span class="sxs-lookup"><span data-stu-id="d4c0b-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="d4c0b-103">Aby zrównoleglanie operację do źródła danych, jednym z najważniejszych kroków jest *partycjonowanie* źródła w wielu sekcjach, do których można uzyskać dostęp jednocześnie przez wiele wątków.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="d4c0b-104">PLINQ i Biblioteka zadań równoległych (TPL) zapewniają domyślne partycje, które działają w sposób przezroczysty podczas pisania kwerendy równoległej lub pętli <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="d4c0b-105">W przypadku bardziej zaawansowanych scenariuszy można podłączyć własną partycję.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="d4c0b-106">Rodzaje partycjonowania</span><span class="sxs-lookup"><span data-stu-id="d4c0b-106">Kinds of Partitioning</span></span>

<span data-ttu-id="d4c0b-107">Istnieje wiele sposobów partycjonowania źródła danych.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="d4c0b-108">W najbardziej wydajnych podejściach wiele wątków współdziała w celu przetworzenia oryginalnej sekwencji źródłowej, a nie fizycznego oddzielenia źródła na wiele podsekwencji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="d4c0b-109">W przypadku tablic i innych indeksowanych źródeł, takich jak kolekcje <xref:System.Collections.IList>, w których długość jest znana z wyprzedzeniem, *partycjonowanie zakresu* jest Najprostszym rodzajem partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="d4c0b-110">Każdy wątek otrzymuje unikatowy indeks początkowy i końcowy, dzięki czemu może przetwarzać swój zakres źródła bez zastępowania lub przesłonięcia przez inny wątek.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="d4c0b-111">Jedyne obciążenie związane z partycjonowaniem zakresu jest początkową pracą tworzenia zakresów; po tym zakończeniu nie jest wymagana żadna dodatkowa synchronizacja.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="d4c0b-112">W związku z tym może zapewnić dobrą wydajność, o ile obciążenie jest podzielone równomiernie.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="d4c0b-113">Wadą partycjonowania zakresu jest to, że jeśli jeden wątek kończy się wczesnie, nie może pomóc innym wątkom zakończyć pracę.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="d4c0b-114">W przypadku list połączonych lub innych kolekcji, których długość nie jest znana, można użyć *partycjonowania fragmentów*.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="d4c0b-115">W przypadku partycjonowania fragmentów każdy wątek lub zadanie w pętli równoległej lub zapytaniu zużywa pewną liczbę elementów źródłowych w jednym fragmencie, przetwarza je, a następnie wraca do pobrania dodatkowych elementów.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="d4c0b-116">Partycja gwarantuje, że wszystkie elementy są dystrybuowane i że nie ma duplikatów.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="d4c0b-117">Fragment może być dowolnym rozmiarem.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-117">A chunk may be any size.</span></span> <span data-ttu-id="d4c0b-118">Na przykład partycja, która jest przedstawiona w [instrukcje: implementowanie partycji dynamicznych](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) tworzy fragmenty, które zawierają tylko jeden element.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="d4c0b-119">Tak długo, jak fragmenty nie są zbyt duże, ten rodzaj partycjonowania jest założenia równoważenia obciążenia, ponieważ przypisanie elementów do wątków nie jest wstępnie ustalone.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="d4c0b-120">Jednak program Partitioner ponosi obciążenie związane z synchronizacją za każdym razem, gdy wątek musi uzyskać kolejny fragment.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="d4c0b-121">Ilość synchronizacji ponoszonych w tych przypadkach jest odwrotnie proporcjonalna do rozmiaru fragmentów.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="d4c0b-122">Ogólnie partycjonowanie zakresu jest szybsze, gdy czas wykonywania delegata jest mały do umiarkowany, a źródło ma dużą liczbę elementów, a całkowita praca każdej partycji jest w przybliżeniu równoważna.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="d4c0b-123">Partycjonowanie fragmentów jest zatem ogólnie szybsze w większości przypadków.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="d4c0b-124">W przypadku źródeł o niewielkiej liczbie elementów lub dłuższym czasie wykonywania dla delegata, wydajność partycjonowania fragmentu i zakresu jest równa.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="d4c0b-125">Partycje TPL obsługują również dynamiczną liczbę partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="d4c0b-126">Oznacza to, że mogą tworzyć partycje na bieżąco, na przykład gdy pętla <xref:System.Threading.Tasks.Parallel.ForEach%2A> duplikuje nowe zadanie.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="d4c0b-127">Ta funkcja umożliwia skalowanie ze sobą przy użyciu samej pętli.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="d4c0b-128">Dynamiczne partycje są również z równoważeniem obciążenia.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="d4c0b-129">Podczas tworzenia niestandardowej partycji należy obsługiwać partycjonowanie dynamiczne, aby można było go używać z pętli <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="d4c0b-130">Konfigurowanie partycji równoważenia obciążenia dla PLINQ</span><span class="sxs-lookup"><span data-stu-id="d4c0b-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="d4c0b-131">Niektóre przeciążenia metody <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> umożliwiają utworzenie partycji dla tablicy lub źródła <xref:System.Collections.IList> i określenie, czy należy podjąć próbę zrównoważenia obciążenia między wątki.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="d4c0b-132">Gdy partycja jest skonfigurowana do równoważenia obciążenia, używane jest partycjonowanie fragmentu, a elementy są przekazywane do każdej partycji w małych fragmentach w miarę ich żądania.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="d4c0b-133">Takie podejście pozwala upewnić się, że wszystkie partycje mają elementy do przetworzenia, dopóki cała pętla lub kwerenda nie zostanie ukończona.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="d4c0b-134">Dodatkowe Przeciążenie można wykorzystać w celu zapewnienia partycjonowania w ramach równoważenia obciążenia dowolnego źródła <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="d4c0b-135">Ogólnie rzecz biorąc, równoważenie obciążenia wymaga, aby partycje często żądały elementów z partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="d4c0b-136">Z kolei partycja, która umożliwia partycjonowanie statycznej, może przypisywać elementy do każdego programu Partitioner wszystkie jednocześnie, używając partycjonowania zakresu lub fragmentu.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="d4c0b-137">Wymaga to mniejszego obciążenia niż Równoważenie obciążenia, ale może trwać dłużej, jeśli jeden wątek zostanie zakończony znacznie większym nakładem pracy niż inne.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="d4c0b-138">Domyślnie, gdy przeszedł element IList lub Array, PLINQ zawsze używa partycjonowania zakresu bez równoważenia obciążenia.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="d4c0b-139">Aby włączyć równoważenie obciążenia dla PLINQ, użyj metody `Partitioner.Create`, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="d4c0b-140">Najlepszym sposobem, aby określić, czy należy używać równoważenia obciążenia w danym scenariuszu, jest eksperymentowanie i pomiar, jak długo trwa wykonywanie operacji w ramach reprezentatywnych obciążeń i konfiguracji komputerów.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="d4c0b-141">Na przykład partycjonowanie statyczne może zapewnić znaczący przyspieszenie na komputerze z wieloma rdzeniami, który ma tylko kilka rdzeni, ale może to spowodować spowolnienie na komputerach mających stosunkowo wiele rdzeni.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="d4c0b-142">Poniższa tabela zawiera listę dostępnych przeciążeń metody <xref:System.Collections.Concurrent.Partitioner.Create%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="d4c0b-143">Te partycje nie są ograniczone do użycia tylko z PLINQ lub <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="d4c0b-144">Mogą być również używane w przypadku dowolnej niestandardowej konstrukcji równoległej.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="d4c0b-145">Występują</span><span class="sxs-lookup"><span data-stu-id="d4c0b-145">Overload</span></span>|<span data-ttu-id="d4c0b-146">Używa równoważenia obciążenia</span><span class="sxs-lookup"><span data-stu-id="d4c0b-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="d4c0b-147">stałego</span><span class="sxs-lookup"><span data-stu-id="d4c0b-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="d4c0b-148">Gdy argument logiczny jest określony jako true</span><span class="sxs-lookup"><span data-stu-id="d4c0b-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="d4c0b-149">Gdy argument logiczny jest określony jako true</span><span class="sxs-lookup"><span data-stu-id="d4c0b-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="d4c0b-150">Ustawione</span><span class="sxs-lookup"><span data-stu-id="d4c0b-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="d4c0b-151">Ustawione</span><span class="sxs-lookup"><span data-stu-id="d4c0b-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="d4c0b-152">Ustawione</span><span class="sxs-lookup"><span data-stu-id="d4c0b-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="d4c0b-153">Ustawione</span><span class="sxs-lookup"><span data-stu-id="d4c0b-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="d4c0b-154">Konfigurowanie partycji zakresów statycznych dla elementu Parallel. ForEach</span><span class="sxs-lookup"><span data-stu-id="d4c0b-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="d4c0b-155">W pętli <xref:System.Threading.Tasks.Parallel.For%2A> treść pętli jest udostępniana metodzie jako delegat.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="d4c0b-156">Koszt wywołania tego delegata jest taki sam jak wywołanie metody wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="d4c0b-157">W niektórych scenariuszach treść pętli równoległej może być wystarczająco mała, że koszt wywołania delegata w każdej iteracji zostanie znaczący.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="d4c0b-158">W takich sytuacjach można użyć jednego z przeciążeń <xref:System.Collections.Concurrent.Partitioner.Create%2A>, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> partycji zakresu względem elementów źródłowych.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="d4c0b-159">Następnie można przekazać tę kolekcję zakresów do metody <xref:System.Threading.Tasks.Parallel.ForEach%2A>, której treść składa się z zwykłej pętli `for`owej.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="d4c0b-160">Zaletą tego podejścia jest to, że koszt wywołania delegata jest naliczany tylko raz dla każdego zakresu, a nie raz na element.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="d4c0b-161">Poniższy przykład demonstruje wzorzec podstawowy.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="d4c0b-162">Każdy wątek w pętli otrzymuje własne <xref:System.Tuple%602>, które zawierają początkową i końcową wartość indeksu w określonym zakresie.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="d4c0b-163">Wewnętrzna pętla `for` używa wartości `fromInclusive` i `toExclusive` do bezpośredniej pętli tablicy lub <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="d4c0b-164">Jeden z przeciążeń <xref:System.Collections.Concurrent.Partitioner.Create%2A> umożliwia określenie rozmiaru partycji i liczby partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="d4c0b-165">Tego przeciążenia można używać w scenariuszach, w których prace na element są tak niskie, że nawet jedno wywołanie metody wirtualnej na element ma zauważalny wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="d4c0b-166">Niestandardowe partycje</span><span class="sxs-lookup"><span data-stu-id="d4c0b-166">Custom Partitioners</span></span>

<span data-ttu-id="d4c0b-167">W niektórych scenariuszach może być wartościowa, a nawet wymagane do zaimplementowania własnego programu Partitioner.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="d4c0b-168">Na przykład może istnieć niestandardowa Klasa kolekcji, która może być bardziej wydajna niż domyślna partycja, na podstawie wiedzy o wewnętrznej strukturze klasy.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="d4c0b-169">Możesz również utworzyć partycje zakresu o różnych rozmiarach na podstawie wiedzy o tym, jak długo będzie przetwarzać elementy w różnych lokalizacjach w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="d4c0b-170">Aby utworzyć podstawową partycję niestandardową, Utwórz klasę z <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> i Zastąp metody wirtualne zgodnie z opisem w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="d4c0b-171">Ta metoda jest wywoływana raz przez wątek główny i zwraca IList (IEnumerator (TSource)).</span><span class="sxs-lookup"><span data-stu-id="d4c0b-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="d4c0b-172">Każdy wątek roboczy w pętli lub zapytaniu może wywoływać `GetEnumerator` na liście, aby pobrać <xref:System.Collections.Generic.IEnumerator%601> na oddzielnej partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="d4c0b-173">Zwróć `true` w przypadku zaimplementowania <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, w przeciwnym razie, `false`.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="d4c0b-174">Jeśli <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> jest `true`, ta metoda może być wywoływana zamiast <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="d4c0b-175">Jeśli wyniki muszą być sortowane lub wymagają dostępu indeksowanego do elementów, utwórz je od <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> i Zastąp metody wirtualne zgodnie z opisem w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="d4c0b-176">Ta metoda jest wywoływana raz przez wątek główny i zwraca `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="d4c0b-177">Każdy wątek roboczy w pętli lub zapytaniu może wywoływać `GetEnumerator` na liście, aby pobrać <xref:System.Collections.Generic.IEnumerator%601> na oddzielnej partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="d4c0b-178">Zwróć `true` w przypadku zaimplementowania <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; w przeciwnym razie false.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="d4c0b-179">Zazwyczaj to właśnie wywołuje <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="d4c0b-180">Jeśli <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> jest `true`, ta metoda może być wywoływana zamiast <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="d4c0b-181">W poniższej tabeli znajdują się dodatkowe szczegółowe informacje o tym, jak trzy rodzaje partycji równoważenia obciążenia implementują klasę <xref:System.Collections.Concurrent.OrderablePartitioner%601>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="d4c0b-182">Metoda/Właściwość</span><span class="sxs-lookup"><span data-stu-id="d4c0b-182">Method/Property</span></span>|<span data-ttu-id="d4c0b-183">Elementy IList/Array bez równoważenia obciążenia</span><span class="sxs-lookup"><span data-stu-id="d4c0b-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="d4c0b-184">Elementy IList/Array z równoważeniem obciążenia</span><span class="sxs-lookup"><span data-stu-id="d4c0b-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="d4c0b-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="d4c0b-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="d4c0b-186">Używa partycjonowania zakresu</span><span class="sxs-lookup"><span data-stu-id="d4c0b-186">Uses range partitioning</span></span>|<span data-ttu-id="d4c0b-187">Używa partycjonowania fragmentów zoptymalizowanego dla list dla partitionCount określonych</span><span class="sxs-lookup"><span data-stu-id="d4c0b-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="d4c0b-188">Używa partycjonowania fragmentów przez utworzenie statycznej liczby partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="d4c0b-189">Zgłasza wyjątek nieobsługiwany</span><span class="sxs-lookup"><span data-stu-id="d4c0b-189">Throws not-supported exception</span></span>|<span data-ttu-id="d4c0b-190">Używa partycjonowania fragmentów zoptymalizowanego pod kątem list i partycji dynamicznych</span><span class="sxs-lookup"><span data-stu-id="d4c0b-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="d4c0b-191">Używa partycjonowania fragmentów przez utworzenie dynamicznej liczby partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="d4c0b-192">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-192">Returns `true`</span></span>|<span data-ttu-id="d4c0b-193">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-193">Returns `true`</span></span>|<span data-ttu-id="d4c0b-194">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="d4c0b-195">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-195">Returns `true`</span></span>|<span data-ttu-id="d4c0b-196">Zwraca `false`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-196">Returns `false`</span></span>|<span data-ttu-id="d4c0b-197">Zwraca `false`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="d4c0b-198">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-198">Returns `true`</span></span>|<span data-ttu-id="d4c0b-199">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-199">Returns `true`</span></span>|<span data-ttu-id="d4c0b-200">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="d4c0b-201">Zwraca `false`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-201">Returns `false`</span></span>|<span data-ttu-id="d4c0b-202">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-202">Returns `true`</span></span>|<span data-ttu-id="d4c0b-203">Zwraca `true`</span><span class="sxs-lookup"><span data-stu-id="d4c0b-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="d4c0b-204">Partycje dynamiczne</span><span class="sxs-lookup"><span data-stu-id="d4c0b-204">Dynamic Partitions</span></span>

<span data-ttu-id="d4c0b-205">Jeśli zamierzasz używać partycji w metodzie <xref:System.Threading.Tasks.Parallel.ForEach%2A>, musisz mieć możliwość zwrócenia dynamicznej liczby partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="d4c0b-206">Oznacza to, że partycja może dostarczyć moduł wyliczający dla nowej partycji na żądanie w dowolnym momencie podczas wykonywania pętli.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="d4c0b-207">W zasadzie Każda pętla dodaje nowe zadanie równoległe, żąda nowej partycji dla tego zadania.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="d4c0b-208">Jeśli wymaga się, aby dane były możliwe do uporządkowania, należy utworzyć je od <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> tak, aby każdy element w każdej partycji miał przypisany unikatowy indeks.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="d4c0b-209">Aby uzyskać więcej informacji, zobacz [temat jak: implementowanie partycji dynamicznych](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="d4c0b-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="d4c0b-210">Kontrakt dla partycji</span><span class="sxs-lookup"><span data-stu-id="d4c0b-210">Contract for Partitioners</span></span>

<span data-ttu-id="d4c0b-211">Podczas implementowania niestandardowego programu Partitioner postępuj zgodnie z poniższymi wskazówkami, aby zapewnić poprawną interakcję z PLINQ i <xref:System.Threading.Tasks.Parallel.ForEach%2A> w TPL:</span><span class="sxs-lookup"><span data-stu-id="d4c0b-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="d4c0b-212">Jeśli <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> jest wywoływana z argumentem równym zero lub mniejszym dla `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="d4c0b-213">Mimo że PLINQ i TPL nigdy nie przekażą do `partitionCount` równej 0, jednak zalecamy ochronę przed możliwością.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="d4c0b-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> i <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> powinny zawsze zwracać `partitionsCount` liczbę partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="d4c0b-215">Jeśli program partitioner nie może utworzyć tylu partycji zgodnie z żądaniem, metoda powinna zwrócić pusty moduł wyliczający dla każdej z pozostałych partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="d4c0b-216">W przeciwnym razie zarówno PLINQ, jak i TPL będą zgłaszać <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="d4c0b-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>i <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> nigdy nie powinny zwracać `null` (`Nothing` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d4c0b-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="d4c0b-218">W takim przypadku PLINQ/TPL zgłosi <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="d4c0b-219">Metody, które zwracają partycje, powinny zawsze zwracać partycje, które mogą w pełni i jednoznacznie wyliczyć źródło danych.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="d4c0b-220">Nie powinno być duplikowane w źródle danych ani elementy pominięte, chyba że jest to wymagane przez projekt partycji.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="d4c0b-221">Jeśli ta reguła nie zostanie zastosowana, kolejność danych wyjściowych może zostać zaszyfrowana.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="d4c0b-222">Następujące metody pobierające dane logiczne muszą zawsze prawidłowo zwracać następujące wartości, aby kolejność wyjściowa nie została zaszyfrowana:</span><span class="sxs-lookup"><span data-stu-id="d4c0b-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="d4c0b-223">`KeysOrderedInEachPartition`: Każda partycja zwraca elementy z rosnącymi indeksami kluczy.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="d4c0b-224">`KeysOrderedAcrossPartitions`: dla wszystkich zwracanych partycji, indeksy kluczy na partycji *i* są wyższe niż indeksy kluczy na partycji *i*-1.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="d4c0b-225">`KeysNormalized`: wszystkie indeksy kluczowych monotonicznie zwiększają się bez przerw, zaczynając od zera.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="d4c0b-226">Wszystkie indeksy muszą być unikatowe.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-226">All indices must be unique.</span></span> <span data-ttu-id="d4c0b-227">Nie można duplikować indeksów.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-227">There may not be duplicate indices.</span></span> <span data-ttu-id="d4c0b-228">Jeśli ta reguła nie zostanie zastosowana, kolejność danych wyjściowych może zostać zaszyfrowana.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="d4c0b-229">Wszystkie indeksy muszą być nieujemne.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-229">All indices must be nonnegative.</span></span> <span data-ttu-id="d4c0b-230">Jeśli ta reguła nie zostanie zastosowana, PLINQ/TPL może zgłosić wyjątki.</span><span class="sxs-lookup"><span data-stu-id="d4c0b-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="d4c0b-231">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="d4c0b-231">See also</span></span>

- [<span data-ttu-id="d4c0b-232">Programowanie równoległe</span><span class="sxs-lookup"><span data-stu-id="d4c0b-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="d4c0b-233">Instrukcje: implementowanie partycji dynamicznych</span><span class="sxs-lookup"><span data-stu-id="d4c0b-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="d4c0b-234">Instrukcje: implementowanie partycjonera dla partycjonowania statycznego</span><span class="sxs-lookup"><span data-stu-id="d4c0b-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
