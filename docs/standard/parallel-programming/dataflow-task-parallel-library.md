---
title: "Przepływ danych (Biblioteka zadań równoległych)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: "22"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 73933c5f171881b5b3a2479aabdb26d1abd58cfc
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2017
---
# <a name="dataflow-task-parallel-library"></a>Przepływ danych (Biblioteka zadań równoległych)
<a name="top"></a>Zadania biblioteki równoległych (TPL) zawiera składniki przepływu danych, aby zwiększyć niezawodność aplikacji z obsługą współbieżności. Te składniki przepływu danych są nazywane zbiorczo *przepływu danych tpl*. Ten model przepływu danych zamienia Programowanie oparte na aktora przez udostępnienie wiadomości w trakcie przekazywania dla coarse-grained przepływu danych i przetwarzanie potokowe zadania. Składniki przepływu danych kompilacji dla typów i planowania infrastruktury TPL i integracja z języka C#, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]i F # Obsługa języka programowania asynchronicznego. Te składniki przepływu danych są przydatne, jeśli masz wiele operacji, które muszą asynchronicznie komunikować się ze sobą, lub gdy użytkownik chce przetwarzać dane po jej udostępnieniu. Rozważmy na przykład aplikacja, która przetwarza dane obrazu z kamery internetowej. Przy użyciu modelu przepływu danych, aplikacja może przetwarzać ramki obrazu staną się one dostępne. Jeśli aplikacja zwiększa ramki obrazu, na przykład, wykonując światła zmniejszenie korektę lub efektu czerwonych utworzeniem *potoku* składników przepływu danych. Każdy etap potoku może używać więcej funkcji coarse-grained równoległości, takich jak funkcje, które są udostępniane przez TPL, aby przekształcić obrazu.  
  
 Ten dokument zawiera omówienie przepływu danych tpl. Opisuje modelu programowania, typy bloku przepływu danych wstępnie zdefiniowane i konfigurowanie bloków przepływu danych w celu spełnienia określonych wymagań aplikacji.  
  
> [!TIP]
>  Biblioteka przepływu danych tpl (<xref:System.Threading.Tasks.Dataflow?displayProperty=nameWithType> przestrzeni nazw) nie jest rozpowszechniana z [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Aby zainstalować <xref:System.Threading.Tasks.Dataflow> przestrzeni nazw, otwórz projekt w [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], wybierz **Zarządzaj pakietami NuGet** z menu projektu i wyszukaj w trybie online `Microsoft.Tpl.Dataflow` pakietu.  
  
 Ten dokument zawiera następujące sekcje:  
  
-   [Model programowania](#model)  
  
-   [Typy wstępnie zdefiniowanych bloku przepływu danych](#predefined_types)  
  
-   [Konfigurowanie zachowania bloku przepływu danych](#behavior)  
  
-   [Niestandardowych bloków przepływu danych](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Model programowania  
 Biblioteka przepływu danych tpl stanowi podstawę do wiadomości, przekazywanie i parallelizing użycie Procesora CPU i/E wykonujących aplikacji, które mają wysokiej przepływności i małe opóźnienia. Również udostępnia możesz jawną kontrolę nad jak dane są buforowane i przenosi wokół systemu. Aby lepiej zrozumieć modelu programowania przepływu danych, należy wziąć pod uwagę aplikacji asynchronicznie ładuje obrazów z dysku i tworzy złożone tych obrazów. Tradycyjne modele programowania zwykle wymagają użycia wywołania zwrotne i synchronizacji obiekty, takie jak blokad, do koordynowania zadań i dostępu do udostępnionych danych. Za pomocą modelu programowania przepływu danych, można utworzyć obiektów przepływu danych, które przetworzył obrazów, ponieważ są one odczytu z dysku. Zgodnie z modelem przepływu danych deklarowaniu sposobu obsługi danych, gdy stanie się dostępny, a także wszelkie zależności między danymi. Ponieważ środowisko uruchomieniowe zarządza zależności między danymi, często można uniknąć konieczności synchronizujący dostęp do danych udostępnionych. Ponadto ponieważ środowisko uruchomieniowe planuje pracy oparte na asynchronicznego odbioru danych, przepływu danych można zwiększyć czas reakcji i przepływności przez efektywne zarządzanie wątki podstawowe. Na przykład, który korzysta z modelu programowania przepływu danych do zaimplementowania przetwarzania obrazu w aplikacji formularzy systemu Windows, temacie [wskazówki: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Źródła i obiekty docelowe  
 Biblioteka przepływu danych tpl składa się z *bloków przepływu danych*, które są danych struktury danych buforu i procesu. TPL definiuje trzy rodzaje bloków przepływu danych: *źródła bloki*, *target bloki*, i *bloki propagator*. Blok źródła działa jako źródło danych i mogą być odczytywane z. Blok docelowy pełni funkcję odbiornika danych i mogą być zapisywane. Blok propagator działa jako bloku źródłowego i docelowego blok i mogą być odczytywane i zapisywane do. Definiuje TPL <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interfejs do reprezentowania źródeł, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> do reprezentowania obiektów docelowych i <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> do reprezentowania propagators. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>dziedziczy z obu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Biblioteka przepływu danych tpl zawiera kilka wstępnie zdefiniowanych przepływu danych typów bloku, które implementują <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, i <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfejsów. Te typy bloku przepływu danych są opisane w tym dokumencie w sekcji [wstępnie zdefiniowanych typów bloku przepływu danych](#predefined_types).  
  
### <a name="connecting-blocks"></a>Łączenie bloków  
 Możesz połączyć bloków przepływu danych do formularza *potoki*, liniowego sekwencji bloków przepływu danych, które są lub *sieci*, wykresy bloków przepływu danych, które są. Potok jest jeden formularz sieci. W potoku lub w sieci źródeł asynchronicznie propagację danych do obiektów docelowych, wraz ze wzrostem dostępności danych. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> Metody łączy bloku przepływu danych źródła blok docelowy. Źródłem może odnosić się do zero lub więcej celów; obiekty docelowe może być połączony z zero lub więcej źródeł. Można dodawać lub usunąć jednocześnie bloków przepływu danych do lub z potoku lub sieci. Bloku przepływu danych wstępnie zdefiniowanych typów obsługują wszystkie aspekty bezpieczeństwo wątków łączenia i odłączanie.  
  
 Na przykład łączącego bloków przepływu danych do utworzenia podstawowego potoku, zobacz [wskazówki: tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Na przykład łączącego bloków przepływu danych do utworzenia bardziej złożonych sieci, zobacz [wskazówki: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Na przykład, który wstrzymuje docelowego źródła po źródło oferuje obiektu docelowego komunikatu, zobacz [porady: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrowanie  
 Podczas wywoływania <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> metodę połączenia źródła dla miejsca docelowego, możesz podać delegata, który określa, czy blok docelowy akceptuje czy odrzuca wiadomości na podstawie wartości tej wiadomości. Ten mechanizm filtrowania jest to wygodny sposób, aby zagwarantować, że blok przepływu danych odbiera tylko niektóre wartości. Większość typów bloku przepływu danych wstępnie zdefiniowane Jeśli bloku źródłowego jest podłączona do wielu bloków docelowej, gdy blok docelowy odrzuca wiadomości, źródło oferuje tej wiadomości do następnego elementu docelowego. Kolejność, w której źródłem oferuje wiadomości do obiektów docelowych jest definiowana za pomocą źródłowego i mogą się różnić zależnie od typu źródłowego. Większość typów bloku źródła Zatrzymaj oferty wiadomość, gdy jeden element docelowy zaakceptuje ten komunikat. Jedynym wyjątkiem od tej reguły jest <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasy, która udostępnia każdy komunikat do wszystkich celów, nawet jeśli niektóre elementy docelowe odrzucić komunikat. Na przykład, który używa filtrowanie do przetwarzania wyłącznie komunikatów, zobacz [wskazówki: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Ponieważ każdy źródła wstępnie zdefiniowanego typu bloku przepływu danych gwarantuje, że komunikaty są przenoszone poza w kolejności, w którym są odbierane, każdej wiadomości musi być odczytywany z bloku źródłowego przed bloku źródłowego może przetwarzać komunikatów dalej. W związku z tym korzystając z filtrowania do nawiązania połączenia ze źródłem wielu elementów docelowych, upewnij się, że tego bloku co najmniej jeden cel odbiera każdy komunikat. W przeciwnym razie aplikacja może zakleszczenie.  
  
### <a name="message-passing"></a>Przekazywanie komunikatów  
 Model programowania przepływu danych jest powiązany z pojęcie *przekazywania komunikatów*, gdzie niezależnych składników programu komunikować się ze sobą przy wysyłaniu wiadomości. Jednym ze sposobów propagację wiadomości między składnikami aplikacji jest wywołać <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> metod do wysyłania komunikatów do post bloków przepływu danych docelowych (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> działa synchronicznie; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> działa asynchronicznie) i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> metod do odbierania wiadomości z bloków źródła. Te metody można połączyć z potoki przepływu danych lub sieci przez wysłanie danych wejściowych z węzłem głównym (blok docelowy) i odbierać dane wyjściowe z terminala węzła potoku lub terminal węzłów sieci (jeden lub więcej bloków źródła). Można również użyć <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> metody do odczytu z pierwszego podanych źródłach danych i wykonania akcji na tych danych.  
  
 Bloki źródła oferowanie danych docelowych bloków przez wywołanie metody <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> metody. Docelowy blok odpowiada na komunikat oferowane w jeden z trzech sposobów: można zaakceptować komunikat, odrzucić komunikat lub odłożyć wiadomości. Gdy element docelowy akceptuje komunikat <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Gdy element docelowy odrzuci komunikat <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Jeśli element docelowy wymaga on nie będzie już otrzymywać żadnych komunikatów ze źródła, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Typy blok wstępnie zdefiniowanych źródła nie oferują wiadomości do połączonych elementów docelowych po odebraniu wartości zwracanej, i automatycznie odłączyć, z takich miejsc docelowych.  
  
 Gdy blok docelowy odłoży komunikat do późniejszego użycia <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Blok docelowy, który odłoży komunikat może nowsze wywołania <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> metodę Zarezerwuj oferowany wiadomości. W tym momencie wiadomość jest nadal dostępny i mogą być używane przez blok docelowy lub wiadomość została podjęta przez inny element docelowy. Blok docelowy później wymaga wiadomości lub nie będzie już potrzebował komunikat, wywołuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> metody odpowiednio. Zastrzeżenia komunikat zwykle jest używana przez typy bloku przepływu danych, które działają w trybie niezachłanne. Tryb intensywnie nie znajduje się w dalszej części tego dokumentu. Zamiast rezerwowania przełożonych wiadomości, można również użyć blok docelowy <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> metody prób bezpośrednio używać przełożonych wiadomości.  
  
### <a name="dataflow-block-completion"></a>Uzupełnianie bloku przepływu danych  
 Bloki przepływu danych obsługuje również pojęcie *zakończenia*. Bloku przepływu danych, która jest w stanie ukończone nie wykonuje żadnych dalszych działań. Każdy blok przepływu danych ma skojarzoną <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> obiektu, znany jako *ukończenia zadania*, reprezentujący stan ukończenia bloku. Ponieważ można czekać na <xref:System.Threading.Tasks.Task> obiekt, aby zakończyć, za pomocą zadań zakończenia możesz poczekać na jeden lub więcej węzłów końcowych przepływu danych sieci, aby zakończyć. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> Interfejs definiuje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metodę, która informuje bloku przepływu danych żądania na jego zakończenie, a <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwość, która zwraca zadań zakończenia bloku przepływu danych. Zarówno <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> dziedziczą <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfejsu.  
  
 Istnieją dwa sposoby ustalić, czy bloku przepływu danych zostało ukończone bez błędów, Napotkano co najmniej jeden błąd lub została anulowana. Pierwszym sposobem jest wywołać <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody na ukończenie zadania w `try` - `catch` bloku (`Try` - `Catch` w języku Visual Basic). Poniższy przykład tworzy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt, który zgłasza <xref:System.ArgumentOutOfRangeException> jeśli jego wartość wejściowa jest mniejsza od zera. <xref:System.AggregateException>jest generowany, gdy w tym przykładzie wywołuje <xref:System.Threading.Tasks.Task.Wait%2A> na ukończenie zadania. <xref:System.ArgumentOutOfRangeException> Jest dostępny za pośrednictwem <xref:System.AggregateException.InnerExceptions%2A> właściwość <xref:System.AggregateException> obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 W tym przykładzie przedstawiono przypadek, w którym wyjątek przechodzi nieobsługiwany w elemencie delegowanym wykonywania bloku przepływu danych. Zaleca się, że obsługa wyjątków w treści takich bloków. Jednak jeśli nie jest możliwe to zrobić, bloku zachowuje się tak, jakby zostało anulowane, a nie przetwarza komunikatów przychodzących.  
  
 Po anulowaniu bloku przepływu danych jawnie, <xref:System.AggregateException> zawiera obiekt <xref:System.OperationCanceledException> w <xref:System.AggregateException.InnerExceptions%2A> właściwości. Aby uzyskać więcej informacji na temat anulowania przepływu danych zobacz Włączanie anulowania w dalszej części tego dokumentu.  
  
 Drugi sposób, aby określić stan ukończenia bloku przepływu danych jest użycia kontynuacji wylogowuje na zakończenie zadania lub możliwości korzystania z funkcji asynchronicznych języka C# i Visual Basic asynchronicznie oczekiwania na ukończenie zadania. Delegata, który osobie <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> ma metodę <xref:System.Threading.Tasks.Task> obiekt, który reprezentuje poprzedzających zadań. W przypadku liczby <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwości, delegat kontynuowania przyjmuje samo zadanie ukończenia. Poniższy przykład przypomina poprzedni, z wyjątkiem tego, że zastosowano <xref:System.Threading.Tasks.Task.ContinueWith%2A> metodę w celu utworzenia ukończenia zadania, które wyświetla stan ogólny operacji przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Można również użyć właściwości takich jak <xref:System.Threading.Tasks.Task.IsCanceled%2A> w treści zadania kontynuacji tak, aby określić dodatkowe informacje dotyczące stanu ukończenia bloku przepływu danych. Aby uzyskać więcej informacji na temat zadań kontynuacji i ich relacji z anulowania oraz obsługi błędów zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md), [wyjątku Obsługa](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md), i [NIB: porady: obsługa wyjątków zgłaszanych przez zadania](http://msdn.microsoft.com/en-us/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[przejdź do góry](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Typy wstępnie zdefiniowanych bloku przepływu danych  
 Biblioteka przepływu danych tpl udostępnia kilka typów bloku przepływu danych wstępnie zdefiniowane. Te typy są podzielone na trzy kategorie: *buforowanie bloki*, *bloki wykonywania*, i *grupowanie bloki*. W poniższych sekcjach opisano typy bloku wchodzące w skład tych kategorii.  
  
### <a name="buffering-blocks"></a>Buforowanie bloków  
 Bloki buforowania przechowywania danych używanych przez konsumentów danych. Biblioteka przepływu danych tpl udostępnia trzy typy bloku buforowanie: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Klasa reprezentuje ogólnego przeznaczenia asynchroniczne struktury obsługi wiadomości. Ta klasa przechowuje pierwszy w pierwszej FIFO kolejki komunikatów, które mogą być zapisywane wiele źródeł lub odczytywane przez wiele obiektów docelowych. Jeśli element docelowy odbiera komunikat z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, że wiadomość zostanie usunięta z kolejki wiadomości. W związku z tym mimo że <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiekt może mieć wielu elementów docelowych, tylko jeden obiekt docelowy będzie otrzymywać każdego komunikatu. <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Klasy jest przydatne, gdy chcesz przekazać wiele komunikatów do innego składnika i składnik ten musi otrzymać każdy komunikat.  
  
 Poniższy przykład podstawowe ogłoszeń kilka <xref:System.Int32> wartości do <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektów i odczytuje wartości z kopii tego obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Pełny przykład przedstawiający sposób pisanie i odbieranie wiadomości z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektów, zobacz [porady: wiadomości do zapisu i odczytu wiadomości z bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Klasy jest przydatne, gdy trzeba przekazać wiele komunikatów do innego składnika, ale ten składnik wymaga tylko najnowsze wartość. Ta klasa jest również przydatne, gdy chcesz wysyłać wiadomości do wielu składników.  
  
 Następujące wpisy prosty przykład <xref:System.Double> do wartości <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektu, a następnie odczytów, które wartość wykonują kopie kilka razy z tym obiektem. Ponieważ wartości nie zostaną usunięte z <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektów po ich wczytywania taką samą wartość jest dostępna zawsze.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Pełny przykład przedstawiający sposób użycia <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> wysyłać wiadomości na wiele bloków docelowej, zobacz [porady: Określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Podobny klasy <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasy, z wyjątkiem <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektu można zapisać tylko raz. Można potraktować <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jako zbliżone do języka C# [tylko do odczytu](~/docs/csharp/language-reference/keywords/readonly.md) ([tylko do odczytu](~/docs/visual-basic/language-reference/modifiers/readonly.md) w [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) — słowo kluczowe, z wyjątkiem <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt staje się niezmienne po otrzymaniu wartość zamiast w konstrukcji. Podobnie jak <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasy, gdy element docelowy otrzyma komunikat z <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt ten komunikat nie zostanie usunięty z tego obiektu. W związku z tym wiele elementów docelowych odbierać kopia wiadomości. <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Klasy jest przydatne, gdy chcesz propagację tylko pierwszy wiele komunikatów.  
  
 Poniższy przykład podstawowe ogłoszeń wielu <xref:System.String> wartości do <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektu, a następnie odczytuje wartość kopii z tego obiektu. Ponieważ <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektu mogą być zapisywane na raz, po <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt odbiera wiadomości, odrzuca kolejnych komunikatów.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Pełny przykład przedstawiający sposób użycia <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> aby otrzymać wartość pierwszej operacji, która kończy, zobacz [porady: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Bloki wykonywania  
 Bloki wykonania wywołania delegata dostarczane przez użytkownika dla każdego z nich odbierane dane. Biblioteka przepływu danych tpl udostępnia trzy typy bloku wykonywania: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Klasa jest blok docelowy, który wywołuje delegata po odebraniu danych. Pomyśl o <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu jako delegata, który jest uruchamiane asynchronicznie, gdy dane będą dostępne. Delegat, który osobie <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt może być typu <xref:System.Action> lub typ `System.Func\<TInput, Task>`. Jeśli używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt z <xref:System.Action>, przetwarzania każdego elementu wejściowego jest uznawane za zakończone po powrocie z obiektem delegowanym. Jeśli używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt z `System.Func\<TInput, Task>`, przetwarzania każdego elementu wejściowego jest uznawany za ukończone tylko wtedy, gdy zwracana <xref:System.Threading.Tasks.Task> obiektu zostało zakończone. Korzystając z tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> dla każdego elementu wejściowego Przetwarzanie synchroniczne i asynchroniczne.  
  
 Poniższy przykład podstawowe ogłoszeń wielu <xref:System.Int32> wartości do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Obiektu wyświetla te wartości do konsoli. W tym przykładzie następnie ustawia bloku stanu ukończenia i czeka na zakończenie wszystkich zadań przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Pełne przykłady, które pokazują, jak używać delegatów o <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> , zobacz [porady: wykonania akcji podczas przepływu danych bloku odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>Element TransformBlock (tWEJŚCIE, tWYJŚCIE)  
 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> Podobny klasy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> klasy, z wyjątkiem, że działa jako zarówno źródłowy, a element docelowy. Delegat, który jest przekazywany do <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu zwraca wartość typu `TOutput`. Delegat, który osobie <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt może być typu `System.Func<TInput, TOutput>` lub typ `System.Func<TInput, Task>`. Jeśli używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt z `System.Func\<TInput, TOutput>`, przetwarzania każdego elementu wejściowego jest uznawane za zakończone po powrocie z obiektem delegowanym. Jeśli używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt użyty z `System.Func<TInput, Task<TOutput>>`, przetwarzania każdego elementu wejściowego jest uznawany za ukończone tylko wtedy, gdy zwracana <xref:System.Threading.Tasks.Task> obiektu zostało zakończone. Jak <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, korzystając z tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> dla każdego elementu wejściowego Przetwarzanie synchroniczne i asynchroniczne.  
  
 Poniższy przykład podstawowe tworzy <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt, który oblicza pierwiastek kwadratowy jej danych wejściowych. <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> Obiekt ma <xref:System.Int32> wartości jako dane wejściowe i tworzy <xref:System.Double> wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Pełną przykłady, których używa <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> w sieci bloków przepływu danych, która przetwarza obrazu w aplikacji formularzy systemu Windows, temacie [wskazówki: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock (tWEJŚCIE, tWYJŚCIE)  
 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> Podobny klasy <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> klasy, z wyjątkiem <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> daje zero lub więcej wartości danych wyjściowych dla każdego wartość wejściowa jest, a nie tylko jeden wyjściowy wartość dla każdej wartości wejściowej. Delegat, który osobie <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt może być typu `System.Func<TInput, IEnumerable<TOutput>>` lub `type System.Func<TInput, Task<IEnumerable<TOutput>>>`. Jeśli używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt z `System.Func<TInput, IEnumerable<TOutput>>`, przetwarzania każdego elementu wejściowego jest uznawane za zakończone po powrocie z obiektem delegowanym. Jeśli używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt z `System.Func<TInput, Task<IEnumerable<TOutput>>>`, przetwarzania każdego elementu wejściowego jest uznawany za pełną tylko wtedy, gdy zwracana `System.Threading.Tasks.Task<IEnumerable<TOutput>>` obiektu zostało zakończone.  
  
 Poniższy przykład podstawowe tworzy <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt, który dzieli ciągów na ich sekwencje znaków indywidualnych. <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> Obiekt ma <xref:System.String> wartości jako dane wejściowe i tworzy <xref:System.Char> wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Pełne przykłady, które używają <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> można tworzyć wiele niezależnych dane wyjściowe dla każdego danych wejściowych w potoku przepływu danych, zobacz [wskazówki: tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Stopień równoległości  
 Każdy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektu buforów danych wejściowych wiadomości do momentu bloku jest gotowa do ich przetworzenia. Domyślnie te klasy przetwarzania komunikatów w kolejności, w którym są odbierane, jeden komunikat naraz. Można również określić stopień równoległości, aby włączyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekty jednocześnie przetwarzać wiele komunikatów. Aby uzyskać więcej informacji o wykonanie współbieżne zobacz sekcję Określanie stopnia równoległości w dalszej części tego dokumentu. Na przykład, który ustawia maksymalny stopień równoległości, aby umożliwić wykonanie bloku przepływu danych do jednoczesnego przetwarzania więcej niż jeden komunikat, zobacz [porady: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Podsumowanie typów delegatów  
 Poniższa tabela zawiera podsumowanie typów delegata, które można udostępniać użytkownikom <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów. Ta tabela określa również, czy typ delegata działa synchronicznie lub asynchronicznie.  
  
|Typ|Typ delegata synchroniczne|Typ delegata asynchroniczne|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Można również użycie wyrażeń lambda, podczas pracy z typami bloku wykonywania. Na przykład pokazujący sposób wyrażenia lambda za pomocą bloku wykonywania zobacz [porady: wykonania akcji podczas przepływu danych bloku odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Grupowanie bloków  
 Bloki grupowania połączyć dane z jednego lub więcej źródeł i w różne ograniczenia. Biblioteka przepływu danych tpl udostępnia trzy typy bloku sprzężenia: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Klasy łączy zestawy danych wejściowych, które są nazywane partie, do tablic danych wyjściowych. Określ rozmiar każdej z partii, podczas tworzenia <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu. Gdy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt odbiera określonej liczby elementów wejściowych, asynchronicznie propaguje on limit tablicę, która zawiera te elementy. Jeśli <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu ma ustawioną wartość stanu ukończenia, ale nie zawiera za mało elementów do tworzenia partii, rozprzestrzenia się poza końcowym tablica, która zawiera wszystkie pozostałe elementy wejściowe.  
  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Klasa działa w jednym *zachłanne* lub *niezachłanne* tryb. W trybie intensywnie, który jest domyślnym, <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> akceptuje każdy komunikat jest oferowany i propaguje limit tablicy po otrzymaniu określonej liczby elementów. W trybie niezachłanne <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu odłoży wszystkie wiadomości przychodzących, dopóki za mało źródeł ma oferowana wiadomości do bloku do tworzenia partii. Tryb intensywnie przeważnie wykonuje lepiej niż tryb niezachłanne ponieważ wymaga mniej przetwarzania. Jednak użyciem niezachłanne trybu zużycia z wielu źródeł w sposób atomic musi być dostosowana. Określ tryb niezachłanne przez ustawienie <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> do `False` w `dataflowBlockOptions` parametru w <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> konstruktora.  
  
 Poniższy przykład podstawowe ogłoszeń kilka <xref:System.Int32> wartości do <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu, który zawiera 10 elementów w partii. Aby zagwarantować, że wszystkie wartości propagację z <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, w tym przykładzie wywołuje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metody. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> Zestawów — metoda <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu do stanu ukończenia i w związku z tym <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu propaguje limit wszelkie pozostałe elementy jako ostatecznego partii.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> w celu poprawy wydajności bazy danych operacji insert, zobacz [wskazówki: przy użyciu BatchBlock i BatchedJoinBlock, aby poprawić wydajność](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>Klasy JoinBlock (T1, T2,...)  
 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> klasy Zbieranie elementów wejściowych i Propaguj limit <xref:System.Tuple%602?displayProperty=nameWithType> lub <xref:System.Tuple%603?displayProperty=nameWithType> obiektów, które zawierają te elementy. <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> klasy dziedziczy <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Zamiast tego zawierają właściwości, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Podobnie jak <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> działają w trybie zachłanne lub niezachłanne. W trybie intensywnie, który jest domyślnym, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> akceptuje każdy komunikat jest oferowany i propaguje limit krotka po otrzymaniu każdego z jego elementów docelowych co najmniej jeden komunikat. W trybie niezachłanne <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiektu odłoży wszystkie wiadomości przychodzących, dopóki wszystkie elementy docelowe oferowane dane, które jest wymagane do utworzenia spójnych kolekcji. W tym momencie bloku uczestniczy w dwufazowego protokołu wykonania automatycznie pobrać wszystkie wymagane elementy ze źródeł. Tego opóźnienia umożliwia innego podmiotu zużywanie dane w tym samym czasie, aby zezwolić całego systemu postęp.  
  
 W poniższym przykładzie podstawowe pokazano przypadek, w którym <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt wymaga wielu danych do obliczenia wartości. Ten przykład tworzy <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt, który wymaga dwóch <xref:System.Int32> wartości i <xref:System.Char> wartość do wykonywania operacji arytmetycznej.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiektów w trybie niezachłanne wspólnie udostępnianie zasobów, zobacz [porady: klasy JoinBlock używany do odczytu danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock (T1, T2,...)  
 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> klasy zbieranie partie elementów wejściowych i Propaguj limit `System.Tuple(IList(T1), IList(T2))` lub `System.Tuple(IList(T1), IList(T2), IList(T3))` obiektów, które zawierają te elementy. Pomyśl o <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> jako połączenie <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Określ rozmiar każdej z partii, podczas tworzenia <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>Udostępnia właściwości, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Po odebraniu od określonej liczby elementów wejściowych przez wszystkie elementy docelowe, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu asynchronicznie rozprzestrzenia się `System.Tuple(IList(T1), IList(T2))` obiekt, który zawiera te elementy.  
  
 Poniższy przykład podstawowe tworzy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiekt przechowujący wyników, <xref:System.Int32> wartości i błędy, które są <xref:System.Exception> obiektów. W tym przykładzie wykonuje wiele operacji i zapisuje wyniki do <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> właściwości oraz błędy, aby <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> właściwości, z <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. Ponieważ liczba udane i nieudane operacje jest nieznany z wyprzedzeniem <xref:System.Collections.Generic.IList%601> obiektów Włącz każdego obiektu docelowego do odbierania zero lub więcej wartości.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> do przechwytywania zarówno wyniki oraz wszystkie wyjątki, które są wykonywane, gdy program odczytuje z bazy danych, zobacz [wskazówki: przy użyciu BatchBlock i BatchedJoinBlock, aby poprawić wydajność](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
 [[przejdź do góry](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Konfigurowanie zachowania bloku przepływu danych  
 Dodatkowe opcje można włączyć, podając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> obiekt do konstruktora typu bloku przepływu danych. Te opcje umożliwiają kontrolowanie zachowania takiego harmonogramu, która zarządza podstawowych zadań i stopień równoległości. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> Również ma pochodnych typów, które określają zachowanie, które są specyficzne dla określonych typów bloku przepływu danych. W poniższej tabeli przedstawiono opcje typu jest skojarzony z każdego typu bloku przepływu danych.  
  
|Typ bloku przepływu danych|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>Typ|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Poniższe sekcje zawierają dodatkowe informacje o ważnych rodzaje przepływu danych opcje bloku, które są dostępne za pośrednictwem <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> klasy.  
  
### <a name="specifying-the-task-scheduler"></a>Określanie harmonogramu zadań  
 Każdy blok przepływu danych wstępnie zdefiniowanych używa TPL zadania planowania mechanizm do wykonywania działań takich jak rozmnożeniowy dane do obiektu docelowego, odbieranie danych z źródła i systemem delegatów zdefiniowane przez użytkownika, gdy są dostępne. <xref:System.Threading.Tasks.TaskScheduler>jest klasą abstrakcyjną, która reprezentuje harmonogramu zadań zadań kolejki na wątki. Domyślny harmonogram zadań, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, używa <xref:System.Threading.ThreadPool> klasy do kolejki i do pracy. Można zastąpić domyślny harmonogram zadań, ustawiając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Podczas tego samego harmonogram zadań zarządza wiele bloków przepływu danych, można wymusić zasad, między nimi. Na przykład, jeśli wiele bloków przepływu danych poszczególnych skonfigurowano pod kątem wyłącznego harmonogram tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektów, wszystkie pracy, że działa przez te bloki jest serializowany. Podobnie jeśli te bloki są skonfigurowane pod kątem harmonogram współbieżne tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektu i że harmonogramu jest skonfigurowany do współbieżności maksymalny poziom, pracy z te bloki jest ograniczona do tej liczby jednoczesnych operacji. Na przykład, który używa <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> klasy, aby umożliwić operacje odczytu są wykonywane równolegle, ale zapisu wystąpić wyłącznie wszystkich innych działań, zobacz [porady: Określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Aby uzyskać więcej informacji na temat planiści zadań w TPL, zobacz <xref:System.Threading.Tasks.TaskScheduler> klasy tematu.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Określanie stopnia równoległości  
 Domyślnie typy bloku wykonania trzech, które udostępnia przepływu danych tpl, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, jednoczesnego przetwarzania jeden komunikat. Te typy bloku przepływu danych także przetwarzać komunikatów w kolejności, w którym są odbierane. Aby włączyć te bloki przepływu danych przetwarzanych wiadomości jednocześnie, ustaw <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Wartość domyślna <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> wynosi 1, co gwarantuje, że bloku przepływu danych przetwarza jeden komunikat naraz. Ustawienie tej właściwości na wartość, która jest większa niż 1 umożliwia bloku przepływu danych jednocześnie przetwarzać wiele komunikatów. Ustawienie tej właściwości na <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> umożliwia dla podstawowego harmonogramu zadań zarządzania maksymalny stopień współbieżności.  
  
> [!IMPORTANT]
>  Po określeniu maksymalny stopień równoległości, który jest większy niż 1, wiele komunikatów przetwarzanych jednocześnie i w związku z tym wiadomości nie mogą być przetwarzane w kolejności, w którym są odbierane. Kolejność, w którym komunikaty są jednak dane wyjściowe będą bloku, prawidłowo uporządkowane.  
  
 Ponieważ <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwość reprezentuje maksymalny stopień równoległości, bloku przepływu danych może być wykonywane za pomocą niższy stopień równoległości nie określisz. W bloku przepływu danych może używać niższy stopień równoległości do swoich wymagań funkcjonalności lub brakiem dostępnych zasobów systemowych. Blok przepływu danych nigdy nie wybierze równoległości więcej niż w przypadku określenia.  
  
 Wartość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwość jest wyłącznie dla każdego obiektu bloku przepływu danych. Na przykład jeśli czterech przepływu danych bloku obiektów każdego określić 1 dla maksymalny stopień równoległości, wszystkie cztery obiekty bloku przepływu danych może potencjalnie równolegle.  
  
 Na przykład, który ustawia maksymalny stopień równoległości, aby włączyć długich operacje są wykonywane równolegle, zobacz [porady: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Określanie liczby komunikatów poszczególnych zadań  
 Typy bloku przepływu danych wstępnie zdefiniowanych użycie zadań w celu przetworzenia wielu elementów wejściowych. Minimalizuje to liczba obiektów zadań, które są wymagane do przetwarzania danych, który umożliwia aplikacjom bardziej efektywną pracę. Jednak podczas przetwarzania danych zadań z jednego zestawu bloków przepływu danych, zadania z innych bloków przepływu danych może być konieczne poczekanie czas przetwarzania usługi kolejkowania wiadomości. Aby włączyć lepsze sprawiedliwe przydzielanie zasobów między zadania przepływu danych, ustaw <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwości. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> ustawiono <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>zadań używane przez bloku przepływu danych przetwarza dowolną liczbę wiadomości, ponieważ nie jest dostępna, co jest ustawieniem domyślnym. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> ma ustawioną wartość innych niż <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, bloku przepływu danych co najwyżej procesów to liczba komunikatów na <xref:System.Threading.Tasks.Task> obiektu. Mimo że ustawienie <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwości zwiększyć sprawiedliwe przydzielanie zasobów spośród zadań, system można utworzyć zadania więcej niż jest to konieczne, może spowodować, która może obniżyć wydajność.  
  
### <a name="enabling-cancellation"></a>Włączanie anulowania  
 TPL udostępnia mechanizm umożliwiający zadań do koordynowania anulowania w sposób współpracy. Aby włączyć bloków przepływu danych do udziału w ten mechanizm anulowania, ustaw <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> właściwości. Gdy to <xref:System.Threading.CancellationToken> obiektu ma ustawioną wartość stanu anulowane, wszystkie bloki przepływu danych, które monitorują ten token zakończenia wykonywania ich bieżącego elementu, ale nie uruchamiaj przetwarzania kolejnych elementów. Te bloki przepływu danych, również wyczyść buforowane żadnego wiadomości, wersji połączenia z żadnym źródłowego i docelowego bloków i przejście do stanu Anulowano. Przez przejście do stanu Anulowano <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> ma właściwość <xref:System.Threading.Tasks.Task.Status%2A> ustawioną właściwość <xref:System.Threading.Tasks.TaskStatus.Canceled>, o ile nie wystąpił wyjątek podczas przetwarzania. W takim przypadku <xref:System.Threading.Tasks.Task.Status%2A> ma ustawioną wartość <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Na przykład, który demonstruje sposób używania anulowania w aplikacji formularzy systemu Windows, temacie [porady: anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Aby uzyskać więcej informacji o anulowanie w TPL, zobacz [anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Określanie intensywnie i zachowanie Niezachłanne  
 Kilka typów bloku przepływu danych grupowania może działać w jednym *zachłanne* lub *niezachłanne* tryb. Domyślnie typy bloku przepływu danych wstępnie zdefiniowanych działają w trybie zachłanne.  
  
 W celu utworzenia sprzężenia zablokować typy takich jak <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, tryb intensywnie oznacza, że blok natychmiast akceptuje dane, nawet jeśli odpowiednich danych, z którą chcesz przyłączyć nie jest jeszcze dostępna. Zachłanne innym niż tryb oznacza bloku odłoży wszystkie wiadomości przychodzących, dopóki nie jest dostępny na wszystkich jego cele do wykonania sprzężenia. Jeśli dowolny z komunikatów przełożonych nie będą już dostępne, blok sprzężenia zwalnia wszystkich przełożonych wiadomości i ponownego uruchomienia procesu. Dla <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> klasy zachłanne i niezachłanne zachowanie jest podobne, z wyjątkiem w trybie niezachłanne <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu odłoży wszystkie wiadomości przychodzących, dopóki nie ma wystarczającej ilości są dostępne z różnych źródeł do ukończenia partii.  
  
 Aby określić tryb niezachłanne bloku przepływu danych, ustaw <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> do `False`. Na przykład, który demonstruje sposób w trybie niezachłanne włączyć wiele bloków sprzężenia wydajniej udostępnianie źródła danych, zobacz [porady: Użyj klasy JoinBlock do odczytu danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[przejdź do góry](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Niestandardowych bloków przepływu danych  
 Biblioteka przepływu danych tpl zapewnia wiele typów blok wstępnie zdefiniowane, jednak można utworzyć bloku dodatkowe typy, które powoduje wykonanie akcji niestandardowych. Implementowanie <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> lub <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsy bezpośrednio lub za pomocą <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> metoda tworzenia złożonych bloku, który hermetyzuje zachowanie istniejących typów bloku. Aby uzyskać przykłady, które przedstawiają sposób implementowania bloku przepływu danych niestandardowych, zobacz [wskazówki: Tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[przejdź do góry](#top)]  
  
## <a name="related-topics"></a>Tematy pokrewne  
  
|Tytuł|Opis|  
|-----------|-----------------|  
|[Porady: pisanie i odbieranie wiadomości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Pokazuje, jak pisanie i odbieranie wiadomości z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu.|  
|[Porady: Implementowanie wzorca przepływu danych producent — konsument](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Opisuje sposób umożliwia Implementowanie wzorca producent — konsument, gdzie producenta wysyła komunikaty do bloku przepływu danych, a klient odczytuje wiadomości z tego bloku przepływu danych modelu.|  
|[Porady: akcję wykonać po bloku przepływu danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Opisuje sposób zapewnienia delegatów do wykonywania typów bloku przepływu danych, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Wskazówki: Tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Opisuje sposób tworzenia potoku przepływu danych, które pobiera tekst z sieci web i wykonuje operacje na tekst.|  
|[Porady: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Pokazuje, jak używać <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> metodę, aby odłączyć od źródła bloku docelowego po źródło oferuje komunikatów do obiektu docelowego.|  
|[Wskazówki: Korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Pokazuje, jak utworzyć sieć bloków przepływu danych, które wykonują przetwarzania obrazu w aplikacji formularzy systemu Windows.|  
|[Porady: anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Pokazuje, jak używać anulowania w aplikacji formularzy systemu Windows.|  
|[Porady: Korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Wyjaśniono, jak używać <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> klasę, aby wykonać operację, gdy dane są dostępne z wielu źródeł i sposobu użycia trybu niezachłanne umożliwiające wiele bloków sprzężenia wydajniej udostępnianie źródła danych.|  
|[Porady: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Opisuje sposób ustawiania <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwości, aby umożliwić wykonanie bloku przepływu danych do jednoczesnego przetwarzania więcej niż jeden komunikat.|  
|[Porady: Określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Pokazuje, jak skojarzyć harmonogramu zadań określone przy użyciu przepływu danych w aplikacji.|  
|[Wskazówki: Używanie klas BatchBlock i BatchedJoinBlock do poprawy wydajności](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Informacje dotyczące używania <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Wstaw klasę, aby zwiększyć wydajność bazy danych operacji i sposobu użycia <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> klasa do przechwytywania zarówno wyniki oraz wszystkie wyjątki, które są wykonywane, gdy program odczytuje z bazy danych.|  
|[Wskazówki: Tworzenie typu bloku przepływu danych niestandardowych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Przedstawia dwa sposoby tworzenia typu bloku przepływu danych, który implementuje zachowanie niestandardowych.|  
|[Biblioteka zadań równoległych (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Wprowadza TPL, upraszczającym Programowanie równoległe lub jednocześnie w bibliotece [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] aplikacji.|
