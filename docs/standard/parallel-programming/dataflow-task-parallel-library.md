---
title: Przepływ danych (Biblioteka zadań równoległych)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 8fc88b06ee1e206208e6d6950f640966f53df3a1
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/22/2019
ms.locfileid: "69924915"
---
# <a name="dataflow-task-parallel-library"></a>Przepływ danych (Biblioteka zadań równoległych)
<a name="top"></a>Biblioteka zadań równoległych (TPL) zawiera składniki przepływu danych, które ułatwiają zwiększenie niezawodności aplikacji korzystających z współbieżności. Te składniki przepływu danych są zbiorczo określane jako *Biblioteka TPL przepływu danych*. Ten model przepływu danych wspiera Programowanie oparte na aktorze, zapewniając w procesie przekazywanie komunikatów w celu uzyskania bardziej szczegółowych zadań przepływu danych i potokowych. Składniki przepływu danych są oparte na typach i planowaniu infrastruktury TPL i integrują się z obsługą C#, Visual Basic i F# językiem w programowaniu asynchronicznym. Te składniki przepływu danych są przydatne, gdy istnieje wiele operacji, które muszą komunikować się ze sobą asynchronicznie, lub gdy chcesz przetwarzać dane, gdy staną się dostępne. Rozważmy na przykład aplikację, która przetwarza dane obrazu z kamery sieci Web. Korzystając z modelu przepływu danych, aplikacja może przetwarzać ramki obrazu w miarę ich udostępniania. Jeśli aplikacja rozszerza ramki obrazu, na przykład przez wykonanie korekcji światła lub zmniejszenie oka, można utworzyć *potok* składników przepływu danych. Każdy etap potoku może korzystać z bardziej precyzyjnych funkcji równoległych, takich jak funkcje dostarczone przez TPL, aby przekształcić obraz.  
  
 Ten dokument zawiera omówienie biblioteki przepływu danych TPL. Opisano w nim model programowania, wstępnie zdefiniowane typy bloków przepływu danych oraz sposób konfigurowania bloków przepływu danych w celu spełnienia określonych wymagań aplikacji.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]
  
 Ten dokument zawiera następujące sekcje:  
  
- [Model programowania](#model)  
  
- [Wstępnie zdefiniowane typy bloków przepływu danych](#predefined_types)  
  
- [Konfigurowanie zachowania blokowania przepływu danych](#behavior)  
  
- [Niestandardowe bloki przepływu danych](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Model programowania  
 Biblioteka TPL przepływu danych stanowi podstawę przekazywania komunikatów i przekształcają intensywnie korzystających z procesora CPU aplikacji intensywnie wykorzystujących procesor i/wy, które mają wysoką przepływność i małe opóźnienia. Zapewnia również jawną kontrolę nad sposobem buforowania danych i poruszaniem się w systemie. Aby lepiej zrozumieć model programowania przepływu danych, weź pod uwagę aplikację, która asynchronicznie ładuje obrazy z dysku i tworzy złożone obrazy. Tradycyjne modele programistyczne zwykle wymagają używania wywołań zwrotnych i obiektów synchronizacji, takich jak blokady, do koordynowania zadań i uzyskiwania dostępu do udostępnionych danych. Za pomocą modelu programowania przepływu danych można tworzyć obiekty przepływu danych, które przetwarzają obrazy w miarę ich odczytu z dysku. W modelu przepływu danych deklaruje, jak dane są obsługiwane, gdy staną się dostępne, a także wszelkie zależności między danymi. Ponieważ środowisko uruchomieniowe zarządza zależnościami między danymi, często można uniknąć konieczności synchronizacji dostępu do udostępnionych danych. Ponadto, ponieważ harmonogramy środowiska uruchomieniowego są wykonywane na podstawie asynchronicznego przybycia danych, przepływu danych może zwiększyć czas reakcji i przepływność przez wydajne zarządzanie wątkami bazowymi. Aby zapoznać się z przykładem wykorzystującym model programowania przepływu danych do implementowania przetwarzania obrazów w aplikacji Windows Forms [, zobacz Przewodnik: Korzystanie z przepływu danych w aplikacji](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)Windows Forms.  
  
### <a name="sources-and-targets"></a>Źródła i obiekty docelowe  
 Biblioteka TPL przepływu danych składa się z *bloków przepływu danych*, które są strukturami danych, które buforują i przetwarzają dane. TPL definiuje trzy rodzaje bloków przepływu danych: *bloków źródłowych*, *bloków docelowych*i *bloków propagacji*. Blok źródłowy działa jako źródło danych i może zostać odczytany. Blok docelowy działa jako odbiorca danych i może być zapisany w. Blok propagator działa zarówno jako blok źródłowy, jak i blok docelowy i może być odczytywany i zapisywana. TPL definiuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interfejs do reprezentowania źródeł, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> reprezentujący obiekty docelowe i <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> reprezentujący propagator. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>dziedziczy z obu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>i. <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>  
  
 Biblioteka TPL przepływu danych zawiera kilka wstępnie zdefiniowanych typów bloków przepływu danych, które <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>interfejsy, <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> i. Te typy bloków przepływu danych zostały opisane w tym dokumencie w sekcji [wstępnie zdefiniowane typy bloków przepływu danych](#predefined_types).  
  
### <a name="connecting-blocks"></a>Łączenie bloków  
 Bloki przepływu danych można połączyć z potokami, które są sekwencjami liniowymi bloków przepływu danych lub *sieci*, które są wykresami bloków przepływu danych. Potok jest jedną z form sieci. W potoku lub sieci źródła asynchronicznie propagują dane do obiektów docelowych, ponieważ te dane staną się dostępne. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> Metoda łączy źródłowy blok przepływu danych z blokiem docelowym. Źródło może być połączone z zero lub więcej obiektami docelowymi; elementy docelowe mogą być połączone z zera lub więcej źródeł. Możesz dodawać lub usuwać bloki przepływu danych do lub z potoku lub sieci jednocześnie. Wstępnie zdefiniowane typy bloku przepływu danych obsługują wszystkie aspekty bezpiecznego wątku łączące i odłączania.  
  
 Aby uzyskać przykład, który łączy bloki przepływu danych w celu utworzenia potoku podstawowego [, zobacz Przewodnik: Tworzenie potoku](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)przepływu danych. Aby uzyskać przykład, który łączy bloki przepływu danych w celu utworzenia bardziej złożonej sieci, [zobacz Przewodnik: Korzystanie z przepływu danych w aplikacji](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)Windows Forms. Aby uzyskać przykład, który odłącza obiekt docelowy od źródła, gdy źródło zawiera docelowy komunikat, zobacz [How to: Odłącz bloki](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)przepływu danych.  
  
#### <a name="filtering"></a>Filtrowanie  
 Po wywołaniu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> metody w celu połączenia źródła z obiektem docelowym można dostarczyć delegata, który określa, czy blok docelowy akceptuje lub odrzuca komunikat na podstawie wartości tego komunikatu. Mechanizm filtrowania jest użytecznym sposobem zagwarantowania, że blok przepływu danych odbiera tylko niektóre wartości. W przypadku większości wstępnie zdefiniowanych typów bloków przepływu danych, jeśli blok źródłowy jest połączony z wieloma blokami docelowymi, gdy blok docelowy odrzuci komunikat, Źródło oferuje ten komunikat do następnego celu. Kolejność, w której źródło oferuje komunikaty do obiektów docelowych, jest definiowana przez źródło i może się różnić w zależności od typu źródła. Większość typów bloków źródłowych przerywa oferowanie komunikatu po zaakceptowaniu tego komunikatu przez jeden obiekt docelowy. Jedynym wyjątkiem od <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> tej reguły jest Klasa, która oferuje każdy komunikat do wszystkich obiektów docelowych, nawet jeśli niektóre obiekty docelowe odrzucają komunikat. Aby zapoznać się z przykładem, który używa filtrowania do przetwarzania tylko [niektórych komunikatów, zobacz Przewodnik: Korzystanie z przepływu danych w aplikacji](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)Windows Forms.  
  
> [!IMPORTANT]
> Ponieważ każdy wstępnie zdefiniowany typ bloku Source przepływu danych gwarantuje, że komunikaty są rozmnożone w kolejności, w której są odbierane, każdy komunikat musi zostać odczytany z bloku źródłowego, zanim blok źródłowy będzie mógł przetworzyć następny komunikat. Dlatego w przypadku używania filtrowania do łączenia wielu obiektów docelowych ze źródłem upewnij się, że co najmniej jeden blok docelowy otrzymuje każdy komunikat. W przeciwnym razie aplikacja może zakleszczenie.  
  
### <a name="message-passing"></a>Przekazywanie komunikatów  
 Model programowania przepływu danych jest powiązany z koncepcją *przekazywania komunikatów*, gdzie niezależne składniki programu komunikują się ze sobą przez wysyłanie komunikatów. Jednym ze sposobów propagowania komunikatów między składnikami aplikacji jest <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> wywoływanie <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> metod i wysyłanie komunikatów do docelowego bloków przepływu danych Blocks<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> (działa synchronicznie; działa asynchronicznie) <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>oraz metody <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> , aby odbierać komunikaty z bloków źródłowych. <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> Można połączyć te metody z potokami przepływu danych lub sieciami, wysyłając dane wejściowe do węzła głównego (blok docelowy) i pobierając dane wyjściowe z węzła terminalu potoku lub węzłów terminalu sieci (co najmniej jeden blok źródłowy). Można również użyć <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> metody do odczytu z pierwszego z podanych źródeł, które mają dostępne dane, i wykonywania akcji na tych danych.  
  
 Bloki źródła oferują dane do bloków docelowych przez wywołanie <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> metody. Blok docelowy reaguje na oferowany komunikat na jeden z trzech sposobów: może zaakceptować komunikat, odrzucić komunikat lub odłożyć komunikat. Gdy obiekt docelowy akceptuje komunikat, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> Metoda zwraca. <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted> Gdy obiekt docelowy odrzuci komunikat, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> Metoda zwraca. <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined> Gdy element docelowy wymaga, aby nie odbierał już żadnych komunikatów ze źródła, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>wartość. Wstępnie zdefiniowane typy bloków źródłowych nie oferują komunikatów do połączonych obiektów docelowych po odebraniu takiej wartości zwracanej i automatycznie odłączają od tych elementów docelowych.  
  
 Gdy blok docelowy opóźnia komunikat do późniejszego użycia, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> Metoda zwraca. <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed> Blok docelowy, który opóźnia komunikat, może później wywołać <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> metodę, aby spróbować zarezerwować proponowany komunikat. W tym momencie komunikat jest nadal dostępny i może być używany przez blok docelowy lub komunikat został wykonany przez inny element docelowy. Gdy blok docelowy później wymaga wiadomości lub nie potrzebuje już komunikatu, wywołuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> odpowiednio metodę lub. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> Rezerwacja komunikatów jest zwykle używana przez typy bloku przepływu danych, które działają w trybie innym niż zachłanne. Tryb inny niż zachłanne został wyjaśniony w dalszej części tego dokumentu. Zamiast obsłużyć odroczony komunikat, blok docelowy może również użyć <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> metody, aby próbować bezpośrednio wykorzystać odroczony komunikat.  
  
### <a name="dataflow-block-completion"></a>Zakończenie bloku przepływu danych  
 Bloki przepływu danych obsługują również koncepcję *uzupełniania*. Blok przepływu danych, który jest w stanie ukończone, nie wykonuje żadnych dalszych zadań. Każdy blok przepływu danych ma skojarzony <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> obiekt, znany jako *zadanie uzupełniania*, reprezentujący stan ukończenia bloku. Ponieważ możesz poczekać na <xref:System.Threading.Tasks.Task> zakończenie obiektu za pomocą zadań ukończenia, możesz poczekać na zakończenie co najmniej jednego węzła terminalu sieci przepływu danych. Interfejs definiuje metodę, która informuje blok przepływu danych o żądaniu do ukończenia, i <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwość, która zwraca zadanie ukończenia dla bloku przepływu danych. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> Oba <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> dziedziczą<xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfejs.  
  
 Istnieją dwa sposoby, aby określić, czy blok przepływu danych zakończył pracę bez błędu, napotkał co najmniej jeden błąd lub został anulowany. <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Pierwszym sposobem jest wywołanie metody w zadaniu zakończenia `catch` - `try` w bloku (`Try` - `Catch` w Visual Basic). Poniższy przykład tworzy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt, który zgłasza <xref:System.ArgumentOutOfRangeException> , jeśli jego wartość wejściowa jest mniejsza od zera. <xref:System.AggregateException>jest zgłaszany, gdy ten <xref:System.Threading.Tasks.Task.Wait%2A> przykład wywołuje zadanie ukończenia. Dostęp do niego odbywa <xref:System.AggregateException> <xref:System.AggregateException.InnerExceptions%2A> <xref:System.ArgumentOutOfRangeException> się za pomocą właściwości obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 W tym przykładzie pokazano przypadek, w którym wyjątek jest nieobsługiwany w delegatze bloku przepływu danych wykonywania. Zalecamy obsługę wyjątków w treści takich bloków. Jednakże jeśli nie można tego zrobić, blok zachowuje się tak, jakby został anulowany i nie przetwarza komunikatów przychodzących.  
  
 Gdy blok przepływu danych zostanie anulowany jawnie, <xref:System.AggregateException> obiekt zawiera <xref:System.OperationCanceledException> <xref:System.AggregateException.InnerExceptions%2A> właściwość. Aby uzyskać więcej informacji na temat anulowania przepływu danych, zobacz sekcję [Włączanie anulowania](#enabling-cancellation) .  
  
 Drugi sposób na określenie stanu ukończenia bloku przepływu danych polega na kontynuacji zadania ukończenia lub użyciu funkcji języka asynchronicznego C# i Visual Basic, aby asynchronicznie oczekiwać na ukończenie zadania. Delegat dostarczany do <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metody <xref:System.Threading.Tasks.Task> przyjmuje obiekt, który reprezentuje zadanie poprzedzające. W przypadku <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwości delegat dla kontynuacji pobiera samo zadanie zakończenia. Poniższy przykład przypomina poprzednią, z tą różnicą, że używa <xref:System.Threading.Tasks.Task.ContinueWith%2A> również metody do tworzenia zadania kontynuacji, które drukuje stan ogólnej operacji przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Możesz również użyć właściwości, takich jak <xref:System.Threading.Tasks.Task.IsCanceled%2A> w treści zadania kontynuacji, aby określić dodatkowe informacje o stanie ukończenia bloku przepływu danych. Aby uzyskać więcej informacji na temat zadań kontynuacji i sposobu ich odnoszących do anulowania i obsługi błędów, zobacz Tworzenie [łańcucha zadań przy użyciu zadań kontynuacji](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [anulowania zadań](../../../docs/standard/parallel-programming/task-cancellation.md)i [obsługi wyjątków](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [[Przejdź do góry](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Wstępnie zdefiniowane typy bloków przepływu danych  
 Biblioteka TPL przepływu danych zawiera kilka wstępnie zdefiniowanych typów bloków przepływu danych. Te typy są podzielone na trzy kategorie: *buforowanie bloków*, *bloków wykonywania*i *bloków grupowania*. W poniższych sekcjach opisano typy bloków, które składają się na te kategorie.  
  
### <a name="buffering-blocks"></a>Buforowanie bloków  
 Bloki buforowania przechowują dane do użycia przez użytkowników danych. Biblioteka TPL przepływu danych zawiera trzy typy bloków buforowania: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Klasa reprezentuje strukturę asynchronicznej obsługi komunikatów ogólnego przeznaczenia. Ta klasa przechowuje kolejki w pierwszej kolejności (FIFO) komunikatów, które mogą być zapisywane przez wiele źródeł lub odczytywane przez wiele obiektów docelowych. Gdy obiekt docelowy otrzymuje komunikat z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, ten komunikat zostanie usunięty z kolejki komunikatów. W związku z tym <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> mimo że obiekt może mieć wiele obiektów docelowych, tylko jeden element docelowy otrzyma każdy komunikat. <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Klasa jest przydatna, gdy chcesz przekazać wiele komunikatów do innego składnika, a ten składnik musi odebrać każdy komunikat.  
  
 Poniższy przykład podstawowy zapisuje kilka <xref:System.Int32> wartości <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> do obiektu, a następnie odczytuje te wartości z powrotem z tego obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Aby zapoznać się z kompletnym przykładem, który ilustruje sposób pisania komunikatów do i <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> odczytywania komunikatów [z obiektu, zobacz How to: Zapisuj wiadomości do i odczytywanie wiadomości z bloku](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)przepływu danych.  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Klasa jest przydatna, gdy musisz przekazać wiele komunikatów do innego składnika, ale ten składnik wymaga tylko najnowszej wartości. Ta klasa jest również przydatna, gdy chcesz emitować komunikat do wielu składników.  
  
 Poniższy przykład podstawowy zapisuje <xref:System.Double> wartość <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> do obiektu, a następnie odczytuje tę wartość z tego obiektu kilka razy. Ponieważ wartości nie są usuwane z <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektów po ich odczytaniu, ta sama wartość jest dostępna za każdym razem.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Aby zapoznać się z kompletnym przykładem <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> służącym do rozgłaszania komunikatów do wielu bloków docelowych, zobacz [How to: Określ Harmonogram zadań w bloku](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)przepływu danych.  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jest podobna <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> do <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> klasy, z tą różnicą, że obiekt może być zapisywana tylko raz. Można traktować <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jako podobny do C# słowa kluczowego [ReadOnly](../../csharp/language-reference/keywords/readonly.md) ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> w Visual Basic), z tą różnicą, że obiekt staje się niemodyfikowalny po odebraniu wartości, a nie w konstrukcji. Podobnie jak <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Klasa, gdy obiekt docelowy otrzymuje komunikat z obiektu, ten komunikat nie jest usuwany z tego obiektu. <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> W związku z tym wiele obiektów docelowych otrzymuje kopię wiadomości. <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Klasa jest przydatna, gdy chcesz propagować tylko pierwszy z wielu komunikatów.  
  
 Poniższy przykład podstawowy zapisuje wiele <xref:System.String> wartości <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> do obiektu, a następnie odczytuje wartość z powrotem z tego obiektu. Ponieważ obiekt może być zapisywany tylko jeden raz, <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> po odebraniu komunikatu przez obiekt odrzuci kolejne komunikaty. <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Aby zapoznać się z kompletnym przykładem, <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> który pokazuje, jak użyć do uzyskania wartości pierwszej operacji, która [kończy się, zobacz How to: Odłącz bloki](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)przepływu danych.  
  
### <a name="execution-blocks"></a>Bloki wykonywania  
 Bloki wykonywania wywołują delegata dostarczony przez użytkownika dla każdej z odebranych danych. Biblioteka TPL przepływu danych zawiera trzy typy bloków wykonywania: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Klasa jest blokiem docelowym, który wywołuje delegata po odebraniu danych. Zastanów <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> się obiektu jako delegata, który jest uruchamiany asynchronicznie, gdy dane staną się dostępne. Delegat, który można przekazać do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu, może być typu <xref:System.Action%601> lub typu `System.Func<TInput, Task>`. Gdy używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu z <xref:System.Action%601>, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy delegat zwraca. Gdy używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu z `System.Func<TInput, Task>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy <xref:System.Threading.Tasks.Task> zwracany obiekt jest zakończony. Korzystając z tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> zarówno do przetwarzania synchronicznego, jak i asynchronicznego dla każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy zapisuje wiele <xref:System.Int32> wartości <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> do obiektu. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Obiekt drukuje te wartości do konsoli. W tym przykładzie ustawia blok do stanu ukończone i czeka na zakończenie wszystkich zadań przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Aby zapoznać się z kompletnymi przykładami, które pokazują <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> , jak używać [delegatów z klasą, zobacz How to: Wykonaj akcję, gdy blok przepływu danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 Klasa <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> jest podobna do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> klasy, z tą różnicą, że działa jako źródło i jako element docelowy. Delegat przekazywany do <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu zwraca wartość typu `TOutput`. Delegat, który podaje się do <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu, może być typu `System.Func<TInput, TOutput>` lub typu `System.Func<TInput, Task<TOutput>>`. Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu z `System.Func<TInput, TOutput>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy delegat zwraca. Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu używanego z `System.Func<TInput, Task<TOutput>>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy <xref:System.Threading.Tasks.Task%601> zwracany obiekt jest zakończony. Podobnie jak <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>w przypadku, korzystając z tych dwóch mechanizmów, można <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> użyć zarówno do przetwarzania synchronicznego, jak i asynchronicznego dla każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt, który oblicza pierwiastek kwadratowy jego danych wejściowych. Obiekt pobiera <xref:System.Int32> wartości jako dane wejściowe i generuje <xref:System.Double> wartości jako dane wyjściowe. <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Aby zapoznać się z kompletnymi przykładami, które używają <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> w sieci bloków przepływu danych, które wykonują przetwarzanie obrazów w aplikacji Windows Forms, zobacz [Przewodnik: Korzystanie z przepływu danych w aplikacji](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)Windows Forms.  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 Klasa <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> jest podobna <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> do klasy, z tą różnicą, że <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> generuje zero lub więcej wartości wyjściowych dla każdej wartości wejściowej, a nie tylko jedną wartość wyjściową dla każdej wartości wejściowej. Delegat, który podaje się do <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektu, może być typu `System.Func<TInput, IEnumerable<TOutput>>` lub typu `System.Func<TInput, Task<IEnumerable<TOutput>>>`. Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektu z `System.Func<TInput, IEnumerable<TOutput>>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy delegat zwraca. Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektu z `System.Func<TInput, Task<IEnumerable<TOutput>>>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy `System.Threading.Tasks.Task<IEnumerable<TOutput>>` zwracany obiekt jest zakończony.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt dzielący ciągi na ich poszczególne sekwencje znaków. Obiekt pobiera <xref:System.String> wartości jako dane wejściowe i generuje <xref:System.Char> wartości jako dane wyjściowe. <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Aby zapoznać się z kompletnymi przykładami używanymi <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> do tworzenia wielu niezależnych danych wyjściowych dla każdego elementu wejściowego w potoku przepływu danych, zobacz [Przewodnik: Tworzenie potoku](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)przepływu danych.  
  
#### <a name="degree-of-parallelism"></a>Stopień równoległości  
 Każdy obiekt, i<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> buforuje komunikaty wejściowe do momentu, gdy blok jest gotowy do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>przetworzenia <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>. Domyślnie te klasy przetwarzają komunikaty w kolejności, w której są odbierane, po jednym komunikacie. Można również określić stopień równoległości do włączenia <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> oraz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekty do równoczesnego przetwarzania wielu komunikatów. Więcej informacji o jednoczesnym wykonywaniu można znaleźć w sekcji Określanie stopnia równoległości w dalszej części tego dokumentu. Aby uzyskać przykład, który ustawia stopień równoległości, aby umożliwić blokowi przepływu danych wykonywania przetwarzanie więcej niż jednego komunikatu w danym momencie, zobacz [How to: Określ stopień równoległości w bloku](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)przepływu danych.  
  
#### <a name="summary-of-delegate-types"></a>Podsumowanie typów delegatów  
 Poniższa tabela zawiera podsumowanie typów delegatów, które można dostarczyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów. Ta tabela określa również, czy typ delegata działa synchronicznie, czy asynchronicznie.  
  
|Typ|Typ delegata synchronicznego|Typ delegata asynchronicznego|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Można również użyć wyrażeń lambda podczas pracy z typami bloków wykonywania. Aby zapoznać się z przykładem, który pokazuje, jak używać wyrażenia lambda z blokiem [wykonywania, zobacz How to: Wykonaj akcję, gdy blok przepływu danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Bloki grupowania  
 Bloki grupowania łączą dane z co najmniej jednego źródła i w różnych ograniczeniach. Biblioteka TPL przepływu danych zawiera trzy typy bloków sprzężenia: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Klasa łączy zestawy danych wejściowych, które są nazywane partiami, do tablic danych wyjściowych. Podczas tworzenia <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu należy określić rozmiar każdej partii. <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Gdy obiekt otrzymuje określoną liczbę elementów wejściowych, asynchronicznie propaguje tablicę zawierającą te elementy. <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Jeśli obiekt jest ustawiony na stan ukończony, ale nie zawiera wystarczającej liczby elementów, aby utworzyć partię, propaguje ostateczną tablicę zawierającą pozostałe elementy wejściowe.  
  
 Klasa działa w trybie *zachłanne* lub *innym niż zachłanne.* <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> W trybie zachłanne, który jest domyślnym, <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt akceptuje każdy komunikat, że jest oferowany, i propaguje tablicę po odebraniu określonej liczby elementów. W trybie innym niż zachłanne <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt opóźnia wszystkie komunikaty przychodzące do momentu, gdy wystarczające źródła nie zaoferują komunikatów do bloku, aby utworzyć partię. Tryb zachłanne zazwyczaj wykonuje lepsze niż tryb inny niż zachłanne, ponieważ wymaga mniejszego obciążenia przetwarzania. Można jednak używać trybu zachłanne, gdy trzeba skoordynować użycie z wielu źródeł w sposób niepodzielny. Określ tryb inny niż zachłanne, ustawiając <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> `False` wartość <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> w `dataflowBlockOptions` parametrze w konstruktorze.  
  
 Poniższy przykład podstawowy zapisuje kilka <xref:System.Int32> wartości <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> do obiektu, który przechowuje dziesięć elementów w partii. W celu zagwarantowania, że wszystkie wartości <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>są propagowane z, <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> ten przykład wywołuje metodę. Metoda ustawia obiekt na stan ukończony i w związku z tym <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt propaguje wszystkie pozostałe elementy jako końcową partię. <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Aby zapoznać się z kompletnym <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> przykładem, który używa do poprawiania wydajności operacji [wstawiania bazy danych, zobacz Przewodnik: Korzystanie z BatchBlock i BatchedJoinBlock w celu](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)zwiększenia wydajności.  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 Klasy <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> zbierają elementy<xref:System.Tuple%602?displayProperty=nameWithType>wejściowe i propagują obiekty,którezawierająteelementy.<xref:System.Tuple%603?displayProperty=nameWithType> Klasy <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> nie dziedziczą z <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Zamiast tego dostarczają właściwości <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>,, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Podobnie jak <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>wtrybie zachłannelubzachłanne.<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> W trybie zachłanne, który jest wartością domyślną, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt akceptuje każdy komunikat, że jest oferowany, i propaguje spójność kolekcji po każdym z jej obiektów docelowych odbiera co najmniej jeden komunikat. W trybie <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> innym niż zachłanne obiekt lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> odrzuca wszystkie komunikaty przychodzące do momentu zaoferowania wszystkim elementom docelowym danych, które są wymagane do utworzenia krotki. W tym momencie blok jest zaangażowany w dwufazowego protokołu zatwierdzania w celu niepodzielnego pobrania wszystkich wymaganych elementów ze źródeł. To odroczenie pozwala innym jednostkom zużywać dane w międzyczasie, aby umożliwić całkowitemu systemowi przeprowadzenie do przodu postępu.  
  
 Poniższy przykład podstawowy ilustruje przypadek, w którym <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt wymaga wielu danych do obliczenia wartości. Ten przykład tworzy <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt, który wymaga dwóch <xref:System.Int32> wartości i <xref:System.Char> wartości do wykonania operacji arytmetycznej.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Aby zapoznać się z kompletnym <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> przykładem, który używa obiektów w trybie innym niż zachłanne do współdzielenia zasobu, zobacz [How to: Użyj klasy JoinBlock, aby odczytywać dane z](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)wielu źródeł.  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Klasy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> `System.Tuple(IList(T1), IList(T2))` i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> zbierają partie`System.Tuple(IList(T1), IList(T2), IList(T3))` elementów wejściowych i propaguje obiekty, które zawierają te elementy. Należy traktować <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>jako kombinację i. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> Określ rozmiar każdej partii podczas tworzenia <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>zawiera również właściwości <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Gdy określona liczba elementów wejściowych jest odbierana z wszystkich obiektów docelowych, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiekt asynchronicznie propaguje `System.Tuple(IList(T1), IList(T2))` obiekt, który zawiera te elementy.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiekt, który przechowuje wyniki, <xref:System.Int32> wartości i błędy, które są <xref:System.Exception> obiektami. Ten przykład wykonuje wiele operacji i zapisuje wyniki do <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> właściwości oraz błędy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> do właściwości <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. Ze względu na to, że liczba zakończonych powodzeniem i zakończonych <xref:System.Collections.Generic.IList%601> niepowodzeniem operacji jest nieznana z wyprzedzeniem, obiekty umożliwiają każdy element docelowy otrzymać zero lub więcej wartości.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> do przechwytywania zarówno wyników, jak i wyjątków, które występują, gdy program odczytuje z bazy danych, zobacz [Przewodnik: Korzystanie z BatchBlock i BatchedJoinBlock w celu](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)zwiększenia wydajności.  
  
 [[Przejdź do góry](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Konfigurowanie zachowania blokowania przepływu danych  
 Dodatkowe opcje można włączyć, dostarczając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> obiekt do konstruktora typów bloków przepływu danych. Te opcje kontrolują zachowanie, takie jak harmonogram zarządzający zadaniem podstawowym i stopień równoległości. Ma <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> także typy pochodne, które określają zachowanie specyficzne dla określonych typów bloku przepływu danych. Poniższa tabela zawiera podsumowanie typów opcji skojarzonych z każdym typem bloku przepływu danych.  
  
|Typ bloku przepływu danych|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>Wprowadź|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 W poniższych sekcjach znajdują się dodatkowe informacje o ważnych typach opcji blokowania przepływu danych, które są dostępne za <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>pomocą <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>klas, <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> i.  
  
### <a name="specifying-the-task-scheduler"></a>Określanie Harmonogram zadań  
 Każdy wstępnie zdefiniowany blok przepływu danych używa mechanizmu planowania zadań TPL do wykonywania działań, takich jak propagowanie danych do obiektu docelowego, pobieranie danych ze źródła i uruchamianie delegatów zdefiniowanych przez użytkownika, gdy dane staną się dostępne. <xref:System.Threading.Tasks.TaskScheduler>jest klasą abstrakcyjną, która reprezentuje harmonogram zadań, który kolejkuje zadania na wątki. Domyślny harmonogram <xref:System.Threading.Tasks.TaskScheduler.Default%2A>zadań,, <xref:System.Threading.ThreadPool> używa klasy do kolejkowanie i wykonywanie pracy. Można zastąpić domyślny harmonogram zadań, ustawiając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Gdy ten sam harmonogram zadań zarządza wieloma blokami przepływu danych, może wymuszać zasady dla nich. Jeśli na przykład wiele bloków przepływu danych jest skonfigurowanych pod kątem wyłącznego harmonogramu tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektu, wszystkie zadania działające w ramach tych bloków są serializowane. Podobnie, jeśli te bloki są skonfigurowane pod kątem współbieżnego harmonogramu tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektu, a harmonogram jest skonfigurowany tak, aby miał maksymalny poziom współbieżności, wszystkie prace z tych bloków są ograniczone do tej liczby współbieżnych operacji. Aby zapoznać się z przykładem <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> , który używa klasy do włączania operacji odczytu równolegle, ale operacje zapisu mają być wykonywane wyłącznie przez wszystkie inne operacje [, zobacz How to: Określ Harmonogram zadań w bloku](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)przepływu danych. Aby uzyskać więcej informacji na temat harmonogramów zadań w TPL, zobacz <xref:System.Threading.Tasks.TaskScheduler> temat Klasa.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Określanie stopnia równoległości  
 Domyślnie trzy typy bloków wykonywania, które Biblioteka TPL przepływu danych udostępniają, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, przetwarzają jeden komunikat w danym momencie. Te typy bloków przepływu danych również przetwarzają komunikaty w kolejności, w jakiej zostały odebrane. Aby włączyć te bloki przepływu danych do przetwarzania komunikatów współbieżnie, należy ustawić <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Wartość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> domyślna wynosi 1, co gwarantuje, że blok przepływu danych przetwarza jeden komunikat w danym momencie. Ustawienie tej właściwości na wartość, która jest większa niż 1 umożliwia blokowi przepływu danych przetwarzanie wielu komunikatów współbieżnie. Ustawienie tej właściwości <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> umożliwia uruchamianie bazowego harmonogramu zadań w celu zarządzania maksymalnym stopień współbieżności.  
  
> [!IMPORTANT]
> W przypadku określenia maksymalnego stopnia równoległości, który jest większy niż 1, wiele komunikatów jest przetwarzanych jednocześnie i dlatego komunikaty mogą nie być przetwarzane w kolejności, w której zostały odebrane. Kolejność, w jakiej komunikaty są wyprowadzane z bloku, jest jednak taka sama, w której zostały odebrane.  
  
 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> Ponieważ właściwość reprezentuje maksymalny stopień równoległości, blok przepływu danych może być wykonywany z mniejszym stopieńem równoległości niż określono. Blok przepływu danych może używać mniejszego stopnia równoległości w celu spełnienia wymagań funkcjonalnych lub braku dostępnych zasobów systemowych. Blok przepływu danych nigdy nie wybiera bardziej równoległości niż określono.  
  
 Wartość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwości jest wyłącznie dla każdego obiektu bloku przepływu danych. Na przykład jeśli cztery obiekty przepływu danych bloku Each określają 1 dla maksymalnego stopnia równoległości, wszystkie cztery obiekty bloku przepływu danych mogą być uruchamiane równolegle.  
  
 Aby uzyskać przykład, który ustawia maksymalny stopień równoległości, aby umożliwić równoległe wykonywanie operacji, zobacz [How to: Określ stopień równoległości w bloku](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)przepływu danych.  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Określanie liczby komunikatów na zadanie  
 Wstępnie zdefiniowane typy bloków przepływu danych używają zadań do przetwarzania wielu elementów wejściowych. Pozwala to zminimalizować liczbę obiektów zadań, które są wymagane do przetwarzania danych, dzięki czemu aplikacje mogą działać wydajniej. Jednak podczas przetwarzania danych przez zadania z jednego zestawu bloków przepływu danych zadania z innych bloków przepływu danych mogą wymagać poczekania na czas przetwarzania przez kolejkowanie komunikatów. Aby zapewnić lepszą sprawiedliwość między zadaniami przepływu danych, ustaw <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwość. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest ustawiona na <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, jest to ustawienie domyślne, zadanie używane przez blok przepływu danych przetwarza tyle komunikatów, ile jest dostępnych. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest ustawiona na wartość inną niż <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, blok przepływu danych przetwarza co najwyżej następującą liczbę komunikatów na <xref:System.Threading.Tasks.Task> obiekt. Chociaż ustawienie <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwości może zwiększyć atrakcyjność między zadaniami, może to spowodować, że system będzie mógł utworzyć więcej zadań, niż jest to konieczne, co może obniżyć wydajność.  
  
### <a name="enabling-cancellation"></a>Włączanie anulowania  
 TPL zapewnia mechanizm, który umożliwia wykonywanie zadań w celu koordynowania anulowania w sposób współpracy. Aby włączyć bloki przepływu danych do uczestnictwa w tym mechanizmie anulowania, należy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> ustawić właściwość. Gdy ten <xref:System.Threading.CancellationToken> obiekt jest ustawiony na stan anulowane, wszystkie bloki przepływu danych, które monitorują ten token, zakończą wykonywanie bieżącego elementu, ale nie rozpoczynają przetwarzania kolejnych elementów. Te bloki przepływu danych czyściją także wszystkie buforowane komunikaty, zwalniają połączenia z dowolnymi blokami źródłowymi i docelowymi oraz przejścia do stanu anulowane. Przejście do stanu anulowane powoduje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> , że właściwość <xref:System.Threading.Tasks.Task.Status%2A> ma ustawioną właściwość na <xref:System.Threading.Tasks.TaskStatus.Canceled>, chyba że wystąpił wyjątek podczas przetwarzania. W takim przypadku <xref:System.Threading.Tasks.Task.Status%2A> jest ustawiony na <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Aby zapoznać się z przykładem, który ilustruje sposób używania anulowania w aplikacji Windows Forms [, zobacz How to: Anuluj blok](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)przepływu danych. Aby uzyskać więcej informacji na temat anulowania w TPL, zobacz [Anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Określanie zachowania zachłanne a inne niż zachłanne  
 Niektóre typy bloków przepływu danych grupowania mogą działać w trybie *zachłanne* lub *innym niż zachłanne* . Domyślnie wstępnie zdefiniowane typy bloku przepływu danych działają w trybie zachłanne.  
  
 W przypadku typów bloku sprzężenia <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, takich jak, tryb zachłannenia oznacza, że blok natychmiast akceptuje dane, nawet jeśli odpowiadające im dane, z którymi mają zostać przyłączone, nie są jeszcze dostępne. Tryb inny niż zachłanne oznacza, że blok opóźnia wszystkie komunikaty przychodzące do momentu, gdy jeden z nich jest dostępny w celu zakończenia przyłączenia. Jeśli którykolwiek z odroczonych komunikatów nie jest już dostępny, blok sprzężenia zwalnia wszystkie odroczone komunikaty i ponownie uruchamia proces. W przypadku <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> klasy zachłanne i niezachłanne zachowanie jest podobne, z tą różnicą, że w trybie innym niż zachłanne, obiekt opóźnia wszystkie komunikaty przychodzące do momentu, gdy jest on dostępny z różnych źródeł, aby zakończyć partię. <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>  
  
 Aby określić tryb inny niż zachłanne dla bloku przepływu danych, ustaw wartość <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> na `False`. Aby zapoznać się z przykładem, który ilustruje, jak używać trybu zachłanne, aby umożliwić wielokrotne udostępnianie źródła danych, zobacz [How to: Użyj klasy JoinBlock, aby odczytywać dane z](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)wielu źródeł.  
  
 [[Przejdź do góry](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Niestandardowe bloki przepływu danych  
 Chociaż biblioteka TPL przepływu danych udostępnia wiele wstępnie zdefiniowanych typów bloków, można utworzyć dodatkowe typy bloku, które wykonują niestandardowe zachowanie. Zaimplementuj <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsy lub bezpośrednio lub Użyj metody,abyutworzyćblokzłożony,któryhermetyzujezachowanieistniejącychtypówbloków.<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> Przykłady pokazujące sposób implementacji niestandardowej funkcji blokowania przepływu danych można znaleźć [w przewodniku: Tworzenie niestandardowego typu](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)bloku przepływu danych.  
  
 [[Przejdź do góry](#top)]  
  
## <a name="related-topics"></a>Tematy pokrewne  
  
|Tytuł|Opis|  
|-----------|-----------------|  
|[Instrukcje: Zapisuj wiadomości do i odczytywać wiadomości z bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Demonstruje sposób pisania komunikatów do i odczytywania wiadomości z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu.|  
|[Instrukcje: Implementowanie wzorca przepływu danych konsumenta-odbiorcy](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Opisuje, w jaki sposób używać modelu przepływu danych do implementowania wzorca producenta, gdzie producent wysyła komunikaty do bloku przepływu danych, a konsument odczytuje komunikaty z tego bloku.|  
|[Instrukcje: Wykonaj akcję, gdy blok przepływu danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Opisuje sposób dostarczania delegatów do typów bloku przepływu danych wykonywania, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Przewodnik: Tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Opisuje sposób tworzenia potoku przepływu danych, który pobiera tekst z sieci Web i wykonuje operacje na tym tekście.|  
|[Instrukcje: Odłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Pokazuje, <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> jak używać metody do odłączenia bloku docelowego od jego źródła, gdy źródło oferuje komunikat do obiektu docelowego.|  
|[Przewodnik: Korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Pokazuje, jak utworzyć sieć bloków przepływu danych, które wykonują przetwarzanie obrazów w aplikacji Windows Forms.|  
|[Instrukcje: Anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Pokazuje, jak używać anulowania w aplikacji Windows Forms.|  
|[Instrukcje: Korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Wyjaśnia, w jaki sposób <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> używać klasy do wykonywania operacji, gdy dane są dostępne z wielu źródeł, oraz jak używać trybu zachłanne, aby umożliwić wielu blokom sprzężenia bardziej wydajne udostępnianie źródła danych.|  
|[Instrukcje: Określ stopień równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Opisuje sposób ustawiania <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwości w celu włączenia bloku przepływu danych wykonywania w celu przetworzenia więcej niż jednego komunikatu w danym momencie.|  
|[Instrukcje: Określ Harmonogram zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Demonstruje sposób kojarzenia określonego harmonogramu zadań w przypadku korzystania z przepływu danych w aplikacji.|  
|[Przewodnik: Korzystanie z BatchBlock i BatchedJoinBlock w celu zwiększenia wydajności](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Opisuje sposób użycia <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> klasy w celu zwiększenia wydajności operacji wstawiania bazy danych oraz sposobu <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> używania klasy do przechwytywania zarówno wyników, jak i wyjątków, które występują, gdy program odczytuje z bazy danych.|  
|[Przewodnik: Tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Ilustruje dwa sposoby tworzenia typu bloku przepływu danych, który implementuje zachowanie niestandardowe.|  
|[Biblioteka zadań równoległych (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Wprowadza TPL, bibliotekę, która upraszcza równoległe i współbieżne programowanie w aplikacjach .NET Framework.|
