---
title: Przepływ danych (Biblioteka zadań równoległych)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 6c589e85a0bbfb3f0b5858698ffb2a294ff88cf2
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "73973784"
---
# <a name="dataflow-task-parallel-library"></a>Przepływ danych (Biblioteka zadań równoległych)
Biblioteka równoległa zadań (TPL) udostępnia składniki przepływu danych, aby zwiększyć niezawodność aplikacji obsługujących współbieżność. Te składniki przepływu danych są zbiorczo określane jako *Biblioteka przepływu danych TPL*. Ten model przepływu danych promuje programowanie oparte na aktora, zapewniając przekazywanie komunikatów w toku dla zadań przepływu danych zgrubniezoną i rurociągów. Składniki przepływu danych opierają się na typach i infrastrukturze planowania tpl i integrują się z obsługą języka C#, Visual Basic i F# dla programowania asynchronicznego. Te składniki przepływu danych są przydatne, gdy masz wiele operacji, które muszą komunikować się ze sobą asynchronicznie lub gdy chcesz przetwarzać dane, gdy stają się dostępne. Rozważmy na przykład aplikację, która przetwarza dane obrazu z kamery internetowej. Za pomocą modelu przepływu danych, aplikacja może przetwarzać ramki obrazu, gdy stają się one dostępne. Jeśli aplikacja zwiększa ramki obrazu, na przykład poprzez wykonywanie korekcji światła lub redukcji efektu czerwonych oczu, można utworzyć *potok* składników przepływu danych. Każdy etap potoku może używać bardziej gruboziarnisto-grained funkcji równoległości, takich jak funkcje, które są dostarczane przez TPL, aby przekształcić obraz.  
  
 Ten dokument zawiera omówienie biblioteki przepływu danych TPL. Opisuje model programowania, wstępnie zdefiniowane typy bloków przepływu danych i sposób konfigurowania bloków przepływu danych w celu spełnienia określonych wymagań aplikacji.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a>Model programowania
 Biblioteka przepływu danych TPL stanowi podstawę do przekazywania komunikatów i równoległych aplikacji intensywnie korzystających z procesora CPU i intensywnie korzystających z we/wy, które mają wysoką przepływność i małe opóźnienia. Zapewnia również jawne kontroli nad jak dane są buforowane i porusza się po systemie. Aby lepiej zrozumieć model programowania przepływu danych, należy wziąć pod uwagę aplikację, która asynchronicznie ładuje obrazy z dysku i tworzy złożony z tych obrazów. Tradycyjne modele programowania zazwyczaj wymagają użycia wywołań wywołania wstecznych i obiektów synchronizacji, takich jak blokady, do koordynowania zadań i dostępu do udostępnionych danych. Za pomocą modelu programowania przepływu danych można tworzyć obiekty przepływu danych, które przetwarzają obrazy podczas odczytu z dysku. W modelu przepływu danych deklarujesz, jak dane są obsługiwane, gdy stają się dostępne, a także wszelkie zależności między danymi. Ponieważ czas wykonywania zarządza zależności między danymi, często można uniknąć wymogu synchronizacji dostępu do udostępnionych danych. Ponadto ponieważ harmonogramy czasu wykonywania działają na podstawie asynchronicznego nadejścia danych, przepływ danych może poprawić czas reakcji i przepływność, efektywnie zarządzając wątkami źródłowymi. Na przykład, który używa modelu programowania przepływu danych do zaimplementowania przetwarzania obrazu w aplikacji Formularze systemu Windows, zobacz [Instruktaż: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Źródła i obiekty docelowe  
 Biblioteka przepływu danych TPL składa się z *bloków przepływu danych,* które są strukturami danych buforowania i przetwarzania danych. TPL definiuje trzy rodzaje bloków przepływu danych: *bloki źródłowe,* *bloki docelowe*i *bloki propagatora.* Blok źródłowy działa jako źródło danych i mogą być odczytywane. Blok docelowy działa jako odbiorca danych i mogą być zapisywane. Blok propagatora działa zarówno jako blok źródłowy, jak i blok docelowy i może być odczytywany i zapisywany. TPL definiuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interfejs do reprezentowania <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> źródeł, do <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> reprezentowania obiektów docelowych i do reprezentowania propagatorów. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>dziedziczy <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>z <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>obu , i .  
  
 Biblioteka przepływu danych TPL zawiera kilka wstępnie zdefiniowanych <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>typów <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> bloków przepływu danych, które implementują , i interfejsy. Te typy bloków przepływu danych są opisane w tym dokumencie w sekcji [Wstępnie zdefiniowane typy bloków przepływu danych](#predefined-dataflow-block-types).  
  
### <a name="connecting-blocks"></a>Bloki łączące  
 Bloki przepływu danych można łączyć z *potokami tworzącymi,* które są sekwencjami liniowymi bloków przepływu danych lub *sieci*, które są wykresami bloków przepływu danych. Potok jest jedną z form sieci. W potoku lub sieci źródła asynchronicznie propagować dane do obiektów docelowych, jak te dane stają się dostępne. Metoda <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> łączy blok źródła przepływu danych do bloku docelowego. Źródło może być połączone z zerowym lub większą liczbą celów; cele można powiązać z zerowych lub większej liczby źródeł. Można jednocześnie dodawać lub usuwać bloki przepływu danych do potoku lub sieci lub z niego. Wstępnie zdefiniowane typy bloków przepływu danych obsługują wszystkie aspekty bezpieczeństwa wątków łączenia i odłączania.  
  
 Na przykład, który łączy bloki przepływu danych w celu utworzenia podstawowego potoku, zobacz [Instruktaż: Tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Na przykład, który łączy bloki przepływu danych w celu utworzenia bardziej złożonej sieci, zobacz [Instruktaż: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Na przykład, że odłącza obiekt docelowy ze źródła po źródło oferuje docelowy komunikat, zobacz [Jak: Odłączyć bloki przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrowanie  
 Po wywołaniu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> metody, aby połączyć źródło do obiektu docelowego, można podać pełnomocnika, który określa, czy blok docelowy akceptuje lub odrzuca wiadomość na podstawie wartości tej wiadomości. Ten mechanizm filtrowania jest przydatnym sposobem zagwarantowania, że blok przepływu danych odbiera tylko niektóre wartości. W przypadku większości wstępnie zdefiniowanych typów bloków przepływu danych, jeśli blok źródłowy jest połączony z wieloma blokami docelowymi, gdy blok docelowy odrzuca wiadomość, źródło oferuje tę wiadomość następnemu obiektowi docelowemu. Kolejność, w jakiej źródło oferuje wiadomości do obiektów docelowych jest zdefiniowana przez źródło i może się różnić w zależności od typu źródła. Większość typów bloków źródłowych przestaje oferować wiadomość po zaakceptowaniu tej wiadomości przez jeden obiekt docelowy. Jednym z wyjątków <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> od tej reguły jest klasa, która oferuje każdy komunikat do wszystkich obiektów docelowych, nawet jeśli niektóre obiekty docelowe odrzucić wiadomość. Na przykład, który używa filtrowania do przetwarzania tylko niektórych wiadomości, zobacz [Instruktaż: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
> Ponieważ każdy wstępnie zdefiniowany typ bloku przepływu danych źródłowych gwarantuje, że wiadomości są propagowane w kolejności, w jakiej są odbierane, każda wiadomość musi być odczytana z bloku źródłowego, zanim blok źródłowy może przetworzyć następną wiadomość. W związku z tym podczas filtrowania do łączenia wielu obiektów docelowych do źródła, upewnij się, że co najmniej jeden blok docelowy odbiera każdy komunikat. W przeciwnym razie aplikacja może zakleszczenie.  
  
### <a name="message-passing"></a>Przekazywanie wiadomości  
 Model programowania przepływu danych jest związany z pojęciem *przekazywania wiadomości,* gdzie niezależne składniki programu komunikują się ze sobą poprzez wysyłanie wiadomości. Jednym ze sposobów propagowania wiadomości między <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> składnikami aplikacji jest wywołanie i<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> metody wysyłania wiadomości do docelowych bloków przepływu danych post ( działa synchronicznie; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> działa asynchronicznie) <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> i metody odbierania wiadomości z bloków źródłowych. Metody te można łączyć z potokami lub sieciami przepływu danych, wysyłając dane wejściowe do węzła centralnego (blok docelowy) i odbierając dane wyjściowe z węzła terminala potoku lub węzłów końcowych sieci (jeden lub więcej bloków źródłowych). Można również użyć <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> metody do odczytu z pierwszego z podanych źródeł, który ma dostępne dane i wykonać akcję na tych danych.  
  
 Bloki źródłowe oferują dane <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> do bloków docelowych, wywołując metodę. Blok docelowy odpowiada na oferowaną wiadomość na jeden z trzech sposobów: może zaakceptować wiadomość, odrzucić wiadomość lub odłożyć wiadomość. Gdy obiekt docelowy zaakceptuje <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> wiadomość, <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>metoda zwraca . Gdy obiekt docelowy odrzuci <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> wiadomość, <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>metoda zwraca . Gdy obiekt docelowy wymaga, aby nie odbierał <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>już żadnych wiadomości ze źródła, zwraca . Wstępnie zdefiniowane typy bloków źródłowych nie oferują wiadomości do połączonych obiektów docelowych po odebraniu takiej wartości zwracanej i automatycznie odłączają się od takich obiektów docelowych.  
  
 Gdy blok docelowy odracza wiadomość do <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> późniejszego użycia, metoda zwraca . <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed> Blok docelowy, który odracza wiadomość, może później wywołać <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> metodę, aby spróbować zarezerwować oferowaną wiadomość. W tym momencie wiadomość jest nadal dostępna i może być używana przez blok docelowy lub wiadomość została podjęta przez inny obiekt docelowy. Gdy blok docelowy później wymaga wiadomości lub nie potrzebuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> już <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> wiadomości, wywołuje lub metody, odpowiednio. Rezerwacja wiadomości jest zwykle używana przez typy bloków przepływu danych, które działają w trybie niechciwym. Tryb niechciwy jest wyjaśniony w dalszej części tego dokumentu. Zamiast rezerwować odroczoną wiadomość, blok docelowy <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> można również użyć metody, aby spróbować bezpośrednio zużywać odroczoną wiadomość.  
  
### <a name="dataflow-block-completion"></a>Uzupełnianie bloku przepływu danych  
 Bloki przepływu danych obsługują również koncepcję *ukończenia*. Blok przepływu danych, który jest w stanie ukończony nie wykonuje żadnych dalszych prac. Każdy blok przepływu danych <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> ma skojarzony obiekt, znany jako *zadanie zakończenia,* który reprezentuje stan ukończenia bloku. Ponieważ można poczekać <xref:System.Threading.Tasks.Task> na zakończenie obiektu, przy użyciu zadań zakończenia, można poczekać na zakończenie jednego lub więcej węzłów terminala sieci przepływu danych. Interfejs <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> definiuje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metodę, która informuje blok przepływu danych żądania do ukończenia <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> i właściwość, która zwraca zadanie zakończenia dla bloku przepływu danych. Oba <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> i <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> dziedziczą interfejs.  
  
 Istnieją dwa sposoby, aby ustalić, czy blok przepływu danych zakończone bez błędów, napotkał jeden lub więcej błędów lub został anulowany. <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Pierwszym sposobem jest wywołanie metody w zadaniu ukończenia w bloku (w `try` - `catch` `Try` - `Catch` języku Visual Basic). Poniższy przykład tworzy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt, <xref:System.ArgumentOutOfRangeException> który zgłasza, jeśli jego wartość wejściowa jest mniejsza niż zero. <xref:System.AggregateException>jest generowany, gdy <xref:System.Threading.Tasks.Task.Wait%2A> w tym przykładzie wywołuje zadanie ukończenia. Dostęp <xref:System.ArgumentOutOfRangeException> jest dostępny <xref:System.AggregateException.InnerExceptions%2A> za pośrednictwem właściwości <xref:System.AggregateException> obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 W tym przykładzie przedstawiono przypadek, w którym wyjątek nie jest obsługiwany w pełnomocniku bloku przepływu danych wykonywania. Zaleca się obsługę wyjątków w ciałach takich bloków. Jeśli jednak nie możesz tego zrobić, blok zachowuje się tak, jakby został anulowany i nie przetwarza wiadomości przychodzących.  
  
 Gdy blok przepływu danych jest anulowany <xref:System.AggregateException> jawnie, obiekt zawiera <xref:System.OperationCanceledException> we <xref:System.AggregateException.InnerExceptions%2A> właściwości. Aby uzyskać więcej informacji na temat anulowania przepływu danych, zobacz [Włączanie anulowania](#enabling-cancellation) sekcji.  
  
 Drugim sposobem określenia stanu zakończenia bloku przepływu danych jest użycie kontynuacji zadania zakończenia lub użycie funkcji języka asynchronicznego języka C# i Visual Basic do asynchronicznego oczekiwania na zadanie zakończenia. Pełnomocnik, który należy podać <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> do <xref:System.Threading.Tasks.Task> metody przyjmuje obiekt, który reprezentuje zadanie poprzednika. W przypadku <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwości pełnomocnik dla kontynuacji przyjmuje samo zadanie ukończenia. Poniższy przykład przypomina poprzedni, z tą różnicą, że używa również <xref:System.Threading.Tasks.Task.ContinueWith%2A> metody do tworzenia zadania kontynuacji, który drukuje stan operacji przepływu danych ogólnej.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Można również użyć właściwości, <xref:System.Threading.Tasks.Task.IsCanceled%2A> takich jak w treści zadania kontynuacji, aby określić dodatkowe informacje o stanie zakończenia bloku przepływu danych. Aby uzyskać więcej informacji na temat zadań kontynuacji i ich relacji z anulowaniem i obsługą błędów, zobacz [Zadania łańcuchowe przy użyciu zadań kontynuacji,](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) [anulowanie zadań](../../../docs/standard/parallel-programming/task-cancellation.md)i [obsługa wyjątków](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  

## <a name="predefined-dataflow-block-types"></a>Wstępnie zdefiniowane typy bloków przepływu danych  
 Biblioteka przepływu danych TPL zawiera kilka wstępnie zdefiniowanych typów bloków przepływu danych. Te typy są podzielone na trzy kategorie: *buforowanie bloków,* *bloki wykonywania*i *bloki grupowania*. W poniższych sekcjach opisano typy bloków, które tworzą te kategorie.  
  
### <a name="buffering-blocks"></a>Bloki buforowania  
 Bloki buforowania przechowują dane do użycia przez konsumentów danych. Biblioteka przepływu danych TPL zawiera trzy <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>typy <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>bloków buforowania: , , i <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> reprezentuje ogólnego przeznaczenia struktury komunikatów asynchronicznych. Ta klasa przechowuje pierwszy w, pierwszy out (FIFO) kolejki wiadomości, które mogą być zapisywane przez wiele źródeł lub odczytywane przez wiele obiektów docelowych. Gdy obiekt docelowy odbiera <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> wiadomość z obiektu, ta wiadomość jest usuwana z kolejki komunikatów. W związku <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> z tym mimo że obiekt może mieć wiele obiektów docelowych, tylko jeden obiekt docelowy otrzyma każdą wiadomość. Klasa <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> jest przydatna, gdy chcesz przekazać wiele komunikatów do innego składnika, a ten składnik musi odbierać każdy komunikat.  
  
 Poniższy przykład podstawowy <xref:System.Int32> księguje <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> kilka wartości do obiektu, a następnie odczytuje te wartości z powrotem z tego obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Aby uzyskać pełny przykład, który pokazuje, jak pisać <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> wiadomości do i odczytywać wiadomości z obiektu, zobacz [Jak: Zapisywać wiadomości do i odczytywać wiadomości z bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> jest przydatna, gdy należy przekazać wiele komunikatów do innego składnika, ale ten składnik wymaga tylko najnowszej wartości. Ta klasa jest również przydatna, gdy chcesz emitować wiadomość do wielu składników.  
  
 Poniższy przykład podstawowy <xref:System.Double> księguje <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> wartość obiektu, a następnie odczytuje tę wartość z powrotem z tego obiektu kilka razy. Ponieważ wartości nie <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> są usuwane z obiektów po ich odczytaniu, ta sama wartość jest dostępna za każdym razem.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Aby uzyskać pełny przykład, który <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> pokazuje, jak używać do emisji wiadomości do wielu bloków docelowych, zobacz [Jak: Określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> przypomina <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasę, z tą <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> różnicą, że obiekt może być zapisany tylko raz. Można traktować <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jako podobne do c# [readonly](../../csharp/language-reference/keywords/readonly.md) [(ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) w języku <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Visual Basic), z tą różnicą, że obiekt staje się niezmienne po odebraniu wartości, a nie w budownictwie. Podobnie <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> jak klasa, gdy obiekt docelowy <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> odbiera wiadomość z obiektu, ta wiadomość nie jest usuwany z tego obiektu. W związku z tym wiele obiektów docelowych otrzymują kopię wiadomości. Klasa <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jest przydatna, gdy chcesz propagować tylko pierwszy z wielu komunikatów.  
  
 Poniższy przykład podstawowy <xref:System.String> księguje <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> wiele wartości do obiektu, a następnie odczytuje wartość z powrotem z tego obiektu. Ponieważ <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt może być zapisany tylko jeden <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> raz, po obiekt odbiera wiadomość, odrzuca kolejne wiadomości.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Aby uzyskać pełny przykład, który <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> pokazuje, jak używać do odbierania wartości pierwszej operacji, która kończy się, zobacz [Jak: Odłączyć bloki przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Bloki wykonywania  
 Bloki wykonywania wywołać delegata dostarczonego przez użytkownika dla każdego elementu odebranych danych. Biblioteka przepływu danych TPL zawiera trzy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>typy <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>bloków wykonywania: , , i .  
  
#### <a name="actionblockt"></a>Blok akcji(T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> jest blokiem docelowym, który wywołuje delegata po odebraniu danych. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Obiekt można potraktuować jako pełnomocnika, który uruchamia się asynchronicznie, gdy dane stają się dostępne. Pełnomocnik, który udostępniasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektowi, <xref:System.Action%601> może `System.Func<TInput, Task>`być typu lub typu . W przypadku <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> korzystania <xref:System.Action%601>z obiektu z , przetwarzanie każdego elementu wejściowego jest uważany za zakończone po powrocie pełnomocnika. W przypadku <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> korzystania `System.Func<TInput, Task>`z obiektu z , przetwarzanie każdego elementu wejściowego jest uważany za zakończone tylko po zakończeniu zwracanego <xref:System.Threading.Tasks.Task> obiektu. Za pomocą tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> do synchronicznego i asynchronicznego przetwarzania każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy <xref:System.Int32> księguje <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> wiele wartości w obiekcie. Obiekt <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> drukuje te wartości na konsoli. W tym przykładzie następnie ustawia blok do stanu ukończonego i czeka na zakończenie wszystkich zadań przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Aby uzyskać pełne przykłady, które pokazują, jak używać delegatów z klasą, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> zobacz [Jak: Wykonywanie akcji, gdy blok danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 Klasa <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> przypomina <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> klasę, z tą różnicą, że działa zarówno jako źródło, jak i jako miejsce docelowe. Pełnomocnik, który przekazujesz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> do obiektu zwraca `TOutput`wartość typu . Pełnomocnik, który udostępniasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektowi, `System.Func<TInput, TOutput>` może `System.Func<TInput, Task<TOutput>>`być typu lub typu . W przypadku <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> korzystania `System.Func<TInput, TOutput>`z obiektu z , przetwarzanie każdego elementu wejściowego jest uważany za zakończone po powrocie pełnomocnika. W przypadku <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> korzystania z `System.Func<TInput, Task<TOutput>>`obiektu używanego z , przetwarzanie każdego elementu <xref:System.Threading.Tasks.Task%601> wejściowego jest uważany za zakończone tylko po zakończeniu zwracanego obiektu. Podobnie <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>jak w przypadku , za <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> pomocą tych dwóch mechanizmów, można użyć do synchronicznego i asynchronicznego przetwarzania każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> tworzy obiekt, który oblicza pierwiastek kwadratowy jego danych wejściowych. Obiekt <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> przyjmuje <xref:System.Int32> wartości jako dane <xref:System.Double> wejściowe i generuje wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Aby uzyskać pełne <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> przykłady, które są używane w sieci bloków przepływu danych, który wykonuje przetwarzanie obrazu w aplikacji formularzy systemu Windows, zobacz [Instruktaż: Korzystanie z przepływu danych w aplikacji formularzy systemu Windows](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 Klasa <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> przypomina <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> klasę, z <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> tą różnicą, że generuje zero lub więcej wartości wyjściowych dla każdej wartości wejściowej, a nie tylko jedną wartość wyjściową dla każdej wartości wejściowej. Pełnomocnik, który udostępniasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektowi, `System.Func<TInput, IEnumerable<TOutput>>` może `System.Func<TInput, Task<IEnumerable<TOutput>>>`być typu lub typu . W przypadku <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> korzystania `System.Func<TInput, IEnumerable<TOutput>>`z obiektu z , przetwarzanie każdego elementu wejściowego jest uważany za zakończone po powrocie pełnomocnika. W przypadku <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> korzystania `System.Func<TInput, Task<IEnumerable<TOutput>>>`z obiektu z , przetwarzanie każdego elementu `System.Threading.Tasks.Task<IEnumerable<TOutput>>` wejściowego jest uważany za ukończony tylko po zakończeniu zwracanego obiektu.  
  
 Poniższy przykład podstawowy <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> tworzy obiekt, który dzieli ciągi na ich poszczególnych sekwencji znaków. Obiekt <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> przyjmuje <xref:System.String> wartości jako dane <xref:System.Char> wejściowe i generuje wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Aby uzyskać pełne <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> przykłady, które są używane do tworzenia wielu niezależnych danych wyjściowych dla każdego wejścia w potoku przepływu danych, zobacz [Instruktaż: Tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Stopień równoległości  
 Każdy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> i obiekt buforuje komunikaty wejściowe, dopóki blok jest gotowy do ich przetworzenia. Domyślnie te klasy przetwarzają wiadomości w kolejności, w jakiej są odbierane, po jednej wiadomości naraz. Można również określić stopień <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>równoległości, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> aby włączyć i obiektów do przetwarzania wielu komunikatów jednocześnie. Aby uzyskać więcej informacji na temat równoczesnych wykonywania, zobacz sekcję Określanie stopnia równoległości w dalszej części tego dokumentu. Na przykład, który ustawia stopień równoległości, aby umożliwić blok przepływu danych wykonywania do przetwarzania więcej niż jeden komunikat naraz, zobacz [Jak: Określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Podsumowanie typów delegatów  
 W poniższej tabeli podsumowano typy delegatów, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>które <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> można podać do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, i obiekty. W tej tabeli określono również, czy typ delegata działa synchronicznie, czy asynchronicznie.  
  
|Typ|Synchroniczny typ delegata|Asynchroniczny typ delegata|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Można również użyć wyrażeń lambda podczas pracy z typami bloków wykonywania. Na przykład, który pokazuje, jak używać wyrażenia lambda z blokiem wykonywania, zobacz [Jak: Wykonywanie akcji, gdy blok przepływu danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Grupowanie bloków  
 Grupowanie bloków łączy dane z jednego lub większej liczby źródeł i pod różnymi ograniczeniami. Biblioteka przepływu danych TPL zawiera trzy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>typy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>bloków sprzężenia: , , i .  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> łączy zestawy danych wejściowych, które są znane jako partie, w tablice danych wyjściowych. Rozmiar każdej partii można określić podczas <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> tworzenia obiektu. Gdy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt odbiera określoną liczbę elementów wejściowych, asynchronicznie propaguje tablicę, która zawiera te elementy. Jeśli <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt jest ustawiony na stan ukończony, ale nie zawiera wystarczającej ilości elementów do utworzenia partii, propaguje się tablica końcowa, która zawiera pozostałe elementy wejściowe.  
  
 Klasa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> działa w trybie *chciwym* lub *niechciwym.* W trybie chciwym, który <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> jest domyślny, obiekt akceptuje każdą wiadomość, która jest oferowana i propaguje tablicę po odebraniu określonej liczby elementów. W trybie niechciwym <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt odracza wszystkie wiadomości przychodzące, dopóki wystarczająca liczba źródeł nie oferuje wiadomości do bloku w celu utworzenia partii. Tryb chciwy zazwyczaj działa lepiej niż tryb niechciwy, ponieważ wymaga mniej narzutów przetwarzania. Można jednak użyć trybu niechcistego, gdy trzeba koordynować zużycie z wielu źródeł w sposób niepodzielny. Określ tryb niechciwy, ustawiając <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> `False` parametr w `dataflowBlockOptions` konstruktorze.  
  
 Poniższy przykład podstawowy <xref:System.Int32> księguje <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> kilka wartości do obiektu, który zawiera dziesięć elementów w partii. Aby zagwarantować, że wszystkie wartości <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>propagowane <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> z , w tym przykładzie wywołuje metodę. Metoda <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> ustawia <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt do stanu ukończonego, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> zatem obiekt propaguje wszystkie pozostałe elementy jako ostateczną partię.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Aby uzyskać pełny <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> przykład, który używa do poprawy wydajności operacji wstawiania bazy danych, zobacz [Instruktaż: Za pomocą BatchBlock i BatchedJoinBlock do zwiększenia wydajności](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 I <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> klas zbierać elementy wejściowe <xref:System.Tuple%602?displayProperty=nameWithType> <xref:System.Tuple%603?displayProperty=nameWithType> i propagacji obecnie lub obiektów, które zawierają te elementy. I <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> klasy nie dziedziczą z <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Zamiast tego zapewniają <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>właściwości, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>i , które implementują .  
  
 Podobnie <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> jak <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> , i działają w trybie chciwy lub niechciwy. W trybie chciwym, który <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> jest domyślny, lub obiekt akceptuje każdą wiadomość, która jest oferowana i propaguje krotkę po każdym z jego obiektów docelowych odbiera co najmniej jedną wiadomość. W trybie <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> niechciwym <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> lub obiekt odracza wszystkie przychodzące wiadomości, dopóki wszystkie obiekty docelowe nie zostaną zaoferowane dane, które są wymagane do utworzenia krotki. W tym momencie blok angażuje się w dwufazowy protokół zatwierdzania, aby atomically pobrać wszystkie wymagane elementy ze źródeł. To odroczenie umożliwia innej jednostce korzystanie z danych w międzyczasie, aby umożliwić całego systemu do przodu postępu.  
  
 W poniższym podstawowym przykładzie przedstawiono <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> przypadek, w którym obiekt wymaga wielu danych do obliczenia wartości. W tym <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> przykładzie tworzy <xref:System.Int32> obiekt, <xref:System.Char> który wymaga dwóch wartości i wartości do wykonania operacji arytmetycznej.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Aby uzyskać pełny <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> przykład, który używa obiektów w trybie niechciwym do współdzielenia zasobu, zobacz [Jak: Użyj JoinBlock do odczytu danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 I <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> klasy zbierać partie elementów wejściowych `System.Tuple(IList(T1), IList(T2))` `System.Tuple(IList(T1), IList(T2), IList(T3))` i propagacji lub obiektów, które zawierają te elementy. Pomyśl <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> o jako <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> połączenie <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>i . Określ rozmiar każdej partii podczas <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> tworzenia obiektu. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>zapewnia również <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> właściwości, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, które implementują . Gdy określona liczba elementów wejściowych są odbierane <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> ze wszystkich obiektów docelowych, `System.Tuple(IList(T1), IList(T2))` obiekt asynchronicznie propaguje się obiekt, który zawiera te elementy.  
  
 Poniższy przykład podstawowy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> tworzy obiekt, <xref:System.Int32> który przechowuje wyniki, <xref:System.Exception> wartości i błędy, które są obiektami. W tym przykładzie wykonuje wiele operacji <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> i zapisuje wyniki <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> do właściwości <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> i błędy do właściwości obiektu. Ponieważ liczba udanych i nieudanych operacji jest <xref:System.Collections.Generic.IList%601> nieznana z wyprzedzeniem, obiekty umożliwiają każdemu obiektowi docelowemu otrzymywanie wartości zerowych lub więcej.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Aby uzyskać pełny <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> przykład, który używa do przechwytywania zarówno wyniki i wszelkie wyjątki, które występują podczas odczytu programu z bazy danych, zobacz [Instruktaż: Za pomocą BatchBlock i BatchedJoinBlock, aby zwiększyć wydajność](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  

## <a name="configuring-dataflow--block-behavior"></a>Konfigurowanie zachowania bloku przepływu danych  
 Można włączyć dodatkowe opcje, <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> udostępniając obiekt do konstruktora typów bloków przepływu danych. Te opcje kontrolują zachowanie, takie harmonogram, który zarządza podstawowym zadaniem i stopień równoległości. Ma <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> również pochodne typy, które określają zachowanie, które jest specyficzne dla niektórych typów bloków przepływu danych. W poniższej tabeli podsumowano, który typ opcji jest skojarzony z każdym typem bloku przepływu danych.  
  
|Typ bloku przepływu danych|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>Typu|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Poniższe sekcje zawierają dodatkowe informacje na temat ważnych rodzajów <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>opcji <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>bloku <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> przepływu danych, które są dostępne za pośrednictwem programu , i klas.  
  
### <a name="specifying-the-task-scheduler"></a>Określanie harmonogramu zadań  
 Każdy wstępnie zdefiniowany blok przepływu danych używa mechanizmu planowania zadań TPL do wykonywania działań, takich jak propagowanie danych do obiektu docelowego, odbieranie danych ze źródła i uruchamianie delegatów zdefiniowanych przez użytkownika, gdy dane staną się dostępne. <xref:System.Threading.Tasks.TaskScheduler>jest klasą abstrakcyjną, która reprezentuje harmonogram zadań, który kolejkuje zadania na wątki. Domyślny harmonogram zadań <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, używa <xref:System.Threading.ThreadPool> klasy do kolejki i wykonywania pracy. Można zastąpić domyślnego harmonogramu zadań, <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> ustawiając właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Gdy ten sam harmonogram zadań zarządza wieloma blokami przepływu danych, może wymuszać zasady między nimi. Na przykład jeśli wiele bloków przepływu danych są skonfigurowane do <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> kierowania wyłączne harmonogram tego samego obiektu, wszystkie prace, które działa w tych bloków jest serializowany. Podobnie jeśli te bloki są skonfigurowane do docelowego równoczesnych harmonogram tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektu i że harmonogram jest skonfigurowany do maksymalnego poziomu współbieżności, wszystkie prace z tych bloków jest ograniczona do tej liczby równoczesnych operacji. Na przykład, który <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> używa klasy, aby umożliwić operacje odczytu występuje równolegle, ale operacje zapisu występuje wyłącznie wszystkich innych operacji, zobacz [Jak: Określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Aby uzyskać więcej informacji na temat harmonogramów <xref:System.Threading.Tasks.TaskScheduler> zadań w TPL, zobacz temat klasy.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Określanie stopnia równoległości  
 Domyślnie trzy typy bloków wykonywania, które zapewnia <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>biblioteka <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>przepływu danych TPL, i , przetwarzają po jednej wiadomości naraz. Te typy bloków przepływu danych przetwarzają również wiadomości w kolejności, w jakiej są odbierane. Aby włączyć te bloki przepływu danych do <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> przetwarzania komunikatów jednocześnie, należy ustawić właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Domyślną wartością <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> jest 1, co gwarantuje, że blok przepływu danych przetwarza jeden komunikat naraz. Ustawienie tej właściwości na wartość większą niż 1 umożliwia blokprzepływu danych do przetwarzania wielu komunikatów jednocześnie. Ustawienie tej <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> właściwości, aby umożliwiać podstawowego harmonogramu zadań do zarządzania maksymalny stopień współbieżności.  
  
> [!IMPORTANT]
> Po określeniu maksymalnego stopnia równoległości, który jest większy niż 1, wiele wiadomości są przetwarzane jednocześnie i dlatego wiadomości mogą nie być przetwarzane w kolejności, w jakiej są odbierane. Kolejność, w jakiej komunikaty są wyprowadzane z bloku jest jednak ten sam, w którym są odbierane.  
  
 Ponieważ <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwość reprezentuje maksymalny stopień równoległości, blok przepływu danych może być wykonywany z mniejszym stopniem równoległości niż określono. Blok przepływu danych może używać mniejszego stopnia równoległości, aby spełnić jego wymagania funkcjonalne lub ponieważ brakuje dostępnych zasobów systemowych. Blok przepływu danych nigdy nie wybiera więcej równoległości niż określono.  
  
 Wartość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwości jest wyłącznym dla każdego obiektu bloku przepływu danych. Na przykład jeśli cztery obiekty bloku przepływu danych każdy określić 1 dla maksymalnego stopnia równoległości, wszystkie cztery obiekty bloku przepływu danych mogą potencjalnie działać równolegle.  
  
 Na przykład, który ustawia maksymalny stopień równoległości, aby umożliwić długie operacje występować równolegle, zobacz [Jak: Określić stopień równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Określanie liczby komunikatów na zadanie  
 Wstępnie zdefiniowane typy bloków przepływu danych używają zadań do przetwarzania wielu elementów wejściowych. Pomaga to zminimalizować liczbę obiektów zadań, które są wymagane do przetwarzania danych, co umożliwia aplikacjom wydajniejsze uruchamianie. Jednak gdy zadania z jednego zestawu bloków przepływu danych przetwarzają dane, zadania z innych bloków przepływu danych mogą wymagać oczekiwania na czas przetwarzania przez kolejkowanie wiadomości. Aby umożliwić większą uczciwość między <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> zadaniami przepływu danych, należy ustawić właściwość. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>ustawiona na , co jest ustawieniem domyślnym, zadanie używane przez blok przepływu danych przetwarza tyle komunikatów, ile jest dostępnych. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest ustawiona na <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>wartość inną niż , blok przepływu danych <xref:System.Threading.Tasks.Task> przetwarza co najwyżej tę liczbę komunikatów na obiekt. Chociaż ustawienie <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwości może zwiększyć uczciwość między zadaniami, może spowodować, że system może utworzyć więcej zadań niż jest to konieczne, co może zmniejszyć wydajność.  
  
### <a name="enabling-cancellation"></a>Włączanie anulowania  
 TPL zapewnia mechanizm, który umożliwia zadania koordynować anulowanie w sposób współpracy. Aby włączyć bloki przepływu danych do udziału <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> w tym mechanizmie anulowania, należy ustawić właściwość. Gdy <xref:System.Threading.CancellationToken> ten obiekt jest ustawiony na stan anulowane, wszystkie bloki przepływu danych, które monitorują to token zakończyć wykonanie ich bieżącego elementu, ale nie rozpocząć przetwarzanie kolejnych elementów. Te bloki przepływu danych również wyczyścić wszystkie buforowane komunikaty, połączenia wydania do dowolnego bloku źródłowego i docelowego i przejście do stanu anulowanego. Przechodząc do stanu anulowanego, <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwość ma <xref:System.Threading.Tasks.Task.Status%2A> właściwość <xref:System.Threading.Tasks.TaskStatus.Canceled>ustawioną na , chyba że wystąpił wyjątek podczas przetwarzania. W takim <xref:System.Threading.Tasks.Task.Status%2A> przypadku jest <xref:System.Threading.Tasks.TaskStatus.Faulted>ustawiona na .  
  
 Na przykład, który pokazuje, jak używać anulowania w aplikacji formularzy systemu Windows, zobacz [Jak: Anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Aby uzyskać więcej informacji na temat anulowania w TPL, zobacz [Anulowanie zadań](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Określanie chciwego w porównaniu do zachowania niechciwego  
 Kilka typów bloków przepływu danych grupowania może działać w trybie *chciwym* lub *niechciwym.* Domyślnie wstępnie zdefiniowane typy bloków przepływu danych działają w trybie chciwości.  
  
 W przypadku typów <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>bloków sprzężenia, takich jak , tryb chciwy oznacza, że blok natychmiast akceptuje dane, nawet jeśli odpowiednie dane, z którymi można dołączyć, nie są jeszcze dostępne. Tryb niechciwy oznacza, że blok odracza wszystkie przychodzące wiadomości, dopóki jeden z nich nie będzie dostępny dla każdego z jego celów, aby ukończyć sprzężenie. Jeśli którykolwiek z odłożonych wiadomości nie są już dostępne, blok sprzężenia zwalnia wszystkie przełożone wiadomości i ponownie uruchamia proces. Dla <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> klasy, chciwy i niechciwy zachowanie jest podobny, z tą <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> różnicą, że w trybie niechciwy, obiekt odracza wszystkie przychodzące wiadomości, dopóki nie są dostępne wystarczająco z różnych źródeł, aby zakończyć partii.  
  
 Aby określić tryb niechciwy dla bloku <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> `False`przepływu danych, ustaw wartość . Na przykład, który pokazuje, jak używać trybu niechciwego, aby umożliwić wiele bloków sprzężenia do bardziej efektywnego udostępniania źródła danych, zobacz [Jak: Użyj JoinBlock do odczytu danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).

## <a name="custom-dataflow-blocks"></a>Niestandardowe bloki przepływu danych  
 Chociaż biblioteka przepływu danych TPL zawiera wiele wstępnie zdefiniowanych typów bloków, można utworzyć dodatkowe typy bloków, które wykonują zachowanie niestandardowe. Zaimplementuj <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> lub <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsów <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> bezpośrednio lub użyć metody do tworzenia złożonego bloku, który hermetyzuje zachowanie istniejących typów bloków. Przykłady, które pokazują, jak zaimplementować niestandardowe funkcje bloku przepływu danych, zobacz [Instruktaż: Tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).

## <a name="related-topics"></a>Tematy pokrewne  
  
|Tytuł|Opis|  
|-----------|-----------------|  
|[Instrukcje: zapisywanie komunikatów w bloku przepływu danych i odczytywanie ich z tego bloku](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Pokazuje, jak pisać wiadomości do i <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> odczytywać wiadomości z obiektu.|  
|[Instrukcje: implementowanie wzorca przepływu danych producent — konsument](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Opisuje sposób używania modelu przepływu danych do implementowania wzorca producent-konsument, gdzie producent wysyła wiadomości do bloku przepływu danych, a konsument odczytuje wiadomości z tego bloku.|  
|[Instrukcje: wykonywanie akcji w przypadku odebrania danych przez blok przepływu danych](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Opisuje sposób dostarczania pełnomocników do typów <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>bloków <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>przepływu danych wykonywania, , , i .|  
|[Przewodnik: tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Opisuje sposób tworzenia potoku przepływu danych, który pobiera tekst z sieci Web i wykonuje operacje na tym tekście.|  
|[Instrukcje: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Pokazuje, jak użyć <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> metody, aby odłączyć blok docelowy od jego źródła po źródło oferuje komunikat do obiektu docelowego.|  
|[Przewodnik: korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Pokazuje, jak utworzyć sieć bloków przepływu danych, które wykonują przetwarzanie obrazu w aplikacji Formularzy systemu Windows.|  
|[Porady: Anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Pokazuje, jak używać anulowania w aplikacji formularzy systemu Windows.|  
|[Instrukcje: korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|W tym artykule <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> wyjaśniono, jak używać klasy do wykonywania operacji, gdy dane są dostępne z wielu źródeł i jak używać trybu niechciwego, aby umożliwić wiele bloków sprzężenia do bardziej efektywnego udostępniania źródła danych.|  
|[Instrukcje: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|W tym artykule <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> opisano, jak ustawić właściwość, aby włączyć blok przepływu danych wykonywania do przetwarzania więcej niż jeden komunikat naraz.|  
|[Instrukcje: określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Pokazuje, jak skojarzyć określony harmonogram zadań podczas korzystania z przepływu danych w aplikacji.|  
|[Przewodnik: poprawa wydajności przy użyciu klas BatchBlock i BatchedJoinBlock](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Opisuje sposób używania <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> klasy w celu zwiększenia wydajności operacji wstawiania bazy danych i używania <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> klasy do przechwytywania zarówno wyników, jak i wyjątków występujących podczas odczytu przez program z bazy danych.|  
|[Przewodnik: tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Demonstruje dwa sposoby tworzenia typu bloku przepływu danych, który implementuje zachowanie niestandardowe.|  
|[Biblioteka zadań równoległych (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Wprowadza TPL, biblioteki, która upraszcza równoległe i równoczesne programowania w aplikacjach .NET Framework.|
