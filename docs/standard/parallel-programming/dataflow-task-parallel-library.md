---
title: Przepływ danych (Biblioteka zadań równoległych)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: d44ec0e0601383133e6c59e44cd81031918d4b6d
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/14/2018
ms.locfileid: "45619071"
---
# <a name="dataflow-task-parallel-library"></a>Przepływ danych (Biblioteka zadań równoległych)
<a name="top"></a> Biblioteka zadań równoległych (TPL) zapewnia składników przepływu danych, aby zwiększyć niezawodność aplikacji obsługujących współbieżności. Te składniki przepływu danych są nazywane zbiorczo *Biblioteka przepływu danych TPL*. Ten model przepływu danych promuje aktorów programowania przez dostarczanie komunikatów w trakcie przekazywania dla gruboziarnistych przepływu danych i ich przetwarzanie potokowe zadania. Składniki przepływu danych kompilacji dla typów i planowania infrastruktury TPL i integracja z obsługą języka C#, Visual Basic i F # w programowaniu asynchronicznym. Te składniki przepływu danych są przydatne, jeśli masz wiele operacji, które muszą asynchronicznie komunikować się ze sobą, lub gdy chcesz przetwarzania danych, gdy stanie się dostępny. Na przykład rozważmy aplikację, która przetwarza dane obrazu z kamery internetowej. Za pomocą modelu przepływu danych, aplikacja może przetwarzać ramki obrazu po ich udostępnieniu. Jeśli aplikacja zwiększa klatek, na przykład, wykonując światła redukcji korekty lub efektu czerwonych utworzeniem *potoku* składników przepływu danych. Każdy etap potoku może używać więcej funkcji równoległości gruboziarnistych, takich jak funkcje, które są dostarczane przez TPL w celu przekształcenia obrazu.  
  
 Ten dokument zawiera omówienie Biblioteka przepływu danych TPL. Opisano w nim modelu programowania, typów bloków przepływu danych wstępnie zdefiniowanych i sposobie konfigurowania bloków przepływu danych pod kątem wymagań dotyczących aplikacji.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]
  
 Ten dokument zawiera następujące sekcje:  
  
-   [Model programowania](#model)  
  
-   [Typy wstępnie zdefiniowanych bloków przepływu danych](#predefined_types)  
  
-   [Konfigurowanie zachowania bloku przepływu danych](#behavior)  
  
-   [Niestandardowych bloków przepływu danych](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Model programowania  
 Biblioteka przepływu danych TPL stanowi podstawę do wiadomości, przekazywanie i przekształcają mocy procesora CPU i/O z wieloma operacjami we aplikacji, które mają wysokiej przepływności i małego opóźnienia. Oferuje on również jawną kontrolę nad tym jak dane są buforowane i kręci się wokół systemie. Aby lepiej zrozumieć modelu programowania przepływu danych, należy wziąć pod uwagę aplikacji asynchronicznie wczytuje obrazy z dysku i tworzy złożonego tych obrazów. Tradycyjne modele programowania zwykle wymagają używać wywołań zwrotnych i obiekty synchronizacji, takie jak blokad, do koordynowania zadań i uzyskiwania dostępu do udostępnionych danych. Za pomocą modelu programowania przepływu danych, można utworzyć obiektów przepływu danych, które przetwarzania obrazów, ponieważ są odczytywane z dysku. W ramach modelu przepływu danych możesz deklarować, sposobu obsługi danych, gdy stanie się dostępny, a także wszelkie zależności między danymi. Ponieważ środowisko uruchomieniowe zarządza zależności między danymi, często można uniknąć konieczności synchronizowania dostępu do udostępnionych danych. Ponadto ponieważ środowisko uruchomieniowe planuje pracę sądząc po przybyciu asynchronicznego danych, przepływu danych może poprawić czas odpowiedzi i przepływności efektywnie zarządzając bazowego wątków. Na przykład, który używa modelu programowania przepływu danych do zaimplementowania przetwarzania obrazów w aplikacji Windows Forms, zobacz [wskazówki: Korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Źródła i obiekty docelowe  
 Biblioteka przepływu danych TPL składa się z *bloków przepływu danych*, które to dane struktury tego buforu i przetwarzanie danych. Używanie biblioteki TPL definiuje trzy rodzaje bloków przepływu danych: *źródła bloki*, *bloków docelowych*, i *bloki propagator*. Blok źródłowy działa jako źródło danych i mogą być odczytywane z. Blok docelowy działa jako odbiornik danych i mogą być zapisywane. Blok propagatora działa jako blok źródłowy i blok docelowy może odczytywać i zapisane. Definiuje TPL <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interfejsu do reprezentowania źródeł, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> do reprezentowania obiektów docelowych, a <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> do reprezentowania propagators. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> dziedziczy z obu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Biblioteka przepływu danych TPL zawiera kilka typów bloków przepływu danych wstępnie zdefiniowanych, które implementują <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, i <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfejsów. Te typy bloku przepływu danych są opisane w niniejszym dokumencie, w sekcji [wstępnie zdefiniowanych typów bloków przepływu danych](#predefined_types).  
  
### <a name="connecting-blocks"></a>Łączenie bloków  
 Możesz nawiązać połączenie bloków przepływu danych formularza *potoki*, służą do liniowej sekwencje bloków przepływu danych lub *sieci*, służą do wykresów bloków przepływu danych. Potoki to jeden formularz sieci. W potoku lub w sieci źródeł asynchronicznie propagowanie danych do celów danych staje się dostępna. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> Metoda łączy bloku przepływu danych źródłowych do bloku docelowego. Źródłem może być połączony z zero lub więcej obiektów docelowych; obiekty docelowe mogą być połączone z zero lub więcej źródeł. Można dodać lub usunąć jednocześnie bloków przepływu danych do lub z potoku lub sieci. Blok przepływu wstępnie zdefiniowanych typów obsługują wszystkie aspekty bezpieczeństwo wątków łączenie i rozłączanie.  
  
 Dla przykładu, który łączy się z bloków przepływu danych w celu utworzenia podstawowy potok, zobacz [wskazówki: tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Na przykład, która łączy się z bloków przepływu danych w celu utworzenia bardziej złożonych sieci, zobacz [wskazówki: Korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Na przykład, który wstrzymuje docelowym ze źródła po źródła oferuje obiektu docelowego komunikatu, zobacz [porady: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrowanie  
 Gdy wywołujesz <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> metodę połączenia źródła do docelowego podasz delegata, która określa, czy blok docelowy akceptuje lub odrzuca komunikat na podstawie wartości tego komunikatu. Ten mechanizm filtrowania jest to wygodny sposób, aby zagwarantować, że blok przepływu danych odbiera tylko niektóre wartości. Dla większości typów bloków przepływu danych wstępnie zdefiniowane Jeśli blok źródłowy jest połączona wiele bloków docelowych, gdy blok docelowy odrzuca wiadomości, źródło oferuje ten komunikat do następnego obiektu docelowego. Kolejność, w którym źródłem oferuje wiadomości do celów jest zdefiniowana przez źródło i mogą się różnić zależnie od typu źródłowego. Większość typów bloków źródła Zatrzymaj oferty komunikat, gdy jeden element docelowy zaakceptuje ten komunikat. Jedynym wyjątkiem od tej reguły jest <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasy, która oferuje każdy komunikat do wszystkich celów, nawet jeśli niektóre cele Odrzuć komunikat. Dla przykładu, który używa funkcji filtrowania do przetwarzania wyłącznie komunikatów, zobacz [wskazówki: Korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Ponieważ każdy typu bloku przepływu danych wstępnie zdefiniowanego źródła gwarantuje, że komunikaty są propagowane się w kolejności, w której zostały odebrane, każdy komunikat musi odczytywać blok źródłowy przed blok źródłowy może przetworzyć następny komunikat. W związku z tym podczas nawiązywania połączenia ze źródłem wiele elementów docelowych używasz filtrowania, upewnij się, że tego bloku co najmniej jeden element docelowy odbiera każdego komunikatu. W przeciwnym razie aplikacja może zakleszczenie.  
  
### <a name="message-passing"></a>Przekazywanie komunikatów  
 Model programowania przepływu danych jest powiązany z koncepcji *przekazywania komunikatów*, gdzie niezależnie od składników programu komunikować się ze sobą, wysyłając komunikaty. Jednym ze sposobów Propagacja komunikatów między składnikami aplikacji jest wywołanie <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> metody, aby wysyłać komunikaty do wpisu bloków przepływu danych docelowych (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> działa synchronicznie; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> działa asynchronicznie) i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> metody, aby odbierać komunikaty z bloków źródła. Metody te można połączyć z potoki przepływu danych lub sieci, wysyłając dane wejściowe do węzła głównego (blok docelowy), i odbierać dane wyjściowe z terminalu węzeł potoku lub terminalu węzłów sieci (jeden lub więcej bloków źródła). Można również użyć <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> metodę w celu odczytania od pierwszego z podanych źródeł, które ma dostępne dane i wykonywać działania na tych danych.  
  
 Bloków źródła oferują dane do bloków docelowych, wywołując <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> metody. Blok docelowy odpowiada na komunikat oferowane w jeden z trzech sposobów: możesz zaakceptować komunikat, odrzucić komunikat lub odroczyć wiadomości. Gdy element docelowy akceptuje komunikat <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Gdy element docelowy odrzuci komunikat <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Gdy element docelowy wymaga ona nie będzie już otrzymywać żadnych komunikatów ze źródła, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Typów bloków wstępnie zdefiniowanego źródła nie oferują wiadomości do połączonych elementów docelowych, po odebraniu zwracana wartość i automatycznie odłączyć, z takich miejsc docelowych.  
  
 Gdy blok docelowy odłoży komunikat do późniejszego użycia <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Blok docelowy, który odłoży komunikat później może wywołać <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> metody Zarezerwuj oferowane wiadomości. W tym momencie komunikat jest nadal dostępne i mogą być używane przez blok docelowy lub komunikat jest już zajęta przez inny obiekt docelowy. Gdy blok docelowy nowszego wymaga wiadomości lub nie potrzebuje już komunikat, wywołuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> metody, odpowiednio. Zastrzeżenie komunikatu jest zwykle używana przez typów bloków przepływu danych, które działają w trybie niezachłanne. Tryb zachłanne inne niż zostało wyjaśnione w dalszej części tego dokumentu. Zamiast zarezerwowanie odroczone wiadomości, można również użyć bloku docelowego <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> metoda próbuje bezpośrednio korzystać odroczone wiadomości.  
  
### <a name="dataflow-block-completion"></a>Uzupełnianie bloku przepływu danych  
 Bloków przepływu danych obsługują również pojęcie *uzupełniania*. Blok przepływu danych, który jest w stanie ukończone nie wykonuje żadnych dalszych działań. Każdy blok przepływu danych ma skojarzoną <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> obiektu, nazywany *ukończenia zadania*, który reprezentuje stan realizacji bloku. Ponieważ możesz poczekać, aż <xref:System.Threading.Tasks.Task> obiektu, aby zakończyć, za pomocą zadań zakończenia możesz poczekać, aż jeden lub więcej węzłów końcowych przepływu danych sieciowych na zakończenie. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> Interfejs definiuje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metody, która informuje bloku przepływu danych żądania na jego zakończenie, a <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwość, która zwraca zadanie zakończenia bloku przepływu danych. Zarówno <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> dziedziczą <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfejsu.  
  
 Istnieją dwa sposoby ustalić, czy bloku przepływu danych zostało ukończone bez błędów, napotkała co najmniej jeden błąd lub zostało anulowane. Pierwszy sposób polega na wywołaniu <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody na ukończenie zadania w `try` - `catch` bloku (`Try` - `Catch` w języku Visual Basic). Poniższy przykład tworzy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt, który zgłasza <xref:System.ArgumentOutOfRangeException> jeśli jego wartość wejściowa jest mniejsza niż zero. <xref:System.AggregateException> jest zgłaszany, gdy ten przykład wywołuje <xref:System.Threading.Tasks.Task.Wait%2A> do ukończenia zadania. <xref:System.ArgumentOutOfRangeException> Odbywa się za pośrednictwem <xref:System.AggregateException.InnerExceptions%2A> właściwość <xref:System.AggregateException> obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 Ten przykład pokazuje przypadek, w którym wyjątek przechodzi nieobsługiwany w delegacie wykonanie bloku przepływu danych. Firma Microsoft zaleca obsługi wyjątków w treści tych bloków. Jednak jeśli nie jest możliwe to zrobić, blok zachowuje się tak, jakby zostało anulowane, a nie przetwarzają komunikatów przychodzących.  
  
 Gdy blok przepływu danych została anulowana jawnie <xref:System.AggregateException> obiekt zawiera <xref:System.OperationCanceledException> w <xref:System.AggregateException.InnerExceptions%2A> właściwości. Aby uzyskać więcej informacji na temat anulowania przepływu danych, zobacz [Włączanie anulowania](#enabling-cancellation) sekcji.  
  
 Drugim sposobem ustalenia stanu ukończenia bloku przepływu danych jest celu to kontynuacja ukończenia zadania lub używać asynchronicznych funkcji języka C# i Visual Basic asynchronicznego oczekiwania na ukończenie zadania. Delegat, który możesz udostępnić <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metoda przyjmuje <xref:System.Threading.Tasks.Task> obiekt, który reprezentuje zadania poprzedzającego. W przypadku właściwości <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwości delegata kontynuacji pobiera samo zadanie ukończenia. Poniższy przykład przypomina poprzedni, z tą różnicą, że użyto także <xref:System.Threading.Tasks.Task.ContinueWith%2A> metodę, aby utworzyć zadanie kontynuacji, który wyświetla stan ogólnej operacji przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Można również użyć właściwości takich jak <xref:System.Threading.Tasks.Task.IsCanceled%2A> w treści zadania kontynuacji, aby określić dodatkowe informacje na temat stanu ukończenia bloku przepływu danych. Aby uzyskać więcej informacji dotyczących kontynuacji zadań i ich wzajemnymi anulowania i obsługi błędów, zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md), i [ Obsługa wyjątków](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [[przejdź do góry](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Typy wstępnie zdefiniowanych bloków przepływu danych  
 Biblioteka przepływu danych TPL zawiera kilka typów bloków przepływu danych wstępnie zdefiniowane. Te typy są podzielone na trzy kategorie: *buforowania bloki*, *bloki wykonywania*, i *grupowanie bloki*. W poniższych sekcjach opisano typy bloku, które tworzą te kategorie.  
  
### <a name="buffering-blocks"></a>Buforowanie bloków  
 Bloki buforowania przechowywania danych na potrzeby używania przez konsumenci danych. Biblioteka przepływu danych TPL udostępnia trzy buforowania typów bloków: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Klasa reprezentuje strukturę ogólnego przeznaczenia komunikatów asynchronicznych. Ta klasa przechowuje imię w pierwszej FIFO kolejki komunikatów, które mogą być zapisywane przez wiele źródeł lub odczytywać przez wiele elementów docelowych. Gdy obiekt docelowy otrzymuje komunikat z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, ten komunikat zostanie usunięty z kolejki komunikatów. W związku z tym mimo że <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiekt może mieć wiele elementów docelowych, tylko jeden element docelowy będzie otrzymywać każdego komunikatu. <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Klasy jest przydatne w przypadku, gdy chcesz przekazać wiele wiadomości do innego składnika i ten składnik musi otrzymać bit każdego komunikatu.  
  
 Poniższy przykład podstawowy publikuje kilka <xref:System.Int32> wartości <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, a następnie odczytuje wartości z kopii tego obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Aby uzyskać kompletny przykład, który pokazuje, jak pisać wiadomości do danych i odczytywanie ich z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, zobacz [jak: wiadomości do zapisu i odczytu komunikatów z bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Klasy jest przydatne w przypadku, gdy trzeba przekazać wiele wiadomości do innych składników, ale ten składnik wymaga tylko najnowszą wartość. Ta klasa jest również przydatne, jeśli chcesz wysyłać komunikat do wielu składników.  
  
 Następujące wpisy na przykład podstawowy <xref:System.Double> wartość <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektu, a następnie odczytów, które wartość z powrotem z tego obiektu kilka razy. Ponieważ wartości nie są usuwane z <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektów po są odczytywane, tę samą wartość jest dostępna zawsze.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Pełny przykład, który demonstruje sposób używania <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> wysyłać komunikat do bloków docelowych wielu, zobacz [porady: Określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Klasa przypomina <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasy, chyba że <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektów mogą być zapisywane tylko raz. Można potraktować <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jako zbliżone do języka C# [tylko do odczytu](~/docs/csharp/language-reference/keywords/readonly.md) ([tylko do odczytu](~/docs/visual-basic/language-reference/modifiers/readonly.md) w języku Visual Basic) słowa kluczowego, chyba że <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt staje się niezmienne, po otrzymaniu wartości zamiast na konstrukcja. Podobnie jak <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasy, gdy obiekt docelowy odbiera wiadomości z <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektu, ten komunikat nie zostanie usunięta z tego obiektu. W związku z tym wiele elementów docelowych otrzymać kopię wiadomości. <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Klasy jest przydatne w przypadku, gdy chcesz Propagacja tylko pierwszy z wielu wiadomości.  
  
 Poniższy przykład podstawowy publikuje wielu <xref:System.String> wartości <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektu, a następnie odczytuje wartość z powrotem z tego obiektu. Ponieważ <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektów mogą być zapisywane jeden raz, po <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt otrzymuje komunikat, odrzuca on kolejnych komunikatów.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Aby uzyskać kompletny przykład, który demonstruje sposób skorzystania <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> aby otrzymać wartość pierwszą operacją, która zakończy się, zobacz [porady: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Blokuje wykonanie  
 Bloki wykonywania wywołania delegata dostarczone przez użytkownika dla każdego z nich odebranych danych. Biblioteka przepływu danych TPL udostępnia trzy typy bloku wykonywania: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Klasa jest blok docelowy, który wywołuje delegata, po odebraniu danych. Traktować <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu jako delegat, który jest uruchamiany asynchronicznie, gdy dane będą dostępne. Delegat, który możesz udostępnić <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt może być typu <xref:System.Action%601> lub typ `System.Func<TInput, Task>`. Kiedy używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt z <xref:System.Action%601>, przetwarzania każdego elementu wejściowego jest uznawane za wykonane po powrocie delegata. Kiedy używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt z `System.Func<TInput, Task>`, przetwarzania każdego elementu wejściowego jest uznawany za ukończone tylko wtedy, gdy zwrócony <xref:System.Threading.Tasks.Task> obiektu zostało zakończone. Za pomocą tych dwóch mechanizmów, możesz użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> synchroniczne i asynchroniczne przetwarzania każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy publikuje wielu <xref:System.Int32> wartości <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Wydruk obiektu te wartości do konsoli. Następnie, w tym przykładzie ustawia blok do stanu ukończenia i czeka na zakończenie wszystkich zadań przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Kompletne przykłady pokazujące, jak używać obiektów delegowanych z <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> klasy, zobacz [jak: wykonywać akcji podczas przepływu danych Blokuj odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock (tWEJŚCIE, tWYJŚCIE)  
 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> Klasa przypomina <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> klasy, z tą różnicą, że działa ona jako oba źródła i elementu docelowego. Delegat, który jest przekazywany do <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> zwraca wartość typu `TOutput`. Delegat, który możesz udostępnić <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt może być typu `System.Func<TInput, TOutput>` lub typ `System.Func<TInput, Task<TOutput>>`. Kiedy używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt z `System.Func<TInput, TOutput>`, przetwarzania każdego elementu wejściowego jest uznawane za wykonane po powrocie delegata. Kiedy używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt użyty z `System.Func<TInput, Task<TOutput>>`, przetwarzania każdego elementu wejściowego jest uznawany za ukończone tylko wtedy, gdy zwrócony <xref:System.Threading.Tasks.Task%601> obiektu zostało zakończone. Podobnie jak w przypadku <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, korzystając z tych dwóch mechanizmów, możesz użyć <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> synchroniczne i asynchroniczne przetwarzania każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt, który oblicza pierwiastek kwadratowy danych wejściowych. <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> Przyjmuje obiekt <xref:System.Int32> wartości jako dane wejściowe i generuje <xref:System.Double> wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Kompletne przykłady, których używa <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> w sieci bloków przepływu danych, który wykonuje przetwarzanie obrazów w aplikacji Windows Forms, zobacz [wskazówki: Korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock (tWEJŚCIE, tWYJŚCIE)  
 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> Klasa przypomina <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> klasy, chyba że <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> tworzy zero lub więcej wartości danych wyjściowych dla każdej wejściowej wartości, zamiast tylko jedną wartość dla każdej wartości wejściowe w danych wyjściowych. Delegat, który możesz udostępnić <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt może być typu `System.Func<TInput, IEnumerable<TOutput>>` lub typ `System.Func<TInput, Task<IEnumerable<TOutput>>>`. Kiedy używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt z `System.Func<TInput, IEnumerable<TOutput>>`, przetwarzania każdego elementu wejściowego jest uznawane za wykonane po powrocie delegata. Kiedy używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt z `System.Func<TInput, Task<IEnumerable<TOutput>>>`, przetwarzania każdego elementu wejściowego jest uznawany za ukończone tylko wtedy, gdy zwrócony `System.Threading.Tasks.Task<IEnumerable<TOutput>>` obiektu zostało zakończone.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt, który dzieli ciągi na ich sekwencje pojedynczy znak. <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> Przyjmuje obiekt <xref:System.String> wartości jako dane wejściowe i generuje <xref:System.Char> wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Kompletne przykłady, które używają <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> do tworzenia wielu niezależnych danych wyjściowych dla każdej dane wejściowe w potoku przepływu danych, zobacz [wskazówki: tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Stopień równoległości  
 Każdy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> buforów obiektu danych wejściowych wiadomości do momentu blok jest gotowa do ich przetworzenia. Domyślnie w ramach tych zajęć przetwarzania wiadomości w kolejności, w którym są odbierane, jeden komunikat w danym momencie. Można również określić stopień równoległości, aby umożliwić <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów przetwarzanie wielu komunikatów jednocześnie. Aby uzyskać więcej informacji na temat wykonania zobacz sekcję Określanie stopnia równoległości w dalszej części tego dokumentu. Na przykład, który ustawia maksymalny stopień równoległości, aby umożliwić wykonanie bloku przepływu danych do przetwarzania więcej niż jeden komunikat w danym momencie, zobacz [porady: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Podsumowanie typów delegowanych  
 W poniższej tabeli przedstawiono typy delegatów, które można udostępnić <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów. Ta tabela określa również, czy typ delegata działa synchronicznie lub asynchronicznie.  
  
|Typ|Typ delegata synchroniczne|Typ delegata asynchroniczne|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Można również użycie wyrażeń lambda, podczas pracy z typów bloków wykonywania. Na przykład, która pokazuje sposób użycia wyrażenia lambda z blokiem wykonywania, zobacz [jak: wykonywać akcji podczas przepływu danych Blokuj odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Grupowanie bloków  
 Bloki grupowania łączyć dane z jednego lub kilku źródeł i w ramach różnych ograniczeń. Biblioteka przepływu danych TPL udostępnia trzy typy bloku sprzężenia: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Klasy łączy zestawy danych wejściowych, które są znane jako partie, do tablic danych wyjściowych. Określ rozmiar każdej partii, tworząc <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu. Gdy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt otrzymuje określonej liczby elementów wejściowych, jego asynchronicznie propaguje tablicę, która zawiera te elementy. Jeśli <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu jest ustawiony na stanu ukończenia, ale nie zawiera wystarczającej liczby elementów w celu utworzenia usługi batch, jego propaguje końcowego tablicę, która zawiera wszystkie pozostałe elementy danych wejściowych.  
  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Klasy działa albo *zachłanne* lub *niezachłanne* trybu. W trybie zachłannego, co jest ustawieniem domyślnym, <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> akceptuje każdy komunikat jest oferowana i propaguje tablicy po otrzymaniu określonej liczby elementów. W trybie niezachłanne <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu odłoży wszystkie wiadomości przychodzące, dopóki wystarczającej liczby źródeł ma dostępne komunikaty do bloku w celu utworzenia usługi batch. Tryb zachłanne zazwyczaj działa lepiej niż tryb niezachłanne ponieważ wymaga mniej przetwarzania. Jednak można użyć trybu niezachłanne, gdy musisz skoordynować zużycie z wielu źródeł w sposób atomic. Określ tryb niezachłanne, ustawiając <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> do `False` w `dataflowBlockOptions` parametru w <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> konstruktora.  
  
 Poniższy przykład podstawowy publikuje kilka <xref:System.Int32> wartości <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt, który zawiera 10 elementów w zadaniu wsadowym. Aby zagwarantować, że wszystkie wartości są propagowane z <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, ten przykład wywołuje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metody. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> Metody ustawia <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu do stanu ukończenia i dlatego <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu rozdaje wszystkie pozostałe elementy jako ostatecznego przetwarzania wsadowego.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> w celu poprawy wydajności bazy danych operacji wstawiania, zobacz [Instruktaż: przy użyciu klas BatchBlock i BatchedJoinBlock do poprawy efektywności](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> klasy Zbieranie elementów wejściowych i propagowania <xref:System.Tuple%602?displayProperty=nameWithType> lub <xref:System.Tuple%603?displayProperty=nameWithType> obiektów, które zawierają te elementy. <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> klasy nie dziedziczą <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Zamiast tego zapewniają właściwości <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Podobnie jak <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> działają w trybie zachłanne lub niezachłanne. W trybie zachłannego, co jest ustawieniem domyślnym, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> akceptuje każdy komunikat jest oferowana i propaguje spójnych kolekcji po każdym z jego elementów docelowych odbiera co najmniej jeden komunikat. W trybie niezachłanne <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiektu odłoży wszystkie wiadomości przychodzące, dopóki wszystkie elementy docelowe oferowane danych, która jest wymagana do utworzenia spójnej kolekcji. W tym momencie blok uczestniczy w dwufazowy protokół zatwierdzania niepodzielne pobrać wszystkie wymagane elementy ze źródeł. Tego opóźnienia sprawiają, że innej jednostki, korzystającą z danych w tym samym czasie, aby zezwolić na cały system postępu do przodu.  
  
 Poniższy przykład podstawowy pokazuje przypadek, w którym <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt wymaga wiele danych do obliczenia wartości. Ten przykład tworzy <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt, który wymaga dwóch <xref:System.Int32> wartości i <xref:System.Char> wartość do wykonywania operacji arytmetycznej.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiektów w trybie niezachłanne wspólne udostępnianie zasobów, zobacz [porady: użycie klasy JoinBlock, Odczyt danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> klasy zbieranie partie elementów wejściowych i propagowania `System.Tuple(IList(T1), IList(T2))` lub `System.Tuple(IList(T1), IList(T2), IList(T3))` obiektów, które zawierają te elementy. Traktować <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> pod postacią połączenia <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Określ rozmiar każdej partii, tworząc <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> Udostępnia właściwości, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Po odebraniu określonej liczby elementów wejściowych z różnych wszystkie elementy docelowe, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu asynchronicznie rozdaje `System.Tuple(IList(T1), IList(T2))` obiekt, który zawiera te elementy.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiekt, który przechowuje wyniki, <xref:System.Int32> wartości i błędy, które są <xref:System.Exception> obiektów. W tym przykładzie wykonuje wiele operacji i zapisuje wyniki do <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> właściwości oraz błędy, aby <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> właściwości z <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. Ponieważ liczba udanych i nieudanych operacji jest nieznany z wyprzedzeniem, <xref:System.Collections.Generic.IList%601> obiektów Włącz każdego obiektu docelowego otrzymać zero lub więcej wartości.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Aby uzyskać kompletny przykład, który używa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> do przechwytywania zarówno wyników jak i wyjątków, które występują, gdy program czyta z bazy danych, zobacz [wskazówki: przy użyciu klas BatchBlock i BatchedJoinBlock do poprawy efektywności](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
 [[przejdź do góry](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Konfigurowanie zachowania bloku przepływu danych  
 Możesz włączyć dodatkowe opcje, zapewniając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> obiekt do konstruktora typu bloku przepływu danych. Te opcje umożliwiają kontrolowanie zachowania taki harmonogram, który zarządza zadania podstawowego i stopień równoległości. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> Również ma pochodne typy, które określają zachowanie, które są specyficzne dla niektórych typów bloków przepływu danych. W poniższej tabeli przedstawiono, jaki typ opcji jest skojarzony z każdego typu bloku przepływu danych.  
  
|Typ bloku przepływu danych|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> Typ|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Poniższe sekcje zawierają dodatkowe informacje na temat ważnych rodzajów przepływu danych opcje bloku, które są dostępne za pośrednictwem <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, i <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> klasy.  
  
### <a name="specifying-the-task-scheduler"></a>Określanie harmonogramu zadań  
 Każdy blok przepływu danych wstępnie zdefiniowanych używa zadanie TPL planowania mechanizm do wykonywania działań takich jak propagowania dane do obiektu docelowego, odbierania danych ze źródła i uruchamianie delegatów zdefiniowanych przez użytkownika, gdy są dostępne. <xref:System.Threading.Tasks.TaskScheduler> jest klasą abstrakcyjną, która reprezentuje harmonogramu zadań tego zadania kolejki na wątki. Domyślnego harmonogramu zadań, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, używa <xref:System.Threading.ThreadPool> klasy do kolejki i wykonywania pracy. Można zastąpić przy użyciu domyślnego harmonogramu zadań, ustawiając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> właściwości podczas konstruowania obiektu Blok przepływu danych.  
  
 Gdy ten sam harmonogram zadań zarządza wiele bloków przepływu danych, jej wymuszać zasady, między nimi. Na przykład, jeśli wiele bloków przepływu danych każdego skonfigurowanych pod kątem wyłączne harmonogram tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiekt i wszystkie współpracować, że działa na te bloki jest serializowana. Podobnie jeśli te bloki są skonfigurowane pod kątem współbieżnych harmonogram tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektu, a ten harmonogram ma skonfigurowaną poziom współbieżności maksymalną, cała praca z tych bloków jest ograniczona do tej liczby operacji jednoczesnych. Aby uzyskać przykład, który używa <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> klasy, aby umożliwić operacje odczytu są wykonywane równolegle, ale operacje zapisu mają występować wyłącznie z wszystkich innych operacji, zobacz [porady: Określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Aby uzyskać więcej informacji dotyczących harmonogramów zadań w TPL, zobacz <xref:System.Threading.Tasks.TaskScheduler> temat poświęcony klasie.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Określanie stopnia równoległości  
 Domyślnie, wykonanie trzech typów bloków, udostępniane Biblioteka przepływu danych TPL <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, przetwarzać jeden komunikat w danym momencie. Te typy bloku przepływu danych także przetwarzać wiadomości w kolejności, w której zostały odebrane. Aby włączyć te bloki przepływu danych przetwarzanych wiadomości jednocześnie, ustaw <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> właściwość podczas konstruowania obiektu Blok przepływu danych.  
  
 Wartość domyślna <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> wynosi 1, co gwarantuje, że blok przepływu danych przetwarza jeden komunikat w danym momencie. Ustawienie tej właściwości na wartość, która jest większa niż 1 umożliwia bloku przepływu danych, przetwarzanie wielu komunikatów jednocześnie. Ustawienie tej właściwości na <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> umożliwia bazowego harmonogram zadań do zarządzania maksymalny stopień współbieżności.  
  
> [!IMPORTANT]
>  Po określeniu maksymalny stopień równoległości, który jest większy niż 1, wiele komunikatów przetwarzanych jednocześnie i w związku z tym wiadomości nie może być przetwarzane w kolejności, w której zostały odebrane. Kolejność, w której wiadomości są dane wyjściowe z bloku jest jednak taki sam, w którym są odbierane.  
  
 Ponieważ <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwość reprezentuje maksymalny stopień równoległości, bloku przepływu danych może być wykonywany z niższy stopień równoległości, niż można określić. W bloku przepływu danych może używać niższy stopień równoległości do swoich wymagań funkcjonalności lub brakiem dostępnych zasobów systemowych. W bloku przepływu danych nigdy nie wybiera równoległości więcej, niż można określić.  
  
 Wartość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwość jest dostępna wyłącznie dla każdego obiektu w bloku przepływu danych. Na przykład jeśli cztery przepływu danych blokowych obiektów każdego Określ 1, aby uzyskać maksymalny stopień równoległości, wszystkie cztery obiekty bloku przepływu danych potencjalnie można uruchomić równolegle.  
  
 Na przykład, który ustawia maksymalny stopień równoległości, aby włączyć długie operacje są wykonywane równolegle, zobacz [porady: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Określanie liczby komunikatów na zadanie  
 Typów bloków przepływu danych wstępnie zdefiniowanych używają zadań do przetwarzania wielu elementów wejściowych. Dzięki temu można zminimalizować liczbę obiektów zadań, które są wymagane do przetwarzania danych, co umożliwia bardziej wydajne uruchamianie aplikacji. Jednak podczas zadania z jednego zestawu bloków przepływu danych są przetwarzania danych, zadania z innych bloków przepływu danych może być konieczne poczekanie przez czas przetwarzania przez usługi kolejkowania komunikatów. Aby umożliwić lepsze sprawiedliwe spośród zadań przepływu danych, ustaw <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwości. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest równa <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, co jest ustawieniem domyślnym, zadanie podrzędne, używane przez blok przepływu danych przetwarza dowolną liczbę komunikatów są dostępne. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest równa wartości innych niż <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, bloku przepływu danych, co najwyżej przetwarza tę liczbę wiadomości na <xref:System.Threading.Tasks.Task> obiektu. Mimo że ustawienie <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwości można zwiększyć sprawiedliwe spośród zadań, może to spowodować systemu, aby utworzyć większej liczby zadań, niż jest to konieczne, która może obniżyć wydajność.  
  
### <a name="enabling-cancellation"></a>Włączanie anulowania  
 Używanie biblioteki TPL zapewnia mechanizm, który umożliwia zadania do koordynowania anulowania w sposób współpracujący. Aby włączyć bloków przepływu danych do udziału w tym mechanizmie anulowania, ustaw <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> właściwości. Gdy to <xref:System.Threading.CancellationToken> obiekt jest ustawiony na stanem anulowane, wszystkich bloków przepływu danych, które monitorują ten token zakończy się wykonywanie ich bieżącego elementu, ale nie należy uruchamiać przetwarzania kolejne elementy. Tych bloków przepływu danych, również wyczyść dowolne buforowanych wiadomości, wersji połączenia z dowolnego źródła i bloków docelowych i przejście do stanu Anulowano. Przez przejście do stanu Anulowano <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwość ma <xref:System.Threading.Tasks.Task.Status%2A> właściwością <xref:System.Threading.Tasks.TaskStatus.Canceled>, chyba że wystąpił wyjątek podczas przetwarzania. W takim przypadku <xref:System.Threading.Tasks.Task.Status%2A> ustawiono <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Na przykład, który demonstruje, jak należy używać odwołania w aplikacji Windows Forms, zobacz [porady: anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Aby uzyskać więcej informacji na temat anulowanie w TPL zobacz [anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Określanie złączenia Zachłanne VS. Niezachłanne zachowanie  
 Kilka typów bloków przepływu danych grupowania może działać w jednym *zachłanne* lub *niezachłanne* trybu. Domyślnie typów bloków przepływu danych wstępnie zdefiniowanych działają w trybie zachłanne.  
  
 W celu utworzenia sprzężenia zablokować takie jak typy <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, tryb zachłanne oznacza, że blok natychmiast akceptuje dane, nawet jeśli odpowiadające im dane, z którym należy dołączyć nie jest jeszcze dostępna. Zachłanne inne niż tryb oznacza, że blok odłoży wszystkie wiadomości przychodzące, dopóki nie jest dostępne na każdym z jego elementów docelowych do wykonania sprzężenia. Jeśli którykolwiek z odroczonym komunikatów nie są już dostępne, blok sprzężenia zwalnia wszystkich przełożonych wiadomości i ponowne uruchomienie procesu. Aby uzyskać <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> klasy zachłanne i niezachłanne zachowanie jest podobne, chyba że w trybie niezachłanne <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu odłoży wszystkie wiadomości przychodzące, dopóki wystarczająco dużo, są dostępne z różnych źródeł, aby ukończyć partii.  
  
 Aby określić tryb niezachłanne w bloku przepływu danych, ustaw <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> do `False`. Na przykład, który demonstruje, jak włączyć wiele bloków sprzężenia wydajniej udostępnianie źródła danych za pomocą trybu niezachłanne, zobacz [porady: Użyj klasy JoinBlock do odczytu danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[przejdź do góry](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Niestandardowych bloków przepływu danych  
 Chociaż Biblioteka przepływu danych TPL wielu typów bloku wstępnie zdefiniowane, możesz utworzyć typy bloku dodatkowe, które wykonują niestandardowe zachowanie. Implementowanie <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> lub <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsy bezpośrednio lub za pomocą <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> metoda tworzenia złożonych Blok, który hermetyzuje zachowanie istniejących typów bloku. Przykłady pokazujące, jak do implementacji funkcji bloku przepływu danych niestandardowych, zobacz [wskazówki: Tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[przejdź do góry](#top)]  
  
## <a name="related-topics"></a>Tematy pokrewne  
  
|Tytuł|Opis|  
|-----------|-----------------|  
|[Instrukcje: zapisywanie komunikatów w bloku przepływu danych i odczytywanie ich z tego bloku](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Pokazuje, jak pisać wiadomości do danych i odczytywanie ich z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu.|  
|[Instrukcje: implementowanie wzorca przepływu danych producent — konsument](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Opisuje sposób implementacji wzorca producent — konsument, w którym producent wysyła komunikaty do bloku przepływu danych, a użytkownik odczytuje komunikaty z tego bloku przy użyciu modelu przepływu danych.|  
|[Instrukcje: wykonywanie akcji w przypadku odebrania danych przez blok przepływu danych](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|W tym artykule opisano sposób udostępniania delegatów dla typów bloku przepływu danych wykonywania, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Przewodnik: tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|W tym temacie opisano tworzenie potoku przepływu danych, pliki do pobrania tekstu z sieci web, która wykonuje operacje na ten tekst.|  
|[Instrukcje: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Pokazuje sposób użycia <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> metoda można odłączyć od źródła blok docelowy po źródła oferuje wiadomość do obiektu docelowego.|  
|[Przewodnik: korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Pokazuje, jak utworzyć sieć bloków przepływu danych, które wykonują przetwarzania obrazów w aplikacji Windows Forms.|  
|[Instrukcje: anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Pokazuje, jak należy używać odwołania w aplikacji Windows Forms.|  
|[Instrukcje: korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Opis sposobu użycia <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> klasy w celu wykonania operacji, gdy dane są dostępne z wielu źródeł i jak włączyć wiele bloków sprzężenia wydajniej udostępnianie źródła danych za pomocą niezachłanne trybu.|  
|[Instrukcje: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|W tym artykule opisano sposób ustawiania <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwości, aby umożliwić wykonanie bloku przepływu danych do przetwarzania więcej niż jeden komunikat w danym momencie.|  
|[Instrukcje: określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Pokazuje, jak skojarzyć harmonogram zadań szczególnych, korzystając z przepływu danych w aplikacji.|  
|[Przewodnik: poprawa wydajności przy użyciu klas BatchBlock i BatchedJoinBlock](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Opisuje sposób używania <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Wstaw klasy, aby zwiększyć wydajność bazy danych, operacji i sposób korzystania <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> klasa do przechwytywania zarówno wyników jak i wyjątków, które występują, gdy program czyta z bazy danych.|  
|[Przewodnik: tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Przedstawia dwa sposoby tworzenia typu bloku przepływu danych, który implementuje niestandardowe zachowanie.|  
|[Biblioteka zadań równoległych (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Wprowadza TPL bibliotekę, która upraszcza programowania równoległego i współbieżne w [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] aplikacji.|
