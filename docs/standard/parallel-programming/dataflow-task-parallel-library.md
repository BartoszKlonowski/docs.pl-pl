---
title: Przepływ danych (Biblioteka zadań równoległych)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 7f5969bc6f73b2260ae1ffa4b0026d5b4119ff88
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/30/2019
ms.locfileid: "73134269"
---
# <a name="dataflow-task-parallel-library"></a>Przepływ danych (Biblioteka zadań równoległych)
<a name="top"></a>Biblioteka zadań równoległych (TPL) zawiera składniki przepływu danych, które ułatwiają zwiększenie niezawodności aplikacji korzystających z współbieżności. Te składniki przepływu danych są zbiorczo określane jako *Biblioteka TPL przepływu danych*. Ten model przepływu danych wspiera Programowanie oparte na aktorze, zapewniając w procesie przekazywanie komunikatów w celu uzyskania bardziej szczegółowych zadań przepływu danych i potokowych. Składniki przepływu danych są oparte na typach i planowaniu infrastruktury TPL i integrują się z obsługą C#, Visual Basic i F# językiem w programowaniu asynchronicznym. Te składniki przepływu danych są przydatne, gdy istnieje wiele operacji, które muszą komunikować się ze sobą asynchronicznie, lub gdy chcesz przetwarzać dane, gdy staną się dostępne. Rozważmy na przykład aplikację, która przetwarza dane obrazu z kamery sieci Web. Korzystając z modelu przepływu danych, aplikacja może przetwarzać ramki obrazu w miarę ich udostępniania. Jeśli aplikacja rozszerza ramki obrazu, na przykład przez wykonanie korekcji światła lub zmniejszenie oka, można utworzyć *potok* składników przepływu danych. Każdy etap potoku może korzystać z bardziej precyzyjnych funkcji równoległych, takich jak funkcje dostarczone przez TPL, aby przekształcić obraz.  
  
 Ten dokument zawiera omówienie biblioteki przepływu danych TPL. Opisano w nim model programowania, wstępnie zdefiniowane typy bloków przepływu danych oraz sposób konfigurowania bloków przepływu danych w celu spełnienia określonych wymagań aplikacji.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]
  
 Ten dokument zawiera następujące sekcje:  
  
- [Model programowania](#model)  
  
- [Wstępnie zdefiniowane typy bloków przepływu danych](#predefined_types)  
  
- [Konfigurowanie zachowania blokowania przepływu danych](#behavior)  
  
- [Niestandardowe bloki przepływu danych](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Model programowania  
 Biblioteka TPL przepływu danych stanowi podstawę przekazywania komunikatów i przekształcają intensywnie korzystających z procesora CPU aplikacji intensywnie wykorzystujących procesor i/wy, które mają wysoką przepływność i małe opóźnienia. Zapewnia również jawną kontrolę nad sposobem buforowania danych i poruszaniem się w systemie. Aby lepiej zrozumieć model programowania przepływu danych, weź pod uwagę aplikację, która asynchronicznie ładuje obrazy z dysku i tworzy złożone obrazy. Tradycyjne modele programistyczne zwykle wymagają używania wywołań zwrotnych i obiektów synchronizacji, takich jak blokady, do koordynowania zadań i uzyskiwania dostępu do udostępnionych danych. Za pomocą modelu programowania przepływu danych można tworzyć obiekty przepływu danych, które przetwarzają obrazy w miarę ich odczytu z dysku. W modelu przepływu danych deklaruje, jak dane są obsługiwane, gdy staną się dostępne, a także wszelkie zależności między danymi. Ponieważ środowisko uruchomieniowe zarządza zależnościami między danymi, często można uniknąć konieczności synchronizacji dostępu do udostępnionych danych. Ponadto, ponieważ harmonogramy środowiska uruchomieniowego są wykonywane na podstawie asynchronicznego przybycia danych, przepływu danych może zwiększyć czas reakcji i przepływność przez wydajne zarządzanie wątkami bazowymi. Aby zapoznać się z przykładem wykorzystującym model programowania przepływu danych do implementowania przetwarzania obrazów w aplikacji Windows Forms, zobacz [Przewodnik: używanie przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Źródła i obiekty docelowe  
 Biblioteka TPL przepływu danych składa się z *bloków przepływu danych*, które są strukturami danych, które buforują i przetwarzają dane. TPL definiuje trzy rodzaje bloków przepływu danych: *bloków źródłowych*, *bloków docelowych*i *bloków propagacji*. Blok źródłowy działa jako źródło danych i może zostać odczytany. Blok docelowy działa jako odbiorca danych i może być zapisany w. Blok propagator działa zarówno jako blok źródłowy, jak i blok docelowy i może być odczytywany i zapisywana. TPL definiuje interfejs <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> do reprezentowania źródeł, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> do reprezentowania obiektów docelowych oraz <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> do reprezentowania propagator. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> dziedziczy z obu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Biblioteka TPL przepływu danych zawiera kilka wstępnie zdefiniowanych typów bloków przepływu danych, które implementują interfejsy <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>i <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>. Te typy bloków przepływu danych zostały opisane w tym dokumencie w sekcji [wstępnie zdefiniowane typy bloków przepływu danych](#predefined_types).  
  
### <a name="connecting-blocks"></a>Łączenie bloków  
 Bloki przepływu danych można połączyć z *potokami*, które są sekwencjami liniowymi bloków przepływu danych lub *sieci*, które są wykresami bloków przepływu danych. Potok jest jedną z form sieci. W potoku lub sieci źródła asynchronicznie propagują dane do obiektów docelowych, ponieważ te dane staną się dostępne. Metoda <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> łączy źródłowy blok przepływu danych z blokiem docelowym. Źródło może być połączone z zero lub więcej obiektami docelowymi; elementy docelowe mogą być połączone z zera lub więcej źródeł. Możesz dodawać lub usuwać bloki przepływu danych do lub z potoku lub sieci jednocześnie. Wstępnie zdefiniowane typy bloku przepływu danych obsługują wszystkie aspekty bezpiecznego wątku łączące i odłączania.  
  
 Aby uzyskać przykład, który łączy bloki przepływu danych w celu utworzenia potoku podstawowego, zobacz [Przewodnik: Tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Aby uzyskać przykład, który łączy bloki przepływu danych w celu utworzenia bardziej złożonej sieci, zobacz [Przewodnik: używanie przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Aby uzyskać przykład, który odłącza obiekt docelowy od źródła, gdy źródło zawiera docelowy komunikat, zobacz [How to: relink Blocks przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrowanie  
 Po wywołaniu metody <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> w celu połączenia źródła z obiektem docelowym można dostarczyć delegata, który określa, czy blok docelowy akceptuje lub odrzuca komunikat na podstawie wartości tego komunikatu. Mechanizm filtrowania jest użytecznym sposobem zagwarantowania, że blok przepływu danych odbiera tylko niektóre wartości. W przypadku większości wstępnie zdefiniowanych typów bloków przepływu danych, jeśli blok źródłowy jest połączony z wieloma blokami docelowymi, gdy blok docelowy odrzuci komunikat, Źródło oferuje ten komunikat do następnego celu. Kolejność, w której źródło oferuje komunikaty do obiektów docelowych, jest definiowana przez źródło i może się różnić w zależności od typu źródła. Większość typów bloków źródłowych przerywa oferowanie komunikatu po zaakceptowaniu tego komunikatu przez jeden obiekt docelowy. Jedynym wyjątkiem od tej reguły jest Klasa <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, która oferuje każdy komunikat do wszystkich obiektów docelowych, nawet jeśli niektóre obiekty docelowe odrzucają komunikat. Aby zapoznać się z przykładem, który używa filtrowania do przetwarzania tylko niektórych komunikatów, zobacz [Przewodnik: korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
> Ponieważ każdy wstępnie zdefiniowany typ bloku Source przepływu danych gwarantuje, że komunikaty są rozmnożone w kolejności, w której są odbierane, każdy komunikat musi zostać odczytany z bloku źródłowego, zanim blok źródłowy będzie mógł przetworzyć następny komunikat. Dlatego w przypadku używania filtrowania do łączenia wielu obiektów docelowych ze źródłem upewnij się, że co najmniej jeden blok docelowy otrzymuje każdy komunikat. W przeciwnym razie aplikacja może zakleszczenie.  
  
### <a name="message-passing"></a>Przekazywanie komunikatów  
 Model programowania przepływu danych jest powiązany z koncepcją *przekazywania komunikatów*, gdzie niezależne składniki programu komunikują się ze sobą przez wysyłanie komunikatów. Jednym ze sposobów propagowania komunikatów między składnikami aplikacji jest wywołanie <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> metod w celu wysyłania komunikatów do docelowych bloków przepływu danych post (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> działa synchronicznie, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> działa asynchronicznie) i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>i <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> metody odbierania wiadomości z bloków źródłowych. Można połączyć te metody z potokami przepływu danych lub sieciami, wysyłając dane wejściowe do węzła głównego (blok docelowy) i pobierając dane wyjściowe z węzła terminalu potoku lub węzłów terminalu sieci (co najmniej jeden blok źródłowy). Można również użyć metody <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A>, aby odczytać z pierwszego z udostępnionych źródeł danych i wykonać działania dotyczące tych danych.  
  
 Bloki źródła oferują dane do bloków docelowych przez wywołanie metody <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType>. Blok docelowy reaguje na oferowany komunikat na jeden z trzech sposobów: może zaakceptować komunikat, odrzucić komunikat lub odłożyć komunikat. Gdy element docelowy akceptuje komunikat, Metoda <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Gdy obiekt docelowy odrzuci komunikat, Metoda <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Gdy element docelowy wymaga, aby nie odbierał już żadnych komunikatów ze źródła, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Wstępnie zdefiniowane typy bloków źródłowych nie oferują komunikatów do połączonych obiektów docelowych po odebraniu takiej wartości zwracanej i automatycznie odłączają od tych elementów docelowych.  
  
 Gdy blok docelowy opóźnia komunikat do późniejszego użycia, Metoda <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Blok docelowy, który opóźnia komunikat, może później wywołać metodę <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType>, aby spróbować zarezerwować proponowany komunikat. W tym momencie komunikat jest nadal dostępny i może być używany przez blok docelowy lub komunikat został wykonany przez inny element docelowy. Gdy blok docelowy później wymaga wiadomości lub nie potrzebuje już komunikatu, wywołuje odpowiednio metodę <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A>. Rezerwacja komunikatów jest zwykle używana przez typy bloku przepływu danych, które działają w trybie innym niż zachłanne. Tryb inny niż zachłanne został wyjaśniony w dalszej części tego dokumentu. Zamiast obsłużyć odroczony komunikat, blok docelowy może również użyć metody <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType>, aby próbować bezpośrednio wykorzystać odroczony komunikat.  
  
### <a name="dataflow-block-completion"></a>Zakończenie bloku przepływu danych  
 Bloki przepływu danych obsługują również koncepcję *uzupełniania*. Blok przepływu danych, który jest w stanie ukończone, nie wykonuje żadnych dalszych zadań. Każdy blok przepływu danych ma skojarzony obiekt <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, znany jako *zadanie uzupełniania*, reprezentujący stan ukończenia bloku. Ponieważ możesz poczekać na zakończenie działania obiektu <xref:System.Threading.Tasks.Task>, za pomocą zadań ukończenia, możesz poczekać na zakończenie co najmniej jednego węzła terminalu sieci przepływu danych. Interfejs <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> definiuje metodę <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>, która informuje blok przepływu danych o żądaniu do ukończenia, i Właściwość <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, która zwraca zadanie ukończenia dla bloku przepływu danych. Zarówno <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, jak i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> dziedziczą interfejs <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>.  
  
 Istnieją dwa sposoby, aby określić, czy blok przepływu danych zakończył pracę bez błędu, napotkał co najmniej jeden błąd lub został anulowany. Pierwszym sposobem jest wywołanie metody <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>j w zadaniu zakończenia w `try`-`catch` bloku (`Try`-`Catch` w Visual Basic). Poniższy przykład tworzy obiekt <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, który zgłasza <xref:System.ArgumentOutOfRangeException>, jeśli jego wartość wejściowa jest mniejsza od zera. <xref:System.AggregateException> jest generowany, gdy ten przykład wywołuje <xref:System.Threading.Tasks.Task.Wait%2A> w zadaniu zakończenia. <xref:System.ArgumentOutOfRangeException> jest dostępny za pomocą właściwości <xref:System.AggregateException.InnerExceptions%2A> obiektu <xref:System.AggregateException>.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 W tym przykładzie pokazano przypadek, w którym wyjątek jest nieobsługiwany w delegatze bloku przepływu danych wykonywania. Zalecamy obsługę wyjątków w treści takich bloków. Jednakże jeśli nie można tego zrobić, blok zachowuje się tak, jakby został anulowany i nie przetwarza komunikatów przychodzących.  
  
 Gdy blok przepływu danych zostanie anulowany jawnie, obiekt <xref:System.AggregateException> zawiera <xref:System.OperationCanceledException> we właściwości <xref:System.AggregateException.InnerExceptions%2A>. Aby uzyskać więcej informacji na temat anulowania przepływu danych, zobacz sekcję [Włączanie anulowania](#enabling-cancellation) .  
  
 Drugi sposób na określenie stanu ukończenia bloku przepływu danych polega na kontynuacji zadania ukończenia lub użyciu funkcji języka asynchronicznego C# i Visual Basic, aby asynchronicznie oczekiwać na ukończenie zadania. Delegat udostępniany metodzie <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> przyjmuje obiekt <xref:System.Threading.Tasks.Task>, który reprezentuje zadanie poprzedzające. W przypadku właściwości <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> delegat dla kontynuacji pobiera samo zadanie zakończenia. Poniższy przykład przypomina poprzednią, z tą różnicą, że używa również metody <xref:System.Threading.Tasks.Task.ContinueWith%2A> do utworzenia zadania kontynuacji, które drukuje stan ogólnej operacji przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Możesz również użyć właściwości, takich jak <xref:System.Threading.Tasks.Task.IsCanceled%2A> w treści zadania kontynuacji, aby określić dodatkowe informacje o stanie ukończenia bloku przepływu danych. Aby uzyskać więcej informacji na temat zadań kontynuacji i sposobu ich odnoszących do anulowania i obsługi błędów, zobacz Tworzenie [łańcucha zadań przy użyciu zadań kontynuacji](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [anulowania zadań](../../../docs/standard/parallel-programming/task-cancellation.md)i [obsługi wyjątków](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [[Przejdź do góry](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Wstępnie zdefiniowane typy bloków przepływu danych  
 Biblioteka TPL przepływu danych zawiera kilka wstępnie zdefiniowanych typów bloków przepływu danych. Te typy są podzielone na trzy kategorie: *buforowanie bloków*, *bloków wykonywania*i *bloków grupowania*. W poniższych sekcjach opisano typy bloków, które składają się na te kategorie.  
  
### <a name="buffering-blocks"></a>Buforowanie bloków  
 Bloki buforowania przechowują dane do użycia przez użytkowników danych. Biblioteka TPL przepływu danych zawiera trzy typy bloków buforowania: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>i <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock (T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> reprezentuje strukturę asynchronicznej obsługi komunikatów ogólnego przeznaczenia. Ta klasa przechowuje kolejki w pierwszej kolejności (FIFO) komunikatów, które mogą być zapisywane przez wiele źródeł lub odczytywane przez wiele obiektów docelowych. Gdy obiekt docelowy otrzymuje komunikat z obiektu <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, ten komunikat zostanie usunięty z kolejki komunikatów. W związku z tym mimo że obiekt <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> może mieć wiele obiektów docelowych, tylko jeden element docelowy otrzyma każdy komunikat. Klasa <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> jest przydatna, gdy chcesz przekazać wiele komunikatów do innego składnika, a ten składnik musi odebrać każdy komunikat.  
  
 Poniższy przykład podstawowy zapisuje kilka <xref:System.Int32> wartości do obiektu <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, a następnie odczytuje te wartości z powrotem z tego obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Aby zapoznać się z kompletnym przykładem, który ilustruje sposób pisania komunikatów do i odczytywania komunikatów z obiektu <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, zobacz [How to: Write Message in and Read messages Block przepływu danych](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock (T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> jest przydatna, gdy należy przekazać wiele komunikatów do innego składnika, ale ten składnik wymaga tylko najnowszej wartości. Ta klasa jest również przydatna, gdy chcesz emitować komunikat do wielu składników.  
  
 Poniższy przykład podstawowy zapisuje wartość <xref:System.Double> do obiektu <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, a następnie odczytuje tę wartość z tego obiektu kilka razy. Ponieważ wartości nie są usuwane z <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektów po ich odczytaniu, ta sama wartość jest dostępna za każdym razem.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Aby uzyskać kompletny przykład, w którym pokazano, jak używać <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> do rozgłaszania komunikatów do wielu bloków docelowych, zobacz [How to: określ harmonogram zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock (T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jest podobna do klasy <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, z tą różnicą, że obiekt <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> może być zapisywana tylko raz. Można traktować <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jako podobne do C# słowa kluczowego [ReadOnly](../../csharp/language-reference/keywords/readonly.md) ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) w Visual Basic), z tą różnicą, że obiekt <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> staje się niezmienny po otrzymaniu wartości, a nie w konstrukcji. Podobnie jak w przypadku klasy <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, gdy obiekt docelowy otrzymuje komunikat z obiektu <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, ten komunikat nie zostanie usunięty z tego obiektu. W związku z tym wiele obiektów docelowych otrzymuje kopię wiadomości. Klasa <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jest przydatna, gdy chcesz propagować tylko pierwszy z wielu komunikatów.  
  
 Poniższy przykład podstawowy zapisuje wiele wartości <xref:System.String> do obiektu <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, a następnie odczytuje wartość z powrotem z tego obiektu. Ponieważ obiekt <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> może być zapisywany tylko jednokrotnie, po odebraniu komunikatu przez <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt odrzuci kolejne komunikaty.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Aby uzyskać kompletny przykład, w którym pokazano, jak za pomocą <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> otrzymać wartość pierwszej operacji, która kończy się, zobacz [How to: relink Blocks przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Bloki wykonywania  
 Bloki wykonywania wywołują delegata dostarczony przez użytkownika dla każdej z odebranych danych. Biblioteka TPL przepływu danych zawiera trzy typy bloków wykonywania: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock (T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> jest blokiem docelowym, który wywołuje delegata po odebraniu danych. Obiekt <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> należy traktować jako delegat, który jest uruchamiany asynchronicznie, gdy dane staną się dostępne. Delegat dostarczany do obiektu <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> może być typu <xref:System.Action%601> lub `System.Func<TInput, Task>`. Gdy używasz obiektu <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> z <xref:System.Action%601>, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy obiekt delegowany zwraca wartość. Gdy używasz obiektu <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> z `System.Func<TInput, Task>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy zwracany jest obiekt <xref:System.Threading.Tasks.Task> zakończony. Korzystając z tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> do przetwarzania synchronicznego i asynchronicznego każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy zapisuje wiele wartości <xref:System.Int32> do obiektu <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>. Obiekt <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> drukuje te wartości w konsoli programu. W tym przykładzie ustawia blok do stanu ukończone i czeka na zakończenie wszystkich zadań przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Aby zapoznać się z kompletnymi przykładami, które pokazują, jak używać delegatów z klasą <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, zobacz [How to: wykonywanie akcji, gdy blok przepływu danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 Klasa <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> przypomina klasę <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, z tą różnicą, że działa jako źródło i jako element docelowy. Delegat przekazywany do obiektu <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> zwraca wartość typu `TOutput`. Delegat dostarczany do obiektu <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> może być typu `System.Func<TInput, TOutput>` lub `System.Func<TInput, Task<TOutput>>`. Gdy używasz obiektu <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> z `System.Func<TInput, TOutput>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy obiekt delegowany zwraca wartość. Gdy używasz obiektu <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> użytego z `System.Func<TInput, Task<TOutput>>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy zwrócony obiekt <xref:System.Threading.Tasks.Task%601> został ukończony. Podobnie jak w przypadku <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, za pomocą tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> do przetwarzania synchronicznego i asynchronicznego każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy tworzy obiekt <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, który oblicza pierwiastek kwadratowy jego danych wejściowych. Obiekt <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> pobiera <xref:System.Int32> wartości jako dane wejściowe i generuje wartości <xref:System.Double> jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Aby zapoznać się z kompletnymi przykładami korzystającymi z <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> w sieci bloków przepływu danych, które wykonują przetwarzanie obrazów w aplikacji Windows Forms, zobacz [Przewodnik: używanie przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 Klasa <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> jest podobna do klasy <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, z tą różnicą, że <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> generuje zero lub więcej wartości wyjściowych dla każdej wartości wejściowej, a nie tylko jedną wartość wyjściową dla każdej wartości wejściowej. Delegat dostarczany do obiektu <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> może być typu `System.Func<TInput, IEnumerable<TOutput>>` lub `System.Func<TInput, Task<IEnumerable<TOutput>>>`. Gdy używasz obiektu <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> z `System.Func<TInput, IEnumerable<TOutput>>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy obiekt delegowany zwraca wartość. Gdy używasz obiektu <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> z `System.Func<TInput, Task<IEnumerable<TOutput>>>`, przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy zwrócony obiekt `System.Threading.Tasks.Task<IEnumerable<TOutput>>` został ukończony.  
  
 Poniższy przykład podstawowy tworzy obiekt <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, który dzieli ciągi na ich poszczególne sekwencje znaków. Obiekt <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> pobiera <xref:System.String> wartości jako dane wejściowe i generuje wartości <xref:System.Char> jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Aby uzyskać pełne przykłady, które używają <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> do tworzenia wielu niezależnych danych wyjściowych dla każdego elementu wejściowego w potoku przepływu danych, zobacz [Przewodnik: Tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Stopień równoległości  
 Każdy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów buforuje komunikaty wejściowe do momentu, gdy blok będzie gotowy do przetworzenia. Domyślnie te klasy przetwarzają komunikaty w kolejności, w której są odbierane, po jednym komunikacie. Możesz również określić stopień równoległości, aby umożliwić <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów w celu przetworzenia wielu komunikatów jednocześnie. Więcej informacji o jednoczesnym wykonywaniu można znaleźć w sekcji Określanie stopnia równoległości w dalszej części tego dokumentu. Aby uzyskać przykład, który ustawia stopień równoległości, aby umożliwić blokowi przepływu danych wykonywania przetwarzanie więcej niż jednego komunikatu jednocześnie, zobacz [How to: Określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Podsumowanie typów delegatów  
 Poniższa tabela zawiera podsumowanie typów delegatów, które można udostępniać <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów. Ta tabela określa również, czy typ delegata działa synchronicznie, czy asynchronicznie.  
  
|Typ|Typ delegata synchronicznego|Typ delegata asynchronicznego|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Można również użyć wyrażeń lambda podczas pracy z typami bloków wykonywania. Aby zapoznać się z przykładem, który pokazuje, jak używać wyrażenia lambda z blokiem wykonywania, zobacz [How to: wykonywanie akcji, gdy blok przepływu danych odbiera dane](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Bloki grupowania  
 Bloki grupowania łączą dane z co najmniej jednego źródła i w różnych ograniczeniach. Biblioteka TPL przepływu danych zawiera trzy typy bloków sprzężenia: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock (T)  
 Klasa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> łączy zestawy danych wejściowych, które są znane jako partie, do tablic danych wyjściowych. Podczas tworzenia obiektu <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> należy określić rozmiar każdej partii. Gdy obiekt <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> otrzymuje określoną liczbę elementów wejściowych, asynchronicznie propaguje tablicę zawierającą te elementy. Jeśli obiekt <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> jest ustawiony na stan ukończony, ale nie zawiera wystarczającej liczby elementów, aby utworzyć partię, propaguje ostateczną tablicę zawierającą pozostałe elementy wejściowe.  
  
 Klasa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> działa w trybie *zachłanne* lub *zachłanne* . W trybie zachłanne, który jest domyślnym, obiekt <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> akceptuje każdy komunikat, który jest oferowany, i propaguje tablicę po odebraniu określonej liczby elementów. W trybie innym niż zachłanne obiekt <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> opóźnia wszystkie komunikaty przychodzące do momentu, gdy wystarczające źródła nie zaoferują komunikatów do bloku, aby utworzyć partię. Tryb zachłanne zazwyczaj wykonuje lepsze niż tryb inny niż zachłanne, ponieważ wymaga mniejszego obciążenia przetwarzania. Można jednak używać trybu zachłanne, gdy trzeba skoordynować użycie z wielu źródeł w sposób niepodzielny. Określ tryb inny niż zachłanne, ustawiając <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> na `False` w parametrze `dataflowBlockOptions` w konstruktorze <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>.  
  
 Poniższy przykład podstawowy zapisuje kilka <xref:System.Int32> wartości do obiektu <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, który zawiera dziesięć elementów w partii. W celu zagwarantowania, że wszystkie wartości są propagowane z <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, ten przykład wywołuje metodę <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>. Metoda <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> ustawia obiekt <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> do stanu ukończenia, w związku z czym obiekt <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> propaguje wszystkie pozostałe elementy jako końcową partię.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, aby zwiększyć wydajność operacji wstawiania bazy danych, zobacz [Przewodnik: korzystanie z BatchBlock i BatchedJoinBlock w celu zwiększenia wydajności](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>Klasy JoinBlock (T1, T2,...)  
 Klasy <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> zbierają elementy wejściowe i propagują <xref:System.Tuple%602?displayProperty=nameWithType> lub <xref:System.Tuple%603?displayProperty=nameWithType> obiekty, które zawierają te elementy. Klasy <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> nie dziedziczą po <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Zamiast tego dostarczają właściwości, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Podobnie jak <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> działać w trybie zachłanne lub zachłanne. W trybie zachłanne, który jest domyślnym, obiekt <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> akceptuje każdy komunikat, który jest oferowany, i propaguje spójność kolekcji po każdym z jej obiektów docelowych odbiera co najmniej jeden komunikat. W trybie innym niż zachłanne obiekt <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> opóźnia wszystkie komunikaty przychodzące do momentu zaoferowania wszystkim elementom docelowym danych wymaganych do utworzenia krotki. W tym momencie blok jest zaangażowany w dwufazowego protokołu zatwierdzania w celu niepodzielnego pobrania wszystkich wymaganych elementów ze źródeł. To odroczenie pozwala innym jednostkom zużywać dane w międzyczasie, aby umożliwić całkowitemu systemowi przeprowadzenie do przodu postępu.  
  
 Poniższy przykład podstawowy ilustruje przypadek, w którym obiekt <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> wymaga wielu danych do obliczenia wartości. Ten przykład tworzy obiekt <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>, który wymaga dwóch wartości <xref:System.Int32> i <xref:System.Char> wartości do wykonania operacji arytmetycznej.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Aby zapoznać się z kompletnym przykładem, który używa <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiektów w trybie innym niż zachłanne do współdzielenia zasobu, zobacz [How to: use klasy JoinBlock do odczytywania danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock (T1, T2,...)  
 Klasy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> zbierają partie elementów wejściowych i propagują `System.Tuple(IList(T1), IList(T2))` lub `System.Tuple(IList(T1), IList(T2), IList(T3))` obiekty, które zawierają te elementy. Potraktuj <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> jako kombinację <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Określ rozmiar każdej partii podczas tworzenia obiektu <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> udostępnia również właściwości, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Gdy określona liczba elementów wejściowych jest odbierana z wszystkich obiektów docelowych, obiekt <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> asynchronicznie propaguje obiekt `System.Tuple(IList(T1), IList(T2))` zawierający te elementy.  
  
 Poniższy przykład podstawowy tworzy obiekt <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>, który zawiera wyniki, <xref:System.Int32> wartości i błędy, które są <xref:System.Exception> obiektów. Ten przykład wykonuje wiele operacji i zapisuje wyniki do właściwości <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> i błędy właściwości <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> obiektu <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. Ze względu na to, że liczba zakończonych powodzeniem i zakończonych niepowodzeniem operacji jest nieznana z wyprzedzeniem, obiekty <xref:System.Collections.Generic.IList%601> umożliwiają każdy element docelowy otrzymać zero lub więcej wartości.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Pełny przykład, który używa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> do przechwytywania zarówno wyników, jak i wyjątków, które występują, gdy program odczytuje z bazy danych, zobacz [Przewodnik: korzystanie z BatchBlock i BatchedJoinBlock w celu zwiększenia wydajności](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
 [[Przejdź do góry](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Konfigurowanie zachowania blokowania przepływu danych  
 Dodatkowe opcje można włączyć, dostarczając obiekt <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> do konstruktora typów bloku przepływu danych. Te opcje kontrolują zachowanie, takie jak harmonogram zarządzający zadaniem podstawowym i stopień równoległości. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> ma również typy pochodne, które określają zachowanie specyficzne dla określonych typów bloku przepływu danych. Poniższa tabela zawiera podsumowanie typów opcji skojarzonych z każdym typem bloku przepływu danych.  
  
|Typ bloku przepływu danych|Typ <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 W poniższych sekcjach znajdują się dodatkowe informacje o ważnych typach opcji blokowania przepływu danych, które są dostępne za pomocą klas <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>i <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType>.  
  
### <a name="specifying-the-task-scheduler"></a>Określanie Harmonogram zadań  
 Każdy wstępnie zdefiniowany blok przepływu danych używa mechanizmu planowania zadań TPL do wykonywania działań, takich jak propagowanie danych do obiektu docelowego, pobieranie danych ze źródła i uruchamianie delegatów zdefiniowanych przez użytkownika, gdy dane staną się dostępne. <xref:System.Threading.Tasks.TaskScheduler> jest klasą abstrakcyjną, która reprezentuje harmonogram zadań, który kolejkuje zadania na wątki. Domyślny harmonogram zadań, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, używa klasy <xref:System.Threading.ThreadPool> do kolejki i wykonywania pracy. Można zastąpić domyślny harmonogram zadań, ustawiając właściwość <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> podczas konstruowania obiektu bloku przepływu danych.  
  
 Gdy ten sam harmonogram zadań zarządza wieloma blokami przepływu danych, może wymuszać zasady dla nich. Jeśli na przykład wiele bloków przepływu danych jest skonfigurowanych pod kątem wyłącznego harmonogramu tego samego obiektu <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, wszystkie zadania działające w ramach tych bloków są serializowane. Podobnie, jeśli te bloki są skonfigurowane pod kątem współbieżnego harmonogramu tego samego obiektu <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, a harmonogram jest skonfigurowany tak, aby miał maksymalny poziom współbieżności, wszystkie prace z tych bloków są ograniczone do tej liczby współbieżnych operacji. Aby zapoznać się z przykładem, który używa klasy <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, aby umożliwić wykonywanie operacji odczytu równolegle, ale operacje zapisu mają być wykonywane wyłącznie przez wszystkie inne operacje, zobacz [How to: określ harmonogram zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Aby uzyskać więcej informacji na temat harmonogramów zadań w TPL, zobacz temat Klasa <xref:System.Threading.Tasks.TaskScheduler>.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Określanie stopnia równoległości  
 Domyślnie trzy typy bloków wykonywania, które udostępnia Biblioteka TPL przepływu danych, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, przetwarzają jeden komunikat w danym momencie. Te typy bloków przepływu danych również przetwarzają komunikaty w kolejności, w jakiej zostały odebrane. Aby włączyć te bloki przepływu danych do przetwarzania komunikatów współbieżnie, należy ustawić właściwość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> podczas konstruowania obiektu bloku przepływu danych.  
  
 Wartość domyślna <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> wynosi 1, co gwarantuje, że blok przepływu danych przetwarza jeden komunikat w danym momencie. Ustawienie tej właściwości na wartość, która jest większa niż 1 umożliwia blokowi przepływu danych przetwarzanie wielu komunikatów współbieżnie. Ustawienie tej właściwości na <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> umożliwia uruchamianie bazowego harmonogramu zadań w celu zarządzania maksymalnym stopień współbieżności.  
  
> [!IMPORTANT]
> W przypadku określenia maksymalnego stopnia równoległości, który jest większy niż 1, wiele komunikatów jest przetwarzanych jednocześnie i dlatego komunikaty mogą nie być przetwarzane w kolejności, w której zostały odebrane. Kolejność, w jakiej komunikaty są wyprowadzane z bloku, jest jednak taka sama, w której zostały odebrane.  
  
 Ponieważ właściwość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> reprezentuje maksymalny stopień równoległości, blok przepływu danych może być wykonywany z mniejszym stopieńem równoległości niż określono. Blok przepływu danych może używać mniejszego stopnia równoległości w celu spełnienia wymagań funkcjonalnych lub braku dostępnych zasobów systemowych. Blok przepływu danych nigdy nie wybiera bardziej równoległości niż określono.  
  
 Wartość właściwości <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> jest wyłącznie dla każdego obiektu bloku przepływu danych. Na przykład jeśli cztery obiekty przepływu danych bloku Each określają 1 dla maksymalnego stopnia równoległości, wszystkie cztery obiekty bloku przepływu danych mogą być uruchamiane równolegle.  
  
 Aby uzyskać przykład, który ustawia maksymalny stopień równoległości, aby umożliwić równoległe wykonywanie operacji, zobacz [How to: Określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Określanie liczby komunikatów na zadanie  
 Wstępnie zdefiniowane typy bloków przepływu danych używają zadań do przetwarzania wielu elementów wejściowych. Pozwala to zminimalizować liczbę obiektów zadań, które są wymagane do przetwarzania danych, dzięki czemu aplikacje mogą działać wydajniej. Jednak podczas przetwarzania danych przez zadania z jednego zestawu bloków przepływu danych zadania z innych bloków przepływu danych mogą wymagać poczekania na czas przetwarzania przez kolejkowanie komunikatów. Aby zapewnić lepszą sprawiedliwość spośród zadań przepływu danych, ustaw właściwość <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest ustawiona na <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, co jest ustawieniem domyślnym, zadanie używane przez blok przepływu danych przetwarza tyle komunikatów, ile jest dostępnych. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest ustawiona na wartość inną niż <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, blok przepływu danych przetwarza co najwyżej następującą liczbę komunikatów na <xref:System.Threading.Tasks.Task> obiektu. Chociaż ustawienie właściwości <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> może zwiększyć wartość godziwą między zadaniami, może to spowodować, że system będzie mógł utworzyć więcej zadań, niż jest to konieczne, co może obniżyć wydajność.  
  
### <a name="enabling-cancellation"></a>Włączanie anulowania  
 TPL zapewnia mechanizm, który umożliwia wykonywanie zadań w celu koordynowania anulowania w sposób współpracy. Aby włączyć bloki przepływu danych do uczestnictwa w tym mechanizmie anulowania, ustaw właściwość <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A>. Gdy ten obiekt <xref:System.Threading.CancellationToken> jest ustawiony na stan anulowane, wszystkie bloki przepływu danych, które monitorują ten token, zakończą wykonywanie bieżącego elementu, ale nie rozpoczynają przetwarzania kolejnych elementów. Te bloki przepływu danych czyściją także wszystkie buforowane komunikaty, zwalniają połączenia z dowolnymi blokami źródłowymi i docelowymi oraz przejścia do stanu anulowane. Przejście do stanu anulowane powoduje, że właściwość <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> ma właściwość <xref:System.Threading.Tasks.Task.Status%2A> ustawioną na <xref:System.Threading.Tasks.TaskStatus.Canceled>, chyba że wystąpił wyjątek podczas przetwarzania. W takim przypadku <xref:System.Threading.Tasks.Task.Status%2A> jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Aby zapoznać się z przykładem, który ilustruje sposób używania anulowania w aplikacji Windows Forms, zobacz [How to: Cancel a przepływu danych Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Aby uzyskać więcej informacji na temat anulowania w TPL, zobacz [Anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Określanie zachowania zachłanne a inne niż zachłanne  
 Niektóre typy bloków przepływu danych grupowania mogą działać w trybie *zachłanne* lub *innym niż zachłanne* . Domyślnie wstępnie zdefiniowane typy bloku przepływu danych działają w trybie zachłanne.  
  
 W przypadku typów bloku sprzężenia, takich jak <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, tryb zachłanne oznacza, że blok natychmiast akceptuje dane, nawet jeśli odpowiadające im dane, z którymi mają zostać przyłączone, nie są jeszcze dostępne. Tryb inny niż zachłanne oznacza, że blok opóźnia wszystkie komunikaty przychodzące do momentu, gdy jeden z nich jest dostępny w celu zakończenia przyłączenia. Jeśli którykolwiek z odroczonych komunikatów nie jest już dostępny, blok sprzężenia zwalnia wszystkie odroczone komunikaty i ponownie uruchamia proces. W przypadku klasy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> zachowanie zachłanne i inne niż zachłanne jest podobne, z tą różnicą, że w trybie innym niż zachłanne, obiekt <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> opóźnia wszystkie komunikaty przychodzące do momentu uzyskania wystarczającej liczby dostępności z różnych źródeł, aby zakończyć partię.  
  
 Aby określić tryb inny niż zachłanne dla bloku przepływu danych, ustaw <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> na `False`. Aby zapoznać się z przykładem, który ilustruje, jak używać trybu zachłanne, aby umożliwić wielokrotne współużytkowanie źródła danych przez wiele bloków join, zobacz [How to: use klasy JoinBlock do odczytywania danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[Przejdź do góry](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Niestandardowe bloki przepływu danych  
 Chociaż biblioteka TPL przepływu danych udostępnia wiele wstępnie zdefiniowanych typów bloków, można utworzyć dodatkowe typy bloku, które wykonują niestandardowe zachowanie. Zaimplementuj interfejsy <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> lub <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> bezpośrednio lub użyj metody <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A>, aby utworzyć blok złożony, który hermetyzuje zachowanie istniejących typów bloków. Przykłady pokazujące sposób implementacji niestandardowej funkcji blokowania przepływu danych można znaleźć w [przewodniku: Tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[Przejdź do góry](#top)]  
  
## <a name="related-topics"></a>Tematy pokrewne  
  
|Tytuł|Opis|  
|-----------|-----------------|  
|[Instrukcje: zapisywanie komunikatów w bloku przepływu danych i odczytywanie ich z tego bloku](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Demonstruje sposób pisania komunikatów do i odczytywania komunikatów z obiektu <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>.|  
|[Instrukcje: implementowanie wzorca przepływu danych producent — konsument](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Opisuje, w jaki sposób używać modelu przepływu danych do implementowania wzorca producenta, gdzie producent wysyła komunikaty do bloku przepływu danych, a konsument odczytuje komunikaty z tego bloku.|  
|[Instrukcje: wykonywanie akcji w przypadku odebrania danych przez blok przepływu danych](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Opisuje sposób dostarczania delegatów do typów bloku przepływu danych wykonywania, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Przewodnik: tworzenie potoku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Opisuje sposób tworzenia potoku przepływu danych, który pobiera tekst z sieci Web i wykonuje operacje na tym tekście.|  
|[Instrukcje: rozłączanie bloków przepływu danych](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Pokazuje, jak używać metody <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A>, aby odłączyć blok docelowy od jego źródła po utworzeniu przez źródło komunikatu dla elementu docelowego.|  
|[Przewodnik: korzystanie z przepływu danych w aplikacji Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Pokazuje, jak utworzyć sieć bloków przepływu danych, które wykonują przetwarzanie obrazów w aplikacji Windows Forms.|  
|[Instrukcje: anulowanie bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Pokazuje, jak używać anulowania w aplikacji Windows Forms.|  
|[Instrukcje: korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Wyjaśnia, w jaki sposób używać klasy <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> do wykonywania operacji, gdy dane są dostępne z wielu źródeł oraz jak używać trybu zachłanne, aby umożliwić wielokrotne współużytkowanie źródła danych przez wiele bloków sprzężeń.|  
|[Instrukcje: określanie stopnia równoległości w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Opisuje sposób ustawiania właściwości <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> w celu włączenia bloku przepływu danych wykonywania w celu przetworzenia więcej niż jednego komunikatu w danym momencie.|  
|[Instrukcje: określanie harmonogramu zadań w bloku przepływu danych](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Demonstruje sposób kojarzenia określonego harmonogramu zadań w przypadku korzystania z przepływu danych w aplikacji.|  
|[Przewodnik: poprawa wydajności przy użyciu klas BatchBlock i BatchedJoinBlock](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Opisuje, w jaki sposób używać klasy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, aby zwiększyć wydajność operacji wstawiania bazy danych oraz jak używać klasy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> do przechwytywania zarówno wyników, jak i wyjątków, które występują, gdy program odczytuje dane z bazy danych.|  
|[Przewodnik: tworzenie niestandardowego typu bloku przepływu danych](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Ilustruje dwa sposoby tworzenia typu bloku przepływu danych, który implementuje zachowanie niestandardowe.|  
|[Biblioteka zadań równoległych (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Wprowadza TPL, bibliotekę, która upraszcza równoległe i współbieżne programowanie w aplikacjach .NET Framework.|
