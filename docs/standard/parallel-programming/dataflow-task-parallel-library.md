---
title: Przepływ danych (Biblioteka zadań równoległych)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: e1d4dc596f57a4c75c11806f95099ee5593c6c03
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/02/2020
ms.locfileid: "84285537"
---
# <a name="dataflow-task-parallel-library"></a>Przepływ danych (Biblioteka zadań równoległych)
Biblioteka zadań równoległych (TPL) zawiera składniki przepływu danych, które ułatwiają zwiększenie niezawodności aplikacji korzystających z współbieżności. Te składniki przepływu danych są zbiorczo określane jako *Biblioteka TPL przepływu danych*. Ten model przepływu danych wspiera Programowanie oparte na aktorze, zapewniając w procesie przekazywanie komunikatów w celu uzyskania bardziej szczegółowych zadań przepływu danych i potokowych. Składniki przepływu danych są oparte na typach i infrastrukturze planowania TPL i integrują się z obsługą języków C#, Visual Basic i języka F # na potrzeby programowania asynchronicznego. Te składniki przepływu danych są przydatne, gdy istnieje wiele operacji, które muszą komunikować się ze sobą asynchronicznie, lub gdy chcesz przetwarzać dane, gdy staną się dostępne. Rozważmy na przykład aplikację, która przetwarza dane obrazu z kamery sieci Web. Korzystając z modelu przepływu danych, aplikacja może przetwarzać ramki obrazu w miarę ich udostępniania. Jeśli aplikacja rozszerza ramki obrazu, na przykład przez wykonanie korekcji światła lub zmniejszenie oka, można utworzyć *potok* składników przepływu danych. Każdy etap potoku może korzystać z bardziej precyzyjnych funkcji równoległych, takich jak funkcje dostarczone przez TPL, aby przekształcić obraz.  
  
 Ten dokument zawiera omówienie biblioteki przepływu danych TPL. Opisano w nim model programowania, wstępnie zdefiniowane typy bloków przepływu danych oraz sposób konfigurowania bloków przepływu danych w celu spełnienia określonych wymagań aplikacji.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a>Model programowania
 Biblioteka TPL przepływu danych stanowi podstawę przekazywania komunikatów i przekształcają intensywnie korzystających z procesora CPU aplikacji intensywnie wykorzystujących procesor i/wy, które mają wysoką przepływność i małe opóźnienia. Zapewnia również jawną kontrolę nad sposobem buforowania danych i poruszaniem się w systemie. Aby lepiej zrozumieć model programowania przepływu danych, weź pod uwagę aplikację, która asynchronicznie ładuje obrazy z dysku i tworzy złożone obrazy. Tradycyjne modele programistyczne zwykle wymagają używania wywołań zwrotnych i obiektów synchronizacji, takich jak blokady, do koordynowania zadań i uzyskiwania dostępu do udostępnionych danych. Za pomocą modelu programowania przepływu danych można tworzyć obiekty przepływu danych, które przetwarzają obrazy w miarę ich odczytu z dysku. W modelu przepływu danych deklaruje, jak dane są obsługiwane, gdy staną się dostępne, a także wszelkie zależności między danymi. Ponieważ środowisko uruchomieniowe zarządza zależnościami między danymi, często można uniknąć konieczności synchronizacji dostępu do udostępnionych danych. Ponadto, ponieważ harmonogramy środowiska uruchomieniowego są wykonywane na podstawie asynchronicznego przybycia danych, przepływu danych może zwiększyć czas reakcji i przepływność przez wydajne zarządzanie wątkami bazowymi. Aby zapoznać się z przykładem wykorzystującym model programowania przepływu danych do implementowania przetwarzania obrazów w aplikacji Windows Forms, zobacz [Przewodnik: używanie przepływu danych w aplikacji Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Źródła i obiekty docelowe  
 Biblioteka TPL przepływu danych składa się z *bloków przepływu danych*, które są strukturami danych, które buforują i przetwarzają dane. TPL definiuje trzy rodzaje bloków przepływu danych: *bloków źródłowych*, *bloków docelowych*i *bloków propagacji*. Blok źródłowy działa jako źródło danych i może zostać odczytany. Blok docelowy działa jako odbiorca danych i może być zapisany w. Blok propagator działa zarówno jako blok źródłowy, jak i blok docelowy i może być odczytywany i zapisywana. TPL definiuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interfejs do reprezentowania źródeł, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> reprezentujący obiekty docelowe i <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> reprezentujący propagator. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>dziedziczy z obu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> .  
  
 Biblioteka TPL przepływu danych zawiera kilka wstępnie zdefiniowanych typów bloków przepływu danych, które implementują <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsy, i <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> . Te typy bloków przepływu danych zostały opisane w tym dokumencie w sekcji [wstępnie zdefiniowane typy bloków przepływu danych](#predefined-dataflow-block-types).  
  
### <a name="connecting-blocks"></a>Łączenie bloków  
 Bloki przepływu danych można połączyć z *potokami*, które są sekwencjami liniowymi bloków przepływu danych lub *sieci*, które są wykresami bloków przepływu danych. Potok jest jedną z form sieci. W potoku lub sieci źródła asynchronicznie propagują dane do obiektów docelowych, ponieważ te dane staną się dostępne. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType>Metoda łączy źródłowy blok przepływu danych z blokiem docelowym. Źródło może być połączone z zero lub więcej obiektami docelowymi; elementy docelowe mogą być połączone z zera lub więcej źródeł. Możesz dodawać lub usuwać bloki przepływu danych do lub z potoku lub sieci jednocześnie. Wstępnie zdefiniowane typy bloku przepływu danych obsługują wszystkie aspekty bezpiecznego wątku łączące i odłączania.  
  
 Aby uzyskać przykład, który łączy bloki przepływu danych w celu utworzenia potoku podstawowego, zobacz [Przewodnik: Tworzenie potoku przepływu danych](walkthrough-creating-a-dataflow-pipeline.md). Aby uzyskać przykład, który łączy bloki przepływu danych w celu utworzenia bardziej złożonej sieci, zobacz [Przewodnik: używanie przepływu danych w aplikacji Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md). Aby uzyskać przykład, który odłącza obiekt docelowy od źródła, gdy źródło zawiera docelowy komunikat, zobacz [How to: relink Blocks przepływu danych](how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrowanie  
 Po wywołaniu <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> metody w celu połączenia źródła z obiektem docelowym można dostarczyć delegata, który określa, czy blok docelowy akceptuje lub odrzuca komunikat na podstawie wartości tego komunikatu. Mechanizm filtrowania jest użytecznym sposobem zagwarantowania, że blok przepływu danych odbiera tylko niektóre wartości. W przypadku większości wstępnie zdefiniowanych typów bloków przepływu danych, jeśli blok źródłowy jest połączony z wieloma blokami docelowymi, gdy blok docelowy odrzuci komunikat, Źródło oferuje ten komunikat do następnego celu. Kolejność, w której źródło oferuje komunikaty do obiektów docelowych, jest definiowana przez źródło i może się różnić w zależności od typu źródła. Większość typów bloków źródłowych przerywa oferowanie komunikatu po zaakceptowaniu tego komunikatu przez jeden obiekt docelowy. Jedynym wyjątkiem od tej reguły jest <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Klasa, która oferuje każdy komunikat do wszystkich obiektów docelowych, nawet jeśli niektóre obiekty docelowe odrzucają komunikat. Aby zapoznać się z przykładem, który używa filtrowania do przetwarzania tylko niektórych komunikatów, zobacz [Przewodnik: korzystanie z przepływu danych w aplikacji Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
> Ponieważ każdy wstępnie zdefiniowany typ bloku Source przepływu danych gwarantuje, że komunikaty są rozmnożone w kolejności, w której są odbierane, każdy komunikat musi zostać odczytany z bloku źródłowego, zanim blok źródłowy będzie mógł przetworzyć następny komunikat. Dlatego w przypadku używania filtrowania do łączenia wielu obiektów docelowych ze źródłem upewnij się, że co najmniej jeden blok docelowy otrzymuje każdy komunikat. W przeciwnym razie aplikacja może zakleszczenie.  
  
### <a name="message-passing"></a>Przekazywanie komunikatów  
 Model programowania przepływu danych jest powiązany z koncepcją *przekazywania komunikatów*, gdzie niezależne składniki programu komunikują się ze sobą przez wysyłanie komunikatów. Jednym ze sposobów propagowania komunikatów między składnikami aplikacji jest wywoływanie <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> metod i wysyłanie komunikatów do docelowego bloku przepływu danych Blocks ( <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> działa synchronicznie; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> działa asynchronicznie) oraz <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A> metod, i, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> Aby odbierać komunikaty z bloków źródłowych. Można połączyć te metody z potokami przepływu danych lub sieciami, wysyłając dane wejściowe do węzła głównego (blok docelowy) i pobierając dane wyjściowe z węzła terminalu potoku lub węzłów terminalu sieci (co najmniej jeden blok źródłowy). Można również użyć <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> metody do odczytu z pierwszego z podanych źródeł, które mają dostępne dane, i wykonywania akcji na tych danych.  
  
 Bloki źródła oferują dane do bloków docelowych przez wywołanie <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> metody. Blok docelowy reaguje na oferowany komunikat na jeden z trzech sposobów: może zaakceptować komunikat, odrzucić komunikat lub odłożyć komunikat. Gdy obiekt docelowy akceptuje komunikat, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> Metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted> . Gdy obiekt docelowy odrzuci komunikat, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> Metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined> . Gdy element docelowy wymaga, aby nie odbierał już żadnych komunikatów ze źródła, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> zwraca wartość <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently> . Wstępnie zdefiniowane typy bloków źródłowych nie oferują komunikatów do połączonych obiektów docelowych po odebraniu takiej wartości zwracanej i automatycznie odłączają od tych elementów docelowych.  
  
 Gdy blok docelowy opóźnia komunikat do późniejszego użycia, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> Metoda zwraca <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed> . Blok docelowy, który opóźnia komunikat, może później wywołać metodę, <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> aby spróbować zarezerwować proponowany komunikat. W tym momencie komunikat jest nadal dostępny i może być używany przez blok docelowy lub komunikat został wykonany przez inny element docelowy. Gdy blok docelowy później wymaga wiadomości lub nie potrzebuje już komunikatu, wywołuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> odpowiednio metodę lub. Rezerwacja komunikatów jest zwykle używana przez typy bloku przepływu danych, które działają w trybie innym niż zachłanne. Tryb inny niż zachłanne został wyjaśniony w dalszej części tego dokumentu. Zamiast obsłużyć odroczony komunikat, blok docelowy może również użyć <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> metody, aby próbować bezpośrednio wykorzystać odroczony komunikat.  
  
### <a name="dataflow-block-completion"></a>Zakończenie bloku przepływu danych  
 Bloki przepływu danych obsługują również koncepcję *uzupełniania*. Blok przepływu danych, który jest w stanie ukończone, nie wykonuje żadnych dalszych zadań. Każdy blok przepływu danych ma skojarzony <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> obiekt, znany jako *zadanie uzupełniania*, reprezentujący stan ukończenia bloku. Ponieważ możesz poczekać na <xref:System.Threading.Tasks.Task> zakończenie obiektu za pomocą zadań ukończenia, możesz poczekać na zakończenie co najmniej jednego węzła terminalu sieci przepływu danych. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>Interfejs definiuje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metodę, która informuje blok przepływu danych o żądaniu do ukończenia, i <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> Właściwość, która zwraca zadanie ukończenia dla bloku przepływu danych. Oba <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> i <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> dziedziczą <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfejs.  
  
 Istnieją dwa sposoby, aby określić, czy blok przepływu danych zakończył pracę bez błędu, napotkał co najmniej jeden błąd lub został anulowany. Pierwszym sposobem jest wywołanie <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody w zadaniu zakończenia w `try` - `catch` bloku ( `Try` - `Catch` w Visual Basic). Poniższy przykład tworzy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiekt, który zgłasza, <xref:System.ArgumentOutOfRangeException> jeśli jego wartość wejściowa jest mniejsza od zera. <xref:System.AggregateException>jest zgłaszany, gdy ten przykład wywołuje <xref:System.Threading.Tasks.Task.Wait%2A> zadanie ukończenia. Dostęp do niego odbywa <xref:System.ArgumentOutOfRangeException> się za pomocą <xref:System.AggregateException.InnerExceptions%2A> właściwości <xref:System.AggregateException> obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 W tym przykładzie pokazano przypadek, w którym wyjątek jest nieobsługiwany w delegatze bloku przepływu danych wykonywania. Zalecamy obsługę wyjątków w treści takich bloków. Jednakże jeśli nie można tego zrobić, blok zachowuje się tak, jakby został anulowany i nie przetwarza komunikatów przychodzących.  
  
 Gdy blok przepływu danych zostanie anulowany jawnie, <xref:System.AggregateException> obiekt zawiera <xref:System.OperationCanceledException> <xref:System.AggregateException.InnerExceptions%2A> Właściwość. Aby uzyskać więcej informacji na temat anulowania przepływu danych, zobacz sekcję [Włączanie anulowania](#enabling-cancellation) .  
  
 Drugi sposób na określenie stanu ukończenia bloku przepływu danych polega na kontynuacji zadania ukończenia lub użyciu funkcji języka asynchronicznego języka C# i Visual Basic, aby asynchronicznie oczekiwać na ukończenie zadania. Delegat dostarczany do <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metody przyjmuje <xref:System.Threading.Tasks.Task> obiekt, który reprezentuje zadanie poprzedzające. W przypadku <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> Właściwości delegat dla kontynuacji pobiera samo zadanie zakończenia. Poniższy przykład przypomina poprzednią, z tą różnicą, że używa również <xref:System.Threading.Tasks.Task.ContinueWith%2A> metody do tworzenia zadania kontynuacji, które drukuje stan ogólnej operacji przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Możesz również użyć właściwości, takich jak <xref:System.Threading.Tasks.Task.IsCanceled%2A> w treści zadania kontynuacji, aby określić dodatkowe informacje o stanie ukończenia bloku przepływu danych. Aby uzyskać więcej informacji na temat zadań kontynuacji i sposobu ich odnoszących do anulowania i obsługi błędów, zobacz Tworzenie [łańcucha zadań przy użyciu zadań kontynuacji](chaining-tasks-by-using-continuation-tasks.md), [anulowania zadań](task-cancellation.md)i [obsługi wyjątków](exception-handling-task-parallel-library.md).  

## <a name="predefined-dataflow-block-types"></a>Wstępnie zdefiniowane typy bloków przepływu danych  
 Biblioteka TPL przepływu danych zawiera kilka wstępnie zdefiniowanych typów bloków przepływu danych. Te typy są podzielone na trzy kategorie: *buforowanie bloków*, *bloków wykonywania*i *bloków grupowania*. W poniższych sekcjach opisano typy bloków, które składają się na te kategorie.  
  
### <a name="buffering-blocks"></a>Buforowanie bloków  
 Bloki buforowania przechowują dane do użycia przez użytkowników danych. Biblioteka TPL przepływu danych zawiera trzy typy bloków buforowania: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType> , <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> , i <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType> .  
  
#### <a name="bufferblockt"></a>BufferBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>Klasa reprezentuje strukturę asynchronicznej obsługi komunikatów ogólnego przeznaczenia. Ta klasa przechowuje kolejki w pierwszej kolejności (FIFO) komunikatów, które mogą być zapisywane przez wiele źródeł lub odczytywane przez wiele obiektów docelowych. Gdy obiekt docelowy otrzymuje komunikat z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, ten komunikat zostanie usunięty z kolejki komunikatów. W związku z tym mimo że <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiekt może mieć wiele obiektów docelowych, tylko jeden element docelowy otrzyma każdy komunikat. <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>Klasa jest przydatna, gdy chcesz przekazać wiele komunikatów do innego składnika, a ten składnik musi odebrać każdy komunikat.  
  
 Poniższy przykład podstawowy zapisuje kilka <xref:System.Int32> wartości do <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, a następnie odczytuje te wartości z powrotem z tego obiektu.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Aby zapoznać się z kompletnym przykładem, który ilustruje sposób pisania komunikatów do i odczytywania komunikatów z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu, zobacz [How to: Write messages to and Read messages Block przepływu danych](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>Klasa jest przydatna, gdy musisz przekazać wiele komunikatów do innego składnika, ale ten składnik wymaga tylko najnowszej wartości. Ta klasa jest również przydatna, gdy chcesz emitować komunikat do wielu składników.  
  
 Poniższy przykład podstawowy zapisuje <xref:System.Double> wartość do <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektu, a następnie odczytuje tę wartość z tego obiektu kilka razy. Ponieważ wartości nie są usuwane z <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> obiektów po ich odczytaniu, ta sama wartość jest dostępna za każdym razem.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Aby zapoznać się z kompletnym przykładem służącym <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> do rozgłaszania komunikatów do wielu bloków docelowych, zobacz [How to: Określanie harmonogram zadań w bloku przepływu danych](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>Klasa jest podobna do <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> klasy, z tą różnicą, że <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt może być zapisywana tylko raz. Można traktować <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> jako podobny do słowa kluczowego [ReadOnly](../../csharp/language-reference/keywords/readonly.md) ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) w Visual Basic), z tą różnicą, że <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt staje się niemodyfikowalny po odebraniu wartości, a nie w konstrukcji. Podobnie jak <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Klasa, gdy obiekt docelowy otrzymuje komunikat z <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektu, ten komunikat nie jest usuwany z tego obiektu. W związku z tym wiele obiektów docelowych otrzymuje kopię wiadomości. <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>Klasa jest przydatna, gdy chcesz propagować tylko pierwszy z wielu komunikatów.  
  
 Poniższy przykład podstawowy zapisuje wiele <xref:System.String> wartości do <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiektu, a następnie odczytuje wartość z powrotem z tego obiektu. Ponieważ <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> obiekt może być zapisywany tylko jeden raz, po <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> odebraniu komunikatu przez obiekt odrzuci kolejne komunikaty.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Aby zapoznać się z kompletnym przykładem, który pokazuje, jak użyć <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> do uzyskania wartości pierwszej operacji, która kończy się, zobacz [How to: relink Blocks przepływu danych](how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Bloki wykonywania  
 Bloki wykonywania wywołują delegata dostarczony przez użytkownika dla każdej z odebranych danych. Biblioteka TPL przepływu danych zawiera trzy typy bloków wykonywania: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> , <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> , i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType> .  
  
#### <a name="actionblockt"></a>ActionBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>Klasa jest blokiem docelowym, który wywołuje delegata po odebraniu danych. Zastanów się <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu jako delegata, który jest uruchamiany asynchronicznie, gdy dane staną się dostępne. Delegat, który można przekazać do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu, może być typu <xref:System.Action%601> lub typu `System.Func<TInput, Task>` . Gdy używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu z <xref:System.Action%601> , przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy delegat zwraca. Gdy używasz <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu z `System.Func<TInput, Task>` , przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy zwracany <xref:System.Threading.Tasks.Task> obiekt jest zakończony. Korzystając z tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> zarówno do przetwarzania synchronicznego, jak i asynchronicznego dla każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy zapisuje wiele <xref:System.Int32> wartości do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> obiektu. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>Obiekt drukuje te wartości do konsoli. W tym przykładzie ustawia blok do stanu ukończone i czeka na zakończenie wszystkich zadań przepływu danych.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Aby zapoznać się z kompletnymi przykładami, które pokazują, jak używać delegatów z <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> klasą, zobacz [How to: wykonywanie akcji, gdy blok przepływu danych odbiera dane](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>Klasa jest podobna do <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> klasy, z tą różnicą, że działa jako źródło i jako element docelowy. Delegat przekazywany do <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu zwraca wartość typu `TOutput` . Delegat, który podaje się do <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu, może być typu `System.Func<TInput, TOutput>` lub typu `System.Func<TInput, Task<TOutput>>` . Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu z `System.Func<TInput, TOutput>` , przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy delegat zwraca. Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiektu używanego z `System.Func<TInput, Task<TOutput>>` , przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy zwracany <xref:System.Threading.Tasks.Task%601> obiekt jest zakończony. Podobnie jak w przypadku <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> , korzystając z tych dwóch mechanizmów, można użyć <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> zarówno do przetwarzania synchronicznego, jak i asynchronicznego dla każdego elementu wejściowego.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt, który oblicza pierwiastek kwadratowy jego danych wejściowych. <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>Obiekt pobiera <xref:System.Int32> wartości jako dane wejściowe i generuje <xref:System.Double> wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Aby zapoznać się z kompletnymi przykładami używanymi <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> w sieci bloków przepływu danych, które wykonują przetwarzanie obrazów w aplikacji Windows Forms, zobacz [Przewodnik: używanie przepływu danych w aplikacji Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>Klasa jest podobna do <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> klasy, z tą różnicą, że <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> generuje zero lub więcej wartości wyjściowych dla każdej wartości wejściowej, a nie tylko jedną wartość wyjściową dla każdej wartości wejściowej. Delegat, który podaje się do <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektu, może być typu `System.Func<TInput, IEnumerable<TOutput>>` lub typu `System.Func<TInput, Task<IEnumerable<TOutput>>>` . Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektu z `System.Func<TInput, IEnumerable<TOutput>>` , przetwarzanie każdego elementu wejściowego jest uznawane za ukończone, gdy delegat zwraca. Gdy używasz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektu z `System.Func<TInput, Task<IEnumerable<TOutput>>>` , przetwarzanie każdego elementu wejściowego jest uznawane za ukończone tylko wtedy, gdy zwracany `System.Threading.Tasks.Task<IEnumerable<TOutput>>` obiekt jest zakończony.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekt dzielący ciągi na ich poszczególne sekwencje znaków. <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>Obiekt pobiera <xref:System.String> wartości jako dane wejściowe i generuje <xref:System.Char> wartości jako dane wyjściowe.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Aby zapoznać się z kompletnymi przykładami używanymi <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> do tworzenia wielu niezależnych danych wyjściowych dla każdego elementu wejściowego w potoku przepływu danych, zobacz [Przewodnik: Tworzenie potoku przepływu danych](walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Stopień równoległości  
 Każdy <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> obiekt, i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> buforuje komunikaty wejściowe do momentu, gdy blok jest gotowy do przetworzenia. Domyślnie te klasy przetwarzają komunikaty w kolejności, w której są odbierane, po jednym komunikacie. Można również określić stopień równoległości do włączenia <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> oraz <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiekty do równoczesnego przetwarzania wielu komunikatów. Więcej informacji o jednoczesnym wykonywaniu można znaleźć w sekcji Określanie stopnia równoległości w dalszej części tego dokumentu. Aby uzyskać przykład, który ustawia stopień równoległości, aby umożliwić blokowi przepływu danych wykonywania przetwarzanie więcej niż jednego komunikatu jednocześnie, zobacz [How to: Określanie stopnia równoległości w bloku przepływu danych](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Podsumowanie typów delegatów  
 Poniższa tabela zawiera podsumowanie typów delegatów, które można dostarczyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> , <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> obiektów. Ta tabela określa również, czy typ delegata działa synchronicznie, czy asynchronicznie.  
  
|Typ|Typ delegata synchronicznego|Typ delegata asynchronicznego|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Można również użyć wyrażeń lambda podczas pracy z typami bloków wykonywania. Aby zapoznać się z przykładem, który pokazuje, jak używać wyrażenia lambda z blokiem wykonywania, zobacz [How to: wykonywanie akcji, gdy blok przepływu danych odbiera dane](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Bloki grupowania  
 Bloki grupowania łączą dane z co najmniej jednego źródła i w różnych ograniczeniach. Biblioteka TPL przepływu danych zawiera trzy typy bloków sprzężenia: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> , <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> , i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> .  
  
#### <a name="batchblockt"></a>BatchBlock (T)  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>Klasa łączy zestawy danych wejściowych, które są nazywane partiami, do tablic danych wyjściowych. Podczas tworzenia obiektu należy określić rozmiar każdej partii <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> . Gdy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt otrzymuje określoną liczbę elementów wejściowych, asynchronicznie propaguje tablicę zawierającą te elementy. Jeśli <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt jest ustawiony na stan ukończony, ale nie zawiera wystarczającej liczby elementów, aby utworzyć partię, propaguje ostateczną tablicę zawierającą pozostałe elementy wejściowe.  
  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>Klasa działa w trybie *zachłanne* lub *innym niż zachłanne* . W trybie zachłanne, który jest domyślnym, <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt akceptuje każdy komunikat, że jest oferowany, i propaguje tablicę po odebraniu określonej liczby elementów. W trybie innym niż zachłanne <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt opóźnia wszystkie komunikaty przychodzące do momentu, gdy wystarczające źródła nie zaoferują komunikatów do bloku, aby utworzyć partię. Tryb zachłanne zazwyczaj wykonuje lepsze niż tryb inny niż zachłanne, ponieważ wymaga mniejszego obciążenia przetwarzania. Można jednak używać trybu zachłanne, gdy trzeba skoordynować użycie z wielu źródeł w sposób niepodzielny. Określ tryb inny niż zachłanne, ustawiając <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> wartość `False` w `dataflowBlockOptions` parametrze w <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> konstruktorze.  
  
 Poniższy przykład podstawowy zapisuje kilka <xref:System.Int32> wartości do <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiektu, który przechowuje dziesięć elementów w partii. W celu zagwarantowania, że wszystkie wartości są propagowane z <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> , ten przykład wywołuje <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metodę. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>Metoda ustawia <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt na stan ukończony i w związku z tym <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt propaguje wszystkie pozostałe elementy jako końcową partię.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Aby zapoznać się z kompletnym przykładem, który służy <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> do poprawiania wydajności operacji wstawiania bazy danych, zobacz [Przewodnik: używanie BatchBlock i BatchedJoinBlock w celu zwiększenia wydajności](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>Klasy JoinBlock (T1, T2,...)  
 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>Klasy i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> zbierają elementy wejściowe i propagują <xref:System.Tuple%602?displayProperty=nameWithType> <xref:System.Tuple%603?displayProperty=nameWithType> obiekty, które zawierają te elementy. <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>Klasy i nie <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> dziedziczą z <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> . Zamiast tego dostarczają właściwości, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A> , <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> , i <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A> , które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> .  
  
 Podobnie <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> jak <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> w trybie zachłanne lub zachłanne. W trybie zachłanne, który jest wartością domyślną, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> lub <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt akceptuje każdy komunikat, że jest oferowany, i propaguje spójność kolekcji po każdym z jej obiektów docelowych odbiera co najmniej jeden komunikat. W trybie innym niż zachłanne <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiekt lub odrzuca <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> wszystkie komunikaty przychodzące do momentu zaoferowania wszystkim elementom docelowym danych, które są wymagane do utworzenia krotki. W tym momencie blok jest zaangażowany w dwufazowego protokołu zatwierdzania w celu niepodzielnego pobrania wszystkich wymaganych elementów ze źródeł. To odroczenie pozwala innym jednostkom zużywać dane w międzyczasie, aby umożliwić całkowitemu systemowi przeprowadzenie do przodu postępu.  
  
 Poniższy przykład podstawowy ilustruje przypadek, w którym <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt wymaga wielu danych do obliczenia wartości. Ten przykład tworzy <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obiekt, który wymaga dwóch <xref:System.Int32> wartości i <xref:System.Char> wartości do wykonania operacji arytmetycznej.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Aby zapoznać się z kompletnym przykładem, który używa <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> obiektów w trybie innym niż zachłanne do współdzielenia zasobu, zobacz [How to: use klasy JoinBlock do odczytywania danych z wielu źródeł](how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock (T1, T2,...)  
 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>Klasy i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> zbierają partie elementów wejściowych i propaguje `System.Tuple(IList(T1), IList(T2))` `System.Tuple(IList(T1), IList(T2), IList(T3))` obiekty, które zawierają te elementy. Należy traktować <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> jako kombinację <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> i <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> . Określ rozmiar każdej partii podczas tworzenia <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>zawiera również właściwości <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> i <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> , które implementują <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> . Gdy określona liczba elementów wejściowych jest odbierana z wszystkich obiektów docelowych, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiekt asynchronicznie propaguje `System.Tuple(IList(T1), IList(T2))` obiekt, który zawiera te elementy.  
  
 Poniższy przykład podstawowy tworzy <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiekt, który przechowuje wyniki, <xref:System.Int32> wartości i błędy, które są <xref:System.Exception> obiektami. Ten przykład wykonuje wiele operacji i zapisuje wyniki do <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> właściwości oraz błędy do <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> właściwości <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> obiektu. Ze względu na to, że liczba zakończonych powodzeniem i zakończonych niepowodzeniem operacji jest nieznana z wyprzedzeniem, <xref:System.Collections.Generic.IList%601> obiekty umożliwiają każdy element docelowy otrzymać zero lub więcej wartości.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Aby zapoznać się z kompletnym przykładem, który używa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> do przechwytywania zarówno wyników, jak i wyjątków, które występują, gdy program odczytuje z bazy danych, zobacz [Przewodnik: korzystanie z BatchBlock i BatchedJoinBlock w celu zwiększenia wydajności](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  

## <a name="configuring-dataflow--block-behavior"></a>Konfigurowanie zachowania blokowania przepływu danych  
 Dodatkowe opcje można włączyć, dostarczając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> obiekt do konstruktora typów bloków przepływu danych. Te opcje kontrolują zachowanie, takie jak harmonogram zarządzający zadaniem podstawowym i stopień równoległości. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>Ma także typy pochodne, które określają zachowanie specyficzne dla określonych typów bloku przepływu danych. Poniższa tabela zawiera podsumowanie typów opcji skojarzonych z każdym typem bloku przepływu danych.  
  
|Typ bloku przepływu danych|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>Wprowadź|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 W poniższych sekcjach znajdują się dodatkowe informacje o ważnych typach opcji blokowania przepływu danych, które są dostępne za <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> pomocą <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> klas, i <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> .  
  
### <a name="specifying-the-task-scheduler"></a>Określanie Harmonogram zadań  
 Każdy wstępnie zdefiniowany blok przepływu danych używa mechanizmu planowania zadań TPL do wykonywania działań, takich jak propagowanie danych do obiektu docelowego, pobieranie danych ze źródła i uruchamianie delegatów zdefiniowanych przez użytkownika, gdy dane staną się dostępne. <xref:System.Threading.Tasks.TaskScheduler>jest klasą abstrakcyjną, która reprezentuje harmonogram zadań, który kolejkuje zadania na wątki. Domyślny harmonogram zadań, <xref:System.Threading.Tasks.TaskScheduler.Default%2A> , używa <xref:System.Threading.ThreadPool> klasy do kolejkowanie i wykonywanie pracy. Można zastąpić domyślny harmonogram zadań, ustawiając <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> Właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Gdy ten sam harmonogram zadań zarządza wieloma blokami przepływu danych, może wymuszać zasady dla nich. Jeśli na przykład wiele bloków przepływu danych jest skonfigurowanych pod kątem wyłącznego harmonogramu tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektu, wszystkie zadania działające w ramach tych bloków są serializowane. Podobnie, jeśli te bloki są skonfigurowane pod kątem współbieżnego harmonogramu tego samego <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> obiektu, a harmonogram jest skonfigurowany tak, aby miał maksymalny poziom współbieżności, wszystkie prace z tych bloków są ograniczone do tej liczby współbieżnych operacji. Aby zapoznać się z przykładem, który używa <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> klasy do włączania operacji odczytu równolegle, ale operacje zapisu mają być wykonywane wyłącznie przez wszystkie inne operacje, zobacz [How to: Określanie harmonogram zadań w bloku przepływu danych](how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Aby uzyskać więcej informacji na temat harmonogramów zadań w TPL, zobacz <xref:System.Threading.Tasks.TaskScheduler> temat Klasa.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Określanie stopnia równoległości  
 Domyślnie trzy typy bloków wykonywania, które Biblioteka TPL przepływu danych udostępniają,, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> , przetwarzają jeden komunikat w danym momencie. Te typy bloków przepływu danych również przetwarzają komunikaty w kolejności, w jakiej zostały odebrane. Aby włączyć te bloki przepływu danych do przetwarzania komunikatów współbieżnie, należy ustawić <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> Właściwość podczas konstruowania obiektu bloku przepływu danych.  
  
 Wartość domyślna <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> wynosi 1, co gwarantuje, że blok przepływu danych przetwarza jeden komunikat w danym momencie. Ustawienie tej właściwości na wartość, która jest większa niż 1 umożliwia blokowi przepływu danych przetwarzanie wielu komunikatów współbieżnie. Ustawienie tej właściwości umożliwia <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> Uruchamianie bazowego harmonogramu zadań w celu zarządzania maksymalnym stopień współbieżności.  
  
> [!IMPORTANT]
> W przypadku określenia maksymalnego stopnia równoległości, który jest większy niż 1, wiele komunikatów jest przetwarzanych jednocześnie i dlatego komunikaty mogą nie być przetwarzane w kolejności, w której zostały odebrane. Kolejność, w jakiej komunikaty są wyprowadzane z bloku, jest jednak taka sama, w której zostały odebrane.  
  
 Ponieważ <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> Właściwość reprezentuje maksymalny stopień równoległości, blok przepływu danych może być wykonywany z mniejszym stopieńem równoległości niż określono. Blok przepływu danych może używać mniejszego stopnia równoległości w celu spełnienia wymagań funkcjonalnych lub braku dostępnych zasobów systemowych. Blok przepływu danych nigdy nie wybiera bardziej równoległości niż określono.  
  
 Wartość <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwości jest wyłącznie dla każdego obiektu bloku przepływu danych. Na przykład jeśli cztery obiekty przepływu danych bloku Each określają 1 dla maksymalnego stopnia równoległości, wszystkie cztery obiekty bloku przepływu danych mogą być uruchamiane równolegle.  
  
 Aby uzyskać przykład, który ustawia maksymalny stopień równoległości, aby umożliwić równoległe wykonywanie operacji, zobacz [How to: Określanie stopnia równoległości w bloku przepływu danych](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Określanie liczby komunikatów na zadanie  
 Wstępnie zdefiniowane typy bloków przepływu danych używają zadań do przetwarzania wielu elementów wejściowych. Pozwala to zminimalizować liczbę obiektów zadań, które są wymagane do przetwarzania danych, dzięki czemu aplikacje mogą działać wydajniej. Jednak podczas przetwarzania danych przez zadania z jednego zestawu bloków przepływu danych zadania z innych bloków przepływu danych mogą wymagać poczekania na czas przetwarzania przez kolejkowanie komunikatów. Aby zapewnić lepszą sprawiedliwość między zadaniami przepływu danych, ustaw <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> Właściwość. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest ustawiona na <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> , jest to ustawienie domyślne, zadanie używane przez blok przepływu danych przetwarza tyle komunikatów, ile jest dostępnych. Gdy <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> jest ustawiona na wartość inną niż <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded> , blok przepływu danych przetwarza co najwyżej następującą liczbę komunikatów na <xref:System.Threading.Tasks.Task> obiekt. Chociaż ustawienie <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> właściwości może zwiększyć atrakcyjność między zadaniami, może to spowodować, że system będzie mógł utworzyć więcej zadań, niż jest to konieczne, co może obniżyć wydajność.  
  
### <a name="enabling-cancellation"></a>Włączanie anulowania  
 TPL zapewnia mechanizm, który umożliwia wykonywanie zadań w celu koordynowania anulowania w sposób współpracy. Aby włączyć bloki przepływu danych do uczestnictwa w tym mechanizmie anulowania, należy ustawić <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> Właściwość. Gdy ten <xref:System.Threading.CancellationToken> obiekt jest ustawiony na stan anulowane, wszystkie bloki przepływu danych, które monitorują ten token, zakończą wykonywanie bieżącego elementu, ale nie rozpoczynają przetwarzania kolejnych elementów. Te bloki przepływu danych czyściją także wszystkie buforowane komunikaty, zwalniają połączenia z dowolnymi blokami źródłowymi i docelowymi oraz przejścia do stanu anulowane. Przejście do stanu anulowane powoduje, <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> że właściwość ma <xref:System.Threading.Tasks.Task.Status%2A> ustawioną właściwość na <xref:System.Threading.Tasks.TaskStatus.Canceled> , chyba że wystąpił wyjątek podczas przetwarzania. W takim przypadku <xref:System.Threading.Tasks.Task.Status%2A> jest ustawiony na <xref:System.Threading.Tasks.TaskStatus.Faulted> .  
  
 Aby zapoznać się z przykładem, który ilustruje sposób używania anulowania w aplikacji Windows Forms, zobacz [How to: Cancel a przepływu danych Block](how-to-cancel-a-dataflow-block.md). Aby uzyskać więcej informacji na temat anulowania w TPL, zobacz [Anulowanie zadania](task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Określanie zachowania zachłanne a inne niż zachłanne  
 Niektóre typy bloków przepływu danych grupowania mogą działać w trybie *zachłanne* lub *innym niż zachłanne* . Domyślnie wstępnie zdefiniowane typy bloku przepływu danych działają w trybie zachłanne.  
  
 W przypadku typów bloku sprzężenia <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> , takich jak, tryb zachłannenia oznacza, że blok natychmiast akceptuje dane, nawet jeśli odpowiadające im dane, z którymi mają zostać przyłączone, nie są jeszcze dostępne. Tryb inny niż zachłanne oznacza, że blok opóźnia wszystkie komunikaty przychodzące do momentu, gdy jeden z nich jest dostępny w celu zakończenia przyłączenia. Jeśli którykolwiek z odroczonych komunikatów nie jest już dostępny, blok sprzężenia zwalnia wszystkie odroczone komunikaty i ponownie uruchamia proces. W przypadku <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> klasy zachłanne i niezachłanne zachowanie jest podobne, z tą różnicą, że w trybie innym niż zachłanne, <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> obiekt opóźnia wszystkie komunikaty przychodzące do momentu, gdy jest on dostępny z różnych źródeł, aby zakończyć partię.  
  
 Aby określić tryb inny niż zachłanne dla bloku przepływu danych, ustaw wartość <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> na `False` . Aby zapoznać się z przykładem, który ilustruje, jak używać trybu zachłanne, aby umożliwić wielokrotne współużytkowanie źródła danych przez wiele bloków join, zobacz [How to: use klasy JoinBlock do odczytywania danych z wielu źródeł](how-to-use-joinblock-to-read-data-from-multiple-sources.md).

## <a name="custom-dataflow-blocks"></a>Niestandardowe bloki przepływu danych  
 Chociaż biblioteka TPL przepływu danych udostępnia wiele wstępnie zdefiniowanych typów bloków, można utworzyć dodatkowe typy bloku, które wykonują niestandardowe zachowanie. Zaimplementuj <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsy lub bezpośrednio lub Użyj <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> metody, aby utworzyć blok złożony, który hermetyzuje zachowanie istniejących typów bloków. Przykłady pokazujące sposób implementacji niestandardowej funkcji blokowania przepływu danych można znaleźć w [przewodniku: Tworzenie niestandardowego typu bloku przepływu danych](walkthrough-creating-a-custom-dataflow-block-type.md).

## <a name="related-topics"></a>Tematy pokrewne  
  
|Tytuł|Opis|  
|-----------|-----------------|  
|[Instrukcje: Zapisywanie komunikatów w bloku przepływu danych i odczytywanie ich z tego bloku](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Demonstruje sposób pisania komunikatów do i odczytywania wiadomości z <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> obiektu.|  
|[Instrukcje: Implementowanie wzorca przepływu danych producent — konsument](how-to-implement-a-producer-consumer-dataflow-pattern.md)|Opisuje, w jaki sposób używać modelu przepływu danych do implementowania wzorca producenta, gdzie producent wysyła komunikaty do bloku przepływu danych, a konsument odczytuje komunikaty z tego bloku.|  
|[Instrukcje: Wykonywanie akcji w przypadku odebrania danych przez blok przepływu danych](how-to-perform-action-when-a-dataflow-block-receives-data.md)|Opisuje sposób dostarczania delegatów do typów bloku przepływu danych wykonywania,, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> i <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> .|  
|[Przewodnik: Tworzenie potoku przepływu danych](walkthrough-creating-a-dataflow-pipeline.md)|Opisuje sposób tworzenia potoku przepływu danych, który pobiera tekst z sieci Web i wykonuje operacje na tym tekście.|  
|[Instrukcje: Rozłączanie bloków przepływu danych](how-to-unlink-dataflow-blocks.md)|Pokazuje, jak używać <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> metody do odłączenia bloku docelowego od jego źródła, gdy źródło oferuje komunikat do obiektu docelowego.|  
|[Przewodnik: Korzystanie z przepływu danych w aplikacji Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md)|Pokazuje, jak utworzyć sieć bloków przepływu danych, które wykonują przetwarzanie obrazów w aplikacji Windows Forms.|  
|[Instrukcje: Anulowanie bloku przepływu danych](how-to-cancel-a-dataflow-block.md)|Pokazuje, jak używać anulowania w aplikacji Windows Forms.|  
|[Instrukcje: Korzystanie z klasy JoinBlock do odczytywania danych z wielu źródeł](how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Wyjaśnia, w jaki sposób używać <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> klasy do wykonywania operacji, gdy dane są dostępne z wielu źródeł, oraz jak używać trybu zachłanne, aby umożliwić wielu blokom sprzężenia bardziej wydajne udostępnianie źródła danych.|  
|[Instrukcje: Określanie stopnia równoległości w bloku przepływu danych](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Opisuje sposób ustawiania <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> właściwości w celu włączenia bloku przepływu danych wykonywania w celu przetworzenia więcej niż jednego komunikatu w danym momencie.|  
|[Instrukcje: Określanie harmonogramu zadań w bloku przepływu danych](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Demonstruje sposób kojarzenia określonego harmonogramu zadań w przypadku korzystania z przepływu danych w aplikacji.|  
|[Przewodnik: Poprawa wydajności przy użyciu klas BatchBlock i BatchedJoinBlock](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Opisuje sposób użycia klasy w <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> celu zwiększenia wydajności operacji wstawiania bazy danych oraz sposobu używania <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> klasy do przechwytywania zarówno wyników, jak i wyjątków, które występują, gdy program odczytuje z bazy danych.|  
|[Przewodnik: Tworzenie niestandardowego typu bloku przepływu danych](walkthrough-creating-a-custom-dataflow-block-type.md)|Ilustruje dwa sposoby tworzenia typu bloku przepływu danych, który implementuje zachowanie niestandardowe.|  
|[Biblioteka zadań równoległych (TPL)](task-parallel-library-tpl.md)|Wprowadza TPL, bibliotekę, która upraszcza równoległe i współbieżne programowanie w aplikacjach .NET Framework.|
