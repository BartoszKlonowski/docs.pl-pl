---
title: Obsługa wyjątków (Biblioteka zadań równoległych)
description: Poznaj obsługę wyjątków przy użyciu biblioteki zadań równoległych (TPL) w programie .NET. Zapoznaj się z zagnieżdżonymi wyjątkami agregującymi, wyjątkami wewnętrznymi, nieobserwowanymi wyjątkami zadań, & więcej.
ms.date: 04/20/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
ms.openlocfilehash: f1c1a994f4b3a8df0556a0190bc4eacb63f2921e
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662540"
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="f3253-104">Obsługa wyjątków (Biblioteka zadań równoległych)</span><span class="sxs-lookup"><span data-stu-id="f3253-104">Exception handling (Task Parallel Library)</span></span>

<span data-ttu-id="f3253-105">Nieobsłużone wyjątki, które są generowane przez kod użytkownika, który działa wewnątrz zadania są propagowane z powrotem do wątku wywołującego, z wyjątkiem określonych scenariuszy opisanych w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f3253-105">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="f3253-106">Wyjątki są propagowane w przypadku używania jednej z metod statycznych lub wystąpień <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> i są obsługiwane przez załączanie wywołania w `try` / `catch` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f3253-106">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="f3253-107">Jeśli zadanie jest elementem nadrzędnym dołączonych zadań podrzędnych lub jeśli oczekujesz na wiele zadań, może zostać zgłoszonych wiele wyjątków.</span><span class="sxs-lookup"><span data-stu-id="f3253-107">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>

<span data-ttu-id="f3253-108">Aby propagować wszystkie wyjątki z powrotem do wątku wywołującego, infrastruktura zadań zawija je w <xref:System.AggregateException> wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="f3253-108">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="f3253-109"><xref:System.AggregateException>Wyjątek ma <xref:System.AggregateException.InnerExceptions%2A> Właściwość, którą można wyliczyć, aby przeanalizować wszystkie pierwotne wyjątki, które zostały zgłoszone, i dojście (lub nie obsłuży) osobno dla każdego z nich.</span><span class="sxs-lookup"><span data-stu-id="f3253-109">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="f3253-110">Można także obsłużyć pierwotne wyjątki przy użyciu <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="f3253-110">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="f3253-111">Nawet w przypadku zgłoszenia tylko jednego wyjątku jest on nadal opakowany w <xref:System.AggregateException> wyjątek, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f3253-111">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
[!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]

<span data-ttu-id="f3253-112">Można uniknąć nieobsłużonego wyjątku poprzez jedynie przechwycenie <xref:System.AggregateException> i nieprzestrzeganie któregokolwiek z wyjątków wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="f3253-112">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="f3253-113">Nie zaleca się jednak, aby to zrobić, ponieważ jest to analogiczne do przechwytywania <xref:System.Exception> typu podstawowego w scenariuszach nierównoległych.</span><span class="sxs-lookup"><span data-stu-id="f3253-113">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="f3253-114">Aby przechwytywać wyjątek bez podejmowania określonych działań do odzyskania z niego, może to spowodować nieokreślony stan programu.</span><span class="sxs-lookup"><span data-stu-id="f3253-114">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>

<span data-ttu-id="f3253-115">Jeśli nie chcesz wywoływać <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody w celu oczekiwania na ukończenie zadania, możesz również pobrać <xref:System.AggregateException> wyjątek z <xref:System.Threading.Tasks.Task.Exception%2A> właściwości zadania, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f3253-115">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="f3253-116">Aby uzyskać więcej informacji, zobacz sekcję [obserwowanie wyjątków za pomocą właściwości Task. Exception](#observing-exceptions-by-using-the-taskexception-property) w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="f3253-116">For more information, see the [Observing exceptions by using the Task.Exception property](#observing-exceptions-by-using-the-taskexception-property) section in this topic.</span></span>

[!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
[!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]

<span data-ttu-id="f3253-117">Jeśli użytkownik nie czeka na zadanie, które propaguje wyjątek lub uzyskuje dostęp do jego <xref:System.Threading.Tasks.Task.Exception%2A> właściwości, wyjątek zostanie przekazany zgodnie z zasadami wyjątku platformy .NET, gdy zadanie jest zbierane jako elementy bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="f3253-117">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>

<span data-ttu-id="f3253-118">Gdy wyjątki mogą być rzutowane z powrotem do wątku sprzęgania, istnieje możliwość, że zadanie może nadal przetwarzać niektóre elementy po wystąpieniu wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f3253-118">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>

> [!NOTE]
> <span data-ttu-id="f3253-119">Po włączeniu "Tylko mój kod" program Visual Studio będzie przerywał pracę w wierszu, który zgłosi wyjątek i wyświetli komunikat o błędzie "wyjątek nie jest obsługiwany przez kod użytkownika".</span><span class="sxs-lookup"><span data-stu-id="f3253-119">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="f3253-120">Ten błąd jest niegroźny.</span><span class="sxs-lookup"><span data-stu-id="f3253-120">This error is benign.</span></span> <span data-ttu-id="f3253-121">Możesz nacisnąć klawisz F5, aby kontynuować i zobaczyć zachowanie obsługi wyjątków, które przedstawiono w poniższych przykładach.</span><span class="sxs-lookup"><span data-stu-id="f3253-121">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="f3253-122">Aby zapobiec utracie przez program Visual Studio pierwszego błędu, po prostu usuń zaznaczenie pola wyboru **włącz tylko mój kod** w obszarze **Narzędzia, opcje, debugowanie, ogólne**.</span><span class="sxs-lookup"><span data-stu-id="f3253-122">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>

## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="f3253-123">Dołączone zadania podrzędne i zagnieżdżone AggregateExceptions</span><span class="sxs-lookup"><span data-stu-id="f3253-123">Attached child tasks and nested AggregateExceptions</span></span>

<span data-ttu-id="f3253-124">Jeśli zadanie ma dołączone zadanie podrzędne, które zgłasza wyjątek, ten wyjątek jest opakowany <xref:System.AggregateException> przed propagacją do zadania nadrzędnego, co spowoduje, że ten wyjątek jest zawijany przed <xref:System.AggregateException> propagacją z powrotem do wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f3253-124">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="f3253-125">W takich przypadkach <xref:System.AggregateException.InnerExceptions%2A> Właściwość <xref:System.AggregateException> wyjątku, która jest przechwytywana w <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> , <xref:System.Threading.Tasks.Task.WaitAny%2A> , lub, <xref:System.Threading.Tasks.Task.WaitAll%2A> zawiera co najmniej jedno <xref:System.AggregateException> wystąpienie, a nie oryginalne wyjątki, które spowodowały błąd.</span><span class="sxs-lookup"><span data-stu-id="f3253-125">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A>, or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="f3253-126">Aby uniknąć konieczności iteracji w przypadku wyjątków zagnieżdżonych <xref:System.AggregateException> , można użyć <xref:System.AggregateException.Flatten%2A> metody do usunięcia wszystkich zagnieżdżonych <xref:System.AggregateException> wyjątków, aby <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawierała oryginalne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="f3253-126">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="f3253-127">W poniższym przykładzie zagnieżdżone <xref:System.AggregateException> wystąpienia są spłaszczone i obsługiwane w zaledwie jednej pętli.</span><span class="sxs-lookup"><span data-stu-id="f3253-127">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>

[!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
[!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]

<span data-ttu-id="f3253-128">Można również użyć metody, <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> Aby ponownie zgłosić wewnętrzne wyjątki z wielu <xref:System.AggregateException> wystąpień zgłoszonych przez wiele zadań w pojedynczym <xref:System.AggregateException> wystąpieniu, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f3253-128">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
[!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]

## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="f3253-129">Wyjątki z odłączonych zadań podrzędnych</span><span class="sxs-lookup"><span data-stu-id="f3253-129">Exceptions from detached child tasks</span></span>

<span data-ttu-id="f3253-130">Domyślnie zadania podrzędne są tworzone jako odłączone.</span><span class="sxs-lookup"><span data-stu-id="f3253-130">By default, child tasks are created as detached.</span></span> <span data-ttu-id="f3253-131">Wyjątki zgłoszone z odłączonych zadań muszą być obsłużone lub ponownie zgłoszone w bezpośrednim zadaniu nadrzędnym. nie są one propagowane z powrotem do wywołującego wątku w taki sam sposób jak dołączone zadania podrzędne propagowane z powrotem.</span><span class="sxs-lookup"><span data-stu-id="f3253-131">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="f3253-132">Element nadrzędny najwyższego poziomu może ręcznie ponownie zgłosić wyjątek z odłączonego elementu podrzędnego, aby spowodować jego zawinięcie <xref:System.AggregateException> i propagację z powrotem do wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f3253-132">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>

[!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
[!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]

<span data-ttu-id="f3253-133">Nawet w przypadku używania kontynuacji do obserwowania wyjątku w zadaniu podrzędnym wyjątek nadal musi być zaobserwowany przez zadanie nadrzędne.</span><span class="sxs-lookup"><span data-stu-id="f3253-133">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>

## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="f3253-134">Wyjątki wskazujące na odwołanie do spółdzielni</span><span class="sxs-lookup"><span data-stu-id="f3253-134">Exceptions that indicate cooperative cancellation</span></span>

<span data-ttu-id="f3253-135">Jeśli kod użytkownika w zadaniu odpowiada na żądanie anulowania, poprawna procedura polega na wyrzucaniu <xref:System.OperationCanceledException> w tokenie anulowania, na którym żądanie zostało przekazane.</span><span class="sxs-lookup"><span data-stu-id="f3253-135">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="f3253-136">Przed próbą propagowania wyjątku wystąpienie zadania porównuje token w wyjątku z tym, który został przesłany do niego podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="f3253-136">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="f3253-137">Jeśli są takie same, zadanie propaguje <xref:System.Threading.Tasks.TaskCanceledException> opakowane w <xref:System.AggregateException> i może być widoczne po zbadaniu wewnętrznych wyjątków.</span><span class="sxs-lookup"><span data-stu-id="f3253-137">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="f3253-138">Jeśli jednak wątek wywołujący nie oczekuje na zadanie, ten konkretny wyjątek nie zostanie propagowany.</span><span class="sxs-lookup"><span data-stu-id="f3253-138">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="f3253-139">Aby uzyskać więcej informacji, zobacz [Anulowanie zadania](task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="f3253-139">For more information, see [Task Cancellation](task-cancellation.md).</span></span>

[!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
[!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]

## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="f3253-140">Używanie metody obsługi do filtrowania wyjątków wewnętrznych</span><span class="sxs-lookup"><span data-stu-id="f3253-140">Using the handle method to filter inner exceptions</span></span>

<span data-ttu-id="f3253-141">Możesz użyć metody, <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> Aby odfiltrować wyjątki, które można traktować jako "obsłużone" bez użycia żadnej dalszej logiki.</span><span class="sxs-lookup"><span data-stu-id="f3253-141">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="f3253-142">W delegatze użytkownika, który jest dostarczany do <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metody, można sprawdzić typ wyjątku, jego <xref:System.Exception.Message%2A> Właściwość lub inne informacje o nim, które pozwolą określić, czy jest to niegroźne.</span><span class="sxs-lookup"><span data-stu-id="f3253-142">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="f3253-143">Wszelkie wyjątki, dla których zwracane są zwroty delegatów, `false` są ponownie zgłaszane w nowym <xref:System.AggregateException> wystąpieniu natychmiast po <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> powrocie metody.</span><span class="sxs-lookup"><span data-stu-id="f3253-143">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>

<span data-ttu-id="f3253-144">Poniższy przykład jest funkcjonalnie odpowiednikiem pierwszego przykładu w tym temacie, który bada każdy wyjątek w <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f3253-144">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="f3253-145">Zamiast tego ten program obsługi wyjątków wywołuje <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> obiekt metody dla każdego wyjątku i ponownie generuje wyjątki, które nie są `CustomException` wystąpieniami.</span><span class="sxs-lookup"><span data-stu-id="f3253-145">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>

[!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
[!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]

<span data-ttu-id="f3253-146">Poniżej przedstawiono bardziej kompletny przykład wykorzystujący <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> metodę w celu zapewnienia specjalnej obsługi <xref:System.UnauthorizedAccessException> wyjątku podczas wyliczania plików.</span><span class="sxs-lookup"><span data-stu-id="f3253-146">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>

[!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
[!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]

## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="f3253-147">Obserwowanie wyjątków przy użyciu właściwości Task. Exception</span><span class="sxs-lookup"><span data-stu-id="f3253-147">Observing exceptions by using the Task.Exception property</span></span>

<span data-ttu-id="f3253-148">Jeśli zadanie zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> stanie, jego <xref:System.Threading.Tasks.Task.Exception%2A> Właściwość może zostać zbadana w celu odnalezienia, który konkretny wyjątek spowodował błąd.</span><span class="sxs-lookup"><span data-stu-id="f3253-148">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="f3253-149">Dobrym sposobem obserwowania <xref:System.Threading.Tasks.Task.Exception%2A> właściwości jest użycie kontynuacji, która jest uruchamiana tylko wtedy, gdy błędy zadań poprzedzających, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f3253-149">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>

[!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
[!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]

<span data-ttu-id="f3253-150">W zrozumiałej aplikacji delegat kontynuacji może rejestrować szczegółowe informacje o wyjątku i ewentualnie zduplikować nowe zadania w celu odzyskania z tego wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f3253-150">In a meaningful application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span> <span data-ttu-id="f3253-151">Jeśli wystąpią błędy zadań, następujące wyrażenia zwracają wyjątek:</span><span class="sxs-lookup"><span data-stu-id="f3253-151">If a task faults, the following expressions throw the exception:</span></span>

- `await task`
- `task.Wait()`
- `task.Result`
- `task.GetAwaiter().GetResult()`

<span data-ttu-id="f3253-152">Użyj [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) instrukcji, aby obsłużyć i obserwować zgłoszone wyjątki.</span><span class="sxs-lookup"><span data-stu-id="f3253-152">Use a [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) statement to handle and observe thrown exceptions.</span></span> <span data-ttu-id="f3253-153">Alternatywnie, zaobserwuj wyjątek, uzyskując dostęp do <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="f3253-153">Alternatively, observe the exception by accessing the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property.</span></span>

## <a name="unobservedtaskexception-event"></a><span data-ttu-id="f3253-154">Zdarzenie UnobservedTaskException</span><span class="sxs-lookup"><span data-stu-id="f3253-154">UnobservedTaskException event</span></span>

<span data-ttu-id="f3253-155">W niektórych scenariuszach, takich jak w przypadku hostowania niezaufanych wtyczek, niegroźne wyjątki mogą być często używane, a ich ręczne obserwowanie może być utrudnione.</span><span class="sxs-lookup"><span data-stu-id="f3253-155">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="f3253-156">W takich przypadkach można obsłużyć <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="f3253-156">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f3253-157"><xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType>Wystąpienie przekazane do procedury obsługi może służyć do uniemożliwienia propagowania niezauważalnego wyjątku z powrotem do wątku przyłączania.</span><span class="sxs-lookup"><span data-stu-id="f3253-157">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>

## <a name="see-also"></a><span data-ttu-id="f3253-158">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="f3253-158">See also</span></span>

- [<span data-ttu-id="f3253-159">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f3253-159">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
