---
title: Obsługa wyjątku (Biblioteka zadań równoległych)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 16ab0b8967ac394540f201fcc9098024faaccaa7
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="51dcd-102">Obsługa wyjątku (Biblioteka zadań równoległych)</span><span class="sxs-lookup"><span data-stu-id="51dcd-102">Exception Handling (Task Parallel Library)</span></span>
<span data-ttu-id="51dcd-103">Nieobsłużonych wyjątków, które są generowane przez kod użytkownika, który działa wewnątrz zadania są propagowane do wątek wywołujący, z wyjątkiem w niektórych scenariuszach, które zostały opisane w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="51dcd-103">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="51dcd-104">Oczekiwania były propagowane, gdy używany jest jeden statycznych lub wystąpienia <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> lub <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` metod, a ich obsługę, umieszczając wywołanie `try` / `catch` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="51dcd-104">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="51dcd-105">Jeśli zadanie ma element nadrzędny zadania podrzędne dołączone lub oczekiwania na wielu zadań, może zostać zgłoszony wiele wyjątków.</span><span class="sxs-lookup"><span data-stu-id="51dcd-105">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>  
  
 <span data-ttu-id="51dcd-106">Wszystkie wyjątki z powrotem do wątku wywołującym propagację, infrastruktury zadań opakowuje je w <xref:System.AggregateException> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="51dcd-106">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="51dcd-107"><xref:System.AggregateException> Wyjątek ma <xref:System.AggregateException.InnerExceptions%2A> właściwości mogą być wyliczane do Badaj wszystkie wyjątki oryginalnego, które zostały zgłoszone, a obsługa (lub nie obsługują) każdej z nich osobno.</span><span class="sxs-lookup"><span data-stu-id="51dcd-107">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="51dcd-108">Można również obsługiwać przy użyciu oryginalnego wyjątki <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="51dcd-108">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="51dcd-109">Nawet wtedy, gdy tylko jeden wyjątek, nadal jest ujęte w <xref:System.AggregateException> wyjątek, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-109">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
 [!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]  
  
 <span data-ttu-id="51dcd-110">Wystąpił nieobsługiwany wyjątek można uniknąć, po prostu Przechwytywanie <xref:System.AggregateException> i nie stosuje wewnętrzny wyjątki.</span><span class="sxs-lookup"><span data-stu-id="51dcd-110">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="51dcd-111">Jednak zaleca się czy nie zrobisz, ponieważ jest ono odpowiednikiem Przechwytywanie bazie <xref:System.Exception> typu w scenariuszach z systemem innym niż równoległe.</span><span class="sxs-lookup"><span data-stu-id="51dcd-111">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="51dcd-112">Aby przechwytywać wyjątku bez konieczności przełączania określonych czynności, aby odzyskać z niego można pozostawić program w stanie nieokreślonym.</span><span class="sxs-lookup"><span data-stu-id="51dcd-112">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>  
  
 <span data-ttu-id="51dcd-113">Jeśli nie chcesz wywołać <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> lub <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` metody czekać na zakończenie zadania, można również pobrać <xref:System.AggregateException> wyjątku z zadania <xref:System.Threading.Tasks.Task.Exception%2A> właściwości, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-113">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="51dcd-114">Aby uzyskać więcej informacji, zobacz [obserwowania wyjątków przy użyciu właściwości Task.Exception](#ExceptionProp) w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-114">For more information, see the [Observing Exceptions By Using the Task.Exception Property](#ExceptionProp) section in this topic.</span></span>  
  
 [!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
 [!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]  
  
 <span data-ttu-id="51dcd-115">Aby nie czekać na zadanie, które propaguje wyjątku lub dostępu do jego <xref:System.Threading.Tasks.Task.Exception%2A> właściwości, wyjątek eskalacji zgodnie z zasadami wyjątek .NET po ukończeniu zadania zbierane pamięci.</span><span class="sxs-lookup"><span data-stu-id="51dcd-115">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>  
  
 <span data-ttu-id="51dcd-116">Wyjątki mogą bąbelkowy się wstecz, aby łącząca wątku, jest to możliwe, że zadania mogą w dalszym ciągu przetwarzania niektórych elementów po jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="51dcd-116">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="51dcd-117">Po włączeniu "Tylko mój kod" programu Visual Studio w niektórych przypadkach będzie podział wiersza, która zgłasza wyjątek i wyświetlony komunikat o błędzie stwierdzający "wyjątek nie obsłużony przez kod użytkownika."</span><span class="sxs-lookup"><span data-stu-id="51dcd-117">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="51dcd-118">Ten błąd jest niegroźne.</span><span class="sxs-lookup"><span data-stu-id="51dcd-118">This error is benign.</span></span> <span data-ttu-id="51dcd-119">Naciśnij klawisz F5, aby kontynuować i zachowanie obsługi wyjątków, przedstawionej w tym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-119">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="51dcd-120">Aby zapobiec dzieleniu pierwszego błędu w Visual Studio, po prostu usuń zaznaczenie pola wyboru **Włącz opcję tylko mój kod** wyboru **narzędzia, opcje, debugowanie, ogólne**.</span><span class="sxs-lookup"><span data-stu-id="51dcd-120">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>  
  
## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="51dcd-121">Zadania podrzędne dołączone i AggregateExceptions zagnieżdżonych</span><span class="sxs-lookup"><span data-stu-id="51dcd-121">Attached Child Tasks and Nested AggregateExceptions</span></span>  
 <span data-ttu-id="51dcd-122">Jeśli zadanie ma zadanie podrzędne dołączone zgłasza wyjątek, ten wyjątek jest ujęte w <xref:System.AggregateException> zanim zostanie przekazane do zadania nadrzędnego, które zawijany ten wyjątek we własnym <xref:System.AggregateException> przed jego propaguje powrót do wywoływania wątku.</span><span class="sxs-lookup"><span data-stu-id="51dcd-122">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="51dcd-123">W takich przypadkach <xref:System.AggregateException.InnerExceptions%2A> właściwość <xref:System.AggregateException> wyjątek, który zostanie przechwycony na <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> lub <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` lub <xref:System.Threading.Tasks.Task.WaitAny%2A> lub <xref:System.Threading.Tasks.Task.WaitAll%2A> metoda zawiera jeden lub więcej <xref:System.AggregateException> wystąpienia nie oryginalny wyjątki, które spowodowało błąd.</span><span class="sxs-lookup"><span data-stu-id="51dcd-123">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` or <xref:System.Threading.Tasks.Task.WaitAny%2A> or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="51dcd-124">Aby uniknąć konieczności iteracja zagnieżdżone <xref:System.AggregateException> wyjątków, można użyć <xref:System.AggregateException.Flatten%2A> metody, aby usunąć wszystkie zagnieżdżone <xref:System.AggregateException> wyjątki, aby <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> właściwość zawiera oryginalnego wyjątków.</span><span class="sxs-lookup"><span data-stu-id="51dcd-124">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="51dcd-125">W poniższym przykładzie zagnieżdżone <xref:System.AggregateException> wystąpienia są spłaszczane i obsługiwane tylko jednej pętli.</span><span class="sxs-lookup"><span data-stu-id="51dcd-125">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>  
  
 [!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
 [!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]  
  
 <span data-ttu-id="51dcd-126">Można również użyć <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> metody do ponownego zgłoszenia wyjątków wewnętrznych z wielu <xref:System.AggregateException> wystąpień zgłaszanych przez wielu zadań w pojedynczym <xref:System.AggregateException> wystąpienia, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-126">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
 [!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]  
  
## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="51dcd-127">Wyjątki od zadania podrzędne odłączona</span><span class="sxs-lookup"><span data-stu-id="51dcd-127">Exceptions from Detached Child Tasks</span></span>  
 <span data-ttu-id="51dcd-128">Domyślnie zadania podrzędne są tworzone jako odłączona.</span><span class="sxs-lookup"><span data-stu-id="51dcd-128">By default, child tasks are created as detached.</span></span> <span data-ttu-id="51dcd-129">Wyjątków zgłaszanych przez zadania odłączyć muszą być obsługiwane lub zgłoszony w zadaniem nadrzędnym natychmiastowego; nie są propagowane do wątku wywołującym sam sposób jak dołączone zadania podrzędne propagowane ponownie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-129">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="51dcd-130">Nadrzędnego najwyższego poziomu można ręcznie Ponowne zgłoszenie wyjątku odłączyć podrzędnej spowodować być ujęte w <xref:System.AggregateException> i propagowane wątek wywołujący.</span><span class="sxs-lookup"><span data-stu-id="51dcd-130">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>  
  
 [!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
 [!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]  
  
 <span data-ttu-id="51dcd-131">Nawet jeśli używasz utrzymania obserwować wyjątek zadania podrzędnego wyjątek nadal muszą być spełnione przez zadaniem nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="51dcd-131">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>  
  
## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="51dcd-132">Wyjątki, które wskazują współpracy anulowania</span><span class="sxs-lookup"><span data-stu-id="51dcd-132">Exceptions That Indicate Cooperative Cancellation</span></span>  
 <span data-ttu-id="51dcd-133">Jeśli kod użytkownika zadania odpowiada na żądanie anulowania, poprawne procedura ma throw <xref:System.OperationCanceledException> przekazując token anulowania, na którym żądanie zostało przesłane.</span><span class="sxs-lookup"><span data-stu-id="51dcd-133">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="51dcd-134">Zanim podejmie próbę propagowanie wyjątku, wystąpienie zadania porównuje token w wyjątek do tego, który został przekazany do niego, podczas jej tworzenia.</span><span class="sxs-lookup"><span data-stu-id="51dcd-134">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="51dcd-135">Jeśli są one takie same, zadanie propaguje <xref:System.Threading.Tasks.TaskCanceledException> otoczona <xref:System.AggregateException>, i może być widoczny, gdy są sprawdzane wyjątków wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="51dcd-135">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="51dcd-136">Jednak jeśli wątek wywołujący nie jest oczekiwanie na zadanie, ten wyjątek nie zostaną zastosowane.</span><span class="sxs-lookup"><span data-stu-id="51dcd-136">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="51dcd-137">Aby uzyskać więcej informacji, zobacz [anulowanie zadania](../../../docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="51dcd-137">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 [!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
 [!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]  
  
## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="51dcd-138">Przy użyciu metody dojścia do filtru wyjątków wewnętrznych</span><span class="sxs-lookup"><span data-stu-id="51dcd-138">Using the Handle Method to Filter Inner Exceptions</span></span>  
 <span data-ttu-id="51dcd-139">Można użyć <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> metodę, aby odfiltrować wyjątki, które można traktować jako "obsługiwane" bez korzystania z żadnych dalszych logiki.</span><span class="sxs-lookup"><span data-stu-id="51dcd-139">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="51dcd-140">W elemencie delegowanym użytkownika, który został dostarczony do <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metody, typ wyjątku, można sprawdzić jego <xref:System.Exception.Message%2A> właściwości lub inne informacje o tym, które pozwalają określić, czy jest niegroźne.</span><span class="sxs-lookup"><span data-stu-id="51dcd-140">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="51dcd-141">Wszelkie wyjątki, dla których zwraca delegata `false` są zgłoszony w nowym <xref:System.AggregateException> natychmiast po wystąpieniu <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> zwraca metody.</span><span class="sxs-lookup"><span data-stu-id="51dcd-141">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>  
  
 <span data-ttu-id="51dcd-142">Poniższy przykład jest funkcjonalnym odpowiednikiem w tym temacie, który sprawdza, czy każdy wyjątek w pierwszym przykładzie <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="51dcd-142">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="51dcd-143">Zamiast tego wywołuje ten program obsługi wyjątku <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> obiekt metody dla każdego wyjątku i tylko wyjątki ponownie zgłasza wyjątek, które nie są `CustomException` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="51dcd-143">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>  
  
 [!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
 [!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]  
  
 <span data-ttu-id="51dcd-144">Poniżej przedstawiono przykład bardziej szczegółowy, który używa <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> metodę w celu zapewnienia obsługi specjalnej dla <xref:System.UnauthorizedAccessException> wyjątek podczas wyliczania plików.</span><span class="sxs-lookup"><span data-stu-id="51dcd-144">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>  
  
 [!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
 [!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]  
  
<a name="ExceptionProp"></a>   
## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="51dcd-145">Obserwowania wyjątków przy użyciu właściwości Task.Exception</span><span class="sxs-lookup"><span data-stu-id="51dcd-145">Observing Exceptions by Using the Task.Exception Property</span></span>  
 <span data-ttu-id="51dcd-146">Po zakończeniu zadania w <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> stanu, jego <xref:System.Threading.Tasks.Task.Exception%2A> właściwości można zbadać, aby dowiedzieć się, które określony wyjątek spowodował.</span><span class="sxs-lookup"><span data-stu-id="51dcd-146">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="51dcd-147">Dobrym sposobem obserwować <xref:System.Threading.Tasks.Task.Exception%2A> właściwości jest użycie kontynuację, w którym działa tylko wtedy, gdy zadanie poprzedzających błędów, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-147">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
 [!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]  
  
 <span data-ttu-id="51dcd-148">W rzeczywistej aplikacji delegata kontynuacji można rejestrować szczegółowe informacje o wyjątku i prawdopodobnie zduplikować nowe zadania, aby odzyskać z wyjątkiem.</span><span class="sxs-lookup"><span data-stu-id="51dcd-148">In a real application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span>  
  
## <a name="unobservedtaskexception-event"></a><span data-ttu-id="51dcd-149">Zdarzenie UnobservedTaskException</span><span class="sxs-lookup"><span data-stu-id="51dcd-149">UnobservedTaskException Event</span></span>  
 <span data-ttu-id="51dcd-150">W niektórych scenariuszach takich jak odnośnie do hostowania niezaufanych dodatków plug-in, wyjątki niegroźne może być wspólne, i może być zbyt trudne do ręcznie obserwować je wszystkie.</span><span class="sxs-lookup"><span data-stu-id="51dcd-150">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="51dcd-151">W takich przypadkach można obsługiwać <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="51dcd-151">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="51dcd-152"><xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> Wystąpienie, które jest przekazywane do programu obsługi można zapobiec niezaobserwowany wyjątek propagowanie do łącząca wątku.</span><span class="sxs-lookup"><span data-stu-id="51dcd-152">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="51dcd-153">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="51dcd-153">See Also</span></span>  
 [<span data-ttu-id="51dcd-154">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="51dcd-154">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
