---
title: Implementacja metody Dispose
description: W tym artykule dowiesz się, jak zaimplementować metodę Dispose, która zwalnia niezarządzane zasoby używane przez kod w programie .NET.
ms.date: 05/27/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: 4f0cc9b88947d60638057ca83adb7f2e141c5d14
ms.sourcegitcommit: 7499bdb428d63ed0e19e97f54d3d576c41598659
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/31/2020
ms.locfileid: "87455731"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="8c71e-103">Implementacja metody Dispose</span><span class="sxs-lookup"><span data-stu-id="8c71e-103">Implement a Dispose method</span></span>

<span data-ttu-id="8c71e-104">Implementowanie <xref:System.IDisposable.Dispose%2A> metody jest przede wszystkim przeznaczone do zwalniania niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="8c71e-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources.</span></span> <span data-ttu-id="8c71e-105">Podczas pracy z elementami członkowskimi wystąpień <xref:System.IDisposable> , które są implementacjami, często są to wywołania kaskadowe <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="8c71e-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="8c71e-106">Istnieją dodatkowe powody wdrożenia <xref:System.IDisposable.Dispose%2A> , na przykład w celu zwolnienia pamięci, która została przypisana, usunąć element, który został dodany do kolekcji lub sygnalizować wykorzystaną blokadę.</span><span class="sxs-lookup"><span data-stu-id="8c71e-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, for example, to free memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</span></span>

<span data-ttu-id="8c71e-107">[Moduł wyrzucania elementów bezużytecznych platformy .NET](index.md) nie przydziela lub nie zwalnia pamięci niezarządzanej.</span><span class="sxs-lookup"><span data-stu-id="8c71e-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="8c71e-108">Wzorzec do usuwania obiektu, nazywany wzorcem usuwania, nakłada kolejność na okres istnienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="8c71e-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="8c71e-109">Wzorzec Dispose jest używany dla obiektów implementujących <xref:System.IDisposable> interfejs i jest powszechny w przypadku współpracy z uchwytami plików i potoków, dojściami do rejestru, dojściami oczekiwania lub wskaźnikami do bloków pamięci niezarządzanej.</span><span class="sxs-lookup"><span data-stu-id="8c71e-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="8c71e-110">Dzieje się tak, ponieważ moduł wyrzucania elementów bezużytecznych nie może odzyskiwać obiektów niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="8c71e-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="8c71e-111">Aby zapewnić, że zasoby są zawsze odpowiednio czyszczone, <xref:System.IDisposable.Dispose%2A> Metoda powinna być idempotentne, tak że jest ona wielokrotnie wywoływana bez zgłaszania wyjątku.</span><span class="sxs-lookup"><span data-stu-id="8c71e-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="8c71e-112">Ponadto kolejne wywołania elementu <xref:System.IDisposable.Dispose%2A> nie powinny nic robić.</span><span class="sxs-lookup"><span data-stu-id="8c71e-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="8c71e-113">Przykład kodu podany dla <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> metody pokazuje, jak wyrzucanie elementów bezużytecznych może spowodować uruchomienie finalizatora, podczas gdy niezarządzane odwołanie do obiektu lub jego członków jest nadal w użyciu.</span><span class="sxs-lookup"><span data-stu-id="8c71e-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="8c71e-114">Warto mieć sens, <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> Aby obiekt nieuprawniony do wyrzucania elementów bezużytecznych od początku bieżącej procedury do punktu, w którym ta metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="8c71e-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="8c71e-115">Bezpieczne dojścia</span><span class="sxs-lookup"><span data-stu-id="8c71e-115">Safe handles</span></span>

<span data-ttu-id="8c71e-116">Pisanie kodu dla finalizatora obiektu to złożone zadanie, które może powodować problemy, jeśli nie zostanie wykonane prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="8c71e-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="8c71e-117">Dlatego zalecamy konstruowanie <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> obiektów zamiast implementowania finalizatora.</span><span class="sxs-lookup"><span data-stu-id="8c71e-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="8c71e-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> jest abstrakcyjnym typem zarządzanym, który otacza obiekt <xref:System.IntPtr?displayProperty=nameWithType> , który identyfikuje niezarządzany zasób.</span><span class="sxs-lookup"><span data-stu-id="8c71e-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="8c71e-119">W systemie Windows może on identyfikować dojście w systemie UNIX, deskryptor pliku.</span><span class="sxs-lookup"><span data-stu-id="8c71e-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="8c71e-120">Zapewnia ona wszystkie wymagane logiki, aby zapewnić, że ten zasób jest wystawiony raz i tylko raz, gdy `SafeHandle` zostanie usunięty lub gdy wszystkie odwołania do `SafeHandle` zostały usunięte, a `SafeHandle` wystąpienie zostanie sfinalizowane.</span><span class="sxs-lookup"><span data-stu-id="8c71e-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="8c71e-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>Jest abstrakcyjną klasą bazową.</span><span class="sxs-lookup"><span data-stu-id="8c71e-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="8c71e-122">Klasy pochodne zapewniają określone wystąpienia dla różnych rodzajów uchwytów.</span><span class="sxs-lookup"><span data-stu-id="8c71e-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="8c71e-123">Te klasy pochodne sprawdzają, jakie wartości <xref:System.IntPtr?displayProperty=nameWithType> są uważane za nieprawidłowe i jak ostatecznie zwolnić dojście.</span><span class="sxs-lookup"><span data-stu-id="8c71e-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="8c71e-124">Na przykład podaje <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> `SafeHandle` się do zawijania, `IntPtrs` który identyfikuje otwarte dojścia do pliku/deskryptory, i zastępuje jego <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metodę, aby zamknąć (za pośrednictwem `close` funkcji w systemie UNIX lub `CloseHandle` funkcji systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="8c71e-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="8c71e-125">Większość interfejsów API w bibliotekach platformy .NET, które tworzą zasób niezarządzany, będzie otoczyć ją w `SafeHandle` i zwrócić `SafeHandle` do Ciebie w razie potrzeby, zamiast wycofać pierwotny wskaźnik.</span><span class="sxs-lookup"><span data-stu-id="8c71e-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="8c71e-126">W sytuacjach, w których można korzystać z niezarządzanego składnika i uzyskać `IntPtr` dla niezarządzanego zasobu, można utworzyć własny `SafeHandle` Typ, aby go otoczyć.</span><span class="sxs-lookup"><span data-stu-id="8c71e-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="8c71e-127">W związku z `SafeHandle` tym kilka typów niewymagających zaimplementowania finalizatorów; Większość implementacji wzorców jednorazowych kończy Zawijanie innych zarządzanych zasobów, z których część może być `SafeHandle` s.</span><span class="sxs-lookup"><span data-stu-id="8c71e-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="8c71e-128">Następujące klasy pochodne w <xref:Microsoft.Win32.SafeHandles> przestrzeni nazw zapewniają bezpieczne dojścia:</span><span class="sxs-lookup"><span data-stu-id="8c71e-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="8c71e-129"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle>Klasy, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> , i <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> , dla plików, plików mapowanych na pamięć i potoków.</span><span class="sxs-lookup"><span data-stu-id="8c71e-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="8c71e-130"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>Klasa dla widoków pamięci.</span><span class="sxs-lookup"><span data-stu-id="8c71e-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="8c71e-131"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>Klasy, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> i <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> , dla konstrukcji kryptografii.</span><span class="sxs-lookup"><span data-stu-id="8c71e-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="8c71e-132"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>Klasa dla kluczy rejestru.</span><span class="sxs-lookup"><span data-stu-id="8c71e-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="8c71e-133"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>Klasa, dla uchwytów oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="8c71e-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="8c71e-134">Dispose () i Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="8c71e-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="8c71e-135"><xref:System.IDisposable>Interfejs wymaga implementacji pojedynczej metody bez parametrów <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="8c71e-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="8c71e-136">Ponadto każda klasa Niezapieczętowana powinna mieć dodatkową `Dispose(bool)` metodę przeciążenia, która ma być zaimplementowana:</span><span class="sxs-lookup"><span data-stu-id="8c71e-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="8c71e-137">`public`Implementacja niewirtualna ( `NonInheritable` w Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> , która nie ma parametrów.</span><span class="sxs-lookup"><span data-stu-id="8c71e-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="8c71e-138">`protected virtual`Metoda ( `Overridable` w Visual Basic), `Dispose` której sygnatura:</span><span class="sxs-lookup"><span data-stu-id="8c71e-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="8c71e-139">`disposing`Parametr powinien być `false` wywoływany z finalizatora i `true` wywoływany z <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8c71e-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8c71e-140">Innymi słowy, jest to w `true` przypadku niejednoznacznego wywoływania i w `false` przypadku, gdy jest wywoływana niejednoznacznie.</span><span class="sxs-lookup"><span data-stu-id="8c71e-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="8c71e-141">Metoda Dispose ()</span><span class="sxs-lookup"><span data-stu-id="8c71e-141">The Dispose() method</span></span>

<span data-ttu-id="8c71e-142">Ponieważ `public` , niewirtualne ( `NonInheritable` w Visual Basic), Metoda bez parametrów `Dispose` jest wywoływana przez odbiorcę typu, jego celem jest zwolnienie niezarządzanych zasobów, wykonanie ogólnego oczyszczania i wskazanie, że finalizator, jeśli taki istnieje, nie musi być uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="8c71e-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="8c71e-143">Zwalnianie rzeczywistej pamięci skojarzonej z obiektem zarządzanym jest zawsze domeną [modułu wyrzucania elementów bezużytecznych](index.md).</span><span class="sxs-lookup"><span data-stu-id="8c71e-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="8c71e-144">Z tego powodu ma standardową implementację:</span><span class="sxs-lookup"><span data-stu-id="8c71e-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="8c71e-145">`Dispose`Metoda wykonuje wszystkie operacje czyszczenia obiektów, dlatego Moduł wyrzucania elementów bezużytecznych nie musi już wywoływać <xref:System.Object.Finalize%2A?displayProperty=nameWithType> przesłonięcia obiektów.</span><span class="sxs-lookup"><span data-stu-id="8c71e-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="8c71e-146">W związku z tym wywołanie <xref:System.GC.SuppressFinalize%2A> metody uniemożliwia uruchomienie finalizatora przez moduł wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="8c71e-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="8c71e-147">Jeśli typ nie ma finalizatora, wywołanie nie <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> ma żadnego wpływu.</span><span class="sxs-lookup"><span data-stu-id="8c71e-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="8c71e-148">Należy zauważyć, że rzeczywiste oczyszczanie jest wykonywane przez `Dispose(bool)` Przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="8c71e-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="8c71e-149">Przeciążenie metody Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="8c71e-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="8c71e-150">W przypadku przeciążenia `disposing` parametr jest <xref:System.Boolean> wskazuje, czy wywołanie metody pochodzi z <xref:System.IDisposable.Dispose%2A> metody (jej wartość jest `true` ) czy z finalizatora (jego wartość to `false` ).</span><span class="sxs-lookup"><span data-stu-id="8c71e-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="8c71e-151">Treść metody składa się z dwóch bloków kodu:</span><span class="sxs-lookup"><span data-stu-id="8c71e-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="8c71e-152">Blok zwalniający niezarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="8c71e-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="8c71e-153">Ten blok jest wykonywany niezależnie od wartości `disposing` parametru.</span><span class="sxs-lookup"><span data-stu-id="8c71e-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="8c71e-154">Blok warunkowy zwalniający zarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="8c71e-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="8c71e-155">Ten blok jest wykonywany, gdy wartość `disposing` jest `true` .</span><span class="sxs-lookup"><span data-stu-id="8c71e-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="8c71e-156">Zarządzane zasoby, które zwalnia, to m.in.:</span><span class="sxs-lookup"><span data-stu-id="8c71e-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="8c71e-157">**Obiekty zarządzane, które implementują <xref:System.IDisposable> .**</span><span class="sxs-lookup"><span data-stu-id="8c71e-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="8c71e-158">Bloku warunkowego można użyć do wywołania ich <xref:System.IDisposable.Dispose%2A> implementacji (kaskadowego Dispose).</span><span class="sxs-lookup"><span data-stu-id="8c71e-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="8c71e-159">Jeśli użyto klasy pochodnej <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> , aby otoczyć niezarządzany zasób, należy wywołać <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementację tutaj.</span><span class="sxs-lookup"><span data-stu-id="8c71e-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="8c71e-160">**Zarządzane obiekty, które zużywają duże ilości pamięci lub zużywają niewystarczające zasoby.**</span><span class="sxs-lookup"><span data-stu-id="8c71e-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="8c71e-161">Przypisz do nich duże odwołania do obiektów zarządzanych, aby `null` zwiększyć ich dostępność.</span><span class="sxs-lookup"><span data-stu-id="8c71e-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="8c71e-162">Te wersje są szybsze, niż gdyby były odzyskiwane w sposób Niedeterministyczny.</span><span class="sxs-lookup"><span data-stu-id="8c71e-162">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="8c71e-163">Jeśli wywołanie metody pochodzi od finalizatora, należy wykonać tylko kod, który zwolni niezarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="8c71e-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="8c71e-164">Realizator jest odpowiedzialny za zapewnienie, że ścieżka fałszywa nie współdziała z zarządzanymi obiektami, które mogły zostać ododzyskiwane.</span><span class="sxs-lookup"><span data-stu-id="8c71e-164">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="8c71e-165">Jest to ważne, ponieważ kolejność, w której moduł zbierający elementy bezużyteczne niszczy obiekty zarządzane podczas finalizowania, nie jest deterministyczna.</span><span class="sxs-lookup"><span data-stu-id="8c71e-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="8c71e-166">Kaskadowe wywołania Dispose</span><span class="sxs-lookup"><span data-stu-id="8c71e-166">Cascade dispose calls</span></span>

<span data-ttu-id="8c71e-167">Jeśli klasa jest własnością pola lub właściwości, a jej typ implementuje <xref:System.IDisposable> , należy również zaimplementować zawierającą ją klasę <xref:System.IDisposable> .</span><span class="sxs-lookup"><span data-stu-id="8c71e-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="8c71e-168">Klasa, która tworzy wystąpienie <xref:System.IDisposable> implementacji i zapisuje ją jako element członkowski wystąpienia, jest również odpowiedzialna za jego czyszczenie.</span><span class="sxs-lookup"><span data-stu-id="8c71e-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="8c71e-169">Jest to pomocne w zapewnieniu, że odwołania do typów jednorazowych, których dotyczy odwołanie, są nadawane za pomocą <xref:System.IDisposable.Dispose%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8c71e-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="8c71e-170">W tym przykładzie Klasa jest `sealed` (lub `NotInheritable` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8c71e-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="8c71e-171">Implementowanie wzorca usuwania</span><span class="sxs-lookup"><span data-stu-id="8c71e-171">Implement the dispose pattern</span></span>

<span data-ttu-id="8c71e-172">Wszystkie niezapieczętowane klasy lub (Visual Basic klas, które nie zostały zmodyfikowane jako `NotInheritable` ), powinny być uważane za potencjalną klasę bazową, ponieważ mogą być dziedziczone.</span><span class="sxs-lookup"><span data-stu-id="8c71e-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="8c71e-173">W przypadku zaimplementowania wzorca usuwania dla dowolnej potencjalnej klasy podstawowej należy podać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8c71e-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="8c71e-174"><xref:System.IDisposable.Dispose%2A>Implementacja, która wywołuje `Dispose(bool)` metodę.</span><span class="sxs-lookup"><span data-stu-id="8c71e-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="8c71e-175">`Dispose(bool)`Metoda, która wykonuje rzeczywiste oczyszczanie.</span><span class="sxs-lookup"><span data-stu-id="8c71e-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="8c71e-176">Klasa pochodna, <xref:System.Runtime.InteropServices.SafeHandle> która otacza niezarządzany zasób (zalecane) lub przesłonięcie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8c71e-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8c71e-177"><xref:System.Runtime.InteropServices.SafeHandle>Klasa zawiera finalizator, więc nie trzeba pisać siebie.</span><span class="sxs-lookup"><span data-stu-id="8c71e-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8c71e-178">Klasa bazowa może odwoływać się tylko do obiektów zarządzanych i zaimplementować wzorzec Dispose.</span><span class="sxs-lookup"><span data-stu-id="8c71e-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="8c71e-179">W takich przypadkach finalizator jest niepotrzebny.</span><span class="sxs-lookup"><span data-stu-id="8c71e-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="8c71e-180">Finalizator jest wymagany tylko w przypadku bezpośredniego odwoływania się do zasobów niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="8c71e-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="8c71e-181">Oto ogólny wzorzec implementowania wzorca usuwania dla klasy bazowej, która używa bezpiecznego dojścia.</span><span class="sxs-lookup"><span data-stu-id="8c71e-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="8c71e-182">W poprzednim przykładzie użyto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu do zilustrowania wzorca; zamiast tego można użyć dowolnego obiektu pochodnego <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="8c71e-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="8c71e-183">Należy zauważyć, że przykład nie tworzy prawidłowo wystąpienia <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8c71e-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="8c71e-184">Oto ogólny wzorzec implementowania wzorca usuwania dla klasy bazowej, która zastąpi <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="8c71e-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="8c71e-185">W języku C# tworzysz [finalizator](../../csharp/programming-guide/classes-and-structs/destructors.md) przez zastąpienie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="8c71e-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8c71e-186">W Visual Basic jest to realizowane za pomocą `Protected Overrides Sub Finalize()` .</span><span class="sxs-lookup"><span data-stu-id="8c71e-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="8c71e-187">Implementowanie wzorca usuwania dla klasy pochodnej</span><span class="sxs-lookup"><span data-stu-id="8c71e-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="8c71e-188">Klasa pochodna klasy, która implementuje <xref:System.IDisposable> Interfejs <xref:System.IDisposable> , nie należy implementować, ponieważ Implementacja klasy bazowej <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> jest dziedziczona przez klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="8c71e-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="8c71e-189">Zamiast tego, aby oczyścić klasę pochodną, należy podać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8c71e-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="8c71e-190">`protected override void Dispose(bool)`Metoda, która zastępuje metodę klasy bazowej i wykonuje rzeczywiste oczyszczanie klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="8c71e-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="8c71e-191">Ta metoda musi również wywołać `base.Dispose(bool)` metodę ( `MyBase.Dispose(bool)` w Visual Basic) klasy bazowej i przekazać jej stan likwidacji dla tego argumentu.</span><span class="sxs-lookup"><span data-stu-id="8c71e-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="8c71e-192">Klasa pochodna, <xref:System.Runtime.InteropServices.SafeHandle> która otacza niezarządzany zasób (zalecane) lub przesłonięcie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8c71e-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8c71e-193"><xref:System.Runtime.InteropServices.SafeHandle>Klasa zawiera finalizator, który uwalnia Cię do kodu.</span><span class="sxs-lookup"><span data-stu-id="8c71e-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="8c71e-194">Jeśli podasz finalizator, musi on wywołać `Dispose(bool)` Przeciążenie z `disposing` argumentem `false` .</span><span class="sxs-lookup"><span data-stu-id="8c71e-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="8c71e-195">Poniżej przedstawiono ogólny schemat implementowania wzorca usuwania dla klasy pochodnej, w którym jest używane bezpieczne dojście:</span><span class="sxs-lookup"><span data-stu-id="8c71e-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="8c71e-196">W poprzednim przykładzie użyto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu do zilustrowania wzorca; zamiast tego można użyć dowolnego obiektu pochodnego <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="8c71e-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="8c71e-197">Należy zauważyć, że przykład nie tworzy prawidłowo wystąpienia <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8c71e-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="8c71e-198">Oto ogólny wzorzec implementowania wzorca usuwania dla klasy pochodnej, która zastąpi <xref:System.Object.Finalize%2A?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="8c71e-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="8c71e-199">Implementowanie wzorca Dispose z bezpiecznymi dojściami</span><span class="sxs-lookup"><span data-stu-id="8c71e-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="8c71e-200">Poniższy przykład ilustruje wzorzec Dispose dla klasy bazowej, `DisposableStreamResource` który używa bezpiecznego dojścia do hermetyzowania niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="8c71e-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="8c71e-201">Definiuje `DisposableStreamResource` klasę, która używa <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> do zawijania <xref:System.IO.Stream> obiektu, który reprezentuje otwarty plik.</span><span class="sxs-lookup"><span data-stu-id="8c71e-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="8c71e-202">Klasa zawiera również pojedynczą właściwość, `Size` która zwraca łączną liczbę bajtów w strumieniu pliku.</span><span class="sxs-lookup"><span data-stu-id="8c71e-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="8c71e-203">Implementowanie wzorca usuwania dla klasy pochodnej z bezpiecznymi dojściami</span><span class="sxs-lookup"><span data-stu-id="8c71e-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="8c71e-204">Poniższy przykład ilustruje wzorzec usuwania dla klasy pochodnej, `DisposableStreamResource2` która dziedziczy z `DisposableStreamResource` klasy przedstawionej w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8c71e-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="8c71e-205">Klasa dodaje dodatkową metodę, `WriteFileInfo` i używa <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu do zawijania uchwytu zapisywalnego pliku.</span><span class="sxs-lookup"><span data-stu-id="8c71e-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="8c71e-206">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="8c71e-206">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="8c71e-207">Definiowanie i korzystanie z klas i struktur (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="8c71e-207">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
