---
title: Implementacja metody Dispose
ms.date: 04/07/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: acc661e8110892dc7daa603ef82b4bc5f167a970
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="implementing-a-dispose-method"></a><span data-ttu-id="6e5cd-102">Implementacja metody Dispose</span><span class="sxs-lookup"><span data-stu-id="6e5cd-102">Implementing a Dispose method</span></span>

<span data-ttu-id="6e5cd-103">Można zaimplementować <xref:System.IDisposable.Dispose%2A> metodę, aby zwolnić zasoby niezarządzane używane przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-103">You implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application.</span></span> <span data-ttu-id="6e5cd-104">Moduł zbierający elementy bezużyteczne .NET nie przydzielić lub wersji niezarządzanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-104">The .NET garbage collector does not allocate or release unmanaged memory.</span></span>  
  
<span data-ttu-id="6e5cd-105">Wzorzec do likwidacji obiekt określany jako [wzorzec dispose](../../../docs/standard/design-guidelines/dispose-pattern.md), narzuca kolejności okresu istnienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-105">The pattern for disposing an object, referred to as a [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md), imposes order on the lifetime of an object.</span></span> <span data-ttu-id="6e5cd-106">Wzorzec usuwania jest używany tylko w przypadku obiektów uzyskujących dostęp do niezarządzanych zasobów, takich jak dojścia do plików i potoków, dojścia do rejestru, dojścia oczekiwania lub wskaźniki do bloków w niezarządzanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-106">The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="6e5cd-107">Z tego powodu moduł odśmiecania pamięci jest bardzo skuteczny w odzyskiwaniu nieużywanych zarządzanych obiektów, ale nie jest w stanie odzyskiwać niezarządzanych obiektów.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-107">This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</span></span>  
  
<span data-ttu-id="6e5cd-108">Wzorzec usuwania ma dwa warianty:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-108">The dispose pattern has two variations:</span></span>  
  
* <span data-ttu-id="6e5cd-109">Zawijaj każdego zasobu niezarządzanego korzystającej z typem w bezpieczne dojście (to znaczy w klasie pochodną <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="6e5cd-109">You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span></span> <span data-ttu-id="6e5cd-110">W takim przypadku wdrożenie <xref:System.IDisposable> interfejsu i dodatkowe `Dispose(Boolean)` metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-110">In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method.</span></span> <span data-ttu-id="6e5cd-111">To jest zalecana zmiana i nie wymaga zastępowanie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-111">This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span>  
  
  > [!NOTE]
  > <span data-ttu-id="6e5cd-112"><xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> Przestrzeń nazw zawiera zestaw klas pochodnych <xref:System.Runtime.InteropServices.SafeHandle>, które są wymienione w [przy użyciu bezpiecznego dojścia](#SafeHandles) sekcji.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-112">The <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section.</span></span> <span data-ttu-id="6e5cd-113">Jeśli nie można znaleźć klasy, która jest odpowiednia do zwalniania niezarządzanych zasobu, można zaimplementować własnych podklas <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-113">If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
* <span data-ttu-id="6e5cd-114">Można zaimplementować <xref:System.IDisposable> interfejsu i dodatkowe `Dispose(Boolean)` metody, a także zastępować <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-114">You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6e5cd-115">Konieczne jest przesłonięcie <xref:System.Object.Finalize%2A> aby upewnić się, że zasoby niezarządzane są usuwane, jeśli Twoje <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji nie jest wywoływany przez odbiorcę tego typu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-115">You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation is not called by a consumer of your type.</span></span> <span data-ttu-id="6e5cd-116">Jeśli używasz zalecane techniki omówione w poprzedni punkt <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> klasy robi to w Twoim imieniu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-116">If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class does this on your behalf.</span></span>  
  
<span data-ttu-id="6e5cd-117">Pomaga zapewnić, że zasoby są zawsze wyczyścić odpowiednio, <xref:System.IDisposable.Dispose%2A> metody powinny móc wywoływać wielokrotnie bez generowania wyjątku.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-117">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception.</span></span>  
  
<span data-ttu-id="6e5cd-118">Przykładowy kod podany dla <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> metody pokazuje sposób agresywne pamięci kolekcji może spowodować finalizator do uruchomienia, gdy element członkowski obiektu regeneracji jest nadal wykonywane.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-118">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.</span></span> <span data-ttu-id="6e5cd-119">Jest dobrym rozwiązaniem do wywołania <xref:System.GC.KeepAlive%2A> metody na końcu długich <xref:System.IDisposable.Dispose%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-119">It is a good idea to call the <xref:System.GC.KeepAlive%2A> method at the end of a lengthy <xref:System.IDisposable.Dispose%2A> method.</span></span>  
  
<a name="Dispose2"></a>
## <a name="dispose-and-disposeboolean"></a><span data-ttu-id="6e5cd-120">Metoda Dispose() a metoda Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="6e5cd-120">Dispose() and Dispose(Boolean)</span></span>  

<span data-ttu-id="6e5cd-121"><xref:System.IDisposable> Interfejsu wymaga wykonania jednej metody bez parametrów, <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-121">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="6e5cd-122">Jednak wzorzec dispose wymaga dwóch `Dispose` metody implementowane:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-122">However, the dispose pattern requires two `Dispose` methods to be implemented:</span></span>  
  
* <span data-ttu-id="6e5cd-123">-Virtual publiczny (`NonInheritable` w języku Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementację, która nie ma parametrów.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-123">A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>  
  
* <span data-ttu-id="6e5cd-124">A chronione wirtualnych (`Overridable` w języku Visual Basic) `Dispose` metody, której sygnatura to:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-124">A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>  
  
  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]  
  
### <a name="the-dispose-overload"></a><span data-ttu-id="6e5cd-125">Przeciążenie metody Dispose()</span><span class="sxs-lookup"><span data-stu-id="6e5cd-125">The Dispose() overload</span></span>

<span data-ttu-id="6e5cd-126">Ponieważ publicznego-wirtualna (`NonInheritable` w języku Visual Basic), bez parametrów `Dispose` metoda jest wywoływana przez odbiorcę tego typu, jej celem jest, aby zwolnić zasoby niezarządzane i aby wskazać, że finalizator, jeśli występuje, nie trzeba uruchamiać.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-126">Because the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="6e5cd-127">Z tego powodu ma standardową implementację:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-127">Because of this, it has a standard implementation:</span></span>  
  
[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]  
  
<span data-ttu-id="6e5cd-128">`Dispose` — Metoda wykonuje czyszczenie wszystkich obiektów, dlatego moduł garbage collector już musi wywołać obiektów <xref:System.Object.Finalize%2A?displayProperty=nameWithType> zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-128">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="6e5cd-129">W związku z tym wywołaniu <xref:System.GC.SuppressFinalize%2A> metody uniemożliwia uruchomienie finalizatora przez moduł garbage collector.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-129">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="6e5cd-130">Jeśli typ nie ma żadnych finalizator wywołanie <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> nie ma wpływu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-130">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="6e5cd-131">Należy pamiętać, że faktyczną pracę zwalniania niezarządzanych zasobów jest wykonywane przez drugi przeciążenia `Dispose` metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-131">Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method.</span></span>  
  
### <a name="the-disposeboolean-overload"></a><span data-ttu-id="6e5cd-132">Przeciążenie Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="6e5cd-132">The Dispose(Boolean) overload</span></span>

<span data-ttu-id="6e5cd-133">W drugim przeciążenia *disposing* parametr jest <xref:System.Boolean> wskazująca, czy wywołanie metody pochodzi z <xref:System.IDisposable.Dispose%2A> — metoda (jego wartość wynosi `true`) lub finalizatora (jego wartość wynosi `false`).</span><span class="sxs-lookup"><span data-stu-id="6e5cd-133">In the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>  
  
<span data-ttu-id="6e5cd-134">Treść metody składa się z dwóch bloków kodu:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-134">The body of the method consists of two blocks of code:</span></span>  
  
* <span data-ttu-id="6e5cd-135">Blok zwalniający niezarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-135">A block that frees unmanaged resources.</span></span> <span data-ttu-id="6e5cd-136">Ten blok wykonuje niezależnie od wartości `disposing` parametru.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-136">This block executes regardless of the value of the `disposing` parameter.</span></span>  
  
* <span data-ttu-id="6e5cd-137">Blok warunkowy zwalniający zarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-137">A conditional block that frees managed resources.</span></span> <span data-ttu-id="6e5cd-138">Ten blok wykonuje, jeśli wartość `disposing` jest `true`.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-138">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="6e5cd-139">Zarządzane zasoby, które zwalnia, to m.in.:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-139">The managed resources that it frees can include:</span></span>  
  
  <span data-ttu-id="6e5cd-140">**Zarządzane obiekty, które implementują <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="6e5cd-140">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="6e5cd-141">Blok warunkowy może służyć do wywołania ich <xref:System.IDisposable.Dispose%2A> implementacji.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-141">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="6e5cd-142">Jeśli używasz bezpieczne dojście do opakowywania niezarządzanego zasobu, należy wywołać <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementację.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-142">If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementation here.</span></span>  
  
  <span data-ttu-id="6e5cd-143">**Zarządzane obiekty, które używają duże ilości pamięci lub korzystać z ograniczonych zasobów.**</span><span class="sxs-lookup"><span data-stu-id="6e5cd-143">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="6e5cd-144">Zwalnianie te obiekty jawnie w `Dispose` metoda zwalnia je szybciej niż w przypadku ich odzyskanych niejednoznaczne przez moduł garbage collector.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-144">Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</span></span>  
  
<span data-ttu-id="6e5cd-145">Jeśli wywołanie metody pochodzi z finalizator (to znaczy, jeśli *disposing* jest `false`), wykonuje tylko kod zwalnia zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-145">If the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes.</span></span> <span data-ttu-id="6e5cd-146">Ponieważ nie określono kolejności, w której moduł zbierający elementy bezużyteczne niszczy podczas finalizacji zarządzanych obiektów, to wywołanie `Dispose` przeciążenia o wartości `false` uniemożliwia próby zwolnienia zarządzanych zasobów, które mogą mieć finalizator już została odzyskana.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-146">Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed.</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="6e5cd-147">Implementowanie wzorca usuwania dla klasy bazowej</span><span class="sxs-lookup"><span data-stu-id="6e5cd-147">Implementing the dispose pattern for a base class</span></span>

<span data-ttu-id="6e5cd-148">Podczas implementowania wzorca usuwania dla klasy bazowej należy dostarczyć następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-148">If you implement the dispose pattern for a base class, you must provide the following:</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="6e5cd-149">Należy zaimplementować tego wzorca dla wszystkich klas podstawowych, które implementują <xref:System.IDisposable.Dispose> i nie są `sealed` (`NotInheritable` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="6e5cd-149">You should implement this pattern for all base classes that implement <xref:System.IDisposable.Dispose> and are not `sealed` (`NotInheritable` in Visual Basic).</span></span>  
  
* <span data-ttu-id="6e5cd-150">A <xref:System.IDisposable.Dispose%2A> wdrożenia, który wywołuje `Dispose(Boolean)` metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-150">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method.</span></span>  
  
* <span data-ttu-id="6e5cd-151">A `Dispose(Boolean)` metodę, która wykonuje faktyczną pracę zwolnienia zasobów.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-151">A `Dispose(Boolean)` method that performs the actual work of releasing resources.</span></span>  
  
* <span data-ttu-id="6e5cd-152">Każda klasa pochodzi od <xref:System.Runtime.InteropServices.SafeHandle> który opakowuje niezarządzanego zasobu (zalecane) lub zastąpienie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-152">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6e5cd-153"><xref:System.Runtime.InteropServices.SafeHandle> Klasa udostępnia finalizatorze zwalnia z konieczności kodu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-153">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span>  
  
<span data-ttu-id="6e5cd-154">Poniżej przedstawiono ogólne wzorca w zakresie implementacji wzorca dispose dla klasy podstawowej, która używa bezpieczne dojście.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-154">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>  
  
[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="6e5cd-155">W poprzednim przykładzie użyto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu w celu zilustrowania wzorzec; dowolny obiekt pochodną <xref:System.Runtime.InteropServices.SafeHandle> może być użyty.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-155">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="6e5cd-156">Należy pamiętać, że przykładzie nie prawidłowo utworzyć wystąpienia jego <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-156">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="6e5cd-157">Poniżej przedstawiono ogólne wzorca w zakresie implementacji wzorca dispose dla klasy podstawowej, która zastępuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-157">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
> [!NOTE]
> <span data-ttu-id="6e5cd-158">W języku C#, Zastąp <xref:System.Object.Finalize%2A?displayProperty=nameWithType> , definiując [destruktora](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="6e5cd-158">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="6e5cd-159">Implementowanie wzorca usuwania dla klasy pochodnej</span><span class="sxs-lookup"><span data-stu-id="6e5cd-159">Implementing the dispose pattern for a derived class</span></span>

<span data-ttu-id="6e5cd-160">Klasą pochodną klasy, która implementuje <xref:System.IDisposable> nie powinny implementować interfejs <xref:System.IDisposable>, ponieważ Implementacja klasy podstawowej <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> jest dziedziczona przez jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-160">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="6e5cd-161">Tak więc, aby zaimplementować wzorzec usuwania dla klasy pochodnej, należy dostarczyć następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-161">Instead, to implement the dispose pattern for a derived class, you provide the following:</span></span>  
  
* <span data-ttu-id="6e5cd-162">A `protected Dispose(Boolean)` metodę, która zastępuje metodę klasy podstawowej i wykonuje faktyczną pracę zwolnienie zasobów klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-162">A `protected Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</span></span> <span data-ttu-id="6e5cd-163">Tej metody należy także wywołać `Dispose(Boolean)` metody podstawowej klasy i przekaż go wartość `true` dla *disposing* argumentu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-163">This method should also call the `Dispose(Boolean)` method of the base class and pass it a value of `true` for the *disposing* argument.</span></span>  
  
* <span data-ttu-id="6e5cd-164">Każda klasa pochodzi od <xref:System.Runtime.InteropServices.SafeHandle> który opakowuje niezarządzanego zasobu (zalecane) lub zastąpienie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-164">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6e5cd-165"><xref:System.Runtime.InteropServices.SafeHandle> Klasa udostępnia finalizatorze zwalnia z konieczności kodu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-165">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="6e5cd-166">Jeśli podasz finalizator powinny wywoływać `Dispose(Boolean)` przeciążenia z *disposing* argument `false`.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-166">If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`.</span></span>  
  
<span data-ttu-id="6e5cd-167">Poniżej przedstawiono ogólny schemat implementowania wzorca usuwania dla klasy pochodnej, w którym jest używane bezpieczne dojście:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-167">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>  
  
[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
> [!NOTE]
> <span data-ttu-id="6e5cd-168">W poprzednim przykładzie użyto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu w celu zilustrowania wzorzec; dowolny obiekt pochodną <xref:System.Runtime.InteropServices.SafeHandle> może być użyty.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-168">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="6e5cd-169">Należy pamiętać, że przykładzie nie prawidłowo utworzyć wystąpienia jego <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-169">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="6e5cd-170">Poniżej przedstawiono ogólne wzorca w zakresie implementacji wzorca dispose dla klasy pochodnej, która zastępuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-170">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>  
  
[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]  
  
> [!NOTE]
> <span data-ttu-id="6e5cd-171">W języku C#, Zastąp <xref:System.Object.Finalize%2A?displayProperty=nameWithType> , definiując [destruktora](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="6e5cd-171">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
<a name="SafeHandles"></a>   
## <a name="using-safe-handles"></a><span data-ttu-id="6e5cd-172">Używanie bezpiecznych dojść</span><span class="sxs-lookup"><span data-stu-id="6e5cd-172">Using safe handles</span></span>

<span data-ttu-id="6e5cd-173">Pisanie kodu dla finalizatora obiektu to złożone zadanie, które może powodować problemy, jeśli nie zostanie wykonane prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-173">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="6e5cd-174">Dlatego zaleca się, że utworzymy <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> obiektów zamiast wykonania finalizator.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-174">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>  
  
<span data-ttu-id="6e5cd-175">Klasy wyprowadzone z <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> klasy uprościć kwestie okresu istnienia obiektu przypisując i zwalniania uchwytów bez przeszkód.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-175">Classes derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class simplify object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="6e5cd-176">Zawierają finalizator krytyczny, który gwarantuje działanie w trakcie zwalniania domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-176">They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</span></span> <span data-ttu-id="6e5cd-177">Aby uzyskać więcej informacji o zaletach korzystania bezpieczne dojście, zobacz <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-177">For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6e5cd-178">Następujące klasy w pochodne <xref:Microsoft.Win32.SafeHandles> bezpiecznego dojścia Podaj przestrzeń nazw:</span><span class="sxs-lookup"><span data-stu-id="6e5cd-178">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>  
  
* <span data-ttu-id="6e5cd-179"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, I <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> klasy dla plików, plików mapowanych na pamięć i potoków.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-179">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>  
  
* <span data-ttu-id="6e5cd-180"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> Klasy widoków pamięci.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-180">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>  
  
* <span data-ttu-id="6e5cd-181"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, I <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> klasy dla konstrukcji kryptografii.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-181">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>  
  
* <span data-ttu-id="6e5cd-182"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> Klasy dla kluczy rejestru.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-182">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>  
  
* <span data-ttu-id="6e5cd-183"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Klasy dla uchwyty oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-183">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>  
  
<a name="base"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="6e5cd-184">Używanie bezpiecznego dojścia w celu implementacji wzorca usuwania dla klasy bazowej</span><span class="sxs-lookup"><span data-stu-id="6e5cd-184">Using a safe handle to implement the dispose pattern for a base class</span></span>

<span data-ttu-id="6e5cd-185">Poniższy przykład przedstawia wzorzec dispose dla klasy podstawowej, `DisposableStreamResource`, że używa bezpieczne dojście do hermetyzować zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-185">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="6e5cd-186">Definiuje `DisposableResource` klasy, która używa <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> opakowywać <xref:System.IO.Stream> obiekt, który reprezentuje plik.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-186">It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="6e5cd-187">`DisposableResource` Metoda również zawiera tylko jedną właściwość `Size`, która zwraca wartość całkowita liczba bajtów w strumieniu plików.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-187">The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>  
  
[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]  
  
<a name="derived"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="6e5cd-188">Używanie bezpiecznego dojścia w celu implementacji wzorca usuwania dla klasy pochodnej</span><span class="sxs-lookup"><span data-stu-id="6e5cd-188">Using a safe handle to implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="6e5cd-189">Poniższy przykład przedstawia wzorzec dispose dla klasy pochodnej, `DisposableStreamResource2`, która dziedziczy `DisposableStreamResource` klasy przedstawionych w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-189">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="6e5cd-190">Klasa dodaje dodatkowe metody `WriteFileInfo`i używa <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> obiekt do zakodowania dojście plik zapisywalny.</span><span class="sxs-lookup"><span data-stu-id="6e5cd-190">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>  
  
[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]  
  
## <a name="see-also"></a><span data-ttu-id="6e5cd-191">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="6e5cd-191">See also</span></span>

<xref:System.GC.SuppressFinalize%2A>   
<xref:System.IDisposable>   
<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>   
<xref:Microsoft.Win32.SafeHandles>   
<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>   
<xref:System.Object.Finalize%2A?displayProperty=nameWithType>   
<span data-ttu-id="6e5cd-192">[Porady: Definiowanie oraz stosowanie klas i struktur (C + +/ CLI)](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli) </span><span class="sxs-lookup"><span data-stu-id="6e5cd-192">[How to: Define and Consume Classes and Structs (C++/CLI)](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli) </span></span>  
[<span data-ttu-id="6e5cd-193">Wzorzec Dispose</span><span class="sxs-lookup"><span data-stu-id="6e5cd-193">Dispose Pattern</span></span>](../../../docs/standard/design-guidelines/dispose-pattern.md)
