---
title: Kolekcje bezpieczne wątkowo
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 7fad67c1a3c53cd83dec6bfa161333b5e20ab4c4
ms.sourcegitcommit: deb9225a55485a5a6e6c7914deb30ccfceb69d3f
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/05/2019
ms.locfileid: "54058324"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="190cb-102">Kolekcje bezpieczne wątkowo</span><span class="sxs-lookup"><span data-stu-id="190cb-102">Thread-Safe Collections</span></span>
<span data-ttu-id="190cb-103">W programie [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] wprowadzono przestrzeń nazw <xref:System.Collections.Concurrent?displayProperty=nameWithType> zawierającą kilka klas kolekcji, które są zarówno bezpieczne wątkowo, jak i skalowalne.</span><span class="sxs-lookup"><span data-stu-id="190cb-103">The [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="190cb-104">Wiele wątków może bezpiecznie i wydajnie dodawać i usuwać elementy te kolekcje, bez konieczności umieszczenia dodatkowej synchronizacji w kodzie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="190cb-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="190cb-105">Kiedy piszesz nowy kod, należy użyć klas kolekcji współbieżnych w każdym przypadku, gdy wiele wątków będzie zapisywać równocześnie do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="190cb-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="190cb-106">Jeśli z udostępnionej kolekcji odbywa się tylko odczyt, można używać klas z przestrzeni nazw <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="190cb-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="190cb-107">Zalecamy nieużywanie klas kolekcji w wersji 1.0, chyba że aplikacje mają być przeznaczone dla środowiska uruchomieniowego .NET Framework 1.1 lub starszego.</span><span class="sxs-lookup"><span data-stu-id="190cb-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="190cb-108">Synchronizacja wątków w kolekcjach środowisk .NET Framework 1.0 i 2.0</span><span class="sxs-lookup"><span data-stu-id="190cb-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="190cb-109">Kolekcje wprowadzone w środowisku .NET Framework 1.0 znajdują się w przestrzeni nazw <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="190cb-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="190cb-110">Kolekcje te, wśród których są m.in. powszechnie używane <xref:System.Collections.ArrayList> i <xref:System.Collections.Hashtable>, oferują pewne bezpieczeństwo wątkowe za pomocą właściwości `Synchronized`, która zwraca bezpieczną wątkowo otokę wokół kolekcji.</span><span class="sxs-lookup"><span data-stu-id="190cb-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="190cb-111">Otoka działa w ten sposób, że blokuje całą kolekcję podczas każdej operacji dodawania lub usuwania.</span><span class="sxs-lookup"><span data-stu-id="190cb-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="190cb-112">W związku z tym każdy wątek, który próbuje uzyskać dostęp do kolekcji, musi czekać na swoją kolej, aby nałożyć jedną blokadę.</span><span class="sxs-lookup"><span data-stu-id="190cb-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="190cb-113">Takie rozwiązanie nie jest skalowalne i przy dużych kolekcjach może powodować znaczne pogorszenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="190cb-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="190cb-114">Ponadto konstrukcja nie jest całkowicie chroniona przed sytuacjami wyścigu.</span><span class="sxs-lookup"><span data-stu-id="190cb-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="190cb-115">Aby uzyskać więcej informacji, zobacz [synchronizacja w kolekcjach ogólnych](https://blogs.msdn.microsoft.com/bclteam/2005/03/15/synchronization-in-generic-collections-brian-grunkemeyer/).</span><span class="sxs-lookup"><span data-stu-id="190cb-115">For more information, see [Synchronization in Generic Collections](https://blogs.msdn.microsoft.com/bclteam/2005/03/15/synchronization-in-generic-collections-brian-grunkemeyer/).</span></span>  
  
 <span data-ttu-id="190cb-116">Klasy kolekcji wprowadzone w środowisku .NET Framework 2.0 są umieszczone w przestrzeni nazw <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="190cb-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="190cb-117">Należą do nich <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> itd.</span><span class="sxs-lookup"><span data-stu-id="190cb-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="190cb-118">Te klasy oferują większe bezpieczeństwo pod względem typów i lepszą wydajność niż klasy środowiska .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="190cb-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="190cb-119">Jednak klasy kolekcji środowiska .NET Framework 2.0 nie zawierają żadnych funkcji synchronizacji wątków. Gdy elementy są dodawane lub usuwane równolegle w wielu wątkach, całą synchronizację musi zapewniać kod użytkownika.</span><span class="sxs-lookup"><span data-stu-id="190cb-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="190cb-120">Firma Microsoft zaleca klas kolekcji współbieżnych [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] ponieważ zapewniają one nie tylko bezpieczeństwo typu klas kolekcji .NET Framework 2.0, ale także bardziej wydajne i kompletne bezpieczeństwo wątkowe niż [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] kolekcje zapewniają.</span><span class="sxs-lookup"><span data-stu-id="190cb-120">We recommend the concurrent collections classes in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="190cb-121">Blokowanie szczegółowe i mechanizmy bezblokadowe</span><span class="sxs-lookup"><span data-stu-id="190cb-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="190cb-122">Niektóre typy kolekcji współbieżnych wykorzystują uproszczone mechanizmy synchronizacji, takie jak <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> i <xref:System.Threading.CountdownEvent>, które po raz pierwszy wprowadzono w środowisku [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].</span><span class="sxs-lookup"><span data-stu-id="190cb-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].</span></span> <span data-ttu-id="190cb-123">Te rodzaje synchronizacji zazwyczaj używa się *rotowania zajętości* podczas krótkich okresów, zanim przełączą wątek do faktycznego stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="190cb-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="190cb-124">Jeśli spodziewane czasy oczekiwania będą bardzo krótkie, warto stosować rotowanie, ponieważ znacznie mniej obciąża ono zasoby systemu niż przejścia jądra występujące w czekaniu.</span><span class="sxs-lookup"><span data-stu-id="190cb-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="190cb-125">W przypadku klas kolekcji wykorzystujących mechanizm rotowania lepsza wydajność oznacza możliwość dodawania i usuwania elementów równolegle przez wiele wątków z bardzo dużą szybkością.</span><span class="sxs-lookup"><span data-stu-id="190cb-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="190cb-126">Aby uzyskać więcej informacji dotyczących rotowania i blokowania, zobacz [struktury SpinLock](../../../../docs/standard/threading/spinlock.md) i [metody SpinWait](../../../../docs/standard/threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="190cb-126">For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="190cb-127">Klasy <xref:System.Collections.Concurrent.ConcurrentQueue%601> i <xref:System.Collections.Concurrent.ConcurrentStack%601> w ogóle nie nakładają blokad.</span><span class="sxs-lookup"><span data-stu-id="190cb-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="190cb-128">Zamiast tego do zapewnienia bezpieczeństwa wątkowego wykorzystują operacje <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="190cb-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="190cb-129">Ponieważ klasy kolekcji współbieżnych obsługują interfejs <xref:System.Collections.ICollection>, implementują one właściwości <xref:System.Collections.ICollection.IsSynchronized%2A> i <xref:System.Collections.ICollection.SyncRoot%2A>, nawet jeśli te właściwości są nieistotne.</span><span class="sxs-lookup"><span data-stu-id="190cb-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="190cb-130">Właściwość `IsSynchronized` zawsze zwraca wartość `false`, a właściwość `SyncRoot` zawsze ma wartość `null` (`Nothing` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="190cb-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="190cb-131">W tabeli poniżej wymieniono typy kolekcji istniejące w przestrzeni nazw <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="190cb-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="190cb-132">Typ</span><span class="sxs-lookup"><span data-stu-id="190cb-132">Type</span></span>|<span data-ttu-id="190cb-133">Opis</span><span class="sxs-lookup"><span data-stu-id="190cb-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="190cb-134">Zapewnia funkcjonalność ograniczania i blokowania dla wszystkich typów implementujących interfejs <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="190cb-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="190cb-135">Aby uzyskać więcej informacji, zobacz [BlockingCollection — Przegląd](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="190cb-135">For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="190cb-136">Bezpieczna wątkowo implementacja słownika par klucz-wartość.</span><span class="sxs-lookup"><span data-stu-id="190cb-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="190cb-137">Bezpieczna wątkowo implementacja kolejki FIFO („pierwszy na wejściu, pierwszy na wyjściu”).</span><span class="sxs-lookup"><span data-stu-id="190cb-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="190cb-138">Bezpieczna wątkowo implementacja stosu LIFO („ostatni na wejściu, pierwszy na wyjściu”).</span><span class="sxs-lookup"><span data-stu-id="190cb-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="190cb-139">Bezpieczna wątkowo implementacja nieuporządkowanej kolekcji elementów.</span><span class="sxs-lookup"><span data-stu-id="190cb-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="190cb-140">Interfejs, który musi implementować typ, aby mógł być używany w klasie `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="190cb-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="190cb-141">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="190cb-141">Related Topics</span></span>  
  
|<span data-ttu-id="190cb-142">Tytuł</span><span class="sxs-lookup"><span data-stu-id="190cb-142">Title</span></span>|<span data-ttu-id="190cb-143">Opis</span><span class="sxs-lookup"><span data-stu-id="190cb-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="190cb-144">BlockingCollection — omówienie</span><span class="sxs-lookup"><span data-stu-id="190cb-144">BlockingCollection Overview</span></span>](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|<span data-ttu-id="190cb-145">Opisuje funkcje zawarte w typie <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="190cb-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="190cb-146">Instrukcje: Dodawanie i usuwanie elementów concurrentdictionary</span><span class="sxs-lookup"><span data-stu-id="190cb-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|<span data-ttu-id="190cb-147">Opisuje metody dodawania i usuwania elementów w klasie <xref:System.Collections.Concurrent.ConcurrentDictionary%602>.</span><span class="sxs-lookup"><span data-stu-id="190cb-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="190cb-148">Instrukcje: Dodawanie i pobieranie elementów osobno z kolekcji BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="190cb-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|<span data-ttu-id="190cb-149">Opisuje metody dodawania i pobierania elementów z kolekcji blokującej bez używania modułu wyliczającego z właściwością tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="190cb-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="190cb-150">Instrukcje: Dodaj blokujących i ograniczających do kolekcji funkcji</span><span class="sxs-lookup"><span data-stu-id="190cb-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|<span data-ttu-id="190cb-151">Opisuje wykorzystywanie klas kolekcji jako podstawowego mechanizmu przechowywania dla kolekcji <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="190cb-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="190cb-152">Instrukcje: Używanie metody ForEach do usuwanie elementów blockingcollection</span><span class="sxs-lookup"><span data-stu-id="190cb-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|<span data-ttu-id="190cb-153">Opisuje zastosowanie instrukcji `foreach` (`For Each` w języku Visual Basic) do usuwania wszystkich elementów w kolekcji blokującej.</span><span class="sxs-lookup"><span data-stu-id="190cb-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="190cb-154">Instrukcje: Używanie tablic kolekcji blokujących w potoku</span><span class="sxs-lookup"><span data-stu-id="190cb-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="190cb-155">Opisuje zastosowanie wielu kolekcji blokujących równocześnie w celu zaimplementowania potoku.</span><span class="sxs-lookup"><span data-stu-id="190cb-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="190cb-156">Instrukcje: Tworzenie puli obiektów przy użyciu ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="190cb-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|<span data-ttu-id="190cb-157">Pokazuje, jak za pomocą współbieżnego zbioru poprawić wydajność w scenariuszach, gdzie można wykorzystywać istniejące obiekty zamiast ciągle tworzyć nowe.</span><span class="sxs-lookup"><span data-stu-id="190cb-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="190cb-158">Tematy pomocy</span><span class="sxs-lookup"><span data-stu-id="190cb-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
