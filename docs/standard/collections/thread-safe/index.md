---
title: Kolekcje bezpieczne wątkowo
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 790543118b18b0422f41c3249512b62aae0cfb03
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "75938109"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="9931a-102">Kolekcje bezpieczne wątkowo</span><span class="sxs-lookup"><span data-stu-id="9931a-102">Thread-Safe Collections</span></span>
<span data-ttu-id="9931a-103">.NET Framework 4 wprowadza <xref:System.Collections.Concurrent?displayProperty=nameWithType> obszar nazw, który zawiera kilka klas kolekcji, które są bezpieczne dla wątków i skalowalne.</span><span class="sxs-lookup"><span data-stu-id="9931a-103">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="9931a-104">Wiele wątków można bezpiecznie i wydajnie dodawać lub usuwać elementy z tych kolekcji, bez konieczności dodatkowej synchronizacji w kodzie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="9931a-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="9931a-105">Podczas pisania nowego kodu, należy użyć klas kolekcji równoczesnych, gdy wiele wątków będzie zapisywać do kolekcji jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="9931a-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="9931a-106">Jeśli z udostępnionej kolekcji odbywa się tylko odczyt, można używać klas z przestrzeni nazw <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9931a-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="9931a-107">Zalecamy nieużywanie klas kolekcji w wersji 1.0, chyba że aplikacje mają być przeznaczone dla środowiska uruchomieniowego .NET Framework 1.1 lub starszego.</span><span class="sxs-lookup"><span data-stu-id="9931a-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="9931a-108">Synchronizacja wątków w kolekcjach środowisk .NET Framework 1.0 i 2.0</span><span class="sxs-lookup"><span data-stu-id="9931a-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="9931a-109">Kolekcje wprowadzone w środowisku .NET Framework 1.0 znajdują się w przestrzeni nazw <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9931a-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="9931a-110">Kolekcje te, wśród których są m.in. powszechnie używane <xref:System.Collections.ArrayList> i <xref:System.Collections.Hashtable>, oferują pewne bezpieczeństwo wątkowe za pomocą właściwości `Synchronized`, która zwraca bezpieczną wątkowo otokę wokół kolekcji.</span><span class="sxs-lookup"><span data-stu-id="9931a-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="9931a-111">Otoka działa w ten sposób, że blokuje całą kolekcję podczas każdej operacji dodawania lub usuwania.</span><span class="sxs-lookup"><span data-stu-id="9931a-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="9931a-112">W związku z tym każdy wątek, który próbuje uzyskać dostęp do kolekcji, musi czekać na swoją kolej, aby nałożyć jedną blokadę.</span><span class="sxs-lookup"><span data-stu-id="9931a-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="9931a-113">Takie rozwiązanie nie jest skalowalne i przy dużych kolekcjach może powodować znaczne pogorszenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="9931a-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="9931a-114">Ponadto konstrukcja nie jest całkowicie chroniona przed sytuacjami wyścigu.</span><span class="sxs-lookup"><span data-stu-id="9931a-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="9931a-115">Aby uzyskać więcej informacji, zobacz [Synchronizacja w zbiorach ogólnych](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span><span class="sxs-lookup"><span data-stu-id="9931a-115">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="9931a-116">Klasy kolekcji wprowadzone w środowisku .NET Framework 2.0 są umieszczone w przestrzeni nazw <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9931a-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="9931a-117">Należą do nich <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> itd.</span><span class="sxs-lookup"><span data-stu-id="9931a-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="9931a-118">Te klasy oferują większe bezpieczeństwo pod względem typów i lepszą wydajność niż klasy środowiska .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="9931a-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="9931a-119">Jednak klasy kolekcji środowiska .NET Framework 2.0 nie zawierają żadnych funkcji synchronizacji wątków. Gdy elementy są dodawane lub usuwane równolegle w wielu wątkach, całą synchronizację musi zapewniać kod użytkownika.</span><span class="sxs-lookup"><span data-stu-id="9931a-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="9931a-120">Firma Microsoft zaleca klas kolekcji równoczesnych w .NET Framework 4, ponieważ zapewniają one nie tylko bezpieczeństwo typu .NET Framework 2.0 klas kolekcji, ale także bardziej wydajne i bardziej kompletne bezpieczeństwo wątków niż .NET Framework 1.0 kolekcje Zapewnić.</span><span class="sxs-lookup"><span data-stu-id="9931a-120">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="9931a-121">Blokowanie szczegółowe i mechanizmy bezblokadowe</span><span class="sxs-lookup"><span data-stu-id="9931a-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="9931a-122">Niektóre typy kolekcji równoczesnych używają lekkich <xref:System.Threading.SpinLock>mechanizmów synchronizacji, takich jak , <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, i <xref:System.Threading.CountdownEvent>, które są nowe w .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="9931a-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="9931a-123">Te typy synchronizacji zazwyczaj używają *zajęty przędzenia* przez krótkie okresy, zanim umieścić wątek w stanie oczekiwania true.</span><span class="sxs-lookup"><span data-stu-id="9931a-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="9931a-124">Jeśli spodziewane czasy oczekiwania będą bardzo krótkie, warto stosować rotowanie, ponieważ znacznie mniej obciąża ono zasoby systemu niż przejścia jądra występujące w czekaniu.</span><span class="sxs-lookup"><span data-stu-id="9931a-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="9931a-125">W przypadku klas kolekcji wykorzystujących mechanizm rotowania lepsza wydajność oznacza możliwość dodawania i usuwania elementów równolegle przez wiele wątków z bardzo dużą szybkością.</span><span class="sxs-lookup"><span data-stu-id="9931a-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="9931a-126">Aby uzyskać więcej informacji na temat wirowania vs blokowania, zobacz [SpinLock](../../../../docs/standard/threading/spinlock.md) i [SpinWait](../../../../docs/standard/threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="9931a-126">For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="9931a-127">Klasy <xref:System.Collections.Concurrent.ConcurrentQueue%601> i <xref:System.Collections.Concurrent.ConcurrentStack%601> w ogóle nie nakładają blokad.</span><span class="sxs-lookup"><span data-stu-id="9931a-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="9931a-128">Zamiast tego do zapewnienia bezpieczeństwa wątkowego wykorzystują operacje <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="9931a-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9931a-129">Ponieważ klasy kolekcji współbieżnych obsługują interfejs <xref:System.Collections.ICollection>, implementują one właściwości <xref:System.Collections.ICollection.IsSynchronized%2A> i <xref:System.Collections.ICollection.SyncRoot%2A>, nawet jeśli te właściwości są nieistotne.</span><span class="sxs-lookup"><span data-stu-id="9931a-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="9931a-130">Właściwość `IsSynchronized` zawsze zwraca wartość `false`, a właściwość `SyncRoot` zawsze ma wartość `null` (`Nothing` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9931a-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="9931a-131">W tabeli poniżej wymieniono typy kolekcji istniejące w przestrzeni nazw <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9931a-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="9931a-132">Typ</span><span class="sxs-lookup"><span data-stu-id="9931a-132">Type</span></span>|<span data-ttu-id="9931a-133">Opis</span><span class="sxs-lookup"><span data-stu-id="9931a-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="9931a-134">Zapewnia funkcjonalność ograniczania i blokowania dla wszystkich typów implementujących interfejs <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="9931a-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="9931a-135">Aby uzyskać więcej informacji, zobacz [Omówienie blokowania kolekcji](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="9931a-135">For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="9931a-136">Bezpieczna wątkowo implementacja słownika par klucz-wartość.</span><span class="sxs-lookup"><span data-stu-id="9931a-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="9931a-137">Bezpieczna wątkowo implementacja kolejki FIFO („pierwszy na wejściu, pierwszy na wyjściu”).</span><span class="sxs-lookup"><span data-stu-id="9931a-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="9931a-138">Bezpieczna wątkowo implementacja stosu LIFO („ostatni na wejściu, pierwszy na wyjściu”).</span><span class="sxs-lookup"><span data-stu-id="9931a-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="9931a-139">Bezpieczna wątkowo implementacja nieuporządkowanej kolekcji elementów.</span><span class="sxs-lookup"><span data-stu-id="9931a-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="9931a-140">Interfejs, który musi implementować typ, aby mógł być używany w klasie `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="9931a-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="9931a-141">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="9931a-141">Related Topics</span></span>  
  
|<span data-ttu-id="9931a-142">Tytuł</span><span class="sxs-lookup"><span data-stu-id="9931a-142">Title</span></span>|<span data-ttu-id="9931a-143">Opis</span><span class="sxs-lookup"><span data-stu-id="9931a-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="9931a-144">BlockingCollection — Przegląd</span><span class="sxs-lookup"><span data-stu-id="9931a-144">BlockingCollection Overview</span></span>](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|<span data-ttu-id="9931a-145">Opisuje funkcje zawarte w typie <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="9931a-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="9931a-146">Porady: dodawanie i usuwanie elementów ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9931a-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|<span data-ttu-id="9931a-147">Opisuje metody dodawania i usuwania elementów w klasie <xref:System.Collections.Concurrent.ConcurrentDictionary%602>.</span><span class="sxs-lookup"><span data-stu-id="9931a-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="9931a-148">Porady: dodawanie i pobieranie elementów osobno z kolekcji BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="9931a-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|<span data-ttu-id="9931a-149">Opisuje metody dodawania i pobierania elementów z kolekcji blokującej bez używania modułu wyliczającego z właściwością tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9931a-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="9931a-150">Porady: dodawanie do kolekcji funkcji blokujących i ograniczających</span><span class="sxs-lookup"><span data-stu-id="9931a-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|<span data-ttu-id="9931a-151">Opisuje wykorzystywanie klas kolekcji jako podstawowego mechanizmu przechowywania dla kolekcji <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="9931a-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="9931a-152">Porady: używanie ForEach do usuwanie elementów BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="9931a-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|<span data-ttu-id="9931a-153">Opisuje zastosowanie instrukcji `foreach` (`For Each` w języku Visual Basic) do usuwania wszystkich elementów w kolekcji blokującej.</span><span class="sxs-lookup"><span data-stu-id="9931a-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="9931a-154">Instrukcje: Używanie tablic kolekcji blokujących w potoku</span><span class="sxs-lookup"><span data-stu-id="9931a-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="9931a-155">Opisuje zastosowanie wielu kolekcji blokujących równocześnie w celu zaimplementowania potoku.</span><span class="sxs-lookup"><span data-stu-id="9931a-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="9931a-156">Porady: tworzenie puli obiektów przy użyciu ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="9931a-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|<span data-ttu-id="9931a-157">Pokazuje, jak za pomocą współbieżnego zbioru poprawić wydajność w scenariuszach, gdzie można wykorzystywać istniejące obiekty zamiast ciągle tworzyć nowe.</span><span class="sxs-lookup"><span data-stu-id="9931a-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="9931a-158">Dokumentacja</span><span class="sxs-lookup"><span data-stu-id="9931a-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
