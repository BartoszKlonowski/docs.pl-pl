---
title: Kiedy należy używać kolekcji bezpiecznych wątkowo
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
author: mairaw
ms.author: mairaw
ms.openlocfilehash: eefa1b52907525059b3403e7eb20542d3b5a5c73
ms.sourcegitcommit: 64f4baed249341e5bf64d1385bf48e3f2e1a0211
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/07/2018
ms.locfileid: "44131701"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="b49ed-102">Kiedy należy używać kolekcji bezpiecznych wątkowo</span><span class="sxs-lookup"><span data-stu-id="b49ed-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="b49ed-103">[!INCLUDE[net_v40_long](../../../../includes/net-v40-long-md.md)] Wprowadza pięć nowe typy kolekcji, które są specjalnie przeznaczone do wsparcia wielowątkowych dodawania i usuwania działań.</span><span class="sxs-lookup"><span data-stu-id="b49ed-103">The [!INCLUDE[net_v40_long](../../../../includes/net-v40-long-md.md)] introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="b49ed-104">Do zapewnienia bezpieczeństwa wątkowego, te nowe typy użyć różnych rodzajów blokowanie wydajne i mechanizmy bezblokadowe synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="b49ed-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="b49ed-105">Synchronizacja obciążenie dodaje się do operacji.</span><span class="sxs-lookup"><span data-stu-id="b49ed-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="b49ed-106">Obciążenie zależy od rodzaju synchronizacji, która jest używana, rodzaj operacji, które są wykonywane i innych czynników, takich jak liczba wątków, które próbują jednocześnie uzyskać dostęp do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="b49ed-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="b49ed-107">W niektórych scenariuszach synchronizacji obciążenie jest niewielki i umożliwia wielowątkowych typu wykonywać znacznie szybciej i skalować znacznie lepsze niż równoważnik bez wątkowo, gdy chronione przez blokadę zewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="b49ed-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="b49ed-108">W innych scenariuszach obciążenie może spowodować typu wątków do wykonywania i skalować prawie taki sam lub nawet wolniej niż wersji zewnętrznie zablokowane, nie wątkowo typu.</span><span class="sxs-lookup"><span data-stu-id="b49ed-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="b49ed-109">Poniższe sekcje zawierają ogólne wytyczne o tym, kiedy używać kolekcji bezpiecznych wątkowo i jego odpowiednik bez wątkowo, która ma blokady użytkownika wokół jego odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="b49ed-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="b49ed-110">Ponieważ wydajność będzie zależeć od wielu czynników, wskazówki nie jest określone i nie nadaje się zawsze w każdych okolicznościach.</span><span class="sxs-lookup"><span data-stu-id="b49ed-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="b49ed-111">Jeśli wydajność jest bardzo ważne, najlepszym sposobem, aby określić typ kolekcji do użycia jest mierzenie wydajności na podstawie konfiguracji reprezentatywny komputera i ładowania.</span><span class="sxs-lookup"><span data-stu-id="b49ed-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="b49ed-112">W tym dokumencie są używane następujące terminy:</span><span class="sxs-lookup"><span data-stu-id="b49ed-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="b49ed-113">*Scenariusz czystego producent — konsument*</span><span class="sxs-lookup"><span data-stu-id="b49ed-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="b49ed-114">Wątek danego, jest dodanie lub usunięcie elementów, ale nie oba.</span><span class="sxs-lookup"><span data-stu-id="b49ed-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="b49ed-115">*Scenariusz mieszane producent — konsument*</span><span class="sxs-lookup"><span data-stu-id="b49ed-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="b49ed-116">Jednym z wątków danej jest równoczesne Dodawanie i usuwanie elementów.</span><span class="sxs-lookup"><span data-stu-id="b49ed-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="b49ed-117">*Przyspieszenie*</span><span class="sxs-lookup"><span data-stu-id="b49ed-117">*Speedup*</span></span>  
 <span data-ttu-id="b49ed-118">Szybsze konsolidatorze wydajności względem innego typu w ten sam scenariusz.</span><span class="sxs-lookup"><span data-stu-id="b49ed-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="b49ed-119">*Skalowalność*</span><span class="sxs-lookup"><span data-stu-id="b49ed-119">*Scalability*</span></span>  
 <span data-ttu-id="b49ed-120">Wzrost wydajności, który jest proporcjonalny do liczby rdzeni na komputerze.</span><span class="sxs-lookup"><span data-stu-id="b49ed-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="b49ed-121">Algorytm, który jest skalowany dokonuje szybciej osiem rdzeni niż na dwa rdzenie.</span><span class="sxs-lookup"><span data-stu-id="b49ed-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="b49ed-122">ConcurrentQueue(T) programu vs. Queue(T)</span><span class="sxs-lookup"><span data-stu-id="b49ed-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="b49ed-123">W scenariuszach czystego producent — konsument, gdy czas przetwarzania dla każdego elementu jest bardzo mały (kilka instrukcje), następnie <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> oferują korzyści z niewielkim wydajności za pośrednictwem <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> ma blokady zewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="b49ed-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="b49ed-124">W tym scenariuszu <xref:System.Collections.Concurrent.ConcurrentQueue%601> sprawdza się najlepiej, gdy umieszcza w kolejce jeden dedykowanym wątku, a jeden dedykowanym wątku cofnąć kolejkowania.</span><span class="sxs-lookup"><span data-stu-id="b49ed-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="b49ed-125">Jeśli nie wymuszają tę regułę, następnie <xref:System.Collections.Generic.Queue%601> nawet mogą wykonywać nieznacznie szybsze niż <xref:System.Collections.Concurrent.ConcurrentQueue%601> na komputerach, które mają wiele rdzeni.</span><span class="sxs-lookup"><span data-stu-id="b49ed-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="b49ed-126">Gdy czas przetwarzania wynosi około 500 FLOPS (operacji zmiennoprzecinkowych) lub więcej, następnie reguła dwóch wątku nie ma zastosowania do <xref:System.Collections.Concurrent.ConcurrentQueue%601>, który następnie jest bardzo dobra skalowalności.</span><span class="sxs-lookup"><span data-stu-id="b49ed-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="b49ed-127"><xref:System.Collections.Generic.Queue%601> nie działa dobrze w tym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="b49ed-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="b49ed-128">W mieszanym producent — konsument scenariusze, gdy czas przetwarzania jest bardzo mały <xref:System.Collections.Generic.Queue%601> zawierający zewnętrznego blokady skaluje się lepiej niż <xref:System.Collections.Concurrent.ConcurrentQueue%601> jest.</span><span class="sxs-lookup"><span data-stu-id="b49ed-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="b49ed-129">Jednak czas przetwarzania po około 500 FLOPS lub dłużej, a następnie <xref:System.Collections.Concurrent.ConcurrentQueue%601> skaluje się lepiej.</span><span class="sxs-lookup"><span data-stu-id="b49ed-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="b49ed-130">ConcurrentStack programu vs. Stos</span><span class="sxs-lookup"><span data-stu-id="b49ed-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="b49ed-131">W scenariuszach czystego producent — konsument, gdy czas przetwarzania jest bardzo mały, następnie <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> i <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> zawierający zewnętrznego blokady prawdopodobnie będzie wykonywać mniej więcej taka sama, za pomocą jednego z dedykowanego wątku wypychania i jeden wątek zdejmowanie dedykowanych.</span><span class="sxs-lookup"><span data-stu-id="b49ed-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="b49ed-132">Jednak jako liczba wątków wzrasta, oba typy spowolnić działanie z powodu nasilenie rywalizacji i <xref:System.Collections.Generic.Stack%601> może działać lepiej niż <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span><span class="sxs-lookup"><span data-stu-id="b49ed-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="b49ed-133">Gdy czas przetwarzania jest około 500 FLOPS lub więcej, a następnie obu typów skalowania o tej samej stawki.</span><span class="sxs-lookup"><span data-stu-id="b49ed-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="b49ed-134">W mieszanym producent — konsument scenariuszy <xref:System.Collections.Concurrent.ConcurrentStack%601> jest szybsza w przypadku zarówno małych, jak i dużych obciążeń.</span><span class="sxs-lookup"><span data-stu-id="b49ed-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="b49ed-135">Korzystanie z <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> i <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> może znacznie przyspieszyć godziny dostępu.</span><span class="sxs-lookup"><span data-stu-id="b49ed-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="b49ed-136">ConcurrentDictionary programu vs. Słownik</span><span class="sxs-lookup"><span data-stu-id="b49ed-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="b49ed-137">Ogólnie rzecz biorąc, użyj <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> w każdym scenariuszu, gdzie Dodawanie i aktualizowanie kluczy ani wartości, jednocześnie z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="b49ed-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="b49ed-138">W scenariuszach, które obejmują częste aktualizacje i stosunkowo niewielką liczbą odczyty <xref:System.Collections.Concurrent.ConcurrentDictionary%602> zwykle zapewnia niewielkie korzyści.</span><span class="sxs-lookup"><span data-stu-id="b49ed-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="b49ed-139">W scenariuszach obejmujących wiele operacji odczytu i wiele aktualizacji <xref:System.Collections.Concurrent.ConcurrentDictionary%602> ogólnie jest znacznie szybsze, na komputerach z dowolną liczbą rdzeni.</span><span class="sxs-lookup"><span data-stu-id="b49ed-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="b49ed-140">W scenariuszach obejmujących częste aktualizacje, można zwiększyć stopień współbieżności w <xref:System.Collections.Concurrent.ConcurrentDictionary%602> , a następnie zmierzyć, aby zobaczyć, czy zwiększona wydajność na komputerach, które mają więcej rdzeni.</span><span class="sxs-lookup"><span data-stu-id="b49ed-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="b49ed-141">Jeśli zmienisz poziom współbieżności, należy unikać możliwie globalne operacje.</span><span class="sxs-lookup"><span data-stu-id="b49ed-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="b49ed-142">Jeśli użytkownik jest tylko do odczytu klucza lub wartości, <xref:System.Collections.Generic.Dictionary%602> przebiega szybciej, ponieważ synchronizacja nie jest wymagana, jeśli słownik nie jest modyfikowana przez wszystkie wątki.</span><span class="sxs-lookup"><span data-stu-id="b49ed-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="b49ed-143">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="b49ed-143">ConcurrentBag</span></span>  
 <span data-ttu-id="b49ed-144">W scenariuszach czystego producent — konsument <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> wykona prawdopodobnie wolniej niż inne typy kolekcji współbieżnych.</span><span class="sxs-lookup"><span data-stu-id="b49ed-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="b49ed-145">W mieszanym producent — konsument scenariuszy <xref:System.Collections.Concurrent.ConcurrentBag%601> jest zwykle znacznie szybsze i bardziej skalowalne niż każdy inny typ kolekcji współbieżnych dla małych i dużych obciążeń.</span><span class="sxs-lookup"><span data-stu-id="b49ed-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="b49ed-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="b49ed-146">BlockingCollection</span></span>  
 <span data-ttu-id="b49ed-147">Gdy blokujących i ograniczających semantyki są wymagane, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> będzie prawdopodobnie działać szybciej, niż niestandardowych implementacji.</span><span class="sxs-lookup"><span data-stu-id="b49ed-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="b49ed-148">Obsługuje również zaawansowane anulowania, wyliczenia i obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="b49ed-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b49ed-149">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="b49ed-149">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
- [<span data-ttu-id="b49ed-150">Kolekcje bezpieczne wątkowo</span><span class="sxs-lookup"><span data-stu-id="b49ed-150">Thread-Safe Collections</span></span>](../../../../docs/standard/collections/thread-safe/index.md)  
- [<span data-ttu-id="b49ed-151">Programowanie równoległe</span><span class="sxs-lookup"><span data-stu-id="b49ed-151">Parallel Programming</span></span>](../../../../docs/standard/parallel-programming/index.md)
