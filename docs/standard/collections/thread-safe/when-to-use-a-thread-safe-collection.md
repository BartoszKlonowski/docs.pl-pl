---
title: Kiedy należy używać kolekcji bezpiecznych wątkowo
description: Dowiedz się, kiedy używać kolekcji bezpiecznej dla wątków w programie .NET. Istnieją 5 typów kolekcji, które są specjalnie przeznaczone do obsługi wielowątkowych Dodaj & operacji usuwania.
ms.date: 03/30/2017
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 92fb912cdd2030f87bee1109b9944e1fa857dddd
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819464"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="54bd8-104">Kiedy używać kolekcji bezpiecznej dla wątków</span><span class="sxs-lookup"><span data-stu-id="54bd8-104">When to use a thread-safe collection</span></span>

<span data-ttu-id="54bd8-105">.NET Framework 4 wprowadził pięć typów kolekcji, które są specjalnie przeznaczone do obsługi operacji dodawania i usuwania wielowątkowych.</span><span class="sxs-lookup"><span data-stu-id="54bd8-105">.NET Framework 4 introduced five collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="54bd8-106">Aby zapewnić bezpieczeństwo wątków, te typy wykorzystują różne rodzaje wydajnych mechanizmów synchronizacji i blokowania bez blokady.</span><span class="sxs-lookup"><span data-stu-id="54bd8-106">To achieve thread-safety, these types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="54bd8-107">Synchronizacja dodaje narzuty do operacji.</span><span class="sxs-lookup"><span data-stu-id="54bd8-107">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="54bd8-108">Ilość narzutów zależy od rodzaju używanej synchronizacji, rodzaju wykonywanych operacji oraz innych czynników, takich jak liczba wątków, które próbują jednocześnie uzyskać dostęp do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="54bd8-108">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="54bd8-109">W niektórych scenariuszach narzuty związane z synchronizacją są nieznaczne i umożliwiają znacznie szybszy i bardziej skalowalne skalowanie, w porównaniu z niebezpiecznym wątkem, w przypadku ochrony przez zewnętrzną blokadę.</span><span class="sxs-lookup"><span data-stu-id="54bd8-109">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="54bd8-110">W innych scenariuszach narzuty mogą spowodować, że typ bezpieczny wątkowo będzie wykonywany i skalowalny na tym samym lub nawet wolniej niż zablokowana zewnętrznie, niezabezpieczona przed wątkiem wersja typu.</span><span class="sxs-lookup"><span data-stu-id="54bd8-110">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="54bd8-111">W poniższych sekcjach znajdują się ogólne wskazówki dotyczące sytuacji, w których należy używać kolekcji bezpiecznej dla wątków, a jej bezwzględnie niebezpieczny wątek, która ma blokadę dostarczoną przez użytkownika wokół operacji odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="54bd8-111">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="54bd8-112">Ze względu na to, że wydajność może się różnić w zależności od wielu czynników, wskazówki nie są specyficzne i nie zawsze są ważne we wszystkich okolicznościach.</span><span class="sxs-lookup"><span data-stu-id="54bd8-112">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="54bd8-113">Jeśli wydajność jest bardzo ważna, najlepszym sposobem określenia typu kolekcji, który ma być używany, jest pomiar wydajności na podstawie konfiguracji i obciążeń na reprezentatywnym komputerze.</span><span class="sxs-lookup"><span data-stu-id="54bd8-113">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="54bd8-114">W tym dokumencie są stosowane następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="54bd8-114">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="54bd8-115">*Czysty scenariusz dla producentów*</span><span class="sxs-lookup"><span data-stu-id="54bd8-115">*Pure producer-consumer scenario*</span></span>\
 <span data-ttu-id="54bd8-116">Każdy dany wątek dodaje lub usuwa elementy, ale nie oba.</span><span class="sxs-lookup"><span data-stu-id="54bd8-116">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="54bd8-117">*Mieszany scenariusz dla klientów*</span><span class="sxs-lookup"><span data-stu-id="54bd8-117">*Mixed producer-consumer scenario*</span></span>\
 <span data-ttu-id="54bd8-118">Każdy dany wątek jednocześnie dodaje i usuwa elementy.</span><span class="sxs-lookup"><span data-stu-id="54bd8-118">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="54bd8-119">*Przyspieszenie*</span><span class="sxs-lookup"><span data-stu-id="54bd8-119">*Speedup*</span></span>\
 <span data-ttu-id="54bd8-120">Szybsza wydajność algorytmu względem innego typu w tym samym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="54bd8-120">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="54bd8-121">*Względem*</span><span class="sxs-lookup"><span data-stu-id="54bd8-121">*Scalability*</span></span>\
 <span data-ttu-id="54bd8-122">Zwiększenie wydajności, która jest proporcjonalna do liczby rdzeni na komputerze.</span><span class="sxs-lookup"><span data-stu-id="54bd8-122">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="54bd8-123">Algorytm, który skaluje się szybciej na osiem rdzeni niż w przypadku dwóch rdzeni.</span><span class="sxs-lookup"><span data-stu-id="54bd8-123">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="54bd8-124">ConcurrentQueue (T) a kolejka (T)</span><span class="sxs-lookup"><span data-stu-id="54bd8-124">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="54bd8-125">W czystych scenariuszach dla producentów, w których czas przetwarzania dla każdego elementu jest bardzo mały (kilka instrukcji), a następnie <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> może oferować niewielkie korzyści z wydajności w porównaniu z <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> zewnętrznym zablokowaniem.</span><span class="sxs-lookup"><span data-stu-id="54bd8-125">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="54bd8-126">W tym scenariuszu <xref:System.Collections.Concurrent.ConcurrentQueue%601> najlepiej sprawdza się w przypadku, gdy jeden dedykowany wątek jest kolejką, a jeden dedykowany wątek zostaje cofnięty.</span><span class="sxs-lookup"><span data-stu-id="54bd8-126">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="54bd8-127">Jeśli ta reguła nie jest wymuszana, <xref:System.Collections.Generic.Queue%601> może to być nawet nieco szybsze niż <xref:System.Collections.Concurrent.ConcurrentQueue%601> na komputerach z wieloma rdzeniami.</span><span class="sxs-lookup"><span data-stu-id="54bd8-127">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="54bd8-128">Gdy czas przetwarzania ma około 500 FLOPS (operacji zmiennoprzecinkowych) lub więcej, to reguła dwuwątkowa nie ma zastosowania do <xref:System.Collections.Concurrent.ConcurrentQueue%601> , który następnie ma bardzo dobrą skalowalność.</span><span class="sxs-lookup"><span data-stu-id="54bd8-128">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="54bd8-129"><xref:System.Collections.Generic.Queue%601> nie skaluje się dobrze w tym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="54bd8-129"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="54bd8-130">W mieszanych scenariuszach konsumenckich klientów, gdy czas przetwarzania jest bardzo mały, a, <xref:System.Collections.Generic.Queue%601> który ma blokadę zewnętrzną skalowalność <xref:System.Collections.Concurrent.ConcurrentQueue%601> .</span><span class="sxs-lookup"><span data-stu-id="54bd8-130">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="54bd8-131">Jeśli jednak czas przetwarzania ma około 500 FLOPS lub więcej, wówczas <xref:System.Collections.Concurrent.ConcurrentQueue%601> skalowanie jest lepsze.</span><span class="sxs-lookup"><span data-stu-id="54bd8-131">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="54bd8-132">ConcurrentStack a stos</span><span class="sxs-lookup"><span data-stu-id="54bd8-132">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="54bd8-133">W czystych scenariuszach z zakresu producentów, gdy czas przetwarzania jest bardzo mały, a w przypadku, gdy <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> ma ona blokadę zewnętrzną, prawdopodobnie zostanie wykonane o jednym dedykowanym wątku wypychania i jednym dedykowanym wątku usuwanie.</span><span class="sxs-lookup"><span data-stu-id="54bd8-133">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="54bd8-134">Jednak w miarę wzrostu liczby wątków oba typy spowalniają działanie ze względu na zwiększoną rywalizację i <xref:System.Collections.Generic.Stack%601> mogą działać lepiej niż <xref:System.Collections.Concurrent.ConcurrentStack%601> .</span><span class="sxs-lookup"><span data-stu-id="54bd8-134">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="54bd8-135">Gdy czas przetwarzania ma około 500 FLOPS lub więcej, wówczas oba typy skalują o tej samej stawce.</span><span class="sxs-lookup"><span data-stu-id="54bd8-135">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="54bd8-136">W mieszanych scenariuszach konsumenckich klientów program <xref:System.Collections.Concurrent.ConcurrentStack%601> jest szybszy dla małych i dużych obciążeń.</span><span class="sxs-lookup"><span data-stu-id="54bd8-136">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="54bd8-137">Korzystanie z <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> i <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> może znacznie przyspieszyć czasy dostępu.</span><span class="sxs-lookup"><span data-stu-id="54bd8-137">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="54bd8-138">ConcurrentDictionary a słownik</span><span class="sxs-lookup"><span data-stu-id="54bd8-138">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="54bd8-139">Ogólnie rzecz biorąc, należy użyć <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> w dowolnym scenariuszu, w którym są dodawane i aktualizowane klucze lub wartości jednocześnie z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="54bd8-139">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="54bd8-140">W scenariuszach, które obejmują częste aktualizacje i stosunkowo kilka operacji odczytu, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> zazwyczaj oferują one niewielkie korzyści.</span><span class="sxs-lookup"><span data-stu-id="54bd8-140">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="54bd8-141">W scenariuszach obejmujących wiele operacji odczytu i wielu aktualizacji <xref:System.Collections.Concurrent.ConcurrentDictionary%602> zwykle jest to znacznie szybsze na komputerach, które mają dowolną liczbę rdzeni.</span><span class="sxs-lookup"><span data-stu-id="54bd8-141">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="54bd8-142">W scenariuszach, które obejmują częste aktualizacje, można zwiększyć stopień współbieżności w, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> a następnie mierzyć, aby sprawdzić, czy wydajność rośnie na komputerach, które mają więcej rdzeni.</span><span class="sxs-lookup"><span data-stu-id="54bd8-142">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="54bd8-143">Jeśli zmienisz poziom współbieżności, unikaj operacji globalnych tak często, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="54bd8-143">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="54bd8-144">W przypadku odczytywania tylko klucza lub wartości, <xref:System.Collections.Generic.Dictionary%602> jest to szybsze, ponieważ nie jest wymagana żadna synchronizacja, jeśli słownik nie jest modyfikowany przez żadne wątki.</span><span class="sxs-lookup"><span data-stu-id="54bd8-144">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="54bd8-145">Obiekt ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="54bd8-145">ConcurrentBag</span></span>  
 <span data-ttu-id="54bd8-146">W czystych scenariuszach z zakresu producentów klient <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> prawdopodobnie przestanie działać wolniej niż inne współbieżne typy kolekcji.</span><span class="sxs-lookup"><span data-stu-id="54bd8-146">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="54bd8-147">W mieszanych scenariuszach konsumenckich klientów <xref:System.Collections.Concurrent.ConcurrentBag%601> jest to znacznie szybsze i bardziej skalowalne niż każdy inny typ kolekcji współbieżnej dla dużych i małych obciążeń.</span><span class="sxs-lookup"><span data-stu-id="54bd8-147">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="54bd8-148">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="54bd8-148">BlockingCollection</span></span>  
 <span data-ttu-id="54bd8-149">Gdy wymagane są semantyki ograniczania i blokowania, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> prawdopodobnie będą wykonywane szybciej niż Każda implementacja niestandardowa.</span><span class="sxs-lookup"><span data-stu-id="54bd8-149">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="54bd8-150">Obsługuje ona również rozbudowane anulowanie, Wyliczanie i obsługę wyjątków.</span><span class="sxs-lookup"><span data-stu-id="54bd8-150">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="54bd8-151">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="54bd8-151">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="54bd8-152">Kolekcje bezpieczne dla wątków</span><span class="sxs-lookup"><span data-stu-id="54bd8-152">Thread-Safe Collections</span></span>](index.md)
- [<span data-ttu-id="54bd8-153">Programowanie równoległe</span><span class="sxs-lookup"><span data-stu-id="54bd8-153">Parallel Programming</span></span>](../../parallel-programming/index.md)
