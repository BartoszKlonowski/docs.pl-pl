---
title: Reguły projektowania (analiza kodu)
description: Poznaj reguły projektowania analizy kodu.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8c7d46b9271e33ab7ce3f989fae95bd57394ccd
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/07/2020
ms.locfileid: "96589436"
---
# <a name="design-rules"></a><span data-ttu-id="44cad-103">Reguły projektowania</span><span class="sxs-lookup"><span data-stu-id="44cad-103">Design rules</span></span>

<span data-ttu-id="44cad-104">Reguły projektowania obsługują przestrzeganie [wytycznych dotyczących projektowania .NET Framework](../../../standard/design-guidelines/index.md).</span><span class="sxs-lookup"><span data-stu-id="44cad-104">Design rules support adherence to the [.NET Framework Design Guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="44cad-105">W tej sekcji</span><span class="sxs-lookup"><span data-stu-id="44cad-105">In this section</span></span>

| <span data-ttu-id="44cad-106">Reguła</span><span class="sxs-lookup"><span data-stu-id="44cad-106">Rule</span></span> | <span data-ttu-id="44cad-107">Opis</span><span class="sxs-lookup"><span data-stu-id="44cad-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="44cad-108">CA1000: Nie deklaruj statycznych składowych na typach ogólnych</span><span class="sxs-lookup"><span data-stu-id="44cad-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="44cad-109">Po wywołaniu statycznego elementu członkowskiego typu ogólnego dla typu trzeba określić argument typu.</span><span class="sxs-lookup"><span data-stu-id="44cad-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="44cad-110">Po wywołaniu wystąpienia ogólnego elementu członkowskiego, które nie obsługuje wnioskowania, dla elementu członkowskiego musi zostać określony argument typu.</span><span class="sxs-lookup"><span data-stu-id="44cad-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="44cad-111">W tych dwóch przypadkach składnia określająca argument typu jest różna i łatwo o pomyłkę.</span><span class="sxs-lookup"><span data-stu-id="44cad-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="44cad-112">CA1001: Typy, do których należą pola możliwe do likwidacji, powinny być możliwe do likwidacji</span><span class="sxs-lookup"><span data-stu-id="44cad-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="44cad-113">Klasa deklaruje i implementuje pole wystąpienia, które jest typem system. IDisposable, a Klasa nie implementuje interfejsu IDisposable.</span><span class="sxs-lookup"><span data-stu-id="44cad-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="44cad-114">Klasa, która deklaruje pole IDisposable, pośrednio posiada niezarządzany zasób i powinna implementować interfejs IDisposable.</span><span class="sxs-lookup"><span data-stu-id="44cad-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="44cad-115">CA1002: Nie uwidaczniaj list ogólnych</span><span class="sxs-lookup"><span data-stu-id="44cad-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="44cad-116">System. Collections. Generic. list< (of \<(T> ) >) to ogólna kolekcja, która została zaprojektowana pod kątem wydajności, a nie dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="44cad-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="44cad-117">Dlatego też lista nie zawiera wirtualnych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="44cad-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="44cad-118">Zamiast powyższych powinny zostać zastosowane kolekcje ogólne, zaprojektowane do obsługi dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="44cad-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="44cad-119">CA1003: Użyj ogólnych wystąpień procedury obsługi zdarzeń</span><span class="sxs-lookup"><span data-stu-id="44cad-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="44cad-120">Typ zawiera delegata zwracającego wartość void, którego sygnatura zawiera dwa parametry (pierwszy obiekt i drugi typ, który można przypisać do EventArgs), oraz element docelowy zawierający zestaw .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="44cad-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="44cad-121">CA1005: Unikaj nadmiernego użycia parametrów w typach ogólnych</span><span class="sxs-lookup"><span data-stu-id="44cad-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="44cad-122">Im więcej parametrów typu zawiera typ ogólny, tym trudniej poznać i zapamiętać, co reprezentuje każdy z nich.</span><span class="sxs-lookup"><span data-stu-id="44cad-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="44cad-123">Zwykle jest oczywiste z jednym parametrem typu, jak na liście \<T> , a w niektórych przypadkach z dwoma parametrami typu, jak w słowniku \<TKey, TValue> .</span><span class="sxs-lookup"><span data-stu-id="44cad-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="44cad-124">Jeśli jednak istnieją więcej niż dwa parametry typu, poziom trudności staje się zbyt wysoki dla większości użytkowników.</span><span class="sxs-lookup"><span data-stu-id="44cad-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="44cad-125">CA1008: Typy wyliczeniowe powinny mieć wartość zero</span><span class="sxs-lookup"><span data-stu-id="44cad-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="44cad-126">Wartość domyślna niezainicjowanego typu wyliczeniowego, podobnie jak inne typy wartości, wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="44cad-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="44cad-127">Wyliczenie atrybutów bez flag powinno definiować składową przy użyciu wartości zero, aby wartość domyślna była prawidłową wartością wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="44cad-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="44cad-128">Jeśli wyliczenie, w którym zastosowano atrybut FlagsAttribute, definiuje element członkowski o wartości zero, powinno być nazwane „Brak”, aby wskazać, że żadne wartości nie zostały ustawione w wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="44cad-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="44cad-129">CA1010: Kolekcje powinny implementować interfejs ogólny</span><span class="sxs-lookup"><span data-stu-id="44cad-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="44cad-130">Aby poszerzyć użyteczność kolekcji, zaimplementuj jeden z interfejsów kolekcji generycznej.</span><span class="sxs-lookup"><span data-stu-id="44cad-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="44cad-131">Następnie kolekcja może zostać użyta, aby wypełnić typy generyczne kolekcji.</span><span class="sxs-lookup"><span data-stu-id="44cad-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="44cad-132">CA1012: Typy abstrakcyjne nie powinny mieć konstruktorów</span><span class="sxs-lookup"><span data-stu-id="44cad-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="44cad-133">Konstruktory dla typów abstrakcyjnych mogą być wywoływane tylko przez typy pochodne.</span><span class="sxs-lookup"><span data-stu-id="44cad-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="44cad-134">Ze względu na to, że publiczne konstruktory tworzą wystąpienia typu, a nie można utworzyć wystąpienia typu abstrakcyjnego, publiczny konstruktor typu abstrakcyjnego został niepoprawnie zaprojektowany.</span><span class="sxs-lookup"><span data-stu-id="44cad-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="44cad-135">CA1014: Oznacz zestawy atrybutem CLSCompliant</span><span class="sxs-lookup"><span data-stu-id="44cad-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="44cad-136">The Common Language Specification (CLS) definiuje ograniczenia nazw, typów danych i reguł, z którymi muszą być zgodne zestawy, jeśli zostaną użyte w językach programowania.</span><span class="sxs-lookup"><span data-stu-id="44cad-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="44cad-137">Dobry projekt wymusza, że wszystkie zestawy jawnie wskazują zgodność ze specyfikacją CLS przy użyciu CLSCompliantAttribute.</span><span class="sxs-lookup"><span data-stu-id="44cad-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="44cad-138">Jeśli ten atrybut nie jest obecny w zestawie, oznacza to, że zestaw jest niezgodny.</span><span class="sxs-lookup"><span data-stu-id="44cad-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="44cad-139">CA1016: Oznacz zestawy atrybutem AssemblyVersion</span><span class="sxs-lookup"><span data-stu-id="44cad-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="44cad-140">Platforma .NET używa numeru wersji do unikatowego identyfikowania zestawu i powiązania z typami w zestawach o silnej nazwie.</span><span class="sxs-lookup"><span data-stu-id="44cad-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="44cad-141">Numer wersji jest używany razem z zasadami wersji i wydawcy.</span><span class="sxs-lookup"><span data-stu-id="44cad-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="44cad-142">Domyślnie aplikacje są uruchamiane tylko z wersji zestawu, z którego zostały zbudowane.</span><span class="sxs-lookup"><span data-stu-id="44cad-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="44cad-143">CA1017: Oznacz zestawy atrybutem ComVisibleAttribute</span><span class="sxs-lookup"><span data-stu-id="44cad-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="44cad-144">ComVisibleAttribute określa, w jaki sposób klienci COM otrzymują dostęp do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="44cad-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="44cad-145">Zasada dobrego projektowania nakazuje, aby zestawy jawnie wskazywały widoczność COM.</span><span class="sxs-lookup"><span data-stu-id="44cad-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="44cad-146">Widoczność COM można ustawić dla całego zestawu, a następnie zastąpić dla poszczególnych typów i elementów członkowskich typu.</span><span class="sxs-lookup"><span data-stu-id="44cad-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="44cad-147">Jeśli ten atrybut jest nieobecny, zawartość zestawu jest widoczna dla klientów COM.</span><span class="sxs-lookup"><span data-stu-id="44cad-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="44cad-148">CA1018: Oznacz atrybuty atrybutem AttributeUsage</span><span class="sxs-lookup"><span data-stu-id="44cad-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="44cad-149">Podczas definiowania atrybutu niestandardowego należy go oznaczyć przy użyciu elementu AttributeUsageAttribute, aby wskazać, w którym miejscu kodu źródłowego ma być on zastosowany.</span><span class="sxs-lookup"><span data-stu-id="44cad-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="44cad-150">Znaczenie i zamierzone użycie atrybutu określi jego prawidłowe lokalizacje w kodzie.</span><span class="sxs-lookup"><span data-stu-id="44cad-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="44cad-151">CA1019: Zdefiniuj metody dostępu dla argumentów atrybutów</span><span class="sxs-lookup"><span data-stu-id="44cad-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="44cad-152">Atrybuty mogą definiować obowiązkowe argumenty, które trzeba określić, aby móc zastosować atrybut do obiektu docelowego.</span><span class="sxs-lookup"><span data-stu-id="44cad-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="44cad-153">Znane są również jako argumenty pozycyjne, ponieważ są one dostarczane do konstruktorów atrybutu jako parametry pozycyjne.</span><span class="sxs-lookup"><span data-stu-id="44cad-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="44cad-154">Dla każdego obowiązkowego argumentu atrybut powinien również dostarczyć odpowiadającą właściwość tylko do odczytu, dzięki której można pobrać wartość argumentu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="44cad-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="44cad-155">Atrybuty mogą też definiować argumenty opcjonalne, które są znane również jako argumenty nazwane.</span><span class="sxs-lookup"><span data-stu-id="44cad-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="44cad-156">Argumenty te są dostarczane do konstruktorów atrybutu poprzez nazwę i powinny mieć odpowiadającą właściwość umożliwiającą odczyt i zapis.</span><span class="sxs-lookup"><span data-stu-id="44cad-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="44cad-157">CA1021: Unikaj parametrów out</span><span class="sxs-lookup"><span data-stu-id="44cad-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="44cad-158">Przekazywanie typów przez odwołanie (używając out lub ref) wymaga doświadczenia w zakresie wskaźników, rozumienia różnicy między typami wartości i typami odwołania oraz umiejętności obsługi metod z wieloma wartościami zwracanymi.</span><span class="sxs-lookup"><span data-stu-id="44cad-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="44cad-159">Ponadto różnica między parametrami out i ref nie jest powszechnie zrozumiała.</span><span class="sxs-lookup"><span data-stu-id="44cad-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="44cad-160">CA1024: Używaj właściwości, o ile to możliwe</span><span class="sxs-lookup"><span data-stu-id="44cad-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="44cad-161">Metody publiczne lub chronione mają nazwę zaczynającą się od „Get”, nie posiadają parametrów i zwracają wartość, która nie jest tablicą.</span><span class="sxs-lookup"><span data-stu-id="44cad-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="44cad-162">Metoda ta może być dobrym kandydatem na właściwość.</span><span class="sxs-lookup"><span data-stu-id="44cad-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="44cad-163">CA1027: Oznacz typy wyliczeniowe atrybutem Flags</span><span class="sxs-lookup"><span data-stu-id="44cad-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="44cad-164">Wyliczenie to typ wartości, który definiuje zestaw powiązanych, nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="44cad-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="44cad-165">Zastosuj atrybut FlagsAttribute do wyliczenia, gdy jego stałe nazwane mogą zostać sensownie połączone.</span><span class="sxs-lookup"><span data-stu-id="44cad-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="44cad-166">CA1028: Magazyn typu wyliczeniowego powinien być typu Int32</span><span class="sxs-lookup"><span data-stu-id="44cad-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="44cad-167">Wyliczenie to typ wartości, który definiuje zestaw powiązanych, nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="44cad-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="44cad-168">Domyślnie typ danych System.Int32 jest używany do przechowywania wartości stałej.</span><span class="sxs-lookup"><span data-stu-id="44cad-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="44cad-169">Mimo że można zmienić ten typ podstawowy, nie jest to wymagane ani zalecane w przypadku większości scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="44cad-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="44cad-170">CA1030: Używaj zdarzeń, o ile to możliwe</span><span class="sxs-lookup"><span data-stu-id="44cad-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="44cad-171">Ta reguła wykrywa metody o nazwach, które normalnie mogą być używane dla zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="44cad-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="44cad-172">Jeśli metoda jest wywoływana w odpowiedzi na jasno określoną zmianę stanu, powinna ona zostać wywołana przez program obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="44cad-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="44cad-173">Obiekty, które wywołują tę metodę, powinny wywoływać zdarzenia, a nie bezpośrednio metodę.</span><span class="sxs-lookup"><span data-stu-id="44cad-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="44cad-174">CA1031: Nie przechwytuj typów wyjątków ogólnych</span><span class="sxs-lookup"><span data-stu-id="44cad-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="44cad-175">Ogólne wyjątki nie powinny być przechwytywane.</span><span class="sxs-lookup"><span data-stu-id="44cad-175">General exceptions should not be caught.</span></span> <span data-ttu-id="44cad-176">Przechwyć wyjątek bardziej szczegółowy lub ponownie Zgłoś wyjątek ogólny jako ostatnią instrukcję w bloku catch.</span><span class="sxs-lookup"><span data-stu-id="44cad-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="44cad-177">CA1032: Zaimplementuj standardowe konstruktory wyjątków</span><span class="sxs-lookup"><span data-stu-id="44cad-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="44cad-178">Niepowodzenie podczas dostarczenia pełnego zestawu konstruktorów może utrudnić poprawną obsługę wyjątków.</span><span class="sxs-lookup"><span data-stu-id="44cad-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="44cad-179">CA1033: Metody interfejsu powinny móc zostać wywołane przez typy podrzędne</span><span class="sxs-lookup"><span data-stu-id="44cad-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="44cad-180">Niezapieczętowany typ widoczny na zewnątrz zapewnia jawną implementację metody interfejsu publicznego i nie dostarcza alternatywnej metody widocznej z zewnątrz o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="44cad-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="44cad-181">CA1034: Typy zagnieżdżone nie powinny być widoczne</span><span class="sxs-lookup"><span data-stu-id="44cad-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="44cad-182">Typ zagnieżdżony to typ, który jest zadeklarowany wewnątrz zakresu innego typu.</span><span class="sxs-lookup"><span data-stu-id="44cad-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="44cad-183">Typy zagnieżdżone są przydatne w przypadku hermetyzacji szczegółów implementacji prywatnej typu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="44cad-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="44cad-184">Używane w tym celu typy zagnieżdżone nie powinny być widoczne na zewnątrz.</span><span class="sxs-lookup"><span data-stu-id="44cad-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="44cad-185">CA1036: Przesłaniaj metody porównywalnych typów</span><span class="sxs-lookup"><span data-stu-id="44cad-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="44cad-186">Typ publiczny lub chroniony implementuje interfejs System.IComparable.</span><span class="sxs-lookup"><span data-stu-id="44cad-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="44cad-187">Nie zastępuje on metody Object.Equals ani nie przeciąża specyficznego dla języka operatora równości, nierówności, mniejsze lub większe niż.</span><span class="sxs-lookup"><span data-stu-id="44cad-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="44cad-188">CA1040: Unikaj pustych interfejsów</span><span class="sxs-lookup"><span data-stu-id="44cad-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="44cad-189">Interfejsy definiują elementy członkowskie, które zapewniają zachowanie lub użycie kontraktu.</span><span class="sxs-lookup"><span data-stu-id="44cad-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="44cad-190">Funkcjonalność opisana przez interfejs może zostać przyjęta przez dowolny typ, niezależnie od tego, gdzie ten typ się pojawia w hierarchii dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="44cad-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="44cad-191">Typ implementuje interfejs, dostarczając implementacje dla jego elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="44cad-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="44cad-192">Pusty interfejs nie definiuje żadnych elementów członkowskich; dlatego też nie definiuje kontraktu, który można zaimplementować.</span><span class="sxs-lookup"><span data-stu-id="44cad-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="44cad-193">CA1041: Udostępnij komunikat ObsoleteAttribute</span><span class="sxs-lookup"><span data-stu-id="44cad-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="44cad-194">Typ lub element członkowski jest oznaczony za pomocą atrybutu System.ObsoleteAttribute, który nie ma określonej właściwości ObsoleteAttribute.Message.</span><span class="sxs-lookup"><span data-stu-id="44cad-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="44cad-195">Gdy jest kompilowany typ lub element członkowski, który jest oznaczony za pomocą ObsoleteAttribute, zostanie wyświetlona Właściwość Message dla atrybutu, który zawiera informacje o użytkowniku o nieaktualnym typie lub członku.</span><span class="sxs-lookup"><span data-stu-id="44cad-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="44cad-196">CA1043: Używaj argumentów typu liczba całkowita lub ciąg dla indeksatorów</span><span class="sxs-lookup"><span data-stu-id="44cad-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="44cad-197">Indeksatory (właściwości indeksowane) powinny używać dla indeksu typów całkowitych lub ciągu.</span><span class="sxs-lookup"><span data-stu-id="44cad-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="44cad-198">Typy te są zwykle używane do indeksowania struktur danych i zwiększają one użyteczność biblioteki.</span><span class="sxs-lookup"><span data-stu-id="44cad-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="44cad-199">Użycie typu Object powinno zostać ograniczone do przypadków, w których nie może zostać określony typ całkowity lub ciąg w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="44cad-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="44cad-200">CA1044: Właściwości nie powinny być tylko do zapisu</span><span class="sxs-lookup"><span data-stu-id="44cad-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="44cad-201">Chociaż posiadanie właściwości tylko do odczytu jest dopuszczalne i często konieczne, wytyczne projektowania zabraniają używania właściwości tylko do zapisu.</span><span class="sxs-lookup"><span data-stu-id="44cad-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="44cad-202">Dzieje się tak dlatego, że umożliwienie użytkownikowi ustawienia wartości, a następnie uniemożliwianie przeglądania tej wartości nie zapewnia żadnych zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="44cad-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="44cad-203">Poza tym bez dostępu do odczytu nie można przeglądać stanu obiektów udostępnionych, co ogranicza ich przydatność.</span><span class="sxs-lookup"><span data-stu-id="44cad-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="44cad-204">CA1045: Nie przekazuj typów przez odwołanie</span><span class="sxs-lookup"><span data-stu-id="44cad-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="44cad-205">Przekazywanie typów przez odwołanie (używając out lub ref) wymaga doświadczenia w zakresie wskaźników, rozumienia różnicy między typami wartości i typami odwołania oraz umiejętności obsługi metod z wieloma wartościami zwracanymi.</span><span class="sxs-lookup"><span data-stu-id="44cad-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="44cad-206">Architekci biblioteki, którzy tworzą dla wszystkich, nie powinni oczekiwać od użytkowników dobrej znajomości parametrów out lub ref.</span><span class="sxs-lookup"><span data-stu-id="44cad-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="44cad-207">CA1046: Nie przeciążaj operatora równości w typach referencyjnych</span><span class="sxs-lookup"><span data-stu-id="44cad-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="44cad-208">Dla typów odwołań domyślna implementacja operatora równości jest prawie zawsze poprawna.</span><span class="sxs-lookup"><span data-stu-id="44cad-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="44cad-209">Domyślnie dwa odwołania są równe tylko wtedy, gdy wskazują ten sam obiekt.</span><span class="sxs-lookup"><span data-stu-id="44cad-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="44cad-210">CA1047: Nie deklaruj chronionych składowych w typach zapieczętowanych</span><span class="sxs-lookup"><span data-stu-id="44cad-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="44cad-211">Chronione elementy członkowskie są zadeklarowane w typach tak, aby typy dziedziczące miały dostęp do elementu członkowskiego i mogły go zastąpić.</span><span class="sxs-lookup"><span data-stu-id="44cad-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="44cad-212">Z definicji po typach zapieczętowanych nie można dziedziczyć, co oznacza, że nie można wywołać metody chronionej na typach zapieczętowanych.</span><span class="sxs-lookup"><span data-stu-id="44cad-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="44cad-213">CA1050: Deklaruj typy w przestrzeniach nazw</span><span class="sxs-lookup"><span data-stu-id="44cad-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="44cad-214">Typy są zadeklarowane w przestrzeniach nazw, aby zapobiec kolizjom nazw oraz jako sposób organizowania typów powiązanych w hierarchii obiektów.</span><span class="sxs-lookup"><span data-stu-id="44cad-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="44cad-215">CA1051: Nie deklaruj widocznych pól w wystąpieniach</span><span class="sxs-lookup"><span data-stu-id="44cad-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="44cad-216">Głównym zastosowaniem pola powinno być to, co szczegółowo opisuje implementacja.</span><span class="sxs-lookup"><span data-stu-id="44cad-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="44cad-217">Pola powinny być prywatne lub wewnętrzne i dostępne przy użyciu właściwości.</span><span class="sxs-lookup"><span data-stu-id="44cad-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="44cad-218">CA1052: Statyczne typy przechowujące powinny być zapieczętowane</span><span class="sxs-lookup"><span data-stu-id="44cad-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="44cad-219">Typ publiczny lub chroniony zawiera tylko statyczne elementy członkowskie i nie jest deklarowany za pomocą modyfikatora sealed (C#) lub NotInheritable (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44cad-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="44cad-220">Typ, po którym nie będzie dziedziczenia, powinien być oznakowany przy użyciu modyfikatora sealed, aby zapobiec użyciu go jako typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="44cad-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="44cad-221">CA1053: Statyczne typy przechowujące nie powinny mieć konstruktorów</span><span class="sxs-lookup"><span data-stu-id="44cad-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="44cad-222">Typ publiczny lub publiczny zagnieżdżony deklaruje tylko statyczne elementy członkowskie i ma publiczny lub chroniony konstruktor domyślny.</span><span class="sxs-lookup"><span data-stu-id="44cad-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="44cad-223">Konstruktor jest zbędny, ponieważ wywołanie statycznego elementu członkowskiego nie wymaga wystąpienia tego typu.</span><span class="sxs-lookup"><span data-stu-id="44cad-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="44cad-224">Przeciążenie typu ciąg powinno wywoływać, dla bezpieczeństwa, przeciążenie jednolitego identyfikatora zasobów (URI) przy użyciu argumentu typu ciąg.</span><span class="sxs-lookup"><span data-stu-id="44cad-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="44cad-225">CA1054: Parametry identyfikatora URI nie powinny być ciągami</span><span class="sxs-lookup"><span data-stu-id="44cad-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="44cad-226">Jeśli metoda pobiera reprezentację ciągu identyfikatora URI, powinno zostać dostarczone odpowiadające przeciążenie, pobierające wystąpienie klasy URI, które dostarcza te usługi w bezpieczny sposób.</span><span class="sxs-lookup"><span data-stu-id="44cad-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="44cad-227">CA1055: Wartości zwracane identyfikatora URI nie powinny być ciągami</span><span class="sxs-lookup"><span data-stu-id="44cad-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="44cad-228">Reguła ta zakłada, że metoda zwraca identyfikator URI.</span><span class="sxs-lookup"><span data-stu-id="44cad-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="44cad-229">Reprezentacja ciągu identyfikatora URI jest podatna na analizowanie i kodowanie błędów i może prowadzić do powstawania luk w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="44cad-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="44cad-230">Klasa System.Uri udostępnia te usługi w bezpieczny sposób.</span><span class="sxs-lookup"><span data-stu-id="44cad-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="44cad-231">CA1056: Właściwości identyfikatora URI nie powinny być ciągami</span><span class="sxs-lookup"><span data-stu-id="44cad-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="44cad-232">Ta reguła zakłada, że właściwość reprezentuje identyfikator URI.</span><span class="sxs-lookup"><span data-stu-id="44cad-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="44cad-233">Reprezentacja ciągu identyfikatora URI jest podatna na analizowanie i kodowanie błędów i może prowadzić do powstawania luk w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="44cad-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="44cad-234">Klasa System.Uri udostępnia te usługi w bezpieczny sposób.</span><span class="sxs-lookup"><span data-stu-id="44cad-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="44cad-235">CA1058: Typy nie powinny rozszerzać niektórych typów podstawowych</span><span class="sxs-lookup"><span data-stu-id="44cad-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="44cad-236">Typ widoczny na zewnątrz rozszerza niektóre typy podstawowe.</span><span class="sxs-lookup"><span data-stu-id="44cad-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="44cad-237">Użyj jednej z alternatyw.</span><span class="sxs-lookup"><span data-stu-id="44cad-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="44cad-238">CA1060: Przenieś P/Invoke do klasy NativeMethods</span><span class="sxs-lookup"><span data-stu-id="44cad-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="44cad-239">Metody wywołania platformy, takie jak te oznaczone przy <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> użyciu metody lub, zdefiniowane za pomocą słowa kluczowego Declare w Visual Basic, uzyskują dostęp do kodu niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="44cad-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="44cad-240">Metody te powinny być klasami NativeMethods, SafeNativeMethods lub UnsafeNativeMethods.</span><span class="sxs-lookup"><span data-stu-id="44cad-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="44cad-241">CA1061: Nie ukrywaj metod klasy bazowej</span><span class="sxs-lookup"><span data-stu-id="44cad-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="44cad-242">Metoda w typie podstawowym jest ukryta przez metodę o identycznej nazwie typu pochodnego, gdy sygnatura parametru metody pochodnej różni się tylko typami, które są słabiej dziedziczone niż odpowiadające typy w sygnaturze parametru metody podstawowej.</span><span class="sxs-lookup"><span data-stu-id="44cad-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="44cad-243">CA1062: Waliduj argumenty metod publicznych</span><span class="sxs-lookup"><span data-stu-id="44cad-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="44cad-244">Wszystkie argumenty odwołania, które są przekazywane do metody widocznej na zewnątrz, powinny być sprawdzane pod kątem wartości null.</span><span class="sxs-lookup"><span data-stu-id="44cad-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="44cad-245">CA1063: Poprawnie zaimplementuj interfejs IDisposable</span><span class="sxs-lookup"><span data-stu-id="44cad-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="44cad-246">Wszystkie typy IDisposable powinny poprawnie implementować wzorzec Dispose.</span><span class="sxs-lookup"><span data-stu-id="44cad-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="44cad-247">CA1064: Wyjątki powinny być publiczne</span><span class="sxs-lookup"><span data-stu-id="44cad-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="44cad-248">Wyjątek wewnętrzny jest widoczny tylko wewnątrz własnego zakresu wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="44cad-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="44cad-249">W przypadku wystąpienia wyjątku poza zakresem wewnętrznym tylko wyjątek podstawowy może zostać użyty do jego przechwycenia.</span><span class="sxs-lookup"><span data-stu-id="44cad-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="44cad-250">Jeśli wewnętrzny wyjątek jest Dziedziczony z <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> , lub <xref:System.ApplicationException?displayProperty=fullName> , kod zewnętrzny nie będzie zawierał wystarczających informacji, aby dowiedzieć się, co należy zrobić z wyjątkiem.</span><span class="sxs-lookup"><span data-stu-id="44cad-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="44cad-251">CA1065: Nie wywołuj wyjątków w nieoczekiwanych lokalizacjach</span><span class="sxs-lookup"><span data-stu-id="44cad-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="44cad-252">Metoda, od której nie oczekiwano zgłaszania wyjątków, zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="44cad-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="44cad-253">CA1066: Zaimplementuj interfejs IEquatable przy przesłanianiu metody Equals</span><span class="sxs-lookup"><span data-stu-id="44cad-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="44cad-254">Typ wartości przesłania <xref:System.Object.Equals%2A> metodę, ale nie implementuje <xref:System.IEquatable%601> .</span><span class="sxs-lookup"><span data-stu-id="44cad-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="44cad-255">CA1067: Przesłoń metodę Equals podczas implementowania interfejsu IEquatable</span><span class="sxs-lookup"><span data-stu-id="44cad-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="44cad-256">Typ implementuje <xref:System.IEquatable%601> , ale nie przesłania <xref:System.Object.Equals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="44cad-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="44cad-257">CA1068: Parametry CancellationToken muszą występować na końcu</span><span class="sxs-lookup"><span data-stu-id="44cad-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="44cad-258">Metoda ma parametr CancellationToken, który nie jest ostatnim parametrem.</span><span class="sxs-lookup"><span data-stu-id="44cad-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="44cad-259">CA1069: Wyliczenia nie powinny mieć zduplikowanych wartości</span><span class="sxs-lookup"><span data-stu-id="44cad-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="44cad-260">Wyliczenie ma wiele elementów członkowskich, do których jawnie przypisano tę samą stałą wartość.</span><span class="sxs-lookup"><span data-stu-id="44cad-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="44cad-261">CA1070: Nie deklaruj pól zdarzeń jako wirtualnych</span><span class="sxs-lookup"><span data-stu-id="44cad-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="44cad-262">[Zdarzenie podobne do pola](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) zostało zadeklarowane jako wirtualne.</span><span class="sxs-lookup"><span data-stu-id="44cad-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
