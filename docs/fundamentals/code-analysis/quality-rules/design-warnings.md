---
title: Reguły projektowania (analiza kodu)
description: Poznaj reguły projektowania analizy kodu.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 7b49403b1aa3d48008e6f7448ab0ed5a84468373
ms.sourcegitcommit: 45c7148f2483db2501c1aa696ab6ed2ed8cb71b2
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/08/2020
ms.locfileid: "96851532"
---
# <a name="design-rules"></a>Reguły projektowania

Reguły projektowania obsługują przestrzeganie [wytycznych dotyczących projektowania .NET Framework](../../../standard/design-guidelines/index.md).

## <a name="in-this-section"></a>W tej sekcji

| Reguła | Opis |
| - | - |
| [CA1000: Nie deklaruj statycznych składowych na typach ogólnych](ca1000.md) | Po wywołaniu statycznego elementu członkowskiego typu ogólnego dla typu trzeba określić argument typu. Po wywołaniu wystąpienia ogólnego elementu członkowskiego, które nie obsługuje wnioskowania, dla elementu członkowskiego musi zostać określony argument typu. W tych dwóch przypadkach składnia określająca argument typu jest różna i łatwo o pomyłkę. |
| [CA1001: Typy, do których należą pola możliwe do likwidacji, powinny być możliwe do likwidacji](ca1001.md) | Klasa deklaruje i implementuje pole wystąpienia, które jest typem system. IDisposable, a Klasa nie implementuje interfejsu IDisposable. Klasa, która deklaruje pole IDisposable, pośrednio posiada niezarządzany zasób i powinna implementować interfejs IDisposable. |
| [CA1002: Nie uwidaczniaj list ogólnych](ca1002.md) | System. Collections. Generic. list< (of \<(T> ) >) to ogólna kolekcja, która została zaprojektowana pod kątem wydajności, a nie dziedziczenia. Dlatego też lista nie zawiera wirtualnych elementów członkowskich. Zamiast powyższych powinny zostać zastosowane kolekcje ogólne, zaprojektowane do obsługi dziedziczenia. |
| [CA1003: Użyj ogólnych wystąpień procedury obsługi zdarzeń](ca1003.md) | Typ zawiera delegata zwracającego wartość void, którego sygnatura zawiera dwa parametry (pierwszy obiekt i drugi typ, który można przypisać do EventArgs), oraz element docelowy zawierający zestaw .NET Framework 2,0. |
| [CA1005: Unikaj nadmiernego użycia parametrów w typach ogólnych](ca1005.md) | Im więcej parametrów typu zawiera typ ogólny, tym trudniej poznać i zapamiętać, co reprezentuje każdy z nich. Zwykle jest oczywiste z jednym parametrem typu, jak na liście \<T> , a w niektórych przypadkach z dwoma parametrami typu, jak w słowniku \<TKey, TValue> . Jeśli jednak istnieją więcej niż dwa parametry typu, poziom trudności staje się zbyt wysoki dla większości użytkowników. |
| [CA1008: Typy wyliczeniowe powinny mieć wartość zero](ca1008.md) | Wartość domyślna niezainicjowanego typu wyliczeniowego, podobnie jak inne typy wartości, wynosi zero. Wyliczenie atrybutów bez flag powinno definiować składową przy użyciu wartości zero, aby wartość domyślna była prawidłową wartością wyliczenia. Jeśli wyliczenie, w którym zastosowano atrybut FlagsAttribute, definiuje element członkowski o wartości zero, powinno być nazwane „Brak”, aby wskazać, że żadne wartości nie zostały ustawione w wyliczeniu. |
| [CA1010: Kolekcje powinny implementować interfejs ogólny](ca1010.md) | Aby poszerzyć użyteczność kolekcji, zaimplementuj jeden z interfejsów kolekcji generycznej. Następnie kolekcja może zostać użyta, aby wypełnić typy generyczne kolekcji. |
| [CA1012: Typy abstrakcyjne nie powinny mieć konstruktorów](ca1012.md) | Konstruktory dla typów abstrakcyjnych mogą być wywoływane tylko przez typy pochodne. Ze względu na to, że publiczne konstruktory tworzą wystąpienia typu, a nie można utworzyć wystąpienia typu abstrakcyjnego, publiczny konstruktor typu abstrakcyjnego został niepoprawnie zaprojektowany. |
| [CA1014: Oznacz zestawy atrybutem CLSCompliant](ca1014.md) | The Common Language Specification (CLS) definiuje ograniczenia nazw, typów danych i reguł, z którymi muszą być zgodne zestawy, jeśli zostaną użyte w językach programowania. Dobry projekt wymusza, że wszystkie zestawy jawnie wskazują zgodność ze specyfikacją CLS przy użyciu CLSCompliantAttribute. Jeśli ten atrybut nie jest obecny w zestawie, oznacza to, że zestaw jest niezgodny. |
| [CA1016: Oznacz zestawy atrybutem AssemblyVersion](ca1016.md) | Platforma .NET używa numeru wersji do unikatowego identyfikowania zestawu i powiązania z typami w zestawach o silnej nazwie. Numer wersji jest używany razem z zasadami wersji i wydawcy. Domyślnie aplikacje są uruchamiane tylko z wersji zestawu, z którego zostały zbudowane. |
| [CA1017: Oznacz zestawy atrybutem ComVisibleAttribute](ca1017.md) | ComVisibleAttribute określa, w jaki sposób klienci COM otrzymują dostęp do kodu zarządzanego. Zasada dobrego projektowania nakazuje, aby zestawy jawnie wskazywały widoczność COM. Widoczność COM można ustawić dla całego zestawu, a następnie zastąpić dla poszczególnych typów i elementów członkowskich typu. Jeśli ten atrybut jest nieobecny, zawartość zestawu jest widoczna dla klientów COM. |
| [CA1018: Oznacz atrybuty atrybutem AttributeUsage](ca1018.md) | Podczas definiowania atrybutu niestandardowego należy go oznaczyć przy użyciu elementu AttributeUsageAttribute, aby wskazać, w którym miejscu kodu źródłowego ma być on zastosowany. Znaczenie i zamierzone użycie atrybutu określi jego prawidłowe lokalizacje w kodzie. |
| [CA1019: Zdefiniuj metody dostępu dla argumentów atrybutów](ca1019.md) | Atrybuty mogą definiować obowiązkowe argumenty, które trzeba określić, aby móc zastosować atrybut do obiektu docelowego. Znane są również jako argumenty pozycyjne, ponieważ są one dostarczane do konstruktorów atrybutu jako parametry pozycyjne. Dla każdego obowiązkowego argumentu atrybut powinien również dostarczyć odpowiadającą właściwość tylko do odczytu, dzięki której można pobrać wartość argumentu w czasie wykonywania. Atrybuty mogą też definiować argumenty opcjonalne, które są znane również jako argumenty nazwane. Argumenty te są dostarczane do konstruktorów atrybutu poprzez nazwę i powinny mieć odpowiadającą właściwość umożliwiającą odczyt i zapis. |
| [CA1021: Unikaj parametrów out](ca1021.md) | Przekazywanie typów przez odwołanie (używając out lub ref) wymaga doświadczenia w zakresie wskaźników, rozumienia różnicy między typami wartości i typami odwołania oraz umiejętności obsługi metod z wieloma wartościami zwracanymi. Ponadto różnica między parametrami out i ref nie jest powszechnie zrozumiała. |
| [CA1024: Używaj właściwości, o ile to możliwe](ca1024.md) | Metody publiczne lub chronione mają nazwę zaczynającą się od „Get”, nie posiadają parametrów i zwracają wartość, która nie jest tablicą. Metoda ta może być dobrym kandydatem na właściwość. |
| [CA1027: Oznacz typy wyliczeniowe atrybutem Flags](ca1027.md) | Wyliczenie to typ wartości, który definiuje zestaw powiązanych, nazwanych stałych. Zastosuj atrybut FlagsAttribute do wyliczenia, gdy jego stałe nazwane mogą zostać sensownie połączone. |
| [CA1028: Magazyn typu wyliczeniowego powinien być typu Int32](ca1028.md) | Wyliczenie to typ wartości, który definiuje zestaw powiązanych, nazwanych stałych. Domyślnie typ danych System.Int32 jest używany do przechowywania wartości stałej. Mimo że można zmienić ten typ podstawowy, nie jest to wymagane ani zalecane w przypadku większości scenariuszy. |
| [CA1030: Używaj zdarzeń, o ile to możliwe](ca1030.md) | Ta reguła wykrywa metody o nazwach, które normalnie mogą być używane dla zdarzeń. Jeśli metoda jest wywoływana w odpowiedzi na jasno określoną zmianę stanu, powinna ona zostać wywołana przez program obsługi zdarzeń. Obiekty, które wywołują tę metodę, powinny wywoływać zdarzenia, a nie bezpośrednio metodę. |
| [CA1031: Nie przechwytuj typów wyjątków ogólnych](ca1031.md) | Ogólne wyjątki nie powinny być przechwytywane. Przechwyć wyjątek bardziej szczegółowy lub ponownie Zgłoś wyjątek ogólny jako ostatnią instrukcję w bloku catch. |
| [CA1032: Zaimplementuj standardowe konstruktory wyjątków](ca1032.md) | Niepowodzenie podczas dostarczenia pełnego zestawu konstruktorów może utrudnić poprawną obsługę wyjątków. |
| [CA1033: Metody interfejsu powinny móc zostać wywołane przez typy podrzędne](ca1033.md) | Niezapieczętowany typ widoczny na zewnątrz zapewnia jawną implementację metody interfejsu publicznego i nie dostarcza alternatywnej metody widocznej z zewnątrz o tej samej nazwie. |
| [CA1034: Typy zagnieżdżone nie powinny być widoczne](ca1034.md) | Typ zagnieżdżony to typ, który jest zadeklarowany wewnątrz zakresu innego typu. Typy zagnieżdżone są przydatne w przypadku hermetyzacji szczegółów implementacji prywatnej typu zawierającego. Używane w tym celu typy zagnieżdżone nie powinny być widoczne na zewnątrz. |
| [CA1036: Przesłaniaj metody porównywalnych typów](ca1036.md) | Typ publiczny lub chroniony implementuje interfejs System.IComparable. Nie zastępuje on metody Object.Equals ani nie przeciąża specyficznego dla języka operatora równości, nierówności, mniejsze lub większe niż. |
| [CA1040: Unikaj pustych interfejsów](ca1040.md) | Interfejsy definiują elementy członkowskie, które zapewniają zachowanie lub użycie kontraktu. Funkcjonalność opisana przez interfejs może zostać przyjęta przez dowolny typ, niezależnie od tego, gdzie ten typ się pojawia w hierarchii dziedziczenia. Typ implementuje interfejs, dostarczając implementacje dla jego elementów członkowskich. Pusty interfejs nie definiuje żadnych elementów członkowskich; dlatego też nie definiuje kontraktu, który można zaimplementować. |
| [CA1041: Udostępnij komunikat ObsoleteAttribute](ca1041.md) | Typ lub element członkowski jest oznaczony za pomocą atrybutu System.ObsoleteAttribute, który nie ma określonej właściwości ObsoleteAttribute.Message. Gdy jest kompilowany typ lub element członkowski, który jest oznaczony za pomocą ObsoleteAttribute, zostanie wyświetlona Właściwość Message dla atrybutu, który zawiera informacje o użytkowniku o nieaktualnym typie lub członku. |
| [CA1043: Używaj argumentów typu liczba całkowita lub ciąg dla indeksatorów](ca1043.md) | Indeksatory (właściwości indeksowane) powinny używać dla indeksu typów całkowitych lub ciągu. Typy te są zwykle używane do indeksowania struktur danych i zwiększają one użyteczność biblioteki. Użycie typu Object powinno zostać ograniczone do przypadków, w których nie może zostać określony typ całkowity lub ciąg w czasie projektowania. |
| [CA1044: Właściwości nie powinny być tylko do zapisu](ca1044.md) | Chociaż posiadanie właściwości tylko do odczytu jest dopuszczalne i często konieczne, wytyczne projektowania zabraniają używania właściwości tylko do zapisu. Dzieje się tak dlatego, że umożliwienie użytkownikowi ustawienia wartości, a następnie uniemożliwianie przeglądania tej wartości nie zapewnia żadnych zabezpieczeń. Poza tym bez dostępu do odczytu nie można przeglądać stanu obiektów udostępnionych, co ogranicza ich przydatność. |
| [CA1045: Nie przekazuj typów przez odwołanie](ca1045.md) | Przekazywanie typów przez odwołanie (używając out lub ref) wymaga doświadczenia w zakresie wskaźników, rozumienia różnicy między typami wartości i typami odwołania oraz umiejętności obsługi metod z wieloma wartościami zwracanymi. Architekci biblioteki, którzy tworzą dla wszystkich, nie powinni oczekiwać od użytkowników dobrej znajomości parametrów out lub ref. |
| [CA1046: Nie przeciążaj operatora równości w typach referencyjnych](ca1046.md) | Dla typów odwołań domyślna implementacja operatora równości jest prawie zawsze poprawna. Domyślnie dwa odwołania są równe tylko wtedy, gdy wskazują ten sam obiekt. |
| [CA1047: Nie deklaruj chronionych składowych w typach zapieczętowanych](ca1047.md) | Chronione elementy członkowskie są zadeklarowane w typach tak, aby typy dziedziczące miały dostęp do elementu członkowskiego i mogły go zastąpić. Z definicji po typach zapieczętowanych nie można dziedziczyć, co oznacza, że nie można wywołać metody chronionej na typach zapieczętowanych. |
| [CA1050: Deklaruj typy w przestrzeniach nazw](ca1050.md) | Typy są zadeklarowane w przestrzeniach nazw, aby zapobiec kolizjom nazw oraz jako sposób organizowania typów powiązanych w hierarchii obiektów. |
| [CA1051: Nie deklaruj widocznych pól w wystąpieniach](ca1051.md) | Głównym zastosowaniem pola powinno być to, co szczegółowo opisuje implementacja. Pola powinny być prywatne lub wewnętrzne i dostępne przy użyciu właściwości. |
| [CA1052: Statyczne typy przechowujące powinny być zapieczętowane](ca1052.md) | Typ publiczny lub chroniony zawiera tylko statyczne elementy członkowskie i nie jest deklarowany za pomocą modyfikatora sealed (C#) lub NotInheritable (Visual Basic). Typ, po którym nie będzie dziedziczenia, powinien być oznakowany przy użyciu modyfikatora sealed, aby zapobiec użyciu go jako typu podstawowego. |
| [CA1053: Statyczne typy przechowujące nie powinny mieć konstruktorów](ca1053.md) | Typ publiczny lub publiczny zagnieżdżony deklaruje tylko statyczne elementy członkowskie i ma publiczny lub chroniony konstruktor domyślny. Konstruktor jest zbędny, ponieważ wywołanie statycznego elementu członkowskiego nie wymaga wystąpienia tego typu. Przeciążenie typu ciąg powinno wywoływać, dla bezpieczeństwa, przeciążenie jednolitego identyfikatora zasobów (URI) przy użyciu argumentu typu ciąg. |
| [CA1054: Parametry identyfikatora URI nie powinny być ciągami](ca1054.md) | Jeśli metoda pobiera reprezentację ciągu identyfikatora URI, powinno zostać dostarczone odpowiadające przeciążenie, pobierające wystąpienie klasy URI, które dostarcza te usługi w bezpieczny sposób. |
| [CA1055: Wartości zwracane identyfikatora URI nie powinny być ciągami](ca1055.md) | Reguła ta zakłada, że metoda zwraca identyfikator URI. Reprezentacja ciągu identyfikatora URI jest podatna na analizowanie i kodowanie błędów i może prowadzić do powstawania luk w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób. |
| [CA1056: Właściwości identyfikatora URI nie powinny być ciągami](ca1056.md) | Ta reguła zakłada, że właściwość reprezentuje identyfikator URI. Reprezentacja ciągu identyfikatora URI jest podatna na analizowanie i kodowanie błędów i może prowadzić do powstawania luk w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób. |
| [CA1058: Typy nie powinny rozszerzać niektórych typów podstawowych](ca1058.md) | Typ widoczny na zewnątrz rozszerza niektóre typy podstawowe. Użyj jednej z alternatyw. |
| [CA1060: Przenieś P/Invoke do klasy NativeMethods](ca1060.md) | Metody wywołania platformy, takie jak te oznaczone przy <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> użyciu metody lub, zdefiniowane za pomocą słowa kluczowego Declare w Visual Basic, uzyskują dostęp do kodu niezarządzanego. Metody te powinny być klasami NativeMethods, SafeNativeMethods lub UnsafeNativeMethods. |
| [CA1061: Nie ukrywaj metod klasy bazowej](ca1061.md) | Metoda w typie podstawowym jest ukryta przez metodę o identycznej nazwie typu pochodnego, gdy sygnatura parametru metody pochodnej różni się tylko typami, które są słabiej dziedziczone niż odpowiadające typy w sygnaturze parametru metody podstawowej. |
| [CA1062: Waliduj argumenty metod publicznych](ca1062.md) | Wszystkie argumenty odwołania, które są przekazywane do metody widocznej na zewnątrz, powinny być sprawdzane pod kątem wartości null. |
| [CA1063: Poprawnie zaimplementuj interfejs IDisposable](ca1063.md) | Wszystkie typy IDisposable powinny poprawnie implementować wzorzec Dispose. |
| [CA1064: Wyjątki powinny być publiczne](ca1064.md) | Wyjątek wewnętrzny jest widoczny tylko wewnątrz własnego zakresu wewnętrznego. W przypadku wystąpienia wyjątku poza zakresem wewnętrznym tylko wyjątek podstawowy może zostać użyty do jego przechwycenia. Jeśli wewnętrzny wyjątek jest Dziedziczony z <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> , lub <xref:System.ApplicationException?displayProperty=fullName> , kod zewnętrzny nie będzie zawierał wystarczających informacji, aby dowiedzieć się, co należy zrobić z wyjątkiem. |
| [CA1065: Nie wywołuj wyjątków w nieoczekiwanych lokalizacjach](ca1065.md) | Metoda, od której nie oczekiwano zgłaszania wyjątków, zgłasza wyjątek. |
| [CA1066: Zaimplementuj interfejs IEquatable przy przesłanianiu metody Equals](ca1066.md) | Typ wartości przesłania <xref:System.Object.Equals%2A> metodę, ale nie implementuje <xref:System.IEquatable%601> . |
| [CA1067: Przesłoń metodę Equals podczas implementowania interfejsu IEquatable](ca1067.md) | Typ implementuje <xref:System.IEquatable%601> , ale nie przesłania <xref:System.Object.Equals%2A> metody. |
| [CA1068: Parametry CancellationToken muszą występować na końcu](ca1068.md) | Metoda ma parametr CancellationToken, który nie jest ostatnim parametrem. |
| [CA1069: Wyliczenia nie powinny mieć zduplikowanych wartości](ca1069.md) | Wyliczenie ma wiele elementów członkowskich, do których jawnie przypisano tę samą stałą wartość. |
| [CA1070: Nie deklaruj pól zdarzeń jako wirtualnych](ca1070.md) | [Zdarzenie podobne do pola](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) zostało zadeklarowane jako wirtualne. |
| [CA1071: Przesłoń bazę. Równa się podczas implementowania IEquatable](ca1071.md) | Typ pochodny implementuje <xref:System.IEquatable%601> , ale nie przesłania metody klasy bazowej <xref:System.IEquatable%601.Equals%2A> . |
