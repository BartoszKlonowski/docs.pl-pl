---
title: Reguły wydajności (analiza kodu)
description: Poznaj reguły wydajności analizy kodu.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/25/2020
ms.locfileid: "96586956"
---
# <a name="performance-rules"></a><span data-ttu-id="e0c57-103">Reguły wydajności</span><span class="sxs-lookup"><span data-stu-id="e0c57-103">Performance rules</span></span>

<span data-ttu-id="e0c57-104">Reguły wydajności obsługują biblioteki i aplikacje o wysokiej wydajności.</span><span class="sxs-lookup"><span data-stu-id="e0c57-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="e0c57-105">W tej sekcji</span><span class="sxs-lookup"><span data-stu-id="e0c57-105">In this section</span></span>

| <span data-ttu-id="e0c57-106">Reguła</span><span class="sxs-lookup"><span data-stu-id="e0c57-106">Rule</span></span> | <span data-ttu-id="e0c57-107">Opis</span><span class="sxs-lookup"><span data-stu-id="e0c57-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="e0c57-108">CA1802: Używaj literałów w odpowiednich miejscach</span><span class="sxs-lookup"><span data-stu-id="e0c57-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="e0c57-109">Pole jest zadeklarowane jako static i tylko do odczytu (Shared i ReadOnly w Visual Basic) i jest inicjowane z wartością, która jest obliczanej w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="e0c57-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="e0c57-110">Ponieważ wartość przypisana do pola Target jest obliczanej w czasie kompilacji, należy zmienić deklarację na wartość const (const w Visual Basic), tak aby była obliczana w czasie kompilacji, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="e0c57-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="e0c57-111">CA1805: Nie inicjuj niepotrzebnie</span><span class="sxs-lookup"><span data-stu-id="e0c57-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="e0c57-112">Środowisko uruchomieniowe platformy .NET inicjuje wszystkie pola typów odwołań do ich wartości domyślnych przed uruchomieniem konstruktora.</span><span class="sxs-lookup"><span data-stu-id="e0c57-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="e0c57-113">W większości przypadków jawne zainicjowanie pola do jego wartości domyślnej jest nadmiarowe, co zwiększa koszty konserwacji i może obniżyć wydajność (na przykład większy rozmiar zestawu).</span><span class="sxs-lookup"><span data-stu-id="e0c57-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="e0c57-114">CA1806: Nie ignoruj wyników metod</span><span class="sxs-lookup"><span data-stu-id="e0c57-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="e0c57-115">Nowy obiekt jest tworzony, ale nigdy nie jest używany lub metoda, która tworzy i zwraca nowy ciąg, jest wywoływana, a nowy ciąg nigdy nie jest używany lub metoda Component Object Model (COM) lub P/Invoke zwraca wynik HRESULT lub kod błędu, który nigdy nie jest używany.</span><span class="sxs-lookup"><span data-stu-id="e0c57-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="e0c57-116">CA1810: Inicjuj pola statyczne typu referencyjnego śródwierszowo</span><span class="sxs-lookup"><span data-stu-id="e0c57-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="e0c57-117">Podczas gdy typ deklaruje jawny, statyczny konstruktor, kompilator just in time (JIT) do każdej metody statycznej dodaje sprawdzenie i konstruktora wystąpienia, aby upewnić się, że konstruktor statyczny został wcześniej wywołany.</span><span class="sxs-lookup"><span data-stu-id="e0c57-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="e0c57-118">Sprawdzenia konstruktora statycznego mogą obniżyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="e0c57-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="e0c57-119">CA1812: Unikaj klas wewnętrznych bez wystąpień</span><span class="sxs-lookup"><span data-stu-id="e0c57-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="e0c57-120">Wystąpienie typu na poziomie zestawu nie jest tworzone przez kod w zestawie.</span><span class="sxs-lookup"><span data-stu-id="e0c57-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="e0c57-121">CA1813: Unikaj niezapieczętowanych atrybutów</span><span class="sxs-lookup"><span data-stu-id="e0c57-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="e0c57-122">.NET oferuje metody pobierania atrybutów niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="e0c57-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="e0c57-123">Domyślnie te metody wyszukują hierarchie dziedziczenia atrybutu.</span><span class="sxs-lookup"><span data-stu-id="e0c57-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="e0c57-124">Plombowanie atrybutu eliminuje wyszukiwanie przez hierarchię dziedziczenia i może zwiększyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="e0c57-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="e0c57-125">CA1814: Wybieraj tablice nieregularne zamiast wielowymiarowych</span><span class="sxs-lookup"><span data-stu-id="e0c57-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="e0c57-126">Nieregularna tablica to ta, której elementy są tablicami.</span><span class="sxs-lookup"><span data-stu-id="e0c57-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="e0c57-127">Tablice, które składają się na elementy, mogą mieć różne rozmiary, co może spowodować mniejsze ilości wolnego miejsca dla niektórych zestawów danych.</span><span class="sxs-lookup"><span data-stu-id="e0c57-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="e0c57-128">CA1815: Przesłaniaj metodę equals i operator równości w typach wartości</span><span class="sxs-lookup"><span data-stu-id="e0c57-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="e0c57-129">Dla typów wartości dziedziczona implementacja operatora Equas wykorzystuje bibliotekę odbić i porównuje zawartość wszystkich pól.</span><span class="sxs-lookup"><span data-stu-id="e0c57-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="e0c57-130">Odbicie jest obliczeniowo kosztowne, a porównanie równości każdego pola może być niepotrzebne.</span><span class="sxs-lookup"><span data-stu-id="e0c57-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="e0c57-131">Jeśli można się spodziewać, że użytkownicy będą porównywać lub sortować wystąpienia lub używać wystąpień jako kluczy tabel haszowanych, typ wartości powinien implementować Equals.</span><span class="sxs-lookup"><span data-stu-id="e0c57-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="e0c57-132">CA1819: Właściwości nie powinny zwracać tablic</span><span class="sxs-lookup"><span data-stu-id="e0c57-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="e0c57-133">Tablice zwracane przez właściwości nie są chronione przed zapisem, nawet jeśli właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="e0c57-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="e0c57-134">Aby zachować tablicę odporną na manipulacje, właściwość musi zwracać kopię tablicy.</span><span class="sxs-lookup"><span data-stu-id="e0c57-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="e0c57-135">Zwykle użytkownicy nie rozumieją, jakie niekorzystne następstwa dla wydajności ma wywołanie takiej właściwości.</span><span class="sxs-lookup"><span data-stu-id="e0c57-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="e0c57-136">CA1820: Testuj obecność pustych ciągów przy użyciu długości ciągu</span><span class="sxs-lookup"><span data-stu-id="e0c57-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="e0c57-137">Porównywanie ciągów za pomocą właściwości String.Length lub metody String.IsNullOrEmpty jest znacznie szybsze niż użycie operatora Equals.</span><span class="sxs-lookup"><span data-stu-id="e0c57-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="e0c57-138">CA1821: Usuwaj puste finalizatory</span><span class="sxs-lookup"><span data-stu-id="e0c57-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="e0c57-139">Jeśli to tylko możliwe, należy unikać finalizatorów ze względu na dodatkowe obciążenie, które bierze udział w śledzeniu okresu istnienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="e0c57-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="e0c57-140">Pusty finalizator wiąże się z dodatkowymi kosztami bez korzyści.</span><span class="sxs-lookup"><span data-stu-id="e0c57-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="e0c57-141">CA1822: Oznaczaj składowe jako statyczne</span><span class="sxs-lookup"><span data-stu-id="e0c57-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="e0c57-142">Elementy członkowskie, które nie uzyskują dostępu do danych wystąpienia lub wywołania metody wystąpienia, mogą być oznaczone jako statyczne (udostępnione w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e0c57-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="e0c57-143">Po oznaczeniu metod jako statyczne kompilator wygeneruje niewirtualne wywołania do tych członków.</span><span class="sxs-lookup"><span data-stu-id="e0c57-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="e0c57-144">To może dać wymierny zysk wydajnościowy dla kodu wrażliwego na wydajność.</span><span class="sxs-lookup"><span data-stu-id="e0c57-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="e0c57-145">CA1823: Unikaj nieużywanych pól prywatnych</span><span class="sxs-lookup"><span data-stu-id="e0c57-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="e0c57-146">Zostały wykryte pola prywatne, które w zestawie nie są widoczne jako dostępne.</span><span class="sxs-lookup"><span data-stu-id="e0c57-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="e0c57-147">CA1824: Oznaczaj zestawy za pomocą atrybutu NeutralResourcesLanguageAttribute</span><span class="sxs-lookup"><span data-stu-id="e0c57-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="e0c57-148">Atrybut NeutralResourcesLanguage informuje Menedżer zasobów języka, który został użyty do wyświetlenia zasobów neutralnej kultury dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="e0c57-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="e0c57-149">To zwiększa wydajność wyszukiwania dla pierwszego zasobu, który się ładuje i może zmniejszyć zestaw roboczy.</span><span class="sxs-lookup"><span data-stu-id="e0c57-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="e0c57-150">CA1825: Unikaj alokacji tablic o zerowej długości</span><span class="sxs-lookup"><span data-stu-id="e0c57-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="e0c57-151">Inicjowanie tablicy o zerowej długości prowadzi do niepotrzebnej alokacji pamięci.</span><span class="sxs-lookup"><span data-stu-id="e0c57-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="e0c57-152">Zamiast tego należy użyć statycznie przydzielonego wystąpienia pustej tablicy przez wywołanie <xref:System.Array.Empty%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="e0c57-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e0c57-153">Alokacja pamięci jest współdzielona przez wszystkie wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="e0c57-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="e0c57-154">CA1826: Użyj właściwości zamiast metody Linq Enumerable</span><span class="sxs-lookup"><span data-stu-id="e0c57-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="e0c57-155"><xref:System.Linq.Enumerable> Metoda LINQ została użyta na typie, który obsługuje równoważną, wydajniejszą właściwość.</span><span class="sxs-lookup"><span data-stu-id="e0c57-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="e0c57-156">CA1827: Nie używaj funkcji Count/LongCount, gdy można użyć funkcji Any</span><span class="sxs-lookup"><span data-stu-id="e0c57-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="e0c57-157"><xref:System.Linq.Enumerable.Count%2A> Metoda or <xref:System.Linq.Enumerable.LongCount%2A> została użyta w przypadku, gdy <xref:System.Linq.Enumerable.Any%2A> Metoda byłaby bardziej wydajna.</span><span class="sxs-lookup"><span data-stu-id="e0c57-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="e0c57-158">CA1828: Nie używaj funkcji CountAsync/LongCountAsync, gdy można użyć funkcji AnyAsync</span><span class="sxs-lookup"><span data-stu-id="e0c57-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="e0c57-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> Metoda or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> została użyta w przypadku, gdy <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> Metoda byłaby bardziej wydajna.</span><span class="sxs-lookup"><span data-stu-id="e0c57-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="e0c57-160">CA1829: Użyj właściwości Length/Count zamiast metody Enumerable.Count</span><span class="sxs-lookup"><span data-stu-id="e0c57-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="e0c57-161"><xref:System.Linq.Enumerable.Count%2A> Metoda LINQ została użyta w typie, który obsługuje równoważną, wydajniejszą `Length` lub `Count` Właściwość.</span><span class="sxs-lookup"><span data-stu-id="e0c57-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="e0c57-162">CA1830: Preferuj silnie typizowane przeciążenia metod Append i Insert w elemencie StringBuilder</span><span class="sxs-lookup"><span data-stu-id="e0c57-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="e0c57-163"><xref:System.Text.StringBuilder.Append%2A> i <xref:System.Text.StringBuilder.Insert%2A> Podaj przeciążenia dla wielu typów poza typem system. String.</span><span class="sxs-lookup"><span data-stu-id="e0c57-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="e0c57-164">Jeśli to możliwe, Preferuj silnie wpisane przeciążenia przy użyciu metody ToString () i przeciążenia opartego na ciągach.</span><span class="sxs-lookup"><span data-stu-id="e0c57-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="e0c57-165">CA1831: Użyj metody AsSpan zamiast indeksatorów opartych na zakresie dla ciągów, gdy ma to zastosowanie</span><span class="sxs-lookup"><span data-stu-id="e0c57-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="e0c57-166">W przypadku korzystania z indeksatora zakresu w ciągu i niejawnego przypisywania wartości do &lt; typu char ReadOnlySpan &gt; , Metoda <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> zostanie użyta zamiast <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , która tworzy kopię żądanego fragmentu ciągu.</span><span class="sxs-lookup"><span data-stu-id="e0c57-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="e0c57-167">CA1832: Użyj metody AsSpan lub AsMemory zamiast indeksatorów opartych na zakresie do pobierania części ReadOnlySpan lub ReadOnlyMemory dla tablicy</span><span class="sxs-lookup"><span data-stu-id="e0c57-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="e0c57-168">W przypadku korzystania z indeksatora zakresu w tablicy i niejawnego przypisywania wartości <xref:System.ReadOnlySpan%601> do <xref:System.ReadOnlyMemory%601> typu lub, Metoda <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> zostanie użyta zamiast <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , która tworzy kopię żądanego fragmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="e0c57-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="e0c57-169">CA1833: Użyj metody AsSpan lub AsMemory zamiast indeksatorów opartych na zakresie do pobierania części Memory dla tablicy</span><span class="sxs-lookup"><span data-stu-id="e0c57-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="e0c57-170">W przypadku korzystania z indeksatora zakresu w tablicy i niejawnego przypisywania wartości <xref:System.Span%601> do <xref:System.Memory%601> typu lub, Metoda <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> zostanie użyta zamiast <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , która tworzy kopię żądanego fragmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="e0c57-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="e0c57-171">CA1834: Użyj StringBuilder.Append(char) dla ciągów z pojedynczym znakiem</span><span class="sxs-lookup"><span data-stu-id="e0c57-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="e0c57-172"><xref:System.Text.StringBuilder> ma `Append` Przeciążenie, które przyjmuje `char` jako argument.</span><span class="sxs-lookup"><span data-stu-id="e0c57-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="e0c57-173">Preferuj wywołania `char` przeciążenia w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="e0c57-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="e0c57-174">CA1835: Preferuj przeciążenia oparte na Memory' dla elementu "ReadAsync" i "WriteAsync"</span><span class="sxs-lookup"><span data-stu-id="e0c57-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="e0c57-175">Element "Stream" ma Przeciążenie "ReadAsync", które przyjmuje &lt; &gt; jako pierwszy argument "bajt pamięci", i Przeciążenie "WriteAsync", które pobiera "ReadOnlyMemory &lt; Byte &gt; " jako pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="e0c57-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="e0c57-176">Preferuj wywoływanie przeciążeń opartych na pamięci, co jest bardziej wydajne.</span><span class="sxs-lookup"><span data-stu-id="e0c57-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="e0c57-177">CA1836: Preferuj `IsEmpty` , `Count` Jeśli są dostępne</span><span class="sxs-lookup"><span data-stu-id="e0c57-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="e0c57-178">Preferuj `IsEmpty` Właściwość, która jest bardziej wydajna niż `Count` , `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> lub, <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Aby określić, czy obiekt zawiera elementy, czy nie.</span><span class="sxs-lookup"><span data-stu-id="e0c57-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="e0c57-179">CA1837: Użyj `Environment.ProcessId` zamiast `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="e0c57-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="e0c57-180">`Environment.ProcessId` jest prostsze i szybsze niż `Process.GetCurrentProcess().Id` .</span><span class="sxs-lookup"><span data-stu-id="e0c57-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="e0c57-181">CA1838: Unikaj `StringBuilder` parametrów dla P/Invoke</span><span class="sxs-lookup"><span data-stu-id="e0c57-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="e0c57-182">Kierowanie programu `StringBuilder` zawsze tworzy natywną kopię buforu, powodującą wiele alokacji dla jednej operacji organizowania.</span><span class="sxs-lookup"><span data-stu-id="e0c57-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
