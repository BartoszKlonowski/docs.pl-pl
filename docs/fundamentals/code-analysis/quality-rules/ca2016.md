---
title: 'CA2016: Przekaż parametr CancellationToken do metod, które przyjmują jeden (analiza kodu)'
description: 'Dowiedz się więcej o regule analizy kodu CA2016: Przekaż parametr CancellationToken do metod, które ją przyjmują'
ms.date: 06/18/2020
ms.topic: reference
f1_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
helpviewer_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: d8d76ca576a4e175528f066741914739a570af41
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/25/2020
ms.locfileid: "96586830"
---
# <a name="ca2016-forward-the-cancellationtoken-parameter-to-methods-that-take-one"></a><span data-ttu-id="26177-103">CA2016: Prześlij dalej parametr CancellationToken do metod, które go przyjmują</span><span class="sxs-lookup"><span data-stu-id="26177-103">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>

| | <span data-ttu-id="26177-104">Wartość</span><span class="sxs-lookup"><span data-stu-id="26177-104">Value</span></span> |
|-|-|
|<span data-ttu-id="26177-105">TypeName</span><span class="sxs-lookup"><span data-stu-id="26177-105">TypeName</span></span>|<span data-ttu-id="26177-106">ForwardCancellationTokenToInvocations</span><span class="sxs-lookup"><span data-stu-id="26177-106">ForwardCancellationTokenToInvocations</span></span>|
| <span data-ttu-id="26177-107">**Identyfikator zasady**</span><span class="sxs-lookup"><span data-stu-id="26177-107">**Rule ID**</span></span> |<span data-ttu-id="26177-108">CA2016</span><span class="sxs-lookup"><span data-stu-id="26177-108">CA2016</span></span>|
| <span data-ttu-id="26177-109">**Kategoria**</span><span class="sxs-lookup"><span data-stu-id="26177-109">**Category**</span></span> |<span data-ttu-id="26177-110">Microsoft. Performance</span><span class="sxs-lookup"><span data-stu-id="26177-110">Microsoft.Performance</span></span>|
| <span data-ttu-id="26177-111">**Naprawa jest przerywana lub nieprzerwana**</span><span class="sxs-lookup"><span data-stu-id="26177-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="26177-112">Nieprzerwanie</span><span class="sxs-lookup"><span data-stu-id="26177-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="26177-113">Przyczyna</span><span class="sxs-lookup"><span data-stu-id="26177-113">Cause</span></span>

<span data-ttu-id="26177-114">Ta zasada służy do lokalizowania wywołań metod, które mogą akceptować <xref:System.Threading.CancellationToken> parametr, ale nie są przekazywane i sugeruje do przesłania dalej do nich metody nadrzędnej `CancellationToken` .</span><span class="sxs-lookup"><span data-stu-id="26177-114">This rule locates method invocations that could accept a <xref:System.Threading.CancellationToken> parameter, but are not passing any, and suggests to forward the parent method's `CancellationToken` to them.</span></span>

## <a name="rule-description"></a><span data-ttu-id="26177-115">Opis reguły</span><span class="sxs-lookup"><span data-stu-id="26177-115">Rule description</span></span>

<span data-ttu-id="26177-116">Ta reguła analizuje definicje metod, które mają `CancellationToken` jako ostatni parametr, a następnie analizuje wszystkie metody wywoływane w jej treści.</span><span class="sxs-lookup"><span data-stu-id="26177-116">This rule analyzes method definitions that take a `CancellationToken` as their last parameter, then analyzes all methods invoked in its body.</span></span> <span data-ttu-id="26177-117">Jeśli którakolwiek z metod wywołania może przyjmować `CancellationToken` jako ostatni parametr lub mieć Przeciążenie, które przyjmuje `CancellationToken` jako ostatni parametr, reguła sugeruje użycie tej opcji zamiast tego, aby upewnić się, że powiadomienie o anulowaniu zostanie przekazane do wszystkich operacji, które mogą się z nim odsłuchiwać.</span><span class="sxs-lookup"><span data-stu-id="26177-117">If any of the method invocations can either accept a `CancellationToken` as the last parameter, or have an overload that takes a `CancellationToken` as the last parameter, then the rule suggests using that option instead to ensure that the cancellation notification gets propagated to all operations that can listen to it.</span></span>

> [!NOTE]
> <span data-ttu-id="26177-118">Reguła CA2016 jest dostępna we wszystkich wersjach .NET, w których `CancellationToken` Typ jest dostępny.</span><span class="sxs-lookup"><span data-stu-id="26177-118">Rule CA2016 is available in all .NET versions where the `CancellationToken` type is available.</span></span> <span data-ttu-id="26177-119">Patrz [sekcja CancellationToken "dotyczy"](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span><span class="sxs-lookup"><span data-stu-id="26177-119">See [CancellationToken "Applies to" section](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="26177-120">Jak naprawić naruszenia</span><span class="sxs-lookup"><span data-stu-id="26177-120">How to fix violations</span></span>

<span data-ttu-id="26177-121">Można je naprawić ręcznie lub można zezwolić programowi Visual Studio na jego wykonywanie przez umieszczenie kursora myszy na żarówki, która ukazuje się obok wywołania metody i wybierając sugerowaną zmianę.</span><span class="sxs-lookup"><span data-stu-id="26177-121">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span>

<span data-ttu-id="26177-122">Poniższy przykład pokazuje dwie sugerowane zmiany:</span><span class="sxs-lookup"><span data-stu-id="26177-122">The following example shows two suggested changes:</span></span>

![CA2016 reguły — Przekaż parametr CancellationToken do metod, które go przyjmują](media/ca2016-diagnose.png)

<span data-ttu-id="26177-124">Istnieje możliwość bezpiecznego pomijania naruszenia tej reguły, jeśli nie ma potrzeby przesyłania powiadomienia o anulowanej operacji do mniejszych wywołań metod.</span><span class="sxs-lookup"><span data-stu-id="26177-124">It's safe to suppress a violation of this rule if you're not concerned about forwarding the canceled operation notification to lower method invocations.</span></span> <span data-ttu-id="26177-125">Można również jawnie przekazać `default` w języku C# ( `Nothing` w Visual Basic) lub <xref:System.Threading.CancellationToken.None> pominąć naruszenie reguły.</span><span class="sxs-lookup"><span data-stu-id="26177-125">You can also explicitly pass `default` in C# (`Nothing` in Visual Basic) or <xref:System.Threading.CancellationToken.None> to suppress the rule violation.</span></span>

<span data-ttu-id="26177-126">Reguła może wykryć różne naruszenia.</span><span class="sxs-lookup"><span data-stu-id="26177-126">The rule can detect a variety of violations.</span></span> <span data-ttu-id="26177-127">W poniższych przykładach przedstawiono przypadki, które mogą być wykrywane przez regułę:</span><span class="sxs-lookup"><span data-stu-id="26177-127">The following examples show cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="26177-128">Przykład 1</span><span class="sxs-lookup"><span data-stu-id="26177-128">Example 1</span></span>

<span data-ttu-id="26177-129">Reguła sugeruje przekazywanie `c` parametru z `MyMethod` do `MyMethodWithDefault` wywołania, ponieważ metoda definiuje opcjonalny parametr tokenu:</span><span class="sxs-lookup"><span data-stu-id="26177-129">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method defines an optional token parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="26177-130">Wiązane</span><span class="sxs-lookup"><span data-stu-id="26177-130">Fix:</span></span>

<span data-ttu-id="26177-131">Prześlij dalej `c` parametr:</span><span class="sxs-lookup"><span data-stu-id="26177-131">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(c);
        }
```

<span data-ttu-id="26177-132">Jeśli nie chcesz otrzymywać powiadomień o anulowaniu przesyłania dalej do mniejszych wywołań, możesz:</span><span class="sxs-lookup"><span data-stu-id="26177-132">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="26177-133">Jawnie przekazanie `default` :</span><span class="sxs-lookup"><span data-stu-id="26177-133">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(default);
        }
```

<span data-ttu-id="26177-134">Lub jawnie przekazać `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="26177-134">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(CancellationToken.None);
        }
```

### <a name="example-2"></a><span data-ttu-id="26177-135">Przykład 2</span><span class="sxs-lookup"><span data-stu-id="26177-135">Example 2</span></span>

<span data-ttu-id="26177-136">Reguła sugeruje przekazywanie `c` parametru z `MyMethod` do `MyMethodWithDefault` wywołania, ponieważ metoda ma Przeciążenie przyjmujące `CancellationToken` parametr:</span><span class="sxs-lookup"><span data-stu-id="26177-136">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method has an overload that takes a `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethodWithOverload(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="26177-137">Wiązane</span><span class="sxs-lookup"><span data-stu-id="26177-137">Fix:</span></span>

<span data-ttu-id="26177-138">Prześlij dalej `c` parametr:</span><span class="sxs-lookup"><span data-stu-id="26177-138">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(c);
        }
```

<span data-ttu-id="26177-139">Jeśli nie chcesz otrzymywać powiadomień o anulowaniu przesyłania dalej do mniejszych wywołań, możesz:</span><span class="sxs-lookup"><span data-stu-id="26177-139">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="26177-140">Jawnie przekazanie `default` :</span><span class="sxs-lookup"><span data-stu-id="26177-140">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(default);
        }
```

<span data-ttu-id="26177-141">Lub jawnie przekazać `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="26177-141">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(CancellationToken.None);
        }
```

## <a name="non-violation-examples"></a><span data-ttu-id="26177-142">Przykłady braku naruszenia</span><span class="sxs-lookup"><span data-stu-id="26177-142">Non-violation examples</span></span>

<span data-ttu-id="26177-143">`CancellationToken`Parametr w metodzie nadrzędnej nie znajduje się na ostatniej pozycji:</span><span class="sxs-lookup"><span data-stu-id="26177-143">The `CancellationToken` parameter in the parent method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c, int lastParameter)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="26177-144">`CancellationToken`Parametr w metodzie domyślnej nie znajduje się na ostatniej pozycji:</span><span class="sxs-lookup"><span data-stu-id="26177-144">The `CancellationToken` parameter in the default method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default, int lastParameter = 0)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="26177-145">`CancellationToken`Parametr w metodzie przeciążenia nie znajduje się na ostatniej pozycji:</span><span class="sxs-lookup"><span data-stu-id="26177-145">The `CancellationToken` parameter in the overload method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(int lastParameter)
        {
        }
        public static void MyMethodWithOverload(CancellationToken ct, int lastParameter)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="26177-146">Metoda nadrzędna definiuje więcej niż jeden `CancellationToken` parametr:</span><span class="sxs-lookup"><span data-stu-id="26177-146">The parent method defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c1, CancellationToken c2)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="26177-147">Metoda z wartościami domyślnymi definiuje więcej niż jeden `CancellationToken` parametr:</span><span class="sxs-lookup"><span data-stu-id="26177-147">The method with defaults defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken c1 = default, CancellationToken c2 = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="26177-148">Przeciążenie metody definiuje więcej niż jeden `CancellationToken` parametr:</span><span class="sxs-lookup"><span data-stu-id="26177-148">The method overload defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(CancellationToken c1, CancellationToken c2)
        {
        }

        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```
