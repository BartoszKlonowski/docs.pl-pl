---
title: 'CA1835: Preferuj przeciążenia oparte na pamięci dla metod ReadAsync/WriteAsync w klasach opartych na strumieniach (analiza kodu)'
description: 'Dowiedz się więcej o regule analizy kodu CA1835: Preferuj przeciążenia oparte na pamięci metod ReadAsync/WriteAsync w klasach opartych na strumieniach'
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: a3730f911f55af27f75ca41a8a9427a29efd0a18
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/25/2020
ms.locfileid: "96587286"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="209da-103">CA1835: Preferuj przeciążenia oparte na pamięci dla metod ReadAsync/WriteAsync w klasach opartych na strumieniu</span><span class="sxs-lookup"><span data-stu-id="209da-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="209da-104">Wartość</span><span class="sxs-lookup"><span data-stu-id="209da-104">Value</span></span> |
|-|-|
|<span data-ttu-id="209da-105">TypeName</span><span class="sxs-lookup"><span data-stu-id="209da-105">TypeName</span></span>|<span data-ttu-id="209da-106">PreferStreamAsyncMemoryOverlodas</span><span class="sxs-lookup"><span data-stu-id="209da-106">PreferStreamAsyncMemoryOverlodas</span></span>|
| <span data-ttu-id="209da-107">**Identyfikator zasady**</span><span class="sxs-lookup"><span data-stu-id="209da-107">**Rule ID**</span></span> |<span data-ttu-id="209da-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="209da-108">CA1835</span></span>|
| <span data-ttu-id="209da-109">**Kategoria**</span><span class="sxs-lookup"><span data-stu-id="209da-109">**Category**</span></span> |<span data-ttu-id="209da-110">Microsoft. Performance</span><span class="sxs-lookup"><span data-stu-id="209da-110">Microsoft.Performance</span></span>|
| <span data-ttu-id="209da-111">**Naprawa jest przerywana lub nieprzerwana**</span><span class="sxs-lookup"><span data-stu-id="209da-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="209da-112">Nieprzerwanie</span><span class="sxs-lookup"><span data-stu-id="209da-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="209da-113">Przyczyna</span><span class="sxs-lookup"><span data-stu-id="209da-113">Cause</span></span>

<span data-ttu-id="209da-114">Ta zasada lokalizuje oczekujące wywołania przeciążenia metod opartych na tablicy dla `ReadAsync` i i `WriteAsync` sugeruje użycie przeciążenia metod opartych na pamięci, ponieważ są bardziej wydajne.</span><span class="sxs-lookup"><span data-stu-id="209da-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="209da-115">Opis reguły</span><span class="sxs-lookup"><span data-stu-id="209da-115">Rule description</span></span>

<span data-ttu-id="209da-116">Przeciążenia metod opartych na pamięci mają wydajniejsze użycie pamięci niż bajty oparte na tablicy.</span><span class="sxs-lookup"><span data-stu-id="209da-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="209da-117">Reguła działa `ReadAsync` i `WriteAsync` wywołania każdej klasy, która dziedziczy z <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="209da-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="209da-118">Reguła działa tylko wtedy, gdy metoda jest poprzedzona `await` słowem kluczowym.</span><span class="sxs-lookup"><span data-stu-id="209da-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="209da-119">Wykryta Metoda</span><span class="sxs-lookup"><span data-stu-id="209da-119">Detected method</span></span>|<span data-ttu-id="209da-120">Sugerowana Metoda</span><span class="sxs-lookup"><span data-stu-id="209da-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="209da-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> z `CancellationToken` ustawieniem na wartość `default` w języku C# lub `Nothing` w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="209da-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="209da-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> z `CancellationToken` ustawieniem na wartość `default` w języku C# lub `Nothing` w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="209da-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="209da-123">Upewnij się, że `offset` argumenty i `count` liczby całkowite zostały przekazane do `Memory` utworzonych `ReadOnlyMemory` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="209da-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="209da-124">Reguła CA1835 jest dostępna we wszystkich wersjach .NET, w których dostępne są przeciążenia oparte na pamięci:</span><span class="sxs-lookup"><span data-stu-id="209da-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="209da-125">.NET Standard 2,1 i nowsze.</span><span class="sxs-lookup"><span data-stu-id="209da-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="209da-126">.NET Core 2,1 lub nowszy.</span><span class="sxs-lookup"><span data-stu-id="209da-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="209da-127">Jak naprawić naruszenia</span><span class="sxs-lookup"><span data-stu-id="209da-127">How to fix violations</span></span>

<span data-ttu-id="209da-128">Można je naprawić ręcznie lub można zezwolić programowi Visual Studio na jego wykonywanie przez umieszczenie kursora myszy na żarówki, która ukazuje się obok wywołania metody i wybierając sugerowaną zmianę.</span><span class="sxs-lookup"><span data-stu-id="209da-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="209da-129">Przykład:</span><span class="sxs-lookup"><span data-stu-id="209da-129">Example:</span></span>

![Poprawka kodu dla CA1835 — Preferuj oparte na pamięci przeciążenia metod ReadAsync/WriteAsync w klasach opartych na strumieniach](media/ca1835-codefix.png)

<span data-ttu-id="209da-131">Reguła może wykryć różne naruszenia `ReadAsync` `WriteAsync` metod i.</span><span class="sxs-lookup"><span data-stu-id="209da-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="209da-132">Poniżej przedstawiono przykłady przypadków, w których można wykryć regułę:</span><span class="sxs-lookup"><span data-stu-id="209da-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="209da-133">Przykład 1</span><span class="sxs-lookup"><span data-stu-id="209da-133">Example 1</span></span>

<span data-ttu-id="209da-134">Wywołania `ReadAsync` , bez i z `CancellationToken` argumentem:</span><span class="sxs-lookup"><span data-stu-id="209da-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="209da-135">Wiązane</span><span class="sxs-lookup"><span data-stu-id="209da-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="209da-136">Przykład 2</span><span class="sxs-lookup"><span data-stu-id="209da-136">Example 2</span></span>

<span data-ttu-id="209da-137">Wywołania `WriteAsync` , bez i z `CancellationToken` argumentem:</span><span class="sxs-lookup"><span data-stu-id="209da-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="209da-138">Wiązane</span><span class="sxs-lookup"><span data-stu-id="209da-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="209da-139">Przykład 3</span><span class="sxs-lookup"><span data-stu-id="209da-139">Example 3</span></span>

<span data-ttu-id="209da-140">Wywołania z `ConfigureAwait` :</span><span class="sxs-lookup"><span data-stu-id="209da-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="209da-141">Wiązane</span><span class="sxs-lookup"><span data-stu-id="209da-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="209da-142">NIENARUSZENIA</span><span class="sxs-lookup"><span data-stu-id="209da-142">Non-violations</span></span>

<span data-ttu-id="209da-143">Poniżej przedstawiono kilka przykładów wywołań, w których zasada **nie** zostanie uruchomiona.</span><span class="sxs-lookup"><span data-stu-id="209da-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="209da-144">Wartość zwracana jest zapisywana w `Task` zmiennej, a nie jest oczekiwana:</span><span class="sxs-lookup"><span data-stu-id="209da-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="209da-145">Zwracana wartość jest zwracana przez metodę otoki, a nie jest oczekiwana:</span><span class="sxs-lookup"><span data-stu-id="209da-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="209da-146">Wartość zwracana jest używana do wywołania `ContinueWith` metody, która jest oczekiwana:</span><span class="sxs-lookup"><span data-stu-id="209da-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="209da-147">Kiedy pominąć ostrzeżenia</span><span class="sxs-lookup"><span data-stu-id="209da-147">When to suppress warnings</span></span>

<span data-ttu-id="209da-148">Istnieje możliwość bezpiecznego pomijania naruszenia tej reguły, jeśli nie ma potrzeby zwiększenia wydajności podczas odczytywania lub pisania buforów w klasach opartych na strumieniach.</span><span class="sxs-lookup"><span data-stu-id="209da-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="209da-149">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="209da-149">See also</span></span>

- [<span data-ttu-id="209da-150">Reguły wydajności</span><span class="sxs-lookup"><span data-stu-id="209da-150">Performance rules</span></span>](performance-warnings.md)
