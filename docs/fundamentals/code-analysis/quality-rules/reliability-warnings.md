---
title: Reguły niezawodności (analiza kodu)
description: Dowiedz się więcej na temat reguł niezawodności analizy kodu.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/07/2020
ms.locfileid: "96589439"
---
# <a name="reliability-rules"></a><span data-ttu-id="22122-103">Reguły dotyczące niezawodności</span><span class="sxs-lookup"><span data-stu-id="22122-103">Reliability rules</span></span>

<span data-ttu-id="22122-104">Reguły niezawodności obsługują niezawodność biblioteki i aplikacji, takie jak poprawne użycie pamięci i wątku.</span><span class="sxs-lookup"><span data-stu-id="22122-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="22122-105">Reguły niezawodności obejmują:</span><span class="sxs-lookup"><span data-stu-id="22122-105">The reliability rules include:</span></span>

|<span data-ttu-id="22122-106">Reguła</span><span class="sxs-lookup"><span data-stu-id="22122-106">Rule</span></span>|<span data-ttu-id="22122-107">Opis</span><span class="sxs-lookup"><span data-stu-id="22122-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="22122-108">CA2000: Likwiduj obiekty przed utratą zakresu</span><span class="sxs-lookup"><span data-stu-id="22122-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="22122-109">Ze względu na to, że może wystąpić wyjątkowe zdarzenie, które uniemożliwi uruchomienie finalizatora obiektu, obiekty powinny być jawnie usuwane, zanim wszystkie odwołania do niego znajdą się poza zakresem.</span><span class="sxs-lookup"><span data-stu-id="22122-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="22122-110">CA2002: Nie blokuj obiektów o słabej tożsamości</span><span class="sxs-lookup"><span data-stu-id="22122-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="22122-111">Obiekt ma słabą tożsamość, gdy można uzyskać do niego bezpośredni dostęp poza granicami domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="22122-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="22122-112">Wątek, który próbuje uzyskać blokadę na obiekcie o słabej tożsamości, może zostać zablokowany przez drugi wątek w domenie innej aplikacji, która ma blokady dla tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="22122-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="22122-113">CA2007: Nie oczekuj bezpośrednio zadania</span><span class="sxs-lookup"><span data-stu-id="22122-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="22122-114">Metoda asynchroniczna [czeka](../../../csharp/language-reference/operators/await.md) <xref:System.Threading.Tasks.Task> bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="22122-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="22122-115">CA2008: Nie twórz zadań bez przekazania klasy TaskScheduler</span><span class="sxs-lookup"><span data-stu-id="22122-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="22122-116">Operacja tworzenia lub kontynuacji zadania używa przeciążenia metody, które nie określa <xref:System.Threading.Tasks.TaskScheduler> parametru.</span><span class="sxs-lookup"><span data-stu-id="22122-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="22122-117">CA2009: Nie wywołuj elementu ToImmutableCollection dla wartości ImmutableCollection</span><span class="sxs-lookup"><span data-stu-id="22122-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="22122-118">`ToImmutable` Metoda była niekoniecznie wywoływana w niezmiennej kolekcji z <xref:System.Collections.Immutable> przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="22122-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="22122-119">CA2011: Nie przypisuj właściwości w ramach jej metody ustawiającej</span><span class="sxs-lookup"><span data-stu-id="22122-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="22122-120">Właściwość przypadkowo przypisała wartość w ramach własnej [metody dostępu set](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span><span class="sxs-lookup"><span data-stu-id="22122-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="22122-121">CA2012: Poprawnie używaj elementów ValueTask</span><span class="sxs-lookup"><span data-stu-id="22122-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="22122-122">ValueTasks zwracane z wywołań elementów członkowskich są przeznaczone do bezpośredniego oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="22122-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="22122-123">Próbuje użyć ValueTask wiele razy lub uzyskać bezpośredni dostęp do wyniku, zanim będzie wiadomo, że może to spowodować wyjątek lub uszkodzenie.</span><span class="sxs-lookup"><span data-stu-id="22122-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="22122-124">Takie ValueTask jest prawdopodobnie oznaką funkcjonalnej usterki i może obniżyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="22122-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="22122-125">CA2013: Nie używaj metody ReferenceEquals z typami wartości</span><span class="sxs-lookup"><span data-stu-id="22122-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="22122-126">Porównując wartości przy użyciu <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> , jeśli obja i objB są typami wartości, są one opakowane przed przekazaniem ich do <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="22122-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="22122-127">Oznacza to, że nawet jeśli zarówno objA, jak i objB reprezentują to samo wystąpienie typu wartości, <xref:System.Object.ReferenceEquals%2A> Metoda jednak zwróci wartość false.</span><span class="sxs-lookup"><span data-stu-id="22122-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="22122-128">CA2014: nie używaj stackalloc w pętlach.</span><span class="sxs-lookup"><span data-stu-id="22122-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="22122-129">Przestrzeń stosu przydzielona przez stackalloc jest wydawana tylko na końcu wywołania bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="22122-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="22122-130">Użycie jej w pętli może spowodować powstanie nieograniczonego wzrostu stosu i ostateczne warunki przepełnienia stosu.</span><span class="sxs-lookup"><span data-stu-id="22122-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="22122-131">CA2015: nie Definiuj finalizatorów dla typów pochodzących z Pamięciobject &lt; T&gt;</span><span class="sxs-lookup"><span data-stu-id="22122-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="22122-132">Dodanie finalizatora do typu pochodzącego od <xref:System.Buffers.MemoryManager%601> może pozwolić na zwolnienie pamięci, gdy jest nadal używany przez <xref:System.Span%601> .</span><span class="sxs-lookup"><span data-stu-id="22122-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="22122-133">CA2016: Prześlij dalej parametr CancellationToken do metod, które go przyjmują</span><span class="sxs-lookup"><span data-stu-id="22122-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="22122-134">Przekaż `CancellationToken` parametr do metod, które przyjmują w celu zapewnienia, że powiadomienia o anulowaniu operacji są prawidłowo propagowane, lub Przekaż `CancellationToken.None` jawnie, aby wskazać celowo niepropagowanie tokenu.</span><span class="sxs-lookup"><span data-stu-id="22122-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
