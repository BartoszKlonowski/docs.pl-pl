---
title: Reguły zabezpieczeń (analiza kodu)
description: Dowiedz się więcej na temat reguł zabezpieczeń analizy kodu.
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: e907905b065d786fc8b3c370fb2d2e2b19e62a2b
ms.sourcegitcommit: 5114e7847e0ff8ddb8c266802d47af78567949cf
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/19/2020
ms.locfileid: "96590020"
---
# <a name="security-rules"></a>Reguły zabezpieczeń

Reguły zabezpieczeń obsługują bezpieczniejsze biblioteki i aplikacje. Te reguły pomagają zapobiegać błędom zabezpieczeń w programie. Jeśli wyłączysz każdą z tych reguł, należy wyraźnie oznaczyć przyczynę kodu, a także poinformować wyznaczeniego oficera zabezpieczeń dla projektu deweloperskiego.

## <a name="in-this-section"></a>W tej sekcji

|Reguła|Opis|
|----------|-----------------|
|[CA2100: Sprawdź zapytania SQL pod kątem luk w zabezpieczeniach](ca2100.md)|Metoda ustawia właściwość System.Data.IDbCommand.CommandText przez użycie ciągu, który jest zbudowany z argumentem ciągu do metody. Zasada ta zakłada, że argument ciągu zawiera dane wejściowe użytkownika. Ciąg polecenia SQL zbudowany z danych wejściowych użytkownika jest narażony na ataki przez wstrzyknięcie kodu SQL.|
|[CA2109: Przejrzyj widoczne procedury obsługi zdarzeń](ca2109.md)|Wykryto publiczną lub chronioną metodę obsługi zdarzeń. Metody obsługi zdarzeń nie powinny być udostępnione, chyba że jest to absolutnie konieczne.|
|[CA2119: Pieczętuj metody, które spełniają wymagania interfejsów prywatnych](ca2119.md)|Dziedziczony typ publiczny zapewnia implementację metody wewnętrznej (zaprzyjaźnionej w Visual Basic). Aby naprawić naruszenie tej zasady, należy zapobiegać zastąpieniu metody poza zestawem.|
|[CA2153: Unikaj obsługiwania wyjątków stanu uszkodzenia](ca2153.md)|[Wyjątki uszkodzonych Stanów (rozszerzenie klienta)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) wskazują, że uszkodzenie pamięci istnieje w procesie. Ich przechwycenie zamiast zezwalania na awarię procesu może prowadzić do luk w zabezpieczeniach, jeśli osoba atakująca może wykorzystać lukę w uszkodzonym regionie pamięci.|
|[CA2300: Nie używaj niezabezpieczonego deserializatora BinaryFormatter](ca2300.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2301: Nie wywołuj metody BinaryFormatter.Deserialize bez uprzedniego ustawienia właściwości BinaryFormatter.Binder](ca2301.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2302: Upewnij się, że właściwość BinaryFormatter.Binder jest ustawiona przed wywołaniem metody BinaryFormatter.Deserialize](ca2302.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2305: Nie używaj niezabezpieczonego deserializatora LosFormatter](ca2305.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2310: Nie używaj niezabezpieczonego deserializatora NetDataContractSerializer](ca2310.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2311: Nie wykonuj deserializacji bez uprzedniego ustawienia właściwości NetDataContractSerializer.Binder](ca2311.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2312: Upewnij się, że właściwość NetDataContractSerializer.Binder jest ustawiona przed deserializacją](ca2312.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2315: Nie używaj niezabezpieczonego deserializatora ObjectStateFormatter](ca2315.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2321: Nie wykonuj deserializacji za pomocą obiektu JavaScriptSerializer zainicjowanego przy użyciu parametru SimpleTypeResolver](ca2321.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2322: Upewnij się, że obiekt JavaScriptSerializer nie został zainicjowany przy użyciu parametru SimpleTypeResolver przed deserializacją](ca2322.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2326: Nie używaj wartości TypeNameHandling innych niż None](ca2326.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2327: Nie używaj niezabezpieczonych ustawień JsonSerializerSettings](ca2327.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2328: Upewnij się, że ustawienia JsonSerializerSettings zostały zabezpieczone](ca2328.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2329: Nie deserializuj przy użyciu rozwiązania JsonSerializer za pomocą niezabezpieczonej konfiguracji](ca2329.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2330: Upewnij się, że podczas deserializacji rozwiązania JsonSerializer ma bezpieczną konfigurację](ca2330.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2350: Upewnij się, że dane wejściowe elementu DataTable.ReadXml () są zaufane](ca2350.md)|Podczas deserializacji <xref:System.Data.DataTable> z niezaufanymi danymi wejściowymi, osoba atakująca może przedrzemieślniczić złośliwe dane wejściowe w celu przeprowadzenia ataku typu "odmowa usługi". Mogą wystąpić nieznane luki w zabezpieczeniach dotyczące zdalnego wykonywania kodu.|
|[CA2351: Upewnij się, że dane wejściowe elementu DataSet.ReadXml () są zaufane](ca2351.md)|Podczas deserializacji <xref:System.Data.DataSet> z niezaufanymi danymi wejściowymi, osoba atakująca może przedrzemieślniczić złośliwe dane wejściowe w celu przeprowadzenia ataku typu "odmowa usługi". Mogą wystąpić nieznane luki w zabezpieczeniach dotyczące zdalnego wykonywania kodu.|
|[CA2352: Niebezpieczny element DataSet lub DataTable w typie możliwym do serializacji może być podatny na ataki polegające na zdalnym wykonaniu kodu](ca2352.md)|Klasa lub struktura oznaczona przy użyciu <xref:System.SerializableAttribute> zawiera <xref:System.Data.DataSet> pole lub <xref:System.Data.DataTable> Właściwość i nie ma <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: Niebezpieczny element DataSet lub DataTable w typie możliwym do serializacji](ca2353.md)|Klasa lub struktura oznaczona przy użyciu atrybutu serializacji XML lub atrybutu kontraktu danych zawiera <xref:System.Data.DataSet> <xref:System.Data.DataTable> pole or lub właściwość.|
|[CA2354: Niebezpieczny element DataSet lub DataTable w deserializowanym wykresie obiektu może być podatny na atak polegający na zdalnym wykonaniu kodu](ca2354.md)|Deserializacja z <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serializowaną, a wykres obiektu typu rzutowego może zawierać <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> .|
|[CA2355: Niebezpieczny element DataSet lub DataTable w deserializowanym wykresie obiektu](ca2355.md)|Deserializacja, gdy wykres obiektu rzutowanego lub określonego typu może zawierać <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> .|
|[CA2356: niebezpieczny zestaw danych lub DataTable w grafie obiektów deserializowanych sieci Web](ca2356.md)|Metoda z <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> lub <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> ma parametr, który może odwoływać się do <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> .|
|[CA2361: Upewnij się, że automatycznie wygenerowana klasa zawierająca element DataSet.ReadXml() nie jest używana z niezaufanymi danymi](ca2361.md)|Podczas deserializacji <xref:System.Data.DataSet> z niezaufanymi danymi wejściowymi, osoba atakująca może przedrzemieślniczić złośliwe dane wejściowe w celu przeprowadzenia ataku typu "odmowa usługi". Mogą wystąpić nieznane luki w zabezpieczeniach dotyczące zdalnego wykonywania kodu.|
|[CA2362: Niebezpieczny element DataSet lub DataTable w automatycznie wygenerowanym typie, który można serializować, może być narażony na ataki polegające na zdalnym wykonaniu kodu](ca2362.md)|Podczas deserializacji niezaufanych danych wejściowych przy użyciu programu <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> i deserializowany obiekt Graph zawiera <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> , osoba atakująca może nawiązać złośliwy ładunek w celu wykonania ataku zdalnego wykonywania kodu.|
|[CA3001: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu SQL](ca3001.md)|Podczas pracy z niezaufanymi poleceniami wejściowymi i SQL należy zastanowić się nad atakami polegającymi na iniekcji SQL. Atak wykorzystujący wstrzyknięcie kodu SQL może wykonywać złośliwe polecenia SQL, narażając zabezpieczenia i integralność aplikacji.|
|[CA3002: Przegląd kodu pod kątem luk umożliwiających działanie skryptów między witrynami](ca3002.md)|Podczas pracy z niezaufanymi danymi wejściowymi z żądań sieci Web należy zastanowić się, jak ataki między środowiskami (XSS). Atak typu "XSS" powoduje dodanie niezaufanych danych wejściowych do nieprzetworzonych danych wyjściowych HTML, co umożliwia osobie atakującej wykonywanie złośliwych skryptów lub złośliwie modyfikowanie zawartości na stronie sieci Web.|
|[CA3003: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie ścieżki pliku](ca3003.md)|Podczas pracy z niezaufanymi danymi wejściowymi z żądań sieci Web należy zastanowić się nad użyciem danych wejściowych sterowanych przez użytkownika podczas określania ścieżek do plików.|
|[CA3004: Przegląd kodu pod kątem luk umożliwiających ujawnienie informacji](ca3004.md)|Odłączanie informacji o wyjątkach daje osobom atakującym wgląd w wewnętrzne dane aplikacji, co może pomóc atakującym znaleźć inne luki w zabezpieczeniach.|
|[CA3006: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie polecenia procesu](ca3006.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy zastanowić się nad atakami polegającymi na iniekcji poleceń. Atak polegający na iniekcji poleceń może wykonywać złośliwe polecenia w podstawowym systemie operacyjnym, narażając zabezpieczenia i integralność serwera.|
|[CA3007: Przegląd kodu pod kątem luk umożliwiających otwarcie przekierowania](ca3007.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze luki w zabezpieczeniach dotyczące otwartych przekierowań. Osoba atakująca może wykorzystać lukę w zabezpieczeniach Open Redirect, aby użyć witryny sieci Web w celu uzyskania oryginalnego adresu URL, ale przekierować niepodejrzanego gościa do phishingu lub innej złośliwej strony sieci Web.|
|[CA3008: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie wyrażenia XPath](ca3008.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy zastanowić się nad atakami z użyciem kodu XPath. Konstruowanie zapytań XPath przy użyciu niezaufanych danych wejściowych może pozwolić osobie atakującej na złośliwe manipulowanie kwerendą w celu zwrócenia niezamierzonego wyniku i może ujawnić zawartość pliku XML z kwerendą.|
|[CA3009: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu XML](ca3009.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze ataki kodu XML.|
|[CA3010: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu XAML](ca3010.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze ataki kodu XAML. XAML jest językiem znaczników, który bezpośrednio reprezentuje Tworzenie wystąpienia obiektu i wykonywanie. Oznacza to, że elementy utworzone w języku XAML mogą korzystać z zasobów systemowych (np. dostępu do sieci i we/wy systemu plików).|
|[CA3011: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie biblioteki DLL](ca3011.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy zastanowić się nad ładowaniem niezaufanego kodu. Jeśli aplikacja sieci Web ładuje niezaufany kod, osoba atakująca może dodawać złośliwe biblioteki DLL do procesu i wykonywać złośliwe kod.|
|[CA3012: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie wyrażenia regularnego](ca3012.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze ataki z iniekcją wyrażeń regularnych. Osoba atakująca może użyć iniekcji wyrażenia regularnego w celu złośliwego zmodyfikowania wyrażeń regularnych, aby wyrażenie regularne pasowało do nieoczekiwanych wyników, lub aby wyrażenie regularne zużywać nadmierny procesor w wyniku ataku typu "odmowa usługi".|
|[CA3061: Nie dodawaj schematu według adresu URL](ca3061.md)|Nie używaj niebezpiecznego przeciążenia metody Add, ponieważ może to spowodować niebezpieczne odwołania zewnętrzne.|
|[CA3075: Niezabezpieczone przetwarzanie definicji DTD](ca3075.md)|Jeśli używasz niezabezpieczonych wystąpień DTDProcessing lub referencyjnych źródeł zewnętrznych, Analizator może zaakceptować niezaufane dane wejściowe i ujawnić poufne informacje osobom atakującym.|
|[CA3076: Niezabezpieczone wykonywanie skryptu XSLT](ca3076.md)|W przypadku wykonywania w aplikacjach .NET niezabezpieczonego przekształcenia XML (Extensible StyleSheet Language Transformation) procesor może rozpoznać niezaufane odwołania do identyfikatorów URI, które mogą ujawnić poufne informacje osobom atakującym, prowadząc do odmowy usługi i ataków między lokacjami.|
|[CA3077: Niezabezpieczone przetwarzanie w elemencie Design interfejsu API, dokumencie XML i czytniku tekstu dla kodu XML](ca3077.md)|Podczas projektowania interfejsu API pochodnego od XmlDocument i XMLTextReader należy mieć na uwadze, że DtdProcessing. Używanie niezabezpieczonych wystąpień DTDProcessing w przypadku odwoływania się do lub rozpoznawania zewnętrznych źródeł jednostek lub ustawiania niezabezpieczonych wartości w kodzie XML może prowadzić do ujawnienia informacji.|
|[CA3147: Oznaczanie procedur obsługi zleceń za pomocą tokenu ValidateAntiForgeryToken](ca3147.md)|Podczas projektowania kontrolera MVC ASP.NET należy zastanowić się, że zachodzą przypadki fałszerstwa żądań między witrynami. Atakujący sfałszowanie żądań między lokacjami może wysyłać złośliwych żądań od uwierzytelnionego użytkownika do kontrolera MVC ASP.NET.|
|[CA5350: Nie używaj słabych algorytmów kryptograficznych](ca5350.md)|Słabe algorytmy szyfrowania i funkcje wyznaczania wartości skrótu są obecnie używane z wielu powodów, ale nie powinny być używane do zagwarantowania poufności lub integralności chronionych danych. Ta reguła jest wyzwalana po znalezieniu w kodzie algorytmów TripleDES, SHA1 lub RIPEMD160.|
|[CA5351: nie używaj uszkodzonych algorytmów kryptograficznych](ca5351.md)|Uszkodzone algorytmy kryptograficzne nie są uważane za bezpieczne, a ich użycie nie powinno być zdecydowanie zalecane. Ta reguła jest wyzwalana, gdy odnajdzie algorytm wyznaczania wartości skrótu MD5 lub algorytmy szyfrowania DES lub RC2 w kodzie.|
|[CA5358: Nie używaj niebezpiecznych trybów szyfrowania](ca5358.md)|Nie używaj niebezpiecznych trybów szyfrowania|
|[CA5359: Nie wyłączaj walidacji certyfikatów](ca5359.md)|Certyfikat może pomóc uwierzytelnić tożsamość serwera programu. Klienci powinni sprawdzić poprawność certyfikatu serwera, aby upewnić się, że żądania są wysyłane do zamierzonego serwera. Jeśli ServerCertificateValidationCallback zawsze zwróci `true` , każdy certyfikat przejdzie pomyślnie weryfikację.|
|[CA5360: Nie wywołuj niebezpiecznych metod w deserializacji](ca5360.md)|Niezabezpieczona deserializacja jest luką w zabezpieczeniach, która występuje, gdy niezaufane dane są używane do nadużycia logiki aplikacji, wynoszą atak typu "odmowa usługi" (DoS), a nawet wykonują dowolny kod podczas deserializacji. Często Złośliwi użytkownicy mogą nadużyć tych funkcji deserializacji, gdy aplikacja deserializacji niezaufanych danych, które są pod kontrolą. W celu wywołaj metody niebezpieczne w procesie deserializacji. Pomyślne niezabezpieczone ataki deserializacji mogą pozwolić atakującemu na przeprowadzanie ataków, takich jak ataki systemu DoS, obejścia uwierzytelniania i zdalne wykonywanie kodu.|
|[CA5361: nie należy wyłączać użycia silnej kryptografii SChannel](ca5361.md)|Ustawienie `Switch.System.Net.DontEnableSchUseStrongCrypto` `true` obniżania poziomu kryptografii używanej w połączeniach wychodzących Transport Layer Security (TLS). Słabsze Kryptografia może naruszać poufność komunikacji między aplikacją a serwerem, ułatwiając atakującym eavesdrop poufnych danych.|
|[CA5362: Potencjalny cykl odwołań w grafie obiektu deserializowanego](ca5362.md)|W przypadku deserializacji niezaufanych danych, każdy kod przetwarzania deserializowanego grafu obiektów musi obsługiwać cykle odwołań bez przechodzenia do nieskończonych pętli. Obejmuje to zarówno kod, który jest częścią wywołania zwrotnego deserializacji i kod, który przetwarza Graf obiektu po zakończeniu deserializacji. W przeciwnym razie atakujący może przeprowadzić atak typu "odmowa usługi" ze złośliwymi danymi zawierającymi cykl referencyjny.|
|[CA5363: Nie wyłączaj weryfikacji żądań](ca5363.md)|Sprawdzanie poprawności żądań jest funkcją w ASP.NET, która sprawdza żądania HTTP i określa, czy zawierają potencjalnie niebezpieczną zawartość, która może prowadzić do ataków iniekcji, w tym skryptów między lokacjami.|
|[CA5364: Nie używaj przestarzałych protokołów zabezpieczeń](ca5364.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Starsze wersje protokołu TLS są mniej bezpieczne niż TLS 1,2 i TLS 1,3 i coraz bardziej mogą mieć nowe luki w zabezpieczeniach. Unikaj stosowania starszych wersji protokołów, aby zminimalizować ryzyko.|
|[CA5365: Nie wyłączaj sprawdzania nagłówka HTTP](ca5365.md)|Sprawdzanie nagłówka HTTP włącza kodowanie znaku powrotu karetki i znaków nowego wiersza, \r i \n, które znajdują się w nagłówkach odpowiedzi. To kodowanie może ułatwić uniknięcie ataków wykorzystujących niezaufane dane zawarte w nagłówku przez program.|
|[CA5366: Użyj czytnika XmlReader na potrzeby pliku XML odczytu zestawu danych](ca5366.md)|Korzystanie z programu <xref:System.Data.DataSet> do odczytywania danych XML z niezaufanymi danymi może ładować niebezpieczne odwołania zewnętrzne, które powinny być ograniczone przy użyciu programu <xref:System.Xml.XmlReader> z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem DTD.|
|[CA5367: Nie serializuj typów z polami wskaźników](ca5367.md)|Ta reguła sprawdza, czy istnieje Klasa możliwa do serializacji z polem wskaźnika lub właściwością. Elementy członkowskie, które nie mogą być serializowane, mogą być wskaźnikami, takimi jak statyczne elementy członkowskie lub pola oznaczone przy użyciu <xref:System.NonSerializedAttribute> .|
|[CA5368: Ustaw właściwość ViewStateUserKey dla klas pochodzących od klasy Page](ca5368.md)|Ustawienie <xref:System.Web.UI.Page.ViewStateUserKey> właściwości może pomóc w zapobieganiu atakom w aplikacji przez umożliwienie przypisania identyfikatora do zmiennej stanu widoku dla poszczególnych użytkowników, tak aby atakujący nie mogli użyć zmiennej do wygenerowania ataku. W przeciwnym razie zostaną wystąpiły luki w zabezpieczeniach związane z fałszerstwem żądań między lokacjami.|
|[CA5369: Używaj elementu XmlReader do deserializacji](ca5369.md)|Przetwarzanie niezaufanych schematów DTD i XML może umożliwić ładowanie niebezpiecznych odwołań zewnętrznych, które powinny być ograniczone przy użyciu elementu XmlReader z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem schematu DTD i XML.|
|[CA5370: Używaj elementu XmlReader do weryfikacji czytelnika](ca5370.md)|Przetwarzanie niezaufanych schematów DTD i XML może umożliwić ładowanie niebezpiecznych odwołań zewnętrznych. To niebezpieczne ładowanie może być ograniczone przy użyciu elementu XmlReader z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem schematu DTD i XML.|
|[CA5371: Używaj elementu XmlReader do odczytywania schematu](ca5371.md)|Przetwarzanie niezaufanych schematów DTD i XML może umożliwić ładowanie niebezpiecznych odwołań zewnętrznych. Używanie elementu XmlReader z bezpiecznym programem rozpoznawania nazw lub z wyłączonym przetwarzaniem schematu DTD i XML jest ograniczone.|
|[CA5372: Używaj elementu XmlReader dla elementu XPathDocument](ca5372.md)|Przetwarzanie kodu XML z niezaufanych danych może ładować niebezpieczne odwołania zewnętrzne, które mogą być ograniczone przy użyciu elementu XmlReader z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem DTD.|
|[CA5373: Nie używaj przestarzałej funkcji wyprowadzania klucza](ca5373.md)|Ta zasada wykrywa wywoływanie metod wyprowadzania słabych kluczy <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> i `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> użyto słabego algorytmu PBKDF1.|
|[CA5374: Nie używaj klasy XslTransform](ca5374.md)|Ta reguła sprawdza, czy <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> jest tworzone wystąpienie w kodzie. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> jest już przestarzałe i nie należy go używać.|
|[CA5375: Nie używaj sygnatury dostępu współdzielonego konta](ca5375.md)|Sygnatura dostępu współdzielonego konta może delegować dostęp do operacji odczytu, zapisu i usuwania dla kontenerów obiektów blob, tabel, kolejek i udziałów plików, które nie są dozwolone przy użyciu sygnatury dostępu współdzielonego usługi. Nie obsługuje jednak zasad na poziomie kontenera i zapewnia mniejszą elastyczność i kontrolę nad udzielonymi uprawnieniami. Po otrzymaniu złośliwych użytkowników Twoje konto magazynu zostanie łatwo naruszone.|
|[CA5376: Użyj właściwości HttpsOnly elementu SharedAccessProtocol](ca5376.md)|Sygnatury dostępu współdzielonego to dane poufne, których nie można transportować w postaci zwykłego tekstu na HTTP|
|[CA5377: Użyj zasad dostępu na poziomie kontenera](ca5377.md)|Zasady dostępu na poziomie kontenera można zmodyfikować lub odwołać w dowolnym momencie. Zapewnia większą elastyczność i kontrolę nad udzielonymi uprawnieniami.|
|[CA5378: Nie wyłączaj protokołów ServicePointManagerSecurityProtocols](ca5378.md)|Ustawienie `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` `true` ograniczające połączenia Transport Layer Security (TLS) środowiska Windows Communication Framework z użyciem protokołu TLS 1,0. Ta wersja protokołu TLS zostanie wycofana.|
|[CA5379: Upewnij się, że algorytm funkcji wyprowadzania klucza jest wystarczająco silny](ca5379.md)|<xref:System.Security.Cryptography.Rfc2898DeriveBytes>Klasa domyślnie używa <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorytmu. Należy określić algorytm wyznaczania wartości skrótu, który ma być używany w niektórych przeciążeniach konstruktora z <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> lub wyższym. Uwaga, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> Właściwość ma tylko `get` metodę dostępu i nie ma `overriden` modyfikatora.|
|[CA5380: Nie dodawaj certyfikatów do magazynu głównego](ca5380.md)|Ta reguła wykrywa kod, który dodaje certyfikat do magazynu certyfikatów zaufanych głównych urzędów certyfikacji. Domyślnie magazyn certyfikatów zaufanych głównych urzędów certyfikacji jest skonfigurowany przy użyciu zestawu publicznych urzędów certyfikacji, które spełniają wymagania programu certyfikatów głównych firmy Microsoft.|
|[CA5381: Upewnij się, że certyfikaty nie są dodawane do magazynu głównego](ca5381.md)|Ta reguła wykrywa kod, który potencjalnie dodaje certyfikat do magazynu certyfikatów zaufanych głównych urzędów certyfikacji. Domyślnie magazyn certyfikatów zaufanych głównych urzędów certyfikacji jest skonfigurowany przy użyciu zestawu publicznych urzędów certyfikacji (CA), które spełniają wymagania programu certyfikatów głównych firmy Microsoft.|
|[CA5382: Użyj bezpiecznych plików cookie na platformie ASP.NET Core](ca5382.md)|Aplikacje dostępne za pośrednictwem protokołu HTTPS muszą używać bezpiecznych plików cookie, które wskazują przeglądarkę, że plik cookie powinien być przesyłany tylko przy użyciu Transport Layer Security (TLS).|
|[CA5383: Upewnij się, że używasz bezpiecznych plików cookie na platformie ASP.NET Core](ca5383.md)|Aplikacje dostępne za pośrednictwem protokołu HTTPS muszą używać bezpiecznych plików cookie, które wskazują przeglądarkę, że plik cookie powinien być przesyłany tylko przy użyciu Transport Layer Security (TLS).|
|[CA5384: Nie używaj algorytmu Digital Signature Algorithm (DSA)](ca5384.md)|DSA jest słabym algorytmem szyfrowania.|
|[CA5385: Użyj algorytmu Rivest-Shamir-Adleman (RSA) z wystarczającym rozmiarem klucza](ca5385.md)|Klucz RSA mniejszy niż 2048 bitów jest bardziej narażony na ataki typu "odmowa".|
|[CA5386: Unikaj kodowania na stałe wartości SecurityProtocolType](ca5386.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Protokół TLS 1,0 i TLS 1,1 są przestarzałe, podczas gdy protokoły TLS 1,2 i TLS 1,3 są aktualne. W przyszłości protokoły TLS 1,2 i TLS 1,3 mogą być przestarzałe. Aby upewnić się, że aplikacja pozostaje zabezpieczona, należy unikać zakodowana wersji protokołu i docelowej co najmniej .NET Framework v 4.7.1.|
|[CA5387: Nie używaj funkcji wyprowadzania klucza słabego z niewystarczającą liczbą iteracji](ca5387.md)|Ta reguła sprawdza, czy klucz kryptograficzny został wygenerowany przy <xref:System.Security.Cryptography.Rfc2898DeriveBytes> użyciu liczby iteracji mniejszej niż 100 000. Wyższa liczba iteracji może pomóc wyeliminować ataki słownikowe próbujące złamać wygenerowany klucz kryptograficzny.|
|[CA5388: Używając funkcji wyprowadzania klucza słabego, upewnij się, że istnieje wystarczająca liczba iteracji](ca5388.md)|Ta reguła sprawdza, czy klucz kryptograficzny został wygenerowany za <xref:System.Security.Cryptography.Rfc2898DeriveBytes> pomocą liczby iteracji, która może być mniejsza niż 100 000. Wyższa liczba iteracji może pomóc wyeliminować ataki słownikowe próbujące złamać wygenerowany klucz kryptograficzny.|
|[CA5389: Nie dodawaj ścieżki elementu archiwum do docelowej ścieżki systemu plików](ca5389.md)|Ścieżka pliku może być względna i może prowadzić do dostępu do systemu plików poza oczekiwaną ścieżką docelową systemu plików, co prowadzi do złośliwych zmian konfiguracji i zdalnego wykonywania kodu za pośrednictwem techniki "Ustal i czekaj".|
|[CA5390: Nie zapisuj klucza szyfrowania na stałe w kodzie](ca5390.md)|Aby algorytm symetryczny był prawidłowy, klucz tajny musi być znany tylko nadawcy i odbiornik. Gdy klucz jest zakodowany, można go łatwo odnaleźć. Nawet przy użyciu skompilowanych plików binarnych, złośliwi użytkownicy mogą łatwo go wyodrębnić. Po naruszeniu zabezpieczeń klucza prywatnego tekst szyfru można odszyfrować bezpośrednio i nie jest już chroniony.|
|[CA5391: Użyj tokenów zabezpieczających przed fałszerstwem w kontrolerach MVC platformy ASP.NET Core](ca5391.md)|Obsługa `POST` , `PUT` , `PATCH` , lub `DELETE` żądanie bez weryfikowania tokenu antysfałszowanego może być narażona na ataki fałszerstwa żądań między lokacjami. Atakujący sfałszowanie żądań między lokacjami może wysyłać złośliwych żądań od uwierzytelnionego użytkownika do kontrolera ASP.NET Core MVC.|
|[CA5392: Użyj atrybutu DefaultDllImportSearchPaths dla elementów P/Invoke](ca5392.md)|Domyślnie funkcja P/Invoke korzysta z <xref:System.Runtime.InteropServices.DllImportAttribute> sondowania wielu katalogów, w tym bieżącego katalogu roboczego biblioteki do załadowania. Może to być problem z zabezpieczeniami dla niektórych aplikacji, co prowadzi do przejęcia biblioteki DLL.|
|[CA5393: Nie używaj niebezpiecznej wartości DllImportSearchPath](ca5393.md)|Może istnieć złośliwa Biblioteka DLL w domyślnych katalogach wyszukiwania bibliotek DLL i katalogach zestawów. Lub, w zależności od tego, gdzie jest uruchomiona aplikacja, może istnieć złośliwa Biblioteka DLL w katalogu aplikacji.|
|[CA5394: Nie używaj niezabezpieczonej losowości](ca5394.md)|Użycie kryptografii z kryptograficznie słabym generatorem liczb losowych może pozwolić osobie atakującej na przewidywalność wygenerowania wartości z uwzględnieniem zabezpieczeń.|
|[CA5395: Pomiń atrybut HttpVerb dla metod akcji](ca5395.md)|Wszystkie metody akcji, które tworzą, edytują, usuwają lub w inny sposób modyfikują dane, muszą być chronione przy użyciu atrybutu antysfałszowanego z ataków fałszerstwa żądań między lokacjami. Wykonanie operacji GET powinno być bezpieczną operacją, która nie ma efektów ubocznych i nie modyfikuje utrwalonych danych.|
|[CA5396: Ustaw element HttpOnly na wartość true dla elementu HttpCookie](ca5396.md)|W celu zapewnienia kompleksowej oceny należy zapewnić, że poufne pliki cookie HTTP są oznaczane jako HttpOnly. Oznacza to, że przeglądarki sieci Web powinny uniemożliwić uzyskiwanie dostępu do plików cookie przez skrypty. Wprowadzane złośliwe skrypty są typowym sposobem kradzieży plików cookie.|
|[CA5397: Nie używaj przestarzałych wartości SslProtocols](ca5397.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Starsze wersje protokołu TLS są mniej bezpieczne niż TLS 1,2 i TLS 1,3 i coraz bardziej mogą mieć nowe luki w zabezpieczeniach. Unikaj stosowania starszych wersji protokołów, aby zminimalizować ryzyko.|
|[CA5398: Unikaj zapisanych na stałe wartości SslProtocols](ca5398.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Protokół TLS 1,0 i TLS 1,1 są przestarzałe, podczas gdy protokoły TLS 1,2 i TLS 1,3 są aktualne. W przyszłości protokoły TLS 1,2 i TLS 1,3 mogą być przestarzałe. Aby upewnić się, że aplikacja pozostaje zabezpieczona, należy unikać zakodowana wersji protokołu.|
|[CA5399: Ostatecznie wyłącz sprawdzenie listy odwołań certyfikatów programu HttpClient](ca5399.md)|Odwołany certyfikat nie jest już zaufany. Mogą one być używane przez osoby atakujące, które przechodzą z pewnych złośliwych danych lub kradzieży poufnych danych w komunikacji przy użyciu protokołu HTTPS.|
|[CA5400: Upewnij się, że sprawdzenie listy odwołań certyfikatów programu HttpClient nie jest wyłączone](ca5400.md)|Odwołany certyfikat nie jest już zaufany. Mogą one być używane przez osoby atakujące, które przechodzą z pewnych złośliwych danych lub kradzieży poufnych danych w komunikacji przy użyciu protokołu HTTPS.|
|[CA5401: Nie używaj metody CreateEncryptor w wektorem inicjowania innym niż domyślny](ca5401.md)|Szyfrowanie symetryczne powinno zawsze używać niepowtarzalnych wektorów inicjalizacji, aby zapobiec atakom słownikowym.|
|[CA5402: Użyj metody CreateEncryptor z domyślnym wektorem inicjowania](ca5402.md)|Szyfrowanie symetryczne powinno zawsze używać niepowtarzalnych wektorów inicjalizacji, aby zapobiec atakom słownikowym.|
|[CA5403: Nie zapisuj certyfikatu na stałe w kodzie](ca5403.md)|`data`Parametr lub `rawData` <xref:System.Security.Cryptography.X509Certificates.X509Certificate> <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> konstruktora or jest zakodowany na stałe.|
