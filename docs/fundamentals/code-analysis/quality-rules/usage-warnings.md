---
title: Reguły użycia (analiza kodu)
description: Dowiedz się więcej na temat reguł użycia analizy kodu.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8b14d2f92502d5a82e41a322e599745bdcf8b85
ms.sourcegitcommit: a6bd4cad438fe479cbd112eae10f2cd449f06e40
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/08/2020
ms.locfileid: "96589648"
---
# <a name="usage-rules"></a><span data-ttu-id="d100f-103">Reguły użycia</span><span class="sxs-lookup"><span data-stu-id="d100f-103">Usage rules</span></span>

<span data-ttu-id="d100f-104">Reguły użycia obsługują poprawne użycie platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="d100f-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="d100f-105">W tej sekcji</span><span class="sxs-lookup"><span data-stu-id="d100f-105">In this section</span></span>

|<span data-ttu-id="d100f-106">Reguła</span><span class="sxs-lookup"><span data-stu-id="d100f-106">Rule</span></span>|<span data-ttu-id="d100f-107">Opis</span><span class="sxs-lookup"><span data-stu-id="d100f-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="d100f-108">CA1801: Dokonaj przeglądu nieużywanych parametrów</span><span class="sxs-lookup"><span data-stu-id="d100f-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="d100f-109">Podpis metody zawiera parametr, który nie jest używany w jej treści.</span><span class="sxs-lookup"><span data-stu-id="d100f-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="d100f-110">CA1816: Poprawnie wywołaj metodę GC.SuppressFinalize</span><span class="sxs-lookup"><span data-stu-id="d100f-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="d100f-111">Metoda, która jest implementacją metody Dispose, nie wywołuje `GC.SuppressFinalize` metody lub metoda, która nie jest implementacją `Dispose` wywołań `GC.SuppressFinalize` ; lub metoda wywołuje `GC.SuppressFinalize` i przekazuje coś innego niż `this` ( `Me` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d100f-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="d100f-112">CA2200: Ponowie zgłoś wyjątek, aby zachować szczegóły stosu</span><span class="sxs-lookup"><span data-stu-id="d100f-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="d100f-113">Wyjątek jest zgłaszany ponownie i jest on jawnie określony w instrukcji „throw”.</span><span class="sxs-lookup"><span data-stu-id="d100f-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="d100f-114">Jeśli wyjątek jest zgłaszany ponownie przez określenie wyjątku w instrukcji „throw”, lista wywołań metod między pierwotną metodą, która zgłosiła wyjątek, a bieżącą zostanie utracona.</span><span class="sxs-lookup"><span data-stu-id="d100f-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="d100f-115">CA2201: Nie zgłaszaj wyjątków o zastrzeżonych typach</span><span class="sxs-lookup"><span data-stu-id="d100f-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="d100f-116">Powoduje to, że oryginalny błąd trudno wykryć i debugować.</span><span class="sxs-lookup"><span data-stu-id="d100f-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="d100f-117">CA2207: Pola statyczne typu wartości inicjuj bezpośrednio</span><span class="sxs-lookup"><span data-stu-id="d100f-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="d100f-118">Typ wartości deklaruje jawny, statyczny konstruktor.</span><span class="sxs-lookup"><span data-stu-id="d100f-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="d100f-119">Aby naprawić naruszenie tej zasady, zainicjuj wszystkie dane statyczne, gdy jest on zadeklarowany, i usuń konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="d100f-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="d100f-120">CA2208: Poprawnie twórz wystąpienia wyjątków argumentów</span><span class="sxs-lookup"><span data-stu-id="d100f-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="d100f-121">Wywołanie odnosi się do domyślnego (bezparametrowego) konstruktora typu wyjątku, który jest elementem ArgumentException lub od niego pochodzi, albo niepoprawny argument ciągu jest przekazywany do sparametryzowania konstruktora typu wyjątku lub pochodzi od elementu ArgumentException.</span><span class="sxs-lookup"><span data-stu-id="d100f-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="d100f-122">CA2211: Pola niebędące stałymi nie powinny być widoczne</span><span class="sxs-lookup"><span data-stu-id="d100f-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="d100f-123">Pola statyczne, które nie są stałymi lub tylko do odczytu, nie są bezpieczne wątkowo.</span><span class="sxs-lookup"><span data-stu-id="d100f-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="d100f-124">Dostęp do takiego pola musi być starannie kontrolowany i wymaga zaawansowanych technik programowania do synchronizowania dostępu do obiektu klasy.</span><span class="sxs-lookup"><span data-stu-id="d100f-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="d100f-125">CA2213: Pola możliwe do likwidacji należy likwidować</span><span class="sxs-lookup"><span data-stu-id="d100f-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="d100f-126">Typ, który implementuje <xref:System.IDisposable?displayProperty=fullName> deklarowane pola, które są typu, które również implementują `IDisposable` .</span><span class="sxs-lookup"><span data-stu-id="d100f-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="d100f-127">`Dispose`Metoda pola nie jest wywoływana przez `Dispose` metodę typu deklarującego.</span><span class="sxs-lookup"><span data-stu-id="d100f-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="d100f-128">CA2214: Nie wywołuj w konstruktorach metod, które można przesłaniać</span><span class="sxs-lookup"><span data-stu-id="d100f-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="d100f-129">Gdy Konstruktor wywołuje metodę wirtualną, istnieje możliwość, że Konstruktor wystąpienia, który wywołuje metodę, nie został wykonany.</span><span class="sxs-lookup"><span data-stu-id="d100f-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="d100f-130">CA2215: Metody Dispose powinny wywoływać metodę Dispose klasy bazowej</span><span class="sxs-lookup"><span data-stu-id="d100f-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="d100f-131">Jeśli typ dziedziczy z typu jednorazowego, musi wywołać `Dispose` metodę typu podstawowego z własnej `Dispose` metody.</span><span class="sxs-lookup"><span data-stu-id="d100f-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="d100f-132">CA2216: Typy możliwe do likwidacji powinny deklarować finalizator</span><span class="sxs-lookup"><span data-stu-id="d100f-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="d100f-133">Typ, który implementuje <xref:System.IDisposable?displayProperty=fullName> i ma pola, które sugerują użycie niezarządzanych zasobów, nie implementuje finalizatora, zgodnie z opisem przez `Object.Finalize` .</span><span class="sxs-lookup"><span data-stu-id="d100f-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="d100f-134">CA2217: Nie oznaczaj typów wyliczeniowych atrybutem Flags</span><span class="sxs-lookup"><span data-stu-id="d100f-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="d100f-135">Widoczne na zewnątrz Wyliczenie jest oznaczone `FlagsAttribute` i ma co najmniej jedną wartość, która nie ma uprawnień dwóch lub kombinacji innych zdefiniowanych wartości w wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="d100f-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="d100f-136">CA2218: Przesłaniaj metodę GetHashCode w razie przesłaniania metody Equals</span><span class="sxs-lookup"><span data-stu-id="d100f-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="d100f-137">Typ publiczny przesłania, <xref:System.Object.Equals%2A?displayProperty=fullName> ale nie przesłania <xref:System.Object.GetHashCode%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="d100f-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="d100f-138">CA2219: Nie zgłaszaj wyjątków w klauzulach wyjątków</span><span class="sxs-lookup"><span data-stu-id="d100f-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="d100f-139">Kiedy wyjątek jest zgłaszany w klauzuli „finally” lub „fault”, nowy wyjątek ukrywa aktywny wyjątek.</span><span class="sxs-lookup"><span data-stu-id="d100f-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="d100f-140">Gdy wyjątek jest zgłaszany w klauzuli „filter”, środowisko uruchomieniowe dyskretnie przechwytuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="d100f-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="d100f-141">Powoduje to, że oryginalny błąd trudno wykryć i debugować.</span><span class="sxs-lookup"><span data-stu-id="d100f-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="d100f-142">CA2224: Przesłaniaj metodę equals w przypadku przeciążania operatora równości</span><span class="sxs-lookup"><span data-stu-id="d100f-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="d100f-143">Typ publiczny implementuje operator równości, ale nie przesłania <xref:System.Object.Equals%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="d100f-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="d100f-144">CA2225: Przeciążenia operatorów mają nazwane elementy alternatywne</span><span class="sxs-lookup"><span data-stu-id="d100f-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="d100f-145">Wykryto przeciążony operator i nie znaleziono metody alternatywnej o oczekiwanej nazwie.</span><span class="sxs-lookup"><span data-stu-id="d100f-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="d100f-146">Nazwany alternatywny element członkowski zapewnia dostęp do tych samych funkcji co operator i jest udostępniany deweloperom programu w językach, które nie obsługują przeciążonych operatorów.</span><span class="sxs-lookup"><span data-stu-id="d100f-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="d100f-147">CA2226: Operatory powinny mieć symetryczne przeciążenia</span><span class="sxs-lookup"><span data-stu-id="d100f-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="d100f-148">Typ implementuje operator równości lub nierówności i nie implementuje operatora przeciwległego.</span><span class="sxs-lookup"><span data-stu-id="d100f-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="d100f-149">CA2227: Właściwości kolekcji powinny być tylko do odczytu</span><span class="sxs-lookup"><span data-stu-id="d100f-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="d100f-150">Właściwość zapisywalnej kolekcji pozwala użytkownikowi zastąpić kolekcję inną kolekcją.</span><span class="sxs-lookup"><span data-stu-id="d100f-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="d100f-151">Właściwość tylko do odczytu uniemożliwia zastępowanie kolekcji, ale nadal umożliwia ustawienie poszczególnych członków.</span><span class="sxs-lookup"><span data-stu-id="d100f-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="d100f-152">CA2229: Zaimplementuj konstruktory serializacji</span><span class="sxs-lookup"><span data-stu-id="d100f-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="d100f-153">Aby naprawić naruszenie tej zasady, należy zaimplementować konstruktora serializacji.</span><span class="sxs-lookup"><span data-stu-id="d100f-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="d100f-154">Dla zamkniętej klasy należy ustawić konstruktor prywatny; w przeciwnym razie powinien być chroniony.</span><span class="sxs-lookup"><span data-stu-id="d100f-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="d100f-155">CA2231: Przeciążaj operator równości w przypadku przesłaniania metody ValueType.Equals</span><span class="sxs-lookup"><span data-stu-id="d100f-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="d100f-156">Typ wartości przesłania `Object.Equals` , ale nie implementuje operatora równości.</span><span class="sxs-lookup"><span data-stu-id="d100f-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="d100f-157">CA2234: Przekazuj obiekty System.Uri zamiast ciągów</span><span class="sxs-lookup"><span data-stu-id="d100f-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="d100f-158">Wykonano wywołanie do metody, która ma parametr typu ciąg, którego nazwa zawiera „uri”, „URI”, „urn”, „URN”, „url” lub „URL”.</span><span class="sxs-lookup"><span data-stu-id="d100f-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="d100f-159">Typ deklarujący metody zawiera odpowiadające Przeciążenie metody z <xref:System.Uri?displayProperty=fullName> parametrem.</span><span class="sxs-lookup"><span data-stu-id="d100f-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="d100f-160">CA2235: Oznacz wszystkie pola nieprzeznaczone do serializacji</span><span class="sxs-lookup"><span data-stu-id="d100f-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="d100f-161">Pola wystąpienia typu, który nie może być serializowany, jest zadeklarowany w typie, który jest możliwy do serializacji.</span><span class="sxs-lookup"><span data-stu-id="d100f-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="d100f-162">CA2237: Oznacz typy ISerializable atrybutem SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="d100f-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="d100f-163">Aby można było rozpoznać przez środowisko uruchomieniowe języka wspólnego jako możliwy do serializacji, typy muszą być oznaczone atrybutem SerializableAttribute, nawet jeśli typ używa niestandardowej procedury serializacji za pośrednictwem implementacji `ISerializable` interfejsu.</span><span class="sxs-lookup"><span data-stu-id="d100f-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="d100f-164">CA2241: Podaj poprawne argumenty metod formatowania</span><span class="sxs-lookup"><span data-stu-id="d100f-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="d100f-165">Argument formatu przesłany do <xref:System.String.Format%2A?displayProperty=nameWithType> nie zawiera elementu formatu, który odnosi się do każdego argumentu obiektu lub odwrotnie.</span><span class="sxs-lookup"><span data-stu-id="d100f-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="d100f-166">CA2242: Poprawnie testuj nie-liczby (NaN)</span><span class="sxs-lookup"><span data-stu-id="d100f-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="d100f-167">To wyrażenie służy do testowania wartości w odniesieniu do `Single.Nan` lub `Double.Nan` .</span><span class="sxs-lookup"><span data-stu-id="d100f-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="d100f-168">Użyj `Single.IsNan(Single)` lub, `Double.IsNan(Double)` Aby przetestować wartość.</span><span class="sxs-lookup"><span data-stu-id="d100f-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="d100f-169">CA2243: Analiza literałów ciągów atrybutów powinna przebiegać poprawnie</span><span class="sxs-lookup"><span data-stu-id="d100f-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="d100f-170">Parametr literału ciągu atrybutu nie jest analizowany poprawnie dla adresu URL, identyfikatora GUID lub wersji.</span><span class="sxs-lookup"><span data-stu-id="d100f-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="d100f-171">CA2244: Nie duplikuj inicjowania indeksowanych elementów</span><span class="sxs-lookup"><span data-stu-id="d100f-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="d100f-172">Inicjator obiektu ma więcej niż jeden indeks elementu indeksowanego z tym samym indeksem stałym.</span><span class="sxs-lookup"><span data-stu-id="d100f-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="d100f-173">Wszystkie oprócz ostatniego inicjatora są nadmiarowe.</span><span class="sxs-lookup"><span data-stu-id="d100f-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="d100f-174">CA2245: Nie przypisuj właściwości do jej samej</span><span class="sxs-lookup"><span data-stu-id="d100f-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="d100f-175">Właściwość została przypadkowo przypisana do samej siebie.</span><span class="sxs-lookup"><span data-stu-id="d100f-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="d100f-176">CA2246: Nie przypisuj symbolu i jego składowej w tej samej instrukcji</span><span class="sxs-lookup"><span data-stu-id="d100f-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="d100f-177">Przypisanie symbolu i jego elementu członkowskiego, czyli pola lub właściwości, w tej samej instrukcji nie jest zalecane.</span><span class="sxs-lookup"><span data-stu-id="d100f-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="d100f-178">Nie jest jasne, jeśli dostęp do elementu członkowskiego był przeznaczony do użycia starej wartości symbolu przed przypisaniem lub nową wartością z przypisania w tej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d100f-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="d100f-179">CA2247: Argument przekazany do konstruktora TaskCompletionSource musi być wyliczeniem TaskCreationOptions, a nie wyliczeniem TaskContinuationOptions</span><span class="sxs-lookup"><span data-stu-id="d100f-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2246.md)|<span data-ttu-id="d100f-180">TaskCompletionSource ma konstruktory, które przyjmują opcji TaskCreationOptions, które kontrolują podstawowe zadanie, i konstruktorów, które przyjmują stan obiektu, który jest przechowywany w zadaniu.</span><span class="sxs-lookup"><span data-stu-id="d100f-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="d100f-181">Przypadkowe przekazanie TaskContinuationOptions zamiast opcji TaskCreationOptions spowoduje wywołanie opcji jako stanu.</span><span class="sxs-lookup"><span data-stu-id="d100f-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="d100f-182">CA2248: Podaj poprawny argument "enum" dla elementu "enum. HasFlag"</span><span class="sxs-lookup"><span data-stu-id="d100f-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="d100f-183">Typ wyliczeniowy przesłany jako argument `HasFlag` wywołania metody różni się od typu wyliczeniowego wywołującego.</span><span class="sxs-lookup"><span data-stu-id="d100f-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="d100f-184">CA2249: Rozważ użycie metody String.Contains zamiast String.IndexOf</span><span class="sxs-lookup"><span data-stu-id="d100f-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="d100f-185">Wywołania, do `string.IndexOf` których wynik służy do sprawdzania obecności lub braku podciągu, mogą zostać zastąpione przez `string.Contains` .</span><span class="sxs-lookup"><span data-stu-id="d100f-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
