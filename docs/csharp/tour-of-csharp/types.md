---
title: 'Definiowanie typów i ich członków — Przewodnik po języku C #'
description: Bloki konstrukcyjne programów są typami. Dowiedz się, jak tworzyć klasy, struktury, interfejsy i inne w języku C#.
ms.date: 08/06/2020
ms.openlocfilehash: 69d6f0fe1e11f287fb5e385761fc210a61929d10
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/11/2020
ms.locfileid: "88068546"
---
# <a name="types-and-members"></a><span data-ttu-id="9cd82-104">Typy i elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="9cd82-104">Types and members</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="9cd82-105">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="9cd82-105">Classes and objects</span></span>

<span data-ttu-id="9cd82-106">*Klasy* są najbardziej podstawą typów języka C#.</span><span class="sxs-lookup"><span data-stu-id="9cd82-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="9cd82-107">Klasa jest strukturą danych, która łączy stan (pola) i akcje (metody i inne elementy członkowskie funkcji) w jednej jednostce.</span><span class="sxs-lookup"><span data-stu-id="9cd82-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="9cd82-108">Klasa zawiera definicję dla *wystąpień* klasy, znane także jako *obiekty*.</span><span class="sxs-lookup"><span data-stu-id="9cd82-108">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="9cd82-109">Klasy obsługują *dziedziczenie* i *polimorfizm*, natomiast mechanizmy, w których *klasy pochodne* mogą poszerzać i specjalizację *klas bazowych*.</span><span class="sxs-lookup"><span data-stu-id="9cd82-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="9cd82-110">Nowe klasy są tworzone za pomocą deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="9cd82-110">New classes are created using class declarations.</span></span> <span data-ttu-id="9cd82-111">Deklaracja klasy zaczyna się od nagłówka.</span><span class="sxs-lookup"><span data-stu-id="9cd82-111">A class declaration starts with a header.</span></span> <span data-ttu-id="9cd82-112">Nagłówek określa:</span><span class="sxs-lookup"><span data-stu-id="9cd82-112">The header specifies:</span></span>

- <span data-ttu-id="9cd82-113">Atrybuty i Modyfikatory klasy</span><span class="sxs-lookup"><span data-stu-id="9cd82-113">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="9cd82-114">Nazwa klasy</span><span class="sxs-lookup"><span data-stu-id="9cd82-114">The name of the class</span></span>
- <span data-ttu-id="9cd82-115">Klasa bazowa (w przypadku dziedziczenia z [klasy bazowej](#base-classes))</span><span class="sxs-lookup"><span data-stu-id="9cd82-115">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="9cd82-116">Interfejsy implementowane przez klasę.</span><span class="sxs-lookup"><span data-stu-id="9cd82-116">The interfaces implemented by the class.</span></span>

<span data-ttu-id="9cd82-117">Po tym nagłówku następuje treść klasy, która składa się z listy deklaracji elementów członkowskich, które są zapisywane między ogranicznikami `{` i `}` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-117">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="9cd82-118">Poniższy kod przedstawia deklarację prostej klasy o nazwie `Point` :</span><span class="sxs-lookup"><span data-stu-id="9cd82-118">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="9cd82-119">Wystąpienia klas są tworzone przy użyciu `new` operatora, który przydziela pamięć dla nowego wystąpienia, wywołuje konstruktora w celu zainicjowania wystąpienia i zwraca odwołanie do wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cd82-119">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="9cd82-120">Poniższe instrukcje tworzą dwa `Point` obiekty i przechowują odwołania do tych obiektów w dwóch zmiennych:</span><span class="sxs-lookup"><span data-stu-id="9cd82-120">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="9cd82-121">Pamięć zajęta przez obiekt jest automatycznie odzyskiwana, gdy obiekt nie jest już dostępny.</span><span class="sxs-lookup"><span data-stu-id="9cd82-121">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="9cd82-122">Nie jest to konieczne ani możliwe, aby jawnie cofnąć alokację obiektów w języku C#.</span><span class="sxs-lookup"><span data-stu-id="9cd82-122">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="9cd82-123">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="9cd82-123">Type parameters</span></span>

<span data-ttu-id="9cd82-124">Klasy ogólne definiują [***parametry typu***](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="9cd82-124">Generic classes define [***type parameters***](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="9cd82-125">Parametry typu są lista nazw parametrów typu ujętych w nawiasy ostre.</span><span class="sxs-lookup"><span data-stu-id="9cd82-125">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="9cd82-126">Parametry typu są zgodne z nazwą klasy.</span><span class="sxs-lookup"><span data-stu-id="9cd82-126">Type parameters follow the class name.</span></span> <span data-ttu-id="9cd82-127">Parametry typu mogą być następnie używane w treści deklaracji klasy do definiowania elementów członkowskich klasy.</span><span class="sxs-lookup"><span data-stu-id="9cd82-127">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="9cd82-128">W poniższym przykładzie parametry typu `Pair` są `TFirst` i `TSecond` :</span><span class="sxs-lookup"><span data-stu-id="9cd82-128">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="9cd82-129">Typ klasy zadeklarowanej do wykonania parametrów typu jest nazywany *typem klasy generycznej*.</span><span class="sxs-lookup"><span data-stu-id="9cd82-129">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="9cd82-130">Typy struktur, interfejsów i delegatów mogą być również rodzajowe.</span><span class="sxs-lookup"><span data-stu-id="9cd82-130">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="9cd82-131">Gdy używana jest Klasa generyczna, należy podać argumenty typu dla każdego z parametrów typu:</span><span class="sxs-lookup"><span data-stu-id="9cd82-131">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="9cd82-132">Typ ogólny z podanymi argumentami typu, jak `Pair<int,string>` powyżej, jest nazywany *typem skonstruowanym*.</span><span class="sxs-lookup"><span data-stu-id="9cd82-132">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="9cd82-133">Klas podstawowych</span><span class="sxs-lookup"><span data-stu-id="9cd82-133">Base classes</span></span>

<span data-ttu-id="9cd82-134">Deklaracja klasy może określać klasę bazową.</span><span class="sxs-lookup"><span data-stu-id="9cd82-134">A class declaration may specify a base class.</span></span> <span data-ttu-id="9cd82-135">Postępuj według nazwy klasy i parametrów typu z dwukropkiem i nazwą klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cd82-135">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="9cd82-136">Pominięcie specyfikacji klasy bazowej jest taka sama jak pochodna typu `object` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-136">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="9cd82-137">W poniższym przykładzie klasą bazową `Point3D` jest `Point` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-137">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="9cd82-138">Z pierwszego przykładu klasą bazową `Point` jest `object` :</span><span class="sxs-lookup"><span data-stu-id="9cd82-138">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="9cd82-139">Klasa dziedziczy elementy członkowskie swojej klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cd82-139">A class inherits the members of its base class.</span></span> <span data-ttu-id="9cd82-140">Dziedziczenie oznacza, że Klasa niejawnie zawiera prawie wszystkich członków swojej klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="9cd82-140">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="9cd82-141">Klasa nie dziedziczy wystąpienia i konstruktorów statycznych i finalizatora.</span><span class="sxs-lookup"><span data-stu-id="9cd82-141">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="9cd82-142">Klasa pochodna może dodawać nowych członków do tych elementów, które dziedziczy, ale nie może usunąć definicji dziedziczonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cd82-142">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="9cd82-143">W poprzednim przykładzie `Point3D` dziedziczy `X` i `Y` składowe z `Point` , a każde `Point3D` wystąpienie zawiera trzy właściwości, `X` , `Y` , i `Z` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-143">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="9cd82-144">Niejawna konwersja istnieje z typu klasy do dowolnego z jego typów klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="9cd82-144">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="9cd82-145">Zmienna typu klasy może odwoływać się do wystąpienia tej klasy lub wystąpienia dowolnej klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="9cd82-145">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="9cd82-146">Na przykład uwzględniając poprzednie deklaracje klas, zmienna typu `Point` może odwoływać się do `Point` lub `Point3D` :</span><span class="sxs-lookup"><span data-stu-id="9cd82-146">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="9cd82-147">Struktury</span><span class="sxs-lookup"><span data-stu-id="9cd82-147">Structs</span></span>

<span data-ttu-id="9cd82-148">Klasy definiują typy obsługujące dziedziczenie i polimorfizm.</span><span class="sxs-lookup"><span data-stu-id="9cd82-148">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="9cd82-149">Umożliwiają one tworzenie zaawansowanych zachowań opartych na hierarchiach klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="9cd82-149">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="9cd82-150">Z kolei typy [***struktur***](../language-reference/builtin-types/struct.md) są prostszymi typami, których głównym celem jest przechowywanie wartości danych.</span><span class="sxs-lookup"><span data-stu-id="9cd82-150">By contrast, [***struct***](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="9cd82-151">Struktury nie mogą deklarować typu podstawowego; niejawnie pochodzą od <xref:System.ValueType?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="9cd82-151">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cd82-152">Nie można wyprowadzić innych `struct` typów z `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="9cd82-152">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="9cd82-153">Są one niejawnie zapieczętowane.</span><span class="sxs-lookup"><span data-stu-id="9cd82-153">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="9cd82-154">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="9cd82-154">Interfaces</span></span>

<span data-ttu-id="9cd82-155">[***Interfejs***](../programming-guide/interfaces/index.md) definiuje kontrakt, który może być zaimplementowany przez klasy i struktury.</span><span class="sxs-lookup"><span data-stu-id="9cd82-155">An [***interface***](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="9cd82-156">Interfejs może zawierać metody, właściwości, zdarzenia i indeksatory.</span><span class="sxs-lookup"><span data-stu-id="9cd82-156">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="9cd82-157">Interfejs zazwyczaj nie dostarcza implementacji elementów członkowskich, które definiuje — tylko określa elementy członkowskie, które muszą być dostarczone przez klasy lub struktury, które implementują interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cd82-157">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="9cd82-158">Interfejsy mogą wykorzystywać ***wielokrotne dziedziczenie***.</span><span class="sxs-lookup"><span data-stu-id="9cd82-158">Interfaces may employ ***multiple inheritance***.</span></span> <span data-ttu-id="9cd82-159">W poniższym przykładzie interfejs `IComboBox` dziedziczy z obu `ITextBox` i `IListBox` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-159">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="9cd82-160">Klasy i struktury mogą implementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="9cd82-160">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="9cd82-161">W poniższym przykładzie Klasa `EditBox` implementuje zarówno `IControl` , jak i `IDataBound` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-161">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="9cd82-162">Gdy Klasa lub struktura implementuje określony interfejs, wystąpienia tej klasy lub struktury mogą być niejawnie konwertowane na typ tego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cd82-162">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="9cd82-163">Na przykład</span><span class="sxs-lookup"><span data-stu-id="9cd82-163">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="9cd82-164">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="9cd82-164">Enums</span></span>

<span data-ttu-id="9cd82-165">Typ [***wyliczeniowy***](../language-reference/builtin-types/enum.md) definiuje zestaw wartości stałych.</span><span class="sxs-lookup"><span data-stu-id="9cd82-165">An [***Enum***](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="9cd82-166">Poniżej `enum` deklarują stałe, które definiują różne warzywa główne:</span><span class="sxs-lookup"><span data-stu-id="9cd82-166">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="9cd82-167">Można również zdefiniować element, `enum` który będzie używany w kombinacji jako flagi.</span><span class="sxs-lookup"><span data-stu-id="9cd82-167">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="9cd82-168">Poniższa deklaracja deklaruje zestaw flag dla czterech sezonów.</span><span class="sxs-lookup"><span data-stu-id="9cd82-168">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="9cd82-169">Można zastosować dowolną kombinację sezonów, w tym `All` wartość obejmującą wszystkie pory roku:</span><span class="sxs-lookup"><span data-stu-id="9cd82-169">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="9cd82-170">W poniższym przykładzie przedstawiono deklaracje obu powyższych typów wyliczeniowych:</span><span class="sxs-lookup"><span data-stu-id="9cd82-170">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="9cd82-171">Typy dopuszczające wartości null</span><span class="sxs-lookup"><span data-stu-id="9cd82-171">Nullable types</span></span>

<span data-ttu-id="9cd82-172">Zmienne dowolnego typu mogą być deklarowane jako ***niedopuszczające wartości null*** lub ***dopuszczające wartości null***.</span><span class="sxs-lookup"><span data-stu-id="9cd82-172">Variables of any type may be declared as ***non-nullable*** or ***nullable***.</span></span> <span data-ttu-id="9cd82-173">Zmienna dopuszczający wartości null może zawierać dodatkową `null` wartość wskazującą brak wartości.</span><span class="sxs-lookup"><span data-stu-id="9cd82-173">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="9cd82-174">Typy wartości null (struktury lub wyliczenia) są reprezentowane przez <xref:System.Nullable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="9cd82-174">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cd82-175">Typy referencyjne niedopuszczające wartości null i dopuszczające wartość null są reprezentowane przez odpowiedni typ referencyjny.</span><span class="sxs-lookup"><span data-stu-id="9cd82-175">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="9cd82-176">Rozróżnienie jest reprezentowane przez metadane odczytywane przez kompilator i niektóre biblioteki.</span><span class="sxs-lookup"><span data-stu-id="9cd82-176">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="9cd82-177">Kompilator zawiera ostrzeżenia, gdy odwołania do wartości null są wyłączane bez uprzedniego sprawdzenia ich wartości `null` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-177">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="9cd82-178">Kompilator zawiera również ostrzeżenia, gdy odwołania niedopuszczające wartości null są przypisywane do wartości, która może być `null` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-178">The compiler also provides warnings when non-nullable references are assigned to a value that may be `null`.</span></span> <span data-ttu-id="9cd82-179">Poniższy przykład deklaruje ***wartość null int***, inicjując ją do `null` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-179">The following example declares a ***nullable int***, initializing it to `null`.</span></span> <span data-ttu-id="9cd82-180">Następnie ustawia wartość na `5` .</span><span class="sxs-lookup"><span data-stu-id="9cd82-180">Then, it sets the value to `5`.</span></span> <span data-ttu-id="9cd82-181">Pokazuje to samo pojęcie z ***niezerowym ciągiem***.</span><span class="sxs-lookup"><span data-stu-id="9cd82-181">It demonstrates the same concept with a ***nullable string***.</span></span> <span data-ttu-id="9cd82-182">Aby uzyskać więcej informacji, zobacz [typy wartości null](../language-reference/builtin-types/nullable-value-types.md) i [typy referencyjne dopuszczające wartość null](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="9cd82-182">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="9cd82-183">Krotki</span><span class="sxs-lookup"><span data-stu-id="9cd82-183">Tuples</span></span>

<span data-ttu-id="9cd82-184">C# obsługuje [***krotki***](../language-reference/builtin-types/value-tuples.md), które zapewniają zwięzłą składnię do grupowania wielu elementów danych w lekkiej strukturze danych.</span><span class="sxs-lookup"><span data-stu-id="9cd82-184">C# supports [***tuples***](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="9cd82-185">Tworzysz wystąpienie krotki przez zadeklarowanie typów i nazw członków między `(` i `)` , jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="9cd82-185">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="9cd82-186">Krotki zapewniają alternatywę dla struktury danych z wieloma elementami członkowskimi, bez używania bloków konstrukcyjnych opisanych w następnym artykule.</span><span class="sxs-lookup"><span data-stu-id="9cd82-186">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9cd82-187">[Poprzedni](index.md) 
> [Dalej](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="9cd82-187">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
