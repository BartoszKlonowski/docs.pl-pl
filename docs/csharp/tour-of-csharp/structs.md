---
title: C# struktur — Przewodnik po przykładzie w języku C#
description: Dowiedz się, że podstawy języka C# wartości typów nazywanych struktury
ms.date: 08/10/2016
ms.assetid: 88a74571-f741-4a31-a2b5-1ccf165535b8
ms.openlocfilehash: 6b165dd040213b33f91d1baf1b0fb4909101666d
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/10/2018
ms.locfileid: "53142739"
---
# <a name="structs"></a><span data-ttu-id="cee22-103">Struktury</span><span class="sxs-lookup"><span data-stu-id="cee22-103">Structs</span></span>

<span data-ttu-id="cee22-104">Takie jak klasy, ***struktury*** są struktur danych, które mogą zawierać elementy członkowskie danych i składowe funkcji, ale w przeciwieństwie do klasy, struktury są typami wartości i nie wymagają alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="cee22-104">Like classes, ***structs*** are data structures that can contain data members and function members, but unlike classes, structs are value types and do not require heap allocation.</span></span> <span data-ttu-id="cee22-105">Zmienną typu struktury bezpośrednio przechowuje dane struktury, natomiast zmienna typu klasa przechowuje odwołania do obiektu przydzielanego dynamicznie.</span><span class="sxs-lookup"><span data-stu-id="cee22-105">A variable of a struct type directly stores the data of the struct, whereas a variable of a class type stores a reference to a dynamically allocated object.</span></span> <span data-ttu-id="cee22-106">Typy struktury nie obsługują dziedziczenia określonych przez użytkownika, a wszystkie typy struktury niejawnie dziedziczą z typu <xref:System.ValueType>, który z kolei niejawnie dziedziczy `object`.</span><span class="sxs-lookup"><span data-stu-id="cee22-106">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <xref:System.ValueType>, which in turn implicitly inherits from `object`.</span></span>

<span data-ttu-id="cee22-107">Struktury są szczególnie przydatne w przypadku małych strukturach danych, które mają semantyki wartości.</span><span class="sxs-lookup"><span data-stu-id="cee22-107">Structs are particularly useful for small data structures that have value semantics.</span></span> <span data-ttu-id="cee22-108">Liczby zespolone, punkty w układzie współrzędnych lub par klucz wartość ze słownika są dobrym przykładem struktury.</span><span class="sxs-lookup"><span data-stu-id="cee22-108">Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs.</span></span> <span data-ttu-id="cee22-109">Używanie struktur, zamiast klasy w małych strukturach danych ułatwia duża różnica w liczbie alokacji pamięci aplikacji wykonuje.</span><span class="sxs-lookup"><span data-stu-id="cee22-109">The use of structs rather than classes for small data structures can make a large difference in the number of memory allocations an application performs.</span></span> <span data-ttu-id="cee22-110">Na przykład następujący program tworzy i inicjuje tablicę 100 punktów.</span><span class="sxs-lookup"><span data-stu-id="cee22-110">For example, the following program creates and initializes an array of 100 points.</span></span> <span data-ttu-id="cee22-111">Za pomocą `Point` implementowany jako klasa, 101 oddzielne obiekty są tworzone — jeden dla macierzy i jeden dla 100 elementów.</span><span class="sxs-lookup"><span data-stu-id="cee22-111">With `Point` implemented as a class, 101 separate objects are instantiated—one for the array and one each for the 100 elements.</span></span>

[!code-csharp[PointClassUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)]

<span data-ttu-id="cee22-112">Alternatywą jest punkt struktury.</span><span class="sxs-lookup"><span data-stu-id="cee22-112">An alternative is to make Point a struct.</span></span>

[!code-csharp[PointStruct](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)]

<span data-ttu-id="cee22-113">Teraz, zostanie uruchomiony tylko jeden obiekt — jeden dla tablicy — i `Point` wystąpienia są przechowywane w tekście w tablicy.</span><span class="sxs-lookup"><span data-stu-id="cee22-113">Now, only one object is instantiated—the one for the array—and the `Point` instances are stored in-line in the array.</span></span>

<span data-ttu-id="cee22-114">Struct — Konstruktorzy są wywoływane przy użyciu `new` operatora, podobne do konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="cee22-114">Struct constructors are invoked with the `new` operator, similar to a class constructor.</span></span> <span data-ttu-id="cee22-115">Jednak zamiast dynamicznej alokacji obiektu w zarządzanym stosie i zwraca odwołanie do niej, Konstruktor struktury po prostu zwraca wartość struct (zwykle znajduje się w lokalizacji tymczasowej na stosie), a ta wartość jest następnie kopiowana gdy jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="cee22-115">But, instead of dynamically allocating an object on the managed heap and returning a reference to it, a struct constructor simply returns the struct value itself (typically in a temporary location on the stack), and this value is then copied as necessary.</span></span>

<span data-ttu-id="cee22-116">W przypadku klas jest możliwe dwóch zmiennych odwoływać się do tego samego obiektu dla operacji na jednej zmiennej miały wpływ na obiekt odwołuje się druga zmienna zatem możliwe.</span><span class="sxs-lookup"><span data-stu-id="cee22-116">With classes, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="cee22-117">Przy użyciu struktury zmienne każda ma własne kopię danych, a nie jest możliwe dla operacji na jednym wpływa na drugi.</span><span class="sxs-lookup"><span data-stu-id="cee22-117">With structs, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span> <span data-ttu-id="cee22-118">Na przykład dane wyjściowe generowane przez następujący fragment kodu zależy od tego, czy punkt znajduje się w klasie lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="cee22-118">For example, the output produced by the following code fragment depends on whether Point is a class or a struct.</span></span>

[!code-csharp[PointUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)]

<span data-ttu-id="cee22-119">Jeśli `Point` jest klasą, dane wyjściowe to 20, ponieważ i b odwoływać się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="cee22-119">If `Point` is a class, the output is 20 because a and b reference the same object.</span></span> <span data-ttu-id="cee22-120">Jeśli punkt jest strukturą, dane wyjściowe to 10, ponieważ przypisanie `a` do `b` tworzona jest kopia wartości, i nie ma wpływu następne przypisanie do tej kopii `a.x`.</span><span class="sxs-lookup"><span data-stu-id="cee22-120">If Point is a struct, the output is 10 because the assignment of `a` to `b` creates a copy of the value, and this copy is unaffected by the subsequent assignment to `a.x`.</span></span>

<span data-ttu-id="cee22-121">W poprzednim przykładzie wyróżniono dwa ograniczenia dotyczące struktury.</span><span class="sxs-lookup"><span data-stu-id="cee22-121">The previous example highlights two of the limitations of structs.</span></span> <span data-ttu-id="cee22-122">Po pierwsze całej strukturze jest to zazwyczaj mniej wydajne niż kopiowanie odwołanie do obiektu, dzięki czemu przekazywanie przypisania i wartość parametru może być bardziej kosztowne przy użyciu struktury niż w przypadku typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="cee22-122">First, copying an entire struct is typically less efficient than copying an object reference, so assignment and value parameter passing can be more expensive with structs than with reference types.</span></span> <span data-ttu-id="cee22-123">Drugi, z wyjątkiem `in`, `ref`, i `out` parametrów, nie jest możliwe do utworzenia odwołania do struktury, która wyklucza ich użycia w różnych sytuacjach.</span><span class="sxs-lookup"><span data-stu-id="cee22-123">Second, except for `in`, `ref`, and `out` parameters, it is not possible to create references to structs, which rules out their usage in a number of situations.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="cee22-124">[Poprzednie](classes-and-objects.md)
>[dalej](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="cee22-124">[Previous](classes-and-objects.md)
[Next](arrays.md)</span></span>