---
title: Przewodnik programowania w języku C# — C#
description: Jesteś nowym w języku C#? Poznaj podstawy języka.
ms.date: 08/06/2020
ms.openlocfilehash: 84775a436deb0958d3c05ec7d0207e76be28f27c
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465003"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="05a5d-104">Przewodnik po języku C#</span><span class="sxs-lookup"><span data-stu-id="05a5d-104">A tour of the C# language</span></span>

<span data-ttu-id="05a5d-105">C# ("Zobacz Sharp") to nowoczesny, zorientowany obiektowo i bezpieczny dla typu język programowania.</span><span class="sxs-lookup"><span data-stu-id="05a5d-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="05a5d-106">Język C# ma swoje elementy główne w rodzinie C i będzie od razu zaznajomiony z programistami C, C++, Java i JavaScript.</span><span class="sxs-lookup"><span data-stu-id="05a5d-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="05a5d-107">Ten przewodnik zawiera omówienie głównych składników języka w języku C# 8 i jego wcześniejszych wersjach.</span><span class="sxs-lookup"><span data-stu-id="05a5d-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="05a5d-108">Jeśli chcesz poznać język za pomocą przykładów interaktywnych, wypróbuj samouczki [dotyczące języka C#](../tutorials/intro-to-csharp/index.md) .</span><span class="sxs-lookup"><span data-stu-id="05a5d-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="05a5d-109">C# to zorientowany obiektowo język programowania ***zorientowany na składniki*** .</span><span class="sxs-lookup"><span data-stu-id="05a5d-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="05a5d-110">Język c# udostępnia konstrukcje języka, aby bezpośrednio obsługiwać te koncepcje, co pozwala na tworzenie i używanie składników oprogramowania w języku C#.</span><span class="sxs-lookup"><span data-stu-id="05a5d-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="05a5d-111">Ze względu na to, że język C# dodał funkcje do obsługi nowych obciążeń i rozwijających się praktyk projektowania oprogramowania.</span><span class="sxs-lookup"><span data-stu-id="05a5d-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="05a5d-112">Kilka funkcji języka C# pomaga w konstruowaniu niezawodnych i trwałych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="05a5d-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="05a5d-113">[***Wyrzucanie elementów bezużytecznych***](../../standard/garbage-collection/index.md) automatycznie odzyskuje ilość pamięci zajętą nieosiągalnymi obiektami.</span><span class="sxs-lookup"><span data-stu-id="05a5d-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="05a5d-114">[***Obsługa wyjątków***](../programming-guide/exceptions/index.md) zapewnia strukturalne i rozszerzalne podejście do wykrywania błędów i odzyskiwania.</span><span class="sxs-lookup"><span data-stu-id="05a5d-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="05a5d-115">[***Wyrażenia lambda***](../language-reference/operators/lambda-expressions.md) obsługują techniki programowania funkcjonalnego.</span><span class="sxs-lookup"><span data-stu-id="05a5d-115">[***Lambda expressions***](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="05a5d-116">[***Składnia zapytania***](../linq/index.md) tworzy wspólny wzorzec do pracy z danymi z dowolnego źródła.</span><span class="sxs-lookup"><span data-stu-id="05a5d-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="05a5d-117">Obsługa języka dla [***operacji asynchronicznych***](../programming-guide/concepts/async/index.md) zapewnia składnię tworzenia systemów rozproszonych.</span><span class="sxs-lookup"><span data-stu-id="05a5d-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="05a5d-118">[***Dopasowywanie wzorców***](..//pattern-matching.md) zawiera składnię umożliwiającą łatwe oddzielenie danych z algorytmów w nowoczesnych systemach rozproszonych.</span><span class="sxs-lookup"><span data-stu-id="05a5d-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="05a5d-119">Język C# ma [***ujednolicony system typów***](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="05a5d-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="05a5d-120">Wszystkie typy C#, w tym typy pierwotne, takie jak `int` i `double` , dziedziczą z jednego `object` typu głównego.</span><span class="sxs-lookup"><span data-stu-id="05a5d-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="05a5d-121">Wszystkie typy korzystają z zestawu typowych operacji.</span><span class="sxs-lookup"><span data-stu-id="05a5d-121">All types share a set of common operations.</span></span> <span data-ttu-id="05a5d-122">Wartości dowolnego typu mogą być przechowywane, transportowane i obsługiwane w spójny sposób.</span><span class="sxs-lookup"><span data-stu-id="05a5d-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="05a5d-123">Ponadto w języku C# obsługiwane są zarówno typy odwołań zdefiniowane przez użytkownika, jak i typy wartości.</span><span class="sxs-lookup"><span data-stu-id="05a5d-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="05a5d-124">Język C# umożliwia dynamiczne przydzielanie obiektów i przechowywanie w wierszu lekkich struktur.</span><span class="sxs-lookup"><span data-stu-id="05a5d-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="05a5d-125">Język C# wyróżnia ***wersje*** , aby zapewnić zgodność programów i bibliotek z upływem czasu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="05a5d-126">Aspekty projektu języka C#, które miały bezpośrednio wpływ na kwestie związane z obsługą wersji, obejmują oddzielność `virtual` i `override` modyfikatory, reguły rozpoznawania przeciążania metod oraz obsługę jawnych deklaracji elementów członkowskich interfejsu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="05a5d-127">Hello world</span><span class="sxs-lookup"><span data-stu-id="05a5d-127">Hello world</span></span>

<span data-ttu-id="05a5d-128">Program "Hello, World" jest tradycyjnie używany do wprowadzania języka programowania.</span><span class="sxs-lookup"><span data-stu-id="05a5d-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="05a5d-129">W tym miejscu jest w języku C#:</span><span class="sxs-lookup"><span data-stu-id="05a5d-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="05a5d-130">Program "Hello, World" rozpoczyna się od `using` dyrektywy, która odwołuje się do `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="05a5d-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="05a5d-131">Przestrzenie nazw zapewniają hierarchiczny sposób organizowania programów i bibliotek w języku C#.</span><span class="sxs-lookup"><span data-stu-id="05a5d-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="05a5d-132">Przestrzenie nazw zawierają typy i inne przestrzenie nazw — na przykład `System` przestrzeń nazw zawiera wiele typów, takich jak `Console` Klasa, do której odwołuje się program, oraz liczba innych przestrzeni nazw, takich jak `IO` i `Collections` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="05a5d-133">`using`Dyrektywa odwołująca się do danej przestrzeni nazw umożliwia niekwalifikowane użycie typów, które są elementami członkowskimi tej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="05a5d-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="05a5d-134">Ze względu na `using` dyrektywę program może użyć `Console.WriteLine` jako skrótu dla elementu `System.Console.WriteLine` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="05a5d-135">`Hello`Klasa zadeklarowana przez program "Hello, World" ma jeden element członkowski, Metoda o nazwie `Main` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="05a5d-136">`Main`Metoda jest zadeklarowana z `static` modyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="05a5d-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="05a5d-137">Chociaż metody wystąpień mogą odwoływać się do określonego wystąpienia obiektu otaczającego za pomocą słowa kluczowego `this` , metody statyczne działają bez odwołania do określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="05a5d-138">Zgodnie z Konwencją metoda statyczna o nazwie `Main` służy jako punkt wejścia programu C#.</span><span class="sxs-lookup"><span data-stu-id="05a5d-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="05a5d-139">Dane wyjściowe programu są tworzone przez `WriteLine` metodę `Console` klasy w `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="05a5d-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="05a5d-140">Ta klasa jest udostępniana przez standardowe biblioteki klas, które domyślnie są przywoływane przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="05a5d-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="05a5d-141">Typy i zmienne</span><span class="sxs-lookup"><span data-stu-id="05a5d-141">Types and variables</span></span>

<span data-ttu-id="05a5d-142">Istnieją dwa rodzaje typów w języku C#: *typy wartości* i *typy referencyjne*.</span><span class="sxs-lookup"><span data-stu-id="05a5d-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="05a5d-143">Zmienne typów wartości bezpośrednio zawierają swoje dane, a zmienne typów referencyjnych przechowują odwołania do danych, które są znane jako obiekty.</span><span class="sxs-lookup"><span data-stu-id="05a5d-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="05a5d-144">W przypadku typów referencyjnych istnieje możliwość, że dwie zmienne odwołują się do tego samego obiektu i możliwe dla operacji na jednej zmiennej mają wpływ na obiekt, do którego odwołuje się inna zmienna.</span><span class="sxs-lookup"><span data-stu-id="05a5d-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="05a5d-145">W przypadku typów wartości zmiennych każda z nich ma własną kopię danych i nie jest możliwe wykonywanie operacji na nich, aby wpływać na drugą (z wyjątkiem `ref` `out` zmiennych i parametrów).</span><span class="sxs-lookup"><span data-stu-id="05a5d-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="05a5d-146">***Identyfikator*** jest nazwą zmiennej.</span><span class="sxs-lookup"><span data-stu-id="05a5d-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="05a5d-147">Identyfikator jest sekwencją znaków Unicode bez odstępów.</span><span class="sxs-lookup"><span data-stu-id="05a5d-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="05a5d-148">Identyfikator może być słowem zastrzeżonym języka C#, jeśli jest poprzedzony przez `@` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="05a5d-149">Może to być przydatne w przypadku współpracy z innymi językami.</span><span class="sxs-lookup"><span data-stu-id="05a5d-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="05a5d-150">Typy wartości języka C# są dalej podzielone na *typy proste*, *typy wyliczeniowe*, *typy struktur*, *typy wartości null* i *typy wartości krotek*.</span><span class="sxs-lookup"><span data-stu-id="05a5d-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, *nullable value types* and *tuple value types*.</span></span> <span data-ttu-id="05a5d-151">Typy odwołań języka C# są dalej podzielone na *typy klas*, *typy interfejsów*, *Typy tablic*i *typy delegatów*.</span><span class="sxs-lookup"><span data-stu-id="05a5d-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="05a5d-152">Poniższy konspekt zawiera omówienie systemu typów języka C#.</span><span class="sxs-lookup"><span data-stu-id="05a5d-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="05a5d-153">Typy wartości</span><span class="sxs-lookup"><span data-stu-id="05a5d-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="05a5d-154">Typy proste</span><span class="sxs-lookup"><span data-stu-id="05a5d-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="05a5d-155">[Całkowita część ze znakiem](../language-reference/builtin-types/integral-numeric-types.md): `sbyte` ,, `short` `int` , `long`</span><span class="sxs-lookup"><span data-stu-id="05a5d-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="05a5d-156">[Całka bez znaku](../language-reference/builtin-types/integral-numeric-types.md): `byte` ,, `ushort` `uint` , `ulong`</span><span class="sxs-lookup"><span data-stu-id="05a5d-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="05a5d-157">[Znaki Unicode](../../standard/base-types/character-encoding-introduction.md): `char` , które reprezentuje jednostkę kodu UTF-16</span><span class="sxs-lookup"><span data-stu-id="05a5d-157">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="05a5d-158">[Binarny zmiennoprzecinkowy IEEE](../language-reference/builtin-types/floating-point-numeric-types.md): `float` , `double`</span><span class="sxs-lookup"><span data-stu-id="05a5d-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="05a5d-159">[Zmiennoprzecinkowa liczba dziesiętna o dużej precyzji](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span><span class="sxs-lookup"><span data-stu-id="05a5d-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="05a5d-160">Wartość logiczna: `bool` , która reprezentuje wartości logiczne — wartości, które są `true` albo `false`</span><span class="sxs-lookup"><span data-stu-id="05a5d-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="05a5d-161">Typy wyliczeniowe</span><span class="sxs-lookup"><span data-stu-id="05a5d-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="05a5d-162">Typy formularza zdefiniowane przez użytkownika `enum E {...}` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="05a5d-163">`enum`Typ jest typem odrębnym o nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="05a5d-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="05a5d-164">Każdy `enum` Typ ma typ podstawowy, który musi być jednym z ośmiu typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="05a5d-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="05a5d-165">Zestaw wartości `enum` typu jest taki sam jak zestaw wartości typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="05a5d-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="05a5d-166">Typy struktur</span><span class="sxs-lookup"><span data-stu-id="05a5d-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="05a5d-167">Typy formularza zdefiniowane przez użytkownika `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="05a5d-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="05a5d-168">Typy wartości dopuszczające wartość null</span><span class="sxs-lookup"><span data-stu-id="05a5d-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="05a5d-169">Rozszerzenia wszystkich innych typów wartości z `null` wartością</span><span class="sxs-lookup"><span data-stu-id="05a5d-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="05a5d-170">Typy wartości krotki</span><span class="sxs-lookup"><span data-stu-id="05a5d-170">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="05a5d-171">Typy formularza zdefiniowane przez użytkownika `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="05a5d-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="05a5d-172">Typy odwołań</span><span class="sxs-lookup"><span data-stu-id="05a5d-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="05a5d-173">Typy klas</span><span class="sxs-lookup"><span data-stu-id="05a5d-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="05a5d-174">Ostateczna Klasa bazowa dla wszystkich innych typów: `object`</span><span class="sxs-lookup"><span data-stu-id="05a5d-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="05a5d-175">[Ciągi Unicode](../../standard/base-types/character-encoding-introduction.md): `string` , które reprezentuje sekwencję jednostek kodu UTF-16</span><span class="sxs-lookup"><span data-stu-id="05a5d-175">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="05a5d-176">Typy formularza zdefiniowane przez użytkownika `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="05a5d-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="05a5d-177">Typy interfejsów</span><span class="sxs-lookup"><span data-stu-id="05a5d-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="05a5d-178">Typy formularza zdefiniowane przez użytkownika `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="05a5d-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="05a5d-179">Typy tablic</span><span class="sxs-lookup"><span data-stu-id="05a5d-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="05a5d-180">Jednowymiarowe, wielowymiarowe i nierówne.</span><span class="sxs-lookup"><span data-stu-id="05a5d-180">Single-dimensional, multi-dimensional and jagged.</span></span> <span data-ttu-id="05a5d-181">Na przykład: `int[]` , `int[,]` , i `int[][]`</span><span class="sxs-lookup"><span data-stu-id="05a5d-181">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="05a5d-182">Typy delegatów</span><span class="sxs-lookup"><span data-stu-id="05a5d-182">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="05a5d-183">Typy formularza zdefiniowane przez użytkownika `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="05a5d-183">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="05a5d-184">Programy w języku C# używają *deklaracji typów* do tworzenia nowych typów.</span><span class="sxs-lookup"><span data-stu-id="05a5d-184">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="05a5d-185">Deklaracja typu określa nazwę i składowe nowego typu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-185">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="05a5d-186">Sześć kategorii typów języka C# jest definiowanych przez użytkownika: typy klas, typy struktur, typy interfejsów, typy wyliczeniowe, typy obiektów delegowanych i typy wartości krotek.</span><span class="sxs-lookup"><span data-stu-id="05a5d-186">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types and tuple value types.</span></span>

- <span data-ttu-id="05a5d-187">`class`Typ definiuje strukturę danych, która zawiera składowe danych (pola) i składowe funkcji (metody, właściwości i inne).</span><span class="sxs-lookup"><span data-stu-id="05a5d-187">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="05a5d-188">Typy klas obsługują pojedyncze dziedziczenie i polimorfizm, czyli mechanizmy, w których klasy pochodne mogą poszerzać i specjalizację klas bazowych.</span><span class="sxs-lookup"><span data-stu-id="05a5d-188">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="05a5d-189">`struct`Typ jest podobny do typu klasy w tym, że reprezentuje strukturę z składowymi danych i składowymi funkcji.</span><span class="sxs-lookup"><span data-stu-id="05a5d-189">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="05a5d-190">Jednak w przeciwieństwie do klas, struktury są typami wartości i nie wymagają zazwyczaj alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="05a5d-190">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="05a5d-191">Typy struktur nie obsługują dziedziczenia określonego przez użytkownika, a wszystkie typy struktur niejawnie dziedziczą po typie `object` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-191">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="05a5d-192">`interface`Typ definiuje kontrakt jako nazwany zestaw publicznych członków.</span><span class="sxs-lookup"><span data-stu-id="05a5d-192">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="05a5d-193">A `class` lub `struct` implementujący `interface` musi zapewniać implementacje elementów członkowskich interfejsu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-193">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="05a5d-194">`interface`Może dziedziczyć z wielu interfejsów podstawowych, a `class` lub `struct` może zaimplementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="05a5d-194">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="05a5d-195">`delegate`Typ reprezentuje odwołania do metod z określoną listą parametrów i zwracanym typem.</span><span class="sxs-lookup"><span data-stu-id="05a5d-195">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="05a5d-196">Delegaty umożliwiają traktowanie metod jako jednostek, które mogą być przypisane do zmiennych i przekazane jako parametry.</span><span class="sxs-lookup"><span data-stu-id="05a5d-196">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="05a5d-197">Delegaty są analogiczne do typów funkcji zapewnianych przez Języki funkcjonalne.</span><span class="sxs-lookup"><span data-stu-id="05a5d-197">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="05a5d-198">Są one również podobne do koncepcji wskaźników funkcji, które znajdują się w innych językach.</span><span class="sxs-lookup"><span data-stu-id="05a5d-198">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="05a5d-199">W przeciwieństwie do wskaźników funkcji Delegaty są zorientowane obiektowo i są bezpieczne dla typów.</span><span class="sxs-lookup"><span data-stu-id="05a5d-199">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="05a5d-200">`class` `struct` `interface` Wszystkie typy,,, i są `delegate` obsługiwane przez wszystkie typy ogólne, dzięki czemu można je sparametryzowane z innymi typami.</span><span class="sxs-lookup"><span data-stu-id="05a5d-200">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="05a5d-201">Język C# obsługuje jednowymiarowe i wielowymiarowe tablice dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-201">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="05a5d-202">W przeciwieństwie do typów wymienionych powyżej, typy tablicy nie muszą być zadeklarowane przed użyciem.</span><span class="sxs-lookup"><span data-stu-id="05a5d-202">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="05a5d-203">Zamiast tego typy tablic są konstruowane przez następujące nazwy typu z nawiasami kwadratowymi.</span><span class="sxs-lookup"><span data-stu-id="05a5d-203">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="05a5d-204">Na przykład `int[]` jest tablicą jednowymiarową `int` , `int[,]` która jest tablicą dwuwymiarową `int` , i `int[][]` jest jednowymiarową tablicą jednowymiarowych tablic lub "nieregularną" tablicą `int` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-204">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="05a5d-205">Typy dopuszczające wartości null nie wymagają oddzielnej definicji.</span><span class="sxs-lookup"><span data-stu-id="05a5d-205">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="05a5d-206">Dla każdego typu, który nie dopuszcza wartości null `T` , istnieje odpowiedni typ dopuszczający wartość null, `T?` który może zawierać dodatkowe wartości `null` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-206">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="05a5d-207">Na przykład `int?` jest typem, który może zawierać dowolną 32-bitową liczbę całkowitą lub wartość `null` , i `string?` jest typem, który może zawierać dowolną `string` lub wartość `null` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-207">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="05a5d-208">System typów języka C# jest jednorodny tak, że wartość dowolnego typu może być traktowana jako `object` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-208">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="05a5d-209">Każdy typ w języku C# bezpośrednio lub pośrednio pochodzi od `object` typu klasy i `object` jest ostateczną klasą bazową wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="05a5d-209">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="05a5d-210">Wartości typów referencyjnych są traktowane jako obiekty, po prostu wyświetlając wartości jako typ `object` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-210">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="05a5d-211">Wartości typów wartości są traktowane jako obiekty *przez wykonywanie* *operacji pakowania*i rozpakowywania.</span><span class="sxs-lookup"><span data-stu-id="05a5d-211">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="05a5d-212">W poniższym przykładzie `int` wartość jest konwertowana na `object` i z powrotem do `int` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-212">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="05a5d-213">Gdy wartość typu wartości jest przypisana do `object` odwołania, pole "Box" jest przydzielane do przechowywania wartości.</span><span class="sxs-lookup"><span data-stu-id="05a5d-213">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="05a5d-214">To pole jest wystąpieniem typu odwołania, a wartość jest kopiowana do tego pola.</span><span class="sxs-lookup"><span data-stu-id="05a5d-214">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="05a5d-215">Z drugiej strony, gdy `object` odwołanie jest rzutowane na typ wartości, jest wykonywane sprawdzenie, że odwołanie `object` jest polem o poprawnym typie wartości.</span><span class="sxs-lookup"><span data-stu-id="05a5d-215">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="05a5d-216">Jeśli sprawdzenie zakończy się powodzeniem, wartość w polu jest kopiowana do typu wartości.</span><span class="sxs-lookup"><span data-stu-id="05a5d-216">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="05a5d-217">Ujednolicony system typów języka C# efektywnie oznacza, że typy wartości są traktowane jako `object` odwołania "na żądanie".</span><span class="sxs-lookup"><span data-stu-id="05a5d-217">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="05a5d-218">Ze względu na nieujednolicenie biblioteki ogólnego przeznaczenia używające typu `object` można używać ze wszystkimi typami, które pochodzą od `object` , w tym typy odwołań i typy wartości.</span><span class="sxs-lookup"><span data-stu-id="05a5d-218">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="05a5d-219">W języku C# istnieje kilka rodzajów *zmiennych* , w tym pola, elementy tablicy, zmienne lokalne i parametry.</span><span class="sxs-lookup"><span data-stu-id="05a5d-219">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="05a5d-220">Zmienne reprezentują lokalizacje magazynu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-220">Variables represent storage locations.</span></span> <span data-ttu-id="05a5d-221">Każda zmienna ma typ, który określa, jakie wartości mogą być przechowywane w zmiennej, jak pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="05a5d-221">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="05a5d-222">Typ wartości niedopuszczający wartości null</span><span class="sxs-lookup"><span data-stu-id="05a5d-222">Non-nullable value type</span></span>
  - <span data-ttu-id="05a5d-223">Wartość tego dokładnego typu</span><span class="sxs-lookup"><span data-stu-id="05a5d-223">A value of that exact type</span></span>
- <span data-ttu-id="05a5d-224">Typ wartości null</span><span class="sxs-lookup"><span data-stu-id="05a5d-224">Nullable value type</span></span>
  - <span data-ttu-id="05a5d-225">`null`Wartość lub wartość tego dokładnego typu</span><span class="sxs-lookup"><span data-stu-id="05a5d-225">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="05a5d-226">object</span><span class="sxs-lookup"><span data-stu-id="05a5d-226">object</span></span>
  - <span data-ttu-id="05a5d-227">`null`Odwołanie, odwołanie do obiektu dowolnego typu odwołania lub odwołanie do wartości opakowanej dowolnego typu wartości</span><span class="sxs-lookup"><span data-stu-id="05a5d-227">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="05a5d-228">Typ klasy</span><span class="sxs-lookup"><span data-stu-id="05a5d-228">Class type</span></span>
  - <span data-ttu-id="05a5d-229">`null`Odwołanie, odwołanie do wystąpienia tego typu klasy lub odwołanie do wystąpienia klasy pochodzącej od tego typu klasy</span><span class="sxs-lookup"><span data-stu-id="05a5d-229">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="05a5d-230">Typ interfejsu</span><span class="sxs-lookup"><span data-stu-id="05a5d-230">Interface type</span></span>
  - <span data-ttu-id="05a5d-231">`null`Odwołanie, odwołanie do wystąpienia typu klasy implementującego ten typ interfejsu lub odwołanie do wartości opakowanej typu wartości implementującej ten typ interfejsu</span><span class="sxs-lookup"><span data-stu-id="05a5d-231">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="05a5d-232">Typ tablicy</span><span class="sxs-lookup"><span data-stu-id="05a5d-232">Array type</span></span>
  - <span data-ttu-id="05a5d-233">`null`Odwołanie, odwołanie do wystąpienia tego typu tablicy lub odwołanie do wystąpienia zgodnego typu tablicy</span><span class="sxs-lookup"><span data-stu-id="05a5d-233">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="05a5d-234">Typ delegata</span><span class="sxs-lookup"><span data-stu-id="05a5d-234">Delegate type</span></span>
  - <span data-ttu-id="05a5d-235">`null`Odwołanie lub odwołanie do wystąpienia zgodnego typu delegata</span><span class="sxs-lookup"><span data-stu-id="05a5d-235">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="05a5d-236">Struktura programu</span><span class="sxs-lookup"><span data-stu-id="05a5d-236">Program structure</span></span>

<span data-ttu-id="05a5d-237">Kluczowe koncepcje organizacyjne w języku C# to [***programy***](../programming-guide/inside-a-program/index.md), [***przestrzenie nazw***](../programming-guide/namespaces/index.md), [***typy***](../programming-guide/types/index.md), [***elementy członkowskie***](../programming-guide/classes-and-structs/members.md)i [***zestawy***](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="05a5d-237">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="05a5d-238">Programy deklarują typy, które zawierają składowe i mogą być zorganizowane w przestrzenie nazw.</span><span class="sxs-lookup"><span data-stu-id="05a5d-238">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="05a5d-239">Klasy, struktury i interfejsy są przykładami typów.</span><span class="sxs-lookup"><span data-stu-id="05a5d-239">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="05a5d-240">Pola, metody, właściwości i zdarzenia są przykładami elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="05a5d-240">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="05a5d-241">Po skompilowaniu programów C# są one fizycznie spakowane w zestawy.</span><span class="sxs-lookup"><span data-stu-id="05a5d-241">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="05a5d-242">Zestawy zazwyczaj mają rozszerzenie pliku `.exe` lub `.dll` , w zależności od tego, czy implementują odpowiednio ***aplikacje*** lub ***biblioteki***.</span><span class="sxs-lookup"><span data-stu-id="05a5d-242">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="05a5d-243">Jako mały przykład rozważmy zestaw, który zawiera następujący kod:</span><span class="sxs-lookup"><span data-stu-id="05a5d-243">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="05a5d-244">W pełni kwalifikowana nazwa tej klasy to `Acme.Collections.Stack` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-244">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="05a5d-245">Klasa zawiera kilka elementów członkowskich: pole o nazwie `top` , dwie metody o nazwie `Push` i `Pop` i zagnieżdżoną klasę o nazwie `Entry` .</span><span class="sxs-lookup"><span data-stu-id="05a5d-245">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="05a5d-246">`Entry`Klasa dodatkowo zawiera trzy elementy członkowskie: pole o nazwie `next` , pole o nazwie `data` i Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="05a5d-246">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="05a5d-247">`Stack`Jest klasą *rodzajową* .</span><span class="sxs-lookup"><span data-stu-id="05a5d-247">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="05a5d-248">Ma jeden parametr typu, `T` który jest zastępowany konkretnym typem, gdy jest używany.</span><span class="sxs-lookup"><span data-stu-id="05a5d-248">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="05a5d-249">*Stos* to kolekcja "First In-Last Out" (filo).</span><span class="sxs-lookup"><span data-stu-id="05a5d-249">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="05a5d-250">Nowe elementy są dodawane na górze stosu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-250">New elements are added to the top of the stack.</span></span> <span data-ttu-id="05a5d-251">Po usunięciu elementu jest on usuwany z góry stosu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-251">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="05a5d-252">Zestawy zawierają kod wykonywalny w postaci instrukcji języka pośredniego (IL) i informacji symbolicznych w formie metadanych.</span><span class="sxs-lookup"><span data-stu-id="05a5d-252">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="05a5d-253">Przed wykonaniem, kompilator just-in-Time (JIT) środowiska uruchomieniowego języka wspólnego .NET konwertuje kod IL w zestawie na kod specyficzny dla procesora.</span><span class="sxs-lookup"><span data-stu-id="05a5d-253">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="05a5d-254">Ponieważ zestaw jest samoopisującą się jednostką funkcji obejmujących zarówno kod, jak i metadane, nie ma potrzeby stosowania `#include` dyrektyw i plików nagłówkowych w języku C#.</span><span class="sxs-lookup"><span data-stu-id="05a5d-254">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="05a5d-255">Typy publiczne i składowe zawarte w określonym zestawie są udostępniane w programie C# po prostu przez odwołanie się do tego zestawu podczas kompilowania programu.</span><span class="sxs-lookup"><span data-stu-id="05a5d-255">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="05a5d-256">Na przykład ten program używa `Acme.Collections.Stack` klasy z `acme.dll` zestawu:</span><span class="sxs-lookup"><span data-stu-id="05a5d-256">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="05a5d-257">Aby skompilować ten program, należy *odwołać* się do zestawu zawierającego klasę stosu zdefiniowaną w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="05a5d-257">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="05a5d-258">Programy w języku C# mogą być przechowywane w kilku plikach źródłowych.</span><span class="sxs-lookup"><span data-stu-id="05a5d-258">C# programs can be stored in several source files.</span></span> <span data-ttu-id="05a5d-259">Po skompilowaniu programu w języku C# wszystkie pliki źródłowe są przetwarzane razem, a pliki źródłowe mogą swobodnie odwoływać się do siebie.</span><span class="sxs-lookup"><span data-stu-id="05a5d-259">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="05a5d-260">Koncepcyjnie, jeśli wszystkie pliki źródłowe zostały połączone w jeden duży plik przed przetworzeniem.</span><span class="sxs-lookup"><span data-stu-id="05a5d-260">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="05a5d-261">Deklaracje przesyłania dalej nie są nigdy konieczne w języku C#, ponieważ z kilkoma wyjątkami porządek deklaracji jest nieważny.</span><span class="sxs-lookup"><span data-stu-id="05a5d-261">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="05a5d-262">Język C# nie ogranicza pliku źródłowego do deklarowania tylko jednego typu publicznego ani nie wymaga, aby nazwa pliku źródłowego była zgodna z typem zadeklarowanym w pliku źródłowym.</span><span class="sxs-lookup"><span data-stu-id="05a5d-262">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="05a5d-263">Dalsze artykuły w tym samouczku wyjaśniają te bloki organizacyjne.</span><span class="sxs-lookup"><span data-stu-id="05a5d-263">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="05a5d-264">Dalej</span><span class="sxs-lookup"><span data-stu-id="05a5d-264">Next</span></span>](types.md)
