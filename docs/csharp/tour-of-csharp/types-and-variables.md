---
title: C#Typy i zmienne — Przewodnik po C# języku
description: Dowiedz się więcej na temat definiowania typów i deklarowania zmiennych wC#
ms.date: 08/10/2016
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: 571e346d1e46be798dca1b42cfcc2af3aa65e641
ms.sourcegitcommit: 44a7cd8687f227fc6db3211ccf4783dc20235e51
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/26/2020
ms.locfileid: "77627568"
---
# <a name="types-and-variables"></a><span data-ttu-id="040eb-103">Typy i zmienne</span><span class="sxs-lookup"><span data-stu-id="040eb-103">Types and variables</span></span>

<span data-ttu-id="040eb-104">Istnieją dwa rodzaje typów w C#: *typy wartości* i *typy odwołań*.</span><span class="sxs-lookup"><span data-stu-id="040eb-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="040eb-105">Zmienne typów wartości bezpośrednio zawierają swoje dane, a zmienne typów referencyjnych przechowują odwołania do danych, które są znane jako obiekty.</span><span class="sxs-lookup"><span data-stu-id="040eb-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="040eb-106">W przypadku typów referencyjnych istnieje możliwość, że dwie zmienne odwołują się do tego samego obiektu, w tym przypadku operacje na jednej zmiennej mają wpływ na obiekt, do którego odwołuje się inna zmienna.</span><span class="sxs-lookup"><span data-stu-id="040eb-106">With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="040eb-107">W przypadku typów wartości zmiennych każda z nich ma własną kopię danych i nie jest możliwe wykonywanie operacji na nich, aby wpływać na drugą (z wyjątkiem `ref` i `out` zmiennych parametrów).</span><span class="sxs-lookup"><span data-stu-id="040eb-107">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="040eb-108">C#typy wartości są dalej podzielone na *typy proste*, *typy wyliczeniowe*, *typy struktur*i *typy wartości null*.</span><span class="sxs-lookup"><span data-stu-id="040eb-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="040eb-109">C#typy odwołań są dalej podzielone na *typy klas*, *typy interfejsów*, *Typy tablic*i *typy delegatów*.</span><span class="sxs-lookup"><span data-stu-id="040eb-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="040eb-110">Poniżej przedstawiono omówienie C#systemu typu.</span><span class="sxs-lookup"><span data-stu-id="040eb-110">The following provides an overview of C#’s type system.</span></span>

- <span data-ttu-id="040eb-111">[Typy wartości][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="040eb-112">[Typy proste][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-112">[Simple types][SimpleTypes]</span></span>
    - <span data-ttu-id="040eb-113">Część ze znakiem: `sbyte`, `short`, `int``long`</span><span class="sxs-lookup"><span data-stu-id="040eb-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="040eb-114">Całka bez znaku: `byte`, `ushort`, `uint``ulong`</span><span class="sxs-lookup"><span data-stu-id="040eb-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="040eb-115">Znaki Unicode: `char`</span><span class="sxs-lookup"><span data-stu-id="040eb-115">Unicode characters: `char`</span></span>
    - <span data-ttu-id="040eb-116">Binarny zmiennoprzecinkowy IEEE: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="040eb-116">IEEE binary floating-point: `float`, `double`</span></span>
    - <span data-ttu-id="040eb-117">Zmiennoprzecinkowa liczba dziesiętna o dużej precyzji: `decimal`</span><span class="sxs-lookup"><span data-stu-id="040eb-117">High-precision decimal floating-point: `decimal`</span></span>
    - <span data-ttu-id="040eb-118">Wartość logiczna: `bool`</span><span class="sxs-lookup"><span data-stu-id="040eb-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="040eb-119">[Typy wyliczeniowe][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-119">[Enum types][EnumTypes]</span></span>
    - <span data-ttu-id="040eb-120">Typy formularzy `enum E {...}` zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="040eb-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="040eb-121">[Typy struktur][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-121">[Struct types][StructTypes]</span></span>
    - <span data-ttu-id="040eb-122">Typy formularzy `struct S {...}` zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="040eb-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="040eb-123">[Typy wartości null][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-123">[Nullable value types][NullableTypes]</span></span>
    - <span data-ttu-id="040eb-124">Rozszerzenia wszystkich innych typów wartości z wartością `null`</span><span class="sxs-lookup"><span data-stu-id="040eb-124">Extensions of all other value types with a `null` value</span></span>
- <span data-ttu-id="040eb-125">[Typy odwołań][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-125">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="040eb-126">[Typy klas][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-126">[Class types][ClassTypes]</span></span>
    - <span data-ttu-id="040eb-127">Ultimate Klasa bazowa dla wszystkich innych typów: `object`</span><span class="sxs-lookup"><span data-stu-id="040eb-127">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="040eb-128">Ciągi Unicode: `string`</span><span class="sxs-lookup"><span data-stu-id="040eb-128">Unicode strings: `string`</span></span>
    - <span data-ttu-id="040eb-129">Typy formularzy `class C {...}` zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="040eb-129">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="040eb-130">[Typy interfejsów][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-130">[Interface types][InterfaceTypes]</span></span>
    - <span data-ttu-id="040eb-131">Typy formularzy `interface I {...}` zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="040eb-131">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="040eb-132">[Typy tablic][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-132">[Array types][ArrayTypes]</span></span>
    - <span data-ttu-id="040eb-133">Pojedyncze i wielowymiarowe, na przykład `int[]` i `int[,]`</span><span class="sxs-lookup"><span data-stu-id="040eb-133">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="040eb-134">[Typy delegatów][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="040eb-134">[Delegate types][DelegateTypes]</span></span>
    - <span data-ttu-id="040eb-135">Typy formularzy `delegate int D(...)` zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="040eb-135">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/builtin-types/value-types.md
[SimpleTypes]: ../language-reference/builtin-types/value-types.md#built-in-value-types
[EnumTypes]: ../language-reference/builtin-types/enum.md
[StructTypes]: ../language-reference/builtin-types/struct.md
[NullableTypes]: ../language-reference/builtin-types/nullable-value-types.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="040eb-136">Aby uzyskać więcej informacji na temat typów liczbowych, zobacz [Typy całkowite](../language-reference/builtin-types/integral-numeric-types.md) i [Tabela typów zmiennoprzecinkowych](../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="040eb-136">For more information about numeric types, see [Integral types](../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point types table](../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="040eb-137">C#Typ `bool` jest używany do reprezentowania wartości logicznych — wartości `true` lub `false`.</span><span class="sxs-lookup"><span data-stu-id="040eb-137">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="040eb-138">Przetwarzanie znaków i ciągów w C# programie używa kodowania Unicode.</span><span class="sxs-lookup"><span data-stu-id="040eb-138">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="040eb-139">Typ `char` reprezentuje jednostkę kodu UTF-16, a typ `string` reprezentuje sekwencję jednostek kodu UTF-16.</span><span class="sxs-lookup"><span data-stu-id="040eb-139">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="040eb-140">C#programy używają *deklaracji typu* do tworzenia nowych typów.</span><span class="sxs-lookup"><span data-stu-id="040eb-140">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="040eb-141">Deklaracja typu określa nazwę i składowe nowego typu.</span><span class="sxs-lookup"><span data-stu-id="040eb-141">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="040eb-142">C#Pięć kategorii typów są definiowane przez użytkownika: typy klas, typy struktur, typy interfejsów, typy wyliczeniowe i typy delegatów.</span><span class="sxs-lookup"><span data-stu-id="040eb-142">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="040eb-143">Typ `class` definiuje strukturę danych, która zawiera składowe danych (pola) i składowe funkcji (metody, właściwości i inne).</span><span class="sxs-lookup"><span data-stu-id="040eb-143">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="040eb-144">Typy klas obsługują pojedyncze dziedziczenie i polimorfizm, czyli mechanizmy, w których klasy pochodne mogą poszerzać i specjalizację klas bazowych.</span><span class="sxs-lookup"><span data-stu-id="040eb-144">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="040eb-145">Typ `struct` jest podobny do typu klasy w tym, że reprezentuje strukturę z elementami członkowskimi danych i składowymi funkcji.</span><span class="sxs-lookup"><span data-stu-id="040eb-145">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="040eb-146">Jednak w przeciwieństwie do klas, struktury są typami wartości i nie wymagają zazwyczaj alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="040eb-146">However, unlike classes, structs are value types and do not typically require heap allocation.</span></span> <span data-ttu-id="040eb-147">Typy struktur nie obsługują dziedziczenia określonego przez użytkownika, a wszystkie typy struktur niejawnie dziedziczą z typu `object`.</span><span class="sxs-lookup"><span data-stu-id="040eb-147">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="040eb-148">Typ `interface` definiuje kontrakt jako nazwany zestaw elementów członkowskich funkcji publicznych.</span><span class="sxs-lookup"><span data-stu-id="040eb-148">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="040eb-149">`class` lub `struct` implementujące `interface` musi dostarczać implementacje składowych funkcji interfejsu.</span><span class="sxs-lookup"><span data-stu-id="040eb-149">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="040eb-150">`interface` może dziedziczyć z wielu interfejsów podstawowych, a `class` lub `struct` może zaimplementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="040eb-150">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="040eb-151">Typ `delegate` reprezentuje odwołania do metod z określoną listą parametrów i zwracanym typem.</span><span class="sxs-lookup"><span data-stu-id="040eb-151">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="040eb-152">Delegaty umożliwiają traktowanie metod jako jednostek, które mogą być przypisane do zmiennych i przekazane jako parametry.</span><span class="sxs-lookup"><span data-stu-id="040eb-152">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="040eb-153">Delegaty są analogiczne do typów funkcji zapewnianych przez Języki funkcjonalne.</span><span class="sxs-lookup"><span data-stu-id="040eb-153">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="040eb-154">Są one również podobne do koncepcji wskaźników funkcji, które znajdują się w innych językach, ale w przeciwieństwie do wskaźników funkcji, Delegaty są zorientowane obiektowo i są bezpieczne dla typów.</span><span class="sxs-lookup"><span data-stu-id="040eb-154">They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="040eb-155">`class`, `struct`, `interface` i `delegate` obsługują typy ogólne, dzięki czemu można je sparametryzowane z innymi typami.</span><span class="sxs-lookup"><span data-stu-id="040eb-155">The `class`, `struct`, `interface` and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="040eb-156">Typ `enum` jest typem odrębnym o nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="040eb-156">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="040eb-157">Każdy typ `enum` ma typ podstawowy, który musi być jednym z ośmiu typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="040eb-157">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="040eb-158">Zestaw wartości typu `enum` jest taki sam jak zestaw wartości typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="040eb-158">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="040eb-159">C#obsługuje tablice pojedynczych i wielowymiarowych dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="040eb-159">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="040eb-160">W przeciwieństwie do typów wymienionych powyżej, typy tablicy nie muszą być zadeklarowane przed użyciem.</span><span class="sxs-lookup"><span data-stu-id="040eb-160">Unlike the types listed above, array types do not have to be declared before they can be used.</span></span> <span data-ttu-id="040eb-161">Zamiast tego typy tablic są konstruowane przez następujące nazwy typu z nawiasami kwadratowymi.</span><span class="sxs-lookup"><span data-stu-id="040eb-161">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="040eb-162">Na przykład `int[]` jest tablicą jednowymiarową `int`, `int[,]` jest dwuwymiarową tablicą `int`, a `int[][]` to Jednowymiarowa tablica jednowymiarowej tablicy `int`.</span><span class="sxs-lookup"><span data-stu-id="040eb-162">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="040eb-163">Nie trzeba również deklarować typów wartości null, aby można było ich używać.</span><span class="sxs-lookup"><span data-stu-id="040eb-163">Nullable value types also do not have to be declared before they can be used.</span></span> <span data-ttu-id="040eb-164">Dla każdego typu wartości niedopuszczających wartości null `T` istnieje odpowiedni typ wartości null `T?`, który może zawierać dodatkową wartość, `null`.</span><span class="sxs-lookup"><span data-stu-id="040eb-164">For each non-nullable value type `T` there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="040eb-165">Na przykład `int?` jest typem, który może zawierać dowolną 32-bitową liczbę całkowitą lub `null`wartość.</span><span class="sxs-lookup"><span data-stu-id="040eb-165">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="040eb-166">C#System typów jest jednorodny tak, że wartość dowolnego typu może być traktowana jako `object`.</span><span class="sxs-lookup"><span data-stu-id="040eb-166">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="040eb-167">Każdy typ C# bezpośrednio lub pośrednio pochodzi od typu klasy `object`, a `object` jest ostateczną klasą bazową wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="040eb-167">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="040eb-168">Wartości typów referencyjnych są traktowane jako obiekty po prostu przez wyświetlanie wartości jako typu `object`.</span><span class="sxs-lookup"><span data-stu-id="040eb-168">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="040eb-169">Wartości typów wartości są traktowane jako obiekty *przez wykonywanie* *operacji pakowania*i rozpakowywania.</span><span class="sxs-lookup"><span data-stu-id="040eb-169">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="040eb-170">W poniższym przykładzie wartość `int` jest konwertowana na `object` i z powrotem do `int`.</span><span class="sxs-lookup"><span data-stu-id="040eb-170">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="040eb-171">Gdy wartość typu wartości jest konwertowana na typ `object`, wystąpienie `object`, zwane również "polem", jest przydzielone do przechowywania wartości, a wartość jest kopiowana do tego pola.</span><span class="sxs-lookup"><span data-stu-id="040eb-171">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="040eb-172">Z drugiej strony, gdy odwołanie `object` jest rzutowane na typ wartości, jest wykonywane sprawdzenie, że odwołanie `object` jest polem poprawnego typu wartości i, jeśli sprawdzenie zakończy się powodzeniem, wartość w polu jest kopiowana.</span><span class="sxs-lookup"><span data-stu-id="040eb-172">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="040eb-173">C#ujednolicony system typów efektywnie oznacza, że typy wartości mogą stać się obiektami "na żądanie".</span><span class="sxs-lookup"><span data-stu-id="040eb-173">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="040eb-174">Ze względu na nieujednolicenie biblioteki ogólnego przeznaczenia używające typu `object` mogą być używane z obydwoma typami referencyjnymi i typami wartości.</span><span class="sxs-lookup"><span data-stu-id="040eb-174">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="040eb-175">W programie istnieją różne rodzaje *zmiennych* , w C#tym pola, elementy tablicy, zmienne lokalne i parametry.</span><span class="sxs-lookup"><span data-stu-id="040eb-175">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="040eb-176">Zmienne reprezentują lokalizacje przechowywania, a Każda zmienna ma typ, który określa, jakie wartości mogą być przechowywane w zmiennej, jak pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="040eb-176">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="040eb-177">Typ wartości niedopuszczający wartości null</span><span class="sxs-lookup"><span data-stu-id="040eb-177">Non-nullable value type</span></span>
  - <span data-ttu-id="040eb-178">Wartość tego dokładnego typu</span><span class="sxs-lookup"><span data-stu-id="040eb-178">A value of that exact type</span></span>
- <span data-ttu-id="040eb-179">Typ wartości null</span><span class="sxs-lookup"><span data-stu-id="040eb-179">Nullable value type</span></span>
  - <span data-ttu-id="040eb-180">Wartość `null` lub wartość tego dokładnego typu</span><span class="sxs-lookup"><span data-stu-id="040eb-180">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="040eb-181">obiekt</span><span class="sxs-lookup"><span data-stu-id="040eb-181">object</span></span>
  - <span data-ttu-id="040eb-182">Odwołanie `null`, odwołanie do obiektu dowolnego typu odwołania lub odwołanie do wartości opakowanej dowolnego typu wartości</span><span class="sxs-lookup"><span data-stu-id="040eb-182">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="040eb-183">Typ klasy</span><span class="sxs-lookup"><span data-stu-id="040eb-183">Class type</span></span>
  - <span data-ttu-id="040eb-184">Odwołanie `null`, odwołanie do wystąpienia tego typu klasy lub odwołanie do wystąpienia klasy pochodzącej od tego typu klasy</span><span class="sxs-lookup"><span data-stu-id="040eb-184">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="040eb-185">Typ interfejsu</span><span class="sxs-lookup"><span data-stu-id="040eb-185">Interface type</span></span>
  - <span data-ttu-id="040eb-186">Odwołanie `null`, odwołanie do wystąpienia typu klasy implementującego ten typ interfejsu lub odwołanie do wartości opakowanej typu wartości implementującej ten typ interfejsu</span><span class="sxs-lookup"><span data-stu-id="040eb-186">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="040eb-187">Typ tablicy</span><span class="sxs-lookup"><span data-stu-id="040eb-187">Array type</span></span>
  - <span data-ttu-id="040eb-188">Odwołanie `null`, odwołanie do wystąpienia tego typu tablicy lub odwołanie do wystąpienia zgodnego typu tablicy</span><span class="sxs-lookup"><span data-stu-id="040eb-188">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="040eb-189">Typ delegata</span><span class="sxs-lookup"><span data-stu-id="040eb-189">Delegate type</span></span>
  - <span data-ttu-id="040eb-190">Odwołanie `null` lub odwołanie do wystąpienia zgodnego typu delegata</span><span class="sxs-lookup"><span data-stu-id="040eb-190">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="040eb-191">[Poprzednie](program-structure.md)
> [dalej](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="040eb-191">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
