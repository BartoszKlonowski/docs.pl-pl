---
title: "C# i zmiennymi — samouczek języka C#"
description: "Więcej informacji na temat definiowania typów i deklarowania zmiennych w języku C#"
keywords: ".NET, csharp, typ, typ, wartość typu odwołania"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: 1f1031384520b9ed37246361da8bbc1b42addb0b
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2017
---
# <a name="types-and-variables"></a><span data-ttu-id="a30c4-104">Typy i zmienne</span><span class="sxs-lookup"><span data-stu-id="a30c4-104">Types and variables</span></span>

<span data-ttu-id="a30c4-105">Istnieją dwa rodzaje typów w języku C#: *typów wartości* i *typy referencyjne*.</span><span class="sxs-lookup"><span data-stu-id="a30c4-105">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="a30c4-106">Zmienne typów wartości zawierają swoje dane bezpośrednio, natomiast zmienne typów referencyjnych przechowywania odwołań do swoich danych, w drugim znaną jako obiekty.</span><span class="sxs-lookup"><span data-stu-id="a30c4-106">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="a30c4-107">Z typami odwołania jest możliwość dwie zmienne odwołać się do tego samego obiektu i w związku z tym możliwe w dla operacji na jedną zmienną, która wpływa na obiekt odwołuje się innej zmiennej.</span><span class="sxs-lookup"><span data-stu-id="a30c4-107">With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="a30c4-108">W przypadku typów wartości zmiennych każdego mają własne kopii danych i nie jest możliwe w dla operacji na jednym wpłynąć na innych (z wyjątkiem w odniesieniu `ref` i `out` zmiennych parametrów).</span><span class="sxs-lookup"><span data-stu-id="a30c4-108">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="a30c4-109">C# dla typów wartości są podzielone na *typów prostych*, *Typy wyliczeniowe*, *typy struktur*, i *typy o wartości zerowalnej*.</span><span class="sxs-lookup"><span data-stu-id="a30c4-109">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="a30c4-110">C# dla typów odwołań są podzielone na *klas typów*, *typy interfejsów*, *typy tablicowe*, i *typów delegatów*.</span><span class="sxs-lookup"><span data-stu-id="a30c4-110">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="a30c4-111">Poniżej omówiono C# dla typu systemu.</span><span class="sxs-lookup"><span data-stu-id="a30c4-111">The following provides an overview of C#’s type system.</span></span>

* <span data-ttu-id="a30c4-112">Typy wartości</span><span class="sxs-lookup"><span data-stu-id="a30c4-112">Value types</span></span>
    - <span data-ttu-id="a30c4-113">Typy proste</span><span class="sxs-lookup"><span data-stu-id="a30c4-113">Simple Types</span></span>
        * <span data-ttu-id="a30c4-114">Podpisana typu całkowitego: `sbyte`, `short`, `int`,`long`</span><span class="sxs-lookup"><span data-stu-id="a30c4-114">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
        * <span data-ttu-id="a30c4-115">Typy całkowite bez znaku: `byte`, `ushort`, `uint`,`ulong`</span><span class="sxs-lookup"><span data-stu-id="a30c4-115">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
        * <span data-ttu-id="a30c4-116">Znaki Unicode:`char`</span><span class="sxs-lookup"><span data-stu-id="a30c4-116">Unicode characters: `char`</span></span>
        * <span data-ttu-id="a30c4-117">Liczba zmiennoprzecinkowa IEEE: `float`,`double`</span><span class="sxs-lookup"><span data-stu-id="a30c4-117">IEEE floating point: `float`, `double`</span></span>
        * <span data-ttu-id="a30c4-118">Decimal wysokiej precyzji:`decimal`</span><span class="sxs-lookup"><span data-stu-id="a30c4-118">High-precision decimal: `decimal`</span></span>
        * <span data-ttu-id="a30c4-119">Wartość logiczna:`bool`</span><span class="sxs-lookup"><span data-stu-id="a30c4-119">Boolean: `bool`</span></span>
    - <span data-ttu-id="a30c4-120">Typy wyliczeniowe</span><span class="sxs-lookup"><span data-stu-id="a30c4-120">Enum types</span></span>
        * <span data-ttu-id="a30c4-121">Typy danych zdefiniowane przez użytkownika w postaci`enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="a30c4-121">User-defined types of the form `enum E {...}`</span></span>
    - <span data-ttu-id="a30c4-122">Typy struktur</span><span class="sxs-lookup"><span data-stu-id="a30c4-122">Struct types</span></span>
        * <span data-ttu-id="a30c4-123">Typy danych zdefiniowane przez użytkownika w postaci`struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="a30c4-123">User-defined types of the form `struct S {...}`</span></span>
    - <span data-ttu-id="a30c4-124">typy dopuszczające wartości zerowe wartości</span><span class="sxs-lookup"><span data-stu-id="a30c4-124">Nullable value types</span></span>
        * <span data-ttu-id="a30c4-125">Rozszerzenia innych typów wartości za pomocą `null` wartości</span><span class="sxs-lookup"><span data-stu-id="a30c4-125">Extensions of all other value types with a `null` value</span></span>
* <span data-ttu-id="a30c4-126">Typy odwołań</span><span class="sxs-lookup"><span data-stu-id="a30c4-126">Reference types</span></span>
    - <span data-ttu-id="a30c4-127">Typy klas</span><span class="sxs-lookup"><span data-stu-id="a30c4-127">Class types</span></span>
        * <span data-ttu-id="a30c4-128">Klasa podstawowa Ultimate innych typów:`object`</span><span class="sxs-lookup"><span data-stu-id="a30c4-128">Ultimate base class of all other types: `object`</span></span>
        * <span data-ttu-id="a30c4-129">Ciągów Unicode:`string`</span><span class="sxs-lookup"><span data-stu-id="a30c4-129">Unicode strings: `string`</span></span>
        * <span data-ttu-id="a30c4-130">Typy danych zdefiniowane przez użytkownika w postaci`class C {...}`</span><span class="sxs-lookup"><span data-stu-id="a30c4-130">User-defined types of the form `class C {...}`</span></span>
    - <span data-ttu-id="a30c4-131">Typy interfejsów</span><span class="sxs-lookup"><span data-stu-id="a30c4-131">Interface types</span></span>
        * <span data-ttu-id="a30c4-132">Typy danych zdefiniowane przez użytkownika w postaci`interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="a30c4-132">User-defined types of the form `interface I {...}`</span></span>
    - <span data-ttu-id="a30c4-133">Typy tablic</span><span class="sxs-lookup"><span data-stu-id="a30c4-133">Array types</span></span>
        * <span data-ttu-id="a30c4-134">Jedno - i są one wielowymiarowe, na przykład `int[]` i`int[,]`</span><span class="sxs-lookup"><span data-stu-id="a30c4-134">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
    - <span data-ttu-id="a30c4-135">Typy delegatów</span><span class="sxs-lookup"><span data-stu-id="a30c4-135">Delegate types</span></span>
        * <span data-ttu-id="a30c4-136">Typy danych zdefiniowane przez użytkownika w postaci`delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="a30c4-136">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="a30c4-137">Typy całkowite osiem zapewniają obsługę 8-bitową, 16-bitowych, 32-bitowe i 64-bitowej wartości formularza podpisem lub bez.</span><span class="sxs-lookup"><span data-stu-id="a30c4-137">The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</span></span>

<span data-ttu-id="a30c4-138">Dwa typy zmiennoprzecinkowe, `float` i `double`, są reprezentowane w 32-bitowych pojedynczej precyzji i 64-bitowe o podwójnej dokładności IEC 60559 formatów, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="a30c4-138">The two floating-point types, `float` and `double`, are represented using the 32-bit single-precision and 64-bit double-precision IEC-60559 formats, respectively.</span></span>

<span data-ttu-id="a30c4-139">`decimal` Typ jest typem danych 128-bitowego odpowiedni do obliczeń finansowych i finansowe.</span><span class="sxs-lookup"><span data-stu-id="a30c4-139">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span>

<span data-ttu-id="a30c4-140">C# w `bool` typ jest używany do reprezentowania wartości logicznych — wartości, które są `true` lub `false`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-140">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="a30c4-141">Znak, a ciąg przetwarzania w języku C# używa kodowanie Unicode.</span><span class="sxs-lookup"><span data-stu-id="a30c4-141">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="a30c4-142">`char` Typu reprezentuje jednostkę kodu UTF-16 i `string` typu reprezentuje sekwencję jednostek kodu UTF-16.</span><span class="sxs-lookup"><span data-stu-id="a30c4-142">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="a30c4-143">To podsumowanie typy liczbowe C# firmy.</span><span class="sxs-lookup"><span data-stu-id="a30c4-143">This summarizes C#’s numeric types.</span></span>

* <span data-ttu-id="a30c4-144">Typy całkowite podpisem</span><span class="sxs-lookup"><span data-stu-id="a30c4-144">Signed Integral</span></span>
    - <span data-ttu-id="a30c4-145">`sbyte`: 8 bitów, z zakresu od -128 do 127.</span><span class="sxs-lookup"><span data-stu-id="a30c4-145">`sbyte`:  8 bits, range from -128 - 127</span></span>
    - <span data-ttu-id="a30c4-146">`short`: 16 bitów, z zakresu od-32 768-32 767 znaków</span><span class="sxs-lookup"><span data-stu-id="a30c4-146">`short`: 16 bits, range from -32,768 - 32,767</span></span>
    - <span data-ttu-id="a30c4-147">`int`: 32-bitowy, zakresu od -2,147,483,648-2 147 483 647</span><span class="sxs-lookup"><span data-stu-id="a30c4-147">`int`  : 32 bits, range from -2,147,483,648 - 2,147,483,647</span></span>
    - <span data-ttu-id="a30c4-148">`long`: 64-bitowy, w zakresie od –9,223,372,036,854,775,808 do 9,223,372,036,854,775,807</span><span class="sxs-lookup"><span data-stu-id="a30c4-148">`long` : 64 bits, range from –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span></span>
* <span data-ttu-id="a30c4-149">Typy całkowite bez znaku</span><span class="sxs-lookup"><span data-stu-id="a30c4-149">Unsigned integral</span></span>
    - <span data-ttu-id="a30c4-150">`byte`: 8 bitów należeć do zakresu od 0 – 255</span><span class="sxs-lookup"><span data-stu-id="a30c4-150">`byte`   :  8 bits, range from 0 - 255</span></span>
    - <span data-ttu-id="a30c4-151">`ushort`: 16 bitów należeć do zakresu od 0 - 65 535</span><span class="sxs-lookup"><span data-stu-id="a30c4-151">`ushort` : 16 bits, range from 0 - 65,535</span></span>
    - <span data-ttu-id="a30c4-152">`uint`: 32-bitowy, należeć do zakresu od 0 - 4 294 967 295</span><span class="sxs-lookup"><span data-stu-id="a30c4-152">`uint`   : 32 bits, range from 0 - 4,294,967,295</span></span>
    - <span data-ttu-id="a30c4-153">`ulong`: 64-bitowy, należeć do zakresu od 0 - 18,446,744,073,709,551,615</span><span class="sxs-lookup"><span data-stu-id="a30c4-153">`ulong`  : 64 bits, range from 0 - 18,446,744,073,709,551,615</span></span>
* <span data-ttu-id="a30c4-154">Liczba zmiennoprzecinkowa</span><span class="sxs-lookup"><span data-stu-id="a30c4-154">Floating point</span></span>
    - <span data-ttu-id="a30c4-155">`float`: 32-bitowy, należeć do zakresu od 1,5 x 10<sup>−45</sup> -3,4 x 10<sup>38</sup>, 7-cyfrowy dokładności</span><span class="sxs-lookup"><span data-stu-id="a30c4-155">`float`  : 32 bits, range from 1.5 × 10<sup>−45</sup> - 3.4 × 10<sup>38</sup>,    7-digit precision</span></span>
    - <span data-ttu-id="a30c4-156">`double`: 64-bitowy, należeć do zakresu od 5.0 x 10<sup>−324</sup> -1.7 x 10<sup>308</sup>, dokładności 15 cyfr</span><span class="sxs-lookup"><span data-stu-id="a30c4-156">`double` : 64 bits, range from 5.0 × 10<sup>−324</sup> - 1.7 × 10<sup>308</sup>, 15-digit precision</span></span>
* <span data-ttu-id="a30c4-157">Wartość dziesiętna</span><span class="sxs-lookup"><span data-stu-id="a30c4-157">Decimal</span></span>
    - <span data-ttu-id="a30c4-158">`decimal`: 128 bitów, zakres jest co najmniej –7.9 x 10<sup>−28</sup> -7,9 x 10<sup>28</sup>, o co najmniej 28 cyfr precyzji</span><span class="sxs-lookup"><span data-stu-id="a30c4-158">`decimal` : 128 bits, range is at least –7.9 × 10<sup>−28</sup> -  7.9 × 10<sup>28</sup>, with at least 28-digit precision</span></span>
    
<span data-ttu-id="a30c4-159">C# Użyj programy *wpisz deklaracje* do tworzenia nowych typów.</span><span class="sxs-lookup"><span data-stu-id="a30c4-159">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="a30c4-160">Deklaracja typu Określa nazwę i elementów członkowskich nowego typu.</span><span class="sxs-lookup"><span data-stu-id="a30c4-160">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="a30c4-161">Pięć kategorii C# dla typów są definiowane przez użytkownika: klasa typy, typy struktur, typów interfejsów, Typy wyliczeniowe i typów delegatów.</span><span class="sxs-lookup"><span data-stu-id="a30c4-161">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="a30c4-162">A `class` typ definiuje struktury danych, który zawiera elementy członkowskie danych (pola) i funkcja członków (metody, właściwości i inne).</span><span class="sxs-lookup"><span data-stu-id="a30c4-162">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="a30c4-163">Typy klas obsługuje pojedyncze dziedziczenie i polimorfizm, mechanizmów zgodnie z którymi klas pochodnych można rozszerzać i której specialize klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="a30c4-163">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="a30c4-164">A `struct` typu jest podobny do typu klasy reprezentuje struktury z elementów członkowskich danych i funkcji elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="a30c4-164">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="a30c4-165">W przeciwieństwie do klasy, struktury są typy wartości i nie wymagają zazwyczaj Alokacja sterty.</span><span class="sxs-lookup"><span data-stu-id="a30c4-165">However, unlike classes, structs are value types and do not typically require heap allocation.</span></span> <span data-ttu-id="a30c4-166">Typy struktur nie obsługują określone przez użytkownika dziedziczenia, a wszystkie typy struktur niejawnie dziedziczyć z typu `object`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-166">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="a30c4-167">`interface` Typ definiuje kontrakt jako nazwany zestaw funkcji publicznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="a30c4-167">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="a30c4-168">A `class` lub `struct` implementującej `interface` muszą zawierać implementacje interfejsu funkcji członków.</span><span class="sxs-lookup"><span data-stu-id="a30c4-168">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="a30c4-169">`interface` Może dziedziczyć po wielu interfejsach podstawowych, a `class` lub `struct` mogą zaimplementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="a30c4-169">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="a30c4-170">A `delegate` typu reprezentuje odwołania do metod z określonego parametru listy i typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="a30c4-170">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="a30c4-171">Obiekty delegowane umożliwiają traktować jako jednostek, które można przypisywać do zmiennych i przekazywane jako parametry metody.</span><span class="sxs-lookup"><span data-stu-id="a30c4-171">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="a30c4-172">Obiekty delegowane są odpowiednikiem typy funkcji dostarczonych przez funkcjonalności języków.</span><span class="sxs-lookup"><span data-stu-id="a30c4-172">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="a30c4-173">Są one również podobny do koncepcji znaleziono w przypadku niektórych języków innych wskaźników funkcji, ale w przeciwieństwie do wskaźników funkcji delegatów są zorientowane obiektowo i bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="a30c4-173">They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="a30c4-174">`class`, `struct`, `interface` i `delegate` typy wszystkie ogólne pomocy technicznej, zgodnie z którymi mogą nadać parametry z innych typów.</span><span class="sxs-lookup"><span data-stu-id="a30c4-174">The `class`, `struct`, `interface` and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="a30c4-175">`enum` Typ jest typem distinct z stałe nazwane.</span><span class="sxs-lookup"><span data-stu-id="a30c4-175">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="a30c4-176">Każdy `enum` typ ma odpowiedni typ, który musi być jedną z ośmiu typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="a30c4-176">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="a30c4-177">Zbiór wartości `enum` typ jest taki sam, jak zestaw wartości typu bazowego.</span><span class="sxs-lookup"><span data-stu-id="a30c4-177">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="a30c4-178">C# obsługuje dimensional jednym i wielu tablice dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="a30c4-178">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="a30c4-179">W przeciwieństwie do typów wymienionych powyżej typy tablic nie trzeba być zadeklarowana przed ich użyciem.</span><span class="sxs-lookup"><span data-stu-id="a30c4-179">Unlike the types listed above, array types do not have to be declared before they can be used.</span></span> <span data-ttu-id="a30c4-180">Zamiast tego typy tablic są wykonane przez następujące Nazwa typu w nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="a30c4-180">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="a30c4-181">Na przykład `int[]` jest tablicy jednowymiarowej z `int`, `int[,]` jest tablicą dwuwymiarową z `int`, i `int[][]` jest tablicy jednowymiarowej tablicy jednowymiarowej `int`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-181">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="a30c4-182">Typy dopuszczające wartości zerowe wartości również nie trzeba być zadeklarowana przed ich użyciem.</span><span class="sxs-lookup"><span data-stu-id="a30c4-182">Nullable value types also do not have to be declared before they can be used.</span></span> <span data-ttu-id="a30c4-183">Dla każdego typu wartość niezerowalna `T` istnieje odpowiedni typ wartości null `T?`, która zawiera dodatkowe wartości `null`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-183">For each non-nullable value type `T` there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="a30c4-184">Na przykład `int?` jest typem, który może posiadać żadnych 32-bitową liczbą całkowitą lub wartość `null`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-184">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="a30c4-185">System typów C# w jest unified w taki sposób, że wartość dowolnego typu może być traktowana jako `object`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-185">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="a30c4-186">Każdy typ w języku C#, bezpośrednio lub pośrednio pochodzi z `object` typ, klasy i `object` jest klasą bazową ultimate wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="a30c4-186">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="a30c4-187">Wartości typu odwołania są traktowane jako obiekty po prostu, wyświetlając wartości jako typ `object`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-187">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="a30c4-188">Wartości typów wartości są traktowane jako obiekty, wykonując *boxing* i *rozpakowującej operacji*.</span><span class="sxs-lookup"><span data-stu-id="a30c4-188">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="a30c4-189">W poniższym przykładzie `int` wartość jest konwertowana na `object` i ponownie utworzyć kopię `int`.</span><span class="sxs-lookup"><span data-stu-id="a30c4-189">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="a30c4-190">Jeśli wartość typu wartości jest konwertowana na typ `object`, `object` wystąpienia, nazywane również "pola", jest przeznaczona do przechowywania wartości, a wartość jest kopiowana do tego pola.</span><span class="sxs-lookup"><span data-stu-id="a30c4-190">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="a30c4-191">Z drugiej strony, gdy `object` odwołania jest Rzutowanie na typ wartości, dokonuje który przywoływana `object` jest polem typu poprawną wartość i, jeśli sprawdzenie zakończy się powodzeniem, wartość w polu jest kopiowana.</span><span class="sxs-lookup"><span data-stu-id="a30c4-191">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="a30c4-192">System typów ujednoliconego C# w oznacza, że typów wartości może stać się obiekty "na żądanie."</span><span class="sxs-lookup"><span data-stu-id="a30c4-192">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="a30c4-193">Z powodu ujednolicenie, bibliotek ogólnego przeznaczenia, które używają typu `object` można używać z typów wartości i typy referencyjne.</span><span class="sxs-lookup"><span data-stu-id="a30c4-193">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="a30c4-194">Istnieje kilka typów z *zmienne* w języku C#, w tym pól, elementy tablicy, zmienne lokalne i parametry.</span><span class="sxs-lookup"><span data-stu-id="a30c4-194">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="a30c4-195">Zmienne reprezentują lokalizacje magazynu, a co zmienna ma typ, który określa, jakie wartości mogą być przechowywane w zmiennej, jak pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="a30c4-195">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

* <span data-ttu-id="a30c4-196">Typ wartości niedopuszczająca wartości null</span><span class="sxs-lookup"><span data-stu-id="a30c4-196">Non-nullable value type</span></span>
    - <span data-ttu-id="a30c4-197">Wartość tego dokładnego typu</span><span class="sxs-lookup"><span data-stu-id="a30c4-197">A value of that exact type</span></span>
* <span data-ttu-id="a30c4-198">Typ wartości null</span><span class="sxs-lookup"><span data-stu-id="a30c4-198">Nullable value type</span></span>
    - <span data-ttu-id="a30c4-199">A `null` lub wartości dokładnego typu</span><span class="sxs-lookup"><span data-stu-id="a30c4-199">A `null` value or a value of that exact type</span></span>
* <span data-ttu-id="a30c4-200">object</span><span class="sxs-lookup"><span data-stu-id="a30c4-200">object</span></span>
    - <span data-ttu-id="a30c4-201">A `null` odwołania, odwołanie do obiektu dowolnego typu odwołanie lub odwołanie do wartości spakowanej dowolnego typu wartości</span><span class="sxs-lookup"><span data-stu-id="a30c4-201">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
* <span data-ttu-id="a30c4-202">Typ klasy</span><span class="sxs-lookup"><span data-stu-id="a30c4-202">Class type</span></span>
    - <span data-ttu-id="a30c4-203">A `null` odwołania, odwołania do wystąpienia tego typu klasy lub odwołanie do wystąpienia klasy pochodnej z tego typu klasy</span><span class="sxs-lookup"><span data-stu-id="a30c4-203">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
* <span data-ttu-id="a30c4-204">Typ interfejsu</span><span class="sxs-lookup"><span data-stu-id="a30c4-204">Interface type</span></span>
    - <span data-ttu-id="a30c4-205">A `null` odwołania, odwołania do wystąpienia typu klasy, która implementuje interfejs typu lub odwołanie do wartości spakowanej typu wartości, który implementuje interfejs typu</span><span class="sxs-lookup"><span data-stu-id="a30c4-205">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
* <span data-ttu-id="a30c4-206">Typ tablicy</span><span class="sxs-lookup"><span data-stu-id="a30c4-206">Array type</span></span>
    - <span data-ttu-id="a30c4-207">A `null` odwołania, odwołania do wystąpienia tego typu tablicy lub odwołania do wystąpienia typu tablicy zgodne</span><span class="sxs-lookup"><span data-stu-id="a30c4-207">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
* <span data-ttu-id="a30c4-208">Typ delegata</span><span class="sxs-lookup"><span data-stu-id="a30c4-208">Delegate type</span></span>
    - <span data-ttu-id="a30c4-209">A `null` odwołanie lub odwołanie do wystąpienia typu delegata zgodne</span><span class="sxs-lookup"><span data-stu-id="a30c4-209">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="a30c4-210">[Poprzednie](program-structure.md)
[dalej](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="a30c4-210">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
