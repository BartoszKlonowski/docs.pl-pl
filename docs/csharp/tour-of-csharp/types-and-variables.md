---
title: C#Typy i zmienne — Przewodnik po przykładzie C# języka
description: Informacje na temat definiowania typów i zadeklarowania zmiennych wC#
ms.date: 08/10/2016
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: ae44dd273a2460e5718adc7324fae324e3de5bba
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61675744"
---
# <a name="types-and-variables"></a><span data-ttu-id="8eef4-103">Typy i zmienne</span><span class="sxs-lookup"><span data-stu-id="8eef4-103">Types and variables</span></span>

<span data-ttu-id="8eef4-104">Istnieją dwa rodzaje typów w języku C#: *typy wartości* i *typy odwołań*.</span><span class="sxs-lookup"><span data-stu-id="8eef4-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="8eef4-105">Zmienne typu wartości zawierają bezpośrednio swoje dane, natomiast zmiennych typu referencyjnego są przechowywane odwołania do swoich danych, te ostatnie są nazywane obiektów.</span><span class="sxs-lookup"><span data-stu-id="8eef4-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="8eef4-106">W przypadku typów referencyjnych jest możliwe w dwóch zmiennych odwoływać się do tego samego obiektu i dlatego możliwe dla operacji na jednej zmiennej miały wpływ na obiekt odwołuje się druga zmienna.</span><span class="sxs-lookup"><span data-stu-id="8eef4-106">With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="8eef4-107">Z typami wartości zmiennych każda ma własne kopię danych i nie jest możliwe dla operacji na jednym wpłynie na inne (z wyjątkiem w przypadku właściwości `ref` i `out` zmiennych parametrów).</span><span class="sxs-lookup"><span data-stu-id="8eef4-107">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="8eef4-108">C#dla typów wartości są podzielone na *typów prostych*, *typach wyliczeniowych*, *typy struktury*, i *typy o wartości zerowalnej*.</span><span class="sxs-lookup"><span data-stu-id="8eef4-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="8eef4-109">C#na typy odwołań są podzielone na *klasy typów*, *typy interfejsów*, *tablicy typów*, i *typy delegatów*.</span><span class="sxs-lookup"><span data-stu-id="8eef4-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="8eef4-110">Poniżej znajdują się z omówieniem C#przez system typów.</span><span class="sxs-lookup"><span data-stu-id="8eef4-110">The following provides an overview of C#’s type system.</span></span>

* <span data-ttu-id="8eef4-111">[Typy wartości][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="8eef4-112">[Typy proste][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-112">[Simple types][SimpleTypes]</span></span>
    * <span data-ttu-id="8eef4-113">Podpisana całkowitego: `sbyte`, `short`, `int`, `long`</span><span class="sxs-lookup"><span data-stu-id="8eef4-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    * <span data-ttu-id="8eef4-114">Całkowite bez znaku: `byte`, `ushort`, `uint`, `ulong`</span><span class="sxs-lookup"><span data-stu-id="8eef4-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    * <span data-ttu-id="8eef4-115">Znaki Unicode: `char`</span><span class="sxs-lookup"><span data-stu-id="8eef4-115">Unicode characters: `char`</span></span>
    * <span data-ttu-id="8eef4-116">Liczba zmiennoprzecinkowa IEEE: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="8eef4-116">IEEE floating point: `float`, `double`</span></span>
    * <span data-ttu-id="8eef4-117">Decimal wysokiej precyzji: `decimal`</span><span class="sxs-lookup"><span data-stu-id="8eef4-117">High-precision decimal: `decimal`</span></span>
    * <span data-ttu-id="8eef4-118">Atrybut typu wartość logiczna: `bool`</span><span class="sxs-lookup"><span data-stu-id="8eef4-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="8eef4-119">[Typach wyliczeniowych][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-119">[Enum types][EnumTypes]</span></span>
    * <span data-ttu-id="8eef4-120">Typy zdefiniowane przez użytkownika w postaci `enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="8eef4-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="8eef4-121">[Typy — struktura][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-121">[Struct types][StructTypes]</span></span>
    * <span data-ttu-id="8eef4-122">Typy zdefiniowane przez użytkownika w postaci `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="8eef4-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="8eef4-123">[Typy o wartości zerowalnej][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-123">[Nullable value types][NullableTypes]</span></span>
    * <span data-ttu-id="8eef4-124">Rozszerzenia z innych typów wartości za pomocą `null` wartość</span><span class="sxs-lookup"><span data-stu-id="8eef4-124">Extensions of all other value types with a `null` value</span></span>
* <span data-ttu-id="8eef4-125">[Typy odwołań][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-125">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="8eef4-126">[Typy klas][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-126">[Class types][ClassTypes]</span></span>
    * <span data-ttu-id="8eef4-127">Ultimate klasa bazowa innych typów: `object`</span><span class="sxs-lookup"><span data-stu-id="8eef4-127">Ultimate base class of all other types: `object`</span></span>
    * <span data-ttu-id="8eef4-128">Ciągi Unicode: `string`</span><span class="sxs-lookup"><span data-stu-id="8eef4-128">Unicode strings: `string`</span></span>
    * <span data-ttu-id="8eef4-129">Typy zdefiniowane przez użytkownika w postaci `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="8eef4-129">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="8eef4-130">[Typy interfejsów][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-130">[Interface types][InterfaceTypes]</span></span>
    * <span data-ttu-id="8eef4-131">Typy zdefiniowane przez użytkownika w postaci `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="8eef4-131">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="8eef4-132">[Typy tablic][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-132">[Array types][ArrayTypes]</span></span>
    * <span data-ttu-id="8eef4-133">Jedno - i są one wielowymiarowe, na przykład `int[]` i `int[,]`</span><span class="sxs-lookup"><span data-stu-id="8eef4-133">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="8eef4-134">[Typy delegatów][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="8eef4-134">[Delegate types][DelegateTypes]</span></span>
    * <span data-ttu-id="8eef4-135">Typy zdefiniowane przez użytkownika w postaci `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="8eef4-135">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/keywords/value-types-table.md
[SimpleTypes]: ../language-reference/keywords/value-types.md#simple-types
[EnumTypes]: ../language-reference/keywords/enum.md
[StructTypes]: ../language-reference/keywords/struct.md
[NullableTypes]: ../programming-guide/nullable-types/index.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="8eef4-136">Osiem typów całkowitych zapewniają obsługę wartości 8-bitową, 16-bitowych, 32-bitowych i 64-bitowe podpisane lub niepodpisane formularza.</span><span class="sxs-lookup"><span data-stu-id="8eef4-136">The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</span></span>

<span data-ttu-id="8eef4-137">Dwa typy zmiennoprzecinkowe, `float` i `double`, są reprezentowane przy użyciu 32-bitowe o pojedynczej dokładności i 64-bitowych podwójnej precyzji IEC 60559 formatów, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="8eef4-137">The two floating-point types, `float` and `double`, are represented using the 32-bit single-precision and 64-bit double-precision IEC-60559 formats, respectively.</span></span>

<span data-ttu-id="8eef4-138">`decimal` Typ to typ danych 128-bitowych, odpowiedni do obliczeń finansowych i walutowych.</span><span class="sxs-lookup"><span data-stu-id="8eef4-138">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span>

<span data-ttu-id="8eef4-139">C#firmy `bool` typ jest używany do reprezentowania wartości logicznych — wartości, które są albo `true` lub `false`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-139">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="8eef4-140">Znakowe i przetwarzania w języku C# przy użyciu kodowania Unicode.</span><span class="sxs-lookup"><span data-stu-id="8eef4-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="8eef4-141">`char` Typ reprezentuje jednostkę kodu UTF-16 i `string` typu reprezentuje sekwencję jednostki kodu UTF-16.</span><span class="sxs-lookup"><span data-stu-id="8eef4-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="8eef4-142">To znajduje się podsumowanie C#na typy liczbowe.</span><span class="sxs-lookup"><span data-stu-id="8eef4-142">This summarizes C#’s numeric types.</span></span>

* <span data-ttu-id="8eef4-143">Całkowite podpisem</span><span class="sxs-lookup"><span data-stu-id="8eef4-143">Signed Integral</span></span>
  - <span data-ttu-id="8eef4-144">`sbyte`:  8 bitów, z zakresu od -128 do 127</span><span class="sxs-lookup"><span data-stu-id="8eef4-144">`sbyte`:  8 bits, range from -128 to 127</span></span>
  - <span data-ttu-id="8eef4-145">`short`: 16 bitów, z zakresu od-32 768 do 32 767 znaków</span><span class="sxs-lookup"><span data-stu-id="8eef4-145">`short`: 16 bits, range from -32,768 to 32,767</span></span>
  - <span data-ttu-id="8eef4-146">`int`  : 32-bitowy, do zakresu od -2,147,483,648 do 2 147 483 647</span><span class="sxs-lookup"><span data-stu-id="8eef4-146">`int`  : 32 bits, range from -2,147,483,648 to 2,147,483,647</span></span>
  - <span data-ttu-id="8eef4-147">`long` : 64-bitowy, do zakresu od-9,223,372,036,854,775,808 do 9,223,372,036,854,775,807</span><span class="sxs-lookup"><span data-stu-id="8eef4-147">`long` : 64 bits, range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span></span>
* <span data-ttu-id="8eef4-148">Całkowite bez znaku</span><span class="sxs-lookup"><span data-stu-id="8eef4-148">Unsigned integral</span></span>
  - <span data-ttu-id="8eef4-149">`byte`   :  8 bitów, z zakresu od 0 do 255</span><span class="sxs-lookup"><span data-stu-id="8eef4-149">`byte`   :  8 bits, range from 0 to 255</span></span>
  - <span data-ttu-id="8eef4-150">`ushort` : 16 bitów, z zakresu od 0 do 65 535 działań</span><span class="sxs-lookup"><span data-stu-id="8eef4-150">`ushort` : 16 bits, range from 0 to 65,535</span></span>
  - <span data-ttu-id="8eef4-151">`uint`   : 32-bitowy z zakresu od 0 do 4 294 967 295</span><span class="sxs-lookup"><span data-stu-id="8eef4-151">`uint`   : 32 bits, range from 0 to 4,294,967,295</span></span>
  - <span data-ttu-id="8eef4-152">`ulong`  : 64-bitowy z zakresu od 0 do 18,446,744,073,709,551,615</span><span class="sxs-lookup"><span data-stu-id="8eef4-152">`ulong`  : 64 bits, range from 0 to 18,446,744,073,709,551,615</span></span>
* <span data-ttu-id="8eef4-153">Liczba zmiennoprzecinkowa</span><span class="sxs-lookup"><span data-stu-id="8eef4-153">Floating point</span></span>
  - <span data-ttu-id="8eef4-154">`float`  : 32-bitowy, do zakresu od 1,5 x 10<sup>-45</sup> do 3,4 x 10<sup>38</sup>, dokładności 7 cyfr</span><span class="sxs-lookup"><span data-stu-id="8eef4-154">`float`  : 32 bits, range from 1.5 × 10<sup>-45</sup> to 3.4 × 10<sup>38</sup>,    7-digit precision</span></span>
  - <span data-ttu-id="8eef4-155">`double` : 64-bitowy, do zakresu od 5.0 x 10<sup>-324</sup> do wersji 1.7 x 10<sup>308</sup>, dokładności 15 cyfr</span><span class="sxs-lookup"><span data-stu-id="8eef4-155">`double` : 64 bits, range from 5.0 × 10<sup>-324</sup> to 1.7 × 10<sup>308</sup>, 15-digit precision</span></span>
* <span data-ttu-id="8eef4-156">Wartość dziesiętna</span><span class="sxs-lookup"><span data-stu-id="8eef4-156">Decimal</span></span>
  - <span data-ttu-id="8eef4-157">`decimal` : 128 bitów — zakres jest co najmniej od -7,9 x 10<sup>-28</sup> do 7,9 x 10<sup>28</sup>, z dokładnością co najmniej 28-cyfrowy</span><span class="sxs-lookup"><span data-stu-id="8eef4-157">`decimal` : 128 bits, range is at least -7.9 × 10<sup>-28</sup> to 7.9 × 10<sup>28</sup>, with at least 28-digit precision</span></span>

<span data-ttu-id="8eef4-158">C# programy użyj *wpisz deklaracje* do tworzenia nowych typów.</span><span class="sxs-lookup"><span data-stu-id="8eef4-158">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="8eef4-159">Deklaracja typu Określa nazwę i elementy członkowskie nowego typu.</span><span class="sxs-lookup"><span data-stu-id="8eef4-159">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="8eef4-160">Pięciu C#firmy kategorie typów są definiowane przez użytkownika: klasy, typy, typy struktury, typy interfejsów, typach wyliczeniowych i typy delegatów.</span><span class="sxs-lookup"><span data-stu-id="8eef4-160">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="8eef4-161">A `class` typ definiuje strukturę danych, który zawiera elementy członkowskie danych (pola) i składowe funkcji (metody, właściwości i inne).</span><span class="sxs-lookup"><span data-stu-id="8eef4-161">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="8eef4-162">Typy klas obsługuje pojedyncze dziedziczenie i polimorfizmu, mechanizmów, według której rozszerzać i specialize klas bazowych klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="8eef4-162">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="8eef4-163">A `struct` typ jest podobny do typu klasy, w tym, że reprezentuje strukturę z elementów członkowskich danych i składowe funkcji.</span><span class="sxs-lookup"><span data-stu-id="8eef4-163">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="8eef4-164">W przeciwieństwie do klasy, struktury są typami wartości i zazwyczaj nie angażuje Alokacja sterty.</span><span class="sxs-lookup"><span data-stu-id="8eef4-164">However, unlike classes, structs are value types and do not typically require heap allocation.</span></span> <span data-ttu-id="8eef4-165">Typy struktury nie obsługują dziedziczenia określonych przez użytkownika, a wszystkie typy struktury niejawnie dziedziczą z typu `object`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-165">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="8eef4-166">`interface` Typ definiuje kontrakt jako nazwany zestaw funkcji publicznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="8eef4-166">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="8eef4-167">A `class` lub `struct` implementującej `interface` muszą dostarczać implementacje interfejsu funkcji składowych.</span><span class="sxs-lookup"><span data-stu-id="8eef4-167">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="8eef4-168">`interface` Może dziedziczyć z wielu interfejsach podstawowych, a `class` lub `struct` może zaimplementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="8eef4-168">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="8eef4-169">A `delegate` typ reprezentuje odwołania do metod z określoną listą parametrów i typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="8eef4-169">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="8eef4-170">Delegatów można umożliwić traktować metod jako jednostki, które mogą być przypisane do zmiennych i przekazywane jako parametry.</span><span class="sxs-lookup"><span data-stu-id="8eef4-170">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="8eef4-171">Obiekty delegowane są analogiczne do typów funkcji dostarczonych przez języków funkcjonalnych.</span><span class="sxs-lookup"><span data-stu-id="8eef4-171">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="8eef4-172">Są one również podobne do koncepcji wskaźników funkcji, w przeciwieństwie do innych języków, ale w przeciwieństwie do wskaźników funkcji, obiekty delegowane są zorientowane obiektowo i bezpieczny typowo.</span><span class="sxs-lookup"><span data-stu-id="8eef4-172">They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="8eef4-173">`class`, `struct`, `interface` i `delegate` typy wszystkie elementy rodzajowe pomocy technicznej, według których mogą być parametryzowane przy użyciu innych typów.</span><span class="sxs-lookup"><span data-stu-id="8eef4-173">The `class`, `struct`, `interface` and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="8eef4-174">`enum` Typ jest typem samodzielnym z nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="8eef4-174">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="8eef4-175">Każdy `enum` typ ma typu podstawowego musi być jednym z ośmiu typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="8eef4-175">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="8eef4-176">Zestaw wartości `enum` typ jest taki sam zestaw wartości typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="8eef4-176">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="8eef4-177">C# obsługuje dimensional jednym i wielu tablic dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="8eef4-177">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="8eef4-178">W przeciwieństwie do typów wymienionych powyżej typy tablic ma zadeklarowany, zanim będzie można ich użyć.</span><span class="sxs-lookup"><span data-stu-id="8eef4-178">Unlike the types listed above, array types do not have to be declared before they can be used.</span></span> <span data-ttu-id="8eef4-179">Zamiast tego typy tablicowe są konstruowane wykonując nazwę typu z nawiasami kwadratowymi.</span><span class="sxs-lookup"><span data-stu-id="8eef4-179">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="8eef4-180">Na przykład `int[]` to Jednowymiarowa tablica `int`, `int[,]` to dwuwymiarowa tablica `int`, i `int[][]` jest tablicą jednowymiarową tablicę jednowymiarową `int`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-180">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="8eef4-181">Typy o wartości zerowalnej również ma być zadeklarowany, zanim będzie można ich użyć.</span><span class="sxs-lookup"><span data-stu-id="8eef4-181">Nullable value types also do not have to be declared before they can be used.</span></span> <span data-ttu-id="8eef4-182">Dla każdego typu wartości niedopuszczającym wartości `T` istnieje odpowiedni typ wartości zerowalnej `T?`, który może zawierać dodatkowe wartości `null`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-182">For each non-nullable value type `T` there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="8eef4-183">Na przykład `int?` jest typem, który może pomieścić dowolna liczba całkowita 32-bitowych lub wartość `null`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-183">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="8eef4-184">C#w systemie typów jest jednolita w taki sposób, że wartość dowolnego typu może być traktowana jako `object`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-184">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="8eef4-185">Każdy typ w języku C#, bezpośrednio lub pośrednio pochodzi z `object` typ, klasy i `object` jest ultimate klasą bazową wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="8eef4-185">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="8eef4-186">Wartości typu referencyjnego są traktowane jako obiekty poprzez wyświetlanie wartości jako typu `object`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-186">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="8eef4-187">Wartości typu wartości są traktowane jako obiekty, wykonując *pakowania* i *Rozpakowywanie operacje*.</span><span class="sxs-lookup"><span data-stu-id="8eef4-187">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="8eef4-188">W poniższym przykładzie `int` wartość jest konwertowana na `object` i wykonać ich kopię ponownie do `int`.</span><span class="sxs-lookup"><span data-stu-id="8eef4-188">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="8eef4-189">Gdy wartość typu wartości jest konwertowany na typ `object`, `object` wystąpienia, nazywany również "pola", jest przeznaczona do przechowywania wartości, a wartość jest kopiowana do tego pola.</span><span class="sxs-lookup"><span data-stu-id="8eef4-189">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="8eef4-190">Z drugiej strony, gdy `object` odwołania jest rzutowany na typ wartości, dokonuje, występujących w odwołaniu `object` jest polem typu poprawnej wartości, i, jeśli sprawdzenie zakończy się powodzeniem, wartość w polu jest kopiowana.</span><span class="sxs-lookup"><span data-stu-id="8eef4-190">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="8eef4-191">C#jego unified typu systemu oznacza, że typy wartości może stać się obiekty "na żądanie."</span><span class="sxs-lookup"><span data-stu-id="8eef4-191">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="8eef4-192">Ze względu na ujednolicenie ogólnego przeznaczenia biblioteki, które używają typu `object` mogą być używane z typami odwołań i typy wartości.</span><span class="sxs-lookup"><span data-stu-id="8eef4-192">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="8eef4-193">Istnieje kilka rodzajów z *zmienne* w języku C#, w tym pól, elementy tablicy, zmienne lokalne i parametry.</span><span class="sxs-lookup"><span data-stu-id="8eef4-193">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="8eef4-194">Zmienne reprezentują lokalizacje przechowywania, a co zmienna ma typ, który określa, jakie wartości mogą być przechowywane w zmiennej, jak pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="8eef4-194">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

* <span data-ttu-id="8eef4-195">Typ wartości nieprzyjmujące</span><span class="sxs-lookup"><span data-stu-id="8eef4-195">Non-nullable value type</span></span>
  - <span data-ttu-id="8eef4-196">Wartość tego typu dokładnie</span><span class="sxs-lookup"><span data-stu-id="8eef4-196">A value of that exact type</span></span>
* <span data-ttu-id="8eef4-197">Typ wartości null</span><span class="sxs-lookup"><span data-stu-id="8eef4-197">Nullable value type</span></span>
  - <span data-ttu-id="8eef4-198">A `null` wartość lub wartość tego typu dokładnie</span><span class="sxs-lookup"><span data-stu-id="8eef4-198">A `null` value or a value of that exact type</span></span>
* <span data-ttu-id="8eef4-199">object</span><span class="sxs-lookup"><span data-stu-id="8eef4-199">object</span></span>
  - <span data-ttu-id="8eef4-200">A `null` odwołanie, odwołanie do obiektu typu odwołania lub odwołania do wartości spakowanej dowolnego typu wartości</span><span class="sxs-lookup"><span data-stu-id="8eef4-200">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
* <span data-ttu-id="8eef4-201">Typ klasy</span><span class="sxs-lookup"><span data-stu-id="8eef4-201">Class type</span></span>
  - <span data-ttu-id="8eef4-202">A `null` odwołanie, odwołanie do wystąpienia tego typu klasy lub odwołanie do wystąpienia klasy pochodzącej od typu klasy</span><span class="sxs-lookup"><span data-stu-id="8eef4-202">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
* <span data-ttu-id="8eef4-203">Typ interfejsu</span><span class="sxs-lookup"><span data-stu-id="8eef4-203">Interface type</span></span>
  - <span data-ttu-id="8eef4-204">A `null` odwołanie, odwołanie do wystąpienia typu klasy, która implementuje interfejs typu lub odwołanie do wartości spakowanej typu wartości, która implementuje interfejs typu</span><span class="sxs-lookup"><span data-stu-id="8eef4-204">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
* <span data-ttu-id="8eef4-205">Typ tablicy</span><span class="sxs-lookup"><span data-stu-id="8eef4-205">Array type</span></span>
  - <span data-ttu-id="8eef4-206">A `null` odwołanie, odwołanie do wystąpienia tego typu tablicy lub odwołanie do wystąpienia typu tablicy zgodne</span><span class="sxs-lookup"><span data-stu-id="8eef4-206">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
* <span data-ttu-id="8eef4-207">Typ delegata</span><span class="sxs-lookup"><span data-stu-id="8eef4-207">Delegate type</span></span>
  - <span data-ttu-id="8eef4-208">A `null` odwołanie lub odwołanie do wystąpienia typu delegowanego zgodne</span><span class="sxs-lookup"><span data-stu-id="8eef4-208">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="8eef4-209">[Poprzednie](program-structure.md)
> [dalej](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="8eef4-209">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
