---
title: Typy i zmienne języka C# — przewodnik po języku Języka C#
description: 'Dowiedz się więcej o definiowaniu typów i deklarowaniu zmiennych w języku C #'
ms.date: 02/25/2020
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: b2a5255a243c12543a1cd59b5724b6c826306e04
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "78159094"
---
# <a name="types-and-variables"></a><span data-ttu-id="b808f-103">Typy i zmienne</span><span class="sxs-lookup"><span data-stu-id="b808f-103">Types and variables</span></span>

<span data-ttu-id="b808f-104">Istnieją dwa rodzaje typów w języku C#: *typy wartości* i *typy odwołań*.</span><span class="sxs-lookup"><span data-stu-id="b808f-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="b808f-105">Zmienne typów wartości bezpośrednio zawierają swoje dane, podczas gdy zmienne typów odwołań przechowują odwołania do ich danych, przy czym te ostatnie są znane jako obiekty.</span><span class="sxs-lookup"><span data-stu-id="b808f-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="b808f-106">W przypadku typów odwołań możliwe jest, aby dwie zmienne odwoływały się do tego samego obiektu, a zatem możliwe, że operacje na jednej zmiennej wpływają na obiekt, do którego odwołuje się inna zmienna.</span><span class="sxs-lookup"><span data-stu-id="b808f-106">With reference types, it's possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="b808f-107">W przypadku typów wartości zmienne mają własną kopię danych i nie jest możliwe, aby operacje `ref` na `out` jednym miały wpływ na inne (z wyjątkiem zmiennych parametrów i zmiennych parametrów).</span><span class="sxs-lookup"><span data-stu-id="b808f-107">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="b808f-108">Typy wartości języka C#są dalej dzielone na *typy proste,* *typy wyliczenia,* *typy struktury*i *wartości nullable*.</span><span class="sxs-lookup"><span data-stu-id="b808f-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="b808f-109">Typy odwołań języka C#są dalej dzielone na *typy klas,* *typy interfejsów,* *typy tablic*i *typy delegatów.*</span><span class="sxs-lookup"><span data-stu-id="b808f-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="b808f-110">Poniższy konspekt zawiera omówienie systemu typów języka C#.</span><span class="sxs-lookup"><span data-stu-id="b808f-110">The following outline provides an overview of C#’s type system.</span></span>

- <span data-ttu-id="b808f-111">[Typy wartości][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="b808f-112">[Typy proste][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-112">[Simple types][SimpleTypes]</span></span>
    - <span data-ttu-id="b808f-113">Podpisana `sbyte`integralna: , `short`, `int``long`</span><span class="sxs-lookup"><span data-stu-id="b808f-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="b808f-114">Niepodpisana `byte`całka: , `ushort`, `uint``ulong`</span><span class="sxs-lookup"><span data-stu-id="b808f-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="b808f-115">Znaki Unicode:`char`</span><span class="sxs-lookup"><span data-stu-id="b808f-115">Unicode characters: `char`</span></span>
    - <span data-ttu-id="b808f-116">Binarny zmiennoprzecinkowy IEEE: `float`,`double`</span><span class="sxs-lookup"><span data-stu-id="b808f-116">IEEE binary floating-point: `float`, `double`</span></span>
    - <span data-ttu-id="b808f-117">Przestawny przecinkowy o wysokiej precyzji:`decimal`</span><span class="sxs-lookup"><span data-stu-id="b808f-117">High-precision decimal floating-point: `decimal`</span></span>
    - <span data-ttu-id="b808f-118">Boolean:`bool`</span><span class="sxs-lookup"><span data-stu-id="b808f-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="b808f-119">[Typy wyliczenia][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-119">[Enum types][EnumTypes]</span></span>
    - <span data-ttu-id="b808f-120">Typy formularzy zdefiniowane przez użytkownika`enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="b808f-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="b808f-121">[Typy struktury][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-121">[Struct types][StructTypes]</span></span>
    - <span data-ttu-id="b808f-122">Typy formularzy zdefiniowane przez użytkownika`struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="b808f-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="b808f-123">[Typy wartości z możliwością null][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-123">[Nullable value types][NullableTypes]</span></span>
    - <span data-ttu-id="b808f-124">Rozszerzenia wszystkich innych typów wartości `null` o wartości</span><span class="sxs-lookup"><span data-stu-id="b808f-124">Extensions of all other value types with a `null` value</span></span>
- <span data-ttu-id="b808f-125">[Typy odwołań][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-125">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="b808f-126">[Typy klas][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-126">[Class types][ClassTypes]</span></span>
    - <span data-ttu-id="b808f-127">Ostateczna klasa podstawowa wszystkich innych typów:`object`</span><span class="sxs-lookup"><span data-stu-id="b808f-127">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="b808f-128">Ciągi Unicode:`string`</span><span class="sxs-lookup"><span data-stu-id="b808f-128">Unicode strings: `string`</span></span>
    - <span data-ttu-id="b808f-129">Typy formularzy zdefiniowane przez użytkownika`class C {...}`</span><span class="sxs-lookup"><span data-stu-id="b808f-129">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="b808f-130">[Typy interfejsów][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-130">[Interface types][InterfaceTypes]</span></span>
    - <span data-ttu-id="b808f-131">Typy formularzy zdefiniowane przez użytkownika`interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="b808f-131">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="b808f-132">[Typy tablic][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-132">[Array types][ArrayTypes]</span></span>
    - <span data-ttu-id="b808f-133">Na przykład jedno- i wielowymiarowe, `int[]` oraz`int[,]`</span><span class="sxs-lookup"><span data-stu-id="b808f-133">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="b808f-134">[Typy pełnomocników][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="b808f-134">[Delegate types][DelegateTypes]</span></span>
    - <span data-ttu-id="b808f-135">Typy formularzy zdefiniowane przez użytkownika`delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="b808f-135">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/builtin-types/value-types.md
[SimpleTypes]: ../language-reference/builtin-types/value-types.md#built-in-value-types
[EnumTypes]: ../language-reference/builtin-types/enum.md
[StructTypes]: ../language-reference/builtin-types/struct.md
[NullableTypes]: ../language-reference/builtin-types/nullable-value-types.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="b808f-136">Aby uzyskać więcej informacji na temat typów liczbowych, zobacz [Typy zintegrowane](../language-reference/builtin-types/integral-numeric-types.md) i Tabela [typów zmiennoprzecinkowych](../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="b808f-136">For more information about numeric types, see [Integral types](../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point types table](../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="b808f-137">Typ języka `bool` C#jest używany do reprezentowania wartości `true` logicznych — wartości, które są albo . `false`</span><span class="sxs-lookup"><span data-stu-id="b808f-137">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="b808f-138">Przetwarzanie znaków i ciągów w języku C# używa kodowania Unicode.</span><span class="sxs-lookup"><span data-stu-id="b808f-138">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="b808f-139">Typ `char` reprezentuje jednostkę kodu UTF-16, `string` a typ reprezentuje sekwencję jednostek kodu UTF-16.</span><span class="sxs-lookup"><span data-stu-id="b808f-139">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="b808f-140">Programy C# używać *deklaracji typu* do tworzenia nowych typów.</span><span class="sxs-lookup"><span data-stu-id="b808f-140">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="b808f-141">Deklaracja typu określa nazwę i elementy członkowskie nowego typu.</span><span class="sxs-lookup"><span data-stu-id="b808f-141">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="b808f-142">Pięć kategorii typów języka C#jest definiowanych przez użytkownika: typy klas, typy struktur, typy interfejsów, typy wyliczenia i typy delegatów.</span><span class="sxs-lookup"><span data-stu-id="b808f-142">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="b808f-143">Typ `class` definiuje strukturę danych, która zawiera elementy członkowskie danych (pola) i elementy członkowskie funkcji (metody, właściwości i inne).</span><span class="sxs-lookup"><span data-stu-id="b808f-143">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="b808f-144">Typy klas obsługują pojedyncze dziedziczenie i polimorfizm, mechanizmy, dzięki którym klasy pochodne mogą rozszerzać i specjalizować klasy podstawowe.</span><span class="sxs-lookup"><span data-stu-id="b808f-144">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="b808f-145">Typ `struct` jest podobny do typu klasy, ponieważ reprezentuje strukturę z członkami danych i członkami funkcji.</span><span class="sxs-lookup"><span data-stu-id="b808f-145">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="b808f-146">Jednak w przeciwieństwie do klas struktury są typy wartości i zazwyczaj nie wymagają alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="b808f-146">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="b808f-147">Typy struktury nie obsługują dziedziczenia określonego przez użytkownika, a wszystkie `object`typy struktury niejawnie dziedziczą z typu .</span><span class="sxs-lookup"><span data-stu-id="b808f-147">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="b808f-148">Typ `interface` definiuje kontrakt jako nazwany zestaw elementów członkowskich funkcji publicznych.</span><span class="sxs-lookup"><span data-stu-id="b808f-148">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="b808f-149">A `class` `struct` lub implementuje `interface` implementuje implementuje implementacje elementów członkowskich funkcji interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b808f-149">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="b808f-150">Może `interface` dziedziczyć z wielu `class` interfejsów podstawowych i lub `struct` może implementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="b808f-150">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="b808f-151">Typ `delegate` reprezentuje odwołania do metod z określoną listą parametrów i typem zwracanym.</span><span class="sxs-lookup"><span data-stu-id="b808f-151">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="b808f-152">Delegaci umożliwiają traktowanie metod jako jednostek, które mogą być przypisane do zmiennych i przekazywane jako parametry.</span><span class="sxs-lookup"><span data-stu-id="b808f-152">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="b808f-153">Delegaci są analogiczne do typów funkcji dostarczanych przez języki funkcjonalne.</span><span class="sxs-lookup"><span data-stu-id="b808f-153">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="b808f-154">Są one również podobne do pojęcia wskaźników funkcji znaleźć w niektórych innych językach.</span><span class="sxs-lookup"><span data-stu-id="b808f-154">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="b808f-155">W przeciwieństwie do wskaźników funkcji delegatów są zorientowane obiektowe i bezpieczne dla typu.</span><span class="sxs-lookup"><span data-stu-id="b808f-155">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="b808f-156">Program `class` `struct`, `interface`, `delegate` i typy wszystkich typów ogólnych obsługi, przy czym mogą być parametryzowane z innymi typami.</span><span class="sxs-lookup"><span data-stu-id="b808f-156">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="b808f-157">Typ `enum` jest odrębnym typem o nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="b808f-157">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="b808f-158">Każdy `enum` typ ma typ bazowy, który musi być jednym z ośmiu typów całek.</span><span class="sxs-lookup"><span data-stu-id="b808f-158">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="b808f-159">Zestaw wartości `enum` typu jest taki sam jak zestaw wartości typu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="b808f-159">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="b808f-160">C# obsługuje tablice jedno- i wielowymiarowe dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="b808f-160">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="b808f-161">W przeciwieństwie do typów wymienionych powyżej typy tablicnie nie muszą być zadeklarowane, zanim będą mogły być używane.</span><span class="sxs-lookup"><span data-stu-id="b808f-161">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="b808f-162">Zamiast tego typy tablic są konstruowane przez następujące nazwy typu z nawiasami kwadratowymi.</span><span class="sxs-lookup"><span data-stu-id="b808f-162">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="b808f-163">`int[]` Na przykład, jest jednowymiarową `int` `int[,]` tablicą , jest `int`tablicą `int[][]` dwuwymiarową , i jest jednowymiarową tablicą jednowymiarowej tablicy `int`.</span><span class="sxs-lookup"><span data-stu-id="b808f-163">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="b808f-164">Typy wartości null również nie muszą być zadeklarowane, zanim będą mogły być używane.</span><span class="sxs-lookup"><span data-stu-id="b808f-164">Nullable value types also don't have to be declared before they can be used.</span></span> <span data-ttu-id="b808f-165">Dla każdego typu `T`wartości niepodlegających wartości null istnieje `T?`odpowiedni typ wartości nullable , który może posiadać dodatkową wartość, `null`.</span><span class="sxs-lookup"><span data-stu-id="b808f-165">For each non-nullable value type `T`, there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="b808f-166">Na przykład `int?` jest typem, który może pomieścić dowolną 32-bitową wartość całkowitą lub wartość `null`.</span><span class="sxs-lookup"><span data-stu-id="b808f-166">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="b808f-167">System typu C#jest ujednolicony w taki sposób, `object`że wartość dowolnego typu może być traktowana jako .</span><span class="sxs-lookup"><span data-stu-id="b808f-167">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="b808f-168">Każdy typ w języku C# bezpośrednio `object` lub pośrednio pochodzi od typu klasy i `object` jest ostateczną klasą podstawową wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="b808f-168">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="b808f-169">Wartości typów odwołań są traktowane jako obiekty `object`po prostu przez wyświetlenie wartości jako typu .</span><span class="sxs-lookup"><span data-stu-id="b808f-169">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="b808f-170">Wartości typów wartości są traktowane jako obiekty, wykonując operacje *bokserskie* i *rozpakowywania*.</span><span class="sxs-lookup"><span data-stu-id="b808f-170">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="b808f-171">W poniższym `int` przykładzie wartość jest `object` konwertowana na `int`i z powrotem do .</span><span class="sxs-lookup"><span data-stu-id="b808f-171">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="b808f-172">Gdy wartość typu wartości jest konwertowana `object`na `object` typ , wystąpienie, nazywane również "pole", jest przydzielane do przechowywania wartości, a wartość jest kopiowana do tego pola.</span><span class="sxs-lookup"><span data-stu-id="b808f-172">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="b808f-173">I odwrotnie, `object` gdy odwołanie jest rzutowane na typ wartości, `object` sprawdzasię, że odwołanie jest polem właściwego typu wartości, a jeśli sprawdzenie zakończy się pomyślnie, wartość w polu jest kopiowana.</span><span class="sxs-lookup"><span data-stu-id="b808f-173">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="b808f-174">Ujednolicony system typów języka C#skutecznie oznacza, że typy wartości mogą stać się obiektami "na żądanie".</span><span class="sxs-lookup"><span data-stu-id="b808f-174">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="b808f-175">Ze względu na unifikacji, biblioteki ogólnego przeznaczenia, które używają typu `object` mogą być używane zarówno z typami odwołań, jak i typami wartości.</span><span class="sxs-lookup"><span data-stu-id="b808f-175">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="b808f-176">Istnieje kilka rodzajów *zmiennych* w języku C#, w tym pola, elementy tablicy, zmienne lokalne i parametry.</span><span class="sxs-lookup"><span data-stu-id="b808f-176">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="b808f-177">Zmienne reprezentują lokalizacje magazynu, a każda zmienna ma typ, który określa, jakie wartości mogą być przechowywane w zmiennej, jak pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="b808f-177">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="b808f-178">Typ wartości niezbywalnej</span><span class="sxs-lookup"><span data-stu-id="b808f-178">Non-nullable value type</span></span>
  - <span data-ttu-id="b808f-179">Wartość tego typu dokładnego</span><span class="sxs-lookup"><span data-stu-id="b808f-179">A value of that exact type</span></span>
- <span data-ttu-id="b808f-180">Typ wartości z możliwością null</span><span class="sxs-lookup"><span data-stu-id="b808f-180">Nullable value type</span></span>
  - <span data-ttu-id="b808f-181">Wartość `null` lub wartość tego typu dokładnego</span><span class="sxs-lookup"><span data-stu-id="b808f-181">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="b808f-182">obiekt</span><span class="sxs-lookup"><span data-stu-id="b808f-182">object</span></span>
  - <span data-ttu-id="b808f-183">Odwołanie, `null` odwołanie do obiektu dowolnego typu odwołania lub odwołanie do wartości pudełkowej dowolnego typu wartości</span><span class="sxs-lookup"><span data-stu-id="b808f-183">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="b808f-184">Typ klasy</span><span class="sxs-lookup"><span data-stu-id="b808f-184">Class type</span></span>
  - <span data-ttu-id="b808f-185">Odwołanie, `null` odwołanie do wystąpienia tego typu klasy lub odwołanie do wystąpienia klasy pochodzącej z tego typu klasy</span><span class="sxs-lookup"><span data-stu-id="b808f-185">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="b808f-186">Typ interfejsu</span><span class="sxs-lookup"><span data-stu-id="b808f-186">Interface type</span></span>
  - <span data-ttu-id="b808f-187">Odwołanie, `null` odwołanie do wystąpienia typu klasy, który implementuje tego typu interfejsu lub odwołanie do wartości pudełkowej typu wartości, która implementuje tego typu interfejsu</span><span class="sxs-lookup"><span data-stu-id="b808f-187">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="b808f-188">Typ tablicy</span><span class="sxs-lookup"><span data-stu-id="b808f-188">Array type</span></span>
  - <span data-ttu-id="b808f-189">Odwołanie, `null` odwołanie do wystąpienia tego typu tablicy lub odwołanie do wystąpienia zgodnego typu tablicy</span><span class="sxs-lookup"><span data-stu-id="b808f-189">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="b808f-190">Typ pełnomocnika</span><span class="sxs-lookup"><span data-stu-id="b808f-190">Delegate type</span></span>
  - <span data-ttu-id="b808f-191">Odwołanie `null` lub odwołanie do wystąpienia zgodnego typu delegata</span><span class="sxs-lookup"><span data-stu-id="b808f-191">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="b808f-192">[Poprzedni](program-structure.md)
> [następny](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="b808f-192">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
