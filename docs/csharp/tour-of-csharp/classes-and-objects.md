---
title: "Klas i obiektów w języku C# — samouczek języka C#"
description: "Jesteś nowym użytkownikiem C#? Przeczytaj ten przegląd klas, obiektów i dziedziczenie"
keywords: ".NET, csharp, klasy, wystąpienie, obiekt, dziedziczenia, polimorfizm"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: 97559a6e7b24f4a61b49dd4f050747a6d0ccbda0
ms.sourcegitcommit: d95a91d685565f4d95c8773b558752864a6a3d7e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2018
---
# <a name="classes-and-objects"></a><span data-ttu-id="2ecad-105">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="2ecad-105">Classes and objects</span></span>

<span data-ttu-id="2ecad-106">*Klasy* są najbardziej podstawowe C# dla typów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="2ecad-107">Klasa jest strukturą danych, łączącą stanu (pól) i akcje (metod i innych funkcji elementów członkowskich) w pojedynczą jednostkę.</span><span class="sxs-lookup"><span data-stu-id="2ecad-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="2ecad-108">Klasa zawiera definicję dla tworzone dynamicznie *wystąpień* klasy, nazywany również *obiektów*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-108">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="2ecad-109">Klasy obsługi *dziedziczenia* i *polimorfizm*, mechanizmów zgodnie z którymi *klas pochodnych* można rozszerzyć i dostosować ją *podstawowa klasy*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="2ecad-110">Nowe klasy są tworzone za pomocą deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-110">New classes are created using class declarations.</span></span> <span data-ttu-id="2ecad-111">Deklaracja klasy rozpoczyna się od nagłówek, który określa atrybuty i Modyfikatory klasy, nazwy klasy, klasy podstawowej (jeśli istnieje) i interfejsów implementowanych przez klasę.</span><span class="sxs-lookup"><span data-stu-id="2ecad-111">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="2ecad-112">Nagłówek następuje treści klasy, która składa się z listą deklaracji elementu członkowskiego, zapisane między ograniczniki `{` i `}`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-112">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="2ecad-113">Poniżej przedstawiono deklaracji prostą klasę o nazwie `Point`:</span><span class="sxs-lookup"><span data-stu-id="2ecad-113">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="2ecad-114">Wystąpienia klas są tworzone przy użyciu `new` operatora, który przydziela pamięć dla nowego wystąpienia, wywołuje konstruktor do inicjowania wystąpienia i zwraca odwołanie do wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="2ecad-114">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="2ecad-115">Poniższe instrukcje utworzenie dwóch obiektów punktu i przechowuje odwołania do tych obiektów w dwóch zmiennych:</span><span class="sxs-lookup"><span data-stu-id="2ecad-115">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="2ecad-116">Pamięć zajmowane przez obiekt jest automatycznie odzyskana, gdy obiekt nie jest już dostępny.</span><span class="sxs-lookup"><span data-stu-id="2ecad-116">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="2ecad-117">Go nie ma potrzeby ani można jawnie deallocate obiektów w języku C#.</span><span class="sxs-lookup"><span data-stu-id="2ecad-117">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="2ecad-118">Elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="2ecad-118">Members</span></span>

<span data-ttu-id="2ecad-119">Elementy członkowskie klasy są statyczne elementy Członkowskie lub elementy członkowskie wystąpień.</span><span class="sxs-lookup"><span data-stu-id="2ecad-119">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="2ecad-120">Statyczne elementy członkowskie należą do klasy, i elementów członkowskich wystąpienia muszą należeć do obiektów (wystąpienia klasy).</span><span class="sxs-lookup"><span data-stu-id="2ecad-120">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="2ecad-121">Poniżej omówiono określonych rodzajów członków klasy może zawierać.</span><span class="sxs-lookup"><span data-stu-id="2ecad-121">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="2ecad-122">Stałe</span><span class="sxs-lookup"><span data-stu-id="2ecad-122">Constants</span></span>
    - <span data-ttu-id="2ecad-123">Wartości stałe skojarzonego z klasą</span><span class="sxs-lookup"><span data-stu-id="2ecad-123">Constant values associated with the class</span></span>
* <span data-ttu-id="2ecad-124">Pola</span><span class="sxs-lookup"><span data-stu-id="2ecad-124">Fields</span></span>
    - <span data-ttu-id="2ecad-125">Zmienne klasy</span><span class="sxs-lookup"><span data-stu-id="2ecad-125">Variables of the class</span></span>
* <span data-ttu-id="2ecad-126">Metody</span><span class="sxs-lookup"><span data-stu-id="2ecad-126">Methods</span></span>
    - <span data-ttu-id="2ecad-127">Obliczenia i akcje, które mogą być wykonywane przez klasę</span><span class="sxs-lookup"><span data-stu-id="2ecad-127">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="2ecad-128">Właściwości</span><span class="sxs-lookup"><span data-stu-id="2ecad-128">Properties</span></span>
    - <span data-ttu-id="2ecad-129">Akcje skojarzone z odczytywanie i zapisywanie właściwości o nazwie klasy</span><span class="sxs-lookup"><span data-stu-id="2ecad-129">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="2ecad-130">Indeksatory</span><span class="sxs-lookup"><span data-stu-id="2ecad-130">Indexers</span></span>
    - <span data-ttu-id="2ecad-131">Akcje skojarzone z indeksowania wystąpień klasy, jak tablicy</span><span class="sxs-lookup"><span data-stu-id="2ecad-131">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="2ecad-132">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="2ecad-132">Events</span></span>
    - <span data-ttu-id="2ecad-133">Powiadomienia, które mogą być generowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="2ecad-133">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="2ecad-134">Operatory</span><span class="sxs-lookup"><span data-stu-id="2ecad-134">Operators</span></span>
    - <span data-ttu-id="2ecad-135">Konwersje i wyrażenie operatory obsługiwane przez klasę</span><span class="sxs-lookup"><span data-stu-id="2ecad-135">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="2ecad-136">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="2ecad-136">Constructors</span></span>
    - <span data-ttu-id="2ecad-137">Akcje wymagane do zainicjowania wystąpienia klasy lub samej klasy</span><span class="sxs-lookup"><span data-stu-id="2ecad-137">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="2ecad-138">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="2ecad-138">Finalizers</span></span>
    - <span data-ttu-id="2ecad-139">Akcje do wykonania przed wystąpień klasy trwale zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="2ecad-139">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="2ecad-140">Types</span><span class="sxs-lookup"><span data-stu-id="2ecad-140">Types</span></span>
    - <span data-ttu-id="2ecad-141">Zagnieżdżone typy zadeklarowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="2ecad-141">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="2ecad-142">Ułatwienia dostępu</span><span class="sxs-lookup"><span data-stu-id="2ecad-142">Accessibility</span></span>

<span data-ttu-id="2ecad-143">Każdy element członkowski klasy ma skojarzone ułatwień dostępu, który kontroluje regionów tekst programu, które są w stanie uzyskać dostępu do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-143">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="2ecad-144">Istnieje pięć możliwych form ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-144">There are five possible forms of accessibility.</span></span> <span data-ttu-id="2ecad-145">Te są podsumowywane poniżej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-145">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="2ecad-146">Nie ograniczając dostęp</span><span class="sxs-lookup"><span data-stu-id="2ecad-146">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="2ecad-147">Dostęp ograniczony do tej klasy lub klas pochodzących z tej klasy</span><span class="sxs-lookup"><span data-stu-id="2ecad-147">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="2ecad-148">Dostęp ograniczony do bieżącego zestawu (.exe, .dll itp.)</span><span class="sxs-lookup"><span data-stu-id="2ecad-148">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="2ecad-149">Dostęp ograniczony do zawierający klasy lub klas pochodnych klasa zawierająca</span><span class="sxs-lookup"><span data-stu-id="2ecad-149">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="2ecad-150">Dostęp ograniczony do tej klasy</span><span class="sxs-lookup"><span data-stu-id="2ecad-150">Access limited to this class</span></span>
* `private protected`
    - <span data-ttu-id="2ecad-151">Dostęp ograniczony do zawierający klasy lub klas pochodnych typu zawierającego w ramach tego samego zestawu</span><span class="sxs-lookup"><span data-stu-id="2ecad-151">Access limited to the containing class or classes derived from the containing type within the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="2ecad-152">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="2ecad-152">Type parameters</span></span>

<span data-ttu-id="2ecad-153">Definicję klasy mogą określać zestaw parametrów typu przez po nazwie klasy z nawiasy otaczającej listę nazw parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-153">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="2ecad-154">Następnie można użyć parametrów typu w treści deklaracji klasy można zdefiniować elementów członkowskich klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-154">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="2ecad-155">W poniższym przykładzie parametrów typu `Pair` są `TFirst` i `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="2ecad-155">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="2ecad-156">Nosi nazwę typu klasy, który jest zadeklarowana, aby wykonać parametrów typu *typu klasy ogólnej*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-156">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="2ecad-157">Można też ogólnego typu struktury, interfejsu i delegata.</span><span class="sxs-lookup"><span data-stu-id="2ecad-157">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="2ecad-158">W przypadku klasy ogólnej należy podać argumentów typu dla każdego z parametrów typu:</span><span class="sxs-lookup"><span data-stu-id="2ecad-158">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="2ecad-159">Typem ogólnym z argumentami typu pod warunkiem, takie jak `Pair<int,string>` powyżej, jest nazywany *skonstruować typu*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-159">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="2ecad-160">Klas podstawowych</span><span class="sxs-lookup"><span data-stu-id="2ecad-160">Base classes</span></span>

<span data-ttu-id="2ecad-161">Deklaracja klasy mogą określać klasy podstawowej przez następujące parametry nazwę i typ klasy z dwukropkiem i nazwy klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-161">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="2ecad-162">Pominięcie specyfikacji klasa podstawowa jest taka sama jak pochodny typ `object`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-162">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="2ecad-163">W poniższym przykładzie klasa podstawowa `Point3D` jest `Point`, a klasa podstawowa `Point` jest `object`:</span><span class="sxs-lookup"><span data-stu-id="2ecad-163">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="2ecad-164">Klasa dziedziczy elementów członkowskich klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-164">A class inherits the members of its base class.</span></span> <span data-ttu-id="2ecad-165">Dziedziczenie oznacza, że klasa niejawnie zawiera wszystkie elementy członkowskie w swojej klasie podstawowej, z wyjątkiem wystąpienie i konstruktorów statycznych i finalizatory klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-165">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="2ecad-166">Klasy pochodne mogą dodawać nowych członków do tych, które dziedziczy, ale nie można usunąć definicji dziedziczonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-166">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="2ecad-167">W poprzednim przykładzie `Point3D` dziedziczy `x` i `y` pola z `Point`, a następnie co `Point3D` wystąpienie zawiera trzy pola `x`, `y`, i `z`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-167">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="2ecad-168">Niejawna konwersja istnieje z typem klasy do dowolnego z jego typów klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-168">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="2ecad-169">W związku z tym zmiennej typu klasy można odwoływać się wystąpienia tej klasy lub wystąpienia klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-169">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="2ecad-170">Na przykład, dla danego poprzedniej deklaracji klasy, zmiennej typu `Point` może odwoływać się albo `Point` lub `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="2ecad-170">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="2ecad-171">Pola</span><span class="sxs-lookup"><span data-stu-id="2ecad-171">Fields</span></span>

<span data-ttu-id="2ecad-172">A *pola* jest zmienna, która jest skojarzona z klasy lub wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-172">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="2ecad-173">Zadeklarowana z modyfikatorem statycznego pola definiuje pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-173">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="2ecad-174">Statyczne pole identyfikuje dokładnie jedną lokalizację magazynu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-174">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="2ecad-175">Niezależnie od tego, jak wiele wystąpień klasy są tworzone jest tylko kiedykolwiek jedną kopię pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-175">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="2ecad-176">Pole zadeklarowana bez modyfikator statyczny definiuje pole wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="2ecad-176">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="2ecad-177">Każde wystąpienie klasy zawiera osobną kopię wszystkie pola wystąpienia tej klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-177">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="2ecad-178">W poniższym przykładzie, każde wystąpienie `Color` klasa ma osobną kopię `r`, `g`, i `b` wystąpienia pól, ale istnieje tylko jedna kopia `Black`, `White`, `Red`, `Green`, i `Blue` pola statyczne:</span><span class="sxs-lookup"><span data-stu-id="2ecad-178">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="2ecad-179">Jak pokazano w poprzednim przykładzie *pola tylko do odczytu* mogą być deklarowane z `readonly` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="2ecad-179">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="2ecad-180">Przypisanie do `readonly` pola mogą występować tylko jako część deklaracja pola lub w Konstruktorze w tej samej klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-180">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="2ecad-181">Metody</span><span class="sxs-lookup"><span data-stu-id="2ecad-181">Methods</span></span>

<span data-ttu-id="2ecad-182">A *metoda* jest elementem członkowskim, który implementuje obliczenia lub akcji, które mogą być wykonywane przez obiekt lub klasa.</span><span class="sxs-lookup"><span data-stu-id="2ecad-182">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="2ecad-183">*Metody statyczne* są dostępne za pośrednictwem klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-183">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="2ecad-184">*Wystąpienie metody* są dostępne za pośrednictwem wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-184">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="2ecad-185">Metody może mieć listy *parametry*, które reprezentują wartości lub odwołań do zmiennych przekazywany do metody i *zwracany typ*, który określa typ wartości obliczana i zwracany przez metodę.</span><span class="sxs-lookup"><span data-stu-id="2ecad-185">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="2ecad-186">Zwracany typ metody jest `void` Jeśli nie zwraca wartości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-186">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="2ecad-187">Jak typy metody może mieć zestaw parametrów typu, dla których należy określić argumenty typu podczas wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="2ecad-187">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="2ecad-188">W przeciwieństwie do typów argumentów typu często można wywnioskować na podstawie argumenty wywołania metody i nie można jawnie konieczne.</span><span class="sxs-lookup"><span data-stu-id="2ecad-188">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="2ecad-189">*Podpisu* metody muszą być unikatowe w klasie, w którym zadeklarowany jest metoda.</span><span class="sxs-lookup"><span data-stu-id="2ecad-189">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="2ecad-190">Podpis metody składa się z nazwy metody, liczba parametrów typu i liczbę, Modyfikatory i typy parametrów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-190">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="2ecad-191">Podpis metody nie ma zwracanego typu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-191">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="2ecad-192">Parametry</span><span class="sxs-lookup"><span data-stu-id="2ecad-192">Parameters</span></span>

<span data-ttu-id="2ecad-193">Parametry są używane do przekazania wartości lub zmiennej odwołania do metody.</span><span class="sxs-lookup"><span data-stu-id="2ecad-193">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="2ecad-194">Parametry metody get swoje rzeczywiste wartości z *argumenty* podano po wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="2ecad-194">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="2ecad-195">Istnieją cztery rodzaje parametry: wartości parametrów, parametry odwołanie parametrów wyjściowych i tablice parametrów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-195">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="2ecad-196">A *wartość parametru* służy do przekazywania argumentów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="2ecad-196">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="2ecad-197">Wartość parametru odnosi się do zmiennej lokalnej, która pobiera swojej wartości początkowej w argumencie, która została przekazana dla parametru.</span><span class="sxs-lookup"><span data-stu-id="2ecad-197">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="2ecad-198">Modyfikacje parametru wartości nie wpływają na argumentu, która została przekazana dla parametru.</span><span class="sxs-lookup"><span data-stu-id="2ecad-198">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="2ecad-199">Wartości parametrów mogą być opcjonalne, przez określenie wartości domyślnej, dzięki czemu można pominąć odpowiednie argumenty.</span><span class="sxs-lookup"><span data-stu-id="2ecad-199">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="2ecad-200">A *odwołać się do parametru* służy do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="2ecad-200">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="2ecad-201">Argumentu przekazanego do parametru odwołania musi być zmienną z określoną wartością, a podczas wykonywania metody, parametr odwołania reprezentuje tej samej lokalizacji magazynu jako argumentu zmiennej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-201">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="2ecad-202">Parametr odwołanie jest zadeklarowane ze `ref` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="2ecad-202">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="2ecad-203">W poniższym przykładzie przedstawiono użycie `ref` parametrów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-203">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="2ecad-204">*Parametru wyjściowego* służy do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="2ecad-204">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="2ecad-205">Jest on podobny do parametru odwołanie, z tą różnicą, że nie wymaga jawnie przypisać wartości do argumentu dostarczane przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="2ecad-205">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="2ecad-206">Parametr wyjściowy jest zadeklarowany za pomocą `out` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="2ecad-206">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="2ecad-207">W poniższym przykładzie przedstawiono użycie `out` parametry, używając składni wprowadzono w języku C# 7.</span><span class="sxs-lookup"><span data-stu-id="2ecad-207">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="2ecad-208">A *tablicy parametrów* pozwala na zmienną liczbę argumentów, które mają być przekazane do metody.</span><span class="sxs-lookup"><span data-stu-id="2ecad-208">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="2ecad-209">Tablica parametrów jest zadeklarowany za pomocą `params` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="2ecad-209">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="2ecad-210">Ostatni parametr metody może być tablicą parametrów, a typ tablicy parametrów musi być typem tablicy jednowymiarowej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-210">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="2ecad-211">Metody zapisu i WriteLine <xref:System.Console?displayProperty=nameWithType> klasy są dobrym przykładem użycia tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-211">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="2ecad-212">Są one zgłoszone w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="2ecad-212">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="2ecad-213">W ramach metody, która używa tablicy parametrów tablicy parametrów zachowuje się tak samo jak regularne parametru typu tablicowego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-213">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="2ecad-214">Jednak w wywołaniu metody z tablicą parametrów, istnieje możliwość przekazania jeden argument typu Tablica parametru albo dowolną liczbę argumentów typu elementu tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-214">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="2ecad-215">W drugim przypadku wystąpienia tablicy jest automatycznie tworzone i zainicjować przy użyciu danego argumentów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-215">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="2ecad-216">W tym przykładzie</span><span class="sxs-lookup"><span data-stu-id="2ecad-216">This example</span></span>

[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="2ecad-217">odpowiada to pisanie poniżej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-217">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="2ecad-218">Treść metody i zmienne lokalne</span><span class="sxs-lookup"><span data-stu-id="2ecad-218">Method body and local variables</span></span>

<span data-ttu-id="2ecad-219">Treść metody Określa instrukcje do wykonania, gdy jest wywoływana metoda.</span><span class="sxs-lookup"><span data-stu-id="2ecad-219">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="2ecad-220">Treść metody mogą zadeklarować zmienne, które są specyficzne dla wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="2ecad-220">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="2ecad-221">Takie zmienne są nazywane *zmiennych lokalnych*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-221">Such variables are called *local variables*.</span></span> <span data-ttu-id="2ecad-222">Deklaracji zmiennej lokalnej Określa nazwę typu, nazwę zmiennej, prawdopodobnie wartość początkową.</span><span class="sxs-lookup"><span data-stu-id="2ecad-222">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="2ecad-223">Poniższy przykład deklaruje zmienną lokalną `i` o początkowej wartości zero i zmiennej lokalnej `j` bez wartości początkowej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-223">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="2ecad-224">C# wymaga zmiennej lokalnej jako *ostatecznie przypisane* przed jego wartość.</span><span class="sxs-lookup"><span data-stu-id="2ecad-224">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="2ecad-225">Na przykład jeśli deklaracja poprzedniego `i` nie zawiera wartości początkowej, kompilator rozpoczną przesyłanie raportów wystąpił błąd dla kolejnych użycia `i` ponieważ `i` nie będzie można zdecydowanie przypisane w tych punktach w programie.</span><span class="sxs-lookup"><span data-stu-id="2ecad-225">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="2ecad-226">Można użyć metody `return` instrukcje, aby zwrócić kontrolkę do swojego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-226">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="2ecad-227">W metodach zwracających `void`, `return` instrukcji nie można określić wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="2ecad-227">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="2ecad-228">W metodach zwracających inny niż void `return` instrukcje musi zawierać wyrażenie, które oblicza wartość zwracaną.</span><span class="sxs-lookup"><span data-stu-id="2ecad-228">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="2ecad-229">Metody statyczne i wystąpienia</span><span class="sxs-lookup"><span data-stu-id="2ecad-229">Static and instance methods</span></span>

<span data-ttu-id="2ecad-230">Metoda zadeklarowana z modyfikatorem statycznego jest *metody statycznej*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-230">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="2ecad-231">Metody statycznej nie będzie działać na określonym wystąpieniu i tylko bezpośrednio dostęp do statycznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="2ecad-231">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="2ecad-232">Metody zadeklarowane bez jest modyfikator statyczny *metody wystąpienia*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-232">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="2ecad-233">Metody wystąpienia działa na określonym wystąpieniu i można dostępu obu statyczna i wystąpienia elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="2ecad-233">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="2ecad-234">Wystąpienie, w którym wywołano metodę wystąpienia są jawnie dostępne `this`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-234">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="2ecad-235">Błąd w odwołaniu do `this` w metodzie statycznej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-235">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="2ecad-236">Następujące `Entity` klasa ma obu statyczna i wystąpienia elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="2ecad-236">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="2ecad-237">Każdy `Entity` wystąpienie zawiera numery seryjne (i prawdopodobnie niektóre inne informacje, które nie są wyświetlane tutaj).</span><span class="sxs-lookup"><span data-stu-id="2ecad-237">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="2ecad-238">`Entity` — Konstruktor (czyli takie jak metody wystąpienia) inicjuje nowe wystąpienie z najbliższy dostępny numer seryjny.</span><span class="sxs-lookup"><span data-stu-id="2ecad-238">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="2ecad-239">Ponieważ Konstruktor elementu członkowskiego wystąpienia, jest dozwolony dostęp zarówno do `serialNo` pole wystąpienia i `nextSerialNo` pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-239">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="2ecad-240">`GetNextSerialNo` i `SetNextSerialNo` metody statyczne mogą uzyskiwać dostęp do `nextSerialNo` pole statyczne, ale będzie błąd dla nich bezpośrednio `serialNo` pole wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="2ecad-240">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="2ecad-241">Poniższy przykład przedstawia użycie klasy jednostka.</span><span class="sxs-lookup"><span data-stu-id="2ecad-241">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="2ecad-242">Należy pamiętać, że `SetNextSerialNo` i `GetNextSerialNo` metody statyczne są wywoływane w klasie, podczas gdy `GetSerialNo` wywołaniu metody wystąpienia na wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-242">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="2ecad-243">Wirtualne, zastępowanie i metody abstrakcyjne</span><span class="sxs-lookup"><span data-stu-id="2ecad-243">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="2ecad-244">Po deklaracji metody wystąpienia obejmuje `virtual` , modyfikator metody jest określany jako *metody wirtualnej*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-244">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="2ecad-245">Nie modyfikatora wirtualnego jest obecny, metoda jest określane jako *Niewirtualna metoda*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-245">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="2ecad-246">Po wywołaniu metody wirtualnej *typu run-time* wystąpienia, dla którego tego wywołania ma miejsce określa rzeczywista implementacja metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="2ecad-246">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="2ecad-247">W wywołaniu metody niewirtualne *typu kompilacji* wystąpienia jest czynnikiem decydującym.</span><span class="sxs-lookup"><span data-stu-id="2ecad-247">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="2ecad-248">Może być metodą wirtualną *przesłonięcia* w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-248">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="2ecad-249">Po deklaracji metody wystąpienia zawiera modyfikator zastąpienie, metoda zastępuje dziedziczonej metody wirtualnej o tej samej sygnaturze.</span><span class="sxs-lookup"><span data-stu-id="2ecad-249">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="2ecad-250">Deklaracja metody wirtualnej wprowadza nową metodę, deklaracji metody zastąpienie specjalizuje się istniejących dziedziczonej metody wirtualnej dostarczając nową implementacją tej metody.</span><span class="sxs-lookup"><span data-stu-id="2ecad-250">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="2ecad-251">*Metody abstrakcyjnej* jest metodą wirtualną z żadnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="2ecad-251">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="2ecad-252">Metoda abstrakcyjna jest zadeklarowany jako abstrakcyjny modyfikatorem i jest dozwolone tylko w klasie, który również został zadeklarowany jako abstrakcyjny.</span><span class="sxs-lookup"><span data-stu-id="2ecad-252">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="2ecad-253">Metoda abstrakcyjna musi zostać zastąpiona w każdej pochodnej klasy nieabstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-253">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="2ecad-254">Poniższy przykład deklaruje klasę abstrakcyjną `Expression`, który reprezentuje węzeł drzewa wyrażenia i trzy pochodzi z klasy, `Constant`, `VariableReference`, i `Operation`, który implementuje węzły drzewa wyrażenia stałych i zmiennych odwołania, a operacje arytmetyczne.</span><span class="sxs-lookup"><span data-stu-id="2ecad-254">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="2ecad-255">(To jest podobny, ale nie należy mylić z typami wyrażenia drzewa).</span><span class="sxs-lookup"><span data-stu-id="2ecad-255">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="2ecad-256">Poprzednie cztery klasy może służyć do modelu w wyrażeniach arytmetycznych.</span><span class="sxs-lookup"><span data-stu-id="2ecad-256">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="2ecad-257">Na przykład za pomocą wystąpień tych klas, wyrażenie `x + 3` można przedstawić w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="2ecad-257">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="2ecad-258">`Evaluate` Metody `Expression` wystąpienia jest wywoływane w celu oceny danego wyrażenia i tworzy `double` wartość.</span><span class="sxs-lookup"><span data-stu-id="2ecad-258">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="2ecad-259">Metoda korzysta z `Dictionary` argumentu, który zawiera wartości (jako wartości wpisy) i nazwy zmiennych (jako klucze wpisy).</span><span class="sxs-lookup"><span data-stu-id="2ecad-259">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="2ecad-260">Ponieważ `Evaluate` jest metoda abstrakcyjna, pochodzi z klasy nieabstrakcyjnej `Expression` przesłonięcie `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-260">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="2ecad-261">A `Constant`w implementacji `Evaluate` po prostu zwraca przechowywanych stała.</span><span class="sxs-lookup"><span data-stu-id="2ecad-261">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="2ecad-262">A `VariableReference`na implementacji wyszukuje nazwę zmiennej w słowniku i zwraca wartość wynikową.</span><span class="sxs-lookup"><span data-stu-id="2ecad-262">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="2ecad-263">`Operation`w implementacji najpierw ocenia lewy i prawy argumentów operacji (wywołując rekursywnie ich `Evaluate` metody), a następnie wykonuje danej operacji arytmetycznej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-263">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="2ecad-264">Następujące program używa `Expression` klasy można oszacować wyrażenia `x * (y + 2)` dla różnych wartości `x` i `y`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-264">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="2ecad-265">Przeciążenie metody</span><span class="sxs-lookup"><span data-stu-id="2ecad-265">Method overloading</span></span>

<span data-ttu-id="2ecad-266">Metoda *przeładowanie* zezwala na wiele metod w tej samej klasy mają taką samą nazwę jak długo mają unikatowe sygnatury.</span><span class="sxs-lookup"><span data-stu-id="2ecad-266">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="2ecad-267">W przypadku kompilowania kodu wywołanie przeciążonej metody, kompilator używa *przeciążenia* ustalenie określonej metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="2ecad-267">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="2ecad-268">Rozpoznanie przeciążenia znajduje jedną metodę czy najlepiej do argumentów nie pasuje lub zgłasza błąd, jeśli można znaleźć nie pojedynczego najlepsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="2ecad-268">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="2ecad-269">W poniższym przykładzie przedstawiono Rozpoznanie przeciążenia obowiązywać.</span><span class="sxs-lookup"><span data-stu-id="2ecad-269">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="2ecad-270">Komentarz dla każdego wywołania w `Main` — metoda zawiera, którego metoda faktycznie jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="2ecad-270">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="2ecad-271">Jak to przedstawiono w przykładzie, zawsze można wybrać konkretnej metody przez jawne rzutowanie argumentów do typów parametru dokładne i/lub jawne określenie argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-271">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="2ecad-272">O innych elementach członkowskich — funkcja</span><span class="sxs-lookup"><span data-stu-id="2ecad-272">Other function members</span></span>

<span data-ttu-id="2ecad-273">Elementy członkowskie, które zawierają kod wykonywalny są nazywane zbiorczo *funkcji elementów członkowskich* klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-273">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="2ecad-274">Poprzedniej sekcji opisano metody, które są podstawowym typem funkcji elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="2ecad-274">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="2ecad-275">W tej sekcji opisano inne rodzaje elementy funkcja obsługiwane w języku C#: konstruktorów, właściwości, indeksatorów, zdarzenia, Operatorzy i finalizatory.</span><span class="sxs-lookup"><span data-stu-id="2ecad-275">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="2ecad-276">Oto ogólny klasy o nazwie listy<T>, który implementuje growable listy obiektów.</span><span class="sxs-lookup"><span data-stu-id="2ecad-276">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="2ecad-277">Klasa zawiera kilka przykładów typowych rodzajów członków funkcji.</span><span class="sxs-lookup"><span data-stu-id="2ecad-277">The class contains several examples of the most common kinds of function members.</span></span>

[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="2ecad-278">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="2ecad-278">Constructors</span></span>

<span data-ttu-id="2ecad-279">C# obsługuje zarówno wystąpienia i konstruktorów statycznych.</span><span class="sxs-lookup"><span data-stu-id="2ecad-279">C# supports both instance and static constructors.</span></span> <span data-ttu-id="2ecad-280">*Konstruktora wystąpienia* jest element członkowski, który implementuje czynności wymagane do zainicjowania wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-280">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="2ecad-281">A *Konstruktor statyczny* jest element członkowski, który implementuje czynności wymagane do zainicjowania samej klasy po pierwszym załadowaniu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-281">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="2ecad-282">Konstruktor jest zadeklarowana jak metody z nie zwracany typ i taką samą nazwę jak klasa zawierająca.</span><span class="sxs-lookup"><span data-stu-id="2ecad-282">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="2ecad-283">Jeśli w deklaracji konstruktora zawiera modyfikator statyczny, deklaruje Konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="2ecad-283">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="2ecad-284">W przeciwnym razie deklaruje być konstruktorem wystąpień.</span><span class="sxs-lookup"><span data-stu-id="2ecad-284">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="2ecad-285">Konstruktory wystąpień może zostać przeciążony i może mieć następujące parametry opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="2ecad-285">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="2ecad-286">Na przykład `List<T>` klasy deklaruje dwa konstruktory wystąpień z żadnych parametrów i jedną, która przyjmuje `int` parametru.</span><span class="sxs-lookup"><span data-stu-id="2ecad-286">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="2ecad-287">Konstruktory wystąpień są wywoływane przy użyciu `new` operatora.</span><span class="sxs-lookup"><span data-stu-id="2ecad-287">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="2ecad-288">Poniższe instrukcje przydzielić dwie `List<string>` wystąpienia przy użyciu konstruktora `List` klasy z włączonymi i wyłączonymi opcjonalny argument.</span><span class="sxs-lookup"><span data-stu-id="2ecad-288">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="2ecad-289">W przeciwieństwie do innych członków konstruktory wystąpień nie są dziedziczone, a klasa nie ma konstruktorów wystąpienia innych niż rzeczywiście zgłoszonymi w klasie.</span><span class="sxs-lookup"><span data-stu-id="2ecad-289">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="2ecad-290">Jeśli żaden konstruktor wystąpienia nie jest dostarczony dla klasy, następnie pustą bez parametrów jest teraz udostępniana automatycznie.</span><span class="sxs-lookup"><span data-stu-id="2ecad-290">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="2ecad-291">Właściwości</span><span class="sxs-lookup"><span data-stu-id="2ecad-291">Properties</span></span>

<span data-ttu-id="2ecad-292">*Właściwości* są stanowi naturalne rozszerzenie pola.</span><span class="sxs-lookup"><span data-stu-id="2ecad-292">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="2ecad-293">Elementy członkowskie o związane z nimi typy są nazwanych, i składnia do uzyskiwania dostępu do pola i właściwości jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="2ecad-293">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="2ecad-294">Jednak w przeciwieństwie do pola, właściwości oznacza lokalizacji przechowywania.</span><span class="sxs-lookup"><span data-stu-id="2ecad-294">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="2ecad-295">Właściwości mają *akcesorów* określające instrukcje, które ma być wykonywana w przypadku ich wartości są odczytywane lub zapisywane.</span><span class="sxs-lookup"><span data-stu-id="2ecad-295">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="2ecad-296">Właściwość zadeklarowana takich jak pole, z wyjątkiem, że deklaracja kończy metody dostępu get i/lub metody dostępu set zapisywane między ograniczniki `{` i `}` zamiast kończy się średnikiem.</span><span class="sxs-lookup"><span data-stu-id="2ecad-296">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="2ecad-297">Właściwość, która ma zarówno metodę dostępu get i SET jest *odczytu i zapisu właściwości*, właściwości, która ma metodę dostępu get jest *właściwości tylko do odczytu*, i właściwości, która zawiera tylko metodą dostępu set jest *właściwości tylko do zapisu*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-297">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="2ecad-298">Metody dostępu get odnosi się do metody bez parametrów, zwracając wartość typu właściwości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-298">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="2ecad-299">Z wyjątkiem jako elementem docelowym przypisania, gdy to wyrażenie odwołuje się do właściwości metody dostępu get właściwości jest wywoływane w celu obliczenia wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-299">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="2ecad-300">Metodą dostępu set odnosi się do metody z pojedynczym parametrem o nazwie wartość i nie zwracanego typu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-300">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="2ecad-301">Gdy właściwość odwołuje się do jako elementem docelowym przypisania lub argument operacji ++ lub--, metody dostępu set jest wywoływana z argumentem, który udostępnia nową wartość.</span><span class="sxs-lookup"><span data-stu-id="2ecad-301">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="2ecad-302">`List<T>` Klasy deklaruje dwie właściwości Liczba i pojemności, które są tylko do odczytu i odczytu i zapisu, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="2ecad-302">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="2ecad-303">Oto przykład korzystanie z tych właściwości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-303">The following is an example of use of these properties.</span></span>

[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="2ecad-304">Podobnie jak pól i metod, C# obsługuje zarówno właściwości wystąpienia i właściwości statycznej.</span><span class="sxs-lookup"><span data-stu-id="2ecad-304">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="2ecad-305">Właściwości statyczne są deklarowane jako statyczne modyfikatorem, a właściwości obiektu są deklarowane jako bez niego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-305">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="2ecad-306">Accessor(s) właściwości mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="2ecad-306">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="2ecad-307">Po deklaracji właściwości obejmuje `virtual`, `abstract`, lub `override` , modyfikator dotyczy ona accessor(s) właściwości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-307">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="2ecad-308">Indeksatory</span><span class="sxs-lookup"><span data-stu-id="2ecad-308">Indexers</span></span>

<span data-ttu-id="2ecad-309">*Indeksatora* jest element członkowski, który umożliwia obiektów do zindeksowania w taki sam sposób jak tablicy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-309">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="2ecad-310">Indeksator zadeklarowano jak właściwości z wyjątkiem, że nazwa elementu członkowskiego jest to następuje listy parametrów zapisywane między ograniczniki `[` i `]`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-310">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="2ecad-311">Parametry są dostępne w accessor(s) indeksatora.</span><span class="sxs-lookup"><span data-stu-id="2ecad-311">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="2ecad-312">Podobnie jak właściwości, indeksatorów mogą być do odczytu / zapisu, tylko do odczytu i tylko do zapisu, a accessor(s) indeksatora mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="2ecad-312">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="2ecad-313">`List` Klasy deklaruje pojedynczego indeksatora odczytu i zapisu, który przyjmuje `int` parametru.</span><span class="sxs-lookup"><span data-stu-id="2ecad-313">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="2ecad-314">Indeksator umożliwia indeksu `List` wystąpień z `int` wartości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-314">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="2ecad-315">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="2ecad-315">For example:</span></span>

[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="2ecad-316">Można przeciążać indeksatorów, co oznacza klasy można zadeklarować indeksatorów wielu tak długo, jak liczby lub typów ich parametry są różne.</span><span class="sxs-lookup"><span data-stu-id="2ecad-316">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="2ecad-317">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="2ecad-317">Events</span></span>

<span data-ttu-id="2ecad-318">*Zdarzeń* jest element członkowski, który umożliwia klasy lub obiekt, aby zapewnić powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="2ecad-318">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="2ecad-319">Zdarzenie zadeklarowano takich jak pole z tą różnicą, że deklaracja zawiera słowo kluczowe zdarzeń i typ musi być typem obiektu delegowanego.</span><span class="sxs-lookup"><span data-stu-id="2ecad-319">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="2ecad-320">W obrębie klasy, który deklaruje element członkowski zdarzeń zdarzenie zachowuje się jak pole typu delegata (zakładając, że zdarzenie nie jest abstrakcyjna i nie deklaruje metody dostępu).</span><span class="sxs-lookup"><span data-stu-id="2ecad-320">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="2ecad-321">Pole zawiera odwołanie do delegata, który reprezentuje obsługi zdarzeń, które zostały dodane do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="2ecad-321">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="2ecad-322">Jeśli istnieją nie obsługi zdarzeń, to pole jest `null`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-322">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="2ecad-323">`List<T>` Klasy deklaruje element członkowski pojedyncze zdarzenie o nazwie `Changed`, co oznacza, że dodano nowy element do listy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-323">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="2ecad-324">Zmienione zdarzenie zostanie wywołane przez `OnChanged` metody wirtualnej, która najpierw sprawdza, czy zdarzenie `null` (to znaczy czy nie obsługi znajdują się).</span><span class="sxs-lookup"><span data-stu-id="2ecad-324">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="2ecad-325">Pojęcia wywołaniem zdarzenia jest dokładnie odpowiednikiem wywołania delegata reprezentowany przez zdarzenie, w związku z tym nie istnieją żadne specjalne języka konstrukcje wywoływanie zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="2ecad-325">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="2ecad-326">Klienci reagowania na zdarzenia za pośrednictwem *procedury obsługi zdarzeń*.</span><span class="sxs-lookup"><span data-stu-id="2ecad-326">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="2ecad-327">Programy obsługi zdarzeń są dołączone przy użyciu `+=` operatora i usunięty przy użyciu `-=` operatora.</span><span class="sxs-lookup"><span data-stu-id="2ecad-327">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="2ecad-328">Poniższy przykład dołącza program obsługi zdarzeń do `Changed` zdarzenie `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-328">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="2ecad-329">Dla zaawansowanych scenariuszy, w których formant powiązany magazyn zdarzenia jest potrzebne, można jawnie Podaj deklaracji zdarzenia `add` i `remove` metod dostępu, które są nieco podobne do `set` metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-329">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="2ecad-330">Operatory</span><span class="sxs-lookup"><span data-stu-id="2ecad-330">Operators</span></span>

<span data-ttu-id="2ecad-331">*Operator* jest element członkowski, który definiuje znaczenie zastosowanie operatora określonego wyrażenia do wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-331">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="2ecad-332">Można zdefiniować trzy rodzaje operatory: jednoargumentowe operatory operatorów binarnych i operatory konwersji.</span><span class="sxs-lookup"><span data-stu-id="2ecad-332">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="2ecad-333">Wszystkie operatory musi być zadeklarowany jako `public` i `static`.</span><span class="sxs-lookup"><span data-stu-id="2ecad-333">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="2ecad-334">`List<T>` Klasy deklaruje dwa operatory `operator ==` i `operator !=`i w związku z tym udostępnia nowe znaczenie wyrażeń, które są stosowane te operatorom `List` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="2ecad-334">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="2ecad-335">W szczególności operatorów Definiowanie równości dwóch `List<T>` wystąpienia jako porównanie każdego zawarte obiekty metodami równości.</span><span class="sxs-lookup"><span data-stu-id="2ecad-335">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="2ecad-336">W poniższym przykładzie użyto `==` operatora, aby porównać dwa `List<int>` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="2ecad-336">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="2ecad-337">Pierwszy `Console.WriteLine` generuje `True` ponieważ dwie listy zawierać taką samą liczbę obiektów o tej samej wartości w tej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="2ecad-337">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="2ecad-338">Ma `List<T>` nie zdefiniowano `operator ==`, pierwszy `Console.WriteLine` będzie mieć output `False` ponieważ `a` i `b` odwołania różnych `List<int>` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="2ecad-338">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="2ecad-339">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="2ecad-339">Finalizers</span></span>

<span data-ttu-id="2ecad-340">A *finalizator* jest element członkowski, który implementuje czynności wymagane do zakończenia wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="2ecad-340">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="2ecad-341">Finalizatory nie mogą mieć parametrów, modyfikatory dostępności nie mogą jednak mieć i nie można wywołać bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="2ecad-341">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="2ecad-342">Finalizator dla wystąpienia jest wywoływana automatycznie podczas wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="2ecad-342">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="2ecad-343">Moduł zbierający elementy bezużyteczne jest dozwolone szerokości szerokości geograficznej w decydowanie o czasie zbierania obiektów i uruchom finalizatory.</span><span class="sxs-lookup"><span data-stu-id="2ecad-343">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="2ecad-344">Czas wywołania finalizatora nie jest deterministyczna i finalizatory mogą być wykonywane w którymkolwiek wątku.</span><span class="sxs-lookup"><span data-stu-id="2ecad-344">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="2ecad-345">Tych i innych przyczyn klasy należy zaimplementować finalizatory tylko wtedy, gdy żadne inne rozwiązania nie są możliwe.</span><span class="sxs-lookup"><span data-stu-id="2ecad-345">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="2ecad-346">`using` Instrukcji zapewnia lepszym rozwiązaniem do zniszczenia obiektu.</span><span class="sxs-lookup"><span data-stu-id="2ecad-346">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="2ecad-347">[Poprzednie](statements.md)
[dalej](structs.md)</span><span class="sxs-lookup"><span data-stu-id="2ecad-347">[Previous](statements.md)
[Next](structs.md)</span></span>
