---
title: Klasy i obiekty w języku C# — zwiedzanie języka Języka C#
description: Nowy w C#? Przeczytaj ten przegląd klas, obiektów i dziedziczenia
ms.date: 02/27/2020
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: c178e11b5667905f75538555c8a309e2fdb4a9ef
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "78159185"
---
# <a name="classes-and-objects"></a><span data-ttu-id="7ffdf-104">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="7ffdf-104">Classes and objects</span></span>

<span data-ttu-id="7ffdf-105">*Klasy* są najbardziej podstawowe typy C#.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="7ffdf-106">Klasa jest strukturą danych, która łączy stan (pola) i akcje (metody i inne elementy członkowskie funkcji) w jednej jednostce.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="7ffdf-107">Klasa zawiera definicję dynamicznie *utworzonych wystąpień* klasy, znanych również jako *obiekty*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="7ffdf-108">Klasy obsługują *dziedziczenie* i *polimorfizm*, mechanizmy, dzięki którym *klasy pochodne* mogą rozszerzać i specjalizować *klasy podstawowe.*</span><span class="sxs-lookup"><span data-stu-id="7ffdf-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="7ffdf-109">Nowe klasy są tworzone przy użyciu deklaracji klas.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-109">New classes are created using class declarations.</span></span> <span data-ttu-id="7ffdf-110">Deklaracja klasy rozpoczyna się od nagłówka, który określa atrybuty i modyfikatory klasy, nazwę klasy, klasę podstawową (jeśli podano) i interfejsy implementowane przez klasę.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="7ffdf-111">Po nagłówku następuje treść klasy, która składa się z listy deklaracji `{` `}`członkowskich napisanych między ogranicznikami i .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="7ffdf-112">Poniższy kod przedstawia deklarację prostej klasy `Point`o nazwie:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-112">The following code shows a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="7ffdf-113">Wystąpienia klas są tworzone przy `new` użyciu operatora, który przydziela pamięć dla nowego wystąpienia, wywołuje konstruktora zainicjować wystąpienie i zwraca odwołanie do wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="7ffdf-114">Następujące instrukcje utworzyć dwa Point obiektów i przechowywać odwołania do tych obiektów w dwóch zmiennych:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="7ffdf-115">Pamięć zajmowana przez obiekt jest automatycznie odzyskiwana, gdy obiekt nie jest już osiągalny.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="7ffdf-116">Nie jest konieczne ani możliwe jawnie calokacji obiektów w języku C#.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-116">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="7ffdf-117">Elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="7ffdf-117">Members</span></span>

<span data-ttu-id="7ffdf-118">Członkowie klasy są statycznych elementów członkowskich lub elementów członkowskich wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="7ffdf-119">Elementy członkowskie statyczne należą do klas, a elementy członkowskie wystąpienia należą do obiektów (wystąpienia klas).</span><span class="sxs-lookup"><span data-stu-id="7ffdf-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="7ffdf-120">Poniższa lista zawiera przegląd rodzajów elementów członkowskich, które może zawierać klasa.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-120">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="7ffdf-121">Stałe</span><span class="sxs-lookup"><span data-stu-id="7ffdf-121">Constants</span></span>
  - <span data-ttu-id="7ffdf-122">Stałe wartości skojarzone z klasą</span><span class="sxs-lookup"><span data-stu-id="7ffdf-122">Constant values associated with the class</span></span>
- <span data-ttu-id="7ffdf-123">Pola</span><span class="sxs-lookup"><span data-stu-id="7ffdf-123">Fields</span></span>
  - <span data-ttu-id="7ffdf-124">Zmienne klasy</span><span class="sxs-lookup"><span data-stu-id="7ffdf-124">Variables of the class</span></span>
- <span data-ttu-id="7ffdf-125">Metody</span><span class="sxs-lookup"><span data-stu-id="7ffdf-125">Methods</span></span>
  - <span data-ttu-id="7ffdf-126">Obliczenia i akcje, które mogą być wykonywane przez klasę</span><span class="sxs-lookup"><span data-stu-id="7ffdf-126">Computations and actions that can be performed by the class</span></span>
- <span data-ttu-id="7ffdf-127">Właściwości</span><span class="sxs-lookup"><span data-stu-id="7ffdf-127">Properties</span></span>
  - <span data-ttu-id="7ffdf-128">Akcje skojarzone z odczytywaniem i zapisywaniem nazwanych właściwości klasy</span><span class="sxs-lookup"><span data-stu-id="7ffdf-128">Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="7ffdf-129">Indexers (Indeksatory)</span><span class="sxs-lookup"><span data-stu-id="7ffdf-129">Indexers</span></span>
  - <span data-ttu-id="7ffdf-130">Akcje skojarzone z indeksowaniem wystąpień klasy, takich jak tablica</span><span class="sxs-lookup"><span data-stu-id="7ffdf-130">Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="7ffdf-131">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="7ffdf-131">Events</span></span>
  - <span data-ttu-id="7ffdf-132">Powiadomienia, które mogą być generowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="7ffdf-132">Notifications that can be generated by the class</span></span>
- <span data-ttu-id="7ffdf-133">Operatory</span><span class="sxs-lookup"><span data-stu-id="7ffdf-133">Operators</span></span>
  - <span data-ttu-id="7ffdf-134">Konwersje i operatory wyrażeń obsługiwane przez klasę</span><span class="sxs-lookup"><span data-stu-id="7ffdf-134">Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="7ffdf-135">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="7ffdf-135">Constructors</span></span>
  - <span data-ttu-id="7ffdf-136">Akcje wymagane do zainicjowania wystąpień klasy lub samej klasy</span><span class="sxs-lookup"><span data-stu-id="7ffdf-136">Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="7ffdf-137">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="7ffdf-137">Finalizers</span></span>
  - <span data-ttu-id="7ffdf-138">Akcje do wykonania przed wystąpieniem klasy są trwale odrzucane</span><span class="sxs-lookup"><span data-stu-id="7ffdf-138">Actions to perform before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="7ffdf-139">Typy</span><span class="sxs-lookup"><span data-stu-id="7ffdf-139">Types</span></span>
  - <span data-ttu-id="7ffdf-140">Typy zagnieżdżone zadeklarowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="7ffdf-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="7ffdf-141">Ułatwienia dostępu</span><span class="sxs-lookup"><span data-stu-id="7ffdf-141">Accessibility</span></span>

<span data-ttu-id="7ffdf-142">Każdy element członkowski klasy ma skojarzoną dostępność, która kontroluje regiony tekstu programu, który może uzyskać dostęp do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-142">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="7ffdf-143">Istnieje sześć możliwych form dostępności.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="7ffdf-144">Modyfikatory dostępu są podsumowane poniżej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-144">The access modifiers are summarized below.</span></span>

- `public`
  - <span data-ttu-id="7ffdf-145">Dostęp nie jest ograniczony.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-145">Access isn't limited.</span></span>
- `protected`
  - <span data-ttu-id="7ffdf-146">Dostęp jest ograniczony do tej klasy lub klas pochodzących z tej klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-146">Access is limited to this class or classes derived from this class.</span></span>
- `internal`
  - <span data-ttu-id="7ffdf-147">Dostęp jest ograniczony do bieżącego zestawu (.exe, .dll itd.).</span><span class="sxs-lookup"><span data-stu-id="7ffdf-147">Access is limited to the current assembly (.exe, .dll, and so on.).</span></span>
- `protected internal`
  - <span data-ttu-id="7ffdf-148">Dostęp jest ograniczony do klasy zawierającej, klas pochodzących z klasy zawierającej lub klas w ramach tego samego zestawu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-148">Access is limited to the containing class, classes derived from the containing class, or classes within the same assembly.</span></span>
- `private`
  - <span data-ttu-id="7ffdf-149">Dostęp jest ograniczony do tej klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-149">Access is limited to this class.</span></span>
- `private protected`
  - <span data-ttu-id="7ffdf-150">Dostęp jest ograniczony do klasy zawierającej lub klas pochodzących z typu zawierającego w ramach tego samego zestawu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-150">Access is limited to the containing class or classes derived from the containing type within the same assembly.</span></span>

## <a name="type-parameters"></a><span data-ttu-id="7ffdf-151">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="7ffdf-151">Type parameters</span></span>

<span data-ttu-id="7ffdf-152">Definicja klasy może określać zestaw parametrów typu, postępując zgodnie z nazwą klasy z nawiasami kątowymi otaczającymi listę nazw parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="7ffdf-153">Parametry typu mogą być następnie używane w treści deklaracji klas do definiowania elementów członkowskich klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="7ffdf-154">W poniższym przykładzie parametry typu `Pair` `TFirst` są `TSecond`i:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="7ffdf-155">Typ klasy, który jest zadeklarowany do podjęcia parametrów typu jest nazywany *typem klasy ogólnej*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="7ffdf-156">Typy struktury, interfejsu i delegata mogą być również ogólne.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-156">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="7ffdf-157">Gdy używana jest klasa ogólna, argumenty typu muszą być podane dla każdego z parametrów typu:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="7ffdf-158">Typ ogólny z podanymi `Pair<int,string>` argumentami typu, jak powyżej, jest nazywany *typem konstruowanym.*</span><span class="sxs-lookup"><span data-stu-id="7ffdf-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="7ffdf-159">Klas podstawowych</span><span class="sxs-lookup"><span data-stu-id="7ffdf-159">Base classes</span></span>

<span data-ttu-id="7ffdf-160">Deklaracja klasy może określić klasę podstawową, wykonując parametry nazwy klasy i typu z dwukropkiem i nazwą klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="7ffdf-161">Pominięcie specyfikacji klasy podstawowej jest taka `object`sama jak wynikająca z typu .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="7ffdf-162">W poniższym przykładzie klasa `Point3D` podstawowa jest `Point`, `Point` a `object`klasa podstawowa jest:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="7ffdf-163">Klasa dziedziczy członków swojej klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="7ffdf-164">Dziedziczenie oznacza, że klasa niejawnie zawiera wszystkie elementy członkowskie swojej klasy podstawowej, z wyjątkiem wystąpienia i konstruktorów statycznych i finalizatorów klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="7ffdf-165">Klasa pochodna można dodać nowe elementy członkowskie do tych elementów członkowskich dziedziczy, ale nie można usunąć definicję dziedziczonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-165">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="7ffdf-166">W poprzednim przykładzie `Point3D` dziedziczy `x` pola i `y` z `Point`, a każde `Point3D` wystąpienie zawiera trzy pola, `x`, `y`, i `z`.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="7ffdf-167">Niejawna konwersja istnieje z typu klasy do dowolnego z jego typów klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="7ffdf-168">Zmienna typu klasy może odwoływać się do wystąpienia tej klasy lub wystąpienia dowolnej klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-168">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="7ffdf-169">Na przykład, biorąc pod uwagę poprzednie deklaracje klasy, zmienna typu `Point` może odwoływać się `Point` `Point3D`do:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="7ffdf-170">Pola</span><span class="sxs-lookup"><span data-stu-id="7ffdf-170">Fields</span></span>

<span data-ttu-id="7ffdf-171">*Pole* jest zmienną skojarzoną z klasą lub wystąpieniem klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="7ffdf-172">Pole zadeklarowane za pomocą modyfikatora statycznego definiuje pole statyczne.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="7ffdf-173">Pole statyczne identyfikuje dokładnie jedną lokalizację magazynu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="7ffdf-174">Bez względu na to, ile wystąpień klasy są tworzone, istnieje tylko jedna kopia pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-174">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="7ffdf-175">Pole zadeklarowane bez modyfikatora statycznego definiuje pole wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="7ffdf-176">Każde wystąpienie klasy zawiera oddzielną kopię wszystkich pól wystąpienia tej klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="7ffdf-177">W poniższym przykładzie każde `Color` wystąpienie klasy ma oddzielną `g`kopię `b` pól `r`, i wystąpienia, ale `Black`istnieje `White` `Red`tylko `Green`jedna `Blue` kopia pól , , , , i statyczne:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="7ffdf-178">Jak pokazano w poprzednim *przykładzie, pola tylko do odczytu* mogą być deklarowane za pomocą modyfikatora. `readonly`</span><span class="sxs-lookup"><span data-stu-id="7ffdf-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="7ffdf-179">Przypisanie `readonly` do pola może nastąpić tylko jako część deklaracji pola lub w konstruktorze w tej samej klasie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="7ffdf-180">Metody</span><span class="sxs-lookup"><span data-stu-id="7ffdf-180">Methods</span></span>

<span data-ttu-id="7ffdf-181">*Metoda* jest elementem członkowskim, który implementuje obliczeń lub akcji, które mogą być wykonywane przez obiekt lub klasę.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="7ffdf-182">*Metody statyczne* są dostępne za pośrednictwem klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="7ffdf-183">*Metody wystąpienia* są dostępne za pośrednictwem wystąpień klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="7ffdf-184">Metody mogą mieć listę *parametrów*, które reprezentują wartości lub odwołania zmiennych przekazywane do metody, oraz *typ zwracany*, który określa typ wartości obliczonej i zwróconej przez metodę.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="7ffdf-185">Typ zwracany metody `void` jest, jeśli nie zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-185">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="7ffdf-186">Podobnie jak typy, metody mogą mieć również zestaw parametrów typu, dla których argumenty typu muszą być określone, gdy metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="7ffdf-187">W przeciwieństwie do typów argumenty typu często można wywnioskować z argumentów wywołania metody i nie muszą być jawnie podane.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="7ffdf-188">*Podpis* metody musi być unikatowy w klasie, w której metoda jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="7ffdf-189">Podpis metody składa się z nazwy metody, liczby parametrów typu i liczby, modyfikatorów i typów jej parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="7ffdf-190">Podpis metody nie zawiera typu zwracanego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-190">The signature of a method doesn't include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="7ffdf-191">Parametry</span><span class="sxs-lookup"><span data-stu-id="7ffdf-191">Parameters</span></span>

<span data-ttu-id="7ffdf-192">Parametry są używane do przekazywania wartości lub zmiennych odniesień do metod.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="7ffdf-193">Parametry metody uzyskać ich rzeczywiste wartości z *argumentów,* które są określone podczas wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="7ffdf-194">Istnieją cztery rodzaje parametrów: parametry wartości, parametry odniesienia, parametry wyjściowe i tablice parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="7ffdf-195">*Parametr wartości* jest używany do przekazywania argumentów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="7ffdf-196">Parametr wartości odpowiada zmiennej lokalnej, która pobiera jego wartość początkową z argumentu, który został przekazany dla parametru.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="7ffdf-197">Modyfikacje parametru value nie mają wpływu na argument, który został przekazany dla parametru.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-197">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="7ffdf-198">Parametry wartości mogą być opcjonalne, określając wartość domyślną, dzięki czemu można pominąć odpowiednie argumenty.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="7ffdf-199">*Parametr referencyjny* jest używany do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="7ffdf-200">Argument przekazany dla parametru odwołania musi być zmienną o określonej wartości, a podczas wykonywania metody parametr referencyjny reprezentuje tę samą lokalizację magazynu co zmienna argumentu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="7ffdf-201">Parametr referencyjny jest `ref` zadeklarowany za pomocą modyfikatora.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="7ffdf-202">W poniższym przykładzie `ref` przedstawiono użycie parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="7ffdf-203">*Parametr wyjściowy* jest używany do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="7ffdf-204">Jest podobny do parametru odwołania, z tą różnicą, że nie wymaga jawnie przypisać wartość do argumentu dostarczonego przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="7ffdf-205">Parametr wyjściowy jest zadeklarowany za pomocą modyfikatora. `out`</span><span class="sxs-lookup"><span data-stu-id="7ffdf-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="7ffdf-206">W poniższym przykładzie `out` przedstawiono użycie parametrów przy użyciu składni wprowadzone w języku C# 7.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="7ffdf-207">Tablica *parametrów* umożliwia zmienną liczbę argumentów, które mają być przekazywane do metody.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="7ffdf-208">Tablica parametrów jest `params` zadeklarowana za pomocą modyfikatora.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="7ffdf-209">Tylko ostatni parametr metody może być tablicą parametrów, a typ tablicy parametrów musi być jednowymiarowym typem tablicy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="7ffdf-210">Metody Write i WriteLine <xref:System.Console?displayProperty=nameWithType> klasy są dobrymi przykładami użycia tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="7ffdf-211">Są one zadeklarowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-211">They're declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="7ffdf-212">W ramach metody, która używa tablicy parametrów, tablica parametrów zachowuje się dokładnie tak, jak zwykły parametr typu tablicy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="7ffdf-213">Jednak w wywołaniu metody z tablicą parametrów można przekazać pojedynczy argument typu tablicy parametrów lub dowolną liczbę argumentów typu elementu tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-213">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="7ffdf-214">W tym ostatnim przypadku wystąpienie tablicy jest automatycznie tworzone i inicjowane z podanymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="7ffdf-215">W tym przykładzie</span><span class="sxs-lookup"><span data-stu-id="7ffdf-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="7ffdf-216">jest odpowiednikiem pisania następujących czynności.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="7ffdf-217">Treść metody i zmienne lokalne</span><span class="sxs-lookup"><span data-stu-id="7ffdf-217">Method body and local variables</span></span>

<span data-ttu-id="7ffdf-218">Treść metody określa instrukcje do wykonania, gdy metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="7ffdf-219">Treść metody może zadeklarować zmienne, które są specyficzne dla wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="7ffdf-220">Takie zmienne są nazywane *zmiennymi lokalnymi*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="7ffdf-221">Deklaracja zmiennej lokalnej określa nazwę typu, nazwę zmiennej i prawdopodobnie wartość początkową.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="7ffdf-222">W poniższym przykładzie zadeklarowano zmienną `i` lokalną o `j` wartości początkowej zero i zmiennej lokalnej bez wartości początkowej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="7ffdf-223">C# wymaga zmiennej *lokalnej,* aby zdecydowanie przypisać przed jego wartość można uzyskać.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="7ffdf-224">Na przykład jeśli deklaracja `i` poprzedniego nie zawiera wartości początkowej, kompilator zgłosi `i` błąd `i` dla kolejnych użycia, ponieważ nie będzie zdecydowanie przypisany w tych punktach w programie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-224">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="7ffdf-225">Metoda może `return` używać instrukcji, aby przywrócić kontrolę do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="7ffdf-226">W zwracanej `void`metodzie `return` instrukcje nie mogą określić wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-226">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="7ffdf-227">W metodzie zwracającej nieunieważnione `return` instrukcje muszą zawierać wyrażenie obliczające wartość zwracaną.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="7ffdf-228">Metody statyczne i instancjowe</span><span class="sxs-lookup"><span data-stu-id="7ffdf-228">Static and instance methods</span></span>

<span data-ttu-id="7ffdf-229">Metoda zadeklarowana za pomocą modyfikatora statycznego jest *metodą statyczną.*</span><span class="sxs-lookup"><span data-stu-id="7ffdf-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="7ffdf-230">Metoda statyczna nie działa w określonym wystąpieniu i może uzyskać bezpośredni dostęp tylko do elementów statycznych.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-230">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="7ffdf-231">Metoda zadeklarowana bez statycznego modyfikatora jest *metodą instancji*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="7ffdf-232">Metoda wystąpienia działa w określonym wystąpieniu i może uzyskać dostęp zarówno statyczne i wystąpienia elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="7ffdf-233">Wystąpienie, na którym wywołana została metoda wystąpienia, `this`można jawnie uzyskać dostęp jako .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="7ffdf-234">Jest to błąd, do `this` wyniku do niego w metodzie statycznej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-234">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="7ffdf-235">Następująca `Entity` klasa ma elementy członkowskie statyczne i wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="7ffdf-236">Każde `Entity` wystąpienie zawiera numer seryjny (i prawdopodobnie inne informacje, które nie są wyświetlane w tym miejscu).</span><span class="sxs-lookup"><span data-stu-id="7ffdf-236">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="7ffdf-237">Konstruktor `Entity` (który jest jak metoda wystąpienia) inicjuje nowe wystąpienie z następnego dostępnego numeru seryjnego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="7ffdf-238">Ponieważ konstruktor jest elementem członkowskim wystąpienia, może `serialNo` uzyskać dostęp `nextSerialNo` zarówno do pola wystąpienia, jak i pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-238">Because the constructor is an instance member, it's permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="7ffdf-239">Metody `GetNextSerialNo` `SetNextSerialNo` statyczne i statyczne `nextSerialNo` mogą uzyskiwać dostęp do pola statycznego, `serialNo` ale byłoby błędem, aby uzyskać bezpośredni dostęp do pola wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="7ffdf-240">W poniższym przykładzie przedstawiono użycie klasy Entity.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="7ffdf-241">Metody `SetNextSerialNo` `GetNextSerialNo` statyczne i statyczne są wywoływane w `GetSerialNo` klasie, podczas gdy metoda wystąpienia jest wywoływana na wystąpieniach klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-241">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="7ffdf-242">Metody wirtualne, zastępowane i abstrakcyjne</span><span class="sxs-lookup"><span data-stu-id="7ffdf-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="7ffdf-243">Gdy deklaracja metody `virtual` wystąpienia zawiera modyfikator, metoda jest uważana za *metodę wirtualną*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="7ffdf-244">Gdy nie ma wirtualnego modyfikatora jest obecny, metoda jest uważana za *metodę niewirtualną*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="7ffdf-245">Gdy metoda wirtualna jest wywoływana, *typ czasu wykonywania* wystąpienia, dla którego odbywa się to wywołanie określa implementację metody rzeczywistej do wywołania.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="7ffdf-246">W wywołaniu metody niewirtualnej *typ czasu kompilacji* wystąpienia jest czynnikiem decydującym.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="7ffdf-247">Metoda wirtualna może zostać *zastąpiona* w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="7ffdf-248">Gdy deklaracja metody wystąpienia zawiera modyfikator zastępowania, metoda zastępuje dziedziczoną metodę wirtualną o tym samym podpisie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="7ffdf-249">Podczas gdy deklaracja metody wirtualnej wprowadza nową metodę, deklaracja metody zastępowania specjalizuje się w istniejącej dziedziczonej metodzie wirtualnej, zapewniając nową implementację tej metody.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="7ffdf-250">*Metoda abstrakcyjna* jest metodą wirtualną bez implementacji.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="7ffdf-251">Metoda abstrakcyjna jest zadeklarowana za pomocą modyfikatora abstrakcyjnego i jest dozwolona tylko w klasie, która jest również zadeklarowana jako abstrakcyjna.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="7ffdf-252">Metoda abstrakcyjna musi zostać zastąpiona w każdej nieabstrakcyjnej klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="7ffdf-253">W poniższym przykładzie deklaruje `Expression`klasę abstrakcyjną, która reprezentuje węzeł drzewa wyrażeń i trzy klasy pochodne , `Constant`, `VariableReference`i `Operation`, które implementują węzły drzewa wyrażeń dla stałych, odwołań zmiennych i operacji arytmetycznych.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="7ffdf-254">(Ten przykład jest podobny do, ale nie należy mylić z typami drzewa wyrażeń).</span><span class="sxs-lookup"><span data-stu-id="7ffdf-254">(This example is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="7ffdf-255">Poprzednie cztery klasy mogą służyć do modelowania wyrażeń arytmetycznych.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="7ffdf-256">Na przykład przy użyciu wystąpień tych `x + 3` klas wyrażenie może być reprezentowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="7ffdf-257">Metoda `Evaluate` wystąpienia `Expression` jest wywoływana do oceny danego wyrażenia `double` i wygenerować wartość.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="7ffdf-258">Metoda przyjmuje `Dictionary` argument, który zawiera nazwy zmiennych (jako klucze wpisów) i wartości (jako wartości wpisów).</span><span class="sxs-lookup"><span data-stu-id="7ffdf-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="7ffdf-259">Ponieważ `Evaluate` jest metodą abstrakcyjną, klasy nieabstrakcyjne pochodzące z `Expression` musi zastąpić `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="7ffdf-260">Implementacja `Constant` `Evaluate` po prostu zwraca przechowywane stałej.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="7ffdf-261">Implementacja `VariableReference`'s wyszbędzie nazwę zmiennej w słowniku i zwraca wynikową wartość.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="7ffdf-262">Implementacja `Operation`najpierw ocenia lewe i prawe argumenty (rekurencyjne wywoływanie ich `Evaluate` metod), a następnie wykonuje daną operację arytmetyczną.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="7ffdf-263">Poniższy program używa `Expression` klas do `x * (y + 2)` oceny wyrażenia `x` dla `y`różnych wartości i .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="7ffdf-264">Przeciążenie metody</span><span class="sxs-lookup"><span data-stu-id="7ffdf-264">Method overloading</span></span>

<span data-ttu-id="7ffdf-265">*Przeciążenie* metody pozwala wielu metod w tej samej klasie mają taką samą nazwę, tak długo, jak mają unikatowe podpisy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="7ffdf-266">Podczas kompilowania wywołania przeciążonej metody kompilator używa *rozpoznawania przeciążenia* w celu określenia określonej metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="7ffdf-267">Rozpoznawanie przeciążenia znajduje jedną metodę, która najlepiej pasuje do argumentów lub zgłasza błąd, jeśli nie można znaleźć najlepszego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="7ffdf-268">W poniższym przykładzie przedstawiono rozdzielczość przeciążenia w życie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="7ffdf-269">Komentarz dla każdego wywołania `UsageExample` w metodzie pokazuje, która metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-269">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="7ffdf-270">Jak pokazano w przykładzie, określonej metody zawsze można wybrać przez jawne rzutowanie argumentów do dokładnych typów parametrów i/lub jawnie podając argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="7ffdf-271">Inne elementy członkowskie funkcji</span><span class="sxs-lookup"><span data-stu-id="7ffdf-271">Other function members</span></span>

<span data-ttu-id="7ffdf-272">Elementy członkowskie, które zawierają kod wykonywalny są zbiorczo nazywane *członkami funkcji* klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="7ffdf-273">W powyższej sekcji opisano metody, które są podstawowymi typami elementów członkowskich funkcji.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-273">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="7ffdf-274">W tej sekcji opisano inne rodzaje elementów członkowskich funkcji obsługiwanych przez konstruktory C#: właściwości, indeksatory, zdarzenia, operatory i finalizatory.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="7ffdf-275">W poniższym przykładzie przedstawiono `MyList<T>`klasę rodzajową o nazwie , która implementuje rozwijaną listę obiektów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-275">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="7ffdf-276">Klasa zawiera kilka przykładów najbardziej typowych rodzajów elementów członkowskich funkcji.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="7ffdf-277">W tym `MyList` przykładzie tworzy klasę, która nie jest <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>taka sama jak standard .NET .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7ffdf-278">Ilustruje pojęcia potrzebne do tej trasy, ale nie zastępuje tej klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="7ffdf-279">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="7ffdf-279">Constructors</span></span>

<span data-ttu-id="7ffdf-280">C# obsługuje zarówno wystąpienia i statycznych konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="7ffdf-281">*Konstruktor wystąpienia* jest elementem członkowskim, który implementuje akcje wymagane do zainicjowania wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="7ffdf-282">*Konstruktora statycznego* jest elementem członkowskim, który implementuje akcje wymagane do zainicjowania samej klasy, gdy jest po raz pierwszy załadowany.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="7ffdf-283">Konstruktor jest zadeklarowany jako metoda bez typu zwracanego i tej samej nazwy co klasa zawierająca.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="7ffdf-284">Jeśli deklaracja konstruktora zawiera modyfikator statyczny, deklaruje konstruktora statycznego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="7ffdf-285">W przeciwnym razie deklaruje konstruktora wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="7ffdf-286">Konstruktory wystąpienia mogą być przeciążone i mogą mieć parametry opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-286">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="7ffdf-287">Na przykład `MyList<T>` klasa deklaruje jeden konstruktor `int` wystąpienia z jednym parametrem opcjonalnym.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-287">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="7ffdf-288">Konstruktory wystąpienia są `new` wywoływane przy użyciu operatora.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="7ffdf-289">Następujące instrukcje przydzielić dwa `MyList<string>` wystąpienia przy `MyList` użyciu konstruktora klasy z i bez argumentu opcjonalnego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="7ffdf-290">W przeciwieństwie do innych elementów członkowskich konstruktory wystąpienia nie są dziedziczone, a klasa nie ma konstruktorów wystąpienia innych niż te konstruktory faktycznie zadeklarowane w klasie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-290">Unlike other members, instance constructors aren't inherited, and a class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="7ffdf-291">Jeśli nie konstruktora wystąpienia jest dostarczany dla klasy, a następnie pusty jeden bez parametrów jest automatycznie dostarczane.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="7ffdf-292">Właściwości</span><span class="sxs-lookup"><span data-stu-id="7ffdf-292">Properties</span></span>

<span data-ttu-id="7ffdf-293">*Właściwości* są naturalnym rozszerzeniem pól.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="7ffdf-294">Oba są nazwane elementy członkowskie z skojarzonymi typami, a składnia dostępu do pól i właściwości jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="7ffdf-295">Jednak w przeciwieństwie do pól właściwości nie oznaczają lokalizacji magazynu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-295">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="7ffdf-296">Zamiast tego właściwości mają *akcesorów,* które określają instrukcje do wykonania, gdy ich wartości są odczytywane lub zapisywane.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="7ffdf-297">Właściwość jest zadeklarowana jako pole, z tą różnicą, że deklaracja kończy się get `{` akcesor i/lub set akcesor napisany między ogranicznikami i `}` zamiast kończyć się średnikiem.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="7ffdf-298">Właściwość, która ma zarówno get akcesor i set akcesor jest *właściwością odczytu i zapisu,* właściwość, która ma tylko get akcesor jest *właściwością tylko do odczytu,* a właściwość, która ma tylko set akcesor jest *tylko do zapisu właściwości*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="7ffdf-299">A get akcesor odpowiada metody bezparametrów z wartością zwracaną typu właściwości.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="7ffdf-300">Z wyjątkiem jako miejsce docelowe przypisania, gdy właściwość odwołuje się w wyrażeniu, get akcesor właściwości jest wywoływana w celu obliczenia wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="7ffdf-301">Set akcesor odpowiada metody z jednego parametru o nazwie wartości i bez zwracanego typu.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="7ffdf-302">Gdy właściwość jest wywoływana jako miejsce docelowe przypisania lub jako operand ++ lub --, set akcesor jest wywoływana z argumentem, który zapewnia nową wartość.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="7ffdf-303">Klasa `MyList<T>` deklaruje dwie właściwości `Count` i `Capacity`, które są tylko do odczytu i odczytu i zapisu, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="7ffdf-304">Poniższy kod jest przykładem użycia tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-304">The following code is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="7ffdf-305">Podobnie jak pola i metody C# obsługuje zarówno właściwości wystąpienia, jak i właściwości statyczne.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="7ffdf-306">Właściwości statyczne są deklarowane za pomocą modyfikatora statycznego, a właściwości wystąpienia są deklarowane bez niego.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="7ffdf-307">Akcesor(y) właściwości może być wirtualny.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="7ffdf-308">Gdy deklaracja właściwości `virtual` `abstract`zawiera `override` , lub modyfikator, ma zastosowanie do akcesor(-ów) właściwości.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="7ffdf-309">Indexers (Indeksatory)</span><span class="sxs-lookup"><span data-stu-id="7ffdf-309">Indexers</span></span>

<span data-ttu-id="7ffdf-310">*Indeksator* jest elementem członkowskim, który umożliwia obiekty do indeksowania w taki sam sposób jak tablicy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="7ffdf-311">Indeksator jest zadeklarowany jako właściwość, z `this` tą różnicą, że po nazwie `[` `]`elementu członkowskiego następuje lista parametrów zapisana między ogranicznikami i .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-311">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="7ffdf-312">Parametry są dostępne w akcesor(-ach) indeksatora.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="7ffdf-313">Podobnie jak właściwości indeksatory mogą być odczytu i zapisu, tylko do odczytu i tylko do zapisu, a akcesor (s) indeksatora może być wirtualny.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="7ffdf-314">Klasa `MyList<T>` deklaruje jeden indeksator odczytu i `int` zapisu, który przyjmuje parametr.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="7ffdf-315">Indeksator umożliwia indeksowanie `MyList<T>` wystąpień `int` z wartościami.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="7ffdf-316">Przykład:</span><span class="sxs-lookup"><span data-stu-id="7ffdf-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="7ffdf-317">Indeksatory mogą być przeciążone, co oznacza, że klasa może zadeklarować wiele indeksatorów, o ile różnią się liczby lub typów ich parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="7ffdf-318">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="7ffdf-318">Events</span></span>

<span data-ttu-id="7ffdf-319">*Zdarzenie* jest elementem członkowskim, który umożliwia klasy lub obiektu do dostarczania powiadomień.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="7ffdf-320">Zdarzenie jest zadeklarowane jako pole, z tą różnicą, że deklaracja zawiera słowo kluczowe zdarzenia, a typ musi być typem delegata.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="7ffdf-321">W ramach klasy, która deklaruje element członkowski zdarzenia, zdarzenie zachowuje się jak pole typu delegata (pod warunkiem, że zdarzenie nie jest abstrakcyjne i nie deklaruje akcesorów).</span><span class="sxs-lookup"><span data-stu-id="7ffdf-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="7ffdf-322">Pole przechowuje odwołanie do pełnomocnika, który reprezentuje programy obsługi zdarzeń, które zostały dodane do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="7ffdf-323">Jeśli nie występują żadne programy obsługi `null`zdarzeń, pole to jest .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="7ffdf-324">Klasa `MyList<T>` deklaruje jeden element członkowski zdarzenia o nazwie `Changed`, co wskazuje, że nowy element został dodany do listy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="7ffdf-325">Changed Zdarzenie jest wywoływane przez metodę wirtualną, `OnChanged` `null` która najpierw sprawdza, czy zdarzenie jest (co oznacza, że nie są dostępne programy obsługi).</span><span class="sxs-lookup"><span data-stu-id="7ffdf-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="7ffdf-326">Pojęcie wywoływania zdarzenia jest dokładnie równoważne wywołanie delegata reprezentowanego przez zdarzenie — w związku z tym nie ma żadnych specjalnych konstrukcji języka do wywoływania zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="7ffdf-327">Klienci reagują na zdarzenia za pomocą *programów obsługi zdarzeń*.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="7ffdf-328">Programy obsługi zdarzeń `+=` są dołączone za `-=` pomocą operatora i usunięte za pomocą operatora.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="7ffdf-329">Poniższy przykład dołącza program obsługi `Changed` zdarzeń `MyList<string>`do zdarzenia .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="7ffdf-330">W przypadku zaawansowanych scenariuszy, w których kontrola podstawowego magazynu zdarzenia `add` jest `remove` pożądane, deklaracja zdarzenia `set` może jawnie zapewnić i akcesorów, które są podobne do akcesora właściwości.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="7ffdf-331">Operatory</span><span class="sxs-lookup"><span data-stu-id="7ffdf-331">Operators</span></span>

<span data-ttu-id="7ffdf-332">*Operator* jest elementem członkowskim, który definiuje znaczenie stosowania określonego operatora wyrażenia do wystąpień klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="7ffdf-333">Można zdefiniować trzy rodzaje operatorów: operatory nieukładane, operatory binarne i operatory konwersji.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="7ffdf-334">Wszystkie podmioty gospodarcze `public` `static`muszą być zadeklarowane jako i .</span><span class="sxs-lookup"><span data-stu-id="7ffdf-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="7ffdf-335">Klasa `MyList<T>` deklaruje dwa operatory, `operator ==` a `operator !=`tym samym nadaje nowe znaczenie `MyList` wyrażeń, które stosują te operatory do wystąpień.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="7ffdf-336">W szczególności operatory zdefiniować `MyList<T>` równość dwóch wystąpień jako porównanie każdego z zawartych obiektów przy użyciu ich Equals metody.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="7ffdf-337">W poniższym `==` przykładzie użyto `MyList<int>` operatora do porównania dwóch wystąpień.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="7ffdf-338">Pierwsze `Console.WriteLine` dane `True` wyjściowe, ponieważ dwie listy zawierają taką samą liczbę obiektów o tych samych wartościach w tej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="7ffdf-339">Gdyby `MyList<T>` nie `operator ==` `Console.WriteLine` zdefiniowano, pierwszy `False` `a` miałby dane wyjściowe, ponieważ i `b` odwoływać się do różnych `MyList<int>` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="7ffdf-340">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="7ffdf-340">Finalizers</span></span>

<span data-ttu-id="7ffdf-341">*Finalizator* jest elementem członkowskim, który implementuje akcje wymagane do sfinalizowania wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="7ffdf-342">Finalizatory nie mogą mieć parametrów, nie mogą mieć modyfikatorów ułatwień dostępu i nie można ich wywołać jawnie.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-342">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="7ffdf-343">Finalizator dla wystąpienia jest wywoływany automatycznie podczas wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="7ffdf-344">Moduł zbierający elementy bezużyteczne może szeroki zakres swobody przy podejmowaniu decyzji, kiedy zbierać obiekty i uruchomić finalizatorów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="7ffdf-345">W szczególności czas wywołań finalizatora nie jest deterministyczny i finalizatorów mogą być wykonywane w dowolnym wątku.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-345">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="7ffdf-346">Z tych i innych powodów klasy należy zaimplementować finalizatorów tylko wtedy, gdy nie inne rozwiązania są możliwe.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="7ffdf-347">Instrukcja `using` zapewnia lepsze podejście do niszczenia obiektów.</span><span class="sxs-lookup"><span data-stu-id="7ffdf-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="7ffdf-348">[Poprzedni](statements.md)
> [następny](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="7ffdf-348">[Previous](statements.md)
[Next](arrays.md)</span></span>
