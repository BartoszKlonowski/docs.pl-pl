---
title: Klas i obiektów w języku C# — samouczek języka C#
description: Jesteś nowym użytkownikiem C#? Przeczytaj ten przegląd klas, obiektów i dziedziczenie
ms.date: 08/10/2016
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: 1a8c34588cce21f4f4164df57aa8044074c23783
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="classes-and-objects"></a><span data-ttu-id="abfac-104">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="abfac-104">Classes and objects</span></span>

<span data-ttu-id="abfac-105">*Klasy* są najbardziej podstawowe C# dla typów.</span><span class="sxs-lookup"><span data-stu-id="abfac-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="abfac-106">Klasa jest strukturą danych, łączącą stanu (pól) i akcje (metod i innych funkcji elementów członkowskich) w pojedynczą jednostkę.</span><span class="sxs-lookup"><span data-stu-id="abfac-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="abfac-107">Klasa zawiera definicję dla tworzone dynamicznie *wystąpień* klasy, nazywany również *obiektów*.</span><span class="sxs-lookup"><span data-stu-id="abfac-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="abfac-108">Klasy obsługi *dziedziczenia* i *polimorfizm*, mechanizmów zgodnie z którymi *klas pochodnych* można rozszerzyć i dostosować ją *podstawowa klasy*.</span><span class="sxs-lookup"><span data-stu-id="abfac-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="abfac-109">Nowe klasy są tworzone za pomocą deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-109">New classes are created using class declarations.</span></span> <span data-ttu-id="abfac-110">Deklaracja klasy rozpoczyna się od nagłówek, który określa atrybuty i Modyfikatory klasy, nazwy klasy, klasy podstawowej (jeśli istnieje) i interfejsów implementowanych przez klasę.</span><span class="sxs-lookup"><span data-stu-id="abfac-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="abfac-111">Nagłówek następuje treści klasy, która składa się z listą deklaracji elementu członkowskiego, zapisane między ograniczniki `{` i `}`.</span><span class="sxs-lookup"><span data-stu-id="abfac-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="abfac-112">Poniżej przedstawiono deklaracji prostą klasę o nazwie `Point`:</span><span class="sxs-lookup"><span data-stu-id="abfac-112">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="abfac-113">Wystąpienia klas są tworzone przy użyciu `new` operatora, który przydziela pamięć dla nowego wystąpienia, wywołuje konstruktor do inicjowania wystąpienia i zwraca odwołanie do wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="abfac-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="abfac-114">Poniższe instrukcje utworzenie dwóch obiektów punktu i przechowuje odwołania do tych obiektów w dwóch zmiennych:</span><span class="sxs-lookup"><span data-stu-id="abfac-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="abfac-115">Pamięć zajmowane przez obiekt jest automatycznie odzyskana, gdy obiekt nie jest już dostępny.</span><span class="sxs-lookup"><span data-stu-id="abfac-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="abfac-116">Go nie ma potrzeby ani można jawnie deallocate obiektów w języku C#.</span><span class="sxs-lookup"><span data-stu-id="abfac-116">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="abfac-117">Elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="abfac-117">Members</span></span>

<span data-ttu-id="abfac-118">Elementy członkowskie klasy są statyczne elementy Członkowskie lub elementy członkowskie wystąpień.</span><span class="sxs-lookup"><span data-stu-id="abfac-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="abfac-119">Statyczne elementy członkowskie należą do klasy, i elementów członkowskich wystąpienia muszą należeć do obiektów (wystąpienia klasy).</span><span class="sxs-lookup"><span data-stu-id="abfac-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="abfac-120">Poniżej omówiono określonych rodzajów członków klasy może zawierać.</span><span class="sxs-lookup"><span data-stu-id="abfac-120">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="abfac-121">Stałe</span><span class="sxs-lookup"><span data-stu-id="abfac-121">Constants</span></span>
    - <span data-ttu-id="abfac-122">Wartości stałe skojarzonego z klasą</span><span class="sxs-lookup"><span data-stu-id="abfac-122">Constant values associated with the class</span></span>
* <span data-ttu-id="abfac-123">Pola</span><span class="sxs-lookup"><span data-stu-id="abfac-123">Fields</span></span>
    - <span data-ttu-id="abfac-124">Zmienne klasy</span><span class="sxs-lookup"><span data-stu-id="abfac-124">Variables of the class</span></span>
* <span data-ttu-id="abfac-125">Metody</span><span class="sxs-lookup"><span data-stu-id="abfac-125">Methods</span></span>
    - <span data-ttu-id="abfac-126">Obliczenia i akcje, które mogą być wykonywane przez klasę</span><span class="sxs-lookup"><span data-stu-id="abfac-126">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="abfac-127">Właściwości</span><span class="sxs-lookup"><span data-stu-id="abfac-127">Properties</span></span>
    - <span data-ttu-id="abfac-128">Akcje skojarzone z odczytywanie i zapisywanie właściwości o nazwie klasy</span><span class="sxs-lookup"><span data-stu-id="abfac-128">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="abfac-129">Indeksatory</span><span class="sxs-lookup"><span data-stu-id="abfac-129">Indexers</span></span>
    - <span data-ttu-id="abfac-130">Akcje skojarzone z indeksowania wystąpień klasy, jak tablicy</span><span class="sxs-lookup"><span data-stu-id="abfac-130">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="abfac-131">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="abfac-131">Events</span></span>
    - <span data-ttu-id="abfac-132">Powiadomienia, które mogą być generowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="abfac-132">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="abfac-133">Operatory</span><span class="sxs-lookup"><span data-stu-id="abfac-133">Operators</span></span>
    - <span data-ttu-id="abfac-134">Konwersje i wyrażenie operatory obsługiwane przez klasę</span><span class="sxs-lookup"><span data-stu-id="abfac-134">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="abfac-135">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="abfac-135">Constructors</span></span>
    - <span data-ttu-id="abfac-136">Akcje wymagane do zainicjowania wystąpienia klasy lub samej klasy</span><span class="sxs-lookup"><span data-stu-id="abfac-136">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="abfac-137">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="abfac-137">Finalizers</span></span>
    - <span data-ttu-id="abfac-138">Akcje do wykonania przed wystąpień klasy trwale zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="abfac-138">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="abfac-139">Types</span><span class="sxs-lookup"><span data-stu-id="abfac-139">Types</span></span>
    - <span data-ttu-id="abfac-140">Zagnieżdżone typy zadeklarowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="abfac-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="abfac-141">Ułatwienia dostępu</span><span class="sxs-lookup"><span data-stu-id="abfac-141">Accessibility</span></span>

<span data-ttu-id="abfac-142">Każdy element członkowski klasy ma skojarzone ułatwień dostępu, który kontroluje regionów tekst programu, które są w stanie uzyskać dostępu do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="abfac-142">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="abfac-143">Istnieje pięć możliwych form ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="abfac-143">There are five possible forms of accessibility.</span></span> <span data-ttu-id="abfac-144">Te są podsumowywane poniżej.</span><span class="sxs-lookup"><span data-stu-id="abfac-144">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="abfac-145">Nie ograniczając dostęp</span><span class="sxs-lookup"><span data-stu-id="abfac-145">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="abfac-146">Dostęp ograniczony do tej klasy lub klas pochodzących z tej klasy</span><span class="sxs-lookup"><span data-stu-id="abfac-146">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="abfac-147">Dostęp ograniczony do bieżącego zestawu (.exe, .dll itp.)</span><span class="sxs-lookup"><span data-stu-id="abfac-147">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="abfac-148">Dostęp ograniczony do zawierający klasy lub klas pochodnych klasa zawierająca</span><span class="sxs-lookup"><span data-stu-id="abfac-148">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="abfac-149">Dostęp ograniczony do tej klasy</span><span class="sxs-lookup"><span data-stu-id="abfac-149">Access limited to this class</span></span>
* `private protected`
    - <span data-ttu-id="abfac-150">Dostęp ograniczony do zawierający klasy lub klas pochodnych typu zawierającego w ramach tego samego zestawu</span><span class="sxs-lookup"><span data-stu-id="abfac-150">Access limited to the containing class or classes derived from the containing type within the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="abfac-151">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="abfac-151">Type parameters</span></span>

<span data-ttu-id="abfac-152">Definicję klasy mogą określać zestaw parametrów typu przez po nazwie klasy z nawiasy otaczającej listę nazw parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="abfac-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="abfac-153">Następnie można użyć parametrów typu w treści deklaracji klasy można zdefiniować elementów członkowskich klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="abfac-154">W poniższym przykładzie parametrów typu `Pair` są `TFirst` i `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="abfac-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="abfac-155">Nosi nazwę typu klasy, który jest zadeklarowana, aby wykonać parametrów typu *typu klasy ogólnej*.</span><span class="sxs-lookup"><span data-stu-id="abfac-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="abfac-156">Można też ogólnego typu struktury, interfejsu i delegata.</span><span class="sxs-lookup"><span data-stu-id="abfac-156">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="abfac-157">W przypadku klasy ogólnej należy podać argumentów typu dla każdego z parametrów typu:</span><span class="sxs-lookup"><span data-stu-id="abfac-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="abfac-158">Typem ogólnym z argumentami typu pod warunkiem, takie jak `Pair<int,string>` powyżej, jest nazywany *skonstruować typu*.</span><span class="sxs-lookup"><span data-stu-id="abfac-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="abfac-159">Klas podstawowych</span><span class="sxs-lookup"><span data-stu-id="abfac-159">Base classes</span></span>

<span data-ttu-id="abfac-160">Deklaracja klasy mogą określać klasy podstawowej przez następujące parametry nazwę i typ klasy z dwukropkiem i nazwy klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="abfac-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="abfac-161">Pominięcie specyfikacji klasa podstawowa jest taka sama jak pochodny typ `object`.</span><span class="sxs-lookup"><span data-stu-id="abfac-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="abfac-162">W poniższym przykładzie klasa podstawowa `Point3D` jest `Point`, a klasa podstawowa `Point` jest `object`:</span><span class="sxs-lookup"><span data-stu-id="abfac-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="abfac-163">Klasa dziedziczy elementów członkowskich klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="abfac-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="abfac-164">Dziedziczenie oznacza, że klasa niejawnie zawiera wszystkie elementy członkowskie w swojej klasie podstawowej, z wyjątkiem wystąpienie i konstruktorów statycznych i finalizatory klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="abfac-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="abfac-165">Klasy pochodne mogą dodawać nowych członków do tych, które dziedziczy, ale nie można usunąć definicji dziedziczonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="abfac-165">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="abfac-166">W poprzednim przykładzie `Point3D` dziedziczy `x` i `y` pola z `Point`, a następnie co `Point3D` wystąpienie zawiera trzy pola `x`, `y`, i `z`.</span><span class="sxs-lookup"><span data-stu-id="abfac-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="abfac-167">Niejawna konwersja istnieje z typem klasy do dowolnego z jego typów klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="abfac-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="abfac-168">W związku z tym zmiennej typu klasy można odwoływać się wystąpienia tej klasy lub wystąpienia klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="abfac-168">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="abfac-169">Na przykład, dla danego poprzedniej deklaracji klasy, zmiennej typu `Point` może odwoływać się albo `Point` lub `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="abfac-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="abfac-170">Pola</span><span class="sxs-lookup"><span data-stu-id="abfac-170">Fields</span></span>

<span data-ttu-id="abfac-171">A *pola* jest zmienna, która jest skojarzona z klasy lub wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="abfac-172">Zadeklarowana z modyfikatorem statycznego pola definiuje pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="abfac-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="abfac-173">Statyczne pole identyfikuje dokładnie jedną lokalizację magazynu.</span><span class="sxs-lookup"><span data-stu-id="abfac-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="abfac-174">Niezależnie od tego, jak wiele wystąpień klasy są tworzone jest tylko kiedykolwiek jedną kopię pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="abfac-174">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="abfac-175">Pole zadeklarowana bez modyfikator statyczny definiuje pole wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="abfac-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="abfac-176">Każde wystąpienie klasy zawiera osobną kopię wszystkie pola wystąpienia tej klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="abfac-177">W poniższym przykładzie, każde wystąpienie `Color` klasa ma osobną kopię `r`, `g`, i `b` wystąpienia pól, ale istnieje tylko jedna kopia `Black`, `White`, `Red`, `Green`, i `Blue` pola statyczne:</span><span class="sxs-lookup"><span data-stu-id="abfac-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="abfac-178">Jak pokazano w poprzednim przykładzie *pola tylko do odczytu* mogą być deklarowane z `readonly` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="abfac-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="abfac-179">Przypisanie do `readonly` pola mogą występować tylko jako część deklaracja pola lub w Konstruktorze w tej samej klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="abfac-180">Metody</span><span class="sxs-lookup"><span data-stu-id="abfac-180">Methods</span></span>

<span data-ttu-id="abfac-181">A *metoda* jest elementem członkowskim, który implementuje obliczenia lub akcji, które mogą być wykonywane przez obiekt lub klasa.</span><span class="sxs-lookup"><span data-stu-id="abfac-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="abfac-182">*Metody statyczne* są dostępne za pośrednictwem klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="abfac-183">*Wystąpienie metody* są dostępne za pośrednictwem wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="abfac-184">Metody może mieć listy *parametry*, które reprezentują wartości lub odwołań do zmiennych przekazywany do metody i *zwracany typ*, który określa typ wartości obliczana i zwracany przez metodę.</span><span class="sxs-lookup"><span data-stu-id="abfac-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="abfac-185">Zwracany typ metody jest `void` Jeśli nie zwraca wartości.</span><span class="sxs-lookup"><span data-stu-id="abfac-185">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="abfac-186">Jak typy metody może mieć zestaw parametrów typu, dla których należy określić argumenty typu podczas wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="abfac-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="abfac-187">W przeciwieństwie do typów argumentów typu często można wywnioskować na podstawie argumenty wywołania metody i nie można jawnie konieczne.</span><span class="sxs-lookup"><span data-stu-id="abfac-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="abfac-188">*Podpisu* metody muszą być unikatowe w klasie, w którym zadeklarowany jest metoda.</span><span class="sxs-lookup"><span data-stu-id="abfac-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="abfac-189">Podpis metody składa się z nazwy metody, liczba parametrów typu i liczbę, Modyfikatory i typy parametrów.</span><span class="sxs-lookup"><span data-stu-id="abfac-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="abfac-190">Podpis metody nie ma zwracanego typu.</span><span class="sxs-lookup"><span data-stu-id="abfac-190">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="abfac-191">Parametry</span><span class="sxs-lookup"><span data-stu-id="abfac-191">Parameters</span></span>

<span data-ttu-id="abfac-192">Parametry są używane do przekazania wartości lub zmiennej odwołania do metody.</span><span class="sxs-lookup"><span data-stu-id="abfac-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="abfac-193">Parametry metody get swoje rzeczywiste wartości z *argumenty* podano po wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="abfac-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="abfac-194">Istnieją cztery rodzaje parametry: wartości parametrów, parametry odwołanie parametrów wyjściowych i tablice parametrów.</span><span class="sxs-lookup"><span data-stu-id="abfac-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="abfac-195">A *wartość parametru* służy do przekazywania argumentów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="abfac-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="abfac-196">Wartość parametru odnosi się do zmiennej lokalnej, która pobiera swojej wartości początkowej w argumencie, która została przekazana dla parametru.</span><span class="sxs-lookup"><span data-stu-id="abfac-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="abfac-197">Modyfikacje parametru wartości nie wpływają na argumentu, która została przekazana dla parametru.</span><span class="sxs-lookup"><span data-stu-id="abfac-197">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="abfac-198">Wartości parametrów mogą być opcjonalne, przez określenie wartości domyślnej, dzięki czemu można pominąć odpowiednie argumenty.</span><span class="sxs-lookup"><span data-stu-id="abfac-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="abfac-199">A *odwołać się do parametru* służy do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="abfac-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="abfac-200">Argumentu przekazanego do parametru odwołania musi być zmienną z określoną wartością, a podczas wykonywania metody, parametr odwołania reprezentuje tej samej lokalizacji magazynu jako argumentu zmiennej.</span><span class="sxs-lookup"><span data-stu-id="abfac-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="abfac-201">Parametr odwołanie jest zadeklarowane ze `ref` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="abfac-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="abfac-202">W poniższym przykładzie przedstawiono użycie `ref` parametrów.</span><span class="sxs-lookup"><span data-stu-id="abfac-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="abfac-203">*Parametru wyjściowego* służy do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="abfac-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="abfac-204">Jest on podobny do parametru odwołanie, z tą różnicą, że nie wymaga jawnie przypisać wartości do argumentu dostarczane przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="abfac-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="abfac-205">Parametr wyjściowy jest zadeklarowany za pomocą `out` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="abfac-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="abfac-206">W poniższym przykładzie przedstawiono użycie `out` parametry, używając składni wprowadzono w języku C# 7.</span><span class="sxs-lookup"><span data-stu-id="abfac-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="abfac-207">A *tablicy parametrów* pozwala na zmienną liczbę argumentów, które mają być przekazane do metody.</span><span class="sxs-lookup"><span data-stu-id="abfac-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="abfac-208">Tablica parametrów jest zadeklarowany za pomocą `params` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="abfac-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="abfac-209">Ostatni parametr metody może być tablicą parametrów, a typ tablicy parametrów musi być typem tablicy jednowymiarowej.</span><span class="sxs-lookup"><span data-stu-id="abfac-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="abfac-210">Metody zapisu i WriteLine <xref:System.Console?displayProperty=nameWithType> klasy są dobrym przykładem użycia tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="abfac-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="abfac-211">Są one zgłoszone w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="abfac-211">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="abfac-212">W ramach metody, która używa tablicy parametrów tablicy parametrów zachowuje się tak samo jak regularne parametru typu tablicowego.</span><span class="sxs-lookup"><span data-stu-id="abfac-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="abfac-213">Jednak w wywołaniu metody z tablicą parametrów, istnieje możliwość przekazania jeden argument typu Tablica parametru albo dowolną liczbę argumentów typu elementu tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="abfac-213">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="abfac-214">W drugim przypadku wystąpienia tablicy jest automatycznie tworzone i zainicjować przy użyciu danego argumentów.</span><span class="sxs-lookup"><span data-stu-id="abfac-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="abfac-215">W tym przykładzie</span><span class="sxs-lookup"><span data-stu-id="abfac-215">This example</span></span>

[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="abfac-216">odpowiada to pisanie poniżej.</span><span class="sxs-lookup"><span data-stu-id="abfac-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="abfac-217">Treść metody i zmienne lokalne</span><span class="sxs-lookup"><span data-stu-id="abfac-217">Method body and local variables</span></span>

<span data-ttu-id="abfac-218">Treść metody Określa instrukcje do wykonania, gdy jest wywoływana metoda.</span><span class="sxs-lookup"><span data-stu-id="abfac-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="abfac-219">Treść metody mogą zadeklarować zmienne, które są specyficzne dla wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="abfac-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="abfac-220">Takie zmienne są nazywane *zmiennych lokalnych*.</span><span class="sxs-lookup"><span data-stu-id="abfac-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="abfac-221">Deklaracji zmiennej lokalnej Określa nazwę typu, nazwę zmiennej, prawdopodobnie wartość początkową.</span><span class="sxs-lookup"><span data-stu-id="abfac-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="abfac-222">Poniższy przykład deklaruje zmienną lokalną `i` o początkowej wartości zero i zmiennej lokalnej `j` bez wartości początkowej.</span><span class="sxs-lookup"><span data-stu-id="abfac-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="abfac-223">C# wymaga zmiennej lokalnej jako *ostatecznie przypisane* przed jego wartość.</span><span class="sxs-lookup"><span data-stu-id="abfac-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="abfac-224">Na przykład jeśli deklaracja poprzedniego `i` nie zawiera wartości początkowej, kompilator rozpoczną przesyłanie raportów wystąpił błąd dla kolejnych użycia `i` ponieważ `i` nie będzie można zdecydowanie przypisane w tych punktach w programie.</span><span class="sxs-lookup"><span data-stu-id="abfac-224">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="abfac-225">Można użyć metody `return` instrukcje, aby zwrócić kontrolkę do swojego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="abfac-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="abfac-226">W metodach zwracających `void`, `return` instrukcji nie można określić wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="abfac-226">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="abfac-227">W metodach zwracających inny niż void `return` instrukcje musi zawierać wyrażenie, które oblicza wartość zwracaną.</span><span class="sxs-lookup"><span data-stu-id="abfac-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="abfac-228">Metody statyczne i wystąpienia</span><span class="sxs-lookup"><span data-stu-id="abfac-228">Static and instance methods</span></span>

<span data-ttu-id="abfac-229">Metoda zadeklarowana z modyfikatorem statycznego jest *metody statycznej*.</span><span class="sxs-lookup"><span data-stu-id="abfac-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="abfac-230">Metody statycznej nie będzie działać na określonym wystąpieniu i tylko bezpośrednio dostęp do statycznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="abfac-230">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="abfac-231">Metody zadeklarowane bez jest modyfikator statyczny *metody wystąpienia*.</span><span class="sxs-lookup"><span data-stu-id="abfac-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="abfac-232">Metody wystąpienia działa na określonym wystąpieniu i można dostępu obu statyczna i wystąpienia elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="abfac-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="abfac-233">Wystąpienie, w którym wywołano metodę wystąpienia są jawnie dostępne `this`.</span><span class="sxs-lookup"><span data-stu-id="abfac-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="abfac-234">Błąd w odwołaniu do `this` w metodzie statycznej.</span><span class="sxs-lookup"><span data-stu-id="abfac-234">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="abfac-235">Następujące `Entity` klasa ma obu statyczna i wystąpienia elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="abfac-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="abfac-236">Każdy `Entity` wystąpienie zawiera numery seryjne (i prawdopodobnie niektóre inne informacje, które nie są wyświetlane tutaj).</span><span class="sxs-lookup"><span data-stu-id="abfac-236">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="abfac-237">`Entity` — Konstruktor (czyli takie jak metody wystąpienia) inicjuje nowe wystąpienie z najbliższy dostępny numer seryjny.</span><span class="sxs-lookup"><span data-stu-id="abfac-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="abfac-238">Ponieważ Konstruktor elementu członkowskiego wystąpienia, jest dozwolony dostęp zarówno do `serialNo` pole wystąpienia i `nextSerialNo` pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="abfac-238">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="abfac-239">`GetNextSerialNo` i `SetNextSerialNo` metody statyczne mogą uzyskiwać dostęp do `nextSerialNo` pole statyczne, ale będzie błąd dla nich bezpośrednio `serialNo` pole wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="abfac-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="abfac-240">Poniższy przykład przedstawia użycie klasy jednostka.</span><span class="sxs-lookup"><span data-stu-id="abfac-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="abfac-241">Należy pamiętać, że `SetNextSerialNo` i `GetNextSerialNo` metody statyczne są wywoływane w klasie, podczas gdy `GetSerialNo` wywołaniu metody wystąpienia na wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-241">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="abfac-242">Wirtualne, zastępowanie i metody abstrakcyjne</span><span class="sxs-lookup"><span data-stu-id="abfac-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="abfac-243">Po deklaracji metody wystąpienia obejmuje `virtual` , modyfikator metody jest określany jako *metody wirtualnej*.</span><span class="sxs-lookup"><span data-stu-id="abfac-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="abfac-244">Nie modyfikatora wirtualnego jest obecny, metoda jest określane jako *Niewirtualna metoda*.</span><span class="sxs-lookup"><span data-stu-id="abfac-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="abfac-245">Po wywołaniu metody wirtualnej *typu run-time* wystąpienia, dla którego tego wywołania ma miejsce określa rzeczywista implementacja metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="abfac-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="abfac-246">W wywołaniu metody niewirtualne *typu kompilacji* wystąpienia jest czynnikiem decydującym.</span><span class="sxs-lookup"><span data-stu-id="abfac-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="abfac-247">Może być metodą wirtualną *przesłonięcia* w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="abfac-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="abfac-248">Po deklaracji metody wystąpienia zawiera modyfikator zastąpienie, metoda zastępuje dziedziczonej metody wirtualnej o tej samej sygnaturze.</span><span class="sxs-lookup"><span data-stu-id="abfac-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="abfac-249">Deklaracja metody wirtualnej wprowadza nową metodę, deklaracji metody zastąpienie specjalizuje się istniejących dziedziczonej metody wirtualnej dostarczając nową implementacją tej metody.</span><span class="sxs-lookup"><span data-stu-id="abfac-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="abfac-250">*Metody abstrakcyjnej* jest metodą wirtualną z żadnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="abfac-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="abfac-251">Metoda abstrakcyjna jest zadeklarowany jako abstrakcyjny modyfikatorem i jest dozwolone tylko w klasie, który również został zadeklarowany jako abstrakcyjny.</span><span class="sxs-lookup"><span data-stu-id="abfac-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="abfac-252">Metoda abstrakcyjna musi zostać zastąpiona w każdej pochodnej klasy nieabstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="abfac-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="abfac-253">Poniższy przykład deklaruje klasę abstrakcyjną `Expression`, który reprezentuje węzeł drzewa wyrażenia i trzy pochodzi z klasy, `Constant`, `VariableReference`, i `Operation`, który implementuje węzły drzewa wyrażenia stałych i zmiennych odwołania, a operacje arytmetyczne.</span><span class="sxs-lookup"><span data-stu-id="abfac-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="abfac-254">(To jest podobny, ale nie należy mylić z typami wyrażenia drzewa).</span><span class="sxs-lookup"><span data-stu-id="abfac-254">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="abfac-255">Poprzednie cztery klasy może służyć do modelu w wyrażeniach arytmetycznych.</span><span class="sxs-lookup"><span data-stu-id="abfac-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="abfac-256">Na przykład za pomocą wystąpień tych klas, wyrażenie `x + 3` można przedstawić w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="abfac-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="abfac-257">`Evaluate` Metody `Expression` wystąpienia jest wywoływane w celu oceny danego wyrażenia i tworzy `double` wartość.</span><span class="sxs-lookup"><span data-stu-id="abfac-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="abfac-258">Metoda korzysta z `Dictionary` argumentu, który zawiera wartości (jako wartości wpisy) i nazwy zmiennych (jako klucze wpisy).</span><span class="sxs-lookup"><span data-stu-id="abfac-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="abfac-259">Ponieważ `Evaluate` jest metoda abstrakcyjna, pochodzi z klasy nieabstrakcyjnej `Expression` przesłonięcie `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="abfac-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="abfac-260">A `Constant`w implementacji `Evaluate` po prostu zwraca przechowywanych stała.</span><span class="sxs-lookup"><span data-stu-id="abfac-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="abfac-261">A `VariableReference`na implementacji wyszukuje nazwę zmiennej w słowniku i zwraca wartość wynikową.</span><span class="sxs-lookup"><span data-stu-id="abfac-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="abfac-262">`Operation`w implementacji najpierw ocenia lewy i prawy argumentów operacji (wywołując rekursywnie ich `Evaluate` metody), a następnie wykonuje danej operacji arytmetycznej.</span><span class="sxs-lookup"><span data-stu-id="abfac-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="abfac-263">Następujące program używa `Expression` klasy można oszacować wyrażenia `x * (y + 2)` dla różnych wartości `x` i `y`.</span><span class="sxs-lookup"><span data-stu-id="abfac-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="abfac-264">Przeciążenie metody</span><span class="sxs-lookup"><span data-stu-id="abfac-264">Method overloading</span></span>

<span data-ttu-id="abfac-265">Metoda *przeładowanie* zezwala na wiele metod w tej samej klasy mają taką samą nazwę jak długo mają unikatowe sygnatury.</span><span class="sxs-lookup"><span data-stu-id="abfac-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="abfac-266">W przypadku kompilowania kodu wywołanie przeciążonej metody, kompilator używa *przeciążenia* ustalenie określonej metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="abfac-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="abfac-267">Rozpoznanie przeciążenia znajduje jedną metodę czy najlepiej do argumentów nie pasuje lub zgłasza błąd, jeśli można znaleźć nie pojedynczego najlepsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="abfac-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="abfac-268">W poniższym przykładzie przedstawiono Rozpoznanie przeciążenia obowiązywać.</span><span class="sxs-lookup"><span data-stu-id="abfac-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="abfac-269">Komentarz dla każdego wywołania w `Main` — metoda zawiera, którego metoda faktycznie jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="abfac-269">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="abfac-270">Jak to przedstawiono w przykładzie, zawsze można wybrać konkretnej metody przez jawne rzutowanie argumentów do typów parametru dokładne i/lub jawne określenie argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="abfac-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="abfac-271">O innych elementach członkowskich — funkcja</span><span class="sxs-lookup"><span data-stu-id="abfac-271">Other function members</span></span>

<span data-ttu-id="abfac-272">Elementy członkowskie, które zawierają kod wykonywalny są nazywane zbiorczo *funkcji elementów członkowskich* klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="abfac-273">Poprzedniej sekcji opisano metody, które są podstawowym typem funkcji elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="abfac-273">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="abfac-274">W tej sekcji opisano inne rodzaje elementy funkcja obsługiwane w języku C#: konstruktorów, właściwości, indeksatorów, zdarzenia, Operatorzy i finalizatory.</span><span class="sxs-lookup"><span data-stu-id="abfac-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="abfac-275">Oto ogólny klasy o nazwie listy<T>, który implementuje growable listy obiektów.</span><span class="sxs-lookup"><span data-stu-id="abfac-275">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="abfac-276">Klasa zawiera kilka przykładów typowych rodzajów członków funkcji.</span><span class="sxs-lookup"><span data-stu-id="abfac-276">The class contains several examples of the most common kinds of function members.</span></span>

[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="abfac-277">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="abfac-277">Constructors</span></span>

<span data-ttu-id="abfac-278">C# obsługuje zarówno wystąpienia i konstruktorów statycznych.</span><span class="sxs-lookup"><span data-stu-id="abfac-278">C# supports both instance and static constructors.</span></span> <span data-ttu-id="abfac-279">*Konstruktora wystąpienia* jest element członkowski, który implementuje czynności wymagane do zainicjowania wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-279">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="abfac-280">A *Konstruktor statyczny* jest element członkowski, który implementuje czynności wymagane do zainicjowania samej klasy po pierwszym załadowaniu.</span><span class="sxs-lookup"><span data-stu-id="abfac-280">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="abfac-281">Konstruktor jest zadeklarowana jak metody z nie zwracany typ i taką samą nazwę jak klasa zawierająca.</span><span class="sxs-lookup"><span data-stu-id="abfac-281">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="abfac-282">Jeśli w deklaracji konstruktora zawiera modyfikator statyczny, deklaruje Konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="abfac-282">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="abfac-283">W przeciwnym razie deklaruje być konstruktorem wystąpień.</span><span class="sxs-lookup"><span data-stu-id="abfac-283">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="abfac-284">Konstruktory wystąpień może zostać przeciążony i może mieć następujące parametry opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="abfac-284">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="abfac-285">Na przykład `List<T>` klasy deklaruje dwa konstruktory wystąpień z żadnych parametrów i jedną, która przyjmuje `int` parametru.</span><span class="sxs-lookup"><span data-stu-id="abfac-285">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="abfac-286">Konstruktory wystąpień są wywoływane przy użyciu `new` operatora.</span><span class="sxs-lookup"><span data-stu-id="abfac-286">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="abfac-287">Poniższe instrukcje przydzielić dwie `List<string>` wystąpienia przy użyciu konstruktora `List` klasy z włączonymi i wyłączonymi opcjonalny argument.</span><span class="sxs-lookup"><span data-stu-id="abfac-287">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="abfac-288">W przeciwieństwie do innych członków konstruktory wystąpień nie są dziedziczone, a klasa nie ma konstruktorów wystąpienia innych niż rzeczywiście zgłoszonymi w klasie.</span><span class="sxs-lookup"><span data-stu-id="abfac-288">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="abfac-289">Jeśli żaden konstruktor wystąpienia nie jest dostarczony dla klasy, następnie pustą bez parametrów jest teraz udostępniana automatycznie.</span><span class="sxs-lookup"><span data-stu-id="abfac-289">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="abfac-290">Właściwości</span><span class="sxs-lookup"><span data-stu-id="abfac-290">Properties</span></span>

<span data-ttu-id="abfac-291">*Właściwości* są stanowi naturalne rozszerzenie pola.</span><span class="sxs-lookup"><span data-stu-id="abfac-291">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="abfac-292">Elementy członkowskie o związane z nimi typy są nazwanych, i składnia do uzyskiwania dostępu do pola i właściwości jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="abfac-292">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="abfac-293">Jednak w przeciwieństwie do pola, właściwości oznacza lokalizacji przechowywania.</span><span class="sxs-lookup"><span data-stu-id="abfac-293">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="abfac-294">Właściwości mają *akcesorów* określające instrukcje, które ma być wykonywana w przypadku ich wartości są odczytywane lub zapisywane.</span><span class="sxs-lookup"><span data-stu-id="abfac-294">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="abfac-295">Właściwość zadeklarowana takich jak pole, z wyjątkiem, że deklaracja kończy metody dostępu get i/lub metody dostępu set zapisywane między ograniczniki `{` i `}` zamiast kończy się średnikiem.</span><span class="sxs-lookup"><span data-stu-id="abfac-295">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="abfac-296">Właściwość, która ma zarówno metodę dostępu get i SET jest *odczytu i zapisu właściwości*, właściwości, która ma metodę dostępu get jest *właściwości tylko do odczytu*, i właściwości, która zawiera tylko metodą dostępu set jest *właściwości tylko do zapisu*.</span><span class="sxs-lookup"><span data-stu-id="abfac-296">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="abfac-297">Metody dostępu get odnosi się do metody bez parametrów, zwracając wartość typu właściwości.</span><span class="sxs-lookup"><span data-stu-id="abfac-297">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="abfac-298">Z wyjątkiem jako elementem docelowym przypisania, gdy to wyrażenie odwołuje się do właściwości metody dostępu get właściwości jest wywoływane w celu obliczenia wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="abfac-298">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="abfac-299">Metodą dostępu set odnosi się do metody z pojedynczym parametrem o nazwie wartość i nie zwracanego typu.</span><span class="sxs-lookup"><span data-stu-id="abfac-299">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="abfac-300">Gdy właściwość odwołuje się do jako elementem docelowym przypisania lub argument operacji ++ lub--, metody dostępu set jest wywoływana z argumentem, który udostępnia nową wartość.</span><span class="sxs-lookup"><span data-stu-id="abfac-300">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="abfac-301">`List<T>` Klasy deklaruje dwie właściwości Liczba i pojemności, które są tylko do odczytu i odczytu i zapisu, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="abfac-301">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="abfac-302">Oto przykład korzystanie z tych właściwości.</span><span class="sxs-lookup"><span data-stu-id="abfac-302">The following is an example of use of these properties.</span></span>

[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="abfac-303">Podobnie jak pól i metod, C# obsługuje zarówno właściwości wystąpienia i właściwości statycznej.</span><span class="sxs-lookup"><span data-stu-id="abfac-303">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="abfac-304">Właściwości statyczne są deklarowane jako statyczne modyfikatorem, a właściwości obiektu są deklarowane jako bez niego.</span><span class="sxs-lookup"><span data-stu-id="abfac-304">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="abfac-305">Accessor(s) właściwości mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="abfac-305">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="abfac-306">Po deklaracji właściwości obejmuje `virtual`, `abstract`, lub `override` , modyfikator dotyczy ona accessor(s) właściwości.</span><span class="sxs-lookup"><span data-stu-id="abfac-306">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="abfac-307">Indeksatory</span><span class="sxs-lookup"><span data-stu-id="abfac-307">Indexers</span></span>

<span data-ttu-id="abfac-308">*Indeksatora* jest element członkowski, który umożliwia obiektów do zindeksowania w taki sam sposób jak tablicy.</span><span class="sxs-lookup"><span data-stu-id="abfac-308">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="abfac-309">Indeksator zadeklarowano jak właściwości z wyjątkiem, że nazwa elementu członkowskiego jest to następuje listy parametrów zapisywane między ograniczniki `[` i `]`.</span><span class="sxs-lookup"><span data-stu-id="abfac-309">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="abfac-310">Parametry są dostępne w accessor(s) indeksatora.</span><span class="sxs-lookup"><span data-stu-id="abfac-310">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="abfac-311">Podobnie jak właściwości, indeksatorów mogą być do odczytu / zapisu, tylko do odczytu i tylko do zapisu, a accessor(s) indeksatora mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="abfac-311">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="abfac-312">`List` Klasy deklaruje pojedynczego indeksatora odczytu i zapisu, który przyjmuje `int` parametru.</span><span class="sxs-lookup"><span data-stu-id="abfac-312">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="abfac-313">Indeksator umożliwia indeksu `List` wystąpień z `int` wartości.</span><span class="sxs-lookup"><span data-stu-id="abfac-313">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="abfac-314">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="abfac-314">For example:</span></span>

[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="abfac-315">Można przeciążać indeksatorów, co oznacza klasy można zadeklarować indeksatorów wielu tak długo, jak liczby lub typów ich parametry są różne.</span><span class="sxs-lookup"><span data-stu-id="abfac-315">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="abfac-316">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="abfac-316">Events</span></span>

<span data-ttu-id="abfac-317">*Zdarzeń* jest element członkowski, który umożliwia klasy lub obiekt, aby zapewnić powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="abfac-317">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="abfac-318">Zdarzenie zadeklarowano takich jak pole z tą różnicą, że deklaracja zawiera słowo kluczowe zdarzeń i typ musi być typem obiektu delegowanego.</span><span class="sxs-lookup"><span data-stu-id="abfac-318">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="abfac-319">W obrębie klasy, który deklaruje element członkowski zdarzeń zdarzenie zachowuje się jak pole typu delegata (zakładając, że zdarzenie nie jest abstrakcyjna i nie deklaruje metody dostępu).</span><span class="sxs-lookup"><span data-stu-id="abfac-319">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="abfac-320">Pole zawiera odwołanie do delegata, który reprezentuje obsługi zdarzeń, które zostały dodane do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="abfac-320">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="abfac-321">Jeśli istnieją nie obsługi zdarzeń, to pole jest `null`.</span><span class="sxs-lookup"><span data-stu-id="abfac-321">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="abfac-322">`List<T>` Klasy deklaruje element członkowski pojedyncze zdarzenie o nazwie `Changed`, co oznacza, że dodano nowy element do listy.</span><span class="sxs-lookup"><span data-stu-id="abfac-322">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="abfac-323">Zmienione zdarzenie zostanie wywołane przez `OnChanged` metody wirtualnej, która najpierw sprawdza, czy zdarzenie `null` (to znaczy czy nie obsługi znajdują się).</span><span class="sxs-lookup"><span data-stu-id="abfac-323">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="abfac-324">Pojęcia wywołaniem zdarzenia jest dokładnie odpowiednikiem wywołania delegata reprezentowany przez zdarzenie, w związku z tym nie istnieją żadne specjalne języka konstrukcje wywoływanie zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="abfac-324">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="abfac-325">Klienci reagowania na zdarzenia za pośrednictwem *procedury obsługi zdarzeń*.</span><span class="sxs-lookup"><span data-stu-id="abfac-325">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="abfac-326">Programy obsługi zdarzeń są dołączone przy użyciu `+=` operatora i usunięty przy użyciu `-=` operatora.</span><span class="sxs-lookup"><span data-stu-id="abfac-326">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="abfac-327">Poniższy przykład dołącza program obsługi zdarzeń do `Changed` zdarzenie `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="abfac-327">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="abfac-328">Dla zaawansowanych scenariuszy, w których formant powiązany magazyn zdarzenia jest potrzebne, można jawnie Podaj deklaracji zdarzenia `add` i `remove` metod dostępu, które są nieco podobne do `set` metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="abfac-328">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="abfac-329">Operatory</span><span class="sxs-lookup"><span data-stu-id="abfac-329">Operators</span></span>

<span data-ttu-id="abfac-330">*Operator* jest element członkowski, który definiuje znaczenie zastosowanie operatora określonego wyrażenia do wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-330">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="abfac-331">Można zdefiniować trzy rodzaje operatory: jednoargumentowe operatory operatorów binarnych i operatory konwersji.</span><span class="sxs-lookup"><span data-stu-id="abfac-331">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="abfac-332">Wszystkie operatory musi być zadeklarowany jako `public` i `static`.</span><span class="sxs-lookup"><span data-stu-id="abfac-332">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="abfac-333">`List<T>` Klasy deklaruje dwa operatory `operator ==` i `operator !=`i w związku z tym udostępnia nowe znaczenie wyrażeń, które są stosowane te operatorom `List` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="abfac-333">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="abfac-334">W szczególności operatorów Definiowanie równości dwóch `List<T>` wystąpienia jako porównanie każdego zawarte obiekty metodami równości.</span><span class="sxs-lookup"><span data-stu-id="abfac-334">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="abfac-335">W poniższym przykładzie użyto `==` operatora, aby porównać dwa `List<int>` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="abfac-335">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="abfac-336">Pierwszy `Console.WriteLine` generuje `True` ponieważ dwie listy zawierać taką samą liczbę obiektów o tej samej wartości w tej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="abfac-336">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="abfac-337">Ma `List<T>` nie zdefiniowano `operator ==`, pierwszy `Console.WriteLine` będzie mieć output `False` ponieważ `a` i `b` odwołania różnych `List<int>` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="abfac-337">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="abfac-338">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="abfac-338">Finalizers</span></span>

<span data-ttu-id="abfac-339">A *finalizator* jest element członkowski, który implementuje czynności wymagane do zakończenia wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="abfac-339">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="abfac-340">Finalizatory nie mogą mieć parametrów, modyfikatory dostępności nie mogą jednak mieć i nie można wywołać bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="abfac-340">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="abfac-341">Finalizator dla wystąpienia jest wywoływana automatycznie podczas wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="abfac-341">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="abfac-342">Moduł zbierający elementy bezużyteczne jest dozwolone szerokości szerokości geograficznej w decydowanie o czasie zbierania obiektów i uruchom finalizatory.</span><span class="sxs-lookup"><span data-stu-id="abfac-342">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="abfac-343">Czas wywołania finalizatora nie jest deterministyczna i finalizatory mogą być wykonywane w którymkolwiek wątku.</span><span class="sxs-lookup"><span data-stu-id="abfac-343">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="abfac-344">Tych i innych przyczyn klasy należy zaimplementować finalizatory tylko wtedy, gdy żadne inne rozwiązania nie są możliwe.</span><span class="sxs-lookup"><span data-stu-id="abfac-344">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="abfac-345">`using` Instrukcji zapewnia lepszym rozwiązaniem do zniszczenia obiektu.</span><span class="sxs-lookup"><span data-stu-id="abfac-345">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="abfac-346">[Poprzednie](statements.md)
[dalej](structs.md)</span><span class="sxs-lookup"><span data-stu-id="abfac-346">[Previous](statements.md)
[Next](structs.md)</span></span>
