---
title: Bloki konstrukcyjne programów C# "
description: Dowiedz się więcej o elementach członkowskich, wyrażeniach i instrukcjach języka C#. Typy zawierają składowe, które są zapisywane. Te elementy członkowskie są kompilowane z instrukcji i wyrażeń.
ms.date: 08/06/2020
ms.openlocfilehash: de9f634db129ea2ec6f692cabb657f9fe41b2f9c
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/11/2020
ms.locfileid: "88068552"
---
# <a name="program-building-blocks"></a><span data-ttu-id="f83d3-105">Bloki konstrukcyjne programu</span><span class="sxs-lookup"><span data-stu-id="f83d3-105">Program building blocks</span></span>

<span data-ttu-id="f83d3-106">Typy opisane w poprzednim artykule są kompilowane przy użyciu następujących bloków konstrukcyjnych: [***składowych***](../programming-guide/classes-and-structs/members.md), [ ***wyrażeń***i ***instrukcji***](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="f83d3-106">The types described in the previous article are built using these building blocks: [***members***](../programming-guide/classes-and-structs/members.md), [***expressions***, and ***statements***](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="f83d3-107">Elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="f83d3-107">Members</span></span>

<span data-ttu-id="f83d3-108">Członkami elementu `class` są ***statyczne elementy członkowskie*** i ***wystąpienia***.</span><span class="sxs-lookup"><span data-stu-id="f83d3-108">The members of a `class` are either ***static members*** or ***instance members***.</span></span> <span data-ttu-id="f83d3-109">Statyczne składowe należą do klas, a elementy członkowskie wystąpienia należą do obiektów (wystąpień klas).</span><span class="sxs-lookup"><span data-stu-id="f83d3-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="f83d3-110">Poniższa lista zawiera przegląd rodzajów elementów członkowskich, które może zawierać Klasa.</span><span class="sxs-lookup"><span data-stu-id="f83d3-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="f83d3-111">**Stałe**: wartości stałe skojarzone z klasą</span><span class="sxs-lookup"><span data-stu-id="f83d3-111">**Constants**: Constant values associated with the class</span></span>
- <span data-ttu-id="f83d3-112">**Pola**: zmienne, które są skojarzone z klasą</span><span class="sxs-lookup"><span data-stu-id="f83d3-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="f83d3-113">**Metody**: akcje, które mogą być wykonywane przez klasę</span><span class="sxs-lookup"><span data-stu-id="f83d3-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="f83d3-114">**Właściwości**: akcje skojarzone z odczytem i pisaniem nazwanych właściwości klasy</span><span class="sxs-lookup"><span data-stu-id="f83d3-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="f83d3-115">**Indeksatory**: akcje skojarzone z wystąpieniami indeksowania klasy, takimi jak tablica</span><span class="sxs-lookup"><span data-stu-id="f83d3-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="f83d3-116">**Zdarzenia**: powiadomienia, które mogą być generowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="f83d3-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="f83d3-117">**Operatory**: konwersje i operatory wyrażeń obsługiwane przez klasę</span><span class="sxs-lookup"><span data-stu-id="f83d3-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="f83d3-118">**Konstruktory**: akcje wymagane do zainicjowania wystąpień klasy lub samej klasy</span><span class="sxs-lookup"><span data-stu-id="f83d3-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="f83d3-119">**Finalizatory**: akcje wykonywane przed wystąpieniem klasy są trwale odrzucone</span><span class="sxs-lookup"><span data-stu-id="f83d3-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="f83d3-120">**Typy**: typy zagnieżdżone zadeklarowane przez klasę</span><span class="sxs-lookup"><span data-stu-id="f83d3-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="f83d3-121">Ułatwienia dostępu</span><span class="sxs-lookup"><span data-stu-id="f83d3-121">Accessibility</span></span>

<span data-ttu-id="f83d3-122">Każdy element członkowski klasy ma skojarzoną dostępność, która kontroluje regiony tekstu programu, które mogą uzyskać dostęp do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="f83d3-123">Istnieje sześć możliwych form ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="f83d3-124">Modyfikatory dostępu są zestawione poniżej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="f83d3-125">`public`: Dostęp nie jest ograniczony.</span><span class="sxs-lookup"><span data-stu-id="f83d3-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="f83d3-126">`private`: Dostęp jest ograniczony do tej klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="f83d3-127">`protected`: Dostęp jest ograniczony do tej klasy lub klas pochodzących od tej klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="f83d3-128">`internal`: Dostęp jest ograniczony do bieżącego zestawu ( `.exe` lub `.dll` ).</span><span class="sxs-lookup"><span data-stu-id="f83d3-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="f83d3-129">`protected internal`: Dostęp jest ograniczony do tej klasy, klas pochodnych tej klasy lub klas w tym samym zestawie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="f83d3-130">`private protected`: Dostęp jest ograniczony do tej klasy lub klas pochodzących od tego typu w ramach tego samego zestawu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="f83d3-131">Pola</span><span class="sxs-lookup"><span data-stu-id="f83d3-131">Fields</span></span>

<span data-ttu-id="f83d3-132">*Pole* jest zmienną, która jest skojarzona z klasą lub wystąpieniem klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="f83d3-133">Pole zadeklarowane ze modyfikatorem static definiuje pole statyczne.</span><span class="sxs-lookup"><span data-stu-id="f83d3-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="f83d3-134">Pole statyczne identyfikuje dokładnie jedną lokalizację magazynu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="f83d3-135">Niezależnie od tego, ile wystąpień klasy zostało utworzonych, istnieje tylko jedna kopia pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="f83d3-136">Pole zadeklarowane bez modyfikatora static definiuje pole wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="f83d3-137">Każde wystąpienie klasy zawiera oddzielną kopię wszystkich pól wystąpienia tej klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="f83d3-138">W poniższym przykładzie każde wystąpienie `Color` klasy ma oddzielną kopię `r` `g` pól,, i `b` wystąpienia, ale istnieje tylko jedna kopia `Black` pól,, `White` `Red` , `Green` i `Blue` pola statyczne:</span><span class="sxs-lookup"><span data-stu-id="f83d3-138">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="f83d3-139">Jak pokazano w poprzednim przykładzie *pola tylko do odczytu* mogą być zadeklarowane za pomocą `readonly` modyfikatora.</span><span class="sxs-lookup"><span data-stu-id="f83d3-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="f83d3-140">Przypisanie do pola tylko do odczytu może wystąpić tylko jako część deklaracji pola lub konstruktora w tej samej klasie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="f83d3-141">Metody</span><span class="sxs-lookup"><span data-stu-id="f83d3-141">Methods</span></span>

<span data-ttu-id="f83d3-142">*Metoda* to element członkowski implementujący obliczenia lub akcję, które mogą być wykonywane przez obiekt lub klasę.</span><span class="sxs-lookup"><span data-stu-id="f83d3-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="f83d3-143">*Metody statyczne* są dostępne za pomocą klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="f83d3-144">*Metody wystąpienia* są dostępne za pomocą wystąpień klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="f83d3-145">Metody mogą mieć listę *parametrów*reprezentujących wartości lub odwołania do zmiennych, które są przenoszone do metody.</span><span class="sxs-lookup"><span data-stu-id="f83d3-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="f83d3-146">Metody mają *zwracany typ*, który określa typ wartości obliczanej i zwracanej przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f83d3-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="f83d3-147">Zwracany typ metody to `void` Jeśli nie zwraca wartości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="f83d3-148">Podobnie jak typy, metody mogą także mieć zestaw parametrów typu, dla których argumenty typu muszą być określone, gdy wywoływana jest metoda.</span><span class="sxs-lookup"><span data-stu-id="f83d3-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="f83d3-149">W przeciwieństwie do typów, argumenty typu często można wywnioskować na podstawie argumentów wywołania metody i nie muszą być jawnie określone.</span><span class="sxs-lookup"><span data-stu-id="f83d3-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="f83d3-150">*Sygnatura* metody musi być unikatowa w klasie, w której metoda jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="f83d3-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="f83d3-151">Podpis metody składa się z nazwy metody, liczby parametrów typu oraz liczby, modyfikatorów i typów jego parametrów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="f83d3-152">Sygnatura metody nie zawiera typu zwracanego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="f83d3-153">Gdy treść metody jest pojedynczym wyrażeniem, Metoda może być zdefiniowana przy użyciu formatu wyrażenia kompaktowego, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="f83d3-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="f83d3-154">Parametry</span><span class="sxs-lookup"><span data-stu-id="f83d3-154">Parameters</span></span>

<span data-ttu-id="f83d3-155">Parametry służą do przekazywania wartości lub odwołań do zmiennych do metod.</span><span class="sxs-lookup"><span data-stu-id="f83d3-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="f83d3-156">Parametry metody pobierają rzeczywiste wartości z *argumentów* , które są określone podczas wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="f83d3-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="f83d3-157">Istnieją cztery rodzaje parametrów: parametry wartości, parametry odwołania, parametry wyjściowe i tablice parametrów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="f83d3-158">*Parametr value* jest używany do przekazywania argumentów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="f83d3-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="f83d3-159">Parametr value odnosi się do zmiennej lokalnej, która pobiera jej wartość początkową z argumentu, który został przesłany dla parametru.</span><span class="sxs-lookup"><span data-stu-id="f83d3-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="f83d3-160">Modyfikacje parametru value nie wpływają na argument, który został przesłany dla parametru.</span><span class="sxs-lookup"><span data-stu-id="f83d3-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="f83d3-161">Parametry wartości mogą być opcjonalne, określając wartość domyślną, aby można było pominąć odpowiednie argumenty.</span><span class="sxs-lookup"><span data-stu-id="f83d3-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="f83d3-162">*Parametr Reference* służy do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="f83d3-163">Argument przesłany dla parametru odwołania musi być zmienną z określoną wartością.</span><span class="sxs-lookup"><span data-stu-id="f83d3-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="f83d3-164">Podczas wykonywania metody parametr Reference reprezentuje tę samą lokalizację magazynu co zmienna argumentu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="f83d3-165">Parametr odwołania jest zadeklarowany z `ref` modyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="f83d3-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="f83d3-166">W poniższym przykładzie pokazano sposób użycia `ref` parametrów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="f83d3-167">*Parametr wyjściowy* jest używany do przekazywania argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="f83d3-168">Jest on podobny do parametru Reference, z tą różnicą, że nie wymaga jawnie przypisywania wartości do argumentu dostarczonego przez wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="f83d3-169">Parametr wyjściowy jest zadeklarowany z `out` modyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="f83d3-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="f83d3-170">W poniższym przykładzie pokazano użycie `out` parametrów przy użyciu składni wprowadzonej w języku C# 7.</span><span class="sxs-lookup"><span data-stu-id="f83d3-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="f83d3-171">*Tablica parametrów* umożliwia przekazanie zmiennej liczbie argumentów do metody.</span><span class="sxs-lookup"><span data-stu-id="f83d3-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="f83d3-172">Tablica parametrów jest zadeklarowana z `params` modyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="f83d3-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="f83d3-173">Tylko ostatni parametr metody może być tablicą parametrów, a typ tablicy parametrów musi być typem tablicy jednowymiarowej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="f83d3-174">`Write`Metody i `WriteLine` <xref:System.Console?displayProperty=nameWithType> klasy są dobrymi przykładami użycia tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="f83d3-175">Są one deklarowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="f83d3-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="f83d3-176">W metodzie, która używa tablicy parametrów, tablica parametrów zachowuje się dokładnie tak jak zwykły parametr typu tablicy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="f83d3-177">Jednak w wywołaniu metody z tablicą parametrów, możliwe jest przekazanie jednego argumentu typu tablicy parametrów lub dowolnej liczby argumentów typu elementu tablicy parametrów w postaci.</span><span class="sxs-lookup"><span data-stu-id="f83d3-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="f83d3-178">W tym drugim przypadku wystąpienie tablicy jest automatycznie tworzone i inicjowane z podanym argumentami.</span><span class="sxs-lookup"><span data-stu-id="f83d3-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="f83d3-179">Ten przykład</span><span class="sxs-lookup"><span data-stu-id="f83d3-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="f83d3-180">jest równoznaczny z zapisem poniżej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="f83d3-181">Treść metody i zmienne lokalne</span><span class="sxs-lookup"><span data-stu-id="f83d3-181">Method body and local variables</span></span>

<span data-ttu-id="f83d3-182">Treść metody Określa instrukcje do wykonania, gdy metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="f83d3-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="f83d3-183">Treść metody może deklarować zmienne, które są specyficzne dla wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="f83d3-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="f83d3-184">Takie zmienne są nazywane *zmiennymi lokalnymi*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="f83d3-185">Deklaracja zmiennej lokalnej określa nazwę typu, nazwę zmiennej i prawdopodobnie wartość początkową.</span><span class="sxs-lookup"><span data-stu-id="f83d3-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="f83d3-186">Poniższy przykład deklaruje zmienną lokalną `i` z początkową wartością zero i zmienną lokalną `j` bez wartości początkowej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="f83d3-187">Język C# wymaga, aby zmienna lokalna była *przypisana ostatecznie* przed uzyskaniem jej wartości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="f83d3-188">Na przykład jeśli deklaracja poprzedniej `i` nie zawierała wartości początkowej, kompilator zgłosi błąd dla późniejszych użycia, `i` ponieważ nie `i` będzie on ostatecznie przypisany w tych punktach w programie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="f83d3-189">Metoda może użyć `return` instrukcji do zwrócenia kontroli do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="f83d3-190">W wyniku zwrócenia metody `void` `return` instrukcje nie mogą określać wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="f83d3-191">W metodzie zwracającej wartości inne niż void `return` instrukcje muszą zawierać wyrażenie, które oblicza wartość zwracaną.</span><span class="sxs-lookup"><span data-stu-id="f83d3-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="f83d3-192">Metody static i instance</span><span class="sxs-lookup"><span data-stu-id="f83d3-192">Static and instance methods</span></span>

<span data-ttu-id="f83d3-193">Metoda zadeklarowana za pomocą `static` modyfikatora jest *metodą statyczną*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="f83d3-194">Metoda statyczna nie działa w konkretnym wystąpieniu i może bezpośrednio uzyskiwać dostęp do statycznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="f83d3-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="f83d3-195">Metoda zadeklarowana bez `static` modyfikatora jest *metodą wystąpienia*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="f83d3-196">Metoda wystąpienia działa w konkretnym wystąpieniu i może uzyskiwać dostęp do elementów członkowskich static i instance.</span><span class="sxs-lookup"><span data-stu-id="f83d3-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="f83d3-197">Wystąpienie, na którym wywołano metodę wystąpienia, można jawnie uzyskać do niego dostęp `this` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="f83d3-198">Jest to błąd, aby odwołać się do `this` w metodzie statycznej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="f83d3-199">Następująca `Entity` Klasa zawiera elementy członkowskie statyczne i wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="f83d3-200">Każde `Entity` wystąpienie zawiera numer seryjny (i najprawdopodobniej inne informacje, które nie są wyświetlane w tym miejscu).</span><span class="sxs-lookup"><span data-stu-id="f83d3-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="f83d3-201">`Entity`Konstruktor (który przypomina metodę wystąpienia) Inicjuje nowe wystąpienie przy użyciu następnego dostępnego numeru seryjnego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="f83d3-202">Ponieważ Konstruktor jest członkiem wystąpienia, dozwolone jest uzyskanie dostępu zarówno do `_serialNo` pola wystąpienia, jak i `s_nextSerialNo` pola statycznego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="f83d3-203">`GetNextSerialNo`Metody i `SetNextSerialNo` static mogą uzyskać dostęp do `s_nextSerialNo` pola statycznego, ale może to być błąd, aby uzyskać bezpośredni dostęp do `_serialNo` pola wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="f83d3-204">Poniższy przykład pokazuje użycie `Entity` klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="f83d3-205">`SetNextSerialNo`Metody i `GetNextSerialNo` Static są wywoływane w klasie, podczas gdy `GetSerialNo` metoda wystąpienia jest wywoływana w wystąpieniach klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="f83d3-206">Metody wirtualne, przesłonięcia i abstrakcyjne</span><span class="sxs-lookup"><span data-stu-id="f83d3-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="f83d3-207">Gdy deklaracja metody wystąpienia zawiera `virtual` modyfikator, metoda jest uznawana za *metodę wirtualną*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="f83d3-208">Gdy nie jest dostępny żaden modyfikator wirtualny, metoda jest uznawana za *metodę niewirtualną*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="f83d3-209">Gdy wywoływana jest metoda wirtualna, *typem czasu wykonywania* wystąpienia, dla którego odbywa się wywołanie określa rzeczywistą implementację metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="f83d3-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="f83d3-210">W wywołaniu metody niewirtualnej *Typ czasu kompilacji* wystąpienia jest czynnikiem decydującym.</span><span class="sxs-lookup"><span data-stu-id="f83d3-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="f83d3-211">Metoda wirtualna może zostać *przesłonięta* w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="f83d3-212">Gdy deklaracja metody wystąpienia zawiera modyfikator przesłonięcia, metoda zastępuje dziedziczonej metody wirtualnej tą samą sygnaturą.</span><span class="sxs-lookup"><span data-stu-id="f83d3-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="f83d3-213">Deklaracja metody wirtualnej AA wprowadza nową metodę.</span><span class="sxs-lookup"><span data-stu-id="f83d3-213">Aa virtual method declaration introduces a new method.</span></span> <span data-ttu-id="f83d3-214">Deklaracja metody przesłonięcia specjalizacji istniejącej dziedziczonej metody wirtualnej przez podanie nowej implementacji tej metody.</span><span class="sxs-lookup"><span data-stu-id="f83d3-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="f83d3-215">*Metoda abstrakcyjna* jest metodą wirtualną bez implementacji.</span><span class="sxs-lookup"><span data-stu-id="f83d3-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="f83d3-216">Metoda abstrakcyjna jest zadeklarowana z `abstract` modyfikatorem i jest dozwolona tylko w klasie abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="f83d3-217">Metoda abstrakcyjna musi zostać przesłonięta w każdej nieabstrakcyjnej klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="f83d3-218">Poniższy przykład deklaruje klasę abstrakcyjną, `Expression` która reprezentuje węzeł drzewa wyrażeń i trzy klasy pochodne, `Constant` , `VariableReference` i `Operation` , które implementują węzły drzewa wyrażeń dla stałych, odwołań do zmiennych i operacji arytmetycznych.</span><span class="sxs-lookup"><span data-stu-id="f83d3-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="f83d3-219">(Ten przykład jest podobny do, ale nie jest powiązany z typami drzewa wyrażeń).</span><span class="sxs-lookup"><span data-stu-id="f83d3-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="f83d3-220">Poprzednie cztery klasy mogą służyć do modelowania wyrażeń arytmetycznych.</span><span class="sxs-lookup"><span data-stu-id="f83d3-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="f83d3-221">Na przykład przy użyciu wystąpień tych klas wyrażenie `x + 3` może być reprezentowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="f83d3-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="f83d3-222">`Evaluate`Metoda `Expression` wystąpienia jest wywoływana w celu obliczenia danego wyrażenia i utworzenia `double` wartości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="f83d3-223">Metoda przyjmuje `Dictionary` argument, który zawiera nazwy zmiennych (jako klucze wpisów) i wartości (jako wartości wpisów).</span><span class="sxs-lookup"><span data-stu-id="f83d3-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="f83d3-224">Ponieważ `Evaluate` jest to metoda abstrakcyjna, klasy nieabstrakcyjne pochodne `Expression` muszą zostać przesłonięte `Evaluate` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="f83d3-225">`Constant`Implementacja `Evaluate` po prostu zwraca przechowywaną stałą.</span><span class="sxs-lookup"><span data-stu-id="f83d3-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="f83d3-226">`VariableReference`Implementacja programu wyszukuje nazwę zmiennej w słowniku i zwraca wartość wynikową.</span><span class="sxs-lookup"><span data-stu-id="f83d3-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="f83d3-227">`Operation`Implementacja najpierw szacuje lewy i prawy operand (cyklicznie wywołując ich `Evaluate` metody), a następnie wykonuje daną operację arytmetyczną.</span><span class="sxs-lookup"><span data-stu-id="f83d3-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="f83d3-228">Poniższy program używa `Expression` klas do obliczenia wyrażenia `x * (y + 2)` pod kątem różnych wartości `x` i `y` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="f83d3-229">Przeciążanie metody</span><span class="sxs-lookup"><span data-stu-id="f83d3-229">Method overloading</span></span>

<span data-ttu-id="f83d3-230">*Przeciążanie* metod pozwala wielu metodom w tej samej klasie mieć taką samą nazwę, o ile mają unikatowe podpisy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="f83d3-231">Podczas kompilowania wywołania przeciążonej metody kompilator używa *rozdzielczości przeciążenia* do określenia konkretnej metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="f83d3-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="f83d3-232">Rozpoznanie przeciążenia umożliwia znalezienie jednej metody, która najlepiej pasuje do argumentów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="f83d3-233">Jeśli nie można znaleźć pojedynczego najlepszego dopasowania, zostanie zgłoszony błąd.</span><span class="sxs-lookup"><span data-stu-id="f83d3-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="f83d3-234">W poniższym przykładzie przedstawiono sposób rozwiązywania przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="f83d3-235">Komentarz dla każdego wywołania `UsageExample` metody pokazuje, która metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="f83d3-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="f83d3-236">Jak pokazano w przykładzie, dana metoda może być zawsze wybierana przez jawne rzutowanie argumentów do dokładnych typów parametrów i argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="f83d3-237">Inne elementy członkowskie funkcji</span><span class="sxs-lookup"><span data-stu-id="f83d3-237">Other function members</span></span>

<span data-ttu-id="f83d3-238">Elementy członkowskie, które zawierają kod wykonywalny, są określane zbiorczo jako *elementy członkowskie* klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="f83d3-239">W poprzedniej sekcji opisano metody, które stanowią podstawowe typy elementów członkowskich funkcji.</span><span class="sxs-lookup"><span data-stu-id="f83d3-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="f83d3-240">W tej sekcji opisano inne rodzaje składowych funkcji obsługiwane przez język C#: konstruktory, właściwości, indeksatory, zdarzenia, operatory i finalizatory.</span><span class="sxs-lookup"><span data-stu-id="f83d3-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="f83d3-241">Poniższy przykład pokazuje klasę generyczną o nazwie `MyList<T>` , która implementuje rozwijaną listę obiektów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="f83d3-242">Klasa zawiera kilka przykładów typowych rodzajów elementów członkowskich funkcji.</span><span class="sxs-lookup"><span data-stu-id="f83d3-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="f83d3-243">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="f83d3-243">Constructors</span></span>

<span data-ttu-id="f83d3-244">C# obsługuje zarówno wystąpienie, jak i konstruktory statyczne.</span><span class="sxs-lookup"><span data-stu-id="f83d3-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="f83d3-245">*Konstruktor wystąpienia* jest członkiem, który implementuje akcje wymagane do zainicjowania wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="f83d3-246">*Statyczny Konstruktor* jest członkiem, który implementuje akcje wymagane do zainicjowania samej klasy podczas pierwszego ładowania.</span><span class="sxs-lookup"><span data-stu-id="f83d3-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="f83d3-247">Konstruktor jest zadeklarowany jak metoda bez zwracanego typu i o takiej samej nazwie jak zawierająca klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="f83d3-248">Jeśli deklaracja konstruktora zawiera `static` modyfikator, deklaruje Konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="f83d3-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="f83d3-249">W przeciwnym razie deklaruje Konstruktor wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="f83d3-250">Konstruktory wystąpień mogą być przeciążone i mogą mieć parametry opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="f83d3-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="f83d3-251">Na przykład `MyList<T>` Klasa deklaruje jeden Konstruktor wystąpienia z jednym opcjonalnym `int` parametrem.</span><span class="sxs-lookup"><span data-stu-id="f83d3-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="f83d3-252">Konstruktory wystąpień są wywoływane przy użyciu `new` operatora.</span><span class="sxs-lookup"><span data-stu-id="f83d3-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="f83d3-253">Poniższe instrukcje przydzielą dwa `MyList<string>` wystąpienia przy użyciu konstruktora `MyList` klasy z argumentem opcjonalnym i bez niego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="f83d3-254">W przeciwieństwie do innych elementów członkowskich, konstruktory wystąpień nie są dziedziczone.</span><span class="sxs-lookup"><span data-stu-id="f83d3-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="f83d3-255">Klasa nie ma konstruktorów wystąpień innych niż te konstruktory faktycznie zadeklarowane w klasie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="f83d3-256">Jeśli nie podano konstruktora wystąpienia dla klasy, zostanie automatycznie podana pusta wartość bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="f83d3-257">Właściwości</span><span class="sxs-lookup"><span data-stu-id="f83d3-257">Properties</span></span>

<span data-ttu-id="f83d3-258">*Właściwości* są naturalnym rozszerzeniem pól.</span><span class="sxs-lookup"><span data-stu-id="f83d3-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="f83d3-259">Oba są nazwanymi członkami ze skojarzonymi typami, a składnia dostępu do pól i właściwości jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="f83d3-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="f83d3-260">Jednak w przeciwieństwie do pól właściwości nie oznacza lokalizacji magazynu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="f83d3-261">Zamiast tego właściwości mają metody *dostępu* określające instrukcje wykonywane, gdy ich wartości są odczytywane lub zapisywane.</span><span class="sxs-lookup"><span data-stu-id="f83d3-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="f83d3-262">Właściwość jest zadeklarowana jako pole, z tą różnicą, że deklaracja kończy się metodą dostępu get lub zestawem akcesora zapisanym między ogranicznikami `{` i `}` zamiast kończyć się średnikiem.</span><span class="sxs-lookup"><span data-stu-id="f83d3-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="f83d3-263">Właściwość, która ma zarówno metodę dostępu get, jak i zestaw akcesora zestawu jest *właściwością do odczytu i zapisu*, właściwość, która ma tylko metodę dostępu get, jest *właściwością tylko do odczytu*, a właściwość, która ma tylko metodę dostępu zestawu, jest *właściwością tylko do zapisu*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="f83d3-264">Metoda dostępu get odpowiada metodzie bez parametrów z wartością zwracaną typu właściwości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="f83d3-265">Metoda dostępu zestawu odpowiada metodzie z pojedynczym parametrem o nazwie Value i bez zwracanego typu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="f83d3-266">Metoda dostępu get oblicza wartość właściwości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="f83d3-267">Metoda dostępu set udostępnia nową wartość właściwości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="f83d3-268">Gdy właściwość jest obiektem docelowym przypisania lub operandem `++` lub `--` , metoda dostępu set jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="f83d3-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="f83d3-269">W innych przypadkach, w których właściwość jest przywoływana, metoda dostępu get jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="f83d3-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

 <span data-ttu-id="f83d3-270">Gdy właściwość jest przywoływana jako element docelowy przypisania lub jako operand + + lub--, metoda dostępu set jest wywoływana z argumentem, który udostępnia nową wartość.</span><span class="sxs-lookup"><span data-stu-id="f83d3-270">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="f83d3-271">`MyList<T>`Klasa deklaruje dwie właściwości `Count` i `Capacity` , które są tylko do odczytu i odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-271">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="f83d3-272">Poniższy kod stanowi przykład użycia tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="f83d3-272">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="f83d3-273">Podobnie jak pola i metody, C# obsługuje zarówno właściwości wystąpienia, jak i właściwości statyczne.</span><span class="sxs-lookup"><span data-stu-id="f83d3-273">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="f83d3-274">Właściwości statyczne są zadeklarowane za pomocą modyfikatora static, a właściwości wystąpienia są deklarowane bez użycia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-274">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="f83d3-275">Metody dostępu właściwości mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="f83d3-275">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="f83d3-276">Gdy Deklaracja właściwości zawiera `virtual` `abstract` modyfikator, lub `override` , ma zastosowanie do akcesorów właściwości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-276">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="f83d3-277">Indeksatory</span><span class="sxs-lookup"><span data-stu-id="f83d3-277">Indexers</span></span>

<span data-ttu-id="f83d3-278">*Indeksator* jest członkiem, który umożliwia indeksowanie obiektów w taki sam sposób jak w przypadku tablicy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-278">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="f83d3-279">Indeksator jest zadeklarowany jak właściwość, z tą różnicą, że po nazwie składowej `this` następuje lista parametrów zapisywana między ogranicznikami `[` i `]` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-279">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="f83d3-280">Parametry są dostępne w metodach dostępu indeksatora.</span><span class="sxs-lookup"><span data-stu-id="f83d3-280">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="f83d3-281">Podobnie jak w przypadku właściwości, indeksatory mogą być tylko do odczytu i zapisu, tylko do odczytu i do zapisu, a Akcesory dla indeksatora mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="f83d3-281">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="f83d3-282">`MyList<T>`Klasa deklaruje pojedynczy indeksator do odczytu i zapisu, który pobiera `int` parametr.</span><span class="sxs-lookup"><span data-stu-id="f83d3-282">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="f83d3-283">Indeksator umożliwia indeksowanie `MyList<T>` wystąpień z `int` wartościami.</span><span class="sxs-lookup"><span data-stu-id="f83d3-283">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="f83d3-284">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="f83d3-284">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="f83d3-285">Indeksatory mogą być przeciążone.</span><span class="sxs-lookup"><span data-stu-id="f83d3-285">Indexers can be overloaded.</span></span> <span data-ttu-id="f83d3-286">Klasa może deklarować wiele indeksatorów, o ile liczba lub typy ich parametrów różnią się.</span><span class="sxs-lookup"><span data-stu-id="f83d3-286">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="f83d3-287">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="f83d3-287">Events</span></span>

<span data-ttu-id="f83d3-288">*Zdarzenie* jest członkiem, który umożliwia klasy lub obiektowi dostarczanie powiadomień.</span><span class="sxs-lookup"><span data-stu-id="f83d3-288">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="f83d3-289">Zdarzenie jest zadeklarowane jak pole, z tą różnicą, że deklaracja zawiera `event` słowo kluczowe i typ musi być typem delegata.</span><span class="sxs-lookup"><span data-stu-id="f83d3-289">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="f83d3-290">W obrębie klasy, która deklaruje element członkowski zdarzenia, zdarzenie zachowuje się podobnie jak pole typu delegata (pod warunkiem, że zdarzenie nie jest abstrakcyjne i nie deklaruje metod dostępu).</span><span class="sxs-lookup"><span data-stu-id="f83d3-290">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="f83d3-291">W polu jest przechowywane odwołanie do delegata, który reprezentuje programy obsługi zdarzeń, które zostały dodane do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-291">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="f83d3-292">Jeśli nie ma żadnych programów obsługi zdarzeń, pole jest `null` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-292">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="f83d3-293">`MyList<T>`Klasa deklaruje pojedynczy element członkowski zdarzenia o nazwie `Changed` , który wskazuje, że dodano nowy element do listy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-293">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="f83d3-294">Zmienione zdarzenie jest wywoływane przez `OnChanged` metodę wirtualną, która najpierw sprawdza, czy zdarzenie jest `null` (oznacza, że nie ma żadnych programów obsługi).</span><span class="sxs-lookup"><span data-stu-id="f83d3-294">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="f83d3-295">Pojęcie podniesienia poziomu zdarzenia jest dokładnie równoważne do wywołania delegata reprezentowanego przez zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-295">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="f83d3-296">Nie istnieją żadne specjalne konstrukcje języka do wywoływania zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="f83d3-296">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="f83d3-297">Klienci reagują na zdarzenia za poorednictwem *programów obsługi zdarzeń*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-297">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="f83d3-298">Procedury obsługi zdarzeń są dołączane przy użyciu `+=` operatora i usuwane przy użyciu `-=` operatora.</span><span class="sxs-lookup"><span data-stu-id="f83d3-298">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="f83d3-299">Poniższy przykład dołącza procedurę obsługi zdarzeń do `Changed` zdarzenia `MyList<string>` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-299">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="f83d3-300">W przypadku zaawansowanych scenariuszy, w których wymagana jest kontrola bazowego magazynu zdarzenia, deklaracja zdarzenia może jawnie dostarczyć i akcesorów `add` `remove` , które są podobne do `set` metody dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="f83d3-300">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="f83d3-301">Operatory</span><span class="sxs-lookup"><span data-stu-id="f83d3-301">Operators</span></span>

<span data-ttu-id="f83d3-302">*Operator* jest członkiem, który definiuje znaczenie zastosowania określonego operatora wyrażenia do wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-302">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="f83d3-303">Można zdefiniować trzy rodzaje operatorów: operatory jednoargumentowe, operatory binarne i operatory konwersji.</span><span class="sxs-lookup"><span data-stu-id="f83d3-303">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="f83d3-304">Wszystkie operatory muszą być zadeklarowane jako `public` i `static` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-304">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="f83d3-305">`MyList<T>`Klasa deklaruje dwa operatory `operator ==` i `operator !=` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-305">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="f83d3-306">Te zastąpione operatory dają nowe znaczenie dla wyrażeń, które stosują te operatory do `MyList` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="f83d3-306">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="f83d3-307">W tym celu operatory definiują równość dwóch `MyList<T>` wystąpień w porównaniu z poszczególnymi obiektami zawartymi przy użyciu `Equals` metod.</span><span class="sxs-lookup"><span data-stu-id="f83d3-307">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="f83d3-308">Poniższy przykład używa `==` operatora do porównywania dwóch `MyList<int>` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="f83d3-308">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="f83d3-309">Pierwsze dane `Console.WriteLine` wyjściowe, `True` ponieważ dwie listy zawierają tę samą liczbę obiektów z tymi samymi wartościami w tej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="f83d3-309">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="f83d3-310">`MyList<T>`Nie zdefiniowano `operator ==` , pierwsze `Console.WriteLine` miałoby wynik, `False` ponieważ `a` i odwołuje się do `b` różnych `MyList<int>` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="f83d3-310">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="f83d3-311">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="f83d3-311">Finalizers</span></span>

<span data-ttu-id="f83d3-312">*Finalizator* jest członkiem, który implementuje akcje wymagane do sfinalizowania wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="f83d3-312">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="f83d3-313">Zazwyczaj finalizator jest wymagany do zwolnienia niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-313">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="f83d3-314">Finalizatory nie mogą mieć parametrów, nie mogą mieć modyfikatorów dostępności i nie mogą być wywoływane jawnie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-314">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="f83d3-315">Finalizator dla wystąpienia jest wywoływany automatycznie podczas wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="f83d3-315">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="f83d3-316">Aby uzyskać więcej informacji, zobacz artykuł dotyczący [finalizatorów](../programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="f83d3-316">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="f83d3-317">Moduł wyrzucania elementów bezużytecznych jest dozwolony w przypadku podejmowania decyzji podczas zbierania obiektów i uruchamiania finalizatorów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-317">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="f83d3-318">W odniesieniu do chronometrażu wywołań finalizatora nie jest deterministyczna, a finalizatory mogą być wykonywane na dowolnym wątku.</span><span class="sxs-lookup"><span data-stu-id="f83d3-318">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="f83d3-319">Z tych i innych powodów klasy powinny implementować finalizatory tylko wtedy, gdy żadne inne rozwiązania nie są możliwe.</span><span class="sxs-lookup"><span data-stu-id="f83d3-319">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="f83d3-320">`using`Instrukcja zawiera lepsze podejście do niszczenia obiektów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-320">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="f83d3-321">Wyrażenia</span><span class="sxs-lookup"><span data-stu-id="f83d3-321">Expressions</span></span>

<span data-ttu-id="f83d3-322">*Wyrażenia* są zbudowane z *argumentów operacji* i *operatorów*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-322">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="f83d3-323">Operatory wyrażenia wskazują, które operacje mają być stosowane do operandów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-323">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="f83d3-324">Przykłady operatorów obejmują `+` , `-` , `*` , `/` , i `new` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-324">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="f83d3-325">Przykłady operandów obejmują literały, pola, zmienne lokalne i wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-325">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="f83d3-326">Gdy wyrażenie zawiera wiele operatorów, *pierwszeństwo* operatorów kontroluje kolejność, w jakiej są oceniane poszczególne operatory.</span><span class="sxs-lookup"><span data-stu-id="f83d3-326">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="f83d3-327">Na przykład wyrażenie `x + y * z` jest oceniane tak, jakby `x + (y * z)` `*` operator miał wyższy priorytet niż `+` operator.</span><span class="sxs-lookup"><span data-stu-id="f83d3-327">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="f83d3-328">Gdy operand występuje między dwoma operatorami o takim samym priorytecie, *łączność* operatorów kontroluje kolejność wykonywania operacji:</span><span class="sxs-lookup"><span data-stu-id="f83d3-328">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="f83d3-329">Z wyjątkiem operatorów przypisania i łączenia wartości null wszystkie operatory binarne są z *lewej strony skojarzenia*, co oznacza, że operacje są wykonywane od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-329">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="f83d3-330">Na przykład, `x + y + z` jest oceniane jako `(x + y) + z` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-330">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="f83d3-331">Operatory przypisania, przeciąganie wartości null `??` i `??=` operatory, a operator warunkowy `?:` są z *prawej strony skojarzenia*, co oznacza, że operacje są wykonywane od prawej do lewej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-331">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="f83d3-332">Na przykład, `x = y = z` jest oceniane jako `x = (y = z)` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-332">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="f83d3-333">Pierwszeństwo i łączność można kontrolować za pomocą nawiasów.</span><span class="sxs-lookup"><span data-stu-id="f83d3-333">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="f83d3-334">Na przykład program `x + y * z` najpierw mnoży `y` przez, `z` a następnie dodaje wynik do `x` , ale `(x + y) * z` najpierw dodaje `x` i `y` i następnie mnoży wynik przez `z` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-334">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="f83d3-335">Większość operatorów może być [*przeciążona*](../language-reference/operators/operator-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="f83d3-335">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="f83d3-336">Przeciążanie operatora umożliwia określenie implementacji operatora zdefiniowanego przez użytkownika dla operacji, w których jeden lub oba operandy są klasy lub typu struktury zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f83d3-336">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="f83d3-337">Język C# zawiera wiele operatorów umożliwiających operacje [arytmetyczne](../language-reference/operators/arithmetic-operators.md), [logiczne](../language-reference/operators/boolean-logical-operators.md), [bitowe i przesunięcia](../language-reference/operators/bitwise-and-shift-operators.md) oraz porównania [równości](../language-reference/operators/equality-operators.md) i [kolejności](../language-reference/operators/comparison-operators.md) .</span><span class="sxs-lookup"><span data-stu-id="f83d3-337">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="f83d3-338">Aby uzyskać pełną listę operatorów języka C# uporządkowanych według poziomu pierwszeństwa, zobacz [operatory języka c#](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="f83d3-338">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="f83d3-339">Instrukcje</span><span class="sxs-lookup"><span data-stu-id="f83d3-339">Statements</span></span>

<span data-ttu-id="f83d3-340">Akcje programu są wyrażane przy użyciu *instrukcji*.</span><span class="sxs-lookup"><span data-stu-id="f83d3-340">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="f83d3-341">Język C# obsługuje kilka różnych rodzajów instrukcji, które są zdefiniowane w postaci instrukcji osadzonych.</span><span class="sxs-lookup"><span data-stu-id="f83d3-341">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="f83d3-342">*Blok* umożliwia zapisanie wielu instrukcji w kontekstach, w których Pojedyncza instrukcja jest dozwolona.</span><span class="sxs-lookup"><span data-stu-id="f83d3-342">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="f83d3-343">Blok składa się z listy instrukcji pisanych między ogranicznikami `{` i `}` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-343">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="f83d3-344">*Instrukcje deklaracji* są używane do deklarowania zmiennych lokalnych i stałych.</span><span class="sxs-lookup"><span data-stu-id="f83d3-344">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="f83d3-345">*Instrukcje wyrażeń* są używane do obliczania wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="f83d3-345">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="f83d3-346">Wyrażenia, które mogą być używane jako instrukcje, obejmują wywołania metod, alokacje obiektów przy użyciu `new` operatora, przypisań przy użyciu `=` i operatorów przypisania złożonego, operacji zwiększania i zmniejszania przy użyciu `++` `--` operatorów i i `await` wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="f83d3-346">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="f83d3-347">*Instrukcje wyboru* są używane do wybierania jednej z wielu możliwych instrukcji do wykonania na podstawie wartości niektórych wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="f83d3-347">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="f83d3-348">Ta grupa zawiera `if` instrukcje i `switch` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-348">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="f83d3-349">*Instrukcje iteracji* są używane do wielokrotnego wykonywania osadzonej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f83d3-349">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="f83d3-350">Ta grupa zawiera `while` instrukcje, `do` , `for` , i `foreach` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-350">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="f83d3-351">*Instrukcje skoku* są używane do transferowania kontroli.</span><span class="sxs-lookup"><span data-stu-id="f83d3-351">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="f83d3-352">Ta grupa zawiera `break` instrukcje, `continue` ,,, `goto` `throw` `return` i `yield` .</span><span class="sxs-lookup"><span data-stu-id="f83d3-352">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="f83d3-353">`try`Instrukcja... służy `catch` do przechwytywania wyjątków, które występują podczas wykonywania bloku, a `try` instrukcja... `finally` jest używana do określania kodu finalizacji, który jest zawsze wykonywany, niezależnie od tego, czy wystąpił wyjątek, czy nie.</span><span class="sxs-lookup"><span data-stu-id="f83d3-353">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="f83d3-354">`checked`Instrukcje and `unchecked` są używane do kontrolowania kontekstu sprawdzania przepełnienia dla operacji arytmetycznych i konwersji typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="f83d3-354">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="f83d3-355">`lock`Instrukcja służy do uzyskiwania blokady wzajemnego wykluczania dla danego obiektu, wykonywania instrukcji i zwalniania blokady.</span><span class="sxs-lookup"><span data-stu-id="f83d3-355">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="f83d3-356">`using`Instrukcja służy do uzyskiwania zasobu, wykonywania instrukcji, a następnie usuwania tego zasobu.</span><span class="sxs-lookup"><span data-stu-id="f83d3-356">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="f83d3-357">Poniżej wymieniono rodzaje instrukcji, które mogą być używane:</span><span class="sxs-lookup"><span data-stu-id="f83d3-357">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="f83d3-358">Deklaracja zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="f83d3-358">Local variable declaration.</span></span>
* <span data-ttu-id="f83d3-359">Lokalna deklaracja stała.</span><span class="sxs-lookup"><span data-stu-id="f83d3-359">Local constant declaration.</span></span>
* <span data-ttu-id="f83d3-360">Instrukcja wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="f83d3-360">Expression statement.</span></span>
* <span data-ttu-id="f83d3-361">`if`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-361">`if` statement.</span></span>
* <span data-ttu-id="f83d3-362">`switch`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-362">`switch` statement.</span></span>
* <span data-ttu-id="f83d3-363">`while`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-363">`while` statement.</span></span>
* <span data-ttu-id="f83d3-364">`do`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-364">`do` statement.</span></span>
* <span data-ttu-id="f83d3-365">`for`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-365">`for` statement.</span></span>
* <span data-ttu-id="f83d3-366">`foreach`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-366">`foreach` statement.</span></span>
* <span data-ttu-id="f83d3-367">`break`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-367">`break` statement.</span></span>
* <span data-ttu-id="f83d3-368">`continue`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-368">`continue` statement.</span></span>
* <span data-ttu-id="f83d3-369">`goto`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-369">`goto` statement.</span></span>
* <span data-ttu-id="f83d3-370">`return`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-370">`return` statement.</span></span>
* <span data-ttu-id="f83d3-371">`yield`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-371">`yield` statement.</span></span>
* <span data-ttu-id="f83d3-372">`throw`instrukcje i `try` instrukcje.</span><span class="sxs-lookup"><span data-stu-id="f83d3-372">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="f83d3-373">`checked`i `unchecked` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f83d3-373">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="f83d3-374">`lock`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-374">`lock` statement.</span></span>
* <span data-ttu-id="f83d3-375">`using`Merge.</span><span class="sxs-lookup"><span data-stu-id="f83d3-375">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f83d3-376">[Poprzedni](types.md) 
> [Dalej](features.md)</span><span class="sxs-lookup"><span data-stu-id="f83d3-376">[Previous](types.md)
[Next](features.md)</span></span>
