---
title: Wykonywanie sprzężeń zgrupowanych (LINQ w języku C#)
description: Dowiedz się, jak wykonywać zgrupowane sprzężenia przy użyciu LINQ w języku C#.
ms.date: 04/22/2020
ms.assetid: 9667daf9-a5fd-4b43-a5c4-a9c2b744000e
ms.openlocfilehash: 6411479c5fe6cb0ee79a0cd3df6de2f4d42c26a2
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/15/2020
ms.locfileid: "90542812"
---
# <a name="perform-grouped-joins"></a><span data-ttu-id="a8724-103">Wykonywanie sprzężeń grupowanych</span><span class="sxs-lookup"><span data-stu-id="a8724-103">Perform grouped joins</span></span>

<span data-ttu-id="a8724-104">Przyłączanie do grupy jest przydatne do tworzenia hierarchicznych struktur danych.</span><span class="sxs-lookup"><span data-stu-id="a8724-104">The group join is useful for producing hierarchical data structures.</span></span> <span data-ttu-id="a8724-105">Parowanie każdego elementu z pierwszej kolekcji z zestawem skorelowanych elementów z drugiej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a8724-105">It pairs each element from the first collection with a set of correlated elements from the second collection.</span></span>

<span data-ttu-id="a8724-106">Na przykład Klasa lub tabela relacyjnej bazy danych o nazwie `Student` mogą zawierać dwa pola: `Id` i `Name` .</span><span class="sxs-lookup"><span data-stu-id="a8724-106">For example, a class or a relational database table named `Student` might contain two fields: `Id` and `Name`.</span></span> <span data-ttu-id="a8724-107">Druga klasa lub relacyjna tabela bazy danych o nazwie `Course` może zawierać dwa pola: `StudentId` i `CourseTitle` .</span><span class="sxs-lookup"><span data-stu-id="a8724-107">A second class or relational database table named `Course` might contain two fields: `StudentId` and `CourseTitle`.</span></span> <span data-ttu-id="a8724-108">Przyłączanie do grupy tych dwóch źródeł danych na podstawie zgodności `Student.Id` i `Course.StudentId` , grupuje każdy `Student` z kolekcją `Course` obiektów (może być pusta).</span><span class="sxs-lookup"><span data-stu-id="a8724-108">A group join of these two data sources, based on matching `Student.Id` and `Course.StudentId`, would group each `Student` with a collection of `Course` objects (which might be empty).</span></span>

> [!NOTE]
> <span data-ttu-id="a8724-109">Każdy element pierwszej kolekcji pojawia się w zestawie wyników sprzężenia grupy, niezależnie od tego, czy skorelowane elementy znajdują się w drugiej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a8724-109">Each element of the first collection appears in the result set of a group join regardless of whether correlated elements are found in the second collection.</span></span> <span data-ttu-id="a8724-110">W przypadku, gdy nie zostaną znalezione żadne skorelowane elementy, sekwencja skorelowanych elementów dla tego elementu jest pusta.</span><span class="sxs-lookup"><span data-stu-id="a8724-110">In the case where no correlated elements are found, the sequence of correlated elements for that element is empty.</span></span> <span data-ttu-id="a8724-111">Dlatego selektor wyniku ma dostęp do każdego elementu pierwszej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a8724-111">The result selector therefore has access to every element of the first collection.</span></span> <span data-ttu-id="a8724-112">Różni się to od selektora wyników w sprzężeniu innym niż grupa, które nie może uzyskać dostępu do elementów z pierwszej kolekcji, która nie ma dopasowania w drugiej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a8724-112">This differs from the result selector in a non-group join, which cannot access elements from the first collection that have no match in the second collection.</span></span>

> [!WARNING]
> <span data-ttu-id="a8724-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> nie ma bezpośredniego odpowiednika w tradycyjnych warunkach relacyjnej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="a8724-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> has no direct equivalent in traditional relational database terms.</span></span> <span data-ttu-id="a8724-114">Jednakże ta metoda implementuje nadzbiór sprzężeń wewnętrznych i Lewe sprzężenia zewnętrzne.</span><span class="sxs-lookup"><span data-stu-id="a8724-114">However, this method does implement a superset of inner joins and left outer joins.</span></span> <span data-ttu-id="a8724-115">Obie te operacje można napisać w odniesieniu do zgrupowanego sprzężenia.</span><span class="sxs-lookup"><span data-stu-id="a8724-115">Both of these operations can be written in terms of a grouped join.</span></span> <span data-ttu-id="a8724-116">Aby uzyskać więcej informacji, zobacz [operacje Join](../programming-guide/concepts/linq/join-operations.md) i [Entity Framework Core, GroupJoin —](/ef/core/querying/complex-query-operators#groupjoin).</span><span class="sxs-lookup"><span data-stu-id="a8724-116">For more information, see [Join Operations](../programming-guide/concepts/linq/join-operations.md) and [Entity Framework Core, GroupJoin](/ef/core/querying/complex-query-operators#groupjoin).</span></span>

<span data-ttu-id="a8724-117">Pierwszy przykład w tym artykule pokazuje, jak wykonać sprzężenie grupy.</span><span class="sxs-lookup"><span data-stu-id="a8724-117">The first example in this article shows you how to perform a group join.</span></span> <span data-ttu-id="a8724-118">Drugi przykład pokazuje, jak używać sprzężenia grupy do tworzenia elementów XML.</span><span class="sxs-lookup"><span data-stu-id="a8724-118">The second example shows you how to use a group join to create XML elements.</span></span>

## <a name="example---group-join"></a><span data-ttu-id="a8724-119">Przykład — Dołącz do grupy</span><span class="sxs-lookup"><span data-stu-id="a8724-119">Example - Group join</span></span>

<span data-ttu-id="a8724-120">Poniższy przykład wykonuje przyłączanie do grupy obiektów typu `Person` i `Pet` w oparciu o `Person` pasującą `Pet.Owner` Właściwość.</span><span class="sxs-lookup"><span data-stu-id="a8724-120">The following example performs a group join of objects of type `Person` and `Pet` based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="a8724-121">W przeciwieństwie do przyłączenia nienależących do grupy, która może utworzyć parę elementów dla każdego dopasowania, sprzężenie grupy generuje tylko jeden wynikowy obiekt dla każdego elementu pierwszej kolekcji, który w tym przykładzie jest `Person` obiektem.</span><span class="sxs-lookup"><span data-stu-id="a8724-121">Unlike a non-group join, which would produce a pair of elements for each match, the group join produces only one resulting object for each element of the first collection, which in this example is a `Person` object.</span></span> <span data-ttu-id="a8724-122">Odpowiednie elementy z drugiej kolekcji, w tym przykładzie są `Pet` obiektami, są pogrupowane w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a8724-122">The corresponding elements from the second collection, which in this example are `Pet` objects, are grouped into a collection.</span></span> <span data-ttu-id="a8724-123">Na koniec funkcja selektora wyników tworzy typ anonimowy dla każdego dopasowania, które składa się z `Person.FirstName` i kolekcji `Pet` obiektów.</span><span class="sxs-lookup"><span data-stu-id="a8724-123">Finally, the result selector function creates an anonymous type for each match that consists of `Person.FirstName` and a collection of `Pet` objects.</span></span>

[!code-csharp[CsLINQProgJoining#5](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_1.cs)]

## <a name="example---group-join-to-create-xml"></a><span data-ttu-id="a8724-124">Przykład — przyłączenie do grupy w celu utworzenia pliku XML</span><span class="sxs-lookup"><span data-stu-id="a8724-124">Example - Group join to create XML</span></span>

<span data-ttu-id="a8724-125">Sprzężenia grup doskonale nadają się do tworzenia kodu XML przy użyciu LINQ to XML.</span><span class="sxs-lookup"><span data-stu-id="a8724-125">Group joins are ideal for creating XML by using LINQ to XML.</span></span> <span data-ttu-id="a8724-126">Poniższy przykład jest podobny do poprzedniego przykładu, z wyjątkiem tego, że zamiast tworzenia typów anonimowych funkcja selektora wyników tworzy elementy XML, które reprezentują połączone obiekty.</span><span class="sxs-lookup"><span data-stu-id="a8724-126">The following example is similar to the previous example except that instead of creating anonymous types, the result selector function creates XML elements that represent the joined objects.</span></span>

[!code-csharp[CsLINQProgJoining#6](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_2.cs)]

## <a name="see-also"></a><span data-ttu-id="a8724-127">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a8724-127">See also</span></span>

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [<span data-ttu-id="a8724-128">Wykonywanie sprzężeń wewnętrznych</span><span class="sxs-lookup"><span data-stu-id="a8724-128">Perform inner joins</span></span>](perform-inner-joins.md)
- [<span data-ttu-id="a8724-129">Wykonywanie lewych sprzężeń zewnętrznych</span><span class="sxs-lookup"><span data-stu-id="a8724-129">Perform left outer joins</span></span>](perform-left-outer-joins.md)
- [<span data-ttu-id="a8724-130">Typy anonimowe</span><span class="sxs-lookup"><span data-stu-id="a8724-130">Anonymous types</span></span>](../programming-guide/classes-and-structs/anonymous-types.md)
