---
title: Wykonywanie sprzężeń wewnętrznych (LINQ w języku C)Perform inner joins (LINQ in C#)
description: Dowiedz się, jak wykonywać sprzężenia wewnętrzne przy użyciu LINQ w języku C#.
ms.date: 12/01/2016
ms.assetid: 45bceed6-f549-4114-a9b1-b44feb497742
ms.openlocfilehash: a3e8e9bd97ec630797bc48a3302b27ed45d9103e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "61659842"
---
# <a name="perform-inner-joins"></a><span data-ttu-id="d9cd8-103">Wykonywanie sprzężeń wewnętrznych</span><span class="sxs-lookup"><span data-stu-id="d9cd8-103">Perform inner joins</span></span>

<span data-ttu-id="d9cd8-104">W kategoriach relacyjnej bazy danych *sprzężenia wewnętrznego* daje zestaw wyników, w którym każdy element pierwszej kolekcji pojawia się jeden raz dla każdego pasującego elementu w drugiej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-104">In relational database terms, an *inner join* produces a result set in which each element of the first collection appears one time for every matching element in the second collection.</span></span> <span data-ttu-id="d9cd8-105">Jeśli element w pierwszej kolekcji nie ma pasujących elementów, nie pojawia się w zestawie wyników.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-105">If an element in the first collection has no matching elements, it does not appear in the result set.</span></span> <span data-ttu-id="d9cd8-106">Metoda, <xref:System.Linq.Enumerable.Join%2A> która jest wywoływana przez klauzulę w języku `join` C#, implementuje sprzężenie wewnętrzne.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-106">The <xref:System.Linq.Enumerable.Join%2A> method, which is called by the `join` clause in C#, implements an inner join.</span></span>

<span data-ttu-id="d9cd8-107">Z tego artykułu dowiesz się, jak wykonać cztery odmiany sprzężenia wewnętrznego:</span><span class="sxs-lookup"><span data-stu-id="d9cd8-107">This article shows you how to perform four variations of an inner join:</span></span>

- <span data-ttu-id="d9cd8-108">Proste sprzężenie wewnętrzne, które koreluje elementy z dwóch źródeł danych na podstawie prostego klucza.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-108">A simple inner join that correlates elements from two data sources based on a simple key.</span></span>

- <span data-ttu-id="d9cd8-109">Sprzężenie wewnętrzne, które koreluje elementy z dwóch źródeł danych na podstawie klucza *złożonego.*</span><span class="sxs-lookup"><span data-stu-id="d9cd8-109">An inner join that correlates elements from two data sources based on a *composite* key.</span></span> <span data-ttu-id="d9cd8-110">Klucz złożony, który jest kluczem, który składa się z więcej niż jednej wartości, umożliwia skorelowanie elementów na podstawie więcej niż jednej właściwości.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-110">A composite key, which is a key that consists of more than one value, enables you to correlate elements based on more than one property.</span></span>

- <span data-ttu-id="d9cd8-111">*Sprzężenie wielokrotne,* w którym kolejne operacje sprzężenia są dołączane do siebie.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-111">A *multiple join* in which successive join operations are appended to each other.</span></span>

- <span data-ttu-id="d9cd8-112">Sprzężenie wewnętrzne, które jest implementowane przy użyciu sprzężenia grupy.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-112">An inner join that is implemented by using a group join.</span></span>

## <a name="example---simple-key-join"></a><span data-ttu-id="d9cd8-113">Przykład — proste sprzężenie klucza</span><span class="sxs-lookup"><span data-stu-id="d9cd8-113">Example - Simple key join</span></span>

<span data-ttu-id="d9cd8-114">Poniższy przykład tworzy dwie kolekcje, które zawierają obiekty `Person` `Pet`dwóch typów zdefiniowanych przez użytkownika i .</span><span class="sxs-lookup"><span data-stu-id="d9cd8-114">The following example creates two collections that contain objects of two user-defined types, `Person` and `Pet`.</span></span> <span data-ttu-id="d9cd8-115">Kwerenda używa `join` klauzuli w `Person` języku `Pet` C# do dopasowania obiektów z obiektami, których `Owner` jest . `Person`</span><span class="sxs-lookup"><span data-stu-id="d9cd8-115">The query uses the `join` clause in C# to match `Person` objects with `Pet` objects whose `Owner` is that `Person`.</span></span> <span data-ttu-id="d9cd8-116">Klauzula `select` w języku C# definiuje, jak będą wyglądać wynikowe obiekty.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-116">The `select` clause in C# defines how the resulting objects will look.</span></span> <span data-ttu-id="d9cd8-117">W tym przykładzie wynikowe obiekty są typy anonimowe, które składają się z imienia właściciela i nazwy zwierzęcia.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-117">In this example the resulting objects are anonymous types that consist of the owner's first name and the pet's name.</span></span>

[!code-csharp[CsLINQProgJoining#1](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_1.cs)]

<span data-ttu-id="d9cd8-118">Należy zauważyć, `Person` `LastName` że obiekt, którego jest "Huff" nie `Pet` pojawia się `Pet.Owner` w `Person`zestawie wyników, ponieważ nie ma żadnego obiektu, który jest równy temu .</span><span class="sxs-lookup"><span data-stu-id="d9cd8-118">Note that the `Person` object whose `LastName` is "Huff" does not appear in the result set because there is no `Pet` object that has `Pet.Owner` equal to that `Person`.</span></span>

## <a name="example---composite-key-join"></a><span data-ttu-id="d9cd8-119">Przykład — sprzężenie klucza złożonego</span><span class="sxs-lookup"><span data-stu-id="d9cd8-119">Example - Composite key join</span></span>

<span data-ttu-id="d9cd8-120">Zamiast korelować elementy oparte na tylko jednej właściwości, można użyć klucza złożonego do porównania elementów na podstawie wielu właściwości.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-120">Instead of correlating elements based on just one property, you can use a composite key to compare elements based on multiple properties.</span></span> <span data-ttu-id="d9cd8-121">W tym celu należy określić funkcję selektora kluczy dla każdej kolekcji, aby zwrócić typ anonimowy, który składa się z właściwości, które chcesz porównać.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-121">To do this, specify the key selector function for each collection to return an anonymous type that consists of the properties you want to compare.</span></span> <span data-ttu-id="d9cd8-122">Jeśli etykiety właściwości, muszą mieć tę samą etykietę w typie anonimowym każdego klucza.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-122">If you label the properties, they must have the same label in each key's anonymous type.</span></span> <span data-ttu-id="d9cd8-123">Właściwości muszą również występować w tej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-123">The properties must also appear in the same order.</span></span>

<span data-ttu-id="d9cd8-124">W poniższym przykładzie `Employee` użyto listy `Student` obiektów i listy obiektów, aby określić, którzy pracownicy są również studentami.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-124">The following example uses a list of `Employee` objects and a list of `Student` objects to determine which employees are also students.</span></span> <span data-ttu-id="d9cd8-125">Oba te typy `FirstName` mają `LastName` i właściwość <xref:System.String>typu .</span><span class="sxs-lookup"><span data-stu-id="d9cd8-125">Both of these types have a `FirstName` and a `LastName` property of type <xref:System.String>.</span></span> <span data-ttu-id="d9cd8-126">Funkcje, które tworzą klucze sprzężenia z elementów każdej listy `FirstName` `LastName` zwracają typ anonimowy, który składa się z i właściwości każdego elementu.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-126">The functions that create the join keys from each list's elements return an anonymous type that consists of the `FirstName` and `LastName` properties of each element.</span></span> <span data-ttu-id="d9cd8-127">Operacja sprzężenia porównuje te klucze złożone dla równości i zwraca pary obiektów z każdej listy, gdzie zarówno imię, jak i nazwisko są zgodne.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-127">The join operation compares these composite keys for equality and returns pairs of objects from each list where both the first name and the last name match.</span></span>

[!code-csharp[CsLINQProgJoining#2](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_2.cs)]

## <a name="example---multiple-join"></a><span data-ttu-id="d9cd8-128">Przykład — sprzężenie wielokrotne</span><span class="sxs-lookup"><span data-stu-id="d9cd8-128">Example - Multiple join</span></span>

<span data-ttu-id="d9cd8-129">Dowolną liczbę operacji sprzężenia można dołączyć do siebie, aby wykonać sprzężenie wielokrotne.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-129">Any number of join operations can be appended to each other to perform a multiple join.</span></span> <span data-ttu-id="d9cd8-130">Każda `join` klauzula w języku C# koreluje określonego źródła danych z wynikami poprzedniego sprzężenia.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-130">Each `join` clause in C# correlates a specified data source with the results of the previous join.</span></span>

<span data-ttu-id="d9cd8-131">Poniższy przykład tworzy trzy kolekcje: listę `Person` obiektów, listę `Cat` obiektów `Dog` i listę obiektów.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-131">The following example creates three collections: a list of `Person` objects, a list of `Cat` objects, and a list of `Dog` objects.</span></span>

<span data-ttu-id="d9cd8-132">Pierwsza `join` klauzula w języku C# `Person` pasuje `Cat.Owner`do osób i kotów na podstawie dopasowania obiektu .</span><span class="sxs-lookup"><span data-stu-id="d9cd8-132">The first `join` clause in C# matches people and cats based on a `Person` object matching `Cat.Owner`.</span></span> <span data-ttu-id="d9cd8-133">Zwraca sekwencję typów anonimowych, `Person` które `Cat.Name`zawierają obiekt i .</span><span class="sxs-lookup"><span data-stu-id="d9cd8-133">It returns a sequence of anonymous types that contain the `Person` object and `Cat.Name`.</span></span>

<span data-ttu-id="d9cd8-134">Druga `join` klauzula w języku C# koreluje typy `Dog` anonimowe zwracane przez pierwsze sprzężenie z obiektami `Owner` na `Person`dostarczonej liście psów, na podstawie klucza złożonego, który składa się z właściwości typu i pierwszej litery nazwy zwierzęcia.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-134">The second `join` clause in C# correlates the anonymous types returned by the first join with `Dog` objects in the supplied list of dogs, based on a composite key that consists of the `Owner` property of type `Person`, and the first letter of the animal's name.</span></span> <span data-ttu-id="d9cd8-135">Zwraca sekwencję typów anonimowych, `Cat.Name` `Dog.Name` które zawierają i właściwości z każdej pasującej pary.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-135">It returns a sequence of anonymous types that contain the `Cat.Name` and `Dog.Name` properties from each matching pair.</span></span> <span data-ttu-id="d9cd8-136">Ponieważ jest to sprzężenie wewnętrzne, zwracane są tylko te obiekty z pierwszego źródła danych, które mają dopasowanie w drugim źródle danych.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-136">Because this is an inner join, only those objects from the first data source that have a match in the second data source are returned.</span></span>

[!code-csharp[CsLINQProgJoining#3](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_3.cs)]

## <a name="example---inner-join-by-using-grouped-join"></a><span data-ttu-id="d9cd8-137">Przykład — sprzężenie wewnętrzne przy użyciu sprzężenia zgrupowanego</span><span class="sxs-lookup"><span data-stu-id="d9cd8-137">Example - Inner join by using grouped join</span></span>

<span data-ttu-id="d9cd8-138">W poniższym przykładzie pokazano, jak zaimplementować sprzężenie wewnętrzne przy użyciu sprzężenia grupy.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-138">The following example shows you how to implement an inner join by using a group join.</span></span>

<span data-ttu-id="d9cd8-139">W `query1`, lista `Person` obiektów jest przyłączona `Pet` do grupy `Person` do `Pet.Owner` listy obiektów na podstawie pasującej właściwości.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-139">In `query1`, the list of `Person` objects is group-joined to the list of `Pet` objects based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="d9cd8-140">Sprzężenie grupy tworzy kolekcję grup pośrednich, `Person` gdzie każda grupa `Pet` składa się z obiektu i sekwencji pasujących obiektów.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-140">The group join creates a collection of intermediate groups, where each group consists of a `Person` object and a sequence of matching `Pet` objects.</span></span>

<span data-ttu-id="d9cd8-141">Dodając drugą `from` klauzulę do kwerendy, ta sekwencja sekwencji jest łączona (lub spłaszczona) w jedną dłuższą sekwencję.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-141">By adding a second `from` clause to the query, this sequence of sequences is combined (or flattened) into one longer sequence.</span></span> <span data-ttu-id="d9cd8-142">Typ elementów końcowej sekwencji jest określony `select` przez klauzulę.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-142">The type of the elements of the final sequence is specified by the `select` clause.</span></span> <span data-ttu-id="d9cd8-143">W tym przykładzie tego typu jest typem `Person.FirstName` `Pet.Name` anonimowym, który składa się z i właściwości dla każdej pasującej pary.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-143">In this example, that type is an anonymous type that consists of the `Person.FirstName` and `Pet.Name` properties for each matching pair.</span></span>

<span data-ttu-id="d9cd8-144">Wynik `query1` jest odpowiednikiem zestawu wyników, które zostałyby `join` uzyskane `into` przy użyciu klauzuli bez klauzuli do wykonania sprzężenia wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-144">The result of `query1` is equivalent to the result set that would have been obtained by using the `join` clause without the `into` clause to perform an inner join.</span></span> <span data-ttu-id="d9cd8-145">Zmienna `query2` demonstruje to równoważne zapytanie.</span><span class="sxs-lookup"><span data-stu-id="d9cd8-145">The `query2` variable demonstrates this equivalent query.</span></span>

[!code-csharp[CsLINQProgJoining#4](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_4.cs)]

## <a name="see-also"></a><span data-ttu-id="d9cd8-146">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="d9cd8-146">See also</span></span>

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [<span data-ttu-id="d9cd8-147">Wykonywanie sprzężeń grupowanych</span><span class="sxs-lookup"><span data-stu-id="d9cd8-147">Perform grouped joins</span></span>](perform-grouped-joins.md)
- [<span data-ttu-id="d9cd8-148">Wykonywanie lewych sprzężeń zewnętrznych</span><span class="sxs-lookup"><span data-stu-id="d9cd8-148">Perform left outer joins</span></span>](perform-left-outer-joins.md)
- [<span data-ttu-id="d9cd8-149">Typy anonimowe</span><span class="sxs-lookup"><span data-stu-id="d9cd8-149">Anonymous types</span></span>](../programming-guide/classes-and-structs/anonymous-types.md)
