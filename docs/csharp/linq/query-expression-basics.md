---
title: Podstawowe informacje o wyrażeniach kwerend
description: Wprowadza pojęcia związane z wyrażenia zapytania
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: d211b0770bdc69f513e4129c818f96650de63e77
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
ms.locfileid: "33288996"
---
# <a name="query-expression-basics"></a><span data-ttu-id="d12c1-103">Podstawowe informacje o wyrażeniach kwerend</span><span class="sxs-lookup"><span data-stu-id="d12c1-103">Query expression basics</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="d12c1-104">Co to jest kwerenda, i jakie zadania wykonuje?</span><span class="sxs-lookup"><span data-stu-id="d12c1-104">What is a query and what does it do?</span></span> 

 <span data-ttu-id="d12c1-105">A *zapytania* zestaw instrukcji w tym artykule opisano, jakie dane należy pobrać źródła danych danego (lub źródeł) i jakie kształt i organizacji zwróconych danych powinny mieć.</span><span class="sxs-lookup"><span data-stu-id="d12c1-105">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="d12c1-106">Zapytanie różni się od wyników, które generuje.</span><span class="sxs-lookup"><span data-stu-id="d12c1-106">A query is distinct from the results that it produces.</span></span>  
  
 <span data-ttu-id="d12c1-107">Ogólnie rzecz biorąc źródło danych jest pogrupowane logicznie sekwencję elementów tego samego rodzaju.</span><span class="sxs-lookup"><span data-stu-id="d12c1-107">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="d12c1-108">Na przykład w tabeli bazy danych SQL zawiera sekwencję wierszy.</span><span class="sxs-lookup"><span data-stu-id="d12c1-108">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="d12c1-109">W pliku XML ma "sekwencji" elementów XML (chociaż są one zorganizowane hierarchicznie w strukturze drzewa).</span><span class="sxs-lookup"><span data-stu-id="d12c1-109">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="d12c1-110">Kolekcja w pamięci zawiera sekwencję obiektów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-110">An in-memory collection contains a sequence of objects.</span></span> 
  
 <span data-ttu-id="d12c1-111">Z punktu widzenia aplikacji określonego typu i struktury oryginalnych danych źródłowych nie jest istotna.</span><span class="sxs-lookup"><span data-stu-id="d12c1-111">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="d12c1-112">Źródło danych jako widzi aplikacji zawsze <xref:System.Collections.Generic.IEnumerable%601> lub <xref:System.Linq.IQueryable%601> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="d12c1-112">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="d12c1-113">Na przykład w składniku LINQ to XML, źródło danych stają się widoczne jako `IEnumerable` \< <xref:System.Xml.Linq.XElement>>.</span><span class="sxs-lookup"><span data-stu-id="d12c1-113">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>  
  
 <span data-ttu-id="d12c1-114">Mając tę sekwencję źródła, zapytania może wykonaj jedną z trzy czynności:</span><span class="sxs-lookup"><span data-stu-id="d12c1-114">Given this source sequence, a query may do one of three things:</span></span>  
  
-   <span data-ttu-id="d12c1-115">Pobrać podzbioru elementów, aby utworzyć nową sekwencję bez modyfikowania poszczególne elementy.</span><span class="sxs-lookup"><span data-stu-id="d12c1-115">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="d12c1-116">Zapytanie może sortowanie i grupowanie zwrócony sekwencji na różne sposoby, jak pokazano w poniższym przykładzie (założono `scores` jest `int[]`):</span><span class="sxs-lookup"><span data-stu-id="d12c1-116">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>  
  
     [!code-csharp[csrefQueryExpBasics#45](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]  
  
-   <span data-ttu-id="d12c1-117">Pobrać sekwencję elementów, jak w poprzednim przykładzie, ale je na nowy typ obiektu transform.</span><span class="sxs-lookup"><span data-stu-id="d12c1-117">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="d12c1-118">Na przykład zapytanie mogą pobrać tylko nazwisk z niektórych rekordów klientów w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="d12c1-118">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="d12c1-119">Lub może pobrać całego rekordu, a następnie użyć jej do utworzenia obiektu w pamięci innego typu, a nawet danych XML przed wygenerowaniem sekwencji wynik końcowy.</span><span class="sxs-lookup"><span data-stu-id="d12c1-119">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="d12c1-120">W poniższym przykładzie przedstawiono projekcji z `int` do `string`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-120">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="d12c1-121">Należy pamiętać, nowy typ `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-121">Note the new type of `highScoresQuery`.</span></span>  
  
     [!code-csharp[csrefQueryExpBasics#46](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]  
  
-   <span data-ttu-id="d12c1-122">Pobierz wartość singleton o źródle danych, takich jak:</span><span class="sxs-lookup"><span data-stu-id="d12c1-122">Retrieve a singleton value about the source data, such as:</span></span>  
  
    -   <span data-ttu-id="d12c1-123">Liczba elementów spełniających określony warunek.</span><span class="sxs-lookup"><span data-stu-id="d12c1-123">The number of elements that match a certain condition.</span></span>  
  
    -   <span data-ttu-id="d12c1-124">Element, który ma największy lub co najmniej wartość.</span><span class="sxs-lookup"><span data-stu-id="d12c1-124">The element that has the greatest or least value.</span></span>  
  
    -   <span data-ttu-id="d12c1-125">Pierwszy element warunku lub Suma określonej wartości w określonym zestawie elementów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-125">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="d12c1-126">Na przykład następujące zapytanie zwraca liczbę wyników większa niż 80 z `scores` tablicy całkowitą:</span><span class="sxs-lookup"><span data-stu-id="d12c1-126">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>  
  
     [!code-csharp[csrefQueryExpBasics#47](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]  
  
     <span data-ttu-id="d12c1-127">W poprzednim przykładzie, zwróć uwagę na użycie nawiasów wokół wyrażenia zapytania przed wywołaniem do `Count` metody.</span><span class="sxs-lookup"><span data-stu-id="d12c1-127">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="d12c1-128">Można również express to przy użyciu nową zmienną do przechowywania konkretnych wynik.</span><span class="sxs-lookup"><span data-stu-id="d12c1-128">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="d12c1-129">Ta technika jest bardziej przejrzysta, ponieważ przechowuje zmiennej, która przechowuje zapytania w oddzielnych przechowujący wynik zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-129">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>  
  
     [!code-csharp[csrefQueryExpBasics#48](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]  
  
 <span data-ttu-id="d12c1-130">W poprzednim przykładzie zapytanie jest wykonywane w wywołaniu `Count`, ponieważ `Count` musi iterację w wynikach w celu ustalenia liczby elementów zwróconych przez `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-130">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>  
  
## <a name="what-is-a-query-expression"></a><span data-ttu-id="d12c1-131">Co to jest wyrażenia zapytania?</span><span class="sxs-lookup"><span data-stu-id="d12c1-131">What is a query expression?</span></span>  

 <span data-ttu-id="d12c1-132">A *zapytania wyrażenie* jest zapytaniem wyrażone w składni zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-132">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="d12c1-133">Wyrażenia zapytania jest konstrukcji języka najwyższej jakości.</span><span class="sxs-lookup"><span data-stu-id="d12c1-133">A query expression is a first-class language construct.</span></span> <span data-ttu-id="d12c1-134">Jest tak samo jak inne wyrażenie i mogą być używane w dowolnym kontekście, w którym wyrażenie C# jest poprawna.</span><span class="sxs-lookup"><span data-stu-id="d12c1-134">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="d12c1-135">Wyrażenia zapytania zawiera zestaw klauzul napisany w składni deklaratywnej podobne do bazy danych SQL lub XQuery.</span><span class="sxs-lookup"><span data-stu-id="d12c1-135">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="d12c1-136">Każdej klauzuli zawiera co najmniej jednego wyrażenia języka C# i wyrażenia te same jest wyrażenia zapytania lub zawiera wyrażenia zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-136">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>  
  
 <span data-ttu-id="d12c1-137">Wyrażenia zapytania musi rozpoczynać się od [z](../language-reference/keywords/from-clause.md) klauzuli i musi się kończyć [wybierz](../language-reference/keywords/select-clause.md) lub [grupy](../language-reference/keywords/group-clause.md) klauzuli.</span><span class="sxs-lookup"><span data-stu-id="d12c1-137">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="d12c1-138">Między pierwszą `from` klauzuli oraz za ostatni `select` lub `group` klauzuli może zawierać co najmniej jedną z klauzul opcjonalne: [gdzie](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [sprzężenia ](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) i nawet dodatkowe [z](../language-reference/keywords/from-clause.md) klauzul.</span><span class="sxs-lookup"><span data-stu-id="d12c1-138">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="d12c1-139">Można również użyć [do](../language-reference/keywords/into.md) — słowo kluczowe, aby włączyć wynik `join` lub `group` klauzuli służyć jako źródło dla klauzul dodatkowych kwerend w jednym wyrażeniu zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-139">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>  
  
### <a name="query-variable"></a><span data-ttu-id="d12c1-140">Zmienną zapytania</span><span class="sxs-lookup"><span data-stu-id="d12c1-140">Query variable</span></span>  
 
 <span data-ttu-id="d12c1-141">W składniku LINQ, zmienną zapytania jest żadnych zmiennej, która przechowuje *zapytania* zamiast *wyniki* zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-141">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="d12c1-142">W szczególności zmienną zapytania jest zawsze typu wyliczalny, który utworzy sekwencję elementów, gdy jest on powtórzyć za pośrednictwem w `foreach` instrukcji lub bezpośrednie wywołanie jego `IEnumerator.MoveNext` metody.</span><span class="sxs-lookup"><span data-stu-id="d12c1-142">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>  
  
 <span data-ttu-id="d12c1-143">Poniższy przykład kodu pokazuje wyrażenia prostego zapytania z jednego źródła danych, jedną klauzulę filtrowania jedną klauzulę porządkowania i nie przekształcania elementy źródłowe.</span><span class="sxs-lookup"><span data-stu-id="d12c1-143">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="d12c1-144">`select` Klauzuli kończy się zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-144">The `select` clause ends the query.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#49](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]  
  
 <span data-ttu-id="d12c1-145">W poprzednim przykładzie `scoreQuery` jest *zmienną zapytania* którego jest czasami określana jako just *zapytania*.</span><span class="sxs-lookup"><span data-stu-id="d12c1-145">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="d12c1-146">Zmienną zapytania są przechowywane żadne dane rzeczywisty wynik, który jest tworzony w `foreach` pętli.</span><span class="sxs-lookup"><span data-stu-id="d12c1-146">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="d12c1-147">I kiedy `foreach` wykonuje instrukcję, wyniki zapytania nie są zwracane przez zmienną zapytania `scoreQuery`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-147">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="d12c1-148">Zamiast są zwracane za pośrednictwem zmiennej iteracji `testScore`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-148">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="d12c1-149">`scoreQuery` Zmiennej można powtórzyć na sekundę `foreach` pętli.</span><span class="sxs-lookup"><span data-stu-id="d12c1-149">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="d12c1-150">Takie same wyniki powoduje wygenerowanie tak długo, jak ten plik ani źródła danych został zmodyfikowany.</span><span class="sxs-lookup"><span data-stu-id="d12c1-150">It will produce the same results as long as neither it nor the data source has been modified.</span></span>  
  
 <span data-ttu-id="d12c1-151">Zmienną zapytania mogą być przechowywane zapytania, które są jest wyrażone w składni zapytania lub składni metody lub kombinację obu.</span><span class="sxs-lookup"><span data-stu-id="d12c1-151">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="d12c1-152">W poniższych przykładach zarówno `queryMajorCities` i `queryMajorCities2` są zmiennych zapytania:</span><span class="sxs-lookup"><span data-stu-id="d12c1-152">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#50](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]  
  
 <span data-ttu-id="d12c1-153">Z drugiej strony w poniższych dwóch przykładach pokazano zmiennych, które nie są zmiennymi zapytania, mimo że każda jest inicjowany z zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-153">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="d12c1-154">Nie są one zmiennych zapytania, ponieważ zapisują wyników:</span><span class="sxs-lookup"><span data-stu-id="d12c1-154">They are not query variables because they store results:</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#51](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]  
  
 <span data-ttu-id="d12c1-155">Aby uzyskać więcej informacji o różnych sposobach express zapytań, zobacz [składnia zapytania i metody w technologii LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-155">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>  
  
#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="d12c1-156">Jawne i niejawne, wpisując zmiennych zapytania</span><span class="sxs-lookup"><span data-stu-id="d12c1-156">Explicit and implicit typing of query variables</span></span>  
 
 <span data-ttu-id="d12c1-157">Ta dokumentacja zwykle zawiera jawnego typu zmienną zapytania aby pokazać relację typu zmienną zapytania i [klauzuli select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-157">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="d12c1-158">Jednak umożliwia także [var](../language-reference/keywords/var.md) — słowo kluczowe nakazać kompilatora do wywnioskowania typu zmienną zapytania (lub lokalna zmienna) w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="d12c1-158">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="d12c1-159">Na przykład przykład zapytania, które zostało przedstawione wcześniej w tym temacie może zostać wyrażona przy użyciu niejawnego wpisując:</span><span class="sxs-lookup"><span data-stu-id="d12c1-159">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#52](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]  
  
 <span data-ttu-id="d12c1-160">Aby uzyskać więcej informacji, zobacz [niejawnie wpisane zmienne lokalne](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) i [relacje typu w składniku LINQ zapytania operacji](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-160">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>  
  
### <a name="starting-a-query-expression"></a><span data-ttu-id="d12c1-161">Uruchamianie wyrażenia zapytania</span><span class="sxs-lookup"><span data-stu-id="d12c1-161">Starting a query expression</span></span>  
 
 <span data-ttu-id="d12c1-162">Wyrażenia zapytania musi rozpoczynać się od `from` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="d12c1-162">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="d12c1-163">Określa źródło danych, wraz z zmiennej zakresu.</span><span class="sxs-lookup"><span data-stu-id="d12c1-163">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="d12c1-164">Zmienna zakresu reprezentuje każdy element w sekwencji źródłowej przejść wzdłuż sekwencji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="d12c1-164">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="d12c1-165">Zmienna zakresu jest silnie typizowane oparte na typ elementów w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="d12c1-165">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="d12c1-166">W poniższym przykładzie ponieważ `countries` jest tablicą `Country` obiekty, również jest typu zmienną zakresu `Country`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-166">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="d12c1-167">Ponieważ silnie jest typu zmienną zakresu, można użyć kropka można uzyskać dostępu do żadnych dostępnych elementów członkowskich tego typu.</span><span class="sxs-lookup"><span data-stu-id="d12c1-167">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#53](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]  
  
 <span data-ttu-id="d12c1-168">Zmienna zakresu znajduje się w zakresie, dopóki zapytanie zostanie zakończone średnikami lub z *kontynuacji* klauzuli.</span><span class="sxs-lookup"><span data-stu-id="d12c1-168">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>  
  
 <span data-ttu-id="d12c1-169">Wyrażenia zapytania mogą zawierać wiele `from` klauzul.</span><span class="sxs-lookup"><span data-stu-id="d12c1-169">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="d12c1-170">Użyj dodatkowych `from` klauzule podczas każdego elementu w sekwencji źródłowej jest elementem kolekcji lub zawiera on kolekcję.</span><span class="sxs-lookup"><span data-stu-id="d12c1-170">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="d12c1-171">Załóżmy na przykład, że masz kolekcję `Country` obiektów, z których każdy zawiera kolekcję `City` obiektów o nazwie `Cities`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-171">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="d12c1-172">W zapytaniu `City` obiektów w każdej `Country`, użyj dwóch `from` klauzule, jak pokazano poniżej:</span><span class="sxs-lookup"><span data-stu-id="d12c1-172">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#54](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]  
  
 <span data-ttu-id="d12c1-173">Aby uzyskać więcej informacji, zobacz [klauzuli from](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-173">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>  
  
### <a name="ending-a-query-expression"></a><span data-ttu-id="d12c1-174">Zakończenie wyrażenia zapytania</span><span class="sxs-lookup"><span data-stu-id="d12c1-174">Ending a query expression</span></span>  
 
 <span data-ttu-id="d12c1-175">Wyrażenia zapytania musi kończyć się albo `group` klauzuli lub `select` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="d12c1-175">A query expression must end with either a `group` clause or a `select` clause.</span></span>  
  
#### <a name="group-clause"></a><span data-ttu-id="d12c1-176">group — Klauzula</span><span class="sxs-lookup"><span data-stu-id="d12c1-176">group clause</span></span>  
 
 <span data-ttu-id="d12c1-177">Użyj `group` klauzuli, aby utworzyć sekwencję grup są zorganizowane według klucza, który określisz.</span><span class="sxs-lookup"><span data-stu-id="d12c1-177">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="d12c1-178">Klucz może być dowolnego typu danych.</span><span class="sxs-lookup"><span data-stu-id="d12c1-178">The key can be any data type.</span></span> <span data-ttu-id="d12c1-179">Na przykład poniższe zapytanie tworzy sekwencję grupy, która zawiera co najmniej jeden `Country` obiektów, którego klucz `char` wartość.</span><span class="sxs-lookup"><span data-stu-id="d12c1-179">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#55](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]  
  
 <span data-ttu-id="d12c1-180">Aby uzyskać więcej informacji na temat grupowania, zobacz [klauzuli group](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-180">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>  
  
#### <a name="select-clause"></a><span data-ttu-id="d12c1-181">select — Klauzula</span><span class="sxs-lookup"><span data-stu-id="d12c1-181">select clause</span></span>  
 <span data-ttu-id="d12c1-182">Użyj `select` klauzuli do produkcji wszystkich typów sekwencji.</span><span class="sxs-lookup"><span data-stu-id="d12c1-182">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="d12c1-183">Prosty `select` klauzuli po prostu tworzy sekwencję tego samego typu obiektów jako obiekty, które są zawarte w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="d12c1-183">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="d12c1-184">W tym przykładzie źródło danych zawiera `Country` obiektów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-184">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="d12c1-185">`orderby` Tylko Sortuje elementy na nową kolejność w klauzuli i `select` klauzuli tworzy sekwencję kolejnos'ci `Country` obiektów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-185">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#56](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]  
  
 <span data-ttu-id="d12c1-186">`select` Klauzuli może służyć do przekształcania danych źródłowych sekwencji nowych typów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-186">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="d12c1-187">Ta transformacja nosi również *projekcji*.</span><span class="sxs-lookup"><span data-stu-id="d12c1-187">This transformation is also named a *projection*.</span></span> <span data-ttu-id="d12c1-188">W poniższym przykładzie `select` klauzuli *projekty* sekwencję typy anonimowe, która zawiera tylko podzbiór pól w oryginalnym elemencie.</span><span class="sxs-lookup"><span data-stu-id="d12c1-188">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="d12c1-189">Należy pamiętać, że nowe obiekty są inicjowane za pomocą inicjatora obiektów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-189">Note that the new objects are initialized by using an object initializer.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#57](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]  
  
 <span data-ttu-id="d12c1-190">Aby uzyskać więcej informacji na temat wszystkich metod który `select` klauzuli może służyć do przekształcania źródła danych, zobacz [klauzuli select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-190">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>  
  
#### <a name="continuations-with-into"></a><span data-ttu-id="d12c1-191">Kontynuacje z "do"</span><span class="sxs-lookup"><span data-stu-id="d12c1-191">Continuations with "into"</span></span>  
 
 <span data-ttu-id="d12c1-192">Można użyć `into` — słowo kluczowe w `select` lub `group` klauzuli, aby utworzyć tymczasowy identyfikator, który przechowuje zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-192">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="d12c1-193">W tym musi wykonywać operacje dodatkowe zapytania w zapytaniu po zgrupowaniu lub wybierz operacji.</span><span class="sxs-lookup"><span data-stu-id="d12c1-193">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="d12c1-194">W poniższym przykładzie `countries` są pogrupowane według populacji w zakresach 10 milionów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-194">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="d12c1-195">Po tych grup zostaną utworzone, dodatkowe klauzul filtru się niektóre grupy, a następnie do sortowania grup w kolejności rosnącej kolejności.</span><span class="sxs-lookup"><span data-stu-id="d12c1-195">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="d12c1-196">Aby wykonać te dodatkowe operacje, kontynuacji reprezentowany przez `countryGroup` jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="d12c1-196">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#58](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]  
  
 <span data-ttu-id="d12c1-197">Aby uzyskać więcej informacji, zobacz [do](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-197">For more information, see [into](../language-reference/keywords/into.md).</span></span>  
  
### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="d12c1-198">Filtrowanie, kolejność i dołączenie</span><span class="sxs-lookup"><span data-stu-id="d12c1-198">Filtering, ordering, and joining</span></span>

 <span data-ttu-id="d12c1-199">Między początkową `from` klauzul i zakończenie `select` lub `group` klauzuli, inne klauzule (`where`, `join`, `orderby`, `from`, `let`) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="d12c1-199">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="d12c1-200">Wszelkie opcjonalna klauzula może służyć zero lub wiele razy w treści wyrażenia zapytania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-200">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>  
  
#### <a name="where-clause"></a><span data-ttu-id="d12c1-201">Klauzula where</span><span class="sxs-lookup"><span data-stu-id="d12c1-201">where clause</span></span>  

 <span data-ttu-id="d12c1-202">Użyj `where` klauzuli, aby filtrować elementy z źródła danych oparte na co najmniej jednego wyrażenia predykatu.</span><span class="sxs-lookup"><span data-stu-id="d12c1-202">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="d12c1-203">`where` Klauzuli w poniższym przykładzie ma jeden predykat z dwa warunki.</span><span class="sxs-lookup"><span data-stu-id="d12c1-203">The `where` clause in the following example has one predicate with two conditions.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#59](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]  
  
 <span data-ttu-id="d12c1-204">Aby uzyskać więcej informacji, zobacz [gdzie klauzuli](../language-reference/keywords/where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-204">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>  
  
#### <a name="orderby-clause"></a><span data-ttu-id="d12c1-205">Klauzula orderby</span><span class="sxs-lookup"><span data-stu-id="d12c1-205">orderby clause</span></span>

 <span data-ttu-id="d12c1-206">Użyj `orderby` klauzuli sortowania wyników w porządku rosnącym lub malejącym.</span><span class="sxs-lookup"><span data-stu-id="d12c1-206">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="d12c1-207">Można również określić kolejność sortowania dodatkowej.</span><span class="sxs-lookup"><span data-stu-id="d12c1-207">You can also specify secondary sort orders.</span></span> <span data-ttu-id="d12c1-208">Poniższy przykład sortuje podstawowego `country` obiektów przy użyciu `Area` właściwości.</span><span class="sxs-lookup"><span data-stu-id="d12c1-208">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="d12c1-209">Następnie wykonuje dodatkowej sortowania za pomocą `Population` właściwości.</span><span class="sxs-lookup"><span data-stu-id="d12c1-209">It then performs a secondary sort by using the `Population` property.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#60](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]  
  
 <span data-ttu-id="d12c1-210">`ascending` — Słowo kluczowe jest opcjonalny; Jeśli nie kolejność jest określana jest domyślny porządek sortowania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-210">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="d12c1-211">Aby uzyskać więcej informacji, zobacz [klauzula orderby](../language-reference/keywords/orderby-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-211">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>  
  
#### <a name="join-clause"></a><span data-ttu-id="d12c1-212">Klauzula join</span><span class="sxs-lookup"><span data-stu-id="d12c1-212">join clause</span></span>

 <span data-ttu-id="d12c1-213">Użyj `join` klauzuli, aby skojarzyć i/lub połączyć elementy z jednego źródła danych z elementami z innego źródła danych na podstawie równości porównania między określone klucze w każdym elemencie.</span><span class="sxs-lookup"><span data-stu-id="d12c1-213">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="d12c1-214">W składniku LINQ operacji łączenia są wykonywane na obiekty, których elementy mają różne typy sekwencji.</span><span class="sxs-lookup"><span data-stu-id="d12c1-214">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="d12c1-215">Po dołączeniu dwóch sekwencji, należy użyć `select` lub `group` instrukcji, aby określić, który element mają być przechowywane w sekwencji danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="d12c1-215">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="d12c1-216">Umożliwia także typu anonimowego do łączenia z każdego zestawu skojarzonych elementów właściwości w nowy typ sekwencji danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="d12c1-216">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="d12c1-217">W poniższym przykładzie `prod` obiekty, których `Category` właściwość odpowiada jednej z kategorii w `categories` tablicy ciągów.</span><span class="sxs-lookup"><span data-stu-id="d12c1-217">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="d12c1-218">Produkty których `Category` nie pasuje do dowolnego ciągu w `categories` są odfiltrowywane. `select` Nowy typ, którego właściwości są pobierane z obu projektów instrukcji `cat` i `prod`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-218">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#61](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]  
  
 <span data-ttu-id="d12c1-219">Można również wykonywać sprzężenia grupy zapisując wyniki `join` operacji do zmiennej tymczasowej, za pomocą [do](../language-reference/keywords/into.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="d12c1-219">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="d12c1-220">Aby uzyskać więcej informacji, zobacz [klauzuli join](../language-reference/keywords/join-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-220">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>  
  
#### <a name="let-clause"></a><span data-ttu-id="d12c1-221">Klauzula Let</span><span class="sxs-lookup"><span data-stu-id="d12c1-221">let clause</span></span> 

 <span data-ttu-id="d12c1-222">Użyj `let` klauzuli, aby przechowywać wynik wyrażenia, takie jak wywołania metody w nowej zmiennej zakresu.</span><span class="sxs-lookup"><span data-stu-id="d12c1-222">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="d12c1-223">W poniższym przykładzie zmienna zakresu `firstName` przechowuje pierwszy element tablicy ciągów, które są zwracane przez `Split`.</span><span class="sxs-lookup"><span data-stu-id="d12c1-223">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#62](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]  
  
 <span data-ttu-id="d12c1-224">Aby uzyskać więcej informacji, zobacz [klauzula let](../language-reference/keywords/let-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-224">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>  
  
### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="d12c1-225">Podzapytań w wyrażeniach kwerend</span><span class="sxs-lookup"><span data-stu-id="d12c1-225">Subqueries in a query expression</span></span>  

 <span data-ttu-id="d12c1-226">Sam zapytanie klauzula może zawierać wyrażenia zapytania jest czasami nazywany *podzapytania*.</span><span class="sxs-lookup"><span data-stu-id="d12c1-226">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="d12c1-227">Każdy podzapytania rozpoczyna się od jego własnej `from` klauzuli, która nie musi wskazywać tego samego źródła danych, w pierwszym `from` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="d12c1-227">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="d12c1-228">Na przykład następujące zapytanie zawiera wyrażenia zapytania, który jest używany w instrukcji select, aby pobrać wyniki operacji grupowania.</span><span class="sxs-lookup"><span data-stu-id="d12c1-228">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>  
  
 [!code-csharp[csrefQueryExpBasics#63](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]  
  
 <span data-ttu-id="d12c1-229">Aby uzyskać więcej informacji, zobacz [porady: wykonanie podzapytania w operacji grupowania](perform-a-subquery-on-a-grouping-operation.md).</span><span class="sxs-lookup"><span data-stu-id="d12c1-229">For more information, see [How to: perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d12c1-230">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="d12c1-230">See Also</span></span>  
 [<span data-ttu-id="d12c1-231">Podręcznik programowania C#</span><span class="sxs-lookup"><span data-stu-id="d12c1-231">C# programming guide</span></span>](../programming-guide/index.md)  
 [<span data-ttu-id="d12c1-232">Wyrażenia zapytań LINQ</span><span class="sxs-lookup"><span data-stu-id="d12c1-232">LINQ query expressions</span></span>](index.md)  
 [<span data-ttu-id="d12c1-233">Słowa kluczowe zapytania (LINQ)</span><span class="sxs-lookup"><span data-stu-id="d12c1-233">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)  
 [<span data-ttu-id="d12c1-234">Operatory standardowe zapytań — omówienie</span><span class="sxs-lookup"><span data-stu-id="d12c1-234">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)
