---
title: Podstawy wyrażeń zapytań (LINQ w języku C#)
description: Wprowadza pojęcia związane z wyrażeniami kwerend
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: 83beaa82d4b4b42ff9da5230edddd391b33a0717
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173357"
---
# <a name="query-expression-basics"></a><span data-ttu-id="693c7-103">Podstawowe informacje o wyrażeniach zapytań</span><span class="sxs-lookup"><span data-stu-id="693c7-103">Query expression basics</span></span>

<span data-ttu-id="693c7-104">W tym artykule przedstawiono podstawowe pojęcia związane z wyrażeniami kwerend w języku C#.</span><span class="sxs-lookup"><span data-stu-id="693c7-104">This article introduces the basic concepts related to query expressions in C#.</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="693c7-105">Co to jest zapytanie i co robi?</span><span class="sxs-lookup"><span data-stu-id="693c7-105">What is a query and what does it do?</span></span>

<span data-ttu-id="693c7-106">*Kwerenda* to zestaw instrukcji opisujących, jakie dane pobrać z danego źródła danych (lub źródeł) oraz jaki kształt i organizację powinny mieć zwrócone dane.</span><span class="sxs-lookup"><span data-stu-id="693c7-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="693c7-107">Kwerenda różni się od wyników, które generuje.</span><span class="sxs-lookup"><span data-stu-id="693c7-107">A query is distinct from the results that it produces.</span></span>

<span data-ttu-id="693c7-108">Ogólnie rzecz biorąc dane źródłowe jest zorganizowana logicznie jako sekwencja elementów tego samego rodzaju.</span><span class="sxs-lookup"><span data-stu-id="693c7-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="693c7-109">Na przykład tabela bazy danych SQL zawiera sekwencję wierszy.</span><span class="sxs-lookup"><span data-stu-id="693c7-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="693c7-110">W pliku XML istnieje "sekwencja" elementów XML (chociaż są one zorganizowane hierarchicznie w strukturze drzewa).</span><span class="sxs-lookup"><span data-stu-id="693c7-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="693c7-111">Kolekcja w pamięci zawiera sekwencję obiektów.</span><span class="sxs-lookup"><span data-stu-id="693c7-111">An in-memory collection contains a sequence of objects.</span></span>

<span data-ttu-id="693c7-112">Z punktu widzenia aplikacji określony typ i struktura oryginalnych danych źródłowych nie jest ważna.</span><span class="sxs-lookup"><span data-stu-id="693c7-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="693c7-113">Aplikacja zawsze widzi dane <xref:System.Collections.Generic.IEnumerable%601> źródłowe <xref:System.Linq.IQueryable%601> jako lub kolekcji.</span><span class="sxs-lookup"><span data-stu-id="693c7-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="693c7-114">Na przykład w LINQ do XML dane źródłowe `IEnumerable` \< <xref:System.Xml.Linq.XElement> są widoczne jako>.</span><span class="sxs-lookup"><span data-stu-id="693c7-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>

<span data-ttu-id="693c7-115">Biorąc pod uwagę tę sekwencję źródłową, kwerenda może wykonać jedną z trzech czynności:</span><span class="sxs-lookup"><span data-stu-id="693c7-115">Given this source sequence, a query may do one of three things:</span></span>

- <span data-ttu-id="693c7-116">Pobierz podzbiór elementów, aby utworzyć nową sekwencję bez modyfikowania poszczególnych elementów.</span><span class="sxs-lookup"><span data-stu-id="693c7-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="693c7-117">Kwerenda może następnie sortować lub grupować zwróconą sekwencję na `scores` różne `int[]`sposoby, jak pokazano w poniższym przykładzie (przyzałożeniu, że jest):</span><span class="sxs-lookup"><span data-stu-id="693c7-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>

    [!code-csharp[csrefQueryExpBasics#45](~/samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]

- <span data-ttu-id="693c7-118">Pobierz sekwencję elementów, jak w poprzednim przykładzie, ale przekształcić je do nowego typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="693c7-118">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="693c7-119">Na przykład kwerenda może pobrać tylko nazwiska z niektórych rekordów klientów w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="693c7-119">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="693c7-120">Lub może pobrać pełny rekord, a następnie użyć go do skonstruowania innego typu obiektu w pamięci lub nawet danych XML przed wygenerowaniem końcowej sekwencji wyników.</span><span class="sxs-lookup"><span data-stu-id="693c7-120">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="693c7-121">W poniższym przykładzie przedstawiono `int` projekcję od . `string`</span><span class="sxs-lookup"><span data-stu-id="693c7-121">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="693c7-122">Zwróć uwagę `highScoresQuery`na nowy typ pliku .</span><span class="sxs-lookup"><span data-stu-id="693c7-122">Note the new type of `highScoresQuery`.</span></span>

    [!code-csharp[csrefQueryExpBasics#46](~/samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]

- <span data-ttu-id="693c7-123">Pobierz wartość singleton o danych źródłowych, takich jak:</span><span class="sxs-lookup"><span data-stu-id="693c7-123">Retrieve a singleton value about the source data, such as:</span></span>

  - <span data-ttu-id="693c7-124">Liczba elementów, które pasują do pewnego warunku.</span><span class="sxs-lookup"><span data-stu-id="693c7-124">The number of elements that match a certain condition.</span></span>

  - <span data-ttu-id="693c7-125">Element, który ma największą lub najmniejszą wartość.</span><span class="sxs-lookup"><span data-stu-id="693c7-125">The element that has the greatest or least value.</span></span>

  - <span data-ttu-id="693c7-126">Pierwszy element, który pasuje do warunku lub suma określonych wartości w określonym zestawie elementów.</span><span class="sxs-lookup"><span data-stu-id="693c7-126">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="693c7-127">Na przykład następująca kwerenda zwraca liczbę wyników `scores` większą niż 80 z tablicy całkowitej:</span><span class="sxs-lookup"><span data-stu-id="693c7-127">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>

    [!code-csharp[csrefQueryExpBasics#47](~/samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]

    <span data-ttu-id="693c7-128">W poprzednim przykładzie należy zwrócić uwagę na użycie nawiasów wokół wyrażenia `Count` kwerendy przed wywołaniem metody.</span><span class="sxs-lookup"><span data-stu-id="693c7-128">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="693c7-129">Można również wyrazić to za pomocą nowej zmiennej do przechowywania wynik betonu.</span><span class="sxs-lookup"><span data-stu-id="693c7-129">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="693c7-130">Ta technika jest bardziej czytelny, ponieważ utrzymuje zmienną, która przechowuje kwerendę oddzielnie od kwerendy, która przechowuje wynik.</span><span class="sxs-lookup"><span data-stu-id="693c7-130">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>

    [!code-csharp[csrefQueryExpBasics#48](~/samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]

<span data-ttu-id="693c7-131">W poprzednim przykładzie kwerenda jest wykonywana `Count`w `Count` wywołaniu , ponieważ musi iterate nad wynikami `highScoresQuery`w celu określenia liczby elementów zwracanych przez .</span><span class="sxs-lookup"><span data-stu-id="693c7-131">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>

## <a name="what-is-a-query-expression"></a><span data-ttu-id="693c7-132">Co to jest wyrażenie zapytania?</span><span class="sxs-lookup"><span data-stu-id="693c7-132">What is a query expression?</span></span>

<span data-ttu-id="693c7-133">*Wyrażenie kwerendy* jest kwerendą wyrażoną w składni kwerendy.</span><span class="sxs-lookup"><span data-stu-id="693c7-133">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="693c7-134">Wyrażenie zapytania jest konstrukcją języka pierwszej klasy.</span><span class="sxs-lookup"><span data-stu-id="693c7-134">A query expression is a first-class language construct.</span></span> <span data-ttu-id="693c7-135">Jest tak jak każde inne wyrażenie i może być używany w dowolnym kontekście, w którym wyrażenie C# jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="693c7-135">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="693c7-136">Wyrażenie kwerendy składa się z zestawu klauzul zapisanych w składni deklaratywnej podobnej do SQL lub XQuery.</span><span class="sxs-lookup"><span data-stu-id="693c7-136">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="693c7-137">Każda klauzula z kolei zawiera co najmniej jedno wyrażenie C#, a te wyrażenia mogą być wyrażeniem kwerendy lub zawierać wyrażenie kwerendy.</span><span class="sxs-lookup"><span data-stu-id="693c7-137">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>

<span data-ttu-id="693c7-138">Wyrażenie kwerendy musi zaczynać się od klauzuli [from](../language-reference/keywords/from-clause.md) i musi kończyć się klauzulą [select](../language-reference/keywords/select-clause.md) lub [group.](../language-reference/keywords/group-clause.md)</span><span class="sxs-lookup"><span data-stu-id="693c7-138">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="693c7-139">Między `from` pierwszą klauzulą `select` `group` a ostatnią lub klauzulą może zawierać jedną lub więcej z tych klauzul opcjonalnych: [gdzie](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [niech,](../language-reference/keywords/let-clause.md) a nawet dodatkowe [z](../language-reference/keywords/from-clause.md) klauzul.</span><span class="sxs-lookup"><span data-stu-id="693c7-139">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="693c7-140">Można również użyć [do](../language-reference/keywords/into.md) słowa kluczowego, `join` `group` aby włączyć wynik lub klauzuli służyć jako źródło dodatkowych klauzul kwerendy w tym samym wyrażeniu kwerendy.</span><span class="sxs-lookup"><span data-stu-id="693c7-140">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>

### <a name="query-variable"></a><span data-ttu-id="693c7-141">Zmienna kwerendy</span><span class="sxs-lookup"><span data-stu-id="693c7-141">Query variable</span></span>

<span data-ttu-id="693c7-142">W LINQ zmiennej kwerendy jest dowolna zmienna, która przechowuje *kwerendę* zamiast *wyników* kwerendy.</span><span class="sxs-lookup"><span data-stu-id="693c7-142">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="693c7-143">W szczególności zmienna kwerendy jest zawsze wyliczalny typ, który będzie generować sekwencję elementów, gdy jest iterowany w `foreach` instrukcji lub bezpośrednie wywołanie jego `IEnumerator.MoveNext` metody.</span><span class="sxs-lookup"><span data-stu-id="693c7-143">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>

<span data-ttu-id="693c7-144">Poniższy przykład kodu przedstawia proste wyrażenie kwerendy z jednym źródłem danych, jedną klauzulą filtrowania, jedną klauzulą porządkową i bez przekształcania elementów źródłowych.</span><span class="sxs-lookup"><span data-stu-id="693c7-144">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="693c7-145">Klauzula `select` kończy kwerendę.</span><span class="sxs-lookup"><span data-stu-id="693c7-145">The `select` clause ends the query.</span></span>

[!code-csharp[csrefQueryExpBasics#49](~/samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]

<span data-ttu-id="693c7-146">W poprzednim przykładzie `scoreQuery` jest *zmienna zapytania,* która jest czasami określana jako tylko *kwerenda*.</span><span class="sxs-lookup"><span data-stu-id="693c7-146">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="693c7-147">Zmienna kwerendy przechowuje żadnych rzeczywistych danych `foreach` wyników, który jest produkowany w pętli.</span><span class="sxs-lookup"><span data-stu-id="693c7-147">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="693c7-148">A gdy `foreach` instrukcja jest wykonywana, wyniki kwerendy `scoreQuery`nie są zwracane za pośrednictwem zmiennej kwerendy .</span><span class="sxs-lookup"><span data-stu-id="693c7-148">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="693c7-149">Są one raczej zwracane za pośrednictwem zmiennej `testScore`iteracji .</span><span class="sxs-lookup"><span data-stu-id="693c7-149">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="693c7-150">Zmienna `scoreQuery` może być iterowana `foreach` w drugiej pętli.</span><span class="sxs-lookup"><span data-stu-id="693c7-150">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="693c7-151">Będzie produkować takie same wyniki, tak długo, jak ani ona, ani źródło danych nie został zmodyfikowany.</span><span class="sxs-lookup"><span data-stu-id="693c7-151">It will produce the same results as long as neither it nor the data source has been modified.</span></span>

<span data-ttu-id="693c7-152">Zmienna kwerendy może przechowywać kwerendę wyrażoną w składni kwerendy lub składni metody lub kombinację tych dwóch.</span><span class="sxs-lookup"><span data-stu-id="693c7-152">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="693c7-153">W poniższych przykładach `queryMajorCities` `queryMajorCities2` oba i są zmienne zapytania:</span><span class="sxs-lookup"><span data-stu-id="693c7-153">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>

[!code-csharp[csrefQueryExpBasics#50](~/samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]

<span data-ttu-id="693c7-154">Z drugiej strony w poniższych dwóch przykładach przedstawiono zmienne, które nie są zmienne kwerendy, mimo że każdy jest inicjowany za pomocą kwerendy.</span><span class="sxs-lookup"><span data-stu-id="693c7-154">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="693c7-155">Nie są one zmienne kwerendy, ponieważ przechowują wyniki:</span><span class="sxs-lookup"><span data-stu-id="693c7-155">They are not query variables because they store results:</span></span>

[!code-csharp[csrefQueryExpBasics#51](~/samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]

<span data-ttu-id="693c7-156">Aby uzyskać więcej informacji na temat różnych sposobów wyrażania zapytań, zobacz [Składnia kwerendy i składnia metody w pliku LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-156">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>

#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="693c7-157">Jawne i niejawne wpisywanie zmiennych zapytania</span><span class="sxs-lookup"><span data-stu-id="693c7-157">Explicit and implicit typing of query variables</span></span>

<span data-ttu-id="693c7-158">Ta dokumentacja zwykle zawiera jawny typ zmiennej kwerendy w celu wyświetlenia relacji typu między zmienną kwerendy a [klauzulą select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-158">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="693c7-159">Jednak można również użyć [var](../language-reference/keywords/var.md) słowa kluczowego, aby poinstruować kompilator, aby wywnioskować typ zmiennej kwerendy (lub dowolnej innej zmiennej lokalnej) w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="693c7-159">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="693c7-160">Na przykład przykład kwerendy, który został pokazany wcześniej w tym temacie można również wyrazić za pomocą niejawnego wpisywania:</span><span class="sxs-lookup"><span data-stu-id="693c7-160">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>

[!code-csharp[csrefQueryExpBasics#52](~/samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]

<span data-ttu-id="693c7-161">Aby uzyskać więcej informacji, zobacz [Niejawnie wpisane zmienne lokalne](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) i [Relacje typu w operacjach kwerend LINQ](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-161">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>

### <a name="starting-a-query-expression"></a><span data-ttu-id="693c7-162">Rozpoczynanie wyrażenia kwerendy</span><span class="sxs-lookup"><span data-stu-id="693c7-162">Starting a query expression</span></span>

<span data-ttu-id="693c7-163">Wyrażenie kwerendy musi `from` zaczynać się od klauzuli.</span><span class="sxs-lookup"><span data-stu-id="693c7-163">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="693c7-164">Określa źródło danych wraz ze zmienną zakresu.</span><span class="sxs-lookup"><span data-stu-id="693c7-164">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="693c7-165">Zmienna zakresu reprezentuje każdy kolejny element w sekwencji źródłowej, gdy sekwencja źródłowa jest przemierzana.</span><span class="sxs-lookup"><span data-stu-id="693c7-165">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="693c7-166">Zmienna zakresu jest silnie typizowany na podstawie typu elementów w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="693c7-166">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="693c7-167">W poniższym przykładzie, ponieważ `countries` `Country` jest tablicą obiektów, zmienna `Country`zakresu jest również wpisana jako .</span><span class="sxs-lookup"><span data-stu-id="693c7-167">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="693c7-168">Ponieważ zmienna zakresu jest silnie typizona, można użyć operatora kropki, aby uzyskać dostęp do wszystkich dostępnych elementów członkowskich tego typu.</span><span class="sxs-lookup"><span data-stu-id="693c7-168">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>

[!code-csharp[csrefQueryExpBasics#53](~/samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]

<span data-ttu-id="693c7-169">Zmienna zakresu znajduje się w zakresie, dopóki kwerenda nie zostanie zakończona średnikiem lub klauzulą *kontynuacji.*</span><span class="sxs-lookup"><span data-stu-id="693c7-169">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>

<span data-ttu-id="693c7-170">Wyrażenie kwerendy może `from` zawierać wiele klauzul.</span><span class="sxs-lookup"><span data-stu-id="693c7-170">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="693c7-171">Użyj `from` dodatkowych klauzul, gdy każdy element w sekwencji źródłowej jest sama kolekcja lub zawiera kolekcję.</span><span class="sxs-lookup"><span data-stu-id="693c7-171">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="693c7-172">Załóżmy na przykład, że `Country` masz kolekcję obiektów, `City` z `Cities`których każdy zawiera kolekcję obiektów o nazwie .</span><span class="sxs-lookup"><span data-stu-id="693c7-172">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="693c7-173">Aby zbadać `City` obiekty `Country`w `from` każdym z nich, należy użyć dwóch klauzul, jak pokazano poniżej:</span><span class="sxs-lookup"><span data-stu-id="693c7-173">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>

[!code-csharp[csrefQueryExpBasics#54](~/samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]

<span data-ttu-id="693c7-174">Aby uzyskać więcej informacji, zobacz [z klauzuli](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-174">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>

### <a name="ending-a-query-expression"></a><span data-ttu-id="693c7-175">Kończenie wyrażenia kwerendy</span><span class="sxs-lookup"><span data-stu-id="693c7-175">Ending a query expression</span></span>

<span data-ttu-id="693c7-176">Wyrażenie kwerendy musi kończyć `group` się `select` klauzulą lub klauzulą.</span><span class="sxs-lookup"><span data-stu-id="693c7-176">A query expression must end with either a `group` clause or a `select` clause.</span></span>

#### <a name="group-clause"></a><span data-ttu-id="693c7-177">group — Klauzula</span><span class="sxs-lookup"><span data-stu-id="693c7-177">group clause</span></span>

<span data-ttu-id="693c7-178">Klauzula `group` służy do tworzenia sekwencji grup zorganizowanych według klucza, który określisz.</span><span class="sxs-lookup"><span data-stu-id="693c7-178">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="693c7-179">Kluczem może być dowolny typ danych.</span><span class="sxs-lookup"><span data-stu-id="693c7-179">The key can be any data type.</span></span> <span data-ttu-id="693c7-180">Na przykład następująca kwerenda tworzy sekwencję grup, która zawiera jeden lub więcej `Country` obiektów i których klucz jest wartością. `char`</span><span class="sxs-lookup"><span data-stu-id="693c7-180">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>

[!code-csharp[csrefQueryExpBasics#55](~/samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]

<span data-ttu-id="693c7-181">Aby uzyskać więcej informacji na temat grupowania, zobacz [klauzulę grupy](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-181">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>

#### <a name="select-clause"></a><span data-ttu-id="693c7-182">select — Klauzula</span><span class="sxs-lookup"><span data-stu-id="693c7-182">select clause</span></span>

<span data-ttu-id="693c7-183">Użyj `select` klauzuli do tworzenia wszystkich innych typów sekwencji.</span><span class="sxs-lookup"><span data-stu-id="693c7-183">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="693c7-184">Prosta `select` klauzula po prostu tworzy sekwencję tego samego typu obiektów jako obiekty, które są zawarte w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="693c7-184">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="693c7-185">W tym przykładzie źródło `Country` danych zawiera obiekty.</span><span class="sxs-lookup"><span data-stu-id="693c7-185">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="693c7-186">Klauzula `orderby` po prostu sortuje elementy `select` w nowej kolejności i klauzula `Country` tworzy sekwencję obiektów o zmianach kolejności.</span><span class="sxs-lookup"><span data-stu-id="693c7-186">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>

[!code-csharp[csrefQueryExpBasics#56](~/samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]

<span data-ttu-id="693c7-187">Klauzula `select` może służyć do przekształcania danych źródłowych w sekwencje nowych typów.</span><span class="sxs-lookup"><span data-stu-id="693c7-187">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="693c7-188">Ta transformacja jest również nazywana *projekcją*.</span><span class="sxs-lookup"><span data-stu-id="693c7-188">This transformation is also named a *projection*.</span></span> <span data-ttu-id="693c7-189">W poniższym przykładzie `select` klauzula *wyświetla* sekwencję typów anonimowych, która zawiera tylko podzbiór pól w oryginalnym elemencie.</span><span class="sxs-lookup"><span data-stu-id="693c7-189">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="693c7-190">Należy zauważyć, że nowe obiekty są inicjowane przy użyciu inicjatora obiektów.</span><span class="sxs-lookup"><span data-stu-id="693c7-190">Note that the new objects are initialized by using an object initializer.</span></span>

[!code-csharp[csrefQueryExpBasics#57](~/samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]

<span data-ttu-id="693c7-191">Aby uzyskać więcej informacji na `select` temat wszystkich sposobów, że klauzula może służyć do przekształcania danych źródłowych, zobacz [select klauzuli](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-191">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>

#### <a name="continuations-with-into"></a><span data-ttu-id="693c7-192">Kontynuacje z "w"</span><span class="sxs-lookup"><span data-stu-id="693c7-192">Continuations with "into"</span></span>

<span data-ttu-id="693c7-193">Słowo kluczowe `into` w `select` lub `group` klauzuli można użyć do utworzenia tymczasowego identyfikatora, który przechowuje kwerendę.</span><span class="sxs-lookup"><span data-stu-id="693c7-193">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="693c7-194">Należy to zrobić, gdy należy wykonać dodatkowe operacje kwerendy na kwerendzie po grupowaniu lub wybierz operację.</span><span class="sxs-lookup"><span data-stu-id="693c7-194">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="693c7-195">W poniższym `countries` przykładzie są pogrupowane według populacji w zakresie 10 milionów.</span><span class="sxs-lookup"><span data-stu-id="693c7-195">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="693c7-196">Po utworzeniu tych grup dodatkowe klauzule odfiltrowują niektóre grupy, a następnie sortują grupy w porządku rosnącym.</span><span class="sxs-lookup"><span data-stu-id="693c7-196">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="693c7-197">Aby wykonać te dodatkowe operacje, `countryGroup` wymagana jest kontynuacja reprezentowana przez.</span><span class="sxs-lookup"><span data-stu-id="693c7-197">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>

[!code-csharp[csrefQueryExpBasics#58](~/samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]

<span data-ttu-id="693c7-198">Aby uzyskać więcej informacji, zobacz [w](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-198">For more information, see [into](../language-reference/keywords/into.md).</span></span>

### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="693c7-199">Filtrowanie, zamawianie i dołączanie</span><span class="sxs-lookup"><span data-stu-id="693c7-199">Filtering, ordering, and joining</span></span>

<span data-ttu-id="693c7-200">Między `from` klauzulą początkową `select` a `group` zakończeniem lub klauzulą`where` `join`wszystkie `orderby` `from`inne `let`klauzule ( , , , , ) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="693c7-200">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="693c7-201">Dowolna z klauzul opcjonalnych może być używana zero razy lub wiele razy w treści kwerendy.</span><span class="sxs-lookup"><span data-stu-id="693c7-201">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>

#### <a name="where-clause"></a><span data-ttu-id="693c7-202">Klauzula where</span><span class="sxs-lookup"><span data-stu-id="693c7-202">where clause</span></span>

<span data-ttu-id="693c7-203">Klauzula `where` służy do filtrowania elementów z danych źródłowych na podstawie jednego lub więcej wyrażeń predykatu.</span><span class="sxs-lookup"><span data-stu-id="693c7-203">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="693c7-204">Klauzula `where` w poniższym przykładzie ma jeden predykat z dwoma warunkami.</span><span class="sxs-lookup"><span data-stu-id="693c7-204">The `where` clause in the following example has one predicate with two conditions.</span></span>

[!code-csharp[csrefQueryExpBasics#59](~/samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]

<span data-ttu-id="693c7-205">Aby uzyskać więcej informacji, zobacz [gdzie klauzula](../language-reference/keywords/where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-205">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>

#### <a name="orderby-clause"></a><span data-ttu-id="693c7-206">Klauzula orderby</span><span class="sxs-lookup"><span data-stu-id="693c7-206">orderby clause</span></span>

<span data-ttu-id="693c7-207">Użyj `orderby` klauzuli, aby posortować wyniki w kolejności rosnącej lub malejącej.</span><span class="sxs-lookup"><span data-stu-id="693c7-207">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="693c7-208">Można również określić dodatkowe zamówienia sortowania.</span><span class="sxs-lookup"><span data-stu-id="693c7-208">You can also specify secondary sort orders.</span></span> <span data-ttu-id="693c7-209">Poniższy przykład wykonuje sortowanie podstawowe `country` na obiektach przy użyciu `Area` właściwości.</span><span class="sxs-lookup"><span data-stu-id="693c7-209">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="693c7-210">Następnie wykonuje sortowanie pomocnicze przy `Population` użyciu właściwości.</span><span class="sxs-lookup"><span data-stu-id="693c7-210">It then performs a secondary sort by using the `Population` property.</span></span>

[!code-csharp[csrefQueryExpBasics#60](~/samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]

<span data-ttu-id="693c7-211">Słowo `ascending` kluczowe jest opcjonalne; jest to domyślna kolejność sortowania, jeśli nie określono żadnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="693c7-211">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="693c7-212">Aby uzyskać więcej informacji, zobacz [orderby klauzuli](../language-reference/keywords/orderby-clause.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-212">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>

#### <a name="join-clause"></a><span data-ttu-id="693c7-213">Klauzula join</span><span class="sxs-lookup"><span data-stu-id="693c7-213">join clause</span></span>

<span data-ttu-id="693c7-214">Klauzula `join` służy do kojarzenia i/lub łączenia elementów z jednego źródła danych z elementami z innego źródła danych na podstawie porównania równości między określonymi kluczami w każdym elemencie.</span><span class="sxs-lookup"><span data-stu-id="693c7-214">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="693c7-215">W LINQ operacje sprzężenia są wykonywane na sekwencje obiektów, których elementy są różne typy.</span><span class="sxs-lookup"><span data-stu-id="693c7-215">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="693c7-216">Po połączeniu dwóch sekwencji należy użyć `select` `group` lub instrukcji, aby określić, który element do przechowywania w sekwencji wyjściowej.</span><span class="sxs-lookup"><span data-stu-id="693c7-216">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="693c7-217">Można również użyć typu anonimowego, aby połączyć właściwości z każdego zestawu skojarzonych elementów do nowego typu dla sekwencji wyjściowej.</span><span class="sxs-lookup"><span data-stu-id="693c7-217">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="693c7-218">Poniższy przykład kojarzy `prod` `Category` obiekty, których właściwość pasuje `categories` do jednej z kategorii w tablicy ciągów.</span><span class="sxs-lookup"><span data-stu-id="693c7-218">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="693c7-219">Produkty, `Category` których nie pasuje `categories` do żadnego ciągu w są filtrowane. Instrukcja `select` projektuje nowy typ, którego `cat` właściwości `prod`są pobierane z obu i .</span><span class="sxs-lookup"><span data-stu-id="693c7-219">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>

[!code-csharp[csrefQueryExpBasics#61](~/samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]

<span data-ttu-id="693c7-220">Można również wykonać sprzężenie grupy, przechowując wyniki `join` operacji w zmiennej tymczasowej przy użyciu słowa kluczowego [Into.](../language-reference/keywords/into.md)</span><span class="sxs-lookup"><span data-stu-id="693c7-220">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="693c7-221">Aby uzyskać więcej informacji, zobacz [klauzulę join .](../language-reference/keywords/join-clause.md)</span><span class="sxs-lookup"><span data-stu-id="693c7-221">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>

#### <a name="let-clause"></a><span data-ttu-id="693c7-222">Klauzula Let</span><span class="sxs-lookup"><span data-stu-id="693c7-222">let clause</span></span>

<span data-ttu-id="693c7-223">Klauzula `let` służy do przechowywania wyniku wyrażenia, takiego jak wywołanie metody, w nowej zmiennej zakresu.</span><span class="sxs-lookup"><span data-stu-id="693c7-223">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="693c7-224">W poniższym przykładzie zmienna `firstName` zakresu przechowuje pierwszy element tablicy ciągów, który jest zwracany przez `Split`.</span><span class="sxs-lookup"><span data-stu-id="693c7-224">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>

[!code-csharp[csrefQueryExpBasics#62](~/samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]

<span data-ttu-id="693c7-225">Aby uzyskać więcej informacji, zobacz [klauzulę let](../language-reference/keywords/let-clause.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-225">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>

### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="693c7-226">Podkwerendy w wyrażeniu kwerendy</span><span class="sxs-lookup"><span data-stu-id="693c7-226">Subqueries in a query expression</span></span>

<span data-ttu-id="693c7-227">Klauzula kwerendy może zawierać wyrażenie kwerendy, które czasami jest określane jako *podkwerenda*.</span><span class="sxs-lookup"><span data-stu-id="693c7-227">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="693c7-228">Każde podkwerenda rozpoczyna `from` się od własnej klauzuli, która `from` niemusi wskazywać na to samo źródło danych w pierwszej klauzuli.</span><span class="sxs-lookup"><span data-stu-id="693c7-228">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="693c7-229">Na przykład poniższa kwerenda pokazuje wyrażenie kwerendy, który jest używany w select instrukcji, aby pobrać wyniki operacji grupowania.</span><span class="sxs-lookup"><span data-stu-id="693c7-229">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>

[!code-csharp[csrefQueryExpBasics#63](~/samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]

<span data-ttu-id="693c7-230">Aby uzyskać więcej informacji, zobacz [Wykonywanie podkwerendy w operacji grupowania](perform-a-subquery-on-a-grouping-operation.md).</span><span class="sxs-lookup"><span data-stu-id="693c7-230">For more information, see [Perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="693c7-231">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="693c7-231">See also</span></span>

- [<span data-ttu-id="693c7-232">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="693c7-232">C# programming guide</span></span>](../programming-guide/index.md)
- [<span data-ttu-id="693c7-233">Language Integrated Query (LINQ)</span><span class="sxs-lookup"><span data-stu-id="693c7-233">Language Integrated Query (LINQ)</span></span>](index.md)
- [<span data-ttu-id="693c7-234">Słowa kluczowe zapytania (LINQ)</span><span class="sxs-lookup"><span data-stu-id="693c7-234">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)
- [<span data-ttu-id="693c7-235">Omówienie standardowych operatorów kwerend</span><span class="sxs-lookup"><span data-stu-id="693c7-235">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)
