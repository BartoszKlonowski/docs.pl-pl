---
description: Klauzula join — odwołanie w C#
title: Klauzula join — odwołanie w C#
ms.date: 07/20/2015
f1_keywords:
- join
- join_CSharpKeyword
helpviewer_keywords:
- join clause [C#]
- join keyword [C#]
ms.assetid: 76e9df84-092c-41a6-9537-c3f1cbd7f0fb
ms.openlocfilehash: 44b35bd1243e4715f81513eef9968f30a8f315a3
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/30/2020
ms.locfileid: "89139752"
---
# <a name="join-clause-c-reference"></a><span data-ttu-id="fbd80-103">Klauzula join (odwołanie w C#)</span><span class="sxs-lookup"><span data-stu-id="fbd80-103">join clause (C# Reference)</span></span>

<span data-ttu-id="fbd80-104">`join`Klauzula jest przydatna do kojarzenia elementów z różnych sekwencji źródłowych, które nie mają bezpośredniej relacji w modelu obiektów.</span><span class="sxs-lookup"><span data-stu-id="fbd80-104">The `join` clause is useful for associating elements from different source sequences that have no direct relationship in the object model.</span></span> <span data-ttu-id="fbd80-105">Jedyny wymóg polega na tym, że elementy w poszczególnych źródłach mają pewną wartość, którą można porównać pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="fbd80-105">The only requirement is that the elements in each source share some value that can be compared for equality.</span></span> <span data-ttu-id="fbd80-106">Na przykład dystrybutor żywności może mieć listę dostawców określonego produktu i listę kupujących.</span><span class="sxs-lookup"><span data-stu-id="fbd80-106">For example, a food distributor might have a list of suppliers of a certain product, and a list of buyers.</span></span> <span data-ttu-id="fbd80-107">`join`Można na przykład użyć klauzuli, aby utworzyć listę dostawców i kupujących tego produktu, którzy znajdują się w tym samym określonym regionie.</span><span class="sxs-lookup"><span data-stu-id="fbd80-107">A `join` clause can be used, for example, to create a list of the suppliers and buyers of that product who are all in the same specified region.</span></span>

<span data-ttu-id="fbd80-108">`join`Klauzula przyjmuje dwie sekwencje źródłowe jako dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="fbd80-108">A `join` clause takes two source sequences as input.</span></span> <span data-ttu-id="fbd80-109">Elementy w każdej sekwencji muszą być albo zawierać właściwość, którą można porównać z odpowiednią właściwością w innej sekwencji.</span><span class="sxs-lookup"><span data-stu-id="fbd80-109">The elements in each sequence must either be or contain a property that can be compared to a corresponding property in the other sequence.</span></span> <span data-ttu-id="fbd80-110">`join`Klauzula porównuje określone klucze dla równości przy użyciu `equals` słowa kluczowego Special.</span><span class="sxs-lookup"><span data-stu-id="fbd80-110">The `join` clause compares the specified keys for equality by using the special `equals` keyword.</span></span> <span data-ttu-id="fbd80-111">Wszystkie sprzężenia wykonywane przez `join` klauzulę to equijoins.</span><span class="sxs-lookup"><span data-stu-id="fbd80-111">All joins performed by the `join` clause are equijoins.</span></span> <span data-ttu-id="fbd80-112">Kształt danych wyjściowych `join` klauzuli zależy od określonego typu dołączania.</span><span class="sxs-lookup"><span data-stu-id="fbd80-112">The shape of the output of a `join` clause depends on the specific type of join you are performing.</span></span> <span data-ttu-id="fbd80-113">Poniżej przedstawiono trzy Najczęstsze typy sprzężeń:</span><span class="sxs-lookup"><span data-stu-id="fbd80-113">The following are three most common join types:</span></span>

- <span data-ttu-id="fbd80-114">Sprzężenie wewnętrzne</span><span class="sxs-lookup"><span data-stu-id="fbd80-114">Inner join</span></span>

- <span data-ttu-id="fbd80-115">Dołącz do grupy</span><span class="sxs-lookup"><span data-stu-id="fbd80-115">Group join</span></span>

- <span data-ttu-id="fbd80-116">Lewe sprzężenie zewnętrzne</span><span class="sxs-lookup"><span data-stu-id="fbd80-116">Left outer join</span></span>

## <a name="inner-join"></a><span data-ttu-id="fbd80-117">Sprzężenie wewnętrzne</span><span class="sxs-lookup"><span data-stu-id="fbd80-117">Inner join</span></span>

<span data-ttu-id="fbd80-118">W poniższym przykładzie przedstawiono proste wewnętrzne equijoin.</span><span class="sxs-lookup"><span data-stu-id="fbd80-118">The following example shows a simple inner equijoin.</span></span> <span data-ttu-id="fbd80-119">To zapytanie tworzy płaską sekwencję par "Nazwa produktu/kategoria".</span><span class="sxs-lookup"><span data-stu-id="fbd80-119">This query produces a flat sequence of "product name / category" pairs.</span></span> <span data-ttu-id="fbd80-120">Ten sam ciąg kategorii będzie wyświetlany w wielu elementach.</span><span class="sxs-lookup"><span data-stu-id="fbd80-120">The same category string will appear in multiple elements.</span></span> <span data-ttu-id="fbd80-121">Jeśli element `categories` nie jest zgodny `products` , Ta kategoria nie będzie wyświetlana w wynikach.</span><span class="sxs-lookup"><span data-stu-id="fbd80-121">If an element from `categories` has no matching `products`, that category will not appear in the results.</span></span>

[!code-csharp[cscsrefQueryKeywords#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#24)]

<span data-ttu-id="fbd80-122">Aby uzyskać więcej informacji, zobacz [wykonywanie sprzężeń wewnętrznych](../../linq/perform-inner-joins.md).</span><span class="sxs-lookup"><span data-stu-id="fbd80-122">For more information, see [Perform inner joins](../../linq/perform-inner-joins.md).</span></span>

## <a name="group-join"></a><span data-ttu-id="fbd80-123">Dołącz do grupy</span><span class="sxs-lookup"><span data-stu-id="fbd80-123">Group join</span></span>

<span data-ttu-id="fbd80-124">`join`Klauzula z `into` wyrażeniem jest nazywana przyłączaniem do grupy.</span><span class="sxs-lookup"><span data-stu-id="fbd80-124">A `join` clause with an `into` expression is called a group join.</span></span>

[!code-csharp[cscsrefQueryKeywords#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#25)]

<span data-ttu-id="fbd80-125">Przyłączenie do grupy tworzy hierarchiczną sekwencję wyników, która kojarzy elementy w sekwencji z lewej strony z co najmniej jednym zgodnymi elementami w sekwencji źródłowej po prawej stronie.</span><span class="sxs-lookup"><span data-stu-id="fbd80-125">A group join produces a hierarchical result sequence, which associates elements in the left source sequence with one or more matching elements in the right side source sequence.</span></span> <span data-ttu-id="fbd80-126">Przyłączanie do grupy nie ma odpowiedników w warunkach relacyjnych; zasadniczo jest to sekwencja tablic obiektów.</span><span class="sxs-lookup"><span data-stu-id="fbd80-126">A group join has no equivalent in relational terms; it is essentially a sequence of object arrays.</span></span>

<span data-ttu-id="fbd80-127">Jeśli nie zostaną znalezione żadne elementy z prawej sekwencji źródłowej pasujące do elementu w lewym źródle, `join` klauzula spowoduje utworzenie pustej tablicy dla tego elementu.</span><span class="sxs-lookup"><span data-stu-id="fbd80-127">If no elements from the right source sequence are found to match an element in the left source, the `join` clause will produce an empty array for that item.</span></span> <span data-ttu-id="fbd80-128">W związku z tym, przyłączenie do grupy jest nadal zasadniczo wewnętrznym equijoin, z tą różnicą, że sekwencja wyników jest zorganizowana w grupy.</span><span class="sxs-lookup"><span data-stu-id="fbd80-128">Therefore, the group join is still basically an inner-equijoin except that the result sequence is organized into groups.</span></span>

<span data-ttu-id="fbd80-129">Jeśli po prostu wybierzesz wyniki przyłączenia do grupy, możesz uzyskać dostęp do tych elementów, ale nie możesz zidentyfikować klucza, na którym są one zgodne.</span><span class="sxs-lookup"><span data-stu-id="fbd80-129">If you just select the results of a group join, you can access the items, but you cannot identify the key that they match on.</span></span> <span data-ttu-id="fbd80-130">W związku z tym zwykle bardziej przydatne jest wybranie wyników sprzężenia grupy na nowy typ, który ma również nazwę klucza, jak pokazano w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="fbd80-130">Therefore, it is generally more useful to select the results of the group join into a new type that also has the key name, as shown in the previous example.</span></span>

<span data-ttu-id="fbd80-131">Oczywiście można również użyć wyniku sprzężenia grupy jako generatora innego podzapytania:</span><span class="sxs-lookup"><span data-stu-id="fbd80-131">You can also, of course, use the result of a group join as the generator of another subquery:</span></span>

[!code-csharp[cscsrefQueryKeywords#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#26)]

<span data-ttu-id="fbd80-132">Aby uzyskać więcej informacji, zobacz [wykonywanie sprzężeń zgrupowanych](../../linq/perform-grouped-joins.md).</span><span class="sxs-lookup"><span data-stu-id="fbd80-132">For more information, see [Perform grouped joins](../../linq/perform-grouped-joins.md).</span></span>

## <a name="left-outer-join"></a><span data-ttu-id="fbd80-133">Lewe sprzężenie zewnętrzne</span><span class="sxs-lookup"><span data-stu-id="fbd80-133">Left outer join</span></span>

<span data-ttu-id="fbd80-134">W lewym sprzężeniu zewnętrznym są zwracane wszystkie elementy w sekwencji po lewej stronie, nawet jeśli żadne zgodne elementy nie są w odpowiedniej kolejności.</span><span class="sxs-lookup"><span data-stu-id="fbd80-134">In a left outer join, all the elements in the left source sequence are returned, even if no matching elements are in the right sequence.</span></span> <span data-ttu-id="fbd80-135">Aby wykonać lewe sprzężenie zewnętrzne w LINQ, użyj `DefaultIfEmpty` metody w połączeniu z przyłączaniem do grupy, aby określić domyślny element po prawej stronie, który ma zostać użyty, jeśli element po lewej stronie nie ma dopasowań.</span><span class="sxs-lookup"><span data-stu-id="fbd80-135">To perform a left outer join in LINQ, use the `DefaultIfEmpty` method in combination with a group join to specify a default right-side element to produce if a left-side element has no matches.</span></span> <span data-ttu-id="fbd80-136">Można użyć `null` jako wartości domyślnej dla dowolnego typu odwołania lub można określić typ domyślny zdefiniowany przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="fbd80-136">You can use `null` as the default value for any reference type, or you can specify a user-defined default type.</span></span> <span data-ttu-id="fbd80-137">W poniższym przykładzie jest pokazywany typ domyślny zdefiniowany przez użytkownika:</span><span class="sxs-lookup"><span data-stu-id="fbd80-137">In the following example, a user-defined default type is shown:</span></span>

[!code-csharp[cscsrefQueryKeywords#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#27)]

<span data-ttu-id="fbd80-138">Aby uzyskać więcej informacji, zobacz [przełączenie do lewego sprzężenia zewnętrznego](../../linq/perform-left-outer-joins.md).</span><span class="sxs-lookup"><span data-stu-id="fbd80-138">For more information, see [Perform left outer joins](../../linq/perform-left-outer-joins.md).</span></span>

## <a name="the-equals-operator"></a><span data-ttu-id="fbd80-139">Operator równości</span><span class="sxs-lookup"><span data-stu-id="fbd80-139">The equals operator</span></span>

<span data-ttu-id="fbd80-140">`join`Klauzula wykonuje equijoin.</span><span class="sxs-lookup"><span data-stu-id="fbd80-140">A `join` clause performs an equijoin.</span></span> <span data-ttu-id="fbd80-141">Innymi słowy, można uzyskać tylko podstawowe dopasowania dotyczące równości dwóch kluczy.</span><span class="sxs-lookup"><span data-stu-id="fbd80-141">In other words, you can only base matches on the equality of two keys.</span></span> <span data-ttu-id="fbd80-142">Inne typy porównania, takie jak "większe niż" lub "not Equals", nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="fbd80-142">Other types of comparisons such as "greater than" or "not equals" are not supported.</span></span> <span data-ttu-id="fbd80-143">Aby wyczyścić, że wszystkie sprzężenia są equijoins, `join` klauzula używa `equals` słowa kluczowego zamiast `==` operatora.</span><span class="sxs-lookup"><span data-stu-id="fbd80-143">To make clear that all joins are equijoins, the `join` clause uses the `equals` keyword instead of the `==` operator.</span></span> <span data-ttu-id="fbd80-144">`equals`Słowo kluczowe może być używane tylko w `join` klauzuli i różni się od `==` operatora w jeden istotny sposób.</span><span class="sxs-lookup"><span data-stu-id="fbd80-144">The `equals` keyword can only be used in a `join` clause and it differs from the `==` operator in one important way.</span></span> <span data-ttu-id="fbd80-145">W przypadku `equals` , lewy klucz zużywa zewnętrzną sekwencję źródłową, a prawy klucz korzysta ze źródła wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="fbd80-145">With `equals`, the left key consumes the outer source sequence, and the right key consumes the inner source.</span></span> <span data-ttu-id="fbd80-146">Zewnętrzne źródło jest tylko w zakresie po lewej stronie `equals` , a wewnętrzna sekwencja źródłowa jest tylko w zakresie po prawej stronie.</span><span class="sxs-lookup"><span data-stu-id="fbd80-146">The outer source is only in scope on the left side of `equals` and the inner source sequence is only in scope on the right side.</span></span>

## <a name="non-equijoins"></a><span data-ttu-id="fbd80-147">Nie equijoins</span><span class="sxs-lookup"><span data-stu-id="fbd80-147">Non-equijoins</span></span>

<span data-ttu-id="fbd80-148">Można wykonywać inne niż equijoins, sprzężenia krzyżowe i inne niestandardowe operacje Join przy użyciu wielu `from` klauzul, aby wprowadzać nowe sekwencje niezależnie do zapytania.</span><span class="sxs-lookup"><span data-stu-id="fbd80-148">You can perform non-equijoins, cross joins, and other custom join operations by using multiple `from` clauses to introduce new sequences independently into a query.</span></span> <span data-ttu-id="fbd80-149">Aby uzyskać więcej informacji, zobacz [wykonywanie niestandardowych operacji łączenia](../../linq/perform-custom-join-operations.md).</span><span class="sxs-lookup"><span data-stu-id="fbd80-149">For more information, see [Perform custom join operations](../../linq/perform-custom-join-operations.md).</span></span>

## <a name="joins-on-object-collections-vs-relational-tables"></a><span data-ttu-id="fbd80-150">Sprzężenia na kolekcjach obiektów a tabelach relacyjnych</span><span class="sxs-lookup"><span data-stu-id="fbd80-150">Joins on object collections vs. relational tables</span></span>

<span data-ttu-id="fbd80-151">W wyrażeniu zapytania LINQ operacje Join są wykonywane w ramach kolekcji obiektów.</span><span class="sxs-lookup"><span data-stu-id="fbd80-151">In a LINQ query expression, join operations are performed on object collections.</span></span> <span data-ttu-id="fbd80-152">Kolekcje obiektów nie mogą być połączone w taki sam sposób jak dwie tabele relacyjne.</span><span class="sxs-lookup"><span data-stu-id="fbd80-152">Object collections cannot be "joined" in exactly the same way as two relational tables.</span></span> <span data-ttu-id="fbd80-153">W LINQ jawne `join` klauzule są wymagane tylko wtedy, gdy dwie sekwencje źródłowe nie są powiązane z żadną relacją.</span><span class="sxs-lookup"><span data-stu-id="fbd80-153">In LINQ, explicit `join` clauses are only required when two source sequences are not tied by any relationship.</span></span> <span data-ttu-id="fbd80-154">Podczas pracy z [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] tabelami kluczy obcych są reprezentowane w modelu obiektów jako właściwości tabeli podstawowej.</span><span class="sxs-lookup"><span data-stu-id="fbd80-154">When working with [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], foreign key tables are represented in the object model as properties of the primary table.</span></span> <span data-ttu-id="fbd80-155">Na przykład w bazie danych Northwind tabela Customer zawiera relację klucza obcego z tabelą Orders.</span><span class="sxs-lookup"><span data-stu-id="fbd80-155">For example, in the Northwind database, the Customer table has a foreign key relationship with the Orders table.</span></span> <span data-ttu-id="fbd80-156">Po zmapowaniu tabel do modelu obiektów Klasa Customer ma właściwość Orders, która zawiera kolekcję zamówień skojarzonych z tym klientem.</span><span class="sxs-lookup"><span data-stu-id="fbd80-156">When you map the tables to the object model, the Customer class has an Orders property that contains the collection of Orders associated with that Customer.</span></span> <span data-ttu-id="fbd80-157">W efekcie połączenie zostało już wykonane.</span><span class="sxs-lookup"><span data-stu-id="fbd80-157">In effect, the join has already been done for you.</span></span>

<span data-ttu-id="fbd80-158">Aby uzyskać więcej informacji o wysyłaniu zapytań między powiązanymi tabelami w kontekście programu [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] , zobacz [How to: map Relationships Database](../../../framework/data/adonet/sql/linq/how-to-map-database-relationships.md).</span><span class="sxs-lookup"><span data-stu-id="fbd80-158">For more information about querying across related tables in the context of [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], see [How to: Map Database Relationships](../../../framework/data/adonet/sql/linq/how-to-map-database-relationships.md).</span></span>

## <a name="composite-keys"></a><span data-ttu-id="fbd80-159">Klucze złożone</span><span class="sxs-lookup"><span data-stu-id="fbd80-159">Composite keys</span></span>

<span data-ttu-id="fbd80-160">Możesz sprawdzić równość wielu wartości przy użyciu klucza złożonego.</span><span class="sxs-lookup"><span data-stu-id="fbd80-160">You can test for equality of multiple values by using a composite key.</span></span> <span data-ttu-id="fbd80-161">Aby uzyskać więcej informacji, zobacz [sprzęganie za pomocą kluczy złożonych](../../linq/join-by-using-composite-keys.md).</span><span class="sxs-lookup"><span data-stu-id="fbd80-161">For more information, see [Join by using composite keys](../../linq/join-by-using-composite-keys.md).</span></span> <span data-ttu-id="fbd80-162">Klucze złożone mogą być również używane w `group` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="fbd80-162">Composite keys can be also used in a `group` clause.</span></span>

## <a name="example"></a><span data-ttu-id="fbd80-163">Przykład</span><span class="sxs-lookup"><span data-stu-id="fbd80-163">Example</span></span>

<span data-ttu-id="fbd80-164">Poniższy przykład porównuje wyniki sprzężenia wewnętrznego, sprzężenie grupy i lewe sprzężenie zewnętrzne w tych samych źródłach danych przy użyciu tych samych pasujących kluczy.</span><span class="sxs-lookup"><span data-stu-id="fbd80-164">The following example compares the results of an inner join, a group join, and a left outer join on the same data sources by using the same matching keys.</span></span> <span data-ttu-id="fbd80-165">Do tych przykładów zostanie dodany dodatkowy kod, aby wyjaśnić wyniki wyświetlane w konsoli.</span><span class="sxs-lookup"><span data-stu-id="fbd80-165">Some extra code is added to these examples to clarify the results in the console display.</span></span>

[!code-csharp[cscsrefQueryKeywords#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#23)]

## <a name="remarks"></a><span data-ttu-id="fbd80-166">Uwagi</span><span class="sxs-lookup"><span data-stu-id="fbd80-166">Remarks</span></span>

<span data-ttu-id="fbd80-167">`join`Klauzula, która nie następuje po `into` translacji na <xref:System.Linq.Enumerable.Join%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="fbd80-167">A `join` clause that is not followed by `into` is translated into a <xref:System.Linq.Enumerable.Join%2A> method call.</span></span> <span data-ttu-id="fbd80-168">`join`Klauzula, która następuje po `into` translacji na <xref:System.Linq.Enumerable.GroupJoin%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="fbd80-168">A `join` clause that is followed by `into` is translated to a <xref:System.Linq.Enumerable.GroupJoin%2A> method call.</span></span>

## <a name="see-also"></a><span data-ttu-id="fbd80-169">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="fbd80-169">See also</span></span>

- [<span data-ttu-id="fbd80-170">Słowa kluczowe zapytania (LINQ)</span><span class="sxs-lookup"><span data-stu-id="fbd80-170">Query Keywords (LINQ)</span></span>](query-keywords.md)
- [<span data-ttu-id="fbd80-171">Language Integrated Query (LINQ)</span><span class="sxs-lookup"><span data-stu-id="fbd80-171">Language Integrated Query (LINQ)</span></span>](../../linq/index.md)
- [<span data-ttu-id="fbd80-172">Operacje połączone</span><span class="sxs-lookup"><span data-stu-id="fbd80-172">Join Operations</span></span>](../../programming-guide/concepts/linq/join-operations.md)
- [<span data-ttu-id="fbd80-173">group — Klauzula</span><span class="sxs-lookup"><span data-stu-id="fbd80-173">group clause</span></span>](group-clause.md)
- [<span data-ttu-id="fbd80-174">Wykonywanie lewych sprzężeń zewnętrznych</span><span class="sxs-lookup"><span data-stu-id="fbd80-174">Perform left outer joins</span></span>](../../linq/perform-left-outer-joins.md)
- [<span data-ttu-id="fbd80-175">Wykonywanie sprzężeń wewnętrznych</span><span class="sxs-lookup"><span data-stu-id="fbd80-175">Perform inner joins</span></span>](../../linq/perform-inner-joins.md)
- [<span data-ttu-id="fbd80-176">Wykonywanie sprzężeń grupowanych</span><span class="sxs-lookup"><span data-stu-id="fbd80-176">Perform grouped joins</span></span>](../../linq/perform-grouped-joins.md)
- [<span data-ttu-id="fbd80-177">Kolejność wyników klauzuli join</span><span class="sxs-lookup"><span data-stu-id="fbd80-177">Order the results of a join clause</span></span>](../../linq/order-the-results-of-a-join-clause.md)
- [<span data-ttu-id="fbd80-178">Sprzęganie za pomocą kluczy złożonych</span><span class="sxs-lookup"><span data-stu-id="fbd80-178">Join by using composite keys</span></span>](../../linq/join-by-using-composite-keys.md)
- [<span data-ttu-id="fbd80-179">Zgodne systemy baz danych dla programu Visual Studio</span><span class="sxs-lookup"><span data-stu-id="fbd80-179">Compatible database systems for Visual Studio</span></span>](/visualstudio/data-tools/installing-database-systems-tools-and-samples)
