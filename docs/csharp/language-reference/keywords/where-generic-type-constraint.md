---
description: WHERE (ograniczenie typu ogólnego) — odwołanie w C#
title: WHERE (ograniczenie typu ogólnego) — odwołanie w C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
- classconstraint_CSharpKeyword
- structconstraint_CSharpKeyword
- enumconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: ff2d50b2148ea62e5bef5eceda547a976e4abf02
ms.sourcegitcommit: 279fb6e8d515df51676528a7424a1df2f0917116
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/27/2020
ms.locfileid: "92687316"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="b0802-103">where — Ograniczenie typu ogólnego (odwołanie w C#)</span><span class="sxs-lookup"><span data-stu-id="b0802-103">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="b0802-104">`where`Klauzula w definicji ogólnej określa ograniczenia dotyczące typów, które są używane jako argumenty parametrów typu w typie ogólnym, metodzie, delegatze lub funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="b0802-104">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="b0802-105">Ograniczenia mogą określać interfejsy, klasy bazowe lub wymagać typu ogólnego, aby być odwołaniem, wartością lub typem niezarządzanym.</span><span class="sxs-lookup"><span data-stu-id="b0802-105">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="b0802-106">Deklarują możliwości, że argument typu musi mieć wartość.</span><span class="sxs-lookup"><span data-stu-id="b0802-106">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="b0802-107">Na przykład można zadeklarować klasę generyczną, `MyGenericClass` w taki sposób, aby parametr typu `T` implementuje <xref:System.IComparable%601> Interfejs:</span><span class="sxs-lookup"><span data-stu-id="b0802-107">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="b0802-108">Aby uzyskać więcej informacji na temat klauzuli WHERE w wyrażeniu zapytania, zobacz [klauzula WHERE](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b0802-108">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="b0802-109">`where`Klauzula może również zawierać ograniczenie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="b0802-109">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="b0802-110">Ograniczenie klasy bazowej określa, że typ, który ma być używany jako argument typu dla tego typu ogólnego ma określoną klasę jako klasę bazową, lub jest tą klasą bazową.</span><span class="sxs-lookup"><span data-stu-id="b0802-110">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="b0802-111">Jeśli jest używane ograniczenie klasy bazowej, musi ono znajdować się przed innymi ograniczeniami tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="b0802-111">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="b0802-112">Niektóre typy są niedozwolone jako ograniczenie klasy bazowej: <xref:System.Object> , <xref:System.Array> , i <xref:System.ValueType> .</span><span class="sxs-lookup"><span data-stu-id="b0802-112">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="b0802-113">Przed C# 7,3, <xref:System.Enum> , <xref:System.Delegate> i <xref:System.MulticastDelegate> były również niedozwolone jako ograniczenia klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="b0802-113">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="b0802-114">W poniższym przykładzie przedstawiono typy, które można teraz określić jako klasę bazową:</span><span class="sxs-lookup"><span data-stu-id="b0802-114">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="b0802-115">W kontekście dopuszczającym wartość null w języku C# 8,0 i nowszych wartości null typu klasy bazowej są wymuszane.</span><span class="sxs-lookup"><span data-stu-id="b0802-115">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="b0802-116">Jeśli klasa bazowa nie dopuszcza wartości null (na przykład `Base` ), argument typu nie może dopuszczać wartości null.</span><span class="sxs-lookup"><span data-stu-id="b0802-116">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="b0802-117">Jeśli klasa bazowa nie dopuszcza wartości null (na przykład `Base?` ), argument typu może być typem referencyjnym nullable lub niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="b0802-117">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="b0802-118">Kompilator generuje ostrzeżenie, jeśli argument typu jest typem referencyjnym dopuszczającym wartość null, jeśli klasa bazowa nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="b0802-118">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="b0802-119">`where`Klauzula może określać, że typem jest `class` lub `struct` .</span><span class="sxs-lookup"><span data-stu-id="b0802-119">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="b0802-120">`struct`Ograniczenie eliminuje konieczność określenia ograniczenia klasy bazowej `System.ValueType` .</span><span class="sxs-lookup"><span data-stu-id="b0802-120">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="b0802-121">`System.ValueType`Typ nie może być używany jako ograniczenie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="b0802-121">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="b0802-122">W poniższym przykładzie przedstawiono zarówno `class` warunek, jak i `struct` :</span><span class="sxs-lookup"><span data-stu-id="b0802-122">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="b0802-123">W kontekście dopuszczającym wartość null w języku C# 8,0 i nowszych, `class` ograniczenie wymaga typu jako typu referencyjnego, który nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="b0802-123">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="b0802-124">Aby zezwolić na typy referencyjne dopuszczające wartość null, użyj `class?` ograniczenia, które zezwala na typ referencyjny dopuszczający wartości null i niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="b0802-124">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="b0802-125">`where`Klauzula może zawierać `notnull` ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="b0802-125">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="b0802-126">`notnull`Ograniczenie ogranicza parametr typu do typu niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="b0802-126">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="b0802-127">Ten typ może być typem [wartości](../builtin-types/value-types.md) lub typem referencyjnym, który nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="b0802-127">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="b0802-128">To `notnull` ograniczenie jest dostępne począwszy od języka C# 8,0 dla kodu skompilowanego w [ `nullable enable` kontekście](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="b0802-128">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="b0802-129">W przeciwieństwie do innych ograniczeń, jeśli argument typu narusza `notnull` ograniczenie, kompilator generuje ostrzeżenie zamiast błędu.</span><span class="sxs-lookup"><span data-stu-id="b0802-129">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="b0802-130">Ostrzeżenia są generowane tylko w `nullable enable` kontekście.</span><span class="sxs-lookup"><span data-stu-id="b0802-130">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b0802-131">Deklaracje ogólne zawierające `notnull` ograniczenie mogą być używane w kontekście wartości null Oblivious, ale kompilator nie wymusza ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="b0802-131">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="b0802-132">`where`Klauzula może również zawierać `unmanaged` ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="b0802-132">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="b0802-133">`unmanaged`Ograniczenie ogranicza parametr typu do typów znanych jako [typy niezarządzane](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="b0802-133">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="b0802-134">To `unmanaged` ograniczenie ułatwia zapisanie kodu międzyoperacyjności niskiego poziomu w języku C#.</span><span class="sxs-lookup"><span data-stu-id="b0802-134">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="b0802-135">To ograniczenie umożliwia wykonywanie procedur wielokrotnego użytku we wszystkich typach niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="b0802-135">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="b0802-136">`unmanaged`Nie można połączyć ograniczenia z `class` `struct` ograniczeniem or.</span><span class="sxs-lookup"><span data-stu-id="b0802-136">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="b0802-137">`unmanaged`Ograniczenie wymusza, że typ musi być `struct` :</span><span class="sxs-lookup"><span data-stu-id="b0802-137">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="b0802-138">`where`Klauzula może również zawierać ograniczenie konstruktora `new()` .</span><span class="sxs-lookup"><span data-stu-id="b0802-138">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="b0802-139">To ograniczenie umożliwia utworzenie wystąpienia parametru typu za pomocą `new` operatora.</span><span class="sxs-lookup"><span data-stu-id="b0802-139">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="b0802-140">To [ograniczenie New ()](new-constraint.md) umożliwia kompilatorowi, że każdy dostarczony argument typu musi mieć dostępny Konstruktor bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="b0802-140">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="b0802-141">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="b0802-141">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="b0802-142">`new()`Ograniczenie jest wyświetlane jako ostatnie w `where` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="b0802-142">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="b0802-143">`new()`Nie można połączyć ograniczenia z `struct` `unmanaged` ograniczeniami lub.</span><span class="sxs-lookup"><span data-stu-id="b0802-143">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="b0802-144">Wszystkie typy spełniające te ograniczenia muszą mieć dostępny Konstruktor bez parametrów, co sprawia, że `new()` ograniczenie jest nadmiarowe.</span><span class="sxs-lookup"><span data-stu-id="b0802-144">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="b0802-145">W przypadku wielu parametrów typu należy użyć jednej `where` klauzuli dla każdego parametru typu, na przykład:</span><span class="sxs-lookup"><span data-stu-id="b0802-145">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="b0802-146">Można również dołączyć ograniczenia do parametrów typu metod ogólnych, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="b0802-146">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="b0802-147">Zauważ, że składnia opisująca ograniczenia parametru typu dla delegatów jest taka sama jak w przypadku metod:</span><span class="sxs-lookup"><span data-stu-id="b0802-147">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="b0802-148">Aby uzyskać informacje na temat delegatów ogólnych, zobacz [Delegaty ogólne](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="b0802-148">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="b0802-149">Aby uzyskać szczegółowe informacje na temat składni i użycia ograniczeń, zobacz [ograniczenia dotyczące parametrów typu](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="b0802-149">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="b0802-150">specyfikacja języka C#</span><span class="sxs-lookup"><span data-stu-id="b0802-150">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="b0802-151">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="b0802-151">See also</span></span>

- [<span data-ttu-id="b0802-152">Odwołanie w C#</span><span class="sxs-lookup"><span data-stu-id="b0802-152">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="b0802-153">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="b0802-153">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="b0802-154">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="b0802-154">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="b0802-155">nowe ograniczenie</span><span class="sxs-lookup"><span data-stu-id="b0802-155">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="b0802-156">Ograniczenia dotyczące parametrów typu</span><span class="sxs-lookup"><span data-stu-id="b0802-156">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
