---
title: gdzie (ograniczenie typu ogólnego) - Odwołanie C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 5a56b8058735d3ca786520a82424c79d1975bfc4
ms.sourcegitcommit: 927b7ea6b2ea5a440c8f23e3e66503152eb85591
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/16/2020
ms.locfileid: "81463012"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="254e2-102">where — Ograniczenie typu ogólnego (odwołanie w C#)</span><span class="sxs-lookup"><span data-stu-id="254e2-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="254e2-103">Klauzula `where` w definicji ogólnej określa ograniczenia dotyczące typów, które są używane jako argumenty dla parametrów typu w typie ogólnym, metodzie, delegata lub funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="254e2-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="254e2-104">Ograniczenia można określić interfejsy, klasy podstawowe lub wymagają typu ogólnego, aby być odwołanie, wartość lub typu niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="254e2-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="254e2-105">Deklarują możliwości, które musi mieć argument typu.</span><span class="sxs-lookup"><span data-stu-id="254e2-105">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="254e2-106">Na przykład można zadeklarować klasy `MyGenericClass`ogólnej, tak, `T` że <xref:System.IComparable%601> parametr typu implementuje interfejs:</span><span class="sxs-lookup"><span data-stu-id="254e2-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="254e2-107">Aby uzyskać więcej informacji na temat klauzuli where w wyrażeniu kwerendy, zobacz [where clause](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="254e2-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="254e2-108">Klauzula `where` może również zawierać ograniczenie klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="254e2-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="254e2-109">Ograniczenie klasy podstawowej stwierdza, że typ, który ma być używany jako argument typu dla tego typu ogólnego ma określoną klasę jako klasę podstawową lub jest tą klasą podstawową.</span><span class="sxs-lookup"><span data-stu-id="254e2-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="254e2-110">Jeśli używane jest ograniczenie klasy podstawowej, musi pojawić się przed innymi ograniczeniami dla tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="254e2-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="254e2-111">Niektóre typy są niedozwolone <xref:System.Object> <xref:System.Array>jako <xref:System.ValueType>ograniczenie klasy podstawowej: , i .</span><span class="sxs-lookup"><span data-stu-id="254e2-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="254e2-112">Przed C# 7.3, <xref:System.Enum>, <xref:System.Delegate>i <xref:System.MulticastDelegate> zostały również niedozwolone jako ograniczenia klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="254e2-112">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="254e2-113">Poniższy przykład przedstawia typy, które można teraz określić jako klasę podstawową:</span><span class="sxs-lookup"><span data-stu-id="254e2-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#2)]

<span data-ttu-id="254e2-114">W kontekście nullable w języku C# 8.0 i nowszych, nullability typu klasy podstawowej jest wymuszane.</span><span class="sxs-lookup"><span data-stu-id="254e2-114">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="254e2-115">Jeśli klasa podstawowa nie może być `Base`nullable (na przykład), argument typu musi być nie można nullable.</span><span class="sxs-lookup"><span data-stu-id="254e2-115">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="254e2-116">Jeśli klasa podstawowa jest nullable (na przykład), `Base?`argument typu może być nullable lub non-nullable typu odwołania.</span><span class="sxs-lookup"><span data-stu-id="254e2-116">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="254e2-117">Kompilator generuje ostrzeżenie, jeśli argument typu jest typem odwołania z dopuszczalną wartością null, gdy klasa podstawowa nie może być nullowa.</span><span class="sxs-lookup"><span data-stu-id="254e2-117">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="254e2-118">Klauzula `where` może określać, `class` że `struct`typ jest lub .</span><span class="sxs-lookup"><span data-stu-id="254e2-118">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="254e2-119">Ograniczenie `struct` eliminuje konieczność określania ograniczenia klasy `System.ValueType`podstawowej .</span><span class="sxs-lookup"><span data-stu-id="254e2-119">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="254e2-120">Typ `System.ValueType` nie może być używany jako ograniczenie klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="254e2-120">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="254e2-121">Poniższy przykład przedstawia `class` `struct` zarówno ograniczenia, jak i ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="254e2-121">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#3)]

<span data-ttu-id="254e2-122">W kontekście nullable w języku C# 8.0 i `class` nowszych, ograniczenie wymaga typu, który ma być typem odwołania niepodjętego do null.</span><span class="sxs-lookup"><span data-stu-id="254e2-122">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="254e2-123">Aby zezwolić na typy `class?` odwołań nullable, należy użyć ograniczenia, które umożliwia zarówno nullable i non-null typy odwołania.</span><span class="sxs-lookup"><span data-stu-id="254e2-123">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="254e2-124">Klauzula `where` może `notnull` zawierać ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="254e2-124">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="254e2-125">Ograniczenie `notnull` ogranicza parametr typu do typów nienastępalnych do wartości null.</span><span class="sxs-lookup"><span data-stu-id="254e2-125">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="254e2-126">Ten typ może być [typem wartości](../builtin-types/value-types.md) lub typem odwołania, którego nie można podkreślać.</span><span class="sxs-lookup"><span data-stu-id="254e2-126">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="254e2-127">Ograniczenie `notnull` jest dostępne począwszy od języka C# 8.0 dla kodu skompilowanego w [ `nullable enable` kontekście](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="254e2-127">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="254e2-128">W przeciwieństwie do innych ograniczeń, jeśli `notnull` argument typu narusza ograniczenie, kompilator generuje ostrzeżenie zamiast błędu.</span><span class="sxs-lookup"><span data-stu-id="254e2-128">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="254e2-129">Ostrzeżenia są generowane `nullable enable` tylko w kontekście.</span><span class="sxs-lookup"><span data-stu-id="254e2-129">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="254e2-130">Ogólne deklaracje, `notnull` które zawierają ograniczenie mogą być używane w kontekście nullable oblivious, ale kompilator nie wymusza ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="254e2-130">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="254e2-131">Klauzula `where` może również `unmanaged` zawierać ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="254e2-131">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="254e2-132">Ograniczenie `unmanaged` ogranicza parametr typu do typów nazywany jako [typy niezarządzane](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="254e2-132">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="254e2-133">Ograniczenie `unmanaged` ułatwia pisanie kodu interop niskiego poziomu w języku C#.</span><span class="sxs-lookup"><span data-stu-id="254e2-133">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="254e2-134">To ograniczenie umożliwia procedury wielokrotnegoużynia we wszystkich typach niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="254e2-134">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="254e2-135">Ograniczenia `unmanaged` nie można łączyć `class` z `struct` ograniczeniem lub ograniczeniem.</span><span class="sxs-lookup"><span data-stu-id="254e2-135">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="254e2-136">Ograniczenie `unmanaged` wymusza, że typ `struct`musi być:</span><span class="sxs-lookup"><span data-stu-id="254e2-136">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#4)]

<span data-ttu-id="254e2-137">Klauzula `where` może również zawierać ograniczenie `new()`konstruktora, .</span><span class="sxs-lookup"><span data-stu-id="254e2-137">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="254e2-138">To ograniczenie umożliwia utworzenie wystąpienia parametru typu `new` przy użyciu operatora.</span><span class="sxs-lookup"><span data-stu-id="254e2-138">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="254e2-139">[Ograniczenie new()](new-constraint.md) informuje kompilatora wiedzieć, że każdy argument typu dostarczone musi mieć dostępne bez parametrów konstruktora.</span><span class="sxs-lookup"><span data-stu-id="254e2-139">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="254e2-140">Przykład:</span><span class="sxs-lookup"><span data-stu-id="254e2-140">For example:</span></span>

[!code-csharp[using the new constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#5)]

<span data-ttu-id="254e2-141">Ograniczenie `new()` pojawia się `where` ostatnio w klauzuli.</span><span class="sxs-lookup"><span data-stu-id="254e2-141">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="254e2-142">Ograniczenia `new()` nie można łączyć `struct` z `unmanaged` ograniczeniami lub ograniczeniami.</span><span class="sxs-lookup"><span data-stu-id="254e2-142">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="254e2-143">Wszystkie typy spełniające te ograniczenia muszą mieć dostępny `new()` konstruktor bez parametrów, co powoduje, że ograniczenie jest zbędne.</span><span class="sxs-lookup"><span data-stu-id="254e2-143">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="254e2-144">W przypadku wielu parametrów typu należy użyć jednej `where` klauzuli dla każdego parametru typu, na przykład:</span><span class="sxs-lookup"><span data-stu-id="254e2-144">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#6)]

<span data-ttu-id="254e2-145">Ograniczenia można również dołączyć do parametrów typu metod ogólnych, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="254e2-145">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#7)]

<span data-ttu-id="254e2-146">Należy zauważyć, że składnia opisująca ograniczenia parametrów typu delegatów jest taka sama jak w metodach:</span><span class="sxs-lookup"><span data-stu-id="254e2-146">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#8)]

<span data-ttu-id="254e2-147">Aby uzyskać informacje na temat delegatów ogólnych, zobacz [Ogólne delegatów](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="254e2-147">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="254e2-148">Aby uzyskać szczegółowe informacje na temat składni i stosowania ograniczeń, zobacz [Ograniczenia dotyczące parametrów typu](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="254e2-148">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="254e2-149">specyfikacja języka C#</span><span class="sxs-lookup"><span data-stu-id="254e2-149">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="254e2-150">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="254e2-150">See also</span></span>

- [<span data-ttu-id="254e2-151">Odwołanie do języka C#</span><span class="sxs-lookup"><span data-stu-id="254e2-151">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="254e2-152">C# Przewodnik programowania</span><span class="sxs-lookup"><span data-stu-id="254e2-152">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="254e2-153">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="254e2-153">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="254e2-154">nowe ograniczenie</span><span class="sxs-lookup"><span data-stu-id="254e2-154">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="254e2-155">Ograniczenia dotyczące parametrów typu</span><span class="sxs-lookup"><span data-stu-id="254e2-155">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
