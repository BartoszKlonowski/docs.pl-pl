---
title: WHERE (ograniczenie typu ogólnego) — odwołanie w C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 406c710cd884363c32b98336717732a09b3d1fc1
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/04/2020
ms.locfileid: "84401878"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="1acc9-102">where — Ograniczenie typu ogólnego (odwołanie w C#)</span><span class="sxs-lookup"><span data-stu-id="1acc9-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="1acc9-103">`where`Klauzula w definicji ogólnej określa ograniczenia dotyczące typów, które są używane jako argumenty parametrów typu w typie ogólnym, metodzie, delegatze lub funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="1acc9-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="1acc9-104">Ograniczenia mogą określać interfejsy, klasy bazowe lub wymagać typu ogólnego, aby być odwołaniem, wartością lub typem niezarządzanym.</span><span class="sxs-lookup"><span data-stu-id="1acc9-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="1acc9-105">Deklarują możliwości, że argument typu musi mieć wartość.</span><span class="sxs-lookup"><span data-stu-id="1acc9-105">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="1acc9-106">Na przykład można zadeklarować klasę generyczną, `MyGenericClass` w taki sposób, aby parametr typu `T` implementuje <xref:System.IComparable%601> Interfejs:</span><span class="sxs-lookup"><span data-stu-id="1acc9-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="1acc9-107">Aby uzyskać więcej informacji na temat klauzuli WHERE w wyrażeniu zapytania, zobacz [klauzula WHERE](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="1acc9-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="1acc9-108">`where`Klauzula może również zawierać ograniczenie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="1acc9-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="1acc9-109">Ograniczenie klasy bazowej określa, że typ, który ma być używany jako argument typu dla tego typu ogólnego ma określoną klasę jako klasę bazową, lub jest tą klasą bazową.</span><span class="sxs-lookup"><span data-stu-id="1acc9-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="1acc9-110">Jeśli jest używane ograniczenie klasy bazowej, musi ono znajdować się przed innymi ograniczeniami tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="1acc9-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="1acc9-111">Niektóre typy są niedozwolone jako ograniczenie klasy bazowej: <xref:System.Object> , <xref:System.Array> , i <xref:System.ValueType> .</span><span class="sxs-lookup"><span data-stu-id="1acc9-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="1acc9-112">Przed C# 7,3, <xref:System.Enum> , <xref:System.Delegate> i <xref:System.MulticastDelegate> były również niedozwolone jako ograniczenia klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="1acc9-112">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="1acc9-113">W poniższym przykładzie przedstawiono typy, które można teraz określić jako klasę bazową:</span><span class="sxs-lookup"><span data-stu-id="1acc9-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="1acc9-114">W kontekście dopuszczającym wartość null w języku C# 8,0 i nowszych wartości null typu klasy bazowej są wymuszane.</span><span class="sxs-lookup"><span data-stu-id="1acc9-114">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="1acc9-115">Jeśli klasa bazowa nie dopuszcza wartości null (na przykład `Base` ), argument typu nie może dopuszczać wartości null.</span><span class="sxs-lookup"><span data-stu-id="1acc9-115">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="1acc9-116">Jeśli klasa bazowa nie dopuszcza wartości null (na przykład `Base?` ), argument typu może być typem referencyjnym nullable lub niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="1acc9-116">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="1acc9-117">Kompilator generuje ostrzeżenie, jeśli argument typu jest typem referencyjnym dopuszczającym wartość null, jeśli klasa bazowa nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="1acc9-117">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="1acc9-118">`where`Klauzula może określać, że typem jest `class` lub `struct` .</span><span class="sxs-lookup"><span data-stu-id="1acc9-118">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="1acc9-119">`struct`Ograniczenie eliminuje konieczność określenia ograniczenia klasy bazowej `System.ValueType` .</span><span class="sxs-lookup"><span data-stu-id="1acc9-119">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="1acc9-120">`System.ValueType`Typ nie może być używany jako ograniczenie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="1acc9-120">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="1acc9-121">W poniższym przykładzie przedstawiono zarówno `class` warunek, jak i `struct` :</span><span class="sxs-lookup"><span data-stu-id="1acc9-121">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="1acc9-122">W kontekście dopuszczającym wartość null w języku C# 8,0 i nowszych, `class` ograniczenie wymaga typu jako typu referencyjnego, który nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="1acc9-122">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="1acc9-123">Aby zezwolić na typy referencyjne dopuszczające wartość null, użyj `class?` ograniczenia, które zezwala na typ referencyjny dopuszczający wartości null i niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="1acc9-123">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="1acc9-124">`where`Klauzula może zawierać `notnull` ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="1acc9-124">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="1acc9-125">`notnull`Ograniczenie ogranicza parametr typu do typu niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="1acc9-125">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="1acc9-126">Ten typ może być typem [wartości](../builtin-types/value-types.md) lub typem referencyjnym, który nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="1acc9-126">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="1acc9-127">To `notnull` ograniczenie jest dostępne począwszy od języka C# 8,0 dla kodu skompilowanego w [ `nullable enable` kontekście](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="1acc9-127">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="1acc9-128">W przeciwieństwie do innych ograniczeń, jeśli argument typu narusza `notnull` ograniczenie, kompilator generuje ostrzeżenie zamiast błędu.</span><span class="sxs-lookup"><span data-stu-id="1acc9-128">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="1acc9-129">Ostrzeżenia są generowane tylko w `nullable enable` kontekście.</span><span class="sxs-lookup"><span data-stu-id="1acc9-129">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1acc9-130">Deklaracje ogólne zawierające `notnull` ograniczenie mogą być używane w kontekście wartości null Oblivious, ale kompilator nie wymusza ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="1acc9-130">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="1acc9-131">`where`Klauzula może również zawierać `unmanaged` ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="1acc9-131">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="1acc9-132">`unmanaged`Ograniczenie ogranicza parametr typu do typów znanych jako [typy niezarządzane](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="1acc9-132">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="1acc9-133">To `unmanaged` ograniczenie ułatwia zapisanie kodu międzyoperacyjności niskiego poziomu w języku C#.</span><span class="sxs-lookup"><span data-stu-id="1acc9-133">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="1acc9-134">To ograniczenie umożliwia wykonywanie procedur wielokrotnego użytku we wszystkich typach niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="1acc9-134">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="1acc9-135">`unmanaged`Nie można połączyć ograniczenia z `class` `struct` ograniczeniem or.</span><span class="sxs-lookup"><span data-stu-id="1acc9-135">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="1acc9-136">`unmanaged`Ograniczenie wymusza, że typ musi być `struct` :</span><span class="sxs-lookup"><span data-stu-id="1acc9-136">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="1acc9-137">`where`Klauzula może również zawierać ograniczenie konstruktora `new()` .</span><span class="sxs-lookup"><span data-stu-id="1acc9-137">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="1acc9-138">To ograniczenie umożliwia utworzenie wystąpienia parametru typu za pomocą `new` operatora.</span><span class="sxs-lookup"><span data-stu-id="1acc9-138">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="1acc9-139">To [ograniczenie New ()](new-constraint.md) umożliwia kompilatorowi, że każdy dostarczony argument typu musi mieć dostępny Konstruktor bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="1acc9-139">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="1acc9-140">Przykład:</span><span class="sxs-lookup"><span data-stu-id="1acc9-140">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="1acc9-141">`new()`Ograniczenie jest wyświetlane jako ostatnie w `where` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="1acc9-141">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="1acc9-142">`new()`Nie można połączyć ograniczenia z `struct` `unmanaged` ograniczeniami lub.</span><span class="sxs-lookup"><span data-stu-id="1acc9-142">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="1acc9-143">Wszystkie typy spełniające te ograniczenia muszą mieć dostępny Konstruktor bez parametrów, co sprawia, że `new()` ograniczenie jest nadmiarowe.</span><span class="sxs-lookup"><span data-stu-id="1acc9-143">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="1acc9-144">W przypadku wielu parametrów typu należy użyć jednej `where` klauzuli dla każdego parametru typu, na przykład:</span><span class="sxs-lookup"><span data-stu-id="1acc9-144">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="1acc9-145">Można również dołączyć ograniczenia do parametrów typu metod ogólnych, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="1acc9-145">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="1acc9-146">Zauważ, że składnia opisująca ograniczenia parametru typu dla delegatów jest taka sama jak w przypadku metod:</span><span class="sxs-lookup"><span data-stu-id="1acc9-146">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="1acc9-147">Aby uzyskać informacje na temat delegatów ogólnych, zobacz [Delegaty ogólne](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="1acc9-147">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="1acc9-148">Aby uzyskać szczegółowe informacje na temat składni i użycia ograniczeń, zobacz [ograniczenia dotyczące parametrów typu](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="1acc9-148">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="1acc9-149">specyfikacja języka C#</span><span class="sxs-lookup"><span data-stu-id="1acc9-149">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="1acc9-150">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="1acc9-150">See also</span></span>

- [<span data-ttu-id="1acc9-151">Odwołanie w C#</span><span class="sxs-lookup"><span data-stu-id="1acc9-151">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="1acc9-152">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="1acc9-152">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="1acc9-153">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="1acc9-153">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="1acc9-154">nowe ograniczenie</span><span class="sxs-lookup"><span data-stu-id="1acc9-154">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="1acc9-155">Ograniczenia dotyczące parametrów typu</span><span class="sxs-lookup"><span data-stu-id="1acc9-155">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
