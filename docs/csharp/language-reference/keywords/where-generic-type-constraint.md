---
title: WHERE (ograniczenie typu ogólnego) — C# odwołanie
ms.custom: seodec18
ms.date: 04/12/2018
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 4e51c5dd226533e7d1ce79a136dba19cbb252f92
ms.sourcegitcommit: 4e2d355baba82814fa53efd6b8bbb45bfe054d11
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/04/2019
ms.locfileid: "70253916"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="78e99-102">where — Ograniczenie typu ogólnego (odwołanie w C#)</span><span class="sxs-lookup"><span data-stu-id="78e99-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="78e99-103">`where` Klauzula w definicji ogólnej określa ograniczenia dotyczące typów, które są używane jako argumenty parametrów typu w typie ogólnym, metodzie, delegatze lub funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="78e99-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="78e99-104">Ograniczenia mogą określać interfejsy, klasy bazowe lub wymagać typu ogólnego, aby być odwołaniem, wartością lub typem niezarządzanym.</span><span class="sxs-lookup"><span data-stu-id="78e99-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="78e99-105">Deklarują możliwości, że argument typu musi mieć wartość.</span><span class="sxs-lookup"><span data-stu-id="78e99-105">They declare capabilities that the type argument must possess.</span></span>

<span data-ttu-id="78e99-106">Na przykład można zadeklarować klasę `MyGenericClass`generyczną, w taki sposób, aby parametr `T` typu implementuje <xref:System.IComparable%601> interfejs:</span><span class="sxs-lookup"><span data-stu-id="78e99-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="78e99-107">Aby uzyskać więcej informacji na temat klauzuli WHERE w wyrażeniu zapytania, zobacz [klauzula WHERE](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="78e99-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="78e99-108">`where` Klauzula może również zawierać ograniczenie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="78e99-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="78e99-109">Ograniczenie klasy bazowej określa, że typ, który ma być używany jako argument typu dla tego typu ogólnego ma określoną klasę jako klasę bazową (lub jest tą klasą bazową), która ma być używana jako argument typu dla tego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="78e99-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class (or is that base class) to be used as a type argument for that generic type.</span></span> <span data-ttu-id="78e99-110">Jeśli jest używane ograniczenie klasy bazowej, musi ono znajdować się przed innymi ograniczeniami tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="78e99-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="78e99-111">Niektóre typy są niedozwolone jako ograniczenie klasy bazowej: <xref:System.Object>, <xref:System.Array>, i <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="78e99-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="78e99-112">Przed C# 7,3, <xref:System.Enum> <xref:System.Delegate>, i<xref:System.MulticastDelegate> były również niedozwolone jako ograniczenia klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="78e99-112">Prior to C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="78e99-113">W poniższym przykładzie przedstawiono typy, które można teraz określić jako klasę bazową:</span><span class="sxs-lookup"><span data-stu-id="78e99-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#2)]

<span data-ttu-id="78e99-114">Klauzula może określać, że typem `class` jest lub `struct`. `where`</span><span class="sxs-lookup"><span data-stu-id="78e99-114">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="78e99-115">Ograniczenie eliminuje konieczność określenia `System.ValueType`ograniczenia klasy bazowej. `struct`</span><span class="sxs-lookup"><span data-stu-id="78e99-115">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="78e99-116">`System.ValueType` Typ nie może być używany jako ograniczenie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="78e99-116">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="78e99-117">W poniższym przykładzie przedstawiono zarówno `class` warunek, jak i: `struct`</span><span class="sxs-lookup"><span data-stu-id="78e99-117">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#3)]

<span data-ttu-id="78e99-118">`where` Klauzula może`notnull` zawierać ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="78e99-118">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="78e99-119">`notnull` Ograniczenie ogranicza parametr typu do typu niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="78e99-119">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="78e99-120">Ten typ może być typem [wartości](struct.md) lub typem referencyjnym, który nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="78e99-120">That type may be a [value type](struct.md) or a non-nullable reference type.</span></span> <span data-ttu-id="78e99-121">To ograniczenie jest dostępne od [ `nullable enable` ](../../nullable-references.md#nullable-contexts) C# 8,0 do kodu skompilowanego w kontekście. `notnull`</span><span class="sxs-lookup"><span data-stu-id="78e99-121">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="78e99-122">W przeciwieństwie do innych ograniczeń, jeśli argument typu narusza `notnull` ograniczenie, kompilator generuje ostrzeżenie zamiast błędu.</span><span class="sxs-lookup"><span data-stu-id="78e99-122">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="78e99-123">Ostrzeżenia są generowane tylko w `nullable enable` kontekście.</span><span class="sxs-lookup"><span data-stu-id="78e99-123">Warnings are only generated in a `nullable enable` context.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="78e99-124">Deklaracje ogólne zawierające `notnull` ograniczenie mogą być używane w kontekście wartości null Oblivious, ale kompilator nie wymusza ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="78e99-124">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="78e99-125">Klauzula może również `unmanaged` zawierać ograniczenie. `where`</span><span class="sxs-lookup"><span data-stu-id="78e99-125">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="78e99-126">Ograniczenie ogranicza parametr typu do typów znanych jako [typy niezarządzane.](../builtin-types/unmanaged-types.md) `unmanaged`</span><span class="sxs-lookup"><span data-stu-id="78e99-126">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="78e99-127">To `unmanaged` ograniczenie ułatwia zapisanie kodu międzyoperacyjności niskiego poziomu w C#programie.</span><span class="sxs-lookup"><span data-stu-id="78e99-127">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="78e99-128">To ograniczenie umożliwia wykonywanie procedur wielokrotnego użytku we wszystkich typach niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="78e99-128">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="78e99-129">Nie można połączyć `class` `struct` ograniczenia z ograniczeniem or. `unmanaged`</span><span class="sxs-lookup"><span data-stu-id="78e99-129">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="78e99-130">Ograniczenie wymusza, że typ musi `struct`być: `unmanaged`</span><span class="sxs-lookup"><span data-stu-id="78e99-130">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#4)]

<span data-ttu-id="78e99-131">Klauzula może również zawierać `new()`ograniczenie konstruktora. `where`</span><span class="sxs-lookup"><span data-stu-id="78e99-131">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="78e99-132">To ograniczenie umożliwia utworzenie wystąpienia parametru typu za pomocą `new` operatora.</span><span class="sxs-lookup"><span data-stu-id="78e99-132">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="78e99-133">To [ograniczenie New ()](new-constraint.md) umożliwia kompilatorowi, że każdy dostarczony argument typu musi mieć dostępny bez parametrów--lub default--konstruktora.</span><span class="sxs-lookup"><span data-stu-id="78e99-133">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless--or default-- constructor.</span></span> <span data-ttu-id="78e99-134">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="78e99-134">For example:</span></span>

[!code-csharp[using the new constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#5)]

<span data-ttu-id="78e99-135">Ograniczenie jest wyświetlane jako ostatnie `where` w klauzuli. `new()`</span><span class="sxs-lookup"><span data-stu-id="78e99-135">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="78e99-136">Nie można połączyć `struct` `unmanaged` ograniczenia z ograniczeniami lub. `new()`</span><span class="sxs-lookup"><span data-stu-id="78e99-136">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="78e99-137">Wszystkie typy spełniające te ograniczenia muszą mieć dostępny Konstruktor bez parametrów, co sprawia, `new()` że ograniczenie jest nadmiarowe.</span><span class="sxs-lookup"><span data-stu-id="78e99-137">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="78e99-138">W przypadku wielu parametrów typu należy użyć `where` jednej klauzuli dla każdego parametru typu, na przykład:</span><span class="sxs-lookup"><span data-stu-id="78e99-138">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#6)]

<span data-ttu-id="78e99-139">Można również dołączyć ograniczenia do parametrów typu metod ogólnych, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="78e99-139">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#7)]

<span data-ttu-id="78e99-140">Zauważ, że składnia opisująca ograniczenia parametru typu dla delegatów jest taka sama jak w przypadku metod:</span><span class="sxs-lookup"><span data-stu-id="78e99-140">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#8)]

<span data-ttu-id="78e99-141">Aby uzyskać informacje na temat delegatów ogólnych, zobacz [Delegaty ogólne](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="78e99-141">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="78e99-142">Aby uzyskać szczegółowe informacje na temat składni i użycia ograniczeń, zobacz [ograniczenia dotyczące parametrów typu](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="78e99-142">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="78e99-143">specyfikacja języka C#</span><span class="sxs-lookup"><span data-stu-id="78e99-143">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="78e99-144">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="78e99-144">See also</span></span>

- [<span data-ttu-id="78e99-145">Dokumentacja języka C#</span><span class="sxs-lookup"><span data-stu-id="78e99-145">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="78e99-146">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="78e99-146">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="78e99-147">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="78e99-147">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="78e99-148">new, ograniczenie</span><span class="sxs-lookup"><span data-stu-id="78e99-148">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="78e99-149">Ograniczenia dotyczące parametrów typu</span><span class="sxs-lookup"><span data-stu-id="78e99-149">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
