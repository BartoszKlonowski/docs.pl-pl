---
description: Ostrzeżenie kompilatora (poziom 2) CS1701
title: Ostrzeżenie kompilatora (poziom 2) CS1701
ms.date: 07/20/2015
f1_keywords:
- CS1701
helpviewer_keywords:
- CS1701
ms.assetid: adbaf99e-c283-49a7-b940-4c9b84ebcb03
ms.openlocfilehash: fa52f0c94ebf53452b473740e07dcf021e307d49
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/30/2020
ms.locfileid: "89128819"
---
# <a name="compiler-warning-level-2-cs1701"></a><span data-ttu-id="a1f7f-103">Ostrzeżenie kompilatora (poziom 2) CS1701</span><span class="sxs-lookup"><span data-stu-id="a1f7f-103">Compiler Warning (level 2) CS1701</span></span>
<span data-ttu-id="a1f7f-104">Zakładając, że odwołanie do zestawu "Nazwa zestawu #1" pasuje do "nazwy zestawu #2", może być konieczne podanie zasad środowiska uruchomieniowego</span><span class="sxs-lookup"><span data-stu-id="a1f7f-104">Assuming assembly reference "Assembly Name #1" matches "Assembly Name #2", you may need to supply runtime policy</span></span>  
  
 <span data-ttu-id="a1f7f-105">Dwa zestawy różnią się od wersji i/lub numeru wersji.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-105">The two assemblies differ in release and/or version number.</span></span> <span data-ttu-id="a1f7f-106">Aby można było przeprowadzić ujednolicenie, należy określić dyrektywy w pliku. config aplikacji i podać poprawną silną nazwę zestawu, jak pokazano w poniższym przykładowym kodzie.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-106">For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly, as demonstrated in the following example code.</span></span>  
  
## <a name="example"></a><span data-ttu-id="a1f7f-107">Przykład</span><span class="sxs-lookup"><span data-stu-id="a1f7f-107">Example</span></span>  
 <span data-ttu-id="a1f7f-108">Poniższy przykład wieloplikowy odwołuje się do zestawu przy użyciu dwóch różnych aliasów zewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-108">The following multifile sample references an assembly using two different external aliases.</span></span> <span data-ttu-id="a1f7f-109">Ten pierwszy przykład tworzy starszą wersję kodu, który tworzy CS1701_d zestawu.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-109">This first sample builds the older version of the code that creates assembly CS1701_d.</span></span>  
  
```csharp  
// CS1701_a.cs  
// compile with: /target:library /out:cs1701_d.dll /keyfile:mykey.snk  
using System.Reflection;  
[assembly:AssemblyVersion("1.0")]  
public class A {  
   public void M1() {}  
}  
  
public class C1 {}  
```  
  
## <a name="example"></a><span data-ttu-id="a1f7f-110">Przykład</span><span class="sxs-lookup"><span data-stu-id="a1f7f-110">Example</span></span>  
 <span data-ttu-id="a1f7f-111">Jest to kod, który tworzy nowszą wersję zestawu CS1701_d.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-111">This is the code that creates the newer version of assembly CS1701_d.</span></span> <span data-ttu-id="a1f7f-112">Należy pamiętać, że kompiluje się do innego katalogu niż w starszej wersji, co jest konieczne, ponieważ pliki wyjściowe mają takie same nazwy.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-112">Note that it compiles into a different directory than the older version, necessary since the output files have the same names.</span></span>  
  
```csharp  
// CS1701_b.cs  
// compile with: /target:library /out:c:\\cs1701_d.dll /keyfile:mykey.snk  
using System.Reflection;  
[assembly:AssemblyVersion("2.0")]  
public class A {  
   public void M2() {}  
   public void M1() {}  
}  
  
public class C2 {}  
public class C1 {}  
```  
  
## <a name="example"></a><span data-ttu-id="a1f7f-113">Przykład</span><span class="sxs-lookup"><span data-stu-id="a1f7f-113">Example</span></span>  
 <span data-ttu-id="a1f7f-114">Ten przykład umożliwia skonfigurowanie aliasów zewnętrznych a1 i a2.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-114">This sample sets up the external aliases A1 and A2.</span></span>  
  
```csharp  
// CS1701_c.cs  
// compile with: /target:library /reference:A2=c:\\cs1701_d.dll /reference:A1=cs1701_d.dll  
  
extern alias A1;  
extern alias A2;  
// using System;  
using a1 = A1::A;  
using a2 = A2::A;  
  
public class Ref {  
   public static a1 A1() { return new a1(); }  
   public static a2 A2() { return new a2(); }  
  
   public static A1::C1 M1() { return new A1::C1(); }  
   public static A2::C2 M2() { return new A2::C2(); }  
}  
```  
  
## <a name="example"></a><span data-ttu-id="a1f7f-115">Przykład</span><span class="sxs-lookup"><span data-stu-id="a1f7f-115">Example</span></span>  
 <span data-ttu-id="a1f7f-116">Ten przykład wywołuje metody przy użyciu dwóch różnych aliasów. Poniższy przykład generuje C1701.</span><span class="sxs-lookup"><span data-stu-id="a1f7f-116">This sample calls methods using two different aliases of A. The following sample generates C1701.</span></span>  
  
```csharp  
// CS1701_d.cs  
// compile with: /reference:c:\\CS1701_d.dll /reference:CS1701_c.dll  
// CS1701 expected  
class Tester {  
   public static void Main() {  
      Ref.A1().M1();  
      Ref.A2().M2();  
   }  
}  
```
