---
title: Błąd kompilatora CS1612
ms.date: 07/20/2015
f1_keywords:
- CS1612
helpviewer_keywords:
- CS1612
ms.assetid: ef5db985-030a-4f15-b53f-e92c9297c6a3
ms.openlocfilehash: 0d6fbedd7dfd560ba9e5dbd44f5d1d09fc250624
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/30/2019
ms.locfileid: "68627768"
---
# <a name="compiler-error-cs1612"></a><span data-ttu-id="cf603-102">Błąd kompilatora CS1612</span><span class="sxs-lookup"><span data-stu-id="cf603-102">Compiler Error CS1612</span></span>
<span data-ttu-id="cf603-103">Nie można zmodyfikować zwracanej wartości wyrażenia "Expression", ponieważ nie jest to zmienna.</span><span class="sxs-lookup"><span data-stu-id="cf603-103">Cannot modify the return value of 'expression' because it is not a variable</span></span>  
  
 <span data-ttu-id="cf603-104">Podjęto próbę zmodyfikowania typu wartości, który jest tworzony jako wynik wyrażenia pośredniego, ale nie jest on przechowywany w zmiennej.</span><span class="sxs-lookup"><span data-stu-id="cf603-104">An attempt was made to modify a value type that is produced as the result of an intermediate expression but is not stored in a variable.</span></span> <span data-ttu-id="cf603-105">Ten błąd może wystąpić, gdy próbujesz bezpośrednio zmodyfikować strukturę w kolekcji ogólnej, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="cf603-105">This error can occur when you attempt to directly modify a struct in a generic collection, as shown in the following example:</span></span>  
  
```csharp  
List<myStruct> list = {…};  
list[0].Name = "MyStruct42"; //CS1612  
```  
  
 <span data-ttu-id="cf603-106">Aby zmodyfikować strukturę, najpierw Przypisz ją do zmiennej lokalnej, zmodyfikuj zmienną, a następnie przypisz zmienną z powrotem do elementu w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="cf603-106">To modify the struct, first assign it to a local variable, modify the variable, then assign the variable back to the item in the collection.</span></span>  
  
```csharp  
List<myStruct> list = {…};  
MyStruct ms = list[0];  
ms.Name = "MyStruct42";  
list[0] = ms;  
```  
  
 <span data-ttu-id="cf603-107">Ten błąd występuje, ponieważ typy wartości są kopiowane podczas przypisywania.</span><span class="sxs-lookup"><span data-stu-id="cf603-107">This error occurs because value types are copied on assignment.</span></span> <span data-ttu-id="cf603-108">Po pobraniu typu wartości z właściwości lub indeksatora pobierana jest kopia obiektu, a nie odwołanie do samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="cf603-108">When you retrieve a value type from a property or indexer, you are getting a copy of the object, not a reference to the object itself.</span></span> <span data-ttu-id="cf603-109">Zwracana kopia nie jest przechowywana przez właściwość ani indeksator, ponieważ są one w rzeczywistości metodami, a nie lokalizacjami magazynu (zmiennymi).</span><span class="sxs-lookup"><span data-stu-id="cf603-109">The copy that is returned is not stored by the property or indexer because they are actually methods, not storage locations (variables).</span></span> <span data-ttu-id="cf603-110">Aby można było zmodyfikować tę kopię, należy ją zapisać w zmiennej, która została zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="cf603-110">You must store the copy into a variable that you declare before you can modify it.</span></span>  
  
 <span data-ttu-id="cf603-111">Błąd nie występuje w przypadku typów referencyjnych, ponieważ właściwość lub indeksator w tym przypadku zwraca odwołanie do istniejącego obiektu, który jest lokalizacją magazynu.</span><span class="sxs-lookup"><span data-stu-id="cf603-111">The error does not occur with reference types because a property or indexer in that case returns a reference to an existing object, which is a storage location.</span></span>  
  
 <span data-ttu-id="cf603-112">Jeśli definiujesz klasę lub strukturę, możesz rozwiązać ten błąd, modyfikując deklarację właściwości, aby zapewnić dostęp do elementów członkowskich struktury.</span><span class="sxs-lookup"><span data-stu-id="cf603-112">If you are defining the class or struct, you can resolve this error by modifying your property declaration to provide access to the members of a struct.</span></span> <span data-ttu-id="cf603-113">Jeśli piszesz kod klienta, możesz rozwiązać ten problem, tworząc własne wystąpienie struktury, modyfikując jej pola, a następnie przypisując całą strukturę z powrotem do właściwości.</span><span class="sxs-lookup"><span data-stu-id="cf603-113">If you are writing client code, you can resolve the error by creating your own instance of the struct, modifying its fields, and then assigning the entire struct back to the property.</span></span> <span data-ttu-id="cf603-114">Jako trzeci alternatywę można zmienić strukturę na klasę.</span><span class="sxs-lookup"><span data-stu-id="cf603-114">As a third alternative, you can change your struct to a class.</span></span>  
  
## <a name="example"></a><span data-ttu-id="cf603-115">Przykład</span><span class="sxs-lookup"><span data-stu-id="cf603-115">Example</span></span>  
 <span data-ttu-id="cf603-116">CS1612 występuje również przy próbie uzyskania dostępu do elementu członkowskiego struktury za pomocą właściwości w otaczającej klasie, która zwraca całą strukturę, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="cf603-116">CS1612 also occurs when you attempt to access the member of a struct through a property on an enclosing class that is returning the entire struct, as shown in the following example:</span></span>  
  
```csharp  
// CS1612.cs  
using System;  
  
public struct MyStruct  
{  
    public int Width;  
}  
  
public class ListView  
{  
    MyStruct ms;  
    public MyStruct Size  
    {  
        get { return ms; }  
        set { ms = value; }  
    }  
}  
  
public class MyClass  
{  
    public MyClass()  
    {  
        ListView lvi;  
        lvi = new ListView();  
        lvi.Size.Width = 5; // CS1612  
  
        // You can use the following lines instead.  
        // MyStruct ms;  
        // ms.Width = 5;  
        // lvi.Size = ms;
    }  
  
    public static void Main()   
    {  
        MyClass mc = new MyClass();  
        // Keep the console open in debug mode.  
        Console.WriteLine("Press any key to exit.");  
        Console.ReadKey();     
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="cf603-117">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="cf603-117">See also</span></span>

- [<span data-ttu-id="cf603-118">Struktury</span><span class="sxs-lookup"><span data-stu-id="cf603-118">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)
- [<span data-ttu-id="cf603-119">Typy wartości</span><span class="sxs-lookup"><span data-stu-id="cf603-119">Value Types</span></span>](../../../csharp/language-reference/keywords/value-types.md)
- [<span data-ttu-id="cf603-120">Typy odwołań</span><span class="sxs-lookup"><span data-stu-id="cf603-120">Reference Types</span></span>](../../../csharp/language-reference/keywords/reference-types.md)
