---
title: "Wyrażenia (Przewodnik programowania w języku C#)"
ms.date: 05/11/2017
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- expressions [C#]
- C# language, expressions
ms.assetid: c7d8feb0-0e58-4f94-8bf6-4d070550a832
caps.latest.revision: "22"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 579851b8c72595ffa5b4cf8267fdc73cd2823d0f
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2017
---
# <a name="expressions-c-programming-guide"></a><span data-ttu-id="eb2c5-102">Wyrażenia (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="eb2c5-102">Expressions (C# Programming Guide)</span></span>
<span data-ttu-id="eb2c5-103">*Wyrażenie* Sekwencja zero lub więcej operatorów, które może przyjąć pojedynczą wartość, obiekt, metodę lub przestrzeń nazw i jeden lub więcej argumentów operacji.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-103">An *expression* is a sequence of one or more operands and zero or more operators that can be evaluated to a single value, object, method, or namespace.</span></span> <span data-ttu-id="eb2c5-104">Wartość literału, wywołania metody, operator i argumentów, może zawierać wyrażenia lub *prosta nazwa*.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-104">Expressions can consist of a literal value, a method invocation, an operator and its operands, or a *simple name*.</span></span> <span data-ttu-id="eb2c5-105">Proste nazwy mogą być nazwę zmiennej, członka typu, parametru metody, przestrzeni nazw lub typu.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-105">Simple names can be the name of a variable, type member, method parameter, namespace or type.</span></span>  
  
 <span data-ttu-id="eb2c5-106">Wyrażenia można używać operatorów, które z kolei inne wyrażenia używane jako parametry lub wywołania metody, której parametry są z kolei inne wywołania metody, więc wyrażenia mogą należeć do zakresu od prostego do bardzo złożonych.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-106">Expressions can use operators that in turn use other expressions as parameters, or method calls whose parameters are in turn other method calls, so expressions can range from simple to very complex.</span></span> <span data-ttu-id="eb2c5-107">Poniżej przedstawiono dwa przykłady wyrażeń:</span><span class="sxs-lookup"><span data-stu-id="eb2c5-107">Following are two examples of expressions:</span></span>  
  
```csharp  
((x < 10) && ( x > 5)) || ((x > 20) && (x < 25));
   
System.Convert.ToInt32("35");  
```  
  
## <a name="expression-values"></a><span data-ttu-id="eb2c5-108">Wyrażenie wartości</span><span class="sxs-lookup"><span data-stu-id="eb2c5-108">Expression values</span></span>  
 <span data-ttu-id="eb2c5-109">W większości w sytuacjach, w których są używane wyrażenia, na przykład w instrukcji lub parametry metody wyrażenia powinien zwrócić wartości.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-109">In most of the contexts in which expressions are used, for example in statements or method parameters, the expression is expected to evaluate to some value.</span></span> <span data-ttu-id="eb2c5-110">Jeśli x i y są liczbami całkowitymi, wyrażenie `x + y` wynikiem jest wartość liczbowa.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-110">If x and y are integers, the expression `x + y` evaluates to a numeric value.</span></span> <span data-ttu-id="eb2c5-111">Wyrażenie `new MyClass()` wynikiem obliczenia jest odwołanie do nowego wystąpienia `MyClass` obiektu.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-111">The expression `new MyClass()` evaluates to a reference to a new instance of a `MyClass` object.</span></span> <span data-ttu-id="eb2c5-112">Wyrażenie `myClass.ToString()` ocenia na ciąg, ponieważ jest to typ zwracany metody.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-112">The expression `myClass.ToString()` evaluates to a string because that is the return type of the method.</span></span> <span data-ttu-id="eb2c5-113">Jednak mimo że nazwa przestrzeni nazw jest sklasyfikowany jako wyrażenie, nie zwraca wartości i dlatego nigdy nie może mieć końcowego wyniku dowolne wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-113">However, although a namespace name is classified as an expression, it does not evaluate to a value and therefore can never be the final result of any expression.</span></span> <span data-ttu-id="eb2c5-114">Nie można przekazać nazwę przestrzeni nazw do parametru metody, lub użyć go w nowym wyrażeniu lub przypisać go do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-114">You cannot pass a namespace name to a method parameter, or use it in a new expression, or assign it to a variable.</span></span> <span data-ttu-id="eb2c5-115">Można używać tylko go jako wyrażenia podrzędnego w wyrażeniu większy.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-115">You can only use it as a sub-expression in a larger expression.</span></span> <span data-ttu-id="eb2c5-116">To samo dotyczy dla typów (w odróżnieniu od <xref:System.Type?displayProperty=nameWithType> obiektów), nazwy grup — metoda (od konkretnych metod) i zdarzenia [dodać](../../../csharp/language-reference/keywords/add.md) i [Usuń](../../../csharp/language-reference/keywords/remove.md) metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-116">The same is true for types (as distinct from <xref:System.Type?displayProperty=nameWithType> objects), method group names (as distinct from specific methods), and event [add](../../../csharp/language-reference/keywords/add.md) and [remove](../../../csharp/language-reference/keywords/remove.md) accessors.</span></span>  
  
 <span data-ttu-id="eb2c5-117">Każda wartość ma skojarzonego typu.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-117">Every value has an associated type.</span></span> <span data-ttu-id="eb2c5-118">Na przykład jeśli x i y są obie zmienne typu `int`, wartość wyrażenia `x + y` jest również typu `int`.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-118">For example, if x and y are both variables of type `int`, the value of the expression `x + y` is also typed as `int`.</span></span> <span data-ttu-id="eb2c5-119">Jeśli wartość jest przypisany do zmiennej innego typu albo x i y są różnych typów, stosowane są reguły konwersji typu.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-119">If the value is assigned to a variable of a different type, or if x and y are different types, the rules of type conversion are applied.</span></span> <span data-ttu-id="eb2c5-120">Aby uzyskać więcej informacji na temat działania takich konwersje zobacz [rzutowanie i konwersje typów](../../../csharp/programming-guide/types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-120">For more information about how such conversions work, see [Casting and Type Conversions](../../../csharp/programming-guide/types/casting-and-type-conversions.md).</span></span>  
  
## <a name="overflows"></a><span data-ttu-id="eb2c5-121">Przepełnienia</span><span class="sxs-lookup"><span data-stu-id="eb2c5-121">Overflows</span></span>  
 <span data-ttu-id="eb2c5-122">Wyrażenia liczbowe może powodować przepełnienia, jeśli wartość jest większa niż wartość maksymalna wartość typu.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-122">Numeric expressions may cause overflows if the value is larger than the maximum value of the value's type.</span></span> <span data-ttu-id="eb2c5-123">Aby uzyskać więcej informacji, zobacz [zaznaczony i niezaznaczony](../../../csharp/language-reference/keywords/checked-and-unchecked.md) i [jawne numeryczne Tabela konwersji](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-123">For more information, see [Checked and Unchecked](../../../csharp/language-reference/keywords/checked-and-unchecked.md) and [Explicit Numeric Conversions Table](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md).</span></span>  
  
## <a name="operator-precedence-and-associativity"></a><span data-ttu-id="eb2c5-124">Kolejność wykonywania działań i łączność</span><span class="sxs-lookup"><span data-stu-id="eb2c5-124">Operator precedence and associativity</span></span>  
 <span data-ttu-id="eb2c5-125">Sposób, w jakiej są oceniane wyrażenia podlega reguły pierwszeństwa łączność i operatora.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-125">The manner in which an expression is evaluated is governed by the rules of associativity and operator precedence.</span></span> <span data-ttu-id="eb2c5-126">Aby uzyskać więcej informacji, zobacz [operatory](../../../csharp/programming-guide/statements-expressions-operators/operators.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-126">For more information, see [Operators](../../../csharp/programming-guide/statements-expressions-operators/operators.md).</span></span>  
  
 <span data-ttu-id="eb2c5-127">Większość wyrażenia, z wyjątkiem wyrażeń przypisania i wyrażenia wywołania metody, musi być osadzony w instrukcji.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-127">Most expressions, except assignment expressions and method invocation expressions, must be embedded in a statement.</span></span> <span data-ttu-id="eb2c5-128">Aby uzyskać więcej informacji, zobacz [instrukcje](../../../csharp/programming-guide/statements-expressions-operators/statements.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-128">For more information, see [Statements](../../../csharp/programming-guide/statements-expressions-operators/statements.md).</span></span>  
  
## <a name="literals-and-simple-names"></a><span data-ttu-id="eb2c5-129">Literały i proste nazwy</span><span class="sxs-lookup"><span data-stu-id="eb2c5-129">Literals and simple names</span></span>  
 <span data-ttu-id="eb2c5-130">Najprostsza dwa rodzaje wyrażeń są literały i proste nazwy.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-130">The two simplest types of expressions are literals and simple names.</span></span> <span data-ttu-id="eb2c5-131">Literał jest wartością stałą, który nie ma nazwy.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-131">A literal is a constant value that has no name.</span></span> <span data-ttu-id="eb2c5-132">Na przykład w poniższym przykładzie kodu zarówno `5` i `"Hello World"` są wartości literałów:</span><span class="sxs-lookup"><span data-stu-id="eb2c5-132">For example, in the following code example, both `5` and `"Hello World"` are literal values:</span></span>  
  
 [!code-csharp[csProgGuideStatements#2](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/expressions_1.cs)]  
  
 <span data-ttu-id="eb2c5-133">Aby uzyskać więcej informacji na literały, zobacz [typów](../../../csharp/language-reference/keywords/types.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-133">For more information on literals, see [Types](../../../csharp/language-reference/keywords/types.md).</span></span>  
  
 <span data-ttu-id="eb2c5-134">W powyższym przykładzie zarówno `i` i `s` są proste nazwy, które identyfikują zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-134">In the preceding example, both `i` and `s` are simple names that identify local variables.</span></span> <span data-ttu-id="eb2c5-135">W przypadku używania tych zmiennych w wyrażeniu nazwę zmiennej daje w wyniku wartość, która obecnie jest przechowywane w zmiennej lokalizacji w pamięci.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-135">When those variables are used in an expression, the variable name evaluates to the value that is currently stored in the variable's location in memory.</span></span> <span data-ttu-id="eb2c5-136">Przedstawiono to w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="eb2c5-136">This is shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/expressions_2.cs)]  
## <a name="invocation-expressions"></a><span data-ttu-id="eb2c5-137">Wyrażenia wywołania</span><span class="sxs-lookup"><span data-stu-id="eb2c5-137">Invocation expressions</span></span>  
 <span data-ttu-id="eb2c5-138">W poniższym przykładzie, wywołanie `DoWork` wyrażenie wywołania.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-138">In the following code example, the call to `DoWork` is an invocation expression.</span></span>  
  
```csharp
DoWork();  
```  
  
 <span data-ttu-id="eb2c5-139">Wywołanie metody wymaga nazwę metody, jak nazwa, co w poprzednim przykładzie lub w wyniku innego wyrażenia, następuje nawiasy i wszelkie parametry metody.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-139">A method invocation requires the name of the method, either as a name as in the previous example, or as the result of another expression, followed by parenthesis and any method parameters.</span></span> <span data-ttu-id="eb2c5-140">Aby uzyskać więcej informacji, zobacz [metody](../../../csharp/programming-guide/classes-and-structs/methods.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-140">For more information, see [Methods](../../../csharp/programming-guide/classes-and-structs/methods.md).</span></span> <span data-ttu-id="eb2c5-141">Wywołanie delegata używa nazwy parametrów delegata i metody w nawiasach.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-141">A delegate invocation uses the name of a delegate and method parameters in parenthesis.</span></span> <span data-ttu-id="eb2c5-142">Aby uzyskać więcej informacji, zobacz [delegatów](../../../csharp/programming-guide/delegates/index.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-142">For more information, see [Delegates](../../../csharp/programming-guide/delegates/index.md).</span></span> <span data-ttu-id="eb2c5-143">Wywołań metod i delegowanie wywołań zwrócić wartość zwracaną przez metodę, jeśli metoda zwróci wartość.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-143">Method invocations and delegate invocations evaluate to the return value of the method, if the method returns a value.</span></span> <span data-ttu-id="eb2c5-144">Zamiast wartości w wyrażeniach nie można użyć metody zwracające typ void.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-144">Methods that return void cannot be used in place of a value in an expression.</span></span>  

## <a name="query-expressions"></a><span data-ttu-id="eb2c5-145">Wyrażenia zapytań</span><span class="sxs-lookup"><span data-stu-id="eb2c5-145">Query expressions</span></span>  
 <span data-ttu-id="eb2c5-146">Wyrażenia te same zasady dotyczą ogólnie wyrażenia zapytania.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-146">The same rules for expressions in general apply to query expressions.</span></span> <span data-ttu-id="eb2c5-147">Aby uzyskać więcej informacji, zobacz [wyrażenia zapytań LINQ](../../../csharp/programming-guide/linq-query-expressions/index.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-147">For more information, see [LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md).</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="eb2c5-148">Wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="eb2c5-148">Lambda expressions</span></span>  
 <span data-ttu-id="eb2c5-149">Wyrażenia lambda reprezentują "wbudowanego metody", które nie mieć nazwy, ale może mieć wejściowych parametry i użycie wielu instrukcji.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-149">Lambda expressions represent "inline methods" that have no name but can have input parameters and multiple statements.</span></span> <span data-ttu-id="eb2c5-150">Są one używane często w składniku LINQ Aby przekazać argumenty do metod.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-150">They are used extensively in LINQ to pass arguments to methods.</span></span> <span data-ttu-id="eb2c5-151">Wyrażenia lambda są kompilowane delegatów lub drzew wyrażeń w zależności od kontekstu, w którym są używane.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-151">Lambda expressions are compiled to either delegates or expression trees depending on the context in which they are used.</span></span> <span data-ttu-id="eb2c5-152">Aby uzyskać więcej informacji, zobacz [wyrażenia Lambda](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-152">For more information, see [Lambda Expressions](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
## <a name="expression-trees"></a><span data-ttu-id="eb2c5-153">Drzewa wyrażeń</span><span class="sxs-lookup"><span data-stu-id="eb2c5-153">Expression trees</span></span>  
 <span data-ttu-id="eb2c5-154">Drzewa wyrażeń włączyć wyrażenia może być reprezentowana jako struktury danych.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-154">Expression trees enable expressions to be represented as data structures.</span></span> <span data-ttu-id="eb2c5-155">Są one używane często przez dostawców LINQ do tłumaczenia wyrażenia zapytania do kodu, który jest przydatny w innym kontekście, takie jak bazy danych SQL.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-155">They are used extensively by LINQ providers to translate query expressions into code that is meaningful in some other context, such as a SQL database.</span></span> <span data-ttu-id="eb2c5-156">Aby uzyskać więcej informacji, zobacz [drzew wyrażeń](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-156">For more information, see [Expression Trees](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b).</span></span>  
  
## <a name="expression-body-definitions"></a><span data-ttu-id="eb2c5-157">Definicje treść wyrażenia</span><span class="sxs-lookup"><span data-stu-id="eb2c5-157">Expression body definitions</span></span>

<span data-ttu-id="eb2c5-158">C# obsługuje *zabudowanych wyrażenia elementów członkowskich*, co pozwala użytkownikowi umożliwiają określanie wartości wyrażenia zwięzły definicji treści metody, konstruktorów finalizatory, właściwości i indeksatorów.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-158">C# supports *expression-bodied members*, which allow you to supply a concise expression body definition for methods, constructors, finalizers, properties, and indexers.</span></span> <span data-ttu-id="eb2c5-159">Aby uzyskać więcej informacji, zobacz [zabudowanych wyrażenia elementów członkowskich](expression-bodied-members.md).</span><span class="sxs-lookup"><span data-stu-id="eb2c5-159">For more information, see [Expression-bodied members](expression-bodied-members.md).</span></span>

## <a name="remarks"></a><span data-ttu-id="eb2c5-160">Uwagi</span><span class="sxs-lookup"><span data-stu-id="eb2c5-160">Remarks</span></span>  
 <span data-ttu-id="eb2c5-161">Zawsze, gdy zmienna, właściwość obiektu lub dostępu do obiektów indeksator zostanie zidentyfikowana z wyrażenia, wartość tego elementu jest używana jako wartość wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-161">Whenever a variable, object property, or object indexer access is identified from an expression, the value of that item is used as the value of the expression.</span></span> <span data-ttu-id="eb2c5-162">Wyrażenie można umieszczać w dowolnym w języku C# gdzie wartość lub obiektu jest wymagane, tak długo, jak ostatecznie wyrażenie ma wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="eb2c5-162">An expression can be placed anywhere in C# where a value or object is required, as long as the expression ultimately evaluates to the required type.</span></span>  

## <a name="see-also"></a><span data-ttu-id="eb2c5-163">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="eb2c5-163">See also</span></span>  
 [<span data-ttu-id="eb2c5-164">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="eb2c5-164">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="eb2c5-165">Metody</span><span class="sxs-lookup"><span data-stu-id="eb2c5-165">Methods</span></span>](../../../csharp/programming-guide/classes-and-structs/methods.md)  
 [<span data-ttu-id="eb2c5-166">Obiekty delegowane</span><span class="sxs-lookup"><span data-stu-id="eb2c5-166">Delegates</span></span>](../../../csharp/programming-guide/delegates/index.md)  
 [<span data-ttu-id="eb2c5-167">Operatory</span><span class="sxs-lookup"><span data-stu-id="eb2c5-167">Operators</span></span>](../../../csharp/programming-guide/statements-expressions-operators/operators.md)  
 [<span data-ttu-id="eb2c5-168">Typy</span><span class="sxs-lookup"><span data-stu-id="eb2c5-168">Types</span></span>](../../../csharp/programming-guide/types/index.md)  
 [<span data-ttu-id="eb2c5-169">Wyrażenia zapytań LINQ</span><span class="sxs-lookup"><span data-stu-id="eb2c5-169">LINQ Query Expressions</span></span>](../../../csharp/programming-guide/linq-query-expressions/index.md)
