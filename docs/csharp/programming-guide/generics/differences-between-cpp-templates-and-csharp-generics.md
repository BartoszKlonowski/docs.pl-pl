---
title: Różnice między C++ szablonami C# i ogólnymi C# przewodnikami programistycznymi
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- generics [C#], vs. C++ templates
ms.assetid: 1da6beeb-d4a4-4da0-87b7-0cfbe04920b7
ms.openlocfilehash: b794666501fb27d2f73a6050f85df3725050982e
ms.sourcegitcommit: 986f836f72ef10876878bd6217174e41464c145a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/19/2019
ms.locfileid: "69589854"
---
# <a name="differences-between-c-templates-and-c-generics-c-programming-guide"></a><span data-ttu-id="25aa8-102">Różnice między szablonami C++ i typami ogólnymi C# (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="25aa8-102">Differences Between C++ Templates and C# Generics (C# Programming Guide)</span></span>
<span data-ttu-id="25aa8-103">C#Typy ogólne i C++ szablony są funkcjami językowymi, które zapewniają obsługę typów sparametryzowanych.</span><span class="sxs-lookup"><span data-stu-id="25aa8-103">C# Generics and C++ templates are both language features that provide support for parameterized types.</span></span> <span data-ttu-id="25aa8-104">Istnieje jednak wiele różnic między nimi.</span><span class="sxs-lookup"><span data-stu-id="25aa8-104">However, there are many differences between the two.</span></span> <span data-ttu-id="25aa8-105">Na poziomie składni C# generyczne są prostsze podejścia do typów sparametryzowanych bez złożoności C++ szablonów.</span><span class="sxs-lookup"><span data-stu-id="25aa8-105">At the syntax level, C# generics are a simpler approach to parameterized types without the complexity of C++ templates.</span></span> <span data-ttu-id="25aa8-106">Ponadto program C# nie podejmuje próby udostępnienia wszystkich funkcji udostępnianych przez C++ szablony.</span><span class="sxs-lookup"><span data-stu-id="25aa8-106">In addition, C# does not attempt to provide all of the functionality that C++ templates provide.</span></span> <span data-ttu-id="25aa8-107">Na poziomie implementacji podstawowa różnica polega na tym, że C# podstawienia typów ogólnych są wykonywane w czasie wykonywania, a ogólne informacje o typie są zachowywane w przypadku obiektów wystąpień.</span><span class="sxs-lookup"><span data-stu-id="25aa8-107">At the implementation level, the primary difference is that C# generic type substitutions are performed at runtime and generic type information is thereby preserved for instantiated objects.</span></span> <span data-ttu-id="25aa8-108">Aby uzyskać więcej informacji, zobacz [typy ogólne w czasie wykonywania](./generics-in-the-run-time.md).</span><span class="sxs-lookup"><span data-stu-id="25aa8-108">For more information, see [Generics in the Run Time](./generics-in-the-run-time.md).</span></span>  
  
 <span data-ttu-id="25aa8-109">Poniżej przedstawiono kluczowe różnice między C# ogólnymi i C++ szablonami:</span><span class="sxs-lookup"><span data-stu-id="25aa8-109">The following are the key differences between C# Generics and C++ templates:</span></span>  
  
- <span data-ttu-id="25aa8-110">C#typy ogólne nie zapewniają takiej samej elastyczności jak C++ szablony.</span><span class="sxs-lookup"><span data-stu-id="25aa8-110">C# generics do not provide the same amount of flexibility as C++ templates.</span></span> <span data-ttu-id="25aa8-111">Na przykład nie jest możliwe wywołanie operatorów arytmetycznych w klasie C# generycznej, chociaż istnieje możliwość wywołania operatorów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="25aa8-111">For example, it is not possible to call arithmetic operators in a C# generic class, although it is possible to call user defined operators.</span></span>  
  
- <span data-ttu-id="25aa8-112">C#nie zezwala na parametry szablonu bez typu, takie jak `template C<int i> {}`.</span><span class="sxs-lookup"><span data-stu-id="25aa8-112">C# does not allow non-type template parameters, such as `template C<int i> {}`.</span></span>  
  
- <span data-ttu-id="25aa8-113">C#nie obsługuje jawnej specjalizacji; oznacza to, że niestandardowa implementacja szablonu dla określonego typu.</span><span class="sxs-lookup"><span data-stu-id="25aa8-113">C# does not support explicit specialization; that is, a custom implementation of a template for a specific type.</span></span>  
  
- <span data-ttu-id="25aa8-114">C#nie obsługuje specjalizacji częściowej: niestandardowej implementacji dla podzbioru argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="25aa8-114">C# does not support partial specialization: a custom implementation for a subset of the type arguments.</span></span>  
  
- <span data-ttu-id="25aa8-115">C#nie zezwala na użycie parametru typu jako klasy bazowej dla typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="25aa8-115">C# does not allow the type parameter to be used as the base class for the generic type.</span></span>  
  
- <span data-ttu-id="25aa8-116">C#nie zezwala na parametry typu mające typy domyślne.</span><span class="sxs-lookup"><span data-stu-id="25aa8-116">C# does not allow type parameters to have default types.</span></span>  
  
- <span data-ttu-id="25aa8-117">W C#programie parametr typu generycznego nie może być typem ogólnym, chociaż skonstruowane typy mogą służyć jako generyczne.</span><span class="sxs-lookup"><span data-stu-id="25aa8-117">In C#, a generic type parameter cannot itself be a generic, although constructed types can be used as generics.</span></span> <span data-ttu-id="25aa8-118">C++zezwala na parametry szablonu.</span><span class="sxs-lookup"><span data-stu-id="25aa8-118">C++ does allow template parameters.</span></span>  
  
- <span data-ttu-id="25aa8-119">C++zezwala na kod, który może być nieprawidłowy dla wszystkich parametrów typu w szablonie, który jest sprawdzany pod kątem określonego typu, który jest używany jako parametr typu.</span><span class="sxs-lookup"><span data-stu-id="25aa8-119">C++ allows code that might not be valid for all type parameters in the template, which is then checked for the specific type used as the type parameter.</span></span> <span data-ttu-id="25aa8-120">C#wymaga, aby kod w klasie był pisany w taki sposób, że będzie działał z dowolnym typem, który spełnia ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="25aa8-120">C# requires code in a class to be written in such a way that it will work with any type that satisfies the constraints.</span></span> <span data-ttu-id="25aa8-121">Na przykład C++ można napisać funkcję, która używa operatorów `+` arytmetycznych i `-` obiektów parametru typu, co spowoduje błąd w czasie tworzenia wystąpienia szablonu z typem, który nie Obsługuj te operatory.</span><span class="sxs-lookup"><span data-stu-id="25aa8-121">For example, in C++ it is possible to write a function that uses the arithmetic operators `+` and `-` on objects of the type parameter, which will produce an error at the time of instantiation of the template with a type that does not support these operators.</span></span> <span data-ttu-id="25aa8-122">C#nie zezwala na to; Jedyne konstrukcje języka dozwolone są te, które można wywnioskować na podstawie ograniczeń.</span><span class="sxs-lookup"><span data-stu-id="25aa8-122">C# disallows this; the only language constructs allowed are those that can be deduced from the constraints.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="25aa8-123">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="25aa8-123">See also</span></span>

- [<span data-ttu-id="25aa8-124">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="25aa8-124">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="25aa8-125">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="25aa8-125">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="25aa8-126">Szablony</span><span class="sxs-lookup"><span data-stu-id="25aa8-126">Templates</span></span>](/cpp/cpp/templates-cpp)
