---
title: "Ograniczenia dotyczące parametrów typu (Przewodnik programowania w języku C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f5382b0050b81ed3bb1a075a042bdc4034a3975d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2017
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="1746e-102">Ograniczenia dotyczące parametrów typu (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="1746e-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="1746e-103">Podczas definiowania klasy ogólnej, można zastosować ograniczenia do rodzajów typów, których kod klienta można używać dla argumentów typu podczas tworzenia wystąpień klasy.</span><span class="sxs-lookup"><span data-stu-id="1746e-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="1746e-104">Jeśli kod klienta próbuje utworzyć wystąpienia klasy przy użyciu typu, który nie jest dozwolona przez ograniczenie, wynikiem jest błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="1746e-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="1746e-105">Ograniczenia te są nazywane ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="1746e-105">These restrictions are called constraints.</span></span> <span data-ttu-id="1746e-106">Ograniczenia są określane przy użyciu `where` kontekstowe słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="1746e-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="1746e-107">W poniższej tabeli wymieniono sześć typy ograniczeń:</span><span class="sxs-lookup"><span data-stu-id="1746e-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="1746e-108">Ograniczenia</span><span class="sxs-lookup"><span data-stu-id="1746e-108">Constraint</span></span>|<span data-ttu-id="1746e-109">Opis</span><span class="sxs-lookup"><span data-stu-id="1746e-109">Description</span></span>|  
|----------------|-----------------|  
|<span data-ttu-id="1746e-110">Gdy struktura T:</span><span class="sxs-lookup"><span data-stu-id="1746e-110">where T: struct</span></span>|<span data-ttu-id="1746e-111">Argument typu musi być typem wartości.</span><span class="sxs-lookup"><span data-stu-id="1746e-111">The type argument must be a value type.</span></span> <span data-ttu-id="1746e-112">Wszystkie wartości typu z wyjątkiem <xref:System.Nullable> można określić.</span><span class="sxs-lookup"><span data-stu-id="1746e-112">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="1746e-113">Zobacz [przy użyciu typów dopuszczających wartości zerowe](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) Aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="1746e-113">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|<span data-ttu-id="1746e-114">gdzie T: klasa</span><span class="sxs-lookup"><span data-stu-id="1746e-114">where T : class</span></span>|<span data-ttu-id="1746e-115">Argument typu musi być typu referencyjnego; dotyczy to również klasy, interfejsu, delegata lub typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="1746e-115">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|<span data-ttu-id="1746e-116">gdzie T: new()</span><span class="sxs-lookup"><span data-stu-id="1746e-116">where T : new()</span></span>|<span data-ttu-id="1746e-117">Typ argumentu musi mieć publicznego konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="1746e-117">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="1746e-118">Gdy jest używany z innymi ograniczeniami `new()` ograniczenie musi być określony jako ostatni.</span><span class="sxs-lookup"><span data-stu-id="1746e-118">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="1746e-119">gdzie T: \<nazwę klasy podstawowej ></span><span class="sxs-lookup"><span data-stu-id="1746e-119">where T : \<base class name></span></span>|<span data-ttu-id="1746e-120">Argument typu musi być lub pochodzić od określonej klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="1746e-120">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="1746e-121">gdzie T: \<Nazwa interfejsu ></span><span class="sxs-lookup"><span data-stu-id="1746e-121">where T : \<interface name></span></span>|<span data-ttu-id="1746e-122">Argument typu muszą być lub implementować określonego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1746e-122">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="1746e-123">Można określić wiele ograniczeń interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1746e-123">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="1746e-124">Można też ogólnego ograniczający interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1746e-124">The constraining interface can also be generic.</span></span>|  
|<span data-ttu-id="1746e-125">gdzie T: U</span><span class="sxs-lookup"><span data-stu-id="1746e-125">where T : U</span></span>|<span data-ttu-id="1746e-126">Argumentu typu dostarczonego T musi być lub pochodzić od argument dostarczony dla U.</span><span class="sxs-lookup"><span data-stu-id="1746e-126">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="1746e-127">Dlaczego warto korzystać z ograniczeniami</span><span class="sxs-lookup"><span data-stu-id="1746e-127">Why Use Constraints</span></span>  
 <span data-ttu-id="1746e-128">Jeśli chcesz sprawdzić element listy ogólnej do ustalenia, czy jest nieprawidłowy lub porównaj je z inny element, kompilator musi mieć niektóre gwarantuje, że operator lub metoda, który musi wywołać będą obsługiwane przez wszystkich argumentów typu określoną przez co klient Niemcy.</span><span class="sxs-lookup"><span data-stu-id="1746e-128">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="1746e-129">Gwarancji są uzyskiwane przez zastosowanie jednego lub więcej ograniczeń do definicji klasy ogólnej.</span><span class="sxs-lookup"><span data-stu-id="1746e-129">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="1746e-130">Na przykład ograniczenie klasy podstawowej informuje kompilator, że tylko obiekty tego typu lub pochodzi z tego typu, będzie można używać jako argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="1746e-130">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="1746e-131">Kompilator ma gwarancji, umożliwiają metody tego typu można wywołać w klasie rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="1746e-131">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="1746e-132">Ograniczenia są stosowane przy użyciu kontekstowe słowo kluczowe `where`.</span><span class="sxs-lookup"><span data-stu-id="1746e-132">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="1746e-133">Poniższy przykład kodu pokazuje funkcji, można dodać do `GenericList<T>` klasy (w [wprowadzenie do typów ogólnych](../../../csharp/programming-guide/generics/introduction-to-generics.md)), stosując ograniczenie klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="1746e-133">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="1746e-134">Klasy ogólnej użyć umożliwia ograniczenie `Employee.Name` właściwości, ponieważ wszystkie elementy typu T zapewniona jest albo `Employee` lub obiektu, który dziedziczy z `Employee`.</span><span class="sxs-lookup"><span data-stu-id="1746e-134">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="1746e-135">Wiele ograniczeń można zastosować do tego samego parametru typu, a same ograniczenia może mieć typów ogólnych w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="1746e-135">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="1746e-136">Ograniczający parametr typu, powoduje zwiększenie liczby operacji w dozwolonym i wywołania metody do obsługiwanych przez ograniczającego typu i wszystkie typy w jej hierarchii dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="1746e-136">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="1746e-137">W związku z tym podczas projektowania klas ogólnego lub metody, jeśli operacji na ogólnych elementów członkowskich poza przypisanie proste lub wywoływania żadnych metod, które nie są obsługiwane przez `System.Object`, należy zastosować ograniczenia do parametru typu.</span><span class="sxs-lookup"><span data-stu-id="1746e-137">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="1746e-138">Podczas stosowania `where T : class` ograniczenia, należy unikać `==` i `!=` operatory w parametrze typu ponieważ tych operatorów sprawdza tożsamości odwołania, nie dla równości wartości.</span><span class="sxs-lookup"><span data-stu-id="1746e-138">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="1746e-139">Dotyczy to nawet wtedy, gdy te operatory są przeciążone w typie, który jest używany jako argument.</span><span class="sxs-lookup"><span data-stu-id="1746e-139">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="1746e-140">Poniższy kod ilustruje tę sytuację; nawet jeśli dane wyjściowe ma wartość false <xref:System.String> klasy przeciążenia `==` operatora.</span><span class="sxs-lookup"><span data-stu-id="1746e-140">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="1746e-141">Przyczyna to zachowanie jest, że w czasie kompilacji, kompilator tylko zna T jest typem referencyjnym czy w związku z tym należy użyć domyślnych operatorów, które są prawidłowe dla wszystkich typów odniesienia.</span><span class="sxs-lookup"><span data-stu-id="1746e-141">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="1746e-142">Jeśli konieczne jest przetestowanie wartość pod kątem równości, zalecaną metodą jest również zastosować `where T : IComparable<T>` ograniczenia i wdrożenie, które interfejs w dowolnej klasy, która ma być użyty do utworzenia klasy ogólnej.</span><span class="sxs-lookup"><span data-stu-id="1746e-142">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="1746e-143">Ograniczający wiele parametrów</span><span class="sxs-lookup"><span data-stu-id="1746e-143">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="1746e-144">Wiele parametrów, a wiele ograniczeń na jeden parametr, można zastosować ograniczenia, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="1746e-144">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="1746e-145">Parametry typu niepowiązanego</span><span class="sxs-lookup"><span data-stu-id="1746e-145">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="1746e-146">Wpisz parametry, które mają żadne ograniczenia, takie jak T w publicznej klasy `SampleClass<T>{}`, są nazywane parametrów niepowiązanego typu.</span><span class="sxs-lookup"><span data-stu-id="1746e-146">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="1746e-147">Parametry typu niepowiązanego mają następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="1746e-147">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="1746e-148">`!=` i `==` nie można używać operatorów, ponieważ nie ma żadnej gwarancji, że argument typu konkretnego będzie obsługiwać tych operatorów.</span><span class="sxs-lookup"><span data-stu-id="1746e-148">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="1746e-149">Może być przekonwertowany do i z `System.Object` lub jawnie przekonwertowane do dowolnego typu interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1746e-149">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="1746e-150">Możesz porównać [null](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="1746e-150">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="1746e-151">Jeśli jest porównywany niepowiązany parametr `null`, porównanie zawsze zwróci wartość false, jeśli argument Typ jest typem wartości.</span><span class="sxs-lookup"><span data-stu-id="1746e-151">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="1746e-152">Parametry typu jako ograniczenia</span><span class="sxs-lookup"><span data-stu-id="1746e-152">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="1746e-153">Użyj parametru typu ogólnego jako ograniczenie jest przydatne w przypadku funkcji członkowskiej z własną parametr typu ma ograniczenie parametru typu parametru typu zawierającego, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="1746e-153">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="1746e-154">W poprzednim przykładzie `T` ograniczenie typu w kontekście `Add` — metoda i parametr niepowiązanego typu w kontekście `List` klasy.</span><span class="sxs-lookup"><span data-stu-id="1746e-154">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="1746e-155">Parametry typu mogą służyć jako ograniczeń w definicji klasy ogólnej.</span><span class="sxs-lookup"><span data-stu-id="1746e-155">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="1746e-156">Należy pamiętać, że parametr typu musi być zadeklarowana w nawiasy razem z innymi parametrami typu:</span><span class="sxs-lookup"><span data-stu-id="1746e-156">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="1746e-157">Przydatność parametrów typu jako ograniczenia z klas ogólnych jest bardzo ograniczona, ponieważ kompilator można założyć, nie ma parametru typu z tą różnicą, że pochodzi od `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="1746e-157">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="1746e-158">Parametry typu jako ograniczenia dotyczące klas ogólnych w scenariuszach, w których chcesz wymusić relację dziedziczenia między dwoma parametrami typu.</span><span class="sxs-lookup"><span data-stu-id="1746e-158">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1746e-159">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="1746e-159">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="1746e-160">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="1746e-160">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="1746e-161">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="1746e-161">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="1746e-162">Klasy ogólne</span><span class="sxs-lookup"><span data-stu-id="1746e-162">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="1746e-163">New — ograniczenie</span><span class="sxs-lookup"><span data-stu-id="1746e-163">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)
