---
title: Typy ogólne w przewodniku programowania w języku C#
description: Dowiedz się więcej o typach ogólnych w czasie wykonywania. Zobacz przykłady kodu i Wyświetl dodatkowe dostępne zasoby.
ms.date: 07/20/2015
helpviewer_keywords:
- generics [C#], at run time
ms.assetid: 119df7e6-9ceb-49df-af36-24f8f8c0747f
ms.openlocfilehash: 1d2afd34d1a80841ba711897492cd4cd6412fa53
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/24/2020
ms.locfileid: "91184121"
---
# <a name="generics-in-the-run-time-c-programming-guide"></a><span data-ttu-id="f42ee-104">Typy ogólne w czasie wykonywania (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="f42ee-104">Generics in the Run Time (C# Programming Guide)</span></span>

<span data-ttu-id="f42ee-105">Gdy typ ogólny lub metoda jest kompilowany do języka pośredniego firmy Microsoft (MSIL), zawiera metadane, które identyfikują go jako parametry typu.</span><span class="sxs-lookup"><span data-stu-id="f42ee-105">When a generic type or method is compiled into Microsoft intermediate language (MSIL), it contains metadata that identifies it as having type parameters.</span></span> <span data-ttu-id="f42ee-106">Sposób użycia MSIL dla typu ogólnego różni się w zależności od tego, czy dostarczony parametr typu jest typem wartości czy typem referencyjnym.</span><span class="sxs-lookup"><span data-stu-id="f42ee-106">How the MSIL for a generic type is used differs based on whether the supplied type parameter is a value type or reference type.</span></span>  
  
 <span data-ttu-id="f42ee-107">Gdy typ ogólny jest najpierw konstruowany z typem wartości jako parametr, środowisko uruchomieniowe tworzy wyspecjalizowany typ ogólny z dostarczonym parametrem lub parametrami zastępowanymi w odpowiednich lokalizacjach w języku MSIL.</span><span class="sxs-lookup"><span data-stu-id="f42ee-107">When a generic type is first constructed with a value type as a parameter, the runtime creates a specialized generic type with the supplied parameter or parameters substituted in the appropriate locations in the MSIL.</span></span> <span data-ttu-id="f42ee-108">Wyspecjalizowane typy ogólne są tworzone jednokrotnie dla każdego unikatowego typu wartości, który jest używany jako parametr.</span><span class="sxs-lookup"><span data-stu-id="f42ee-108">Specialized generic types are created one time for each unique value type that is used as a parameter.</span></span>  
  
 <span data-ttu-id="f42ee-109">Załóżmy na przykład, że kod programu deklaruje stos, który jest zbudowany z liczb całkowitych:</span><span class="sxs-lookup"><span data-stu-id="f42ee-109">For example, suppose your program code declared a stack that is constructed of integers:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#42](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#42)]  
  
 <span data-ttu-id="f42ee-110">W tym momencie środowisko uruchomieniowe generuje wyspecjalizowaną wersję <xref:System.Collections.Generic.Stack%601> klasy, która ma odpowiednią liczbę całkowitą podstawioną odpowiednio do parametru.</span><span class="sxs-lookup"><span data-stu-id="f42ee-110">At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that has the integer substituted appropriately for its parameter.</span></span> <span data-ttu-id="f42ee-111">Teraz za każdym razem, gdy kod programu używa stosu liczb całkowitych, środowisko uruchomieniowe ponownie używa wygenerowanej klasy wyspecjalizowanej <xref:System.Collections.Generic.Stack%601> .</span><span class="sxs-lookup"><span data-stu-id="f42ee-111">Now, whenever your program code uses a stack of integers, the runtime reuses the generated specialized <xref:System.Collections.Generic.Stack%601> class.</span></span> <span data-ttu-id="f42ee-112">W poniższym przykładzie są tworzone dwa wystąpienia stosu liczb całkowitych i współużytkują pojedyncze wystąpienie `Stack<int>` kodu:</span><span class="sxs-lookup"><span data-stu-id="f42ee-112">In the following example, two instances of a stack of integers are created, and they share a single instance of the `Stack<int>` code:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#43](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#43)]  
  
 <span data-ttu-id="f42ee-113">Jednakże Załóżmy, że inna <xref:System.Collections.Generic.Stack%601> Klasa o innym typie wartości, taka jak `long` lub struktura zdefiniowana przez użytkownika, jest tworzona w innym punkcie w kodzie.</span><span class="sxs-lookup"><span data-stu-id="f42ee-113">However, suppose that another <xref:System.Collections.Generic.Stack%601> class with a different value type such as a `long` or a user-defined structure as its parameter is created at another point in your code.</span></span> <span data-ttu-id="f42ee-114">W efekcie środowisko uruchomieniowe generuje inną wersję typu ogólnego i zastępuje je `long` w odpowiednich lokalizacjach w języku MSIL.</span><span class="sxs-lookup"><span data-stu-id="f42ee-114">As a result, the runtime generates another version of the generic type and substitutes a `long` in the appropriate locations in MSIL.</span></span> <span data-ttu-id="f42ee-115">Konwersje nie są już potrzebne, ponieważ każda wyspecjalizowana Klasa ogólna natywnie zawiera typ wartości.</span><span class="sxs-lookup"><span data-stu-id="f42ee-115">Conversions are no longer necessary because each specialized generic class natively contains the value type.</span></span>  
  
 <span data-ttu-id="f42ee-116">Typy ogólne działają nieco inaczej w przypadku typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="f42ee-116">Generics work somewhat differently for reference types.</span></span> <span data-ttu-id="f42ee-117">Pierwszy raz, gdy typ ogólny jest konstruowany przy użyciu dowolnego typu referencyjnego, środowisko uruchomieniowe tworzy wyspecjalizowany typ ogólny z odwołaniami do obiektów, które zastępują parametry w MSIL.</span><span class="sxs-lookup"><span data-stu-id="f42ee-117">The first time a generic type is constructed with any reference type, the runtime creates a specialized generic type with object references substituted for the parameters in the MSIL.</span></span> <span data-ttu-id="f42ee-118">Następnie, za każdym razem, gdy tworzony jest typ wystąpienia typu referencyjnego jako jego parametr, niezależnie od tego, jakiego typu jest, środowisko uruchomieniowe ponownie używa wcześniej utworzonej wyspecjalizowanej wersji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="f42ee-118">Then, every time that a constructed type is instantiated with a reference type as its parameter, regardless of what type it is, the runtime reuses the previously created specialized version of the generic type.</span></span> <span data-ttu-id="f42ee-119">Jest to możliwe, ponieważ wszystkie odwołania mają ten sam rozmiar.</span><span class="sxs-lookup"><span data-stu-id="f42ee-119">This is possible because all references are the same size.</span></span>  
  
 <span data-ttu-id="f42ee-120">Załóżmy na przykład, że istniały dwa typy referencyjne, `Customer` Klasa i `Order` Klasa, a także Załóżmy, że utworzono stos `Customer` typów:</span><span class="sxs-lookup"><span data-stu-id="f42ee-120">For example, suppose you had two reference types, a `Customer` class and an `Order` class, and also suppose that you created a stack of `Customer` types:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#47](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#47)]  
  
 [!code-csharp[csProgGuideGenerics#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#44)]  
  
 <span data-ttu-id="f42ee-121">W tym momencie środowisko uruchomieniowe generuje wyspecjalizowaną wersję <xref:System.Collections.Generic.Stack%601> klasy, która przechowuje odwołania do obiektów, które zostaną uzupełnione później, zamiast przechowywać dane.</span><span class="sxs-lookup"><span data-stu-id="f42ee-121">At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that stores object references that will be filled in later instead of storing data.</span></span> <span data-ttu-id="f42ee-122">Załóżmy, że następny wiersz kodu tworzy stos innego typu referencyjnego, który nosi nazwę `Order` :</span><span class="sxs-lookup"><span data-stu-id="f42ee-122">Suppose the next line of code creates a stack of another reference type, which is named `Order`:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#45](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#45)]  
  
 <span data-ttu-id="f42ee-123">W przeciwieństwie do typów wartości, inna wyspecjalizowana wersja <xref:System.Collections.Generic.Stack%601> klasy nie jest tworzona dla tego `Order` typu.</span><span class="sxs-lookup"><span data-stu-id="f42ee-123">Unlike with value types, another specialized version of the <xref:System.Collections.Generic.Stack%601> class is not created for the `Order` type.</span></span> <span data-ttu-id="f42ee-124">Zamiast tego tworzone jest wystąpienie wyspecjalizowanej wersji klasy, <xref:System.Collections.Generic.Stack%601> a `orders` zmienna jest ustawiana jako odwołująca się do niej.</span><span class="sxs-lookup"><span data-stu-id="f42ee-124">Instead, an instance of the specialized version of the <xref:System.Collections.Generic.Stack%601> class is created and the `orders` variable is set to reference it.</span></span> <span data-ttu-id="f42ee-125">Załóżmy, że napotkasz wiersz kodu w celu utworzenia stosu `Customer` typu:</span><span class="sxs-lookup"><span data-stu-id="f42ee-125">Suppose that you then encountered a line of code to create a stack of a `Customer` type:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#46](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#46)]  
  
 <span data-ttu-id="f42ee-126">Podobnie jak w przypadku poprzedniego użycia <xref:System.Collections.Generic.Stack%601> klasy utworzonej przy użyciu `Order` typu, tworzone jest inne wystąpienie klasy wyspecjalizowanej <xref:System.Collections.Generic.Stack%601> .</span><span class="sxs-lookup"><span data-stu-id="f42ee-126">As with the previous use of the <xref:System.Collections.Generic.Stack%601> class created by using the `Order` type, another instance of the specialized <xref:System.Collections.Generic.Stack%601> class is created.</span></span> <span data-ttu-id="f42ee-127">Znajdujące się w nim wskaźniki są ustawiane jako odwołujące się do obszaru pamięci o rozmiarze `Customer` typu.</span><span class="sxs-lookup"><span data-stu-id="f42ee-127">The pointers that are contained therein are set to reference an area of memory the size of a `Customer` type.</span></span> <span data-ttu-id="f42ee-128">Ze względu na to, że liczba typów referencyjnych może się różnić w zależności od programu do programu, implementacja języka C# generycznych znacznie zmniejsza ilość kodu przez zredukowanie do jednej z wielu wyspecjalizowanych klas utworzonych przez kompilator dla klas ogólnych typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="f42ee-128">Because the number of reference types can vary wildly from program to program, the C# implementation of generics greatly reduces the amount of code by reducing to one the number of specialized classes created by the compiler for generic classes of reference types.</span></span>  
  
 <span data-ttu-id="f42ee-129">Ponadto podczas tworzenia wystąpienia generycznej klasy C# przy użyciu typu wartości lub parametru typu odwołania odbicie może wysyłać zapytania do niego w czasie wykonywania i można ustalić zarówno jego rzeczywisty typ, jak i jego parametr typu.</span><span class="sxs-lookup"><span data-stu-id="f42ee-129">Moreover, when a generic C# class is instantiated by using a value type or reference type parameter, reflection can query it at runtime and both its actual type and its type parameter can be ascertained.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f42ee-130">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f42ee-130">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="f42ee-131">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="f42ee-131">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="f42ee-132">Wprowadzenie do typów ogólnych</span><span class="sxs-lookup"><span data-stu-id="f42ee-132">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="f42ee-133">Typy ogólne</span><span class="sxs-lookup"><span data-stu-id="f42ee-133">Generics</span></span>](../../../standard/generics/index.md)
