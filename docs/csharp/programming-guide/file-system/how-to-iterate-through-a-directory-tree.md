---
title: 'Porady: iterowanie drzewa katalogów (Przewodnik programowania w języku C#)'
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: 1aac40793fabe152e18a1bf1b634058e85b31481
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/04/2018
ms.locfileid: "43515764"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="5e327-102">Porady: iterowanie drzewa katalogów (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="5e327-102">How to: Iterate Through a Directory Tree (C# Programming Guide)</span></span>
<span data-ttu-id="5e327-103">Wyrażenie "Iterowanie drzewa katalogów" oznacza, że dostęp do każdego pliku w każdej zagnieżdżonej podkatalogu w folderze określonym katalogu głównym, na dowolnym poziomie.</span><span class="sxs-lookup"><span data-stu-id="5e327-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="5e327-104">Zawsze, nie trzeba otwierać każdego pliku.</span><span class="sxs-lookup"><span data-stu-id="5e327-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="5e327-105">Możesz po prostu pobrać nazwę pliku lub podkatalog jako `string`, lub można pobrać dodatkowe informacje w formie <xref:System.IO.FileInfo?displayProperty=nameWithType> lub <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> obiektu.</span><span class="sxs-lookup"><span data-stu-id="5e327-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e327-106">W Windows warunki "directory" i "folder" są używane zamiennie.</span><span class="sxs-lookup"><span data-stu-id="5e327-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="5e327-107">Większość dokumentacji i użytkownika tekst interfejsu używany jest termin "folder", ale [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] biblioteki klas używany jest termin "directory".</span><span class="sxs-lookup"><span data-stu-id="5e327-107">Most documentation and user interface text uses the term "folder," but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="5e327-108">W najprostszym przypadku, w którym można ustalić, czy masz uprawnienia dostępu do wszystkich katalogów w określonym katalogu głównym, można użyć `System.IO.SearchOption.AllDirectories` flagi.</span><span class="sxs-lookup"><span data-stu-id="5e327-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="5e327-109">Ta flaga zwraca wszystkie podkatalogi zagnieżdżonych, pasujących do wzorca określonego.</span><span class="sxs-lookup"><span data-stu-id="5e327-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="5e327-110">Poniższy przykład pokazuje, jak użyć tej flagi.</span><span class="sxs-lookup"><span data-stu-id="5e327-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="5e327-111">Słabe strony w tym podejściu jest to, że jeśli powoduje, że jeden podkatalogów w określonym katalogu głównym <xref:System.IO.DirectoryNotFoundException> lub <xref:System.UnauthorizedAccessException>, całej metody zakończy się niepowodzeniem i zwraca żadne katalogi.</span><span class="sxs-lookup"><span data-stu-id="5e327-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="5e327-112">Dotyczy to także gdy używasz <xref:System.IO.DirectoryInfo.GetFiles%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="5e327-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="5e327-113">Jeśli trzeba obsługiwać wyjątki, te w podfolderach określonych, możesz ręcznie Skontroluj drzewo katalogów, jak pokazano w poniższych przykładach.</span><span class="sxs-lookup"><span data-stu-id="5e327-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="5e327-114">Podczas ręcznie Skontroluj drzewo katalogów, które ułatwią Ci obsługę podkatalogów najpierw (*{przechodzenie kolejności wstępnego*), pliki lub pierwszy (*{przechodzenie kolejności po*).</span><span class="sxs-lookup"><span data-stu-id="5e327-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="5e327-115">Jeśli wykonujesz przechodzenie przedsprzedaży, możesz zapoznaj się z całego drzewa w bieżącym folderze przed iteracja plików znajdujących się bezpośrednio w ten sam folder.</span><span class="sxs-lookup"><span data-stu-id="5e327-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="5e327-116">Przykłady w dalszej części tego dokumentu, wykonać {przechodzenie kolejności po, ale można łatwo modyfikować je przeprowadzić {przechodzenie kolejności wstępnego.</span><span class="sxs-lookup"><span data-stu-id="5e327-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="5e327-117">Innym rozwiązaniem jest, czy należy użyć rekursji lub przechodzenia przez oparty na stosie.</span><span class="sxs-lookup"><span data-stu-id="5e327-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="5e327-118">W przykładach w dalszej części tego dokumentu pokazano oba podejścia.</span><span class="sxs-lookup"><span data-stu-id="5e327-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="5e327-119">W przypadku wykonywania różnych operacji na plikach i folderach mogą modularyzacji te przykłady ramach refaktoryzacji elementu operacji na osobne funkcje, które można wywoływać za pomocą pojedynczego delegata.</span><span class="sxs-lookup"><span data-stu-id="5e327-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e327-120">Systemy plików NTFS może zawierać *punkty ponownej analizy* w formie *punkty połączenia*, *łącza symbolicznego*, i *twarde linki*.</span><span class="sxs-lookup"><span data-stu-id="5e327-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="5e327-121">Metody .NET Framework, takie jak <xref:System.IO.DirectoryInfo.GetFiles%2A> i <xref:System.IO.DirectoryInfo.GetDirectories%2A> nie zwróci żadnych podkatalogów w ramach punktu ponownej analizy.</span><span class="sxs-lookup"><span data-stu-id="5e327-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="5e327-122">To zachowanie chroni przed ryzykiem wejść w nieskończoną pętlę, gdy dwa punkty ponownej analizy, zapoznaj się ze sobą.</span><span class="sxs-lookup"><span data-stu-id="5e327-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="5e327-123">Ogólnie rzecz biorąc należy zachować ostrożność extreme podczas operacji punkty ponownej analizy, aby upewnić się, możesz nie przypadkowo modyfikowania lub usuwania plików.</span><span class="sxs-lookup"><span data-stu-id="5e327-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="5e327-124">Jeśli potrzebujesz precyzyjną kontrolę nad tym punkty ponownej analizy, użycie wywołania platformy lub kodu natywnego do odpowiedniego pliku Win32 systemu bezpośrednie wywoływanie metod.</span><span class="sxs-lookup"><span data-stu-id="5e327-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="5e327-125">Przykład</span><span class="sxs-lookup"><span data-stu-id="5e327-125">Example</span></span>  
 <span data-ttu-id="5e327-126">Poniższy przykład pokazuje, jak przeprowadzenie drzewo katalogów przy użyciu rekursji.</span><span class="sxs-lookup"><span data-stu-id="5e327-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="5e327-127">Podejście cykliczne to elegancki, ale może potencjalnie spowodować wyjątek przepełnienia stosu, jeśli drzewo katalogów są duże i głęboko zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="5e327-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="5e327-128">Określonego wyjątki, które są obsługiwane i określonej akcji, które są wykonywane na każdym pliku lub folderu, są dostarczane jako fikcyjne.</span><span class="sxs-lookup"><span data-stu-id="5e327-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="5e327-129">Należy zmodyfikować pod kątem wymagań dotyczących tego kodu.</span><span class="sxs-lookup"><span data-stu-id="5e327-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="5e327-130">Zobacz komentarze w kodzie, aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="5e327-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]  
  
## <a name="example"></a><span data-ttu-id="5e327-131">Przykład</span><span class="sxs-lookup"><span data-stu-id="5e327-131">Example</span></span>  
 <span data-ttu-id="5e327-132">Poniższy przykład pokazuje, jak iteracja plików i folderów w drzewie katalogu bez użycia rekursji.</span><span class="sxs-lookup"><span data-stu-id="5e327-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="5e327-133">Ta metoda korzysta z ogólnego <xref:System.Collections.Generic.Stack%601> typ kolekcji, który jest ostatni w stosie pierwszy LIFO ().</span><span class="sxs-lookup"><span data-stu-id="5e327-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="5e327-134">Określonego wyjątki, które są obsługiwane i określonej akcji, które są wykonywane na każdym pliku lub folderu, są dostarczane jako fikcyjne.</span><span class="sxs-lookup"><span data-stu-id="5e327-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="5e327-135">Należy zmodyfikować pod kątem wymagań dotyczących tego kodu.</span><span class="sxs-lookup"><span data-stu-id="5e327-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="5e327-136">Zobacz komentarze w kodzie, aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="5e327-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]  
  
 <span data-ttu-id="5e327-137">Zazwyczaj jest zbyt czasochłonne przetestować każdy folder w celu ustalenia, czy aplikacja ma uprawnienia do otwierania go.</span><span class="sxs-lookup"><span data-stu-id="5e327-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="5e327-138">W związku z tym, przykładowy kod zawiera tylko część operacji w `try/catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="5e327-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="5e327-139">Możesz zmodyfikować `catch` zablokować tak, aby podczas dostępu do folderu, próby podniesienia poziomu uprawnień użytkownika, a następnie ponownie uzyskać dostęp.</span><span class="sxs-lookup"><span data-stu-id="5e327-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="5e327-140">Zgodnie z zasadą przechwytywać tylko te wyjątki, które może obsłużyć bez opuszczania aplikacji w nieznanym stanie.</span><span class="sxs-lookup"><span data-stu-id="5e327-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="5e327-141">Jeśli zawartość drzewa katalogów, muszą być przechowywane w pamięci lub na dysku, najlepszym rozwiązaniem jest przechowywanie tylko <xref:System.IO.FileSystemInfo.FullName%2A> właściwości (typu `string`) dla każdego pliku.</span><span class="sxs-lookup"><span data-stu-id="5e327-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="5e327-142">Można następnie użyć tego ciągu do utworzenia nowego <xref:System.IO.FileInfo> lub <xref:System.IO.DirectoryInfo> obiektu zgodnie z potrzebami, lub otworzyć dowolny plik, który wymaga dodatkowego przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="5e327-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="5e327-143">Niezawodne programowanie</span><span class="sxs-lookup"><span data-stu-id="5e327-143">Robust Programming</span></span>  
 <span data-ttu-id="5e327-144">Kod iteracji niezawodne pliku należy wziąć pod uwagę wiele złożoności systemu plików.</span><span class="sxs-lookup"><span data-stu-id="5e327-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="5e327-145">Aby uzyskać więcej informacji w systemie plików Windows, zobacz [informacje techniczne dotyczące systemu plików NTFS](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4).</span><span class="sxs-lookup"><span data-stu-id="5e327-145">For more information on the Windows file system, see [NTFS Technical Reference](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5e327-146">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="5e327-146">See Also</span></span>

- <xref:System.IO>  
- [<span data-ttu-id="5e327-147">LINQ i katalogi plików</span><span class="sxs-lookup"><span data-stu-id="5e327-147">LINQ and File Directories</span></span>](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)  
- [<span data-ttu-id="5e327-148">System plików i rejestr (C# Programming Guide)</span><span class="sxs-lookup"><span data-stu-id="5e327-148">File System and the Registry (C# Programming Guide)</span></span>](../../../csharp/programming-guide/file-system/index.md)
