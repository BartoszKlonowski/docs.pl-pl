---
title: Metody rozszerzenia — Przewodnik programowania w języku C#
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 5db2797870b6c2e1998f17f1d8e4df8aa3f95c9e
ms.sourcegitcommit: a241301495a84cc8c64fe972330d16edd619868b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/01/2020
ms.locfileid: "84241412"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="d4e4b-102">Metody rozszerzeń (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="d4e4b-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="d4e4b-103">Metody rozszerzenia umożliwiają „dodawanie” metod do istniejących typów bez konieczności tworzenia nowego typu pochodnego, ponownej kompilacji lub modyfikowania oryginalnego typu w inny sposób.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="d4e4b-104">Metody rozszerzające są metodami statycznymi, ale są wywoływane tak, jakby były metodami wystąpień w typie rozszerzonym.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="d4e4b-105">W przypadku kodu klienta pisanego w językach C#, F # i Visual Basic nie ma żadnej widocznej różnicy między wywołaniem metody rozszerzającej i metodami zdefiniowanymi w typie.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="d4e4b-106">Najbardziej typowymi metodami rozszerzenia są operatory standardowych zapytań LINQ, które dodają funkcję zapytania do <xref:System.Collections.IEnumerable?displayProperty=nameWithType> istniejących <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> typów i.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="d4e4b-107">Aby użyć standardowych operatorów zapytań, najpierw Przenieś je do zakresu za pomocą `using System.Linq` dyrektywy.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="d4e4b-108">Następnie dowolny typ, który implementuje <xref:System.Collections.Generic.IEnumerable%601> wydaje się mieć metody instancji, takie jak <xref:System.Linq.Enumerable.GroupBy%2A> ,, <xref:System.Linq.Enumerable.OrderBy%2A> <xref:System.Linq.Enumerable.Average%2A> , i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="d4e4b-109">Te dodatkowe metody można zobaczyć w uzupełnianiu instrukcji IntelliSense po wpisaniu "kropki" po wystąpieniu <xref:System.Collections.Generic.IEnumerable%601> typu, takim jak <xref:System.Collections.Generic.List%601> lub <xref:System.Array> .</span><span class="sxs-lookup"><span data-stu-id="d4e4b-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="d4e4b-110">Przykład OrderBy</span><span class="sxs-lookup"><span data-stu-id="d4e4b-110">OrderBy Example</span></span>

<span data-ttu-id="d4e4b-111">Poniższy przykład pokazuje, jak wywołać metodę standardowego operatora zapytania `OrderBy` w tablicy liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="d4e4b-112">Wyrażenie w nawiasach to wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="d4e4b-113">Wiele standardowych operatorów zapytań przyjmuje wyrażenia lambda jako parametry, ale nie jest to wymagane dla metod rozszerzających.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="d4e4b-114">Aby uzyskać więcej informacji, zobacz [wyrażenia lambda](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d4e4b-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="d4e4b-115">Metody rozszerzenia są zdefiniowane jako metody statyczne, ale są wywoływane przy użyciu składni metod wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="d4e4b-116">Ich pierwszy parametr określa typ, na którym działa Metoda.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="d4e4b-117">Parametr jest poprzedzony przez [ten](../../language-reference/keywords/this.md) modyfikator.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="d4e4b-118">Metody rozszerzające są tylko w zakresie, gdy jawnie zaimportowano przestrzeń nazw do kodu źródłowego za pomocą `using` dyrektywy.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="d4e4b-119">Poniższy przykład przedstawia metodę rozszerzenia zdefiniowaną dla <xref:System.String?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="d4e4b-120">Jest on zdefiniowany w niezagnieżdżonej nieogólnej klasie statycznej:</span><span class="sxs-lookup"><span data-stu-id="d4e4b-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="d4e4b-121">`WordCount`Metodę rozszerzenia można wprowadzić do zakresu przy użyciu tej `using` dyrektywy:</span><span class="sxs-lookup"><span data-stu-id="d4e4b-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="d4e4b-122">A za pomocą poniższej składni można ją wywołać z aplikacji:</span><span class="sxs-lookup"><span data-stu-id="d4e4b-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="d4e4b-123">Wywoływanie metody rozszerzenia w kodzie za pomocą składni metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="d4e4b-124">Język pośredni (IL) generowany przez kompilator tłumaczy kod na wywołanie metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="d4e4b-125">Zasada hermetyzacji nie jest naprawdę naruszana.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="d4e4b-126">Metody rozszerzające nie mogą uzyskać dostępu do zmiennych prywatnych w typie, który rozszerza.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="d4e4b-127">Aby uzyskać więcej informacji, zobacz [jak zaimplementować i wywołać niestandardową metodę rozszerzenia](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="d4e4b-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="d4e4b-128">Ogólnie rzecz biorąc, prawdopodobnie będą wywoływane metody rozszerzające znacznie częściej niż implementowanie własnych.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="d4e4b-129">Metody rozszerzenia są wywoływane przy użyciu składni metody wystąpienia, więc nie jest potrzebna specjalistyczna wiedza, aby móc używać ich z poziomu kodu klienta.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="d4e4b-130">Aby włączyć metody rozszerzające dla określonego typu, po prostu Dodaj `using` dyrektywę dla przestrzeni nazw, w której są zdefiniowane metody.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="d4e4b-131">Na przykład aby użyć standardowych operatorów zapytań, należy dodać tę `using` dyrektywę do kodu:</span><span class="sxs-lookup"><span data-stu-id="d4e4b-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="d4e4b-132">(Może być również konieczne dodanie odwołania do System. Core. dll). Można zauważyć, że standardowe operatory zapytań są teraz wyświetlane w technologii IntelliSense jako dodatkowe metody dostępne dla większości <xref:System.Collections.Generic.IEnumerable%601> typów.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="d4e4b-133">Metody rozszerzające w czasie kompilacji</span><span class="sxs-lookup"><span data-stu-id="d4e4b-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="d4e4b-134">Można stosować metody rozszerzenia, aby rozszerzyć klasę lub interfejs, ale nie w celu pominięcia go.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="d4e4b-135">Metoda rozszerzenia mająca taką samą nazwę i podpis jak interfejs lub metoda klasy nigdy nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="d4e4b-136">W czasie kompilacji metody rozszerzenia zawsze mają niższy priorytet niż zdefiniowane w typie metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="d4e4b-137">Innymi słowy, jeśli typ ma metodę o nazwie `Process(int i)` i istnieje metoda rozszerzająca o tym samym podpisie, kompilator zawsze utworzy powiązanie z metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="d4e4b-138">Gdy kompilator napotyka wywołanie metody, najpierw szuka dopasowania w metodach wystąpienia danego typu.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="d4e4b-139">Jeżeli nie znajdzie dopasowania, wyszuka metody rozszerzenia, które są zdefiniowane dla danego typu, i utworzy powiązanie z pierwszą metodą rozszerzenia, którą znajdzie.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="d4e4b-140">W poniższym przykładzie pokazano, w jaki sposób kompilator określa metodę rozszerzenia lub metodę wystąpienia, z którą ma utworzyć powiązanie.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="d4e4b-141">Przykład</span><span class="sxs-lookup"><span data-stu-id="d4e4b-141">Example</span></span>

<span data-ttu-id="d4e4b-142">W poniższym przykładzie przedstawiono reguły, zgodnie z którymi kompilator języka C# określa, czy należy powiązać wywołanie metody z metodą wystąpienia typu, czy z metodą rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="d4e4b-143">Klasa statyczna `Extensions` zawiera metody rozszerzenia zdefiniowane dla dowolnego typu, który implementuje `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="d4e4b-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="d4e4b-144">Klasy `A` , `B` i `C` wszystkie implementują interfejs.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="d4e4b-145">`MethodB`Metoda rozszerzenia nigdy nie jest wywoływana, ponieważ jej nazwa i podpis są dokładnie zgodne z metodami już zaimplementowanymi przez klasy.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="d4e4b-146">Gdy kompilator nie może odnaleźć metody wystąpienia o pasującym podpisie, zostanie on powiązany z pasującą metodą rozszerzenia, jeśli taka istnieje.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="d4e4b-147">Typowe wzorce użycia</span><span class="sxs-lookup"><span data-stu-id="d4e4b-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="d4e4b-148">Funkcje kolekcji</span><span class="sxs-lookup"><span data-stu-id="d4e4b-148">Collection Functionality</span></span>

<span data-ttu-id="d4e4b-149">W przeszłości często utworzono "klasy kolekcji", które implementuje <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interfejs dla danego typu i zawiera funkcje, które działały na kolekcjach tego typu.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="d4e4b-150">Mimo że nie ma żadnych problemów z tworzeniem tego typu obiektu kolekcji, można osiągnąć te same funkcje przy użyciu rozszerzenia w <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d4e4b-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4e4b-151">Rozszerzenia mają zalety zezwalające na wywoływanie funkcji z dowolnej kolekcji, takiej jak <xref:System.Array?displayProperty=nameWithType> lub <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> , która jest implementowana <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="d4e4b-152">Przykładem użycia tablicy Int32 można znaleźć [we wcześniejszej części tego artykułu](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="d4e4b-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="d4e4b-153">Funkcje specyficzne dla warstwy</span><span class="sxs-lookup"><span data-stu-id="d4e4b-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="d4e4b-154">W przypadku używania architektury o architekturze ujęć lub innego projektu aplikacji warstwowych często istnieje zestaw jednostek domeny lub Transfer danych obiektów, które mogą być używane do komunikacji między granicami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="d4e4b-155">Te obiekty zwykle nie zawierają funkcji ani tylko minimalnej funkcjonalności, która ma zastosowanie do wszystkich warstw aplikacji.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="d4e4b-156">Metody rozszerzające mogą służyć do dodawania funkcji, które są specyficzne dla każdej warstwy aplikacji bez ładowania obiektu w dół z niezbędnymi metodami lub w innych warstwach.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="d4e4b-157">Rozszerzanie wstępnie zdefiniowanych typów</span><span class="sxs-lookup"><span data-stu-id="d4e4b-157">Extending Predefined Types</span></span>

<span data-ttu-id="d4e4b-158">Zamiast tworzyć nowe obiekty w przypadku konieczności tworzenia funkcji wielokrotnego użytku, można często rozwijać istniejący typ, taki jak .NET lub CLR.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="d4e4b-159">Jeśli na przykład nie korzystamy z metod rozszerzających, możemy utworzyć `Engine` klasę lub, `Query` Aby wykonać kwerendę na SQL Server, która może być wywołana z wielu miejsc w naszym kodzie.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="d4e4b-160">Można jednak w zamian zwiększyć <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> klasę przy użyciu metod rozszerzających, aby wykonać to zapytanie z dowolnego miejsca, w którym mamy połączenie z SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="d4e4b-161">Innymi przykładami może być Dodawanie typowych funkcji do <xref:System.String?displayProperty=nameWithType> klasy, rozszerzonie możliwości przetwarzania danych i obiektów oraz <xref:System.IO.File?displayProperty=nameWithType> <xref:System.IO.Stream?displayProperty=nameWithType> <xref:System.Exception?displayProperty=nameWithType> obiektów dla określonych funkcji obsługi błędów.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="d4e4b-162">Te typy przypadków użycia są ograniczone tylko przez wyobraźnię i dobre znaczenie.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="d4e4b-163">Rozszerzanie wstępnie zdefiniowanych typów może być trudne z `struct` typami, ponieważ są one przesyłane przez wartość do metod.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="d4e4b-164">Oznacza to, że wszelkie zmiany struktury są wykonywane do kopii struktury.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="d4e4b-165">Te zmiany nie są widoczne po zamknięciu metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="d4e4b-166">Począwszy od języka C# 7,2, można dodać `ref` modyfikator do pierwszego argumentu metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="d4e4b-167">Dodanie `ref` modyfikatora oznacza, że pierwszy argument jest przenoszona przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="d4e4b-168">Dzięki temu można pisać metody rozszerzające, które zmieniają stan rozszerzanej struktury.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="d4e4b-169">Ogólne wskazówki</span><span class="sxs-lookup"><span data-stu-id="d4e4b-169">General Guidelines</span></span>

<span data-ttu-id="d4e4b-170">Mimo że jest to zalecane, aby dodać funkcje, modyfikując kod obiektu lub wprowadzając nowy typ, gdy jest to uzasadnione i możliwe do wykonania, metody rozszerzające stają się kluczową opcją tworzenia funkcji wielokrotnego użytku w całym ekosystemie .NET.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="d4e4b-171">Z tego względu, gdy oryginalne źródło nie znajduje się w kontrolce, gdy obiekt pochodny jest nieodpowiedni lub niemożliwe lub gdy funkcjonalność nie powinna być ujawniona poza odpowiednim zakresem, metody rozszerzające są doskonałym wyborem.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="d4e4b-172">Aby uzyskać więcej informacji na temat typów pochodnych, zobacz [dziedziczenie](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="d4e4b-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="d4e4b-173">W przypadku korzystania z metody rozszerzenia w celu rozszerzenia typu, którego kod źródłowy nie jest kontrolowany, należy uruchomić ryzyko, że zmiana w implementacji typu spowoduje, że Metoda rozszerzenia zostanie przerwana.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="d4e4b-174">W przypadku implementowania metod rozszerzających dla danego typu należy pamiętać o następujących kwestiach:</span><span class="sxs-lookup"><span data-stu-id="d4e4b-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="d4e4b-175">Metoda rozszerzenia nigdy nie zostanie wywołana, jeśli ma taki sam podpis, jak metoda zdefiniowana w typie.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="d4e4b-176">Metody rozszerzenia są włączane do zakresu na poziomie przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="d4e4b-177">Na przykład jeśli masz wiele klas statycznych, które zawierają metody rozszerzające w pojedynczej przestrzeni nazw o nazwie `Extensions` , wszystkie te elementy zostaną wprowadzone do zakresu przez `using Extensions;` dyrektywę.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="d4e4b-178">Dla zaimplementowanej biblioteki klas nie należy używać metod rozszerzenia, aby uniknąć zwiększenia numeru wersji zestawu.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="d4e4b-179">Jeśli chcesz dodać znaczną funkcjonalność do biblioteki, do której należy kod źródłowy, postępuj zgodnie ze wskazówkami dotyczącymi platformy .NET dotyczącymi wersji zestawu.</span><span class="sxs-lookup"><span data-stu-id="d4e4b-179">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="d4e4b-180">Aby uzyskać więcej informacji, zobacz [przechowywanie wersji zestawu](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="d4e4b-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="d4e4b-181">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="d4e4b-181">See also</span></span>

- [<span data-ttu-id="d4e4b-182">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="d4e4b-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="d4e4b-183">Równoległe przykłady programowania (zawierają wiele przykładowych metod rozszerzających)</span><span class="sxs-lookup"><span data-stu-id="d4e4b-183">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="d4e4b-184">Wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="d4e4b-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="d4e4b-185">Standardowe operatory zapytań — Omówienie</span><span class="sxs-lookup"><span data-stu-id="d4e4b-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="d4e4b-186">Reguły konwersji dla parametrów wystąpienia i ich wpływu</span><span class="sxs-lookup"><span data-stu-id="d4e4b-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="d4e4b-187">Metody rozszerzające współdziałanie między językami</span><span class="sxs-lookup"><span data-stu-id="d4e4b-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="d4e4b-188">Metody rozszerzające i Delegaty rozwinięte</span><span class="sxs-lookup"><span data-stu-id="d4e4b-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="d4e4b-189">Powiązanie metody rozszerzenia i raportowanie błędów</span><span class="sxs-lookup"><span data-stu-id="d4e4b-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
