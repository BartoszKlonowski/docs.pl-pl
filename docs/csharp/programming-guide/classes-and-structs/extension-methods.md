---
title: Metody rozszerzeń (Przewodnik programowania w języku C#)
ms.date: 07/20/2015
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 7ebd04665d91f599edcb4a5c07680216dfb8925a
ms.sourcegitcommit: 2350a091ef6459f0fcfd894301242400374d8558
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/21/2018
ms.locfileid: "46529823"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="00a69-102">Metody rozszerzeń (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="00a69-102">Extension Methods (C# Programming Guide)</span></span>
<span data-ttu-id="00a69-103">Metody rozszerzenia umożliwiają „dodawanie” metod do istniejących typów bez konieczności tworzenia nowego typu pochodnego, ponownej kompilacji lub modyfikowania oryginalnego typu w inny sposób.</span><span class="sxs-lookup"><span data-stu-id="00a69-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="00a69-104">Metody rozszerzenia stanowią specjalny rodzaj metod statycznych, ale są wywoływane tak, jakby były metodami wystąpień w typie rozszerzonym.</span><span class="sxs-lookup"><span data-stu-id="00a69-104">Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="00a69-105">Dla kodu klienta napisanego w języku C#, F # i Visual Basic nie istnieje żadna widoczna różnica między wywołaniem metody rozszerzenia i metod, które faktycznie są zdefiniowane w typie.</span><span class="sxs-lookup"><span data-stu-id="00a69-105">For client code written in C#, F# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.</span></span>  
  
 <span data-ttu-id="00a69-106">Najczęściej stosowanymi metodami rozszerzenia są [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] standardowych operatorów zapytań, które dodają funkcje zapytań do istniejących <xref:System.Collections.IEnumerable?displayProperty=nameWithType> i <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> typów.</span><span class="sxs-lookup"><span data-stu-id="00a69-106">The most common extension methods are the [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="00a69-107">Aby użyć standardowych operatorów zapytań, najpierw Doprowadź je do zakresu za pomocą `using System.Linq` dyrektywy.</span><span class="sxs-lookup"><span data-stu-id="00a69-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="00a69-108">Następnie dowolny typ, który implementuje <xref:System.Collections.Generic.IEnumerable%601> wydaje się mieć metody wystąpień, takie jak <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="00a69-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="00a69-109">Możesz zobaczyć te dodatkowe metody w instrukcji IntelliSense po wpisaniu "dot" po wystąpieniu typu <xref:System.Collections.Generic.IEnumerable%601> wpisz na przykład <xref:System.Collections.Generic.List%601> lub <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="00a69-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="00a69-110">Poniższy przykład pokazuje sposób wywoływania standardowego operatora zapytania `OrderBy` metody w tablicy liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="00a69-110">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="00a69-111">Wyrażenie w nawiasach to wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="00a69-111">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="00a69-112">Wiele standardowych operatorów zapytań przyjmuje wyrażenia lambda jako parametry, ale nie jest to wymagane dla metod rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="00a69-112">Many standard query operators take lambda expressions as parameters, but this is not a requirement for extension methods.</span></span> <span data-ttu-id="00a69-113">Aby uzyskać więcej informacji, zobacz [wyrażeń Lambda](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="00a69-113">For more information, see [Lambda Expressions](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_1.cs)]  
  
 <span data-ttu-id="00a69-114">Metody rozszerzenia są zdefiniowane jako metody statyczne, ale są wywoływane przy użyciu składni metod wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="00a69-114">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="00a69-115">Ich pierwszy parametr określa, jakiego typu metoda działa, i ten parametr jest poprzedzony przez [to](../../../csharp/language-reference/keywords/this.md) modyfikator.</span><span class="sxs-lookup"><span data-stu-id="00a69-115">Their first parameter specifies which type the method operates on, and the parameter is preceded by the [this](../../../csharp/language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="00a69-116">Metody rozszerzające są w zakresie wyłącznie wtedy, gdy jawnie importujesz przestrzeń nazw do kodu źródłowego za pomocą `using` dyrektywy.</span><span class="sxs-lookup"><span data-stu-id="00a69-116">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>  
  
 <span data-ttu-id="00a69-117">W poniższym przykładzie pokazano metodę rozszerzenia zdefiniowaną dla <xref:System.String?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="00a69-117">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="00a69-118">Należy zauważyć, że zdefiniowano ją wewnątrz niezagnieżdżonej nieogólnej klasy statycznej:</span><span class="sxs-lookup"><span data-stu-id="00a69-118">Note that it is defined inside a non-nested, non-generic static class:</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_2.cs)]  
  
 <span data-ttu-id="00a69-119">`WordCount` — Metoda rozszerzenia może być wprowadzana do zakresu za pomocą `using` dyrektywy:</span><span class="sxs-lookup"><span data-stu-id="00a69-119">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>  
  
```csharp  
using ExtensionMethods;  
```  
  
 <span data-ttu-id="00a69-120">A za pomocą poniższej składni można ją wywołać z aplikacji:</span><span class="sxs-lookup"><span data-stu-id="00a69-120">And it can be called from an application by using this syntax:</span></span>  
  
```csharp  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 <span data-ttu-id="00a69-121">W kodzie metoda rozszerzenia jest wywoływana za pomocą składni metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="00a69-121">In your code you invoke the extension method with instance method syntax.</span></span> <span data-ttu-id="00a69-122">Jednak język pośredni (IL) generowany przez kompilator dokonuje translacji kodu na wywołanie metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="00a69-122">However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="00a69-123">W związku z tym zasada hermetyzacji tak naprawdę nie jest naruszana.</span><span class="sxs-lookup"><span data-stu-id="00a69-123">Therefore, the principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="00a69-124">W rzeczywistości metody rozszerzenia nie mają dostępu do zmiennych prywatnych w typie, który rozszerzają.</span><span class="sxs-lookup"><span data-stu-id="00a69-124">In fact, extension methods cannot access private variables in the type they are extending.</span></span>  
  
 <span data-ttu-id="00a69-125">Aby uzyskać więcej informacji, zobacz [porady: Implementowanie i wywołanie metody rozszerzenia niestandardowe](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="00a69-125">For more information, see [How to: Implement and Call a Custom  Extension Method](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span></span>  
  
 <span data-ttu-id="00a69-126">Ogólnie rzecz biorąc, liczba wywołań metod rozszerzenia zazwyczaj jest o wiele większa niż liczba implementacji własnych metod.</span><span class="sxs-lookup"><span data-stu-id="00a69-126">In general, you will probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="00a69-127">Metody rozszerzenia są wywoływane przy użyciu składni metody wystąpienia, więc nie jest potrzebna specjalistyczna wiedza, aby móc używać ich z poziomu kodu klienta.</span><span class="sxs-lookup"><span data-stu-id="00a69-127">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="00a69-128">Aby włączyć metody rozszerzające dla określonego typu, wystarczy dodać atrybut `using` dyrektywy dla przestrzeni nazw, w którym są zdefiniowane te metody.</span><span class="sxs-lookup"><span data-stu-id="00a69-128">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="00a69-129">Na przykład, aby użyć standardowych operatorów zapytań, dodaj to `using` dyrektywę w kodzie:</span><span class="sxs-lookup"><span data-stu-id="00a69-129">For example, to use the standard query operators, add this `using` directive to your code:</span></span>  
  
```csharp  
using System.Linq;  
```  
  
 <span data-ttu-id="00a69-130">(Może być też koniecznie dodanie odwołania do biblioteki System.Core.dll). Zauważysz, że standardowe operatory zapytań pojawiają się w IntelliSense jako dodatkowe metody dostępne dla większości <xref:System.Collections.Generic.IEnumerable%601> typów.</span><span class="sxs-lookup"><span data-stu-id="00a69-130">(You may also have to add a reference to System.Core.dll.) You will notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>  
  
## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="00a69-131">Metody rozszerzające w czasie kompilacji</span><span class="sxs-lookup"><span data-stu-id="00a69-131">Binding Extension Methods at Compile Time</span></span>  
 <span data-ttu-id="00a69-132">Można stosować metody rozszerzenia, aby rozszerzyć klasę lub interfejs, ale nie w celu pominięcia go.</span><span class="sxs-lookup"><span data-stu-id="00a69-132">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="00a69-133">Metoda rozszerzenia mająca taką samą nazwę i podpis jak interfejs lub metoda klasy nigdy nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="00a69-133">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="00a69-134">W czasie kompilacji metody rozszerzenia zawsze mają niższy priorytet niż zdefiniowane w typie metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="00a69-134">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="00a69-135">Innymi słowy, jeśli typ ma metodę o nazwie `Process(int i)`i masz metodę rozszerzającą o tym samym podpisie, kompilator zawsze utworzy wiązanie z metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="00a69-135">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="00a69-136">Gdy kompilator napotyka wywołanie metody, najpierw szuka dopasowania w metodach wystąpienia danego typu.</span><span class="sxs-lookup"><span data-stu-id="00a69-136">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="00a69-137">Jeżeli nie znajdzie dopasowania, wyszuka metody rozszerzenia, które są zdefiniowane dla danego typu, i utworzy powiązanie z pierwszą metodą rozszerzenia, którą znajdzie.</span><span class="sxs-lookup"><span data-stu-id="00a69-137">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="00a69-138">W poniższym przykładzie pokazano, w jaki sposób kompilator określa metodę rozszerzenia lub metodę wystąpienia, z którą ma utworzyć powiązanie.</span><span class="sxs-lookup"><span data-stu-id="00a69-138">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>  
  
## <a name="example"></a><span data-ttu-id="00a69-139">Przykład</span><span class="sxs-lookup"><span data-stu-id="00a69-139">Example</span></span>  
 <span data-ttu-id="00a69-140">W poniższym przykładzie przedstawiono reguły, zgodnie z którymi kompilator języka C# określa, czy należy powiązać wywołanie metody z metodą wystąpienia typu, czy z metodą rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="00a69-140">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="00a69-141">Klasa statyczna `Extensions` zawiera metody rozszerzenia zdefiniowane dla dowolnego typu, który implementuje `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="00a69-141">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="00a69-142">Klasy `A`, `B`, i `C` implementują interfejs.</span><span class="sxs-lookup"><span data-stu-id="00a69-142">Classes `A`, `B`, and `C` all implement the interface.</span></span>  
  
 <span data-ttu-id="00a69-143">`MethodB` — Metoda rozszerzenia nigdy nie jest wywoływana, ponieważ jego nazwa i podpis dokładnie pasują do metod już zaimplementowanych przez klasy.</span><span class="sxs-lookup"><span data-stu-id="00a69-143">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>  
  
 <span data-ttu-id="00a69-144">Gdy kompilator nie może odnaleźć metody wystąpienia mającej pasujący podpis, tworzy powiązanie z pasującą metodą rozszerzenia, jeśli taka istnieje.</span><span class="sxs-lookup"><span data-stu-id="00a69-144">When the compiler cannot find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_3.cs)]  
  
## <a name="general-guidelines"></a><span data-ttu-id="00a69-145">Ogólne wskazówki</span><span class="sxs-lookup"><span data-stu-id="00a69-145">General Guidelines</span></span>  
 <span data-ttu-id="00a69-146">Ogólnie zalecane jest, aby implementować metody rozszerzenia oszczędnie i tylko wtedy, gdy jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="00a69-146">In general, we recommend that you implement extension methods sparingly and only when you have to.</span></span> <span data-ttu-id="00a69-147">Jeśli to możliwe, kod klienta, który musi rozszerzyć istniejący typ, powinien to zrobić przez utworzenie nowego typu, który będzie typem pochodnym istniejącego typu.</span><span class="sxs-lookup"><span data-stu-id="00a69-147">Whenever possible, client code that must extend an existing type should do so by creating a new type derived from the existing type.</span></span> <span data-ttu-id="00a69-148">Aby uzyskać więcej informacji, zobacz [dziedziczenia](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="00a69-148">For more information, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
 <span data-ttu-id="00a69-149">W przypadku korzystania z metody rozszerzenia w celu rozszerzania typu, którego kodu źródłowego nie można zmienić, istnieje ryzyko, że zmiana w implementacji typu spowoduje przerwanie działania metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="00a69-149">When using an extension method to extend a type whose source code you cannot change, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>  
  
 <span data-ttu-id="00a69-150">W przypadku zastosowania metody rozszerzenia dla danego typu, należy pamiętać o następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="00a69-150">If you do implement extension methods for a given type, remember the following points:</span></span>  
  
-   <span data-ttu-id="00a69-151">Metoda rozszerzenia nigdy nie zostanie wywołana, jeśli ma taki sam podpis, jak metoda zdefiniowana w typie.</span><span class="sxs-lookup"><span data-stu-id="00a69-151">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>  
  
-   <span data-ttu-id="00a69-152">Metody rozszerzenia są włączane do zakresu na poziomie przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="00a69-152">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="00a69-153">Na przykład, jeśli masz wiele klas statycznych, które zawierają metody rozszerzające w pojedynczej przestrzeni nazw o nazwie `Extensions`, ich zostaną wszystkie włączone do zakresu `using Extensions;` dyrektywy.</span><span class="sxs-lookup"><span data-stu-id="00a69-153">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they will all be brought into scope by the `using Extensions;` directive.</span></span>  
  
 <span data-ttu-id="00a69-154">Dla zaimplementowanej biblioteki klas nie należy używać metod rozszerzenia, aby uniknąć zwiększenia numeru wersji zestawu.</span><span class="sxs-lookup"><span data-stu-id="00a69-154">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="00a69-155">W przypadku dodawania znaczącej funkcjonalności do biblioteki, której kod źródłowy jest własnością użytkownika, należy przestrzegać standardowych wytycznych programu .NET Framework dotyczących wersji zestawów.</span><span class="sxs-lookup"><span data-stu-id="00a69-155">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="00a69-156">Aby uzyskać więcej informacji, zobacz [przechowywanie wersji zestawu](../../../../docs/framework/app-domains/assembly-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="00a69-156">For more information, see [Assembly Versioning](../../../../docs/framework/app-domains/assembly-versioning.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="00a69-157">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="00a69-157">See Also</span></span>

- [<span data-ttu-id="00a69-158">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="00a69-158">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
- [<span data-ttu-id="00a69-159">Równoległe przykłady programowania (zawierają wiele przykładów metod rozszerzenia)</span><span class="sxs-lookup"><span data-stu-id="00a69-159">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)  
- [<span data-ttu-id="00a69-160">Wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="00a69-160">Lambda Expressions</span></span>](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)  
- [<span data-ttu-id="00a69-161">Standardowe operatory zapytań — przegląd</span><span class="sxs-lookup"><span data-stu-id="00a69-161">Standard Query Operators Overview</span></span>](../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="00a69-162">Reguły konwersji dla wystąpienia parametrów i ich wpływ</span><span class="sxs-lookup"><span data-stu-id="00a69-162">Conversion rules for Instance parameters and their impact</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/conversion-rules-for-instance-parameters-and-their-impact)  
- [<span data-ttu-id="00a69-163">Międzyoperacyjność metod rozszerzających między językami</span><span class="sxs-lookup"><span data-stu-id="00a69-163">Extension methods Interoperability between languages</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/extension-methods-interoperability-between-languages)  
- [<span data-ttu-id="00a69-164">Metody rozszerzające i przenoszeni delegaci</span><span class="sxs-lookup"><span data-stu-id="00a69-164">Extension methods and Curried Delegates</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/05/01/extension-methods-and-curried-delegates)  
- [<span data-ttu-id="00a69-165">Metoda rozszerzenia powiązań i raportowanie błędów</span><span class="sxs-lookup"><span data-stu-id="00a69-165">Extension method Binding and Error reporting</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/04/26/extension-method-binding-and-error-reporting)
