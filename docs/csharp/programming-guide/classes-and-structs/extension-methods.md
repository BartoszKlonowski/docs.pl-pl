---
title: Metody rozszerzenia — przewodnik po programowaniu języka C#
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0b35ad523fc7f0949cb5243edbdc50cd3e927999
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249223"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="9cf17-102">Metody rozszerzeń (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="9cf17-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="9cf17-103">Metody rozszerzenia umożliwiają „dodawanie” metod do istniejących typów bez konieczności tworzenia nowego typu pochodnego, ponownej kompilacji lub modyfikowania oryginalnego typu w inny sposób.</span><span class="sxs-lookup"><span data-stu-id="9cf17-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="9cf17-104">Metody rozszerzenia są metody statyczne, ale są one wywoływane tak, jakby były metody wystąpienia na typ rozszerzony.</span><span class="sxs-lookup"><span data-stu-id="9cf17-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="9cf17-105">Dla kodu klienta napisanego w językach C#, F# i Visual Basic nie ma widocznej różnicy między wywołaniem metody rozszerzenia a metodami zdefiniowanymi w typie.</span><span class="sxs-lookup"><span data-stu-id="9cf17-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="9cf17-106">Najbardziej typowe metody rozszerzenia są LINQ standardowych operatorów zapytań, które dodają funkcje kwerendy do istniejących <xref:System.Collections.IEnumerable?displayProperty=nameWithType> i <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> typów.</span><span class="sxs-lookup"><span data-stu-id="9cf17-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="9cf17-107">Aby użyć standardowych operatorów zapytań, najpierw `using System.Linq` przenieś je do zakresu za pomocą dyrektywy.</span><span class="sxs-lookup"><span data-stu-id="9cf17-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="9cf17-108">Następnie każdy typ, <xref:System.Collections.Generic.IEnumerable%601> który implementuje wydaje <xref:System.Linq.Enumerable.GroupBy%2A> <xref:System.Linq.Enumerable.OrderBy%2A>się <xref:System.Linq.Enumerable.Average%2A>mieć metody wystąpienia, takie jak , , i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cf17-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="9cf17-109">Te dodatkowe metody można zobaczyć w uzupełnieniu instrukcji IntelliSense po wpisaniu "kropka" po wystąpieniu <xref:System.Collections.Generic.IEnumerable%601> typu, takiego jak <xref:System.Collections.Generic.List%601> lub <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="9cf17-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="9cf17-110">Przykład OrderBy</span><span class="sxs-lookup"><span data-stu-id="9cf17-110">OrderBy Example</span></span>

<span data-ttu-id="9cf17-111">W poniższym przykładzie pokazano, `OrderBy` jak wywołać standardową metodę operatora kwerendy na tablicy liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="9cf17-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="9cf17-112">Wyrażenie w nawiasach to wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="9cf17-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="9cf17-113">Wiele standardowych operatorów zapytań przyjmuje wyrażenia lambda jako parametry, ale nie jest to wymagane dla metod rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="9cf17-114">Aby uzyskać więcej informacji, zobacz [Wyrażenia Lambda](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="9cf17-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="9cf17-115">Metody rozszerzenia są zdefiniowane jako metody statyczne, ale są wywoływane przy użyciu składni metod wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="9cf17-116">Ich pierwszy parametr określa, na którym typ działa metoda.</span><span class="sxs-lookup"><span data-stu-id="9cf17-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="9cf17-117">Parametr jest poprzedzony [tym](../../language-reference/keywords/this.md) modyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="9cf17-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="9cf17-118">Metody rozszerzenia są tylko w zakresie, gdy jawnie zaimportować obszar nazw do kodu źródłowego z dyrektywą. `using`</span><span class="sxs-lookup"><span data-stu-id="9cf17-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="9cf17-119">Poniższy przykład przedstawia metodę rozszerzenia <xref:System.String?displayProperty=nameWithType> zdefiniowaną dla klasy.</span><span class="sxs-lookup"><span data-stu-id="9cf17-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="9cf17-120">Jest zdefiniowany wewnątrz niezagnieżdżonej, niegenerycznej klasy statycznej:</span><span class="sxs-lookup"><span data-stu-id="9cf17-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="9cf17-121">Metoda `WordCount` rozszerzenia może zostać wprowadzona `using` w zakres tej dyrektywy:</span><span class="sxs-lookup"><span data-stu-id="9cf17-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="9cf17-122">A za pomocą poniższej składni można ją wywołać z aplikacji:</span><span class="sxs-lookup"><span data-stu-id="9cf17-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="9cf17-123">Wywołać metodę rozszerzenia w kodzie ze składnią metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="9cf17-124">Język pośredni (IL) generowany przez kompilator tłumaczy kod na wywołanie metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="9cf17-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="9cf17-125">Zasada hermetyzacji nie jest tak naprawdę naruszana.</span><span class="sxs-lookup"><span data-stu-id="9cf17-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="9cf17-126">Metody rozszerzenia nie mogą uzyskać dostępu do zmiennych prywatnych w typie, który rozszerzają.</span><span class="sxs-lookup"><span data-stu-id="9cf17-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="9cf17-127">Aby uzyskać więcej informacji, zobacz [Jak zaimplementować i wywołać niestandardową metodę rozszerzenia](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="9cf17-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="9cf17-128">Ogólnie rzecz biorąc prawdopodobnie będziesz wywoływać metody rozszerzenia znacznie częściej niż implementowanie własnych.</span><span class="sxs-lookup"><span data-stu-id="9cf17-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="9cf17-129">Metody rozszerzenia są wywoływane przy użyciu składni metody wystąpienia, więc nie jest potrzebna specjalistyczna wiedza, aby móc używać ich z poziomu kodu klienta.</span><span class="sxs-lookup"><span data-stu-id="9cf17-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="9cf17-130">Aby włączyć metody rozszerzenia dla określonego `using` typu, wystarczy dodać dyrektywę dla obszaru nazw, w którym metody są zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="9cf17-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="9cf17-131">Na przykład, aby użyć standardowych operatorów zapytań, dodaj tę `using` dyrektywę do kodu:</span><span class="sxs-lookup"><span data-stu-id="9cf17-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="9cf17-132">(Może być również trzeba dodać odwołanie do Pliku System.Core.dll. Można zauważyć, że standardowe operatory zapytań są teraz wyświetlane w <xref:System.Collections.Generic.IEnumerable%601> IntelliSense jako dodatkowe metody dostępne dla większości typów.</span><span class="sxs-lookup"><span data-stu-id="9cf17-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="9cf17-133">Metody rozszerzające w czasie kompilacji</span><span class="sxs-lookup"><span data-stu-id="9cf17-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="9cf17-134">Można stosować metody rozszerzenia, aby rozszerzyć klasę lub interfejs, ale nie w celu pominięcia go.</span><span class="sxs-lookup"><span data-stu-id="9cf17-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="9cf17-135">Metoda rozszerzenia mająca taką samą nazwę i podpis jak interfejs lub metoda klasy nigdy nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="9cf17-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="9cf17-136">W czasie kompilacji metody rozszerzenia zawsze mają niższy priorytet niż zdefiniowane w typie metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="9cf17-137">Innymi słowy, jeśli typ ma `Process(int i)`metodę o nazwie , a masz metodę rozszerzenia z tym samym podpisem, kompilator zawsze będzie powiązany z metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="9cf17-138">Gdy kompilator napotyka wywołanie metody, najpierw szuka dopasowania w metodach wystąpienia danego typu.</span><span class="sxs-lookup"><span data-stu-id="9cf17-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="9cf17-139">Jeżeli nie znajdzie dopasowania, wyszuka metody rozszerzenia, które są zdefiniowane dla danego typu, i utworzy powiązanie z pierwszą metodą rozszerzenia, którą znajdzie.</span><span class="sxs-lookup"><span data-stu-id="9cf17-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="9cf17-140">W poniższym przykładzie pokazano, w jaki sposób kompilator określa metodę rozszerzenia lub metodę wystąpienia, z którą ma utworzyć powiązanie.</span><span class="sxs-lookup"><span data-stu-id="9cf17-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="9cf17-141">Przykład</span><span class="sxs-lookup"><span data-stu-id="9cf17-141">Example</span></span>

<span data-ttu-id="9cf17-142">W poniższym przykładzie przedstawiono reguły, zgodnie z którymi kompilator języka C# określa, czy należy powiązać wywołanie metody z metodą wystąpienia typu, czy z metodą rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="9cf17-143">Klasa statyczna `Extensions` zawiera metody rozszerzenia zdefiniowane `IMyInterface`dla każdego typu implementuujego .</span><span class="sxs-lookup"><span data-stu-id="9cf17-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="9cf17-144">Klasy `A` `B`, `C` i wszystkie implementują interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cf17-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="9cf17-145">Metoda `MethodB` rozszerzenia nigdy nie jest wywoływana, ponieważ jej nazwa i podpis dokładnie pasują do metod już zaimplementowanych przez klasy.</span><span class="sxs-lookup"><span data-stu-id="9cf17-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="9cf17-146">Gdy kompilator nie może znaleźć metody wystąpienia z podpisem dopasowania, będzie powiązana z pasujące metody rozszerzenia, jeśli istnieje.</span><span class="sxs-lookup"><span data-stu-id="9cf17-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="9cf17-147">Typowe wzorce użycia</span><span class="sxs-lookup"><span data-stu-id="9cf17-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="9cf17-148">Funkcja zbierania</span><span class="sxs-lookup"><span data-stu-id="9cf17-148">Collection Functionality</span></span>

<span data-ttu-id="9cf17-149">W przeszłości było wspólne do tworzenia "Klas kolekcji", który implementował <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interfejs dla danego typu i zawarte funkcje, które działały na kolekcje tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cf17-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="9cf17-150">Chociaż nie ma nic złego w tworzeniu tego typu obiektu kolekcji, tę samą <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>funkcjonalność można osiągnąć za pomocą rozszerzenia na .</span><span class="sxs-lookup"><span data-stu-id="9cf17-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cf17-151">Rozszerzenia mają tę zaletę, że funkcja ma być wywoływana z dowolnej kolekcji, <xref:System.Array?displayProperty=nameWithType> takiej jak lub <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> implementuje <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> w tym typie.</span><span class="sxs-lookup"><span data-stu-id="9cf17-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="9cf17-152">Przykład tego przy użyciu tablicy Int32 można znaleźć [wcześniej w tym artykule](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="9cf17-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="9cf17-153">Funkcje specyficzne dla warstwy</span><span class="sxs-lookup"><span data-stu-id="9cf17-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="9cf17-154">Podczas korzystania z architektury cebuli lub innych warstwowych projektu aplikacji, jest często zestaw jednostek domeny lub obiektów transferu danych, które mogą służyć do komunikowania się między granicami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9cf17-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="9cf17-155">Obiekty te zazwyczaj nie zawierają żadnych funkcji lub tylko minimalne funkcje, które ma zastosowanie do wszystkich warstw aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9cf17-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="9cf17-156">Metody rozszerzenia mogą służyć do dodawania funkcji, które są specyficzne dla każdej warstwy aplikacji bez ładowania obiektu w dół z metod nie jest potrzebne lub pożądane w innych warstwach.</span><span class="sxs-lookup"><span data-stu-id="9cf17-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="9cf17-157">Rozszerzanie wstępnie zdefiniowanych typów</span><span class="sxs-lookup"><span data-stu-id="9cf17-157">Extending Predefined Types</span></span>

<span data-ttu-id="9cf17-158">Zamiast tworzyć nowe obiekty, gdy należy utworzyć funkcje wielokrotnego użytku, często możemy rozszerzyć istniejący typ, taki jak .NET Framework lub CLR.</span><span class="sxs-lookup"><span data-stu-id="9cf17-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type such as a .NET Framework or CLR type.</span></span> <span data-ttu-id="9cf17-159">Na przykład jeśli nie używamy metod rozszerzenia, możemy `Engine` utworzyć `Query` lub klasy do wykonywania kwerendy na serwerze SQL, które mogą być wywoływane z wielu miejsc w naszym kodzie.</span><span class="sxs-lookup"><span data-stu-id="9cf17-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="9cf17-160">Jednak zamiast tego możemy <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> rozszerzyć klasę przy użyciu metod rozszerzenia, aby wykonać tę kwerendę z dowolnego miejsca, z których mamy połączenie z programem SQL Server.</span><span class="sxs-lookup"><span data-stu-id="9cf17-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="9cf17-161">Inne przykłady mogą być dodać typowe <xref:System.String?displayProperty=nameWithType> funkcje do klasy, rozszerzyć <xref:System.IO.File?displayProperty=nameWithType> <xref:System.IO.Stream?displayProperty=nameWithType> możliwości przetwarzania <xref:System.Exception?displayProperty=nameWithType> danych i obiektów i obiektów dla określonych funkcji obsługi błędów.</span><span class="sxs-lookup"><span data-stu-id="9cf17-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="9cf17-162">Tego typu przypadki użycia są ograniczone tylko przez wyobraźnię i zdrowy rozsądek.</span><span class="sxs-lookup"><span data-stu-id="9cf17-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="9cf17-163">Rozszerzanie wstępnie zdefiniowanych typów może `struct` być trudne w przypadku typów, ponieważ są one przekazywane przez wartość do metod.</span><span class="sxs-lookup"><span data-stu-id="9cf17-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="9cf17-164">Oznacza to, że wszelkie zmiany w strukturze są wprowadzane do kopii struktury.</span><span class="sxs-lookup"><span data-stu-id="9cf17-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="9cf17-165">Te zmiany nie są widoczne po zamknięciu metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="9cf17-166">Począwszy od języka C# 7.2, można dodać `ref` modyfikator do pierwszego argumentu metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="9cf17-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="9cf17-167">Dodanie `ref` modyfikatora oznacza, że pierwszy argument jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cf17-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="9cf17-168">Dzięki temu można napisać metody rozszerzenia, które zmieniają stan struktury jest rozszerzony.</span><span class="sxs-lookup"><span data-stu-id="9cf17-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="9cf17-169">Ogólne wskazówki</span><span class="sxs-lookup"><span data-stu-id="9cf17-169">General Guidelines</span></span>

<span data-ttu-id="9cf17-170">Chociaż nadal uważa się za preferowane, aby dodać funkcjonalność, modyfikując kod obiektu lub wyprowadzając nowy typ, gdy jest to uzasadnione i możliwe, metody rozszerzenia stały się kluczową opcją do tworzenia funkcji wielokrotnego użytku w całej .NET Ekosystemu.</span><span class="sxs-lookup"><span data-stu-id="9cf17-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="9cf17-171">W tych przypadkach, gdy oryginalne źródło nie jest pod kontrolą, gdy obiekt pochodny jest nieodpowiedni lub niemożliwe lub gdy funkcja nie powinna być narażona poza jego odpowiedni zakres, Metody rozszerzenia są doskonałym wyborem.</span><span class="sxs-lookup"><span data-stu-id="9cf17-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="9cf17-172">Aby uzyskać więcej informacji na temat typów pochodnych, zobacz [Dziedziczenie](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="9cf17-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="9cf17-173">Podczas korzystania z metody rozszerzenia, aby rozszerzyć typ, którego kod źródłowy nie są pod kontrolą, istnieje ryzyko, że zmiana w implementacji typu spowoduje, że metoda rozszerzenia do przerwania.</span><span class="sxs-lookup"><span data-stu-id="9cf17-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="9cf17-174">Jeśli zaimplementujesz metody rozszerzenia dla danego typu, należy pamiętać o następujących punktach:</span><span class="sxs-lookup"><span data-stu-id="9cf17-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="9cf17-175">Metoda rozszerzenia nigdy nie zostanie wywołana, jeśli ma taki sam podpis, jak metoda zdefiniowana w typie.</span><span class="sxs-lookup"><span data-stu-id="9cf17-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="9cf17-176">Metody rozszerzenia są włączane do zakresu na poziomie przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="9cf17-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="9cf17-177">Na przykład jeśli masz wiele klas statycznych, które zawierają `Extensions`metody rozszerzenia w jednej przestrzeni nazw `using Extensions;` o nazwie , wszystkie one zostaną wprowadzone do zakresu przez dyrektywę.</span><span class="sxs-lookup"><span data-stu-id="9cf17-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="9cf17-178">Dla zaimplementowanej biblioteki klas nie należy używać metod rozszerzenia, aby uniknąć zwiększenia numeru wersji zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cf17-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="9cf17-179">W przypadku dodawania znaczącej funkcjonalności do biblioteki, której kod źródłowy jest własnością użytkownika, należy przestrzegać standardowych wytycznych programu .NET Framework dotyczących wersji zestawów.</span><span class="sxs-lookup"><span data-stu-id="9cf17-179">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="9cf17-180">Aby uzyskać więcej informacji, zobacz [Versioning zestawu](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="9cf17-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="9cf17-181">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="9cf17-181">See also</span></span>

- [<span data-ttu-id="9cf17-182">C# Przewodnik programowania</span><span class="sxs-lookup"><span data-stu-id="9cf17-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="9cf17-183">Przykłady programowania równoległego (obejmują one wiele przykładowych metod rozszerzenia)</span><span class="sxs-lookup"><span data-stu-id="9cf17-183">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
- [<span data-ttu-id="9cf17-184">Wyrażenia Lambda</span><span class="sxs-lookup"><span data-stu-id="9cf17-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="9cf17-185">Standardowe operatory zapytań — przegląd</span><span class="sxs-lookup"><span data-stu-id="9cf17-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="9cf17-186">Reguły konwersji dla parametrów instancji i ich wpływu</span><span class="sxs-lookup"><span data-stu-id="9cf17-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="9cf17-187">Metody rozszerzenia Interoperacyjność między językami</span><span class="sxs-lookup"><span data-stu-id="9cf17-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="9cf17-188">Metody rozszerzenia i curried delegatów</span><span class="sxs-lookup"><span data-stu-id="9cf17-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="9cf17-189">Powiązanie metody rozszerzenia i raportowanie błędów</span><span class="sxs-lookup"><span data-stu-id="9cf17-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
