---
title: Funkcje lokalne — Przewodnik programowania w języku C#
description: Funkcje lokalne w języku C# to metody prywatne, które są zagnieżdżone w innym elemencie członkowskim i mogą być wywoływane z ich składowych.
ms.date: 06/14/2017
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 9987d6d5ad57c1dceb3a4bffbae22a81c240c794
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/21/2020
ms.locfileid: "86864530"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="8790f-103">Funkcje lokalne (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="8790f-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="8790f-104">Począwszy od języka C# 7,0, C# obsługuje *funkcje lokalne*.</span><span class="sxs-lookup"><span data-stu-id="8790f-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="8790f-105">Funkcje lokalne są prywatnymi metodami typu, które są zagnieżdżone w innym elemencie członkowskim.</span><span class="sxs-lookup"><span data-stu-id="8790f-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="8790f-106">Mogą być wywoływane tylko z ich składowych.</span><span class="sxs-lookup"><span data-stu-id="8790f-106">They can only be called from their containing member.</span></span> <span data-ttu-id="8790f-107">Funkcje lokalne można zadeklarować w i wywołać z:</span><span class="sxs-lookup"><span data-stu-id="8790f-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="8790f-108">Metody, zwłaszcza metody iteratorów i metody asynchroniczne</span><span class="sxs-lookup"><span data-stu-id="8790f-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="8790f-109">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="8790f-109">Constructors</span></span>
- <span data-ttu-id="8790f-110">Metody dostępu do właściwości</span><span class="sxs-lookup"><span data-stu-id="8790f-110">Property accessors</span></span>
- <span data-ttu-id="8790f-111">Metody dostępu zdarzeń</span><span class="sxs-lookup"><span data-stu-id="8790f-111">Event accessors</span></span>
- <span data-ttu-id="8790f-112">Metody anonimowe</span><span class="sxs-lookup"><span data-stu-id="8790f-112">Anonymous methods</span></span>
- <span data-ttu-id="8790f-113">Wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="8790f-113">Lambda expressions</span></span>
- <span data-ttu-id="8790f-114">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="8790f-114">Finalizers</span></span>
- <span data-ttu-id="8790f-115">Inne funkcje lokalne</span><span class="sxs-lookup"><span data-stu-id="8790f-115">Other local functions</span></span>

<span data-ttu-id="8790f-116">Jednak funkcji lokalnych nie można deklarować wewnątrz elementu członkowskiego będącego w posiadaniu wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="8790f-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="8790f-117">W niektórych przypadkach można użyć wyrażenia lambda, aby zaimplementować funkcje również obsługiwane przez funkcję lokalną.</span><span class="sxs-lookup"><span data-stu-id="8790f-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="8790f-118">Aby zapoznać się z porównaniem, zobacz [funkcje lokalne a wyrażenia lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="8790f-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="8790f-119">Funkcje lokalne sprawiają, że zamiar kodu jest przejrzysty.</span><span class="sxs-lookup"><span data-stu-id="8790f-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="8790f-120">Każda osoba odczytująca kod może zobaczyć, że metoda nie jest wywoływana z wyjątkiem metody zawierającej.</span><span class="sxs-lookup"><span data-stu-id="8790f-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="8790f-121">W przypadku projektów zespołowych uniemożliwiają one również innym deweloperom błędne wywoływanie metody bezpośrednio z innych miejsc w klasie lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="8790f-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="8790f-122">Składnia funkcji lokalnych</span><span class="sxs-lookup"><span data-stu-id="8790f-122">Local function syntax</span></span>

<span data-ttu-id="8790f-123">Funkcja lokalna jest definiowana jako metoda zagnieżdżona wewnątrz składowej zawierającej.</span><span class="sxs-lookup"><span data-stu-id="8790f-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="8790f-124">Jego definicja ma następującą składnię:</span><span class="sxs-lookup"><span data-stu-id="8790f-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers: async | unsafe> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="8790f-125">Funkcje lokalne mogą używać modyfikatorów [Async](../../language-reference/keywords/async.md) i [UNSAFE](../../language-reference/keywords/unsafe.md) .</span><span class="sxs-lookup"><span data-stu-id="8790f-125">Local functions can use the [async](../../language-reference/keywords/async.md) and [unsafe](../../language-reference/keywords/unsafe.md) modifiers.</span></span>

<span data-ttu-id="8790f-126">Należy zauważyć, że wszystkie zmienne lokalne, które są zdefiniowane w składowej zawierającej, łącznie z parametrami metody, są dostępne w funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="8790f-126">Note that all local variables that are defined in the containing member, including its method parameters, are accessible in the local function.</span></span>

<span data-ttu-id="8790f-127">W przeciwieństwie do definicji metody lokalnej definicja funkcji nie może zawierać modyfikatora dostępu do składowej.</span><span class="sxs-lookup"><span data-stu-id="8790f-127">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="8790f-128">Ponieważ wszystkie funkcje lokalne są prywatne, łącznie z modyfikatorem dostępu, takim jak `private` słowo kluczowe, generuje błąd kompilatora CS0106 "modyfikator" Private "jest nieprawidłowy dla tego elementu".</span><span class="sxs-lookup"><span data-stu-id="8790f-128">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

> [!NOTE]
> <span data-ttu-id="8790f-129">W systemach wcześniejszych niż C# 8,0 funkcja lokalna nie może zawierać `static` modyfikatora.</span><span class="sxs-lookup"><span data-stu-id="8790f-129">Prior to C# 8.0, local functions cannot include the `static` modifier.</span></span> <span data-ttu-id="8790f-130">Włączenie `static` słowa kluczowego generuje błąd kompilatora CS0106, "modyfikator" static "jest nieprawidłowy dla tego elementu".</span><span class="sxs-lookup"><span data-stu-id="8790f-130">Including the `static` keyword generates compiler error CS0106, "The modifier 'static' is not valid for this item."</span></span>

<span data-ttu-id="8790f-131">Ponadto atrybuty nie mogą być stosowane do funkcji lokalnej ani do jej parametrów i parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="8790f-131">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="8790f-132">W poniższym przykładzie zdefiniowano funkcję lokalną o nazwie `AppendPathSeparator` , która jest prywatna dla metody o nazwie `GetText` :</span><span class="sxs-lookup"><span data-stu-id="8790f-132">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="8790f-133">Lokalne funkcje i wyjątki</span><span class="sxs-lookup"><span data-stu-id="8790f-133">Local functions and exceptions</span></span>

<span data-ttu-id="8790f-134">Jedną z użytecznych funkcji lokalnych funkcji jest możliwość natychmiastowego zezwolenia na korzystanie z wyjątków.</span><span class="sxs-lookup"><span data-stu-id="8790f-134">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="8790f-135">W przypadku iteratorów metod wyjątki są nakierowane tylko wtedy, gdy zwracana sekwencja jest wyliczana, a nie podczas pobierania iteratora.</span><span class="sxs-lookup"><span data-stu-id="8790f-135">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="8790f-136">W przypadku metod asynchronicznych wszystkie wyjątki zgłoszone w metodzie asynchronicznej są zaobserwowane, gdy zwracane zadanie jest oczekiwane.</span><span class="sxs-lookup"><span data-stu-id="8790f-136">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="8790f-137">W poniższym przykładzie zdefiniowano `OddSequence` metodę, która wylicza liczby nieparzyste między określonym zakresem.</span><span class="sxs-lookup"><span data-stu-id="8790f-137">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="8790f-138">Ponieważ przekazuje liczbę większą niż 100 do `OddSequence` metody Enumerator, metoda zgłasza <xref:System.ArgumentOutOfRangeException> .</span><span class="sxs-lookup"><span data-stu-id="8790f-138">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="8790f-139">Ponieważ dane wyjściowe z przykładu pokazują, powierzchnie wyjątków tylko w przypadku iteracji liczby, a nie podczas pobierania modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="8790f-139">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="8790f-140">Zamiast tego można zgłosić wyjątek podczas sprawdzania poprawności i przed pobraniem iteratora, zwracając iterator z funkcji lokalnej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8790f-140">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="8790f-141">Funkcji lokalnych można używać w podobny sposób, aby obsługiwać wyjątki poza operacją asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="8790f-141">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="8790f-142">Zwykle wyjątki zgłoszone w metodzie asynchronicznej wymagają sprawdzenia wyjątków wewnętrznych <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="8790f-142">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="8790f-143">Funkcje lokalne umożliwiają szybkie i niepowodzenie wykonywania kodu oraz umożliwiają synchroniczną i zaobserwowany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="8790f-143">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="8790f-144">W poniższym przykładzie zastosowano metodę asynchroniczną o nazwie `GetMultipleAsync` do pauzy przez określoną liczbę sekund i zwracają wartość, która jest losowo wielokrotnością tej liczby sekund.</span><span class="sxs-lookup"><span data-stu-id="8790f-144">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="8790f-145">Maksymalne opóźnienie wynosi 5 sekund; <xref:System.ArgumentOutOfRangeException>wyniki, jeśli wartość jest większa niż 5.</span><span class="sxs-lookup"><span data-stu-id="8790f-145">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="8790f-146">Jak pokazano na poniższym przykładzie, wyjątek, który jest generowany, gdy wartość 6 jest przekazana do `GetMultipleAsync` metody jest opakowany w <xref:System.AggregateException> po `GetMultipleAsync` rozpoczęciu wykonywania metody.</span><span class="sxs-lookup"><span data-stu-id="8790f-146">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="8790f-147">Podobnie jak w iteratorze metody, możemy resłużyć kod z tego przykładu, aby przeprowadzić walidację przed wywołaniem metody asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="8790f-147">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="8790f-148">Jak pokazano na poniższym przykładzie, <xref:System.ArgumentOutOfRangeException> nie jest opakowany w <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="8790f-148">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="8790f-149">Funkcje lokalne a wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="8790f-149">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="8790f-150">Na pierwszy rzut oka funkcje lokalne i [wyrażenia lambda](../statements-expressions-operators/lambda-expressions.md) są bardzo podobne.</span><span class="sxs-lookup"><span data-stu-id="8790f-150">At first glance, local functions and [lambda expressions](../statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="8790f-151">W wielu przypadkach wybór między wyrażeniami lambda i funkcjami lokalnymi jest kwestią stylu i preferencji osobistych.</span><span class="sxs-lookup"><span data-stu-id="8790f-151">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="8790f-152">Istnieją jednak rzeczywiste różnice w tym, gdzie można korzystać z jednej z nich lub drugiej.</span><span class="sxs-lookup"><span data-stu-id="8790f-152">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="8790f-153">Sprawdźmy różnice między funkcją lokalną a implementacją wyrażenia lambda algorytmu silnia.</span><span class="sxs-lookup"><span data-stu-id="8790f-153">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="8790f-154">Pierwsza wersja przy użyciu funkcji lokalnej:</span><span class="sxs-lookup"><span data-stu-id="8790f-154">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="8790f-155">Kontrast tej implementacji z wersją, która używa wyrażeń lambda:</span><span class="sxs-lookup"><span data-stu-id="8790f-155">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="8790f-156">Funkcje lokalne mają nazwy.</span><span class="sxs-lookup"><span data-stu-id="8790f-156">The local functions have names.</span></span> <span data-ttu-id="8790f-157">Wyrażenia lambda są metodami anonimowymi przypisanymi do zmiennych, które są `Func` lub `Action` typami.</span><span class="sxs-lookup"><span data-stu-id="8790f-157">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="8790f-158">Gdy deklarujesz funkcję lokalną, typy argumentów i typ zwracany są częścią deklaracji funkcji.</span><span class="sxs-lookup"><span data-stu-id="8790f-158">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="8790f-159">Zamiast być częścią treści wyrażenia lambda, typy argumentów i typ zwracany są częścią deklaracji typu zmiennej wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="8790f-159">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="8790f-160">Te dwie różnice mogą spowodować wyraźniejszy kod.</span><span class="sxs-lookup"><span data-stu-id="8790f-160">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="8790f-161">Funkcje lokalne mają różne reguły dla określonego przypisania niż wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="8790f-161">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="8790f-162">Deklaracja funkcji lokalnej może być przywoływana z dowolnego miejsca w kodzie, w którym znajduje się w zakresie.</span><span class="sxs-lookup"><span data-stu-id="8790f-162">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="8790f-163">Wyrażenie lambda musi być przypisane do zmiennej delegata, zanim będzie można uzyskać do niej dostęp (lub wywołać za pomocą delegata odwołującego się do wyrażenia lambda).</span><span class="sxs-lookup"><span data-stu-id="8790f-163">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="8790f-164">Należy zauważyć, że wersja używająca wyrażenia lambda musi deklarować i inicjować wyrażenie lambda `nthFactorial` przed jego zdefiniowaniem.</span><span class="sxs-lookup"><span data-stu-id="8790f-164">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="8790f-165">Nie powoduje to błędu czasu kompilacji dla odwołania `nthFactorial` przed przypisaniem.</span><span class="sxs-lookup"><span data-stu-id="8790f-165">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="8790f-166">Różnice te oznaczają, że algorytmy cykliczne są łatwiejsze do tworzenia przy użyciu funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="8790f-166">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="8790f-167">Można zadeklarować i zdefiniować funkcję lokalną, która wywołuje samą siebie.</span><span class="sxs-lookup"><span data-stu-id="8790f-167">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="8790f-168">Wyrażenia lambda muszą być zadeklarowane i przypisane do wartości domyślnej przed ponownym przypisaniem do treści, która odwołuje się do tego samego wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="8790f-168">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="8790f-169">Określone reguły przypisywania mają wpływ na wszystkie zmienne, które są przechwytywane przez funkcję lokalną lub wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="8790f-169">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="8790f-170">Zarówno funkcja lokalna, jak i reguły wyrażenia lambda wymagają, aby wszystkie przechwycone zmienne były ostatecznie przypisane w punkcie, gdy funkcja lokalna lub wyrażenie lambda są konwertowane na delegata.</span><span class="sxs-lookup"><span data-stu-id="8790f-170">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="8790f-171">Różnica polega na tym, że wyrażenia lambda są konwertowane na delegatów po ich zadeklarowaniu.</span><span class="sxs-lookup"><span data-stu-id="8790f-171">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="8790f-172">Funkcja lokalna jest konwertowana na delegatów tylko wtedy, gdy jest używana jako delegat.</span><span class="sxs-lookup"><span data-stu-id="8790f-172">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="8790f-173">Jeśli zadeklarujesz funkcję lokalną i odwołujesz się do niej tylko przez wywołanie jej jako metody, nie zostanie ona przekonwertowana na delegata.</span><span class="sxs-lookup"><span data-stu-id="8790f-173">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="8790f-174">Ta reguła umożliwia zadeklarować funkcję lokalną w dowolnej wygodnej lokalizacji w jej zasięgu.</span><span class="sxs-lookup"><span data-stu-id="8790f-174">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="8790f-175">Często deklaruje funkcje lokalne na końcu metody nadrzędnej po dowolnych instrukcjach Return.</span><span class="sxs-lookup"><span data-stu-id="8790f-175">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="8790f-176">Po trzecie kompilator może wykonać analizę statyczną, która umożliwia lokalne funkcje, aby ostatecznie przypisywać przechwycone zmienne w zakresie otaczającym.</span><span class="sxs-lookup"><span data-stu-id="8790f-176">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="8790f-177">Rozważmy następujący przykład:</span><span class="sxs-lookup"><span data-stu-id="8790f-177">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="8790f-178">Kompilator może określić, że jest on `LocalFunction` przypisywany, `y` gdy jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="8790f-178">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="8790f-179">Ponieważ `LocalFunction` jest wywoływana przed `return` instrukcją, `y` jest ostatecznie przypisana do `return` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="8790f-179">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="8790f-180">Analiza, która umożliwia przykładową analizę, włącza czwartą różnicę.</span><span class="sxs-lookup"><span data-stu-id="8790f-180">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="8790f-181">W zależności od ich użycia funkcje lokalne mogą uniknąć przydziałów sterty, które są zawsze niezbędne dla wyrażeń lambda.</span><span class="sxs-lookup"><span data-stu-id="8790f-181">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="8790f-182">Jeśli funkcja lokalna nigdy nie jest konwertowana na delegata, a żadna ze zmiennych przechwyconych przez funkcję lokalną nie zostanie przechwycona przez inne wyrażenia lambda lub funkcje lokalne, które są konwertowane na delegatów, kompilator może uniknąć przydziałów sterty.</span><span class="sxs-lookup"><span data-stu-id="8790f-182">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="8790f-183">Rozważmy ten przykład asynchroniczny:</span><span class="sxs-lookup"><span data-stu-id="8790f-183">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="8790f-184">Zamknięcie tego wyrażenia lambda zawiera `address` `index` zmienne, i `name` .</span><span class="sxs-lookup"><span data-stu-id="8790f-184">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="8790f-185">W przypadku funkcji lokalnych obiekt implementujący zamknięcie może być `struct` typem.</span><span class="sxs-lookup"><span data-stu-id="8790f-185">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="8790f-186">Ten typ struktury zostałby przesłany przez odwołanie do funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="8790f-186">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="8790f-187">Różnica w implementacji spowodowałaby zapisanie alokacji.</span><span class="sxs-lookup"><span data-stu-id="8790f-187">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="8790f-188">Wystąpienie niezbędne dla wyrażeń lambda oznacza dodatkowe alokacje pamięci, które mogą być czynnikiem wydajności w ścieżkach kodu o kluczowym znaczeniu.</span><span class="sxs-lookup"><span data-stu-id="8790f-188">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="8790f-189">Funkcja lokalna nie wiąże się z tym obciążeniem.</span><span class="sxs-lookup"><span data-stu-id="8790f-189">Local functions do not incur this overhead.</span></span> <span data-ttu-id="8790f-190">W powyższym przykładzie wersja funkcji lokalnych ma 2 mniejsze alokacje niż wersja wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="8790f-190">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="8790f-191">Funkcja lokalna równoważna tej metody używa również klasy do zamykania.</span><span class="sxs-lookup"><span data-stu-id="8790f-191">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="8790f-192">Czy zamknięcie funkcji lokalnej jest zaimplementowane jako `class` `struct` szczegóły implementacji.</span><span class="sxs-lookup"><span data-stu-id="8790f-192">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="8790f-193">Funkcja lokalna może używać `struct` wyrażenia lambda, które zawsze będzie używać `class` .</span><span class="sxs-lookup"><span data-stu-id="8790f-193">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="8790f-194">Jedną z końcowych zalet nie pokazanych w tym przykładzie jest to, że funkcje lokalne można zaimplementować jako Iteratory, używając `yield return` składni w celu utworzenia sekwencji wartości.</span><span class="sxs-lookup"><span data-stu-id="8790f-194">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="8790f-195">`yield return`Instrukcja jest niedozwolona w wyrażeniach lambda.</span><span class="sxs-lookup"><span data-stu-id="8790f-195">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="8790f-196">Podczas gdy funkcje lokalne mogą wydawać się nadmiarowe w wyrażeniach lambda, są one w rzeczywistości wykorzystywane do różnych celów i mają różne zastosowania.</span><span class="sxs-lookup"><span data-stu-id="8790f-196">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="8790f-197">Funkcje lokalne są wydajniejsze w przypadku, gdy chcesz napisać funkcję, która jest wywoływana tylko z kontekstu innej metody.</span><span class="sxs-lookup"><span data-stu-id="8790f-197">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="8790f-198">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="8790f-198">See also</span></span>

- [<span data-ttu-id="8790f-199">Metody</span><span class="sxs-lookup"><span data-stu-id="8790f-199">Methods</span></span>](methods.md)
