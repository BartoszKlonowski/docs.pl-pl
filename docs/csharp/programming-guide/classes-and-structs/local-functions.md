---
title: Funkcje lokalne — Przewodnik programowania w języku C#
description: Funkcje lokalne w języku C# to metody prywatne, które są zagnieżdżone w innym elemencie członkowskim i mogą być wywoływane z ich składowych.
ms.date: 10/16/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 75accda2e40443073274ece4d8964c13a0945dad
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332903"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="da2ac-103">Funkcje lokalne (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="da2ac-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="da2ac-104">Począwszy od języka C# 7,0, C# obsługuje *funkcje lokalne*.</span><span class="sxs-lookup"><span data-stu-id="da2ac-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="da2ac-105">Funkcje lokalne są prywatnymi metodami typu, które są zagnieżdżone w innym elemencie członkowskim.</span><span class="sxs-lookup"><span data-stu-id="da2ac-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="da2ac-106">Mogą być wywoływane tylko z ich składowych.</span><span class="sxs-lookup"><span data-stu-id="da2ac-106">They can only be called from their containing member.</span></span> <span data-ttu-id="da2ac-107">Funkcje lokalne można zadeklarować w i wywołać z:</span><span class="sxs-lookup"><span data-stu-id="da2ac-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="da2ac-108">Metody, zwłaszcza metody iteratorów i metody asynchroniczne</span><span class="sxs-lookup"><span data-stu-id="da2ac-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="da2ac-109">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="da2ac-109">Constructors</span></span>
- <span data-ttu-id="da2ac-110">Metody dostępu do właściwości</span><span class="sxs-lookup"><span data-stu-id="da2ac-110">Property accessors</span></span>
- <span data-ttu-id="da2ac-111">Metody dostępu zdarzeń</span><span class="sxs-lookup"><span data-stu-id="da2ac-111">Event accessors</span></span>
- <span data-ttu-id="da2ac-112">Metody anonimowe</span><span class="sxs-lookup"><span data-stu-id="da2ac-112">Anonymous methods</span></span>
- <span data-ttu-id="da2ac-113">Wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="da2ac-113">Lambda expressions</span></span>
- <span data-ttu-id="da2ac-114">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="da2ac-114">Finalizers</span></span>
- <span data-ttu-id="da2ac-115">Inne funkcje lokalne</span><span class="sxs-lookup"><span data-stu-id="da2ac-115">Other local functions</span></span>

<span data-ttu-id="da2ac-116">Jednak funkcji lokalnych nie można deklarować wewnątrz elementu członkowskiego będącego w posiadaniu wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="da2ac-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="da2ac-117">W niektórych przypadkach można użyć wyrażenia lambda, aby zaimplementować funkcje również obsługiwane przez funkcję lokalną.</span><span class="sxs-lookup"><span data-stu-id="da2ac-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="da2ac-118">Aby zapoznać się z porównaniem, zobacz [funkcje lokalne a wyrażenia lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="da2ac-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="da2ac-119">Funkcje lokalne sprawiają, że zamiar kodu jest przejrzysty.</span><span class="sxs-lookup"><span data-stu-id="da2ac-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="da2ac-120">Każda osoba odczytująca kod może zobaczyć, że metoda nie jest wywoływana z wyjątkiem metody zawierającej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="da2ac-121">W przypadku projektów zespołowych uniemożliwiają one również innym deweloperom błędne wywoływanie metody bezpośrednio z innych miejsc w klasie lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="da2ac-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="da2ac-122">Składnia funkcji lokalnych</span><span class="sxs-lookup"><span data-stu-id="da2ac-122">Local function syntax</span></span>

<span data-ttu-id="da2ac-123">Funkcja lokalna jest definiowana jako metoda zagnieżdżona wewnątrz składowej zawierającej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="da2ac-124">Jego definicja ma następującą składnię:</span><span class="sxs-lookup"><span data-stu-id="da2ac-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="da2ac-125">Można użyć następujących modyfikatorów z funkcją lokalną:</span><span class="sxs-lookup"><span data-stu-id="da2ac-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="da2ac-126">[`static`](../../language-reference/keywords/static.md) (w języku C# 8,0 i nowszych).</span><span class="sxs-lookup"><span data-stu-id="da2ac-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="da2ac-127">Statyczna funkcja lokalna nie może przechwycić lokalnych zmiennych lub stanu wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="da2ac-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="da2ac-128">[`extern`](../../language-reference/keywords/extern.md) (w języku C# 9,0 i nowszych).</span><span class="sxs-lookup"><span data-stu-id="da2ac-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="da2ac-129">Zewnętrzna funkcja lokalna musi być `static` .</span><span class="sxs-lookup"><span data-stu-id="da2ac-129">An external local function must be `static`.</span></span>

<span data-ttu-id="da2ac-130">Wszystkie zmienne lokalne, które są zdefiniowane w składowej zawierającej, łącznie z parametrami metody, są dostępne w niestatycznej funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="da2ac-131">W przeciwieństwie do definicji metody lokalnej definicja funkcji nie może zawierać modyfikatora dostępu do składowej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="da2ac-132">Ponieważ wszystkie funkcje lokalne są prywatne, łącznie z modyfikatorem dostępu, takim jak `private` słowo kluczowe, generuje błąd kompilatora CS0106 "modyfikator" Private "jest nieprawidłowy dla tego elementu".</span><span class="sxs-lookup"><span data-stu-id="da2ac-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="da2ac-133">W poniższym przykładzie zdefiniowano funkcję lokalną o nazwie `AppendPathSeparator` , która jest prywatna dla metody o nazwie `GetText` :</span><span class="sxs-lookup"><span data-stu-id="da2ac-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="da2ac-134">Począwszy od języka C# 9,0, można zastosować atrybuty do funkcji lokalnej, jej parametrów i parametrów typu, jak pokazano na poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="da2ac-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="da2ac-135">Poprzedni przykład używa [specjalnego atrybutu](../../language-reference/attributes/nullable-analysis.md) , aby pomóc kompilatorowi w analizie statycznej w kontekście dopuszczającym wartość null.</span><span class="sxs-lookup"><span data-stu-id="da2ac-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="da2ac-136">Lokalne funkcje i wyjątki</span><span class="sxs-lookup"><span data-stu-id="da2ac-136">Local functions and exceptions</span></span>

<span data-ttu-id="da2ac-137">Jedną z użytecznych funkcji lokalnych funkcji jest możliwość natychmiastowego zezwolenia na korzystanie z wyjątków.</span><span class="sxs-lookup"><span data-stu-id="da2ac-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="da2ac-138">W przypadku iteratorów metod wyjątki są nakierowane tylko wtedy, gdy zwracana sekwencja jest wyliczana, a nie podczas pobierania iteratora.</span><span class="sxs-lookup"><span data-stu-id="da2ac-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="da2ac-139">W przypadku metod asynchronicznych wszystkie wyjątki zgłoszone w metodzie asynchronicznej są zaobserwowane, gdy zwracane zadanie jest oczekiwane.</span><span class="sxs-lookup"><span data-stu-id="da2ac-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="da2ac-140">W poniższym przykładzie zdefiniowano `OddSequence` metodę, która wylicza liczby nieparzyste w określonym zakresie.</span><span class="sxs-lookup"><span data-stu-id="da2ac-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="da2ac-141">Ponieważ przekazuje liczbę większą niż 100 do `OddSequence` metody Enumerator, metoda zgłasza <xref:System.ArgumentOutOfRangeException> .</span><span class="sxs-lookup"><span data-stu-id="da2ac-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="da2ac-142">Ponieważ dane wyjściowe z przykładu pokazują, powierzchnie wyjątków tylko w przypadku iteracji liczby, a nie podczas pobierania modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="da2ac-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="da2ac-143">W przypadku umieszczenia logiki iteratora w funkcji lokalnej, wyjątki walidacji argumentów są generowane podczas pobierania modułu wyliczającego, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="da2ac-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

<span data-ttu-id="da2ac-144">Funkcji lokalnych można używać w podobny sposób z operacjami asynchronicznymi.</span><span class="sxs-lookup"><span data-stu-id="da2ac-144">You can use local functions in a similar way with asynchronous operations.</span></span> <span data-ttu-id="da2ac-145">Wyjątki zgłoszone na powierzchni metody asynchronicznej, gdy jest oczekiwane odpowiednie zadanie.</span><span class="sxs-lookup"><span data-stu-id="da2ac-145">Exceptions thrown in an async method surface when the corresponding task is awaited.</span></span> <span data-ttu-id="da2ac-146">Funkcje lokalne umożliwiają szybkie i niepowodzenie wykonywania kodu oraz umożliwiają synchroniczną i zaobserwowany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="da2ac-146">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="da2ac-147">W poniższym przykładzie zastosowano metodę asynchroniczną o nazwie `GetMultipleAsync` do pauzy przez określoną liczbę sekund i zwracają wartość, która jest losowo wielokrotnością tej liczby sekund.</span><span class="sxs-lookup"><span data-stu-id="da2ac-147">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="da2ac-148">Maksymalne opóźnienie wynosi 5 sekund; <xref:System.ArgumentOutOfRangeException> wyniki, jeśli wartość jest większa niż 5.</span><span class="sxs-lookup"><span data-stu-id="da2ac-148">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="da2ac-149">Jak pokazano na poniższym przykładzie, wyjątek, który jest generowany, gdy wartość 6 jest przekazana do `GetMultipleAsync` metody jest zaobserwowana tylko wtedy, gdy zadanie jest oczekiwane.</span><span class="sxs-lookup"><span data-stu-id="da2ac-149">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is observed only when the task is awaited.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

<span data-ttu-id="da2ac-150">Podobnie jak w przypadku iteratora metody można ponownie określić poprzedni przykład i umieścić kod operacji asynchronicznej w funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-150">Like with the method iterator, you can refactor the preceding example and put the code of asynchronous operation in a local function.</span></span> <span data-ttu-id="da2ac-151">Jak pokazano na poniższym przykładzie, zostanie zgłoszony, gdy <xref:System.ArgumentOutOfRangeException> tylko `GetMultiple` Metoda zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="da2ac-151">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is thrown as soon as the `GetMultiple` method is called.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="da2ac-152">Funkcje lokalne a wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="da2ac-152">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="da2ac-153">Na pierwszy rzut oka funkcje lokalne i [wyrażenia lambda](../../language-reference/operators/lambda-expressions.md) są bardzo podobne.</span><span class="sxs-lookup"><span data-stu-id="da2ac-153">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="da2ac-154">W wielu przypadkach wybór między wyrażeniami lambda i funkcjami lokalnymi jest kwestią stylu i preferencji osobistych.</span><span class="sxs-lookup"><span data-stu-id="da2ac-154">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="da2ac-155">Istnieją jednak rzeczywiste różnice w tym, gdzie można korzystać z jednej z nich lub drugiej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-155">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="da2ac-156">Sprawdźmy różnice między funkcją lokalną a implementacją wyrażenia lambda algorytmu silnia.</span><span class="sxs-lookup"><span data-stu-id="da2ac-156">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="da2ac-157">Oto wersja z użyciem funkcji lokalnej:</span><span class="sxs-lookup"><span data-stu-id="da2ac-157">Here's the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="da2ac-158">Ta wersja używa wyrażeń lambda:</span><span class="sxs-lookup"><span data-stu-id="da2ac-158">This version uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

### <a name="naming"></a><span data-ttu-id="da2ac-159">Nazewnictwo</span><span class="sxs-lookup"><span data-stu-id="da2ac-159">Naming</span></span>

<span data-ttu-id="da2ac-160">Funkcje lokalne są jawnie nazywane metodami podobnymi.</span><span class="sxs-lookup"><span data-stu-id="da2ac-160">Local functions are explicitly named like methods.</span></span> <span data-ttu-id="da2ac-161">Wyrażenia lambda to metody anonimowe i muszą być przypisane do zmiennych `delegate` typu, zazwyczaj obu `Action` lub `Func` typów.</span><span class="sxs-lookup"><span data-stu-id="da2ac-161">Lambda expressions are anonymous methods and need to be assigned to variables of a `delegate` type, typically either `Action` or `Func` types.</span></span> <span data-ttu-id="da2ac-162">Kiedy deklarujesz funkcję lokalną, proces przypomina pisanie normalnej metody; deklaruje zwracany typ i sygnaturę funkcji.</span><span class="sxs-lookup"><span data-stu-id="da2ac-162">When you declare a local function, the process is like writing a normal method; you declare a return type and a function signature.</span></span>

### <a name="function-signatures-and-lambda-expression-types"></a><span data-ttu-id="da2ac-163">Sygnatury funkcji i typy wyrażeń lambda</span><span class="sxs-lookup"><span data-stu-id="da2ac-163">Function signatures and lambda expression types</span></span>

<span data-ttu-id="da2ac-164">Wyrażenia lambda bazują na typie `Action` / `Func` zmiennej, do której są przypisane, aby określić argument i typy zwracane.</span><span class="sxs-lookup"><span data-stu-id="da2ac-164">Lambda expressions rely on the type of the `Action`/`Func` variable that they're assigned to determine the argument and return types.</span></span> <span data-ttu-id="da2ac-165">W funkcjach lokalnych, ponieważ składnia jest podobnie jak pisanie normalnej metody, typy argumentów i typ zwracany są już częścią deklaracji funkcji.</span><span class="sxs-lookup"><span data-stu-id="da2ac-165">In local functions, since the syntax is much like writing a normal method, argument types and return type are already part of the function declaration.</span></span>

### <a name="definite-assignment"></a><span data-ttu-id="da2ac-166">Przypisanie określone</span><span class="sxs-lookup"><span data-stu-id="da2ac-166">Definite assignment</span></span>

<span data-ttu-id="da2ac-167">Wyrażenia lambda są obiektami, które są zadeklarowane i przypisywane w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="da2ac-167">Lambda expressions are objects that are declared and assigned at runtime.</span></span> <span data-ttu-id="da2ac-168">Aby można było użyć wyrażenia lambda, musi ono być ostatecznie przypisane: `Action` / `Func` zmienna, do której zostanie przypisany, musi być zadeklarowana i wyrażenie lambda przypisane do niego.</span><span class="sxs-lookup"><span data-stu-id="da2ac-168">In order for a lambda expression to be used, it needs to be definitely assigned: the `Action`/`Func` variable that it will be assigned to must be declared and the lambda expression assigned to it.</span></span> <span data-ttu-id="da2ac-169">Należy zauważyć, że `LambdaFactorial` przed zdefiniowaniem należy zadeklarować i zainicjować wyrażenie lambda `nthFactorial` .</span><span class="sxs-lookup"><span data-stu-id="da2ac-169">Notice that `LambdaFactorial` must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="da2ac-170">Nie powoduje to błędu czasu kompilacji dla odwołania `nthFactorial` przed przypisaniem.</span><span class="sxs-lookup"><span data-stu-id="da2ac-170">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>

<span data-ttu-id="da2ac-171">Funkcje lokalne są definiowane w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="da2ac-171">Local functions are defined at compile time.</span></span> <span data-ttu-id="da2ac-172">Ponieważ nie są one przypisane do zmiennych, można odwoływać się do nich z dowolnego miejsca w kodzie, **w którym znajduje się w zakresie**; w pierwszym przykładzie `LocalFunctionFactorial` możemy zadeklarować funkcję lokalną powyżej lub poniżej `return` instrukcji i nie wyzwolić błędów kompilatora.</span><span class="sxs-lookup"><span data-stu-id="da2ac-172">As they're not assigned to variables, they can be referenced from any code location **where it is in scope**; in our first example `LocalFunctionFactorial`, we could declare our local function either above or below the `return` statement and not trigger any compiler errors.</span></span>

<span data-ttu-id="da2ac-173">Różnice te oznaczają, że algorytmy cykliczne są łatwiejsze do tworzenia przy użyciu funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="da2ac-173">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="da2ac-174">Można zadeklarować i zdefiniować funkcję lokalną, która wywołuje samą siebie.</span><span class="sxs-lookup"><span data-stu-id="da2ac-174">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="da2ac-175">Wyrażenia lambda muszą być zadeklarowane i przypisane do wartości domyślnej przed ponownym przypisaniem do treści, która odwołuje się do tego samego wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="da2ac-175">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

### <a name="implementation-as-a-delegate"></a><span data-ttu-id="da2ac-176">Implementacja jako delegat</span><span class="sxs-lookup"><span data-stu-id="da2ac-176">Implementation as a delegate</span></span>

<span data-ttu-id="da2ac-177">Wyrażenia lambda są konwertowane na delegatów, gdy są one deklarowane.</span><span class="sxs-lookup"><span data-stu-id="da2ac-177">Lambda expressions are converted to delegates when they're declared.</span></span> <span data-ttu-id="da2ac-178">Funkcje lokalne są bardziej elastyczne, ponieważ mogą być zapisywane jak tradycyjną metodę *lub* delegat.</span><span class="sxs-lookup"><span data-stu-id="da2ac-178">Local functions are more flexible in that they can be written like a traditional method *or* as a delegate.</span></span> <span data-ttu-id="da2ac-179">Funkcje lokalne są konwertowane na delegatów tylko wtedy, gdy są ***używane*** jako delegat.</span><span class="sxs-lookup"><span data-stu-id="da2ac-179">Local functions are only converted to delegates when ***used*** as a delegate.</span></span>

<span data-ttu-id="da2ac-180">Jeśli zadeklarujesz funkcję lokalną i odwołujesz się do niej tylko przez wywołanie jej jako metody, nie zostanie ona przekonwertowana na delegata.</span><span class="sxs-lookup"><span data-stu-id="da2ac-180">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span>

### <a name="variable-capture"></a><span data-ttu-id="da2ac-181">Przechwytywanie zmiennych</span><span class="sxs-lookup"><span data-stu-id="da2ac-181">Variable capture</span></span>

<span data-ttu-id="da2ac-182">Reguły o [nieograniczonym przypisaniu](../../../../_csharplang/spec/variables.md#definite-assignment) wpływają również na wszystkie zmienne, które są przechwytywane przez funkcję lokalną lub wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="da2ac-182">The rules of [definite assignment](../../../../_csharplang/spec/variables.md#definite-assignment) also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="da2ac-183">Kompilator może wykonać analizę statyczną, która umożliwia lokalne funkcje, aby ostatecznie przypisywać przechwycone zmienne w zakresie otaczającym.</span><span class="sxs-lookup"><span data-stu-id="da2ac-183">The compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="da2ac-184">Rozważ taki przykład:</span><span class="sxs-lookup"><span data-stu-id="da2ac-184">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="da2ac-185">Kompilator może określić, że jest on `LocalFunction` przypisywany, `y` gdy jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="da2ac-185">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="da2ac-186">Ponieważ `LocalFunction` jest wywoływana przed `return` instrukcją, `y` jest ostatecznie przypisana do `return` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="da2ac-186">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="da2ac-187">Należy pamiętać, że gdy funkcja lokalna przechwytuje zmienne w otaczającym zakresie, funkcja lokalna jest implementowana jako typ delegata.</span><span class="sxs-lookup"><span data-stu-id="da2ac-187">Note that when a local function captures variables in the enclosing scope, the local function is implemented as a delegate type.</span></span>

### <a name="heap-allocations"></a><span data-ttu-id="da2ac-188">Alokacje sterty</span><span class="sxs-lookup"><span data-stu-id="da2ac-188">Heap allocations</span></span>

<span data-ttu-id="da2ac-189">W zależności od ich użycia funkcje lokalne mogą uniknąć przydziałów sterty, które są zawsze niezbędne dla wyrażeń lambda.</span><span class="sxs-lookup"><span data-stu-id="da2ac-189">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="da2ac-190">Jeśli funkcja lokalna nigdy nie jest konwertowana na delegata, a żadna ze zmiennych przechwyconych przez funkcję lokalną nie zostanie przechwycona przez inne wyrażenia lambda lub funkcje lokalne, które są konwertowane na delegatów, kompilator może uniknąć przydziałów sterty.</span><span class="sxs-lookup"><span data-stu-id="da2ac-190">If a local function is never converted to a delegate, and none of the variables captured by the local function are captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="da2ac-191">Rozważmy ten przykład asynchroniczny:</span><span class="sxs-lookup"><span data-stu-id="da2ac-191">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="da2ac-192">Zamknięcie tego wyrażenia lambda zawiera `address` `index` zmienne, i `name` .</span><span class="sxs-lookup"><span data-stu-id="da2ac-192">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="da2ac-193">W przypadku funkcji lokalnych obiekt implementujący zamknięcie może być `struct` typem.</span><span class="sxs-lookup"><span data-stu-id="da2ac-193">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="da2ac-194">Ten typ struktury zostałby przesłany przez odwołanie do funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-194">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="da2ac-195">Różnica w implementacji spowodowałaby zapisanie alokacji.</span><span class="sxs-lookup"><span data-stu-id="da2ac-195">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="da2ac-196">Wystąpienie niezbędne dla wyrażeń lambda oznacza dodatkowe alokacje pamięci, które mogą być czynnikiem wydajności w ścieżkach kodu o kluczowym znaczeniu.</span><span class="sxs-lookup"><span data-stu-id="da2ac-196">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="da2ac-197">Funkcja lokalna nie wiąże się z tym obciążeniem.</span><span class="sxs-lookup"><span data-stu-id="da2ac-197">Local functions do not incur this overhead.</span></span> <span data-ttu-id="da2ac-198">W powyższym przykładzie wersja funkcji lokalnych ma dwa mniejsze alokacje niż wersja wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="da2ac-198">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

<span data-ttu-id="da2ac-199">Jeśli wiesz, że funkcja lokalna nie zostanie przekonwertowana na delegata i żadna ze zmiennych przechwyconych przez nią nie zostanie przechwycona przez inne wyrażenia lambda lub funkcje lokalne, które są konwertowane na Delegaty, możesz zagwarantować, że funkcja lokalna nie zostanie przydzielone na stercie przez zadeklarowanie jej jako `static` funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="da2ac-199">If you know that your local function won't be converted to a delegate and none of the variables captured by it are captured by other lambdas or local functions that are converted to delegates, you can guarantee that your local function avoids being allocated on the heap by declaring it as a `static` local function.</span></span> <span data-ttu-id="da2ac-200">Należy pamiętać, że ta funkcja jest dostępna w języku C# 8,0 i nowszych.</span><span class="sxs-lookup"><span data-stu-id="da2ac-200">Note that this feature is available in C# 8.0 and newer.</span></span>

> [!NOTE]
> <span data-ttu-id="da2ac-201">Funkcja lokalna równoważna tej metody używa również klasy do zamykania.</span><span class="sxs-lookup"><span data-stu-id="da2ac-201">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="da2ac-202">Czy zamknięcie funkcji lokalnej jest zaimplementowane jako `class` `struct` szczegóły implementacji.</span><span class="sxs-lookup"><span data-stu-id="da2ac-202">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="da2ac-203">Funkcja lokalna może używać `struct` wyrażenia lambda, które zawsze będzie używać `class` .</span><span class="sxs-lookup"><span data-stu-id="da2ac-203">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

### <a name="usage-of-the-yield-keyword"></a><span data-ttu-id="da2ac-204">Użycie `yield` słowa kluczowego</span><span class="sxs-lookup"><span data-stu-id="da2ac-204">Usage of the `yield` keyword</span></span>

<span data-ttu-id="da2ac-205">Jedną z końcowych zalet nie pokazanych w tym przykładzie jest to, że funkcje lokalne można zaimplementować jako Iteratory, używając `yield return` składni w celu utworzenia sekwencji wartości.</span><span class="sxs-lookup"><span data-stu-id="da2ac-205">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="YieldReturn" :::

<span data-ttu-id="da2ac-206">`yield return`Instrukcja jest niedozwolona w wyrażeniach lambda, zobacz [błąd kompilatora CS1621](../../misc/cs1621.md).</span><span class="sxs-lookup"><span data-stu-id="da2ac-206">The `yield return` statement is not allowed in lambda expressions, see [compiler error CS1621](../../misc/cs1621.md).</span></span>

<span data-ttu-id="da2ac-207">Podczas gdy funkcje lokalne mogą wydawać się nadmiarowe w wyrażeniach lambda, są one w rzeczywistości wykorzystywane do różnych celów i mają różne zastosowania.</span><span class="sxs-lookup"><span data-stu-id="da2ac-207">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="da2ac-208">Funkcje lokalne są wydajniejsze w przypadku, gdy chcesz napisać funkcję, która jest wywoływana tylko z kontekstu innej metody.</span><span class="sxs-lookup"><span data-stu-id="da2ac-208">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="da2ac-209">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="da2ac-209">See also</span></span>

- [<span data-ttu-id="da2ac-210">Metody</span><span class="sxs-lookup"><span data-stu-id="da2ac-210">Methods</span></span>](methods.md)
