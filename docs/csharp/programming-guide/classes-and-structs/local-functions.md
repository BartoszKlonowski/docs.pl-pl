---
title: Funkcje lokalne — przewodnik programowania języka C#
ms.date: 06/14/2017
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 200fbd097b7c71a1cd392d62622955528a80fd66
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2020
ms.locfileid: "82102947"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="7f4ac-102">Funkcje lokalne (Przewodnik programowania języka C#)</span><span class="sxs-lookup"><span data-stu-id="7f4ac-102">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="7f4ac-103">Począwszy od języka C# 7.0, C# obsługuje *funkcje lokalne*.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-103">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="7f4ac-104">Funkcje lokalne są metody prywatne typu, które są zagnieżdżone w innym elementem członkowskim.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-104">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="7f4ac-105">Można je wywołać tylko od ich zawierającego członka.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-105">They can only be called from their containing member.</span></span> <span data-ttu-id="7f4ac-106">Funkcje lokalne mogą być zadeklarowane i wywoływane z:</span><span class="sxs-lookup"><span data-stu-id="7f4ac-106">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="7f4ac-107">Metody, zwłaszcza metody iteratora i metody asynchronizowania</span><span class="sxs-lookup"><span data-stu-id="7f4ac-107">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="7f4ac-108">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="7f4ac-108">Constructors</span></span>
- <span data-ttu-id="7f4ac-109">Akcesory</span><span class="sxs-lookup"><span data-stu-id="7f4ac-109">Property accessors</span></span>
- <span data-ttu-id="7f4ac-110">Akcesory zdarzeń</span><span class="sxs-lookup"><span data-stu-id="7f4ac-110">Event accessors</span></span>
- <span data-ttu-id="7f4ac-111">Metody anonimowe</span><span class="sxs-lookup"><span data-stu-id="7f4ac-111">Anonymous methods</span></span>
- <span data-ttu-id="7f4ac-112">Wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="7f4ac-112">Lambda expressions</span></span>
- <span data-ttu-id="7f4ac-113">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="7f4ac-113">Finalizers</span></span>
- <span data-ttu-id="7f4ac-114">Inne funkcje lokalne</span><span class="sxs-lookup"><span data-stu-id="7f4ac-114">Other local functions</span></span>

<span data-ttu-id="7f4ac-115">Jednak funkcje lokalne nie można zadeklarować wewnątrz elementu członkowskiego wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-115">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="7f4ac-116">W niektórych przypadkach można użyć wyrażenia lambda do zaimplementowania funkcji obsługiwanych również przez funkcję lokalną.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-116">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="7f4ac-117">Dla porównania zobacz [Funkcje lokalne a wyrażenia lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="7f4ac-117">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="7f4ac-118">Funkcje lokalne sprawiają, że intencja kodu jest wyczyszczona.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-118">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="7f4ac-119">Każdy, kto czyta kod może zobaczyć, że metoda nie jest wywoływana z wyjątkiem metody zawierającej.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-119">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="7f4ac-120">W przypadku projektów zespołowych uniemożliwiają one innemu deweloperowi omyłkowo wywołanie metody bezpośrednio z innego miejsca w klasie lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-120">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="7f4ac-121">Składnia funkcji lokalnej</span><span class="sxs-lookup"><span data-stu-id="7f4ac-121">Local function syntax</span></span>

<span data-ttu-id="7f4ac-122">Funkcja lokalna jest zdefiniowana jako metoda zagnieżdżona wewnątrz elementu członkowskiego zawierającego.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-122">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="7f4ac-123">Jego definicja ma następującą składnię:</span><span class="sxs-lookup"><span data-stu-id="7f4ac-123">Its definition has the following syntax:</span></span>

```csharp
<modifiers: async | unsafe> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="7f4ac-124">Funkcje lokalne można użyć [modyfikatorów asynchroników](../../language-reference/keywords/async.md) i [niebezpiecznych.](../../language-reference/keywords/unsafe.md)</span><span class="sxs-lookup"><span data-stu-id="7f4ac-124">Local functions can use the [async](../../language-reference/keywords/async.md) and [unsafe](../../language-reference/keywords/unsafe.md) modifiers.</span></span>

<span data-ttu-id="7f4ac-125">Należy zauważyć, że wszystkie zmienne lokalne, które są zdefiniowane w element członkowski zawierający, w tym jego parametry metody, są dostępne w funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-125">Note that all local variables that are defined in the containing member, including its method parameters, are accessible in the local function.</span></span>

<span data-ttu-id="7f4ac-126">W przeciwieństwie do definicji metody, definicja funkcji lokalnej nie może zawierać modyfikatora dostępu elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-126">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="7f4ac-127">Ponieważ wszystkie funkcje lokalne są prywatne, w `private` tym modyfikator dostępu, takich jak słowo kluczowe, generuje błąd kompilatora CS0106, "Modyfikator 'private' nie jest prawidłowy dla tego elementu."</span><span class="sxs-lookup"><span data-stu-id="7f4ac-127">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

> [!NOTE]
> <span data-ttu-id="7f4ac-128">Przed C# 8.0 funkcje lokalne `static` nie mogą zawierać modyfikatora.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-128">Prior to C# 8.0, local functions cannot include the `static` modifier.</span></span> <span data-ttu-id="7f4ac-129">W `static` tym słowo kluczowe generuje błąd kompilatora CS0106, "Modyfikator 'statyczny' nie jest prawidłowy dla tego elementu."</span><span class="sxs-lookup"><span data-stu-id="7f4ac-129">Including the `static` keyword generates compiler error CS0106, "The modifier 'static' is not valid for this item."</span></span>

<span data-ttu-id="7f4ac-130">Ponadto atrybuty nie mogą być stosowane do funkcji lokalnej lub do jej parametrów i parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-130">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="7f4ac-131">Poniższy przykład definiuje funkcję `AppendPathSeparator` lokalną o nazwie, `GetText`która jest prywatna dla metody o nazwie:</span><span class="sxs-lookup"><span data-stu-id="7f4ac-131">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="7f4ac-132">Funkcje lokalne i wyjątki</span><span class="sxs-lookup"><span data-stu-id="7f4ac-132">Local functions and exceptions</span></span>

<span data-ttu-id="7f4ac-133">Jedną z przydatnych funkcji funkcji lokalnych jest to, że mogą one zezwalać na wyjątki do powierzchni natychmiast.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-133">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="7f4ac-134">W przypadku iteratorów metody wyjątki są wyświetlane tylko wtedy, gdy zwracana sekwencja jest wyliczona, a nie podczas pobierania iteratora.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-134">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="7f4ac-135">Dla metod asynchronicznych wszelkie wyjątki zgłaszane w metodzie asynchronicznego są obserwowane, gdy zwracane zadanie jest oczekiwane.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-135">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="7f4ac-136">Poniższy przykład definiuje `OddSequence` metodę, która wylicza liczby nieparzyste między określonym zakresem.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-136">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="7f4ac-137">Ponieważ przekazuje liczbę większą niż 100 do metody `OddSequence` wyliczacza, metoda zgłasza . <xref:System.ArgumentOutOfRangeException></span><span class="sxs-lookup"><span data-stu-id="7f4ac-137">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="7f4ac-138">Jak pokazano na wyjściu z przykładu, wyjątek jest wyświetlany tylko wtedy, gdy iteracji liczb, a nie podczas pobierania wylicznika.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-138">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="7f4ac-139">Zamiast tego można zgłosić wyjątek podczas wykonywania sprawdzania poprawności i przed pobraniem iteratora, zwracając iterator z funkcji lokalnej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-139">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="7f4ac-140">Funkcje lokalne mogą być używane w podobny sposób do obsługi wyjątków poza operacją asynchronizacyjną.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-140">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="7f4ac-141">Zwykle wyjątki zgłaszane w metodzie asynchronizowej wymagają zbadania <xref:System.AggregateException>wewnętrznych wyjątków .</span><span class="sxs-lookup"><span data-stu-id="7f4ac-141">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="7f4ac-142">Funkcje lokalne umożliwiają kod szybko zakończyć się niepowodzeniem i zezwalaj na wyjątek zarówno zgłaszane i obserwowane synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-142">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="7f4ac-143">W poniższym przykładzie użyto metody `GetMultipleAsync` asynchroniczne o nazwie do wstrzymania dla określonej liczby sekund i zwracanie wartości, która jest losową wielokrotnością tej liczby sekund.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-143">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="7f4ac-144">Maksymalne opóźnienie wynosi 5 sekund; wyniki, <xref:System.ArgumentOutOfRangeException> jeśli wartość jest większa niż 5.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-144">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="7f4ac-145">Jak pokazano w poniższym przykładzie, wyjątek, który jest `GetMultipleAsync` zgłaszany, gdy <xref:System.AggregateException> wartość `GetMultipleAsync` 6 jest przekazywana do metody jest zawijany w po rozpoczęciu wykonywania metody.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-145">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="7f4ac-146">Podobnie jak w przypadku iteratora metody, możemy refaktoryzację kodu z tego przykładu, aby wykonać sprawdzanie poprawności przed wywołaniem metody asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-146">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="7f4ac-147">Jak pokazano na wyjściu z <xref:System.ArgumentOutOfRangeException> poniższego przykładu, nie jest zawijany w . <xref:System.AggregateException></span><span class="sxs-lookup"><span data-stu-id="7f4ac-147">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="7f4ac-148">Funkcje lokalne a wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="7f4ac-148">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="7f4ac-149">Na pierwszy rzut oka funkcje lokalne i [wyrażenia lambda](../statements-expressions-operators/lambda-expressions.md) są bardzo podobne.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-149">At first glance, local functions and [lambda expressions](../statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="7f4ac-150">W wielu przypadkach wybór między używaniem wyrażeń lambda a funkcjami lokalnymi jest kwestią stylu i osobistych preferencji.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-150">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="7f4ac-151">Istnieją jednak rzeczywiste różnice w tym, gdzie można użyć jednego lub drugiego, że należy pamiętać.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-151">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="7f4ac-152">Przyjrzyjmy się różnice między funkcji lokalnej i implementacji wyrażenia lambda algorytmu faktorialnego.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-152">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="7f4ac-153">Najpierw wersja przy użyciu funkcji lokalnej:</span><span class="sxs-lookup"><span data-stu-id="7f4ac-153">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="7f4ac-154">Kontrast tej implementacji z wersją, która używa wyrażeń lambda:</span><span class="sxs-lookup"><span data-stu-id="7f4ac-154">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="7f4ac-155">Funkcje lokalne mają nazwy.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-155">The local functions have names.</span></span> <span data-ttu-id="7f4ac-156">Wyrażenia lambda są metody anonimowe, które są `Func` przypisane do zmiennych, które są lub `Action` typy.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-156">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="7f4ac-157">Podczas deklarowania funkcji lokalnej typy argumentów i typ zwracany są częścią deklaracji funkcji.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-157">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="7f4ac-158">Zamiast być częścią treści wyrażenia lambda, typy argumentów i typ zwracany są częścią deklaracji typu zmiennego wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-158">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="7f4ac-159">Te dwie różnice mogą spowodować jaśniejszy kod.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-159">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="7f4ac-160">Funkcje lokalne mają różne reguły dla określonego przypisania niż wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-160">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="7f4ac-161">Do deklaracji funkcji lokalnej można odwoływać się z dowolnej lokalizacji kodu, w której znajduje się w zakresie.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-161">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="7f4ac-162">Wyrażenie lambda musi być przypisane do zmiennej delegata, zanim będzie dostępny (lub wywoływane za pośrednictwem pełnomocnika odwołującego się do wyrażenia lambda).</span><span class="sxs-lookup"><span data-stu-id="7f4ac-162">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="7f4ac-163">Należy zauważyć, że wersja przy użyciu wyrażenia lambda musi `nthFactorial` zadeklarować i zainicjować wyrażenie lambda przed zdefiniowaniem go.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-163">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="7f4ac-164">Nie powoduje to błąd czasu kompilacji `nthFactorial` do odwoływania się przed przypisaniem go.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-164">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="7f4ac-165">Różnice te oznaczają, że algorytmy cykliczne są łatwiejsze do tworzenia przy użyciu funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-165">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="7f4ac-166">Można zadeklarować i zdefiniować funkcję lokalną, która wywołuje się.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-166">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="7f4ac-167">Wyrażenia Lambda muszą być zadeklarowane i przypisane wartość domyślną, zanim mogą być ponownie przypisane do treści, która odwołuje się do tego samego wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-167">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="7f4ac-168">Reguły określonego przypisania mają również wpływ na wszystkie zmienne, które są przechwytywane przez funkcję lokalną lub wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-168">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="7f4ac-169">Zarówno funkcje lokalne, jak i reguły wyrażenia lambda wymagają, aby wszystkie przechwycone zmienne były zdecydowanie przypisywane w punkcie, gdy funkcja lokalna lub wyrażenie lambda jest konwertowane na pełnomocnika.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-169">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="7f4ac-170">Różnica polega na tym, że wyrażenia lambda są konwertowane na delegatów, gdy są one zadeklarowane.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-170">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="7f4ac-171">Funkcje lokalne są konwertowane na delegatów tylko wtedy, gdy jest używany jako pełnomocnik.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-171">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="7f4ac-172">Jeśli deklarujesz funkcję lokalną i odwołujesz się tylko do niej, wywołując ją jak metodę, nie zostanie ona przekonwertowana na pełnomocnika.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-172">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="7f4ac-173">Ta reguła umożliwia zadeklarowanie funkcji lokalnej w dowolnej dogodnej lokalizacji w jej otaczającym zakresie.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-173">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="7f4ac-174">Jest to typowe do deklarowania funkcji lokalnych na końcu metody nadrzędnej, po wszelkich instrukcji zwracanych.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-174">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="7f4ac-175">Po trzecie kompilator może wykonywać analizę statyczną, która umożliwia funkcjom lokalnym zdecydowanie przypisać przechwycone zmienne w otaczającym zakresie.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-175">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="7f4ac-176">Rozważmy następujący przykład:</span><span class="sxs-lookup"><span data-stu-id="7f4ac-176">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="7f4ac-177">Kompilator można `LocalFunction` określić, `y` że zdecydowanie przypisuje, gdy wywoływane.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-177">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="7f4ac-178">Ponieważ `LocalFunction` jest wywoływana przed instrukcją, `return` `y` `return` jest zdecydowanie przypisany do instrukcji.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-178">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="7f4ac-179">Analiza, która umożliwia analizę przykładu umożliwia czwartą różnicę.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-179">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="7f4ac-180">W zależności od ich użycia funkcje lokalne można uniknąć alokacji sterty, które są zawsze niezbędne dla wyrażeń lambda.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-180">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="7f4ac-181">Jeśli funkcja lokalna nigdy nie jest konwertowana na pełnomocnika, a żadna ze zmiennych przechwyconych przez funkcję lokalną nie jest przechwytywany przez inne funkcje lambdas lub lokalne, które są konwertowane na delegatów, kompilator może uniknąć alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-181">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="7f4ac-182">Rozważmy ten przykład asynchronii:</span><span class="sxs-lookup"><span data-stu-id="7f4ac-182">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="7f4ac-183">Zamknięcie dla tego wyrażenia lambda `index` `name` zawiera `address`, i zmienne.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-183">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="7f4ac-184">W przypadku funkcji lokalnych obiekt, który implementuje zamknięcie `struct` może być typem.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-184">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="7f4ac-185">Ten typ struktury będzie przekazywana przez odwołanie do funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-185">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="7f4ac-186">Ta różnica we wdrażaniu zaoszczędziłaby na alokacji.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-186">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="7f4ac-187">Wystąpienie niezbędne dla wyrażeń lambda oznacza dodatkowe alokacje pamięci, które mogą być czynnikiem wydajności w ścieżek kodu krytycznego w czasie.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-187">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="7f4ac-188">Funkcje lokalne nie ponoszą tego obciążenia.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-188">Local functions do not incur this overhead.</span></span> <span data-ttu-id="7f4ac-189">W powyższym przykładzie wersja funkcji lokalnych ma 2 mniej alokacji niż wersja wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-189">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="7f4ac-190">Lokalny odpowiednik funkcji tej metody również używa klasy do zamknięcia.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-190">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="7f4ac-191">Czy zamknięcie dla funkcji lokalnej jest `class` implementowana `struct` jako lub a jest szczegół implementacji.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-191">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="7f4ac-192">Funkcja lokalna może `struct` używać natomiast lambda zawsze `class`będzie używać .</span><span class="sxs-lookup"><span data-stu-id="7f4ac-192">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="7f4ac-193">Jedną z zalet końcowych nie wykazane w tym przykładzie jest, że `yield return` funkcje lokalne mogą być implementowane jako iteratory, przy użyciu składni do tworzenia sekwencji wartości.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-193">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="7f4ac-194">Instrukcja `yield return` nie jest dozwolona w wyrażeniach lambda.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-194">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="7f4ac-195">Podczas gdy funkcje lokalne mogą wydawać się zbędne do wyrażeń lambda, w rzeczywistości służą różnym celom i mają różne zastosowania.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-195">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="7f4ac-196">Funkcje lokalne są bardziej wydajne dla przypadku, gdy chcesz napisać funkcję, która jest wywoływana tylko z kontekstu innej metody.</span><span class="sxs-lookup"><span data-stu-id="7f4ac-196">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="7f4ac-197">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="7f4ac-197">See also</span></span>

- [<span data-ttu-id="7f4ac-198">Metody</span><span class="sxs-lookup"><span data-stu-id="7f4ac-198">Methods</span></span>](methods.md)
