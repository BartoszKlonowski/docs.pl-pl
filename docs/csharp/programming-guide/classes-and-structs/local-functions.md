---
title: Funkcje lokalne — Przewodnik programowania w języku C#
description: Funkcje lokalne w języku C# to metody prywatne, które są zagnieżdżone w innym elemencie członkowskim i mogą być wywoływane z ich składowych.
ms.date: 10/02/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: a91995757048c8c54253d7f4b923d5194f69bc7b
ms.sourcegitcommit: 4d45bda8cd9558ea8af4be591e3d5a29360c1ece
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/02/2020
ms.locfileid: "91654923"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="bbaa3-103">Funkcje lokalne (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="bbaa3-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="bbaa3-104">Począwszy od języka C# 7,0, C# obsługuje *funkcje lokalne*.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="bbaa3-105">Funkcje lokalne są prywatnymi metodami typu, które są zagnieżdżone w innym elemencie członkowskim.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="bbaa3-106">Mogą być wywoływane tylko z ich składowych.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-106">They can only be called from their containing member.</span></span> <span data-ttu-id="bbaa3-107">Funkcje lokalne można zadeklarować w i wywołać z:</span><span class="sxs-lookup"><span data-stu-id="bbaa3-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="bbaa3-108">Metody, zwłaszcza metody iteratorów i metody asynchroniczne</span><span class="sxs-lookup"><span data-stu-id="bbaa3-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="bbaa3-109">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="bbaa3-109">Constructors</span></span>
- <span data-ttu-id="bbaa3-110">Metody dostępu do właściwości</span><span class="sxs-lookup"><span data-stu-id="bbaa3-110">Property accessors</span></span>
- <span data-ttu-id="bbaa3-111">Metody dostępu zdarzeń</span><span class="sxs-lookup"><span data-stu-id="bbaa3-111">Event accessors</span></span>
- <span data-ttu-id="bbaa3-112">Metody anonimowe</span><span class="sxs-lookup"><span data-stu-id="bbaa3-112">Anonymous methods</span></span>
- <span data-ttu-id="bbaa3-113">Wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="bbaa3-113">Lambda expressions</span></span>
- <span data-ttu-id="bbaa3-114">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="bbaa3-114">Finalizers</span></span>
- <span data-ttu-id="bbaa3-115">Inne funkcje lokalne</span><span class="sxs-lookup"><span data-stu-id="bbaa3-115">Other local functions</span></span>

<span data-ttu-id="bbaa3-116">Jednak funkcji lokalnych nie można deklarować wewnątrz elementu członkowskiego będącego w posiadaniu wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="bbaa3-117">W niektórych przypadkach można użyć wyrażenia lambda, aby zaimplementować funkcje również obsługiwane przez funkcję lokalną.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="bbaa3-118">Aby zapoznać się z porównaniem, zobacz [funkcje lokalne a wyrażenia lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="bbaa3-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="bbaa3-119">Funkcje lokalne sprawiają, że zamiar kodu jest przejrzysty.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="bbaa3-120">Każda osoba odczytująca kod może zobaczyć, że metoda nie jest wywoływana z wyjątkiem metody zawierającej.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="bbaa3-121">W przypadku projektów zespołowych uniemożliwiają one również innym deweloperom błędne wywoływanie metody bezpośrednio z innych miejsc w klasie lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="bbaa3-122">Składnia funkcji lokalnych</span><span class="sxs-lookup"><span data-stu-id="bbaa3-122">Local function syntax</span></span>

<span data-ttu-id="bbaa3-123">Funkcja lokalna jest definiowana jako metoda zagnieżdżona wewnątrz składowej zawierającej.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="bbaa3-124">Jego definicja ma następującą składnię:</span><span class="sxs-lookup"><span data-stu-id="bbaa3-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="bbaa3-125">Można użyć następujących modyfikatorów z funkcją lokalną:</span><span class="sxs-lookup"><span data-stu-id="bbaa3-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="bbaa3-126">[`static`](../../language-reference/keywords/static.md) (w języku C# 8,0 i nowszych).</span><span class="sxs-lookup"><span data-stu-id="bbaa3-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="bbaa3-127">Statyczna funkcja lokalna nie może przechwycić lokalnych zmiennych lub stanu wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="bbaa3-128">[`extern`](../../language-reference/keywords/extern.md) (w języku C# 9,0 i nowszych).</span><span class="sxs-lookup"><span data-stu-id="bbaa3-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="bbaa3-129">Zewnętrzna funkcja lokalna musi być `static` .</span><span class="sxs-lookup"><span data-stu-id="bbaa3-129">An external local function must be `static`.</span></span>

<span data-ttu-id="bbaa3-130">Wszystkie zmienne lokalne, które są zdefiniowane w składowej zawierającej, łącznie z parametrami metody, są dostępne w niestatycznej funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="bbaa3-131">W przeciwieństwie do definicji metody lokalnej definicja funkcji nie może zawierać modyfikatora dostępu do składowej.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="bbaa3-132">Ponieważ wszystkie funkcje lokalne są prywatne, łącznie z modyfikatorem dostępu, takim jak `private` słowo kluczowe, generuje błąd kompilatora CS0106 "modyfikator" Private "jest nieprawidłowy dla tego elementu".</span><span class="sxs-lookup"><span data-stu-id="bbaa3-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="bbaa3-133">Ponadto atrybuty nie mogą być stosowane do funkcji lokalnej ani do jej parametrów i parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-133">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="bbaa3-134">W poniższym przykładzie zdefiniowano funkcję lokalną o nazwie `AppendPathSeparator` , która jest prywatna dla metody o nazwie `GetText` :</span><span class="sxs-lookup"><span data-stu-id="bbaa3-134">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="bbaa3-135">Lokalne funkcje i wyjątki</span><span class="sxs-lookup"><span data-stu-id="bbaa3-135">Local functions and exceptions</span></span>

<span data-ttu-id="bbaa3-136">Jedną z użytecznych funkcji lokalnych funkcji jest możliwość natychmiastowego zezwolenia na korzystanie z wyjątków.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-136">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="bbaa3-137">W przypadku iteratorów metod wyjątki są nakierowane tylko wtedy, gdy zwracana sekwencja jest wyliczana, a nie podczas pobierania iteratora.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-137">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="bbaa3-138">W przypadku metod asynchronicznych wszystkie wyjątki zgłoszone w metodzie asynchronicznej są zaobserwowane, gdy zwracane zadanie jest oczekiwane.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-138">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="bbaa3-139">W poniższym przykładzie zdefiniowano `OddSequence` metodę, która wylicza liczby nieparzyste między określonym zakresem.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-139">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="bbaa3-140">Ponieważ przekazuje liczbę większą niż 100 do `OddSequence` metody Enumerator, metoda zgłasza <xref:System.ArgumentOutOfRangeException> .</span><span class="sxs-lookup"><span data-stu-id="bbaa3-140">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="bbaa3-141">Ponieważ dane wyjściowe z przykładu pokazują, powierzchnie wyjątków tylko w przypadku iteracji liczby, a nie podczas pobierania modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-141">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="bbaa3-142">Zamiast tego można zgłosić wyjątek podczas sprawdzania poprawności i przed pobraniem iteratora, zwracając iterator z funkcji lokalnej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-142">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="bbaa3-143">Funkcji lokalnych można używać w podobny sposób, aby obsługiwać wyjątki poza operacją asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-143">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="bbaa3-144">Zwykle wyjątki zgłoszone w metodzie asynchronicznej wymagają sprawdzenia wyjątków wewnętrznych <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="bbaa3-144">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="bbaa3-145">Funkcje lokalne umożliwiają szybkie i niepowodzenie wykonywania kodu oraz umożliwiają synchroniczną i zaobserwowany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-145">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="bbaa3-146">W poniższym przykładzie zastosowano metodę asynchroniczną o nazwie `GetMultipleAsync` do pauzy przez określoną liczbę sekund i zwracają wartość, która jest losowo wielokrotnością tej liczby sekund.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-146">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="bbaa3-147">Maksymalne opóźnienie wynosi 5 sekund; <xref:System.ArgumentOutOfRangeException> wyniki, jeśli wartość jest większa niż 5.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-147">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="bbaa3-148">Jak pokazano na poniższym przykładzie, wyjątek, który jest generowany, gdy wartość 6 jest przekazana do `GetMultipleAsync` metody jest opakowany w <xref:System.AggregateException> po `GetMultipleAsync` rozpoczęciu wykonywania metody.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-148">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="bbaa3-149">Podobnie jak w iteratorze metody, możemy resłużyć kod z tego przykładu, aby przeprowadzić walidację przed wywołaniem metody asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-149">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="bbaa3-150">Jak pokazano na poniższym przykładzie, <xref:System.ArgumentOutOfRangeException> nie jest opakowany w <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="bbaa3-150">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="bbaa3-151">Funkcje lokalne a wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="bbaa3-151">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="bbaa3-152">Na pierwszy rzut oka funkcje lokalne i [wyrażenia lambda](../../language-reference/operators/lambda-expressions.md) są bardzo podobne.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-152">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="bbaa3-153">W wielu przypadkach wybór między wyrażeniami lambda i funkcjami lokalnymi jest kwestią stylu i preferencji osobistych.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-153">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="bbaa3-154">Istnieją jednak rzeczywiste różnice w tym, gdzie można korzystać z jednej z nich lub drugiej.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-154">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="bbaa3-155">Sprawdźmy różnice między funkcją lokalną a implementacją wyrażenia lambda algorytmu silnia.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-155">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="bbaa3-156">Pierwsza wersja przy użyciu funkcji lokalnej:</span><span class="sxs-lookup"><span data-stu-id="bbaa3-156">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="bbaa3-157">Kontrast tej implementacji z wersją, która używa wyrażeń lambda:</span><span class="sxs-lookup"><span data-stu-id="bbaa3-157">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="bbaa3-158">Funkcje lokalne mają nazwy.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-158">The local functions have names.</span></span> <span data-ttu-id="bbaa3-159">Wyrażenia lambda są metodami anonimowymi przypisanymi do zmiennych, które są `Func` lub `Action` typami.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-159">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="bbaa3-160">Gdy deklarujesz funkcję lokalną, typy argumentów i typ zwracany są częścią deklaracji funkcji.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-160">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="bbaa3-161">Zamiast być częścią treści wyrażenia lambda, typy argumentów i typ zwracany są częścią deklaracji typu zmiennej wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-161">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="bbaa3-162">Te dwie różnice mogą spowodować wyraźniejszy kod.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-162">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="bbaa3-163">Funkcje lokalne mają różne reguły dla określonego przypisania niż wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-163">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="bbaa3-164">Deklaracja funkcji lokalnej może być przywoływana z dowolnego miejsca w kodzie, w którym znajduje się w zakresie.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-164">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="bbaa3-165">Wyrażenie lambda musi być przypisane do zmiennej delegata, zanim będzie można uzyskać do niej dostęp (lub wywołać za pomocą delegata odwołującego się do wyrażenia lambda).</span><span class="sxs-lookup"><span data-stu-id="bbaa3-165">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="bbaa3-166">Należy zauważyć, że wersja używająca wyrażenia lambda musi deklarować i inicjować wyrażenie lambda `nthFactorial` przed jego zdefiniowaniem.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-166">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="bbaa3-167">Nie powoduje to błędu czasu kompilacji dla odwołania `nthFactorial` przed przypisaniem.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-167">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="bbaa3-168">Różnice te oznaczają, że algorytmy cykliczne są łatwiejsze do tworzenia przy użyciu funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-168">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="bbaa3-169">Można zadeklarować i zdefiniować funkcję lokalną, która wywołuje samą siebie.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-169">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="bbaa3-170">Wyrażenia lambda muszą być zadeklarowane i przypisane do wartości domyślnej przed ponownym przypisaniem do treści, która odwołuje się do tego samego wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-170">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="bbaa3-171">Określone reguły przypisywania mają wpływ na wszystkie zmienne, które są przechwytywane przez funkcję lokalną lub wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-171">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="bbaa3-172">Zarówno funkcja lokalna, jak i reguły wyrażenia lambda wymagają, aby wszystkie przechwycone zmienne były ostatecznie przypisane w punkcie, gdy funkcja lokalna lub wyrażenie lambda są konwertowane na delegata.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-172">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="bbaa3-173">Różnica polega na tym, że wyrażenia lambda są konwertowane na delegatów po ich zadeklarowaniu.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-173">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="bbaa3-174">Funkcja lokalna jest konwertowana na delegatów tylko wtedy, gdy jest używana jako delegat.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-174">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="bbaa3-175">Jeśli zadeklarujesz funkcję lokalną i odwołujesz się do niej tylko przez wywołanie jej jako metody, nie zostanie ona przekonwertowana na delegata.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-175">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="bbaa3-176">Ta reguła umożliwia zadeklarować funkcję lokalną w dowolnej wygodnej lokalizacji w jej zasięgu.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-176">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="bbaa3-177">Często deklaruje funkcje lokalne na końcu metody nadrzędnej po dowolnych instrukcjach Return.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-177">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="bbaa3-178">Po trzecie kompilator może wykonać analizę statyczną, która umożliwia lokalne funkcje, aby ostatecznie przypisywać przechwycone zmienne w zakresie otaczającym.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-178">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="bbaa3-179">Rozważ taki przykład:</span><span class="sxs-lookup"><span data-stu-id="bbaa3-179">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="bbaa3-180">Kompilator może określić, że jest on `LocalFunction` przypisywany, `y` gdy jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-180">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="bbaa3-181">Ponieważ `LocalFunction` jest wywoływana przed `return` instrukcją, `y` jest ostatecznie przypisana do `return` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-181">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="bbaa3-182">Analiza, która umożliwia przykładową analizę, włącza czwartą różnicę.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-182">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="bbaa3-183">W zależności od ich użycia funkcje lokalne mogą uniknąć przydziałów sterty, które są zawsze niezbędne dla wyrażeń lambda.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-183">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="bbaa3-184">Jeśli funkcja lokalna nigdy nie jest konwertowana na delegata, a żadna ze zmiennych przechwyconych przez funkcję lokalną nie zostanie przechwycona przez inne wyrażenia lambda lub funkcje lokalne, które są konwertowane na delegatów, kompilator może uniknąć przydziałów sterty.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-184">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="bbaa3-185">Rozważmy ten przykład asynchroniczny:</span><span class="sxs-lookup"><span data-stu-id="bbaa3-185">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="bbaa3-186">Zamknięcie tego wyrażenia lambda zawiera `address` `index` zmienne, i `name` .</span><span class="sxs-lookup"><span data-stu-id="bbaa3-186">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="bbaa3-187">W przypadku funkcji lokalnych obiekt implementujący zamknięcie może być `struct` typem.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-187">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="bbaa3-188">Ten typ struktury zostałby przesłany przez odwołanie do funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-188">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="bbaa3-189">Różnica w implementacji spowodowałaby zapisanie alokacji.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-189">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="bbaa3-190">Wystąpienie niezbędne dla wyrażeń lambda oznacza dodatkowe alokacje pamięci, które mogą być czynnikiem wydajności w ścieżkach kodu o kluczowym znaczeniu.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-190">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="bbaa3-191">Funkcja lokalna nie wiąże się z tym obciążeniem.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-191">Local functions do not incur this overhead.</span></span> <span data-ttu-id="bbaa3-192">W powyższym przykładzie wersja funkcji lokalnych ma 2 mniejsze alokacje niż wersja wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-192">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="bbaa3-193">Funkcja lokalna równoważna tej metody używa również klasy do zamykania.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-193">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="bbaa3-194">Czy zamknięcie funkcji lokalnej jest zaimplementowane jako `class` `struct` szczegóły implementacji.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-194">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="bbaa3-195">Funkcja lokalna może używać `struct` wyrażenia lambda, które zawsze będzie używać `class` .</span><span class="sxs-lookup"><span data-stu-id="bbaa3-195">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="bbaa3-196">Jedną z końcowych zalet nie pokazanych w tym przykładzie jest to, że funkcje lokalne można zaimplementować jako Iteratory, używając `yield return` składni w celu utworzenia sekwencji wartości.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-196">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="bbaa3-197">`yield return`Instrukcja jest niedozwolona w wyrażeniach lambda.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-197">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="bbaa3-198">Podczas gdy funkcje lokalne mogą wydawać się nadmiarowe w wyrażeniach lambda, są one w rzeczywistości wykorzystywane do różnych celów i mają różne zastosowania.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-198">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="bbaa3-199">Funkcje lokalne są wydajniejsze w przypadku, gdy chcesz napisać funkcję, która jest wywoływana tylko z kontekstu innej metody.</span><span class="sxs-lookup"><span data-stu-id="bbaa3-199">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="bbaa3-200">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="bbaa3-200">See also</span></span>

- [<span data-ttu-id="bbaa3-201">Metody</span><span class="sxs-lookup"><span data-stu-id="bbaa3-201">Methods</span></span>](methods.md)
