---
title: Obiekty (Przewodnik programowania w języku C#)
ms.date: 07/20/2015
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: e5e537d239bd69cb7a95ae82edbdb82144c700a1
ms.sourcegitcommit: 3c1c3ba79895335ff3737934e39372555ca7d6d0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/05/2018
ms.locfileid: "43788736"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="49aeb-102">Obiekty (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="49aeb-102">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="49aeb-103">Definicja klasy lub struktury jest podobna do planu, który określa, co zrobić, typ.</span><span class="sxs-lookup"><span data-stu-id="49aeb-103">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="49aeb-104">Obiekt jest zasadniczo bloku pamięci, która została przydzielona i skonfigurowane zgodnie z planu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-104">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="49aeb-105">Program może tworzyć wiele obiektów w tej samej klasy.</span><span class="sxs-lookup"><span data-stu-id="49aeb-105">A program may create many objects of the same class.</span></span> <span data-ttu-id="49aeb-106">Obiekty są również nazywane wystąpieniami i mogą być przechowywane w nazwanej zmiennej lub w tablicy lub kolekcji.</span><span class="sxs-lookup"><span data-stu-id="49aeb-106">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="49aeb-107">Kod klienta jest kodem, który używa tych zmiennych w celu wywołania metod i uzyskiwać dostęp do właściwości publiczne obiektu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-107">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="49aeb-108">W języku zorientowane obiektowo takich jak C# typowego programu składa się z wielu obiektów interakcji dynamicznie.</span><span class="sxs-lookup"><span data-stu-id="49aeb-108">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="49aeb-109">Typy statyczne będą działały inaczej niż opisane tutaj.</span><span class="sxs-lookup"><span data-stu-id="49aeb-109">Static types behave differently than what is described here.</span></span> <span data-ttu-id="49aeb-110">Aby uzyskać więcej informacji, zobacz [klasy statyczne i statyczne elementy członkowskie klasy](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="49aeb-110">For more information, see [Static Classes and Static Class Members](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span></span>  
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="49aeb-111">Struktura wystąpień programu vs. Wystąpienia klasy</span><span class="sxs-lookup"><span data-stu-id="49aeb-111">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="49aeb-112">Ponieważ klasy są typami odwołań, zmienna obiektu klasy zawiera odwołanie do adresu obiektu w zarządzanym stosie.</span><span class="sxs-lookup"><span data-stu-id="49aeb-112">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="49aeb-113">Jeśli drugi obiekt tego samego typu, jest przypisany do pierwszego obiektu, obie zmienne odnoszą się do obiektu pod tym adresem.</span><span class="sxs-lookup"><span data-stu-id="49aeb-113">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="49aeb-114">Ten punkt jest omówiona bardziej szczegółowo w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-114">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="49aeb-115">Wystąpienia klas są tworzone za pomocą [operatora new](../../../csharp/language-reference/keywords/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="49aeb-115">Instances of classes are created by using the [new operator](../../../csharp/language-reference/keywords/new-operator.md).</span></span> <span data-ttu-id="49aeb-116">W poniższym przykładzie `Person` jest typem i `person1` i `person 2` wystąpienia lub obiektów tego typu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-116">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_1.cs)]  
  
 <span data-ttu-id="49aeb-117">Ponieważ struktury są typami wartości, zmienna obiektu struktura zawiera kopię całego obiektu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-117">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="49aeb-118">Można również tworzyć wystąpienia struktury za pomocą `new` operatora, ale nie jest wymagane, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="49aeb-118">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_2.cs)]  
  
 <span data-ttu-id="49aeb-119">Pamięć dla obu `p1` i `p2` jest przydzielony na stosie wątku.</span><span class="sxs-lookup"><span data-stu-id="49aeb-119">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="49aeb-120">Że pamięć jest odzyskana wraz z typu lub metody, w którym jest zdeklarowana.</span><span class="sxs-lookup"><span data-stu-id="49aeb-120">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="49aeb-121">To jest jednym z powodów dlaczego struktury są kopiowane w przydziale.</span><span class="sxs-lookup"><span data-stu-id="49aeb-121">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="49aeb-122">Z drugiej strony pamięci przydzielonej do wystąpienia klasy jest automatycznie odzyskiwanego (bezużyteczne) przez środowisko uruchomieniowe języka wspólnego, gdy wszystkie odwołania do obiektu zniknie z zakresu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-122">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="49aeb-123">Nie jest możliwe w sposób deterministyczny zniszczenie obiektu klasy, jak w przypadku języka C++.</span><span class="sxs-lookup"><span data-stu-id="49aeb-123">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="49aeb-124">Aby uzyskać więcej informacji dotyczących wyrzucania elementów bezużytecznych w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], zobacz [wyrzucania elementów bezużytecznych](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="49aeb-124">For more information about garbage collection in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="49aeb-125">Alokacji i dezalokacji pamięci na stosie zarządzanym jest wysoce zoptymalizowane pod kątem w środowisko uruchomieniowe języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="49aeb-125">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="49aeb-126">W większości przypadków nie ma znaczące różnic w koszt wydajności związany z przydzielaniem wystąpienie klasy na stosie i przydzielanie wystąpienia struktury, na stosie.</span><span class="sxs-lookup"><span data-stu-id="49aeb-126">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>  
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="49aeb-127">Vs tożsamości obiektu. Równość wartości</span><span class="sxs-lookup"><span data-stu-id="49aeb-127">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="49aeb-128">Podczas porównywania dwóch obiektów pod kątem równości, należy najpierw odróżnić czy chcesz wiedzieć, czy dwie zmienne reprezentują tego samego obiektu w pamięci, lub czy są równoważne wartości co najmniej jednego pola.</span><span class="sxs-lookup"><span data-stu-id="49aeb-128">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="49aeb-129">Jeśli mają zamiar porównać wartości, należy rozważyć, czy obiekty są wystąpień typów wartości (struktury) lub typów referencyjnych (klas, obiektów delegowanych, tablice).</span><span class="sxs-lookup"><span data-stu-id="49aeb-129">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
-   <span data-ttu-id="49aeb-130">Aby ustalić, czy dwa wystąpienia klasy odnoszą się do tej samej lokalizacji w pamięci (co oznacza, że mają tę samą *tożsamości*), używa się statycznej <xref:System.Object.Equals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="49aeb-130">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="49aeb-131">(<xref:System.Object?displayProperty=nameWithType> jest niejawne klasą bazową dla wszystkich typów wartości i typy odwołania, w tym klasy i struktury zdefiniowany przez użytkownika.)</span><span class="sxs-lookup"><span data-stu-id="49aeb-131">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
-   <span data-ttu-id="49aeb-132">Aby określić, czy pola wystąpienia w dwa wystąpienia struktury mają te same wartości, należy użyć <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="49aeb-132">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="49aeb-133">Ponieważ wszystkie struktury niejawnie dziedziczą z <xref:System.ValueType?displayProperty=nameWithType>, wywołać metodę bezpośrednio na obiekcie, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="49aeb-133">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_3.cs)]  
  
 <span data-ttu-id="49aeb-134"><xref:System.ValueType?displayProperty=nameWithType> Implementacji `Equals` używa odbicia, ponieważ muszą być możliwe ustalenie, jakie pola znajdują się w dowolnej struktury.</span><span class="sxs-lookup"><span data-stu-id="49aeb-134">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="49aeb-135">Podczas tworzenia własnych struktur, Zastąp `Equals` metodę, aby zapewnić efektywne równości algorytm, który jest specyficzne dla danego typu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-135">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
-   <span data-ttu-id="49aeb-136">Aby ustalić, czy wartości pól w dwóch wystąpień klasy są takie same, można używać <xref:System.Object.Equals%2A> metody lub [== — operator](../../../csharp/language-reference/operators/equality-comparison-operator.md).</span><span class="sxs-lookup"><span data-stu-id="49aeb-136">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../../csharp/language-reference/operators/equality-comparison-operator.md).</span></span> <span data-ttu-id="49aeb-137">Jednak je stosować wyłącznie wtedy jeśli klasa ma przesłonięcia lub przeciążone je do dostarczania niestandardowych definicji jakie "równości" oznacza dla obiektów tego typu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-137">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="49aeb-138">Klasa może być także implementować <xref:System.IEquatable%601> interfejsu lub <xref:System.Collections.Generic.IEqualityComparer%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="49aeb-138">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="49aeb-139">Oba interfejsy zawierają metody, które mogą służyć do testowania równość wartości.</span><span class="sxs-lookup"><span data-stu-id="49aeb-139">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="49aeb-140">Podczas projektowania własnych klas zastąpienie `Equals`, upewnij się, że zgodnie z wytycznymi dotyczącymi określonych w [porady: Definiowanie równości wartości dla typu](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) i <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="49aeb-140">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to: Define Value Equality for a Type](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>  
  
## <a name="related-sections"></a><span data-ttu-id="49aeb-141">Sekcje pokrewne</span><span class="sxs-lookup"><span data-stu-id="49aeb-141">Related Sections</span></span>  
 <span data-ttu-id="49aeb-142">Informacje dodatkowe:</span><span class="sxs-lookup"><span data-stu-id="49aeb-142">For more information:</span></span>  
  
-   [<span data-ttu-id="49aeb-143">Klasy</span><span class="sxs-lookup"><span data-stu-id="49aeb-143">Classes</span></span>](../../../csharp/programming-guide/classes-and-structs/classes.md)  
  
-   [<span data-ttu-id="49aeb-144">Struktury</span><span class="sxs-lookup"><span data-stu-id="49aeb-144">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)  
  
-   [<span data-ttu-id="49aeb-145">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="49aeb-145">Constructors</span></span>](../../../csharp/programming-guide/classes-and-structs/constructors.md)  
  
-   [<span data-ttu-id="49aeb-146">Finalizatory</span><span class="sxs-lookup"><span data-stu-id="49aeb-146">Finalizers</span></span>](../../../csharp/programming-guide/classes-and-structs/destructors.md)  
  
-   [<span data-ttu-id="49aeb-147">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="49aeb-147">Events</span></span>](../../../csharp/programming-guide/events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="49aeb-148">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="49aeb-148">See Also</span></span>

- [<span data-ttu-id="49aeb-149">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="49aeb-149">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
- [<span data-ttu-id="49aeb-150">object</span><span class="sxs-lookup"><span data-stu-id="49aeb-150">object</span></span>](../../../csharp/language-reference/keywords/object.md)  
- [<span data-ttu-id="49aeb-151">Dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="49aeb-151">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)  
- [<span data-ttu-id="49aeb-152">class</span><span class="sxs-lookup"><span data-stu-id="49aeb-152">class</span></span>](../../../csharp/language-reference/keywords/class.md)  
- [<span data-ttu-id="49aeb-153">struct</span><span class="sxs-lookup"><span data-stu-id="49aeb-153">struct</span></span>](../../../csharp/language-reference/keywords/struct.md)  
- [<span data-ttu-id="49aeb-154">new, operator</span><span class="sxs-lookup"><span data-stu-id="49aeb-154">new Operator</span></span>](../../../csharp/language-reference/keywords/new-operator.md)  
- [<span data-ttu-id="49aeb-155">System typu wspólnego</span><span class="sxs-lookup"><span data-stu-id="49aeb-155">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
