---
title: Polimorfizm — C# Przewodnik programowania
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: e98399ac49e70f9139281ab75947c4acaf2dee7c
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/22/2019
ms.locfileid: "69922083"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="4c172-102">Polimorfizm (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="4c172-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="4c172-103">Polimorfizm jest często określany jako trzeci filar programowania zorientowanego obiektowo po hermetyzacji i dziedziczeniu.</span><span class="sxs-lookup"><span data-stu-id="4c172-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="4c172-104">Polimorfizm jest wyrazem greckim, który oznacza "wiele-kształt" i ma dwa odrębne aspekty:</span><span class="sxs-lookup"><span data-stu-id="4c172-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
- <span data-ttu-id="4c172-105">W czasie wykonywania obiekty klasy pochodnej mogą być traktowane jako obiekty klasy bazowej w miejscach takich jak parametry metody i kolekcje lub tablice.</span><span class="sxs-lookup"><span data-stu-id="4c172-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="4c172-106">W takim przypadku zadeklarowany typ obiektu nie jest już identyczny z typem jego czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4c172-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
- <span data-ttu-id="4c172-107">Klasy bazowe mogą definiować i implementować *metody* [wirtualne](../../language-reference/keywords/virtual.md) , a klasy pochodne mogą je przesłonić, co oznacza, że zapewniają własne definicje i implementacje. [](../../language-reference/keywords/override.md)</span><span class="sxs-lookup"><span data-stu-id="4c172-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="4c172-108">W czasie wykonywania, gdy kod klienta wywołuje metodę, środowisko CLR wyszukuje typ obiektu w czasie wykonywania i wywołuje przesłonięcie metody wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="4c172-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="4c172-109">W tym celu w kodzie źródłowym można wywołać metodę w klasie bazowej i spowodować, że ma zostać wykonana wersja klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="4c172-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="4c172-110">Metody wirtualne umożliwiają współpracę z grupami powiązanych obiektów w jednolity sposób.</span><span class="sxs-lookup"><span data-stu-id="4c172-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="4c172-111">Załóżmy na przykład, że masz aplikację do rysowania, która umożliwia użytkownikowi tworzenie różnych rodzajów kształtów na powierzchni rysunku.</span><span class="sxs-lookup"><span data-stu-id="4c172-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="4c172-112">W czasie kompilacji, które są tworzone dla poszczególnych typów kształtów, użytkownik nie wie.</span><span class="sxs-lookup"><span data-stu-id="4c172-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="4c172-113">Jednak aplikacja musi śledzić wszystkie różne typy tworzonych kształtów i musi je zaktualizować w odpowiedzi na akcje myszy wykonywane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="4c172-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="4c172-114">Można użyć polimorfizmu, aby rozwiązać ten problem w dwóch podstawowych krokach:</span><span class="sxs-lookup"><span data-stu-id="4c172-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1. <span data-ttu-id="4c172-115">Utwórz hierarchię klas, w której każda klasa określonego kształtu pochodzi ze wspólnej klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4c172-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2. <span data-ttu-id="4c172-116">Użyj metody wirtualnej do wywołania odpowiedniej metody dla dowolnej klasy pochodnej za pomocą pojedynczego wywołania metody klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4c172-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="4c172-117">Najpierw Utwórz klasę bazową o nazwie `Shape`i klasy pochodne, takie jak `Rectangle`, `Circle`, i `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="4c172-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="4c172-118">Nadaj klasie metodę wirtualną o nazwie `Draw`i Przesłoń ją w każdej klasie pochodnej, aby narysować określony kształt, który reprezentuje Klasa. `Shape`</span><span class="sxs-lookup"><span data-stu-id="4c172-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="4c172-119">`List<Shape>` Utwórz obiekt i Dodaj okrąg, Trójkąt i prostokąt do niego.</span><span class="sxs-lookup"><span data-stu-id="4c172-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="4c172-120">Aby zaktualizować powierzchnię rysowania, użyj pętli [foreach](../../language-reference/keywords/foreach-in.md) , aby wykonać iterację listy i wywołać `Draw` metodę dla każdego `Shape` obiektu na liście.</span><span class="sxs-lookup"><span data-stu-id="4c172-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="4c172-121">Mimo że każdy obiekt na liście ma zadeklarowany typ `Shape`, jest typem czasu wykonywania (zastąpioną wersją metody w każdej klasie pochodnej), która zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="4c172-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#50](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#50)]  
  
 <span data-ttu-id="4c172-122">W C#programie każdy typ jest polimorficzny, ponieważ wszystkie typy, włącznie z typami zdefiniowanymi przez <xref:System.Object>użytkownika, dziedziczą z.</span><span class="sxs-lookup"><span data-stu-id="4c172-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="4c172-123">Omówienie polimorfizmu</span><span class="sxs-lookup"><span data-stu-id="4c172-123">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="4c172-124">Wirtualne składowe</span><span class="sxs-lookup"><span data-stu-id="4c172-124">Virtual Members</span></span>  
 <span data-ttu-id="4c172-125">Gdy Klasa pochodna dziedziczy z klasy bazowej, uzyskuje wszystkie metody, pola, właściwości i zdarzenia klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4c172-125">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="4c172-126">Projektant klasy pochodnej może wybrać, czy należy</span><span class="sxs-lookup"><span data-stu-id="4c172-126">The designer of the derived class can choose whether to</span></span>  
  
- <span data-ttu-id="4c172-127">Przesłoń wirtualne elementy członkowskie w klasie bazowej,</span><span class="sxs-lookup"><span data-stu-id="4c172-127">override virtual members in the base class,</span></span>  
  
- <span data-ttu-id="4c172-128">Dziedzicz najbliższą metodę klasy bazowej bez jej przesłaniania</span><span class="sxs-lookup"><span data-stu-id="4c172-128">inherit the closest base class method without overriding it</span></span>  
  
- <span data-ttu-id="4c172-129">Zdefiniuj nową niewirtualną implementację tych elementów członkowskich, które ukrywają implementacje klas podstawowych</span><span class="sxs-lookup"><span data-stu-id="4c172-129">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="4c172-130">Klasa pochodna może przesłonić składową klasy bazowej tylko wtedy, gdy element członkowski klasy bazowej jest zadeklarowany jako [wirtualny](../../language-reference/keywords/virtual.md) lub [abstrakcyjny](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="4c172-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="4c172-131">Pochodny element członkowski musi użyć słowa kluczowego [override](../../language-reference/keywords/override.md) , aby jawnie wskazać, że metoda ma uczestniczyć w wywołaniu wirtualnym.</span><span class="sxs-lookup"><span data-stu-id="4c172-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="4c172-132">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="4c172-132">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#20)]  
  
 <span data-ttu-id="4c172-133">Pola nie mogą być wirtualne; tylko metody, właściwości, zdarzenia i indeksatory mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="4c172-133">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="4c172-134">Gdy Klasa pochodna przesłania wirtualną składową, ten element członkowski jest wywoływany nawet wtedy, gdy do wystąpienia tej klasy jest uzyskiwany dostęp jako wystąpienie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4c172-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="4c172-135">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="4c172-135">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#21)]  
  
 <span data-ttu-id="4c172-136">Metody wirtualne i właściwości umożliwiają klasom pochodnym poszerzanie klasy bazowej bez konieczności używania implementacji klasy bazowej metody.</span><span class="sxs-lookup"><span data-stu-id="4c172-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="4c172-137">Aby uzyskać więcej informacji, zobacz [przechowywanie wersji ze słowami kluczowymi override i New](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="4c172-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="4c172-138">Interfejs zapewnia inny sposób definiowania metody lub zestawu metod, których implementacja pozostała do klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="4c172-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="4c172-139">Więcej informacji znajdziesz w artykule [Interfejsy](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="4c172-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="4c172-140">Ukrywanie członków klasy bazowej przy użyciu nowych członków</span><span class="sxs-lookup"><span data-stu-id="4c172-140">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="4c172-141">Jeśli element członkowski pochodna ma mieć taką samą nazwę jak element członkowski w klasie bazowej, ale nie chcesz, aby uczestniczył w wywołaniu wirtualnym, możesz użyć słowa kluczowego [New](../../language-reference/keywords/new-modifier.md) .</span><span class="sxs-lookup"><span data-stu-id="4c172-141">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword.</span></span> <span data-ttu-id="4c172-142">`new` Słowo kluczowe jest umieszczane przed typem zwracanym elementu członkowskiego klasy, który jest zastępowany.</span><span class="sxs-lookup"><span data-stu-id="4c172-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="4c172-143">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="4c172-143">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#18)]  
  
 <span data-ttu-id="4c172-144">Do elementów członkowskich ukrytych klas podstawowych nadal można uzyskać dostęp z kodu klienta, Rzutowanie wystąpienia klasy pochodnej na wystąpienie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4c172-144">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="4c172-145">Przykład:</span><span class="sxs-lookup"><span data-stu-id="4c172-145">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#19)]  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="4c172-146">Uniemożliwianie klas pochodnych przed zastępowaniem wirtualnych elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="4c172-146">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="4c172-147">Wirtualne elementy członkowskie pozostają na czas nieokreślony, niezależnie od tego, jak wiele klas zostało zadeklarowanych między wirtualną składową i klasą, która pierwotnie została zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="4c172-147">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="4c172-148">Jeśli klasa A deklaruje wirtualną składową, a Klasa B pochodzi z, a Klasa C pochodzi od B, Klasa C dziedziczy do wirtualnego elementu członkowskiego i ma możliwość jego zastąpienia, niezależnie od tego, czy Klasa B deklaruje przesłonięcie dla tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4c172-148">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="4c172-149">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="4c172-149">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#22)]  
  
 <span data-ttu-id="4c172-150">Klasa pochodna może zatrzymać Dziedziczenie wirtualne, deklarując przesłonięcie jako [Sealed](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="4c172-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="4c172-151">Wymaga to umieszczenia `sealed` słowa kluczowego `override` przed słowem kluczowym w deklaracji składowej klasy.</span><span class="sxs-lookup"><span data-stu-id="4c172-151">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="4c172-152">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="4c172-152">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#24)]  
  
 <span data-ttu-id="4c172-153">W poprzednim przykładzie metoda `DoWork` nie jest już wirtualna dla żadnej klasy pochodnej języka C. Nadal jest ona wirtualna dla wystąpień C, nawet jeśli są one rzutowane do typu B lub typu A. zapieczętowane metody mogą zostać zastąpione przez klasy pochodne za pomocą `new` słowa kluczowego, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="4c172-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#25)]  
  
 <span data-ttu-id="4c172-154">W tym przypadku, jeśli `DoWork` jest wywoływana w D przy użyciu zmiennej typu d, Nowa `DoWork` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4c172-154">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="4c172-155">Jeśli zmienna typu C, B lub a jest używana w celu uzyskania dostępu do wystąpienia D, wywołanie `DoWork` zostanie zgodne z regułami dziedziczenia wirtualnego, a następnie rozsyła te wywołania do `DoWork` implementacji klasy C.</span><span class="sxs-lookup"><span data-stu-id="4c172-155">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="4c172-156">Uzyskiwanie dostępu do wirtualnych elementów członkowskich klasy podstawowej z klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="4c172-156">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="4c172-157">Klasa pochodna, która zastąpiła lub przesłonięta metodę lub właściwość, może nadal uzyskiwać dostęp do metody lub właściwości w `base` klasie podstawowej przy użyciu słowa kluczowego.</span><span class="sxs-lookup"><span data-stu-id="4c172-157">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="4c172-158">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="4c172-158">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#26)]  
  
 <span data-ttu-id="4c172-159">Aby uzyskać więcej informacji, zobacz temat [Base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="4c172-159">For more information, see [base](../../language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4c172-160">Zaleca się, aby wirtualne składowe `base` używały do wywoływania implementacji klasy bazowej tego elementu członkowskiego we własnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="4c172-160">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="4c172-161">Zezwolenie na zachowanie klasy bazowej umożliwia skoncentrowanie się na implementowaniu przez klasę pochodną zachowania związanego z klasą pochodną.</span><span class="sxs-lookup"><span data-stu-id="4c172-161">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="4c172-162">Jeśli implementacja klasy bazowej nie jest wywoływana, jest do klasy pochodnej, aby ich zachowanie było zgodne z zachowaniem klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4c172-162">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="4c172-163">W tej sekcji</span><span class="sxs-lookup"><span data-stu-id="4c172-163">In This Section</span></span>  
  
- [<span data-ttu-id="4c172-164">Przechowywanie wersji przesłonięć i nowych słów kluczowych</span><span class="sxs-lookup"><span data-stu-id="4c172-164">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)  
  
- [<span data-ttu-id="4c172-165">Użycie przesłonięć i nowych słów kluczowych</span><span class="sxs-lookup"><span data-stu-id="4c172-165">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)  
  
- [<span data-ttu-id="4c172-166">Instrukcje: Zastąp metodę ToString</span><span class="sxs-lookup"><span data-stu-id="4c172-166">How to: Override the ToString Method</span></span>](./how-to-override-the-tostring-method.md)  
  
## <a name="see-also"></a><span data-ttu-id="4c172-167">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="4c172-167">See also</span></span>

- [<span data-ttu-id="4c172-168">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="4c172-168">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="4c172-169">Dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="4c172-169">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="4c172-170">Klasy abstrakcyjne i zapieczętowane oraz elementy członkowskie klas</span><span class="sxs-lookup"><span data-stu-id="4c172-170">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="4c172-171">Metody</span><span class="sxs-lookup"><span data-stu-id="4c172-171">Methods</span></span>](./methods.md)
- [<span data-ttu-id="4c172-172">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="4c172-172">Events</span></span>](../events/index.md)
- [<span data-ttu-id="4c172-173">Właściwości</span><span class="sxs-lookup"><span data-stu-id="4c172-173">Properties</span></span>](./properties.md)
- [<span data-ttu-id="4c172-174">Indeksatory</span><span class="sxs-lookup"><span data-stu-id="4c172-174">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="4c172-175">Typy</span><span class="sxs-lookup"><span data-stu-id="4c172-175">Types</span></span>](../types/index.md)
