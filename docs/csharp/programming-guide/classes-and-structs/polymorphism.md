---
title: Polimorfizm - Przewodnik programowania C#
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 58980bd0d70d8a778cdb208f56d31ee8465871a4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79170172"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="38ba4-102">Polimorfizm (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="38ba4-102">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="38ba4-103">Polimorfizm jest często określany jako trzeci filar programowania obiektowego, po hermetyzacji i dziedziczeniu.</span><span class="sxs-lookup"><span data-stu-id="38ba4-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="38ba4-104">Polimorfizm jest greckie słowo, które oznacza "wielu kształtach" i ma dwa różne aspekty:</span><span class="sxs-lookup"><span data-stu-id="38ba4-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="38ba4-105">W czasie wykonywania obiekty klasy pochodnej mogą być traktowane jako obiekty klasy podstawowej w miejscach, takich jak parametry metody i kolekcje lub tablice.</span><span class="sxs-lookup"><span data-stu-id="38ba4-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="38ba4-106">Po wystąpieniu tego polimorfizmu zadeklarowany typ obiektu nie jest już identyczny z jego typem czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="38ba4-106">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="38ba4-107">Klasy podstawowe mogą definiować i implementować *metody* [wirtualne,](../../language-reference/keywords/virtual.md) a klasy pochodne mogą je [zastąpić,](../../language-reference/keywords/override.md) co oznacza, że zapewniają własną definicję i implementację.</span><span class="sxs-lookup"><span data-stu-id="38ba4-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="38ba4-108">W czasie wykonywania, gdy kod klienta wywołuje metodę, środowisko CLR wyszukuje typ czasu wykonywania obiektu i wywołuje, że zastąpienie metody wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="38ba4-109">W kodzie źródłowym można wywołać metodę w klasie podstawowej i spowodować, że wersja metody klasy pochodnej ma być wykonywana.</span><span class="sxs-lookup"><span data-stu-id="38ba4-109">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="38ba4-110">Metody wirtualne umożliwiają jednolitą pracę z grupami powiązanych obiektów.</span><span class="sxs-lookup"><span data-stu-id="38ba4-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="38ba4-111">Załóżmy na przykład, że masz aplikację do rysowania, która umożliwia użytkownikowi tworzenie różnego rodzaju kształtów na powierzchni rysunku.</span><span class="sxs-lookup"><span data-stu-id="38ba4-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="38ba4-112">Nie wiadomo w czasie kompilacji, które konkretne typy kształtów użytkownik utworzy.</span><span class="sxs-lookup"><span data-stu-id="38ba4-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="38ba4-113">Jednak aplikacja musi śledzić wszystkie różne typy kształtów, które są tworzone i musi je zaktualizować w odpowiedzi na akcje myszy użytkownika.</span><span class="sxs-lookup"><span data-stu-id="38ba4-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="38ba4-114">Możesz użyć polimorfizmu, aby rozwiązać ten problem w dwóch podstawowych krokach:</span><span class="sxs-lookup"><span data-stu-id="38ba4-114">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="38ba4-115">Utwórz hierarchię klas, w której każda klasa określonego kształtu pochodzi od wspólnej klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="38ba4-116">Użyj metody wirtualnej, aby wywołać odpowiednią metodę dla dowolnej klasy pochodnej za pośrednictwem pojedynczego wywołania metody klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="38ba4-117">Najpierw utwórz klasę `Shape`podstawową o nazwie `Rectangle`, `Circle`i `Triangle`klasy pochodne, takie jak , , i .</span><span class="sxs-lookup"><span data-stu-id="38ba4-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="38ba4-118">Nadaj `Shape` klasie metodę `Draw`wirtualną o nazwie i zastąp ją w każdej klasie pochodnej, aby narysować określony kształt, który reprezentuje klasa.</span><span class="sxs-lookup"><span data-stu-id="38ba4-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="38ba4-119">Utwórz `List<Shape>` obiekt i `Circle` `Triangle`dodaj `Rectangle` , i do niego.</span><span class="sxs-lookup"><span data-stu-id="38ba4-119">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="38ba4-120">Aby zaktualizować powierzchnię rysunku, użyj pętli [foreach](../../language-reference/keywords/foreach-in.md) do iteratezania listy i wywołania `Draw` metody na każdym `Shape` obiekcie na liście.</span><span class="sxs-lookup"><span data-stu-id="38ba4-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="38ba4-121">Mimo że każdy obiekt na liście `Shape`ma zadeklarowany typ , jest to typ czasu wykonywania (zastąpiona wersja metody w każdej klasie pochodnej), który zostanie wywołany.</span><span class="sxs-lookup"><span data-stu-id="38ba4-121">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="38ba4-122">W języku C#, każdy typ jest polimorficzny, ponieważ <xref:System.Object>wszystkie typy, w tym typy zdefiniowane przez użytkownika, dziedziczą z .</span><span class="sxs-lookup"><span data-stu-id="38ba4-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="38ba4-123">Przegląd polimorfizmu</span><span class="sxs-lookup"><span data-stu-id="38ba4-123">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="38ba4-124">Członkowie wirtualni</span><span class="sxs-lookup"><span data-stu-id="38ba4-124">Virtual members</span></span>

<span data-ttu-id="38ba4-125">Gdy klasa pochodna dziedziczy z klasy podstawowej, zyskuje wszystkie metody, pola, właściwości i zdarzenia klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-125">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="38ba4-126">Projektant klasy pochodnej może różnych wyborów dla zachowania metod wirtualnych:</span><span class="sxs-lookup"><span data-stu-id="38ba4-126">The designer of the derived class can different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="38ba4-127">Klasa pochodna może zastąpić członków wirtualnych w klasie podstawowej, definiując nowe zachowanie.</span><span class="sxs-lookup"><span data-stu-id="38ba4-127">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="38ba4-128">Klasa pochodna dziedziczyć najbliższą metodę klasy podstawowej bez zastępowania go, zachowując istniejące zachowanie, ale umożliwiając dalsze pochodne klasy zastąpić metodę.</span><span class="sxs-lookup"><span data-stu-id="38ba4-128">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="38ba4-129">Klasa pochodna może zdefiniować nową implementację niewirtualną tych elementów członkowskich, które ukrywają implementacje klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-129">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="38ba4-130">Klasa pochodna może zastąpić element członkowski klasy podstawowej tylko wtedy, gdy element członkowski klasy podstawowej jest zadeklarowany jako [wirtualny](../../language-reference/keywords/virtual.md) lub [abstrakcyjny.](../../language-reference/keywords/abstract.md)</span><span class="sxs-lookup"><span data-stu-id="38ba4-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="38ba4-131">Element członkowski pochodne musi używać [override](../../language-reference/keywords/override.md) — słowo kluczowe, aby jawnie wskazać, że metoda jest przeznaczona do udziału w wywołaniu wirtualnym.</span><span class="sxs-lookup"><span data-stu-id="38ba4-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="38ba4-132">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="38ba4-132">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="38ba4-133">Pola nie mogą być wirtualne; tylko metody, właściwości, zdarzenia i indeksatory mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="38ba4-133">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="38ba4-134">Gdy klasa pochodna zastępuje element członkowski virtual, ten element członkowski jest wywoływany nawet wtedy, gdy wystąpienie tej klasy jest dostępne jako wystąpienie klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="38ba4-135">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="38ba4-135">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="38ba4-136">Metody i właściwości wirtualne umożliwiają klasy pochodne, aby rozszerzyć klasę podstawową bez konieczności używania implementacji klasy podstawowej metody.</span><span class="sxs-lookup"><span data-stu-id="38ba4-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="38ba4-137">Aby uzyskać więcej informacji, zobacz [Przechowywanie wersji przy pomocą słów kluczowych Zastępowania i Nowych](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="38ba4-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="38ba4-138">Interfejs zapewnia inny sposób definiowania metody lub zestawu metod, których implementacja jest pozostawiona klasom pochodnym.</span><span class="sxs-lookup"><span data-stu-id="38ba4-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="38ba4-139">Aby uzyskać więcej informacji, zobacz [Interfejsy](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="38ba4-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="38ba4-140">Ukrywanie członków klasy podstawowej z nowymi członkami</span><span class="sxs-lookup"><span data-stu-id="38ba4-140">Hide base class members with new members</span></span>

<span data-ttu-id="38ba4-141">Jeśli chcesz, aby klasa pochodna miała element członkowski o tej samej nazwie co element członkowski w klasie podstawowej, możesz użyć [nowego](../../language-reference/keywords/new-modifier.md) słowa kluczowego, aby ukryć element członkowski klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-141">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="38ba4-142">Słowo `new` kluczowe jest umieszczane przed zwracanym typem elementu członkowskiego klasy, który jest zastępowany.</span><span class="sxs-lookup"><span data-stu-id="38ba4-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="38ba4-143">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="38ba4-143">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="38ba4-144">Ukryte elementy członkowskie klasy podstawowej mogą być dostępne z kodu klienta przez rzutowanie wystąpienia klasy pochodnej do wystąpienia klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-144">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="38ba4-145">Przykład:</span><span class="sxs-lookup"><span data-stu-id="38ba4-145">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="38ba4-146">Zapobiegaj zastępowaniu wirtualnych elementów członkowskich klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="38ba4-146">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="38ba4-147">Elementy członkowskie wirtualne pozostają wirtualne, niezależnie od tego, ile klas zostały zadeklarowane między elementem członkowskim wirtualnym i klasy, która pierwotnie zadeklarowała go.</span><span class="sxs-lookup"><span data-stu-id="38ba4-147">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="38ba4-148">Jeśli `A` klasa deklaruje wirtualny element `B` członkowski, a `C` klasa `B`pochodzi `C` od `B` `A`, a klasa pochodzi od , klasa dziedziczy element członkowski wirtualny i może go zastąpić, niezależnie od tego, czy klasa zadeklarowała zastąpienie tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="38ba4-148">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="38ba4-149">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="38ba4-149">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="38ba4-150">Klasa pochodna może zatrzymać dziedziczenie wirtualne, deklarując zastąpienie jako [zapieczętowane](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="38ba4-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="38ba4-151">Zatrzymywanie dziedziczenia wymaga `override` umieszczenia słowa kluczowego `sealed` przed słowem kluczowym w deklaracji elementu członkowskiego klasy.</span><span class="sxs-lookup"><span data-stu-id="38ba4-151">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="38ba4-152">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="38ba4-152">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="38ba4-153">W poprzednim przykładzie metoda `DoWork` nie jest już wirtualny do `C`żadnej klasy pochodzącej z .</span><span class="sxs-lookup"><span data-stu-id="38ba4-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="38ba4-154">Jest to nadal wirtualne dla `C`wystąpień , nawet jeśli `B` są `A`one oddanych do typu lub typu .</span><span class="sxs-lookup"><span data-stu-id="38ba4-154">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="38ba4-155">Metody zapieczętowane można zastąpić klasami pochodnymi za pomocą słowa kluczowego, `new` jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="38ba4-155">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="38ba4-156">W takim przypadku, `DoWork` jeśli `D` jest wywoływana `D`przy `DoWork` użyciu zmiennej typu , nowy jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="38ba4-156">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="38ba4-157">Jeśli zmienna `C`typu `B`, `A` lub jest używany `D`do uzyskania `DoWork` dostępu do wystąpienia , wywołanie będzie zgodne `DoWork` z `C`regułami dziedziczenia wirtualnego, routing tych wywołań do implementacji na klasy .</span><span class="sxs-lookup"><span data-stu-id="38ba4-157">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="38ba4-158">Dostęp do wirtualnych elementów członkowskich klasy podstawowej z klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="38ba4-158">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="38ba4-159">Klasa pochodna, która zastąpiła lub zastąpiona metoda lub właściwość nadal może `base` uzyskać dostęp do metody lub właściwości w klasie podstawowej przy użyciu słowa kluczowego.</span><span class="sxs-lookup"><span data-stu-id="38ba4-159">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="38ba4-160">Poniższy kod zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="38ba4-160">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="38ba4-161">Aby uzyskać więcej informacji, zobacz [podstawa](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="38ba4-161">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="38ba4-162">Zaleca się, że elementy `base` członkowskie wirtualne użyć do wywołania implementacji klasy podstawowej tego elementu członkowskiego w ich implementacji własnej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-162">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="38ba4-163">Pozwalając zachowanie klasy podstawowej występuje umożliwia klasy pochodnej skoncentrować się na implementowanie zachowanie specyficzne dla klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-163">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="38ba4-164">Jeśli implementacja klasy podstawowej nie jest wywoływana, to do klasy pochodnej, aby ich zachowanie zgodne z zachowaniem klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="38ba4-164">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="38ba4-165">W tej sekcji</span><span class="sxs-lookup"><span data-stu-id="38ba4-165">In this section</span></span>

- [<span data-ttu-id="38ba4-166">Przechowywanie wersji przesłonięć i nowych słów kluczowych</span><span class="sxs-lookup"><span data-stu-id="38ba4-166">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="38ba4-167">Użycie zastępowania i nowych słów kluczowych</span><span class="sxs-lookup"><span data-stu-id="38ba4-167">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="38ba4-168">Jak zastąpić ToString metody</span><span class="sxs-lookup"><span data-stu-id="38ba4-168">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="38ba4-169">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="38ba4-169">See also</span></span>

- [<span data-ttu-id="38ba4-170">Przewodnik programowania języka C#</span><span class="sxs-lookup"><span data-stu-id="38ba4-170">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="38ba4-171">Dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="38ba4-171">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="38ba4-172">Klasy abstrakcyjne i zapieczętowane oraz członkowie klas</span><span class="sxs-lookup"><span data-stu-id="38ba4-172">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="38ba4-173">Metody</span><span class="sxs-lookup"><span data-stu-id="38ba4-173">Methods</span></span>](./methods.md)
- [<span data-ttu-id="38ba4-174">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="38ba4-174">Events</span></span>](../events/index.md)
- [<span data-ttu-id="38ba4-175">Właściwości</span><span class="sxs-lookup"><span data-stu-id="38ba4-175">Properties</span></span>](./properties.md)
- <span data-ttu-id="38ba4-176">[Indexers](../indexers/index.md) (Indeksatory)</span><span class="sxs-lookup"><span data-stu-id="38ba4-176">[Indexers](../indexers/index.md)</span></span>
- [<span data-ttu-id="38ba4-177">Typy</span><span class="sxs-lookup"><span data-stu-id="38ba4-177">Types</span></span>](../types/index.md)
