---
title: Polimorfizm - C# przewodnik programowania
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 9bb87115f4649a890d1fb2aab1595c3b6848bc74
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/18/2019
ms.locfileid: "59322085"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="e8ace-102">Polimorfizm (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="e8ace-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="e8ace-103">Polimorfizm często nazywa się trzeci filar programowanie zorientowane obiektowo, po hermetyzacji i dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="e8ace-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="e8ace-104">Polimorfizm jest wyrazem greckim, co oznacza "wiele kształcie" i ma dwa różne aspekty:</span><span class="sxs-lookup"><span data-stu-id="e8ace-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
-   <span data-ttu-id="e8ace-105">W czasie wykonywania obiektów klasy pochodne mogą być traktowane jako obiekty klasy bazowej, w miejscach takich jak parametry metody i kolekcje lub tablic.</span><span class="sxs-lookup"><span data-stu-id="e8ace-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="e8ace-106">W takiej sytuacji deklarowany typ obiektu nie jest już taka sama jak jego typu run-time.</span><span class="sxs-lookup"><span data-stu-id="e8ace-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
-   <span data-ttu-id="e8ace-107">Klasy bazowe mogą definiować ani implementować [wirtualnego](../../../csharp/language-reference/keywords/virtual.md) *metody*, oraz klasy pochodne mogą [zastąpienia](../../../csharp/language-reference/keywords/override.md) je, co oznacza, że zapewniają one własne definicję i implementację.</span><span class="sxs-lookup"><span data-stu-id="e8ace-107">Base classes may define and implement [virtual](../../../csharp/language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../../csharp/language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="e8ace-108">W czasie wykonywania gdy kod klienta wywołuje metodę, środowisko CLR odwołuje się do typu run-time obiektu, a wywołuje zastąpienie metod wirtualnych.</span><span class="sxs-lookup"><span data-stu-id="e8ace-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="e8ace-109">Ten sposób w kodzie źródłowym wywołania metody w klasie bazowej i spowodować, że wersja klasy pochodnej metody do wykonania.</span><span class="sxs-lookup"><span data-stu-id="e8ace-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="e8ace-110">Metody wirtualne umożliwiają pracować z grupami powiązanych obiektów w jednolity sposób.</span><span class="sxs-lookup"><span data-stu-id="e8ace-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="e8ace-111">Na przykład załóżmy, że masz rysunku aplikacji, która umożliwia użytkownikowi tworzenie różne rodzaje kształtów na powierzchnię rysunku.</span><span class="sxs-lookup"><span data-stu-id="e8ace-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="e8ace-112">Nie wiesz, w czasie kompilacji które określonych rodzajów kształtów spowoduje utworzenie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e8ace-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="e8ace-113">Jednak aplikacja ma do śledzenia różnych typów kształty, które są tworzone i ma je zaktualizować w odpowiedzi na akcje myszy użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e8ace-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="e8ace-114">Polimorfizm można użyć, aby rozwiązać ten problem w dwa podstawowe kroki:</span><span class="sxs-lookup"><span data-stu-id="e8ace-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1. <span data-ttu-id="e8ace-115">Tworzenie hierarchii klas, w którym każda klasa kształt pochodzi od klasy wspólną klasę bazową.</span><span class="sxs-lookup"><span data-stu-id="e8ace-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2. <span data-ttu-id="e8ace-116">Użyj metody wirtualnej można wywołać metody odpowiedniej dla dowolnej klasy pochodnej za pomocą jednego wywołania metody klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="e8ace-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="e8ace-117">Najpierw należy utworzyć klasę bazową, która wywołuje `Shape`i klas pochodnych, takich jak `Rectangle`, `Circle`, i `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="e8ace-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="e8ace-118">Nadaj `Shape` wywołuje metodę wirtualną klasy `Draw`, i zastąpienie go w każdej klasie pochodnej, aby narysować określonych kształtów, klasa reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="e8ace-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="e8ace-119">Utwórz `List<Shape>` obiektu i dodać do niego koła, trójkąt i prostokąt.</span><span class="sxs-lookup"><span data-stu-id="e8ace-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="e8ace-120">Aby zaktualizować powierzchni do rysowania, użyj [foreach](../../../csharp/language-reference/keywords/foreach-in.md) pętli do iteracji przez listę i wywołania `Draw` metody na każdym `Shape` obiektu na liście.</span><span class="sxs-lookup"><span data-stu-id="e8ace-120">To update the drawing surface, use a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="e8ace-121">Mimo że każdy obiekt na liście ma zadeklarowany typ `Shape`, jest typu run-time (wersja przesłonięte metody w każdej klasie pochodnej), który zostanie wywołany.</span><span class="sxs-lookup"><span data-stu-id="e8ace-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#50](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#50)]  
  
 <span data-ttu-id="e8ace-122">W języku C# polimorficznych jest każdego typu, ponieważ dziedziczy wszystkie typy, w tym typy zdefiniowane przez użytkownika <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="e8ace-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="e8ace-123">Polimorfizm — omówienie</span><span class="sxs-lookup"><span data-stu-id="e8ace-123">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="e8ace-124">Wirtualne składowe</span><span class="sxs-lookup"><span data-stu-id="e8ace-124">Virtual Members</span></span>  
 <span data-ttu-id="e8ace-125">Klasa pochodna dziedziczy z klasy bazowej, uzyskuje się wszystkie metody, pola, właściwości i zdarzeń klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="e8ace-125">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="e8ace-126">Projektant klasy pochodne mogą wybrać opcję</span><span class="sxs-lookup"><span data-stu-id="e8ace-126">The designer of the derived class can choose whether to</span></span>  
  
-   <span data-ttu-id="e8ace-127">Przesłoń składowe wirtualnego w klasie bazowej</span><span class="sxs-lookup"><span data-stu-id="e8ace-127">override virtual members in the base class,</span></span>  
  
-   <span data-ttu-id="e8ace-128">dziedziczenie najbliższego metody klasy bazowej nie przesłanianie go</span><span class="sxs-lookup"><span data-stu-id="e8ace-128">inherit the closest base class method without overriding it</span></span>  
  
-   <span data-ttu-id="e8ace-129">Zdefiniuj nową metodę niewirtualną implementacji tych członków, którzy Ukryj implementacji klasy podstawowej</span><span class="sxs-lookup"><span data-stu-id="e8ace-129">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="e8ace-130">Klasa pochodna można zastąpić składowej klasy bazowej, tylko wtedy, gdy składowej klasy bazowej jest zadeklarowany jako [wirtualnego](../../../csharp/language-reference/keywords/virtual.md) lub [abstrakcyjne](../../../csharp/language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="e8ace-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../../csharp/language-reference/keywords/virtual.md) or [abstract](../../../csharp/language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="e8ace-131">Należy użyć pochodnej elementu członkowskiego [zastąpienia](../../../csharp/language-reference/keywords/override.md) — słowo kluczowe, aby jawnie wskazać, że metoda jest przeznaczona do wzięcia udziału w wywołaniu wirtualnego.</span><span class="sxs-lookup"><span data-stu-id="e8ace-131">The derived member must use the [override](../../../csharp/language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="e8ace-132">Poniższy kod stanowi przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-132">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#20)]  
  
 <span data-ttu-id="e8ace-133">Pola nie mogą być wirtualne; tylko metody, właściwości, zdarzeń i indeksatory mogą być wirtualne.</span><span class="sxs-lookup"><span data-stu-id="e8ace-133">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="e8ace-134">Ten element członkowski w klasie pochodnej przeciążono wirtualna elementu członkowskiego, nosi nawet wtedy, gdy wystąpienie tej klasy jest uzyskiwany jako wystąpienia klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="e8ace-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="e8ace-135">Poniższy kod stanowi przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-135">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#21)]  
  
 <span data-ttu-id="e8ace-136">Włącz klasy pochodne, aby rozszerzyć klasę bazową, bez konieczności korzystania z implementacji klasy podstawowej metody, właściwości i metod wirtualnych.</span><span class="sxs-lookup"><span data-stu-id="e8ace-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="e8ace-137">Aby uzyskać więcej informacji, zobacz [przechowywanie wersji przesłonięć i nowych słów kluczowych](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="e8ace-137">For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="e8ace-138">Interfejs zapewnia innym sposobem zdefiniowania metody lub zestaw metod, których implementacja pozostanie w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="e8ace-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="e8ace-139">Więcej informacji znajdziesz w artykule [Interfejsy](../../../csharp/programming-guide/interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="e8ace-139">For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="e8ace-140">Ukrywanie składowych klasy bazowej dla nowych członków</span><span class="sxs-lookup"><span data-stu-id="e8ace-140">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="e8ace-141">Jeśli chcesz pochodnej elementów członkowskich mają taką samą nazwę jak element członkowski w klasie bazowej, ale chcesz, aby wziąć udział w wirtualnych wywołania on, możesz użyć [nowe](../../../csharp/language-reference/keywords/new.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="e8ace-141">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../../csharp/language-reference/keywords/new.md) keyword.</span></span> <span data-ttu-id="e8ace-142">`new` — Słowo kluczowe jest umieszczany przed zwracanym typem składowej klasy, która jest zastępowany.</span><span class="sxs-lookup"><span data-stu-id="e8ace-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="e8ace-143">Poniższy kod stanowi przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-143">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#18)]  
  
 <span data-ttu-id="e8ace-144">Nadal jest możliwy członków ukrytej klasy bazowej z poziomu kodu klienta przez rzutowanie wystąpienie klasy pochodnej do wystąpienia klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="e8ace-144">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="e8ace-145">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-145">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#19)]  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="e8ace-146">Uniemożliwia zastępowanie wirtualnych elementów członkowskich klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="e8ace-146">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="e8ace-147">Wirtualne elementy członkowskie nadal wirtualnego przez czas nieokreślony, niezależnie od tego, jak wiele klas zostały zadeklarowane między wirtualna elementu członkowskiego i klasy, która pierwotnie zadeklarowała go.</span><span class="sxs-lookup"><span data-stu-id="e8ace-147">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="e8ace-148">Jeśli klasy A deklaruje wirtualna elementu członkowskiego i klasy B pochodzi od A, a klasa C pochodzi od B, klasa C dziedziczy wirtualna elementu członkowskiego i włączono opcję, aby go zastąpić, niezależnie od tego, czy klasy B podana zastąpienia dla tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="e8ace-148">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="e8ace-149">Poniższy kod stanowi przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-149">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#22)]  
  
 <span data-ttu-id="e8ace-150">Klasy pochodnej można zatrzymać dziedziczenie wirtualne od zadeklarowania zastąpienia jako [zapieczętowanego](../../../csharp/language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="e8ace-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../../csharp/language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="e8ace-151">Wymaga to umieszczenie `sealed` — słowo kluczowe przed `override` — słowo kluczowe w deklaracji członka klasy.</span><span class="sxs-lookup"><span data-stu-id="e8ace-151">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="e8ace-152">Poniższy kod stanowi przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-152">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#24)]  
  
 <span data-ttu-id="e8ace-153">W poprzednim przykładzie, Metoda `DoWork` nie jest już wirtualnych do dowolnej klasie pochodnej C. Nadal jest wirtualna dla wystąpienia elementu C, nawet wtedy, gdy są one rzutowane na typ B lub typ metody zapieczętowane A. może być zastąpiony przez klasy pochodne przy użyciu `new` — słowo kluczowe, co ilustruje poniższy przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#25)]  
  
 <span data-ttu-id="e8ace-154">W tym przypadku jeśli `DoWork` jest wywoływana w D przy użyciu zmiennej typu D, nowe `DoWork` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="e8ace-154">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="e8ace-155">Jeśli zmienna typu C, B i A umożliwia dostęp do wystąpienia D, wywołanie `DoWork` będzie zgodna z zasadami dziedziczenie wirtualne routingu wywołań do implementacji `DoWork` klasy C.</span><span class="sxs-lookup"><span data-stu-id="e8ace-155">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="e8ace-156">Uzyskiwanie dostępu do wirtualnych elementów członkowskich klasy podstawowej w klasach pochodnych</span><span class="sxs-lookup"><span data-stu-id="e8ace-156">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="e8ace-157">Klasa pochodna, która została zastąpiona bądź przesłonięcia metody lub właściwości mogą nadal uzyskiwać dostęp do metody lub właściwości w klasie bazowej, przy użyciu `base` — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="e8ace-157">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="e8ace-158">Poniższy kod stanowi przykład:</span><span class="sxs-lookup"><span data-stu-id="e8ace-158">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#26)]  
  
 <span data-ttu-id="e8ace-159">Aby uzyskać więcej informacji, zobacz [podstawowy](../../../csharp/language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="e8ace-159">For more information, see [base](../../../csharp/language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e8ace-160">Zalecane jest, że wirtualne elementy członkowskie używać `base` wywoływały implementację klasy bazowej tego członka w ich własnych implementacji.</span><span class="sxs-lookup"><span data-stu-id="e8ace-160">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="e8ace-161">Umożliwienie zachowanie klasy bazowej, występują umożliwia klasy pochodnej skoncentrować się na implementowanie zachowania specyficzne dla klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="e8ace-161">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="e8ace-162">Jeśli Implementacja klasy bazowej nie jest wywoływana, to do klasy pochodnej, aby ich zachowanie zgodne z zachowaniem klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="e8ace-162">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="e8ace-163">W tej sekcji</span><span class="sxs-lookup"><span data-stu-id="e8ace-163">In This Section</span></span>  
  
-   [<span data-ttu-id="e8ace-164">Przechowywanie wersji przesłonięć i nowych słów kluczowych</span><span class="sxs-lookup"><span data-stu-id="e8ace-164">Versioning with the Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="e8ace-165">Użycie przesłonięć i nowych słów kluczowych</span><span class="sxs-lookup"><span data-stu-id="e8ace-165">Knowing When to Use Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="e8ace-166">Instrukcje: Przesłanianie metody ToString</span><span class="sxs-lookup"><span data-stu-id="e8ace-166">How to: Override the ToString Method</span></span>](../../../csharp/programming-guide/classes-and-structs/how-to-override-the-tostring-method.md)  
  
## <a name="see-also"></a><span data-ttu-id="e8ace-167">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="e8ace-167">See also</span></span>

- [<span data-ttu-id="e8ace-168">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="e8ace-168">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="e8ace-169">Dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="e8ace-169">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="e8ace-170">Klasy abstrakcyjne i zapieczętowane oraz elementy członkowskie klas</span><span class="sxs-lookup"><span data-stu-id="e8ace-170">Abstract and Sealed Classes and Class Members</span></span>](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="e8ace-171">Metody</span><span class="sxs-lookup"><span data-stu-id="e8ace-171">Methods</span></span>](../../../csharp/programming-guide/classes-and-structs/methods.md)
- [<span data-ttu-id="e8ace-172">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="e8ace-172">Events</span></span>](../../../csharp/programming-guide/events/index.md)
- [<span data-ttu-id="e8ace-173">Właściwości</span><span class="sxs-lookup"><span data-stu-id="e8ace-173">Properties</span></span>](../../../csharp/programming-guide/classes-and-structs/properties.md)
- [<span data-ttu-id="e8ace-174">Indeksatory</span><span class="sxs-lookup"><span data-stu-id="e8ace-174">Indexers</span></span>](../../../csharp/programming-guide/indexers/index.md)
- [<span data-ttu-id="e8ace-175">Typy</span><span class="sxs-lookup"><span data-stu-id="e8ace-175">Types</span></span>](../../../csharp/programming-guide/types/index.md)
