---
title: Typy anonimowe (Przewodnik programowania w języku C#)
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: b732de508c8738de5e5e55168a6e17a1d88a3b02
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/06/2018
ms.locfileid: "43885882"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="8a317-102">Typy anonimowe (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="8a317-102">Anonymous Types (C# Programming Guide)</span></span>
<span data-ttu-id="8a317-103">Typy anonimowe umożliwiają wygodne do hermetyzacji zbiór właściwości tylko do odczytu w jeden obiekt bez konieczności jawne zdefiniowanie typu najpierw.</span><span class="sxs-lookup"><span data-stu-id="8a317-103">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="8a317-104">Nazwa typu jest generowanych przez kompilator i nie jest dostępna na poziomie kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="8a317-104">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="8a317-105">Typ każdej właściwości jest wnioskowany przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="8a317-105">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="8a317-106">Typy anonimowe są tworzone przy użyciu [nowe](../../../csharp/language-reference/keywords/new.md) operator wraz z inicjatora obiektu.</span><span class="sxs-lookup"><span data-stu-id="8a317-106">You create anonymous types by using the [new](../../../csharp/language-reference/keywords/new.md) operator together with an object initializer.</span></span> <span data-ttu-id="8a317-107">Aby uzyskać więcej informacji na temat inicjatorów obiektów zobacz [inicjatory obiektów i kolekcji](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="8a317-107">For more information about object initializers, see [Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="8a317-108">Poniższy przykład przedstawia typ anonimowy, który jest inicjowany za pomocą dwie właściwości o nazwie `Amount` i `Message`.</span><span class="sxs-lookup"><span data-stu-id="8a317-108">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="8a317-109">Typy anonimowe są zazwyczaj używane w [wybierz](../../../csharp/language-reference/keywords/select-clause.md) klauzula w wyrażeniu zapytania do zwrócenia podzbiór właściwości z każdego obiektu w sekwencji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="8a317-109">Anonymous types typically are used in the [select](../../../csharp/language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="8a317-110">Aby uzyskać więcej informacji o zapytaniach, zobacz [wyrażenia zapytań LINQ](../../../csharp/programming-guide/linq-query-expressions/index.md).</span><span class="sxs-lookup"><span data-stu-id="8a317-110">For more information about queries, see [LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md).</span></span>  
  
 <span data-ttu-id="8a317-111">Typy anonimowe zawierają co najmniej jeden publiczny właściwości tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="8a317-111">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="8a317-112">Nie innych rodzajów elementów członkowskich klasy takich jak metody lub zdarzenia, są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="8a317-112">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="8a317-113">Wyrażenie, które służy do inicjowania właściwości nie może być `null`, funkcja anonimowa lub typ wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="8a317-113">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="8a317-114">Najbardziej typowym scenariuszem jest do zainicjowania typu anonimowego z właściwościami z innego typu.</span><span class="sxs-lookup"><span data-stu-id="8a317-114">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="8a317-115">W poniższym przykładzie przyjęto założenie, że istnieje klasa, która nosi nazwę `Product`.</span><span class="sxs-lookup"><span data-stu-id="8a317-115">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="8a317-116">Klasa `Product` obejmuje `Color` i `Price` właściwości wraz z innych właściwości, które nie są zainteresowani.</span><span class="sxs-lookup"><span data-stu-id="8a317-116">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="8a317-117">Zmienna `products` to zbiór `Product` obiektów.</span><span class="sxs-lookup"><span data-stu-id="8a317-117">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="8a317-118">Deklaracja typu anonimowego zaczyna się od `new` — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="8a317-118">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="8a317-119">Deklaracja inicjuje nowy typ, który używa tylko dwie właściwości z `Product`.</span><span class="sxs-lookup"><span data-stu-id="8a317-119">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="8a317-120">Powoduje to mniejszą ilość danych, które mają zostać zwrócone w zapytaniu.</span><span class="sxs-lookup"><span data-stu-id="8a317-120">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="8a317-121">Jeśli nie określisz nazwy elementów członkowskich w typu anonimowego, kompilator zapewnia składowe typu anonimowego taką samą nazwę jak właściwość używana do ich inicjowania.</span><span class="sxs-lookup"><span data-stu-id="8a317-121">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="8a317-122">Należy podać nazwę właściwości, który jest inicjowany za pomocą wyrażenia, jak pokazano w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8a317-122">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="8a317-123">W poniższym przykładzie są nazwami właściwości typu anonimowego `Color` i `Price`.</span><span class="sxs-lookup"><span data-stu-id="8a317-123">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/anonymous-types_1.cs)]  
  
 <span data-ttu-id="8a317-124">Zazwyczaj, gdy używasz typu anonimowego można zainicjować zmiennej został zadeklarowany zmiennej jako niejawnie typizowanej zmiennej lokalnej za pomocą [var](../../../csharp/language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="8a317-124">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../../csharp/language-reference/keywords/var.md).</span></span> <span data-ttu-id="8a317-125">Nie można określić nazwę typu w deklaracji zmiennej, ponieważ tylko kompilator ma dostęp do podstawowej nazwy typu anonimowego.</span><span class="sxs-lookup"><span data-stu-id="8a317-125">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="8a317-126">Aby uzyskać więcej informacji na temat `var`, zobacz [niejawnie wpisane zmienne lokalne](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="8a317-126">For more information about `var`, see [Implicitly Typed Local Variables](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="8a317-127">Łącząc niejawnie typizowanej zmiennej lokalnej i niejawnie typizowana tablica, można utworzyć tablicy anonimowo typizowanych elementów, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8a317-127">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="8a317-128">Uwagi</span><span class="sxs-lookup"><span data-stu-id="8a317-128">Remarks</span></span>  
 <span data-ttu-id="8a317-129">Typy anonimowe są [klasy](../../../csharp/language-reference/keywords/class.md) typy, które pochodzą bezpośrednio z [obiektu](../../../csharp/language-reference/keywords/object.md), i nie można rzutować do dowolnego typu z wyjątkiem [obiektu](../../../csharp/language-reference/keywords/object.md).</span><span class="sxs-lookup"><span data-stu-id="8a317-129">Anonymous types are [class](../../../csharp/language-reference/keywords/class.md) types that derive directly from [object](../../../csharp/language-reference/keywords/object.md), and that cannot be cast to any type except [object](../../../csharp/language-reference/keywords/object.md).</span></span> <span data-ttu-id="8a317-130">Kompilator zapewnia nazwę dla każdego typu anonimowego, mimo że aplikacja nie można do niego dostęp.</span><span class="sxs-lookup"><span data-stu-id="8a317-130">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="8a317-131">Z punktu widzenia środowiska uruchomieniowego języka wspólnego typu anonimowego nie różni się od innego typu odwołania.</span><span class="sxs-lookup"><span data-stu-id="8a317-131">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="8a317-132">Jeśli co najmniej dwóch inicjatory obiekt anonimowy w zestawie, należy określić sekwencję właściwości, które znajdują się w tej samej kolejności i mają takie same nazwy i typy, kompilator traktuje obiektów jako wystąpienia tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="8a317-132">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="8a317-133">Współużytkują one te same informacje o typie wygenerowanym przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="8a317-133">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="8a317-134">Nie można zadeklarować pola, właściwości, zdarzenia lub zwracany typ metody jako mające typ anonimowy.</span><span class="sxs-lookup"><span data-stu-id="8a317-134">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="8a317-135">Podobnie nie można zadeklarować formalny parametr metody, właściwości, Konstruktor lub indeksator jako mające typ anonimowy.</span><span class="sxs-lookup"><span data-stu-id="8a317-135">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="8a317-136">Aby przekazać typu anonimowego lub kolekcję, która zawiera typy anonimowe jako argument do metody, można zadeklarować parametru jako obiekt typu.</span><span class="sxs-lookup"><span data-stu-id="8a317-136">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="8a317-137">Jednak w ten sposób pozbawia silne wpisywanie.</span><span class="sxs-lookup"><span data-stu-id="8a317-137">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="8a317-138">Jeśli należy przechowywać wyniki zapytania lub przekazywać je poza granice metody, należy wziąć pod uwagę przy użyciu zwykłej nazwanej struktury lub klasy zamiast typu anonimowego.</span><span class="sxs-lookup"><span data-stu-id="8a317-138">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="8a317-139">Ponieważ <xref:System.Object.Equals%2A> i <xref:System.Object.GetHashCode%2A> metod anonimowych typów są definiowane w kategoriach `Equals` i `GetHashCode` metody, właściwości dwóch wystąpień tego samego typu anonimowego są takie same, tylko wtedy, gdy ich właściwości są takie same.</span><span class="sxs-lookup"><span data-stu-id="8a317-139">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8a317-140">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="8a317-140">See Also</span></span>

- [<span data-ttu-id="8a317-141">Przewodnik programowania w języku C#</span><span class="sxs-lookup"><span data-stu-id="8a317-141">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
- [<span data-ttu-id="8a317-142">Inicjatory obiektów i kolekcji</span><span class="sxs-lookup"><span data-stu-id="8a317-142">Object and Collection Initializers</span></span>](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)  
- [<span data-ttu-id="8a317-143">Wprowadzenie do korzystania z LINQ w C#</span><span class="sxs-lookup"><span data-stu-id="8a317-143">Getting Started with LINQ in C#</span></span>](../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)  
- [<span data-ttu-id="8a317-144">Wyrażenia zapytań LINQ</span><span class="sxs-lookup"><span data-stu-id="8a317-144">LINQ Query Expressions</span></span>](../../../csharp/programming-guide/linq-query-expressions/index.md)
