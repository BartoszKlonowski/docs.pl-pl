---
title: Przechowywanie wersji za pomocą słów kluczowych zastępowania i nowych — przewodnik programowania C#
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
ms.openlocfilehash: 089d5d7c7a95e2de4629f53255d9d9790fd5508a
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "75705395"
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="c3b1a-102">Przechowywanie wersji przesłonięć i nowych słów kluczowych (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="c3b1a-102">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="c3b1a-103">Język Języka C# został zaprojektowany tak, aby przechowywanie wersji między klasami [podstawowymi](../../language-reference/keywords/base.md) i pochodnymi w różnych bibliotekach może ewoluować i utrzymywać zgodność z poprzednimi wersjami.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-103">The C# language is designed so that versioning between [base](../../language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="c3b1a-104">Oznacza to na przykład, że wprowadzenie nowego elementu członkowskiego w [klasie podstawowej](../../language-reference/keywords/class.md) o tej samej nazwie jako element członkowski w klasie pochodnej jest całkowicie obsługiwany przez C# i nie prowadzi do nieoczekiwanego zachowania.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-104">This means, for example, that the introduction of a new member in a base [class](../../language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="c3b1a-105">Oznacza to również, że klasa musi jawnie stwierdzić, czy metoda ma zastąpić dziedziczoną metodę, czy też metoda jest nową metodą, która ukrywa metodę dziedziczoną o podobnej nazwie.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-105">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="c3b1a-106">W języku C#klasy pochodne mogą zawierać metody o tej samej nazwie co metody klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-106">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  
  
- <span data-ttu-id="c3b1a-107">Metoda klasy podstawowej musi być zdefiniowana [wirtualna](../../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="c3b1a-107">The base class method must be defined [virtual](../../language-reference/keywords/virtual.md).</span></span>  
  
- <span data-ttu-id="c3b1a-108">Jeśli metoda w klasie pochodnej nie jest poprzedzona [nowymi](../../language-reference/keywords/new-modifier.md) lub [zastąpić](../../language-reference/keywords/override.md) słowa kluczowe, kompilator `new` wyda ostrzeżenie i metoda będzie zachowywać się tak, jakby słowo kluczowe były obecne.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-108">If the method in the derived class is not preceded by [new](../../language-reference/keywords/new-modifier.md) or [override](../../language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
- <span data-ttu-id="c3b1a-109">Jeśli metoda w klasie pochodnej jest `new` poprzedzona słowem kluczowym, metoda jest definiowana jako niezależna od metody w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
- <span data-ttu-id="c3b1a-110">Jeśli metoda w klasie pochodnej jest `override` poprzedzona słowem kluczowym, obiekty klasy pochodnej wywoła tę metodę zamiast metody klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  
  
- <span data-ttu-id="c3b1a-111">Metoda klasy podstawowej można wywołać z poziomu `base` klasy pochodnej przy użyciu słowa kluczowego.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-111">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
- <span data-ttu-id="c3b1a-112">Słowa `override` `virtual`kluczowe `new` , i słowa kluczowe mogą być również stosowane do właściwości, indeksatorów i zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-112">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="c3b1a-113">Domyślnie metody Języka C# nie są wirtualne.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-113">By default, C# methods are not virtual.</span></span> <span data-ttu-id="c3b1a-114">Jeśli metoda jest zadeklarowana jako wirtualna, każda klasa dziedzicząca metodę można zaimplementować własną wersję.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-114">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="c3b1a-115">Aby metoda była wirtualna, `virtual` modyfikator jest używany w deklaracji metody klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-115">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="c3b1a-116">Klasa pochodna może następnie zastąpić podstawową metodę `override` wirtualną przy użyciu słowa kluczowego `new` lub ukryć metodę wirtualną w klasie podstawowej przy użyciu słowa kluczowego.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-116">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="c3b1a-117">Jeśli nie `override` określono słowa `new` kluczowego ani słowa kluczowego, kompilator wyda ostrzeżenie, a metoda w klasie pochodnej ukryje metodę w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-117">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="c3b1a-118">Aby zademonstrować to w praktyce, załóżmy przez `GraphicsClass`chwilę, że firma A utworzyła klasę o nazwie , której używa program.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-118">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="c3b1a-119">Oto: `GraphicsClass`</span><span class="sxs-lookup"><span data-stu-id="c3b1a-119">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#27)]  
  
 <span data-ttu-id="c3b1a-120">Firma używa tej klasy i używasz jej do uzyskania własnej klasy, dodając nową metodę:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-120">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#28)]  
  
 <span data-ttu-id="c3b1a-121">Aplikacja jest używana bez problemów, dopóki firma A `GraphicsClass`nie wyda nowej wersji , która przypomina następujący kod:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-121">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#29)]  
  
 <span data-ttu-id="c3b1a-122">Nowa wersja `GraphicsClass` teraz zawiera metodę `DrawRectangle`o nazwie .</span><span class="sxs-lookup"><span data-stu-id="c3b1a-122">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="c3b1a-123">Początkowo nic się nie dzieje.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-123">Initially, nothing occurs.</span></span> <span data-ttu-id="c3b1a-124">Nowa wersja jest nadal binarna kompatybilna ze starą wersją.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-124">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="c3b1a-125">Każde wdrożone oprogramowanie będzie nadal działać, nawet jeśli nowa klasa jest zainstalowana w tych systemach komputerowych.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-125">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="c3b1a-126">Wszelkie istniejące wywołania `DrawRectangle` metody będzie nadal odwoływać się do wersji, w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-126">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="c3b1a-127">Jednak gdy tylko ponownie skompilować aplikację przy użyciu `GraphicsClass`nowej wersji , otrzymasz ostrzeżenie od kompilatora, CS0108.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-127">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="c3b1a-128">To ostrzeżenie informuje, że należy wziąć `DrawRectangle` pod uwagę, jak chcesz, aby metoda zachowywała się w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-128">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="c3b1a-129">Jeśli chcesz, aby metoda zastępowała nową metodę `override` klasy podstawowej, użyj słowa kluczowego:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-129">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#30)]  
  
 <span data-ttu-id="c3b1a-130">Słowo `override` kluczowe upewnia się, `YourDerivedGraphicsClass` że wszystkie obiekty pochodzące `DrawRectangle`z użyje wersji klasy pochodnej .</span><span class="sxs-lookup"><span data-stu-id="c3b1a-130">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="c3b1a-131">Obiekty pochodzące `YourDerivedGraphicsClass` z nadal można uzyskać `DrawRectangle` dostęp do wersji klasy podstawowej za pomocą podstawowego słowa kluczowego:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-131">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#44)]  
  
 <span data-ttu-id="c3b1a-132">Jeśli nie chcesz, aby metoda zastąpić nową metodę klasy podstawowej, mają zastosowanie następujące zagadnienia.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-132">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="c3b1a-133">Aby uniknąć pomyłek między dwiema metodami, można zmienić nazwę metody.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-133">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="c3b1a-134">Może to być czasochłonne i podatne na błędy, a w niektórych przypadkach po prostu nie praktyczne.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-134">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="c3b1a-135">Jednak jeśli projekt jest stosunkowo mały, można użyć opcji refaktoryzacji programu Visual Studio, aby zmienić nazwę metody.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-135">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="c3b1a-136">Aby uzyskać więcej informacji, zobacz [Refaktoryzowanie klas i typów (projektant klas)](/visualstudio/ide/class-designer/refactoring-classes-and-types).</span><span class="sxs-lookup"><span data-stu-id="c3b1a-136">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/class-designer/refactoring-classes-and-types).</span></span>  
  
 <span data-ttu-id="c3b1a-137">Alternatywnie można zapobiec ostrzeżenie przy `new` użyciu słowa kluczowego w definicji klasy pochodnej:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-137">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#31)]  
  
 <span data-ttu-id="c3b1a-138">Za `new` pomocą słowa kluczowego informuje kompilator, że definicja ukrywa definicji, która jest zawarta w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-138">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="c3b1a-139">Jest to zachowanie domyślne.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-139">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="c3b1a-140">Zastępowanie i wybór metody</span><span class="sxs-lookup"><span data-stu-id="c3b1a-140">Override and Method Selection</span></span>  
 <span data-ttu-id="c3b1a-141">Gdy metoda jest nazwany na klasy, kompilator C# wybiera najlepszą metodę do wywołania, jeśli więcej niż jedna metoda jest zgodna z wywołaniem, na przykład, gdy istnieją dwie metody o tej samej nazwie i parametry, które są zgodne z parametrem przekazany.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-141">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="c3b1a-142">Następujące metody byłyby zgodne:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-142">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#32)]  
  
 <span data-ttu-id="c3b1a-143">Gdy `DoWork` jest wywoływana `Derived`na wystąpienie , kompilator C# najpierw spróbuje `DoWork` dokonać `Derived`połączenia zgodne z wersjami zadeklarowane pierwotnie na .</span><span class="sxs-lookup"><span data-stu-id="c3b1a-143">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="c3b1a-144">Metody zastępowania nie są traktowane jako zadeklarowane w klasie, są to nowe implementacje metody zadeklarowanej w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-144">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="c3b1a-145">Tylko wtedy kompilator C# nie może dopasować `Derived` wywołania metody do oryginalnej metody na będzie próbował dopasować wywołanie do metody zastąpione o tej samej nazwie i parametrów zgodnych.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-145">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="c3b1a-146">Przykład:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-146">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#33)]  
  
 <span data-ttu-id="c3b1a-147">Ponieważ zmienna `val` może zostać przekonwertowana na podwójnie niejawnie, kompilator C# wywołuje `DoWork(double)` zamiast . `DoWork(int)`</span><span class="sxs-lookup"><span data-stu-id="c3b1a-147">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="c3b1a-148">Istnieją dwa sposoby, aby tego uniknąć.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-148">There are two ways to avoid this.</span></span> <span data-ttu-id="c3b1a-149">Najpierw należy unikać deklarowania nowych metod o takiej samej nazwie jak metody wirtualne.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-149">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="c3b1a-150">Po drugie można poinstruować kompilator C# wywołać metodę wirtualną, wykonując wyszukiwanie `Derived` `Base`listy metod klasy podstawowej przez rzutowanie wystąpienia do .</span><span class="sxs-lookup"><span data-stu-id="c3b1a-150">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="c3b1a-151">Ponieważ metoda jest wirtualna, `DoWork(int)` `Derived` zostanie wywołana implementacja on.</span><span class="sxs-lookup"><span data-stu-id="c3b1a-151">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="c3b1a-152">Przykład:</span><span class="sxs-lookup"><span data-stu-id="c3b1a-152">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#34)]  
  
 <span data-ttu-id="c3b1a-153">Aby uzyskać więcej `new` `override`przykładów i zobacz [Wiedza, kiedy używać zastępowania i nowe słowa kluczowe](./knowing-when-to-use-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="c3b1a-153">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](./knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c3b1a-154">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="c3b1a-154">See also</span></span>

- [<span data-ttu-id="c3b1a-155">Przewodnik programowania języka C#</span><span class="sxs-lookup"><span data-stu-id="c3b1a-155">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="c3b1a-156">Klasy i struktury</span><span class="sxs-lookup"><span data-stu-id="c3b1a-156">Classes and Structs</span></span>](./index.md)
- [<span data-ttu-id="c3b1a-157">Metody</span><span class="sxs-lookup"><span data-stu-id="c3b1a-157">Methods</span></span>](./methods.md)
- [<span data-ttu-id="c3b1a-158">Dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="c3b1a-158">Inheritance</span></span>](./inheritance.md)
