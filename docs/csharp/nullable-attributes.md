---
title: Uaktualnianie interfejsów API dla typów odwołań z wartościami nullable z atrybutami definiuujającym oczekiwania dotyczące wartości null
description: Naucz się używać atrybutów opisowych AllowNull, DisallowNull, MaybeNull, NotNull i innych, aby w pełni opisać stan zerowy interfejsów API.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: 7f78bd0224f93b4b9dcc2b9d4e3577db06497907
ms.sourcegitcommit: c91110ef6ee3fedb591f3d628dc17739c4a7071e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/15/2020
ms.locfileid: "81389594"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="b3b27-103">Aktualizowanie bibliotek w celu używania typów odwołań z regułami zbędnymi wartościami null i przekazywanie reguł nullable wywołującym</span><span class="sxs-lookup"><span data-stu-id="b3b27-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="b3b27-104">Dodanie [typów odwołań nullable](nullable-references.md) oznacza, że `null` można zadeklarować, czy wartość jest dozwolona lub oczekiwana dla każdej zmiennej.</span><span class="sxs-lookup"><span data-stu-id="b3b27-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="b3b27-105">Ponadto można zastosować liczbę atrybutów: `AllowNull` `DisallowNull`, `MaybeNull` `NotNull`, `NotNullWhen` `MaybeNullWhen`, `NotNullIfNotNull` , , i całkowicie opisać null stany argumentów i zwracanych wartości.</span><span class="sxs-lookup"><span data-stu-id="b3b27-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="b3b27-106">Zapewnia to wspaniałe doświadczenie podczas pisania kodu.</span><span class="sxs-lookup"><span data-stu-id="b3b27-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="b3b27-107">Otrzymasz ostrzeżenia, jeśli zmienna nienastępna null może być ustawiona na `null`.</span><span class="sxs-lookup"><span data-stu-id="b3b27-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="b3b27-108">Otrzymasz ostrzeżenia, jeśli zmienna nullable nie jest zaznaczona zerem przed wyłuskaniem go.</span><span class="sxs-lookup"><span data-stu-id="b3b27-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="b3b27-109">Aktualizowanie bibliotek może zająć trochę czasu, ale wypłaty są tego warte.</span><span class="sxs-lookup"><span data-stu-id="b3b27-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="b3b27-110">Im więcej informacji, które podasz `null` kompilatorowi o *tym, kiedy* wartość jest dozwolona lub zabroniona, otrzymają lepsze ostrzeżenia, które otrzymają użytkownicy interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="b3b27-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="b3b27-111">Zacznijmy od znanego przykładu.</span><span class="sxs-lookup"><span data-stu-id="b3b27-111">Let's start with a familiar example.</span></span> <span data-ttu-id="b3b27-112">Wyobraź sobie, że biblioteka ma następujący interfejs API do pobierania ciągu zasobu:</span><span class="sxs-lookup"><span data-stu-id="b3b27-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="b3b27-113">W poprzednim przykładzie `Try*` następuje znane wzorzec w .NET.</span><span class="sxs-lookup"><span data-stu-id="b3b27-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="b3b27-114">Istnieją dwa argumenty odwołania dla `key` tego `message` interfejsu API: i parametr.</span><span class="sxs-lookup"><span data-stu-id="b3b27-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="b3b27-115">Ten interfejs API ma następujące reguły odnoszące się do nieważności tych argumentów:</span><span class="sxs-lookup"><span data-stu-id="b3b27-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="b3b27-116">Dzwoniący nie powinni `null` przechodzić `key`jako argument dla .</span><span class="sxs-lookup"><span data-stu-id="b3b27-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="b3b27-117">Osoby dzwoniące mogą przekazać `null` zmienną, `message`której wartość jest argumentem dla .</span><span class="sxs-lookup"><span data-stu-id="b3b27-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="b3b27-118">Jeśli `TryGetMessage` metoda `true`zwraca , `message` wartość nie jest null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="b3b27-119">Jeśli zwracana `false,` wartość jest `message` wartością (a jej stan zerowy) jest null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="b3b27-120">Reguła `key` dla może być całkowicie wyrażona `key` przez typ zmiennej: powinien być typem odwołania nienastępnego.</span><span class="sxs-lookup"><span data-stu-id="b3b27-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="b3b27-121">Parametr `message` jest bardziej złożony.</span><span class="sxs-lookup"><span data-stu-id="b3b27-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="b3b27-122">Pozwala `null` jako argument, ale gwarantuje, że `out` na sukces, że argument nie jest null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="b3b27-123">W przypadku tych scenariuszy potrzebujesz bogatszego słownictwa, aby opisać oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="b3b27-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="b3b27-124">Aktualizowanie biblioteki dla odwołań nullable wymaga `?` więcej niż posypywanie na niektóre zmienne i nazwy typów.</span><span class="sxs-lookup"><span data-stu-id="b3b27-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="b3b27-125">W poprzednim przykładzie pokazano, że należy zbadać interfejsy API i należy wziąć pod uwagę oczekiwania dla każdego argumentu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="b3b27-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="b3b27-126">Należy wziąć pod uwagę gwarancje `out` dla `ref` wartości zwracanej i wszelkie lub argumenty po powrocie metody.</span><span class="sxs-lookup"><span data-stu-id="b3b27-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="b3b27-127">Następnie komunikować te reguły do kompilatora, a kompilator zapewni ostrzeżenia, gdy wywołania nie są zgodne z tymi regułami.</span><span class="sxs-lookup"><span data-stu-id="b3b27-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="b3b27-128">Ta praca wymaga czasu.</span><span class="sxs-lookup"><span data-stu-id="b3b27-128">This work takes time.</span></span> <span data-ttu-id="b3b27-129">Zacznijmy od strategii, aby biblioteka lub aplikacja nullable-aware, przy jednoczesnym równoważeniu innych wymagań i ujednolików.</span><span class="sxs-lookup"><span data-stu-id="b3b27-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements and deliverables.</span></span> <span data-ttu-id="b3b27-130">Zobaczysz, jak zrównoważyć bieżące gonie, umożliwiając typy odwołań powodujących wartość null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="b3b27-131">Poznasz wyzwania dotyczące definicji typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="b3b27-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="b3b27-132">Nauczysz się stosować atrybuty do opisywania warunków wstępnych i postowych w poszczególnych interfejsach API.</span><span class="sxs-lookup"><span data-stu-id="b3b27-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="b3b27-133">Wybieranie strategii dla typów odwołań z dopuszczaniem do wartości null</span><span class="sxs-lookup"><span data-stu-id="b3b27-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="b3b27-134">Pierwszym wyborem jest to, czy typy odwołań nullable powinny być domyślnie włączone lub wyłączone.</span><span class="sxs-lookup"><span data-stu-id="b3b27-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="b3b27-135">Masz dwie strategie:</span><span class="sxs-lookup"><span data-stu-id="b3b27-135">You have two strategies:</span></span>

- <span data-ttu-id="b3b27-136">Włącz typy odwołań nullable dla całego projektu i wyłącz go w kodzie, który nie jest gotowy.</span><span class="sxs-lookup"><span data-stu-id="b3b27-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="b3b27-137">Włącz tylko typy odwołań z nullable dla kodu, który został o astowany dla typów odwołań zdatnymi do wartości null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="b3b27-138">Pierwsza strategia działa najlepiej podczas dodawania innych funkcji do biblioteki podczas aktualizowania go dla typów odwołań, których można anulować.</span><span class="sxs-lookup"><span data-stu-id="b3b27-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="b3b27-139">Wszystkie nowe rozwoju jest nullable świadomość.</span><span class="sxs-lookup"><span data-stu-id="b3b27-139">All new development is nullable aware.</span></span> <span data-ttu-id="b3b27-140">Podczas aktualizowania istniejącego kodu, można włączyć nullable typy odwołań w tych klasach.</span><span class="sxs-lookup"><span data-stu-id="b3b27-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="b3b27-141">Zgodnie z tą pierwszą strategią wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="b3b27-141">Following this first strategy, you do the following:</span></span>

1. <span data-ttu-id="b3b27-142">Włącz typy odwołań nullable dla `<Nullable>enable</Nullable>` całego projektu, dodając element do plików *csproj.*</span><span class="sxs-lookup"><span data-stu-id="b3b27-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="b3b27-143">Dodaj `#nullable disable` pragmę do każdego pliku źródłowego w projekcie.</span><span class="sxs-lookup"><span data-stu-id="b3b27-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="b3b27-144">Podczas pracy nad każdym plikiem usuń pragmę i zaaminuj wszelkie ostrzeżenia.</span><span class="sxs-lookup"><span data-stu-id="b3b27-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="b3b27-145">Ta pierwsza strategia ma więcej pracy z góry, aby dodać pragmy do każdego pliku.</span><span class="sxs-lookup"><span data-stu-id="b3b27-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="b3b27-146">Zaletą jest to, że każdy nowy plik kodu dodany do projektu będzie nullable włączone.</span><span class="sxs-lookup"><span data-stu-id="b3b27-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="b3b27-147">Wszelkie nowe prace będą nieważne świadomość; tylko istniejący kod musi zostać zaktualizowany.</span><span class="sxs-lookup"><span data-stu-id="b3b27-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="b3b27-148">Druga strategia działa lepiej, jeśli biblioteka jest ogólnie stabilna, a głównym celem rozwoju jest przyjęcie typów odwołań do nullable.</span><span class="sxs-lookup"><span data-stu-id="b3b27-148">The second strategy works better if the library is generally stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="b3b27-149">Typy odwołań z których można wyłączyć z wartościami null, podczas dodawać adnotacje do interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="b3b27-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="b3b27-150">Po zakończeniu można włączyć typy odwołań nullable dla całego projektu.</span><span class="sxs-lookup"><span data-stu-id="b3b27-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="b3b27-151">Zgodnie z tą drugą strategią wykonujesz następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="b3b27-151">Following this second strategy you do the following:</span></span>

1. <span data-ttu-id="b3b27-152">Dodaj `#nullable enable` pragmę do pliku, który chcesz zgłosić do null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="b3b27-153">Usuń wszelkie ostrzeżenia.</span><span class="sxs-lookup"><span data-stu-id="b3b27-153">Address any warnings.</span></span>
1. <span data-ttu-id="b3b27-154">Kontynuuj te dwa pierwsze kroki, dopóki nie dowiesz się, że cała biblioteka jest nieuprawniona.</span><span class="sxs-lookup"><span data-stu-id="b3b27-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="b3b27-155">Włącz typy nullable dla całego `<Nullable>enable</Nullable>` projektu, dodając element do plików *csproj.*</span><span class="sxs-lookup"><span data-stu-id="b3b27-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="b3b27-156">Usuń `#nullable enable` pragmy, ponieważ nie są już potrzebne.</span><span class="sxs-lookup"><span data-stu-id="b3b27-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="b3b27-157">Ta druga strategia ma mniej pracy z góry.</span><span class="sxs-lookup"><span data-stu-id="b3b27-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="b3b27-158">Kompromisem jest to, że pierwszym zadaniem podczas tworzenia nowego pliku jest dodanie pragmy i uczynienie go nullable aware.</span><span class="sxs-lookup"><span data-stu-id="b3b27-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="b3b27-159">Jeśli deweloperzy w zespole zapomnieć, że nowy kod jest teraz w zaległości pracy, aby wszystkie kodu nullable świadomość.</span><span class="sxs-lookup"><span data-stu-id="b3b27-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="b3b27-160">Która z tych strategii zostanie wybrasza, zależy od tego, jak bardzo aktywny rozwój odbywa się w twoim projekcie.</span><span class="sxs-lookup"><span data-stu-id="b3b27-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="b3b27-161">Im bardziej dojrzały i stabilny projekt, tym lepsza druga strategia.</span><span class="sxs-lookup"><span data-stu-id="b3b27-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="b3b27-162">Im więcej funkcji jest opracowywanych, tym lepsza jest pierwsza strategia.</span><span class="sxs-lookup"><span data-stu-id="b3b27-162">The more features being developed, the better the first strategy.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="b3b27-163">Czy ostrzeżenia o unieważnianiu powinny powodować zmiany w przerwaniu?</span><span class="sxs-lookup"><span data-stu-id="b3b27-163">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="b3b27-164">Przed włączeniem typów odwołań do wartości null, zmienne są uważane za *nullable oblivious*.</span><span class="sxs-lookup"><span data-stu-id="b3b27-164">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="b3b27-165">Po włączeniu typów odwołań zable null, wszystkie te zmienne są *niemożna null .*</span><span class="sxs-lookup"><span data-stu-id="b3b27-165">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="b3b27-166">Kompilator wyda ostrzeżenia, jeśli te zmienne nie są inicjowane do wartości innych niż null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-166">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="b3b27-167">Innym prawdopodobnym źródłem ostrzeżeń są zwracane wartości, gdy wartość nie została zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="b3b27-167">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="b3b27-168">Pierwszym krokiem w adresowaniu ostrzeżeń `?` kompilatora jest użycie adnotacji na typy parametrów i zwracać, aby wskazać, kiedy argumenty lub zwraca wartości mogą być null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-168">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="b3b27-169">Gdy zmienne odwołania nie może być null, oryginalna deklaracja jest poprawna.</span><span class="sxs-lookup"><span data-stu-id="b3b27-169">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="b3b27-170">Jak to zrobić, Twoim celem nie jest tylko naprawić ostrzeżenia.</span><span class="sxs-lookup"><span data-stu-id="b3b27-170">As you do this, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="b3b27-171">Ważniejszym celem jest, aby kompilator zrozumieć intencji dla potencjalnych wartości null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-171">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="b3b27-172">Podczas badania ostrzeżeń, można osiągnąć następną ważną decyzję dla biblioteki.</span><span class="sxs-lookup"><span data-stu-id="b3b27-172">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="b3b27-173">Czy chcesz rozważyć zmodyfikowanie podpisów interfejsu API, aby lepiej komunikować intencje projektu?</span><span class="sxs-lookup"><span data-stu-id="b3b27-173">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="b3b27-174">Lepszy podpis interfejsu `TryGetMessage` API dla metody badanej wcześniej może być:</span><span class="sxs-lookup"><span data-stu-id="b3b27-174">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="b3b27-175">Zwracana wartość wskazuje sukces lub niepowodzenie i przenosi wartość, jeśli wartość została znaleziona.</span><span class="sxs-lookup"><span data-stu-id="b3b27-175">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="b3b27-176">W wielu przypadkach zmiana podpisów interfejsu API może poprawić sposób przekazywania wartości null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-176">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="b3b27-177">Jednak w przypadku bibliotek publicznych lub bibliotek z dużymi bazami użytkowników może wolisz nie wprowadzać żadnych zmian podpisu interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="b3b27-177">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="b3b27-178">W tych przypadkach i innych typowych wzorcach można zastosować atrybuty, aby jaśniej `null`zdefiniować, kiedy argument lub wartość zwracana może być .</span><span class="sxs-lookup"><span data-stu-id="b3b27-178">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="b3b27-179">Niezależnie od tego, czy rozważasz zmianę powierzchni interfejsu API, prawdopodobnie okaże się, że `null` same adnotacje typu nie są wystarczające do opisywania wartości argumentów lub zwracanych wartości.</span><span class="sxs-lookup"><span data-stu-id="b3b27-179">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="b3b27-180">W tych przypadkach można zastosować atrybuty, aby jaśniej opisać interfejs API.</span><span class="sxs-lookup"><span data-stu-id="b3b27-180">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="b3b27-181">Atrybuty rozszerzają adnotacje typów</span><span class="sxs-lookup"><span data-stu-id="b3b27-181">Attributes extend type annotations</span></span>

<span data-ttu-id="b3b27-182">Dodano kilka atrybutów, aby wyrazić dodatkowe informacje o stanie null zmiennych.</span><span class="sxs-lookup"><span data-stu-id="b3b27-182">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="b3b27-183">Cały kod, który napisałeś przed C# 8 wprowadzone nullable typy odwołań był *null oblivious*.</span><span class="sxs-lookup"><span data-stu-id="b3b27-183">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="b3b27-184">Oznacza to, że każda zmienna typu odwołania może mieć wartość null, ale nie są wymagane kontrole wartości null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-184">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="b3b27-185">Gdy kod jest *nullable aware*, te reguły zmienić.</span><span class="sxs-lookup"><span data-stu-id="b3b27-185">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="b3b27-186">Typy odwołań `null` nigdy nie powinny być wartością, `null` a typy odwołań do wartości null muszą być sprawdzane przed odwołaniem.</span><span class="sxs-lookup"><span data-stu-id="b3b27-186">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="b3b27-187">Reguły interfejsów API są prawdopodobnie bardziej skomplikowane, `TryGetValue` jak widać w scenariuszu interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="b3b27-187">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="b3b27-188">Wiele interfejsów API ma bardziej złożone reguły, gdy zmienne mogą lub nie mogą być `null`.</span><span class="sxs-lookup"><span data-stu-id="b3b27-188">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="b3b27-189">W takich przypadkach użyjesz atrybutów do wyrażenia tych reguł.</span><span class="sxs-lookup"><span data-stu-id="b3b27-189">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="b3b27-190">Atrybuty opisujące semantykę interfejsu API znajdują się w artykule na [atrybuty, które wpływają na analizę nullable](./language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="b3b27-190">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="b3b27-191">Definicje ogólne i możliwość niemożności</span><span class="sxs-lookup"><span data-stu-id="b3b27-191">Generic definitions and nullability</span></span>

<span data-ttu-id="b3b27-192">Prawidłowe komunikowanie stanu null typów ogólnych i metod ogólnych wymaga szczególnej ostrożności.</span><span class="sxs-lookup"><span data-stu-id="b3b27-192">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="b3b27-193">Wynika to z faktu, że typ wartości nullable i typ odwołania nullable są zasadniczo różne.</span><span class="sxs-lookup"><span data-stu-id="b3b27-193">This stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="b3b27-194">An `int?` jest synonimem `Nullable<int>`, `string?` mając `string` na uwadze, że jest z atrybutem dodanym przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="b3b27-194">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="b3b27-195">Wynik jest, że kompilator nie może `T?` wygenerować poprawny kod bez wiedząc, czy `T` jest `class` lub . `struct`</span><span class="sxs-lookup"><span data-stu-id="b3b27-195">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="b3b27-196">Nie oznacza to, że nie można użyć typu nullable (typ wartości lub typ odwołania) jako argumentu typu dla zamkniętego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="b3b27-196">This doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="b3b27-197">Oba `List<string?>` `List<int?>` i są prawidłowe `List<T>`wystąpienia .</span><span class="sxs-lookup"><span data-stu-id="b3b27-197">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="b3b27-198">Oznacza to, że nie można `T?` używać w deklaracji klasy lub metody rodzajowej bez ograniczeń.</span><span class="sxs-lookup"><span data-stu-id="b3b27-198">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="b3b27-199">Na przykład <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> nie zostanie zmieniona, aby powrócić `T?`.</span><span class="sxs-lookup"><span data-stu-id="b3b27-199">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="b3b27-200">Można przezwyciężyć to ograniczenie, `struct` dodając `class` albo ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="b3b27-200">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="b3b27-201">Z jednym z tych ograniczeń, kompilator wie, `T` jak `T?`wygenerować kod dla obu i .</span><span class="sxs-lookup"><span data-stu-id="b3b27-201">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="b3b27-202">Można ograniczyć typy używane dla argumentu typu ogólnego, aby były typami nienastępulnymi wartością null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-202">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="b3b27-203">Można to zrobić, `notnull` dodając ograniczenie do tego argumentu typu.</span><span class="sxs-lookup"><span data-stu-id="b3b27-203">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="b3b27-204">Po zastosowaniu tego ograniczenia argument typu nie może być typem do null.</span><span class="sxs-lookup"><span data-stu-id="b3b27-204">When that constraint is applied, the type argument must not be a nullable type.</span></span>
