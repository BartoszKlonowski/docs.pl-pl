---
title: Typy krotek — C# Przewodnik
description: Dowiedz się więcej na temat typów krotek bez nazwy i nazwanych wC#
ms.date: 05/15/2018
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 7e5df8c20dbbddbe84a56883a6d2a027f32d8ff7
ms.sourcegitcommit: 628e8147ca10187488e6407dab4c4e6ebe0cac47
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/15/2019
ms.locfileid: "72319755"
---
# <a name="c-tuple-types"></a><span data-ttu-id="93251-103">C#typy krotek</span><span class="sxs-lookup"><span data-stu-id="93251-103">C# tuple types</span></span>

<span data-ttu-id="93251-104">C#krotki są typami definiowanymi przy użyciu uproszczonej składni.</span><span class="sxs-lookup"><span data-stu-id="93251-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="93251-105">Zalety obejmują prostsze składnię, reguły konwersji na podstawie liczby (nazywanej kardynalnością) i typów elementów oraz spójnych reguł dla kopii, testów równości i przypisań.</span><span class="sxs-lookup"><span data-stu-id="93251-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="93251-106">Ze kompromisem, krotki nie obsługują niektórych idiomy zorientowanych obiektowo skojarzonych z dziedziczeniem.</span><span class="sxs-lookup"><span data-stu-id="93251-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="93251-107">Możesz zapoznać się z omówieniem w sekcji dotyczącej [krotek w artykule Co nowego C# w 7,0](whats-new/csharp-7.md#tuples) artykułu.</span><span class="sxs-lookup"><span data-stu-id="93251-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="93251-108">W tym artykule poznasz reguły języka dotyczące krotek w C# 7,0 i nowszych wersjach, różne sposoby ich używania oraz wstępne wskazówki dotyczące pracy z krotkami.</span><span class="sxs-lookup"><span data-stu-id="93251-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="93251-109">Nowe funkcje krotek wymagają typów <xref:System.ValueTuple>.</span><span class="sxs-lookup"><span data-stu-id="93251-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="93251-110">Należy dodać pakiet NuGet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) , aby można go było używać na platformach, które nie zawierają typów.</span><span class="sxs-lookup"><span data-stu-id="93251-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="93251-111">Jest to podobne do innych funkcji języka, które opierają się na typach dostarczonych w środowisku.</span><span class="sxs-lookup"><span data-stu-id="93251-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="93251-112">Przykłady obejmują `async` i `await` polegające na interfejsie `INotifyCompletion` i LINQ polegające na `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="93251-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="93251-113">Jednak mechanizm dostarczania jest zmieniany, ponieważ platforma .NET staje się coraz niezależna od platformy.</span><span class="sxs-lookup"><span data-stu-id="93251-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="93251-114">.NET Framework może nie zawsze dostarczać na tym samym erze co kompilator języka.</span><span class="sxs-lookup"><span data-stu-id="93251-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="93251-115">Gdy nowe funkcje językowe korzystają z nowych typów, te typy będą dostępne jako pakiety NuGet, gdy funkcje języka są dostarczane.</span><span class="sxs-lookup"><span data-stu-id="93251-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="93251-116">Po dodaniu nowych typów do interfejsu API .NET Standard i dostarczeniu ich jako części platformy zostanie usunięte wymaganie pakietu NuGet.</span><span class="sxs-lookup"><span data-stu-id="93251-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="93251-117">Zacznijmy od powodów dodawania nowej obsługi spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="93251-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="93251-118">Metody zwracają pojedynczy obiekt.</span><span class="sxs-lookup"><span data-stu-id="93251-118">Methods return a single object.</span></span> <span data-ttu-id="93251-119">Krotki umożliwiają łatwiejsze pakowanie wielu wartości w tym pojedynczym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="93251-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="93251-120">.NET Framework ma już ogólne klasy `Tuple`.</span><span class="sxs-lookup"><span data-stu-id="93251-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="93251-121">Jednak te klasy miały dwa zasadnicze ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="93251-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="93251-122">Dla jednej z nich klasy `Tuple` o nazwie ich właściwości `Item1`, `Item2` itd.</span><span class="sxs-lookup"><span data-stu-id="93251-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="93251-123">Te nazwy nie zawierają informacji semantycznych.</span><span class="sxs-lookup"><span data-stu-id="93251-123">Those names carry no semantic information.</span></span> <span data-ttu-id="93251-124">Korzystanie z tych typów `Tuple` nie umożliwia komunikowania znaczenia każdej właściwości.</span><span class="sxs-lookup"><span data-stu-id="93251-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="93251-125">Nowe funkcje języka umożliwiają deklarowanie i używanie semantycznie zrozumiałych nazw dla elementów w spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="93251-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="93251-126">Klasy `Tuple` powodują zwiększenie wydajności, ponieważ są to typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="93251-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="93251-127">Użycie jednego z typów `Tuple` oznacza alokowanie obiektów.</span><span class="sxs-lookup"><span data-stu-id="93251-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="93251-128">W przypadku ścieżek aktywnych alokowanie wielu małych obiektów może mieć wymierny wpływ na wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="93251-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="93251-129">W związku z tym, obsługa języków w przypadku krotek wykorzystuje nowe struktury `ValueTuple`.</span><span class="sxs-lookup"><span data-stu-id="93251-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="93251-130">Aby uniknąć tych uchybień, można utworzyć `class` lub `struct`, aby przenieść wiele elementów.</span><span class="sxs-lookup"><span data-stu-id="93251-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="93251-131">Niestety, to jeszcze więcej pracy i zasłania zamiar projektowania.</span><span class="sxs-lookup"><span data-stu-id="93251-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="93251-132">Zastosowanie `struct` lub `class` oznacza, że definiujesz typ z danymi i zachowaniem.</span><span class="sxs-lookup"><span data-stu-id="93251-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="93251-133">Wiele razy, Wystarczy przechowywać wiele wartości w pojedynczym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="93251-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="93251-134">Funkcje języka i struktury ogólne `ValueTuple` wymuszają zasady, że nie można dodać żadnego zachowania (metod) do tych typów krotek.</span><span class="sxs-lookup"><span data-stu-id="93251-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="93251-135">Wszystkie typy `ValueTuple` to *modyfikowalne struktury*.</span><span class="sxs-lookup"><span data-stu-id="93251-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="93251-136">Każde pole elementu członkowskiego jest polem publicznym.</span><span class="sxs-lookup"><span data-stu-id="93251-136">Each member field is a public field.</span></span> <span data-ttu-id="93251-137">Dzięki temu są one bardzo lekkie.</span><span class="sxs-lookup"><span data-stu-id="93251-137">That makes them very lightweight.</span></span> <span data-ttu-id="93251-138">Jednak oznacza to, że nie należy używać krotek, gdzie niezmienności jest ważne.</span><span class="sxs-lookup"><span data-stu-id="93251-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="93251-139">Krotki są prostsze i bardziej elastyczne kontenery danych niż typy `class` i `struct`.</span><span class="sxs-lookup"><span data-stu-id="93251-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="93251-140">Zapoznaj się z tymi różnicami.</span><span class="sxs-lookup"><span data-stu-id="93251-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="93251-141">Krotki nazwane i nienazwane</span><span class="sxs-lookup"><span data-stu-id="93251-141">Named and unnamed tuples</span></span>

<span data-ttu-id="93251-142">Struktura `ValueTuple` zawiera pola o nazwie `Item1`, `Item2`, `Item3` i tak dalej, podobnie jak właściwości zdefiniowane w istniejących typach `Tuple`.</span><span class="sxs-lookup"><span data-stu-id="93251-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="93251-143">Te nazwy są jedynymi nazwami, których można używać w przypadku *krotek nienazwanych*.</span><span class="sxs-lookup"><span data-stu-id="93251-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="93251-144">Jeśli nie podasz żadnych alternatywnych nazw pól dla krotki, utworzona zostanie nienazwana krotka:</span><span class="sxs-lookup"><span data-stu-id="93251-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="93251-145">Krotka w poprzednim przykładzie została zainicjowana przy użyciu stałych literałów i nie będzie miała nazw elementów utworzonych przy użyciu *prognoz nazw pól krotek* w C# 7,1.</span><span class="sxs-lookup"><span data-stu-id="93251-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="93251-146">Jednak po zainicjowaniu krotki można użyć nowych funkcji języka, które zapewniają lepsze nazwy dla każdego pola.</span><span class="sxs-lookup"><span data-stu-id="93251-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="93251-147">Spowoduje to utworzenie *nazwanej krotki*.</span><span class="sxs-lookup"><span data-stu-id="93251-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="93251-148">Nazwane krotki nadal mają elementy o nazwie `Item1`, `Item2`, `Item3` i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="93251-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="93251-149">Ale mają także synonimy dla dowolnego z tych elementów, które mają nazwę.</span><span class="sxs-lookup"><span data-stu-id="93251-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="93251-150">Tworzysz nazwaną krotek przez określenie nazw dla każdego elementu.</span><span class="sxs-lookup"><span data-stu-id="93251-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="93251-151">Jednym ze sposobów jest określenie nazw jako części inicjowania krotki:</span><span class="sxs-lookup"><span data-stu-id="93251-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="93251-152">Te synonimy są obsługiwane przez kompilator i język, dzięki czemu można efektywnie używać nazwanych krotek.</span><span class="sxs-lookup"><span data-stu-id="93251-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="93251-153">Środowisk IDE i redaktorzy mogą odczytywać te nazwy semantyczne przy użyciu interfejsów API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="93251-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="93251-154">Można odwoływać się do elementów nazwanych krotek według tych nazw semantycznych w dowolnym miejscu w tym samym zestawie.</span><span class="sxs-lookup"><span data-stu-id="93251-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="93251-155">Kompilator zastępuje nazwy zdefiniowane przy użyciu odpowiedników `Item*` podczas generowania skompilowanych danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="93251-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="93251-156">Skompilowany język pośredni firmy Microsoft (MSIL) nie zawiera nazw, które zostały podane przez Ciebie.</span><span class="sxs-lookup"><span data-stu-id="93251-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="93251-157">Począwszy od C# 7,1, nazwy pól dla krotki mogą być dostarczone ze zmiennych używanych do inicjowania krotki.</span><span class="sxs-lookup"><span data-stu-id="93251-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="93251-158">Jest to nazywane **[inicjatorami projekcji krotki](#tuple-projection-initializers)** .</span><span class="sxs-lookup"><span data-stu-id="93251-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="93251-159">Poniższy kod tworzy krotkę o nazwie `accumulation` z elementami `count` (Integer) i `sum` (Double).</span><span class="sxs-lookup"><span data-stu-id="93251-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="93251-160">Kompilator musi komunikować te nazwy, które zostały utworzone dla krotek, które są zwracane z metod publicznych lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="93251-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="93251-161">W takich przypadkach kompilator dodaje atrybut <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> w metodzie.</span><span class="sxs-lookup"><span data-stu-id="93251-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="93251-162">Ten atrybut zawiera właściwość listy <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> zawierającą nazwy nadawane każdemu z elementów w spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="93251-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="93251-163">Narzędzia programistyczne, takie jak Visual Studio, odczytują również te metadane i udostępniają funkcję IntelliSense i inne funkcje przy użyciu nazw pól metadanych.</span><span class="sxs-lookup"><span data-stu-id="93251-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="93251-164">Ważne jest, aby zrozumieć te podstawowe podstawy nowych krotek i typ `ValueTuple`, aby zrozumieć reguły przypisywania nazwanych spójnych krotek.</span><span class="sxs-lookup"><span data-stu-id="93251-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="93251-165">Inicjatory projekcji krotki</span><span class="sxs-lookup"><span data-stu-id="93251-165">Tuple projection initializers</span></span>

<span data-ttu-id="93251-166">Ogólnie rzecz biorąc, inicjatory projekcji krotki działają przy użyciu nazw zmiennych lub pól z prawej strony instrukcji inicjowania krotki.</span><span class="sxs-lookup"><span data-stu-id="93251-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="93251-167">Jeśli podano jawną nazwę, która ma pierwszeństwo przed nazwą przewidywaną.</span><span class="sxs-lookup"><span data-stu-id="93251-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="93251-168">Na przykład w poniższym inicjatorze elementy są `explicitFieldOne` i `explicitFieldTwo`, a nie `localVariableOne` i `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="93251-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="93251-169">Dla każdego pola, w którym nie podano jawnej nazwy, odpowiednia nazwa niejawna jest rzutowana.</span><span class="sxs-lookup"><span data-stu-id="93251-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="93251-170">Nie istnieje wymóg udostępniania nazw semantycznych jawnie lub niejawnie.</span><span class="sxs-lookup"><span data-stu-id="93251-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="93251-171">Następujący inicjator ma nazwy pól `Item1`, których wartość jest `42` i `stringContent`, której wartością jest "odpowiedź na wszystko":</span><span class="sxs-lookup"><span data-stu-id="93251-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="93251-172">Istnieją dwa warunki, w których nazwy pól kandydatów nie są rzutowane na pole krotki:</span><span class="sxs-lookup"><span data-stu-id="93251-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="93251-173">Nazwa kandydata jest zastrzeżoną nazwą krotki.</span><span class="sxs-lookup"><span data-stu-id="93251-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="93251-174">Przykłady obejmują `Item3`, `ToString`.</span><span class="sxs-lookup"><span data-stu-id="93251-174">Examples include `Item3`, `ToString`.</span></span> <span data-ttu-id="93251-175">lub `Rest`.</span><span class="sxs-lookup"><span data-stu-id="93251-175">or `Rest`.</span></span>
1. <span data-ttu-id="93251-176">Nazwa kandydata jest duplikatem innej nazwy pola krotki, jawnej lub niejawnej.</span><span class="sxs-lookup"><span data-stu-id="93251-176">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="93251-177">Te warunki nie zezwalają na niejednoznaczność.</span><span class="sxs-lookup"><span data-stu-id="93251-177">These conditions avoid ambiguity.</span></span> <span data-ttu-id="93251-178">Te nazwy spowodują niejednoznaczność, jeśli były używane jako nazwy pól dla pola w spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="93251-178">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="93251-179">Żaden z tych warunków nie powoduje błędów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="93251-179">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="93251-180">Zamiast tego elementy bez przewidywanych nazw nie mają dla nich nazw semantycznych.</span><span class="sxs-lookup"><span data-stu-id="93251-180">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="93251-181">Poniższe przykłady przedstawiają następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="93251-181">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="93251-182">Te sytuacje nie powodują błędów kompilatora, ponieważ mogą to być istotne zmiany w kodzie zapisanym C# w 7,0, gdy projekcje nazw pól krotek nie są dostępne.</span><span class="sxs-lookup"><span data-stu-id="93251-182">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="93251-183">Równość i krotki</span><span class="sxs-lookup"><span data-stu-id="93251-183">Equality and tuples</span></span>

<span data-ttu-id="93251-184">Począwszy od C# 7,3, typy krotek obsługują operatory `==` i `!=`.</span><span class="sxs-lookup"><span data-stu-id="93251-184">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="93251-185">Te operatory działają przez porównanie poszczególnych elementów członkowskich argumentu po lewej stronie z każdym elementem członkowskim argumentu w odpowiedniej kolejności.</span><span class="sxs-lookup"><span data-stu-id="93251-185">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="93251-186">Te porównania są skracane.</span><span class="sxs-lookup"><span data-stu-id="93251-186">These comparisons short-circuit.</span></span> <span data-ttu-id="93251-187">Przestaną oceniać członków, gdy tylko jedna para nie jest równa.</span><span class="sxs-lookup"><span data-stu-id="93251-187">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="93251-188">Poniższe przykłady kodu używają `==`, ale reguły porównania mają zastosowanie do `!=`.</span><span class="sxs-lookup"><span data-stu-id="93251-188">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="93251-189">Poniższy przykład kodu pokazuje porównanie równości dla dwóch par liczb całkowitych:</span><span class="sxs-lookup"><span data-stu-id="93251-189">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="93251-190">Istnieje kilka reguł, dzięki którym testy równości spójnej kolekcji są wygodniejsze.</span><span class="sxs-lookup"><span data-stu-id="93251-190">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="93251-191">Równość krotki wykonuje [przekształcenia zniesione](~/_csharplang/spec/conversions.md#lifted-conversion-operators) , jeśli jedna z krotek jest krotką dopuszczającą wartość null, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="93251-191">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="93251-192">Równość krotek również wykonuje konwersje niejawne dla każdego elementu członkowskiego obu krotek.</span><span class="sxs-lookup"><span data-stu-id="93251-192">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="93251-193">Obejmują one przenoszone konwersje, konwersje rozszerzające lub inne niejawne konwersje.</span><span class="sxs-lookup"><span data-stu-id="93251-193">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="93251-194">Poniższe przykłady pokazują, że liczba całkowita 2-krotka może być porównana z długą 2-krotką ze względu na niejawną konwersję z liczby całkowitej na wartość Long:</span><span class="sxs-lookup"><span data-stu-id="93251-194">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="93251-195">Nazwy składowych krotek nie uczestniczą w testach pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="93251-195">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="93251-196">Jeśli jednak jeden z operandów jest literałem krotki z jawnymi nazwami, kompilator generuje ostrzeżenie CS8383, jeśli te nazwy nie pasują do nazw innych operandów.</span><span class="sxs-lookup"><span data-stu-id="93251-196">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="93251-197">W przypadku, gdy oba operandy są literałami krotki, ostrzeżenie znajduje się na prawym operandzie, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="93251-197">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="93251-198">Na koniec krotki mogą zawierać krotki zagnieżdżone.</span><span class="sxs-lookup"><span data-stu-id="93251-198">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="93251-199">Równość krotki porównuje "kształt" każdego operandu za pomocą krotek zagnieżdżonych, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="93251-199">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="93251-200">Jest to błąd czasu kompilacji służący do porównywania dwóch krotek w celu równości (lub nierówności), gdy mają różne kształty.</span><span class="sxs-lookup"><span data-stu-id="93251-200">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="93251-201">Kompilator nie będzie podejmować próby odbudowy krotek zagnieżdżonych, aby je porównać.</span><span class="sxs-lookup"><span data-stu-id="93251-201">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="93251-202">Przypisanie i krotki</span><span class="sxs-lookup"><span data-stu-id="93251-202">Assignment and tuples</span></span>

<span data-ttu-id="93251-203">Język obsługuje przypisanie między typami krotek, które mają taką samą liczbę elementów, gdzie każdy element po prawej stronie może być niejawnie konwertowany do odpowiadającego mu elementu po lewej stronie.</span><span class="sxs-lookup"><span data-stu-id="93251-203">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="93251-204">Inne konwersje nie są brane pod uwagę w przypisaniach.</span><span class="sxs-lookup"><span data-stu-id="93251-204">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="93251-205">Jest to błąd czasu kompilacji, aby przypisać jedną krotkę do innej, gdy mają różne kształty.</span><span class="sxs-lookup"><span data-stu-id="93251-205">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="93251-206">Kompilator nie będzie podejmować próby odbudowy krotek zagnieżdżonych, aby je przypisać.</span><span class="sxs-lookup"><span data-stu-id="93251-206">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="93251-207">Przyjrzyjmy się typom przypisań, które są dozwolone między typami krotek.</span><span class="sxs-lookup"><span data-stu-id="93251-207">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="93251-208">Należy wziąć pod uwagę te zmienne, które są używane w następujących przykładach:</span><span class="sxs-lookup"><span data-stu-id="93251-208">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="93251-209">Pierwsze dwie zmienne, `unnamed` i `anonymous` nie mają nazw semantycznych dla elementów.</span><span class="sxs-lookup"><span data-stu-id="93251-209">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="93251-210">Nazwy pól są `Item1` i `Item2`.</span><span class="sxs-lookup"><span data-stu-id="93251-210">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="93251-211">Ostatnie dwie zmienne, `named` i `differentName` mają nazwy semantyczne podane dla elementów.</span><span class="sxs-lookup"><span data-stu-id="93251-211">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="93251-212">Te dwie krotki mają różne nazwy dla elementów.</span><span class="sxs-lookup"><span data-stu-id="93251-212">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="93251-213">Wszystkie cztery z tych krotek mają tę samą liczbę elementów (określaną jako Kardynalność) i typy tych elementów są identyczne.</span><span class="sxs-lookup"><span data-stu-id="93251-213">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="93251-214">W związku z tym wszystkie te przypisania działają:</span><span class="sxs-lookup"><span data-stu-id="93251-214">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="93251-215">Zauważ, że nazwy krotek nie są przypisane.</span><span class="sxs-lookup"><span data-stu-id="93251-215">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="93251-216">Wartości elementów są przypisywane po kolejności elementów w spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="93251-216">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="93251-217">Nie można przypisać krotek o różnych typach lub liczbie elementów:</span><span class="sxs-lookup"><span data-stu-id="93251-217">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="93251-218">Krotki jako wartości zwracane przez metodę</span><span class="sxs-lookup"><span data-stu-id="93251-218">Tuples as method return values</span></span>

<span data-ttu-id="93251-219">Jednym z najpopularniejszych zastosowania krotek jest jako wartość zwracana przez metodę.</span><span class="sxs-lookup"><span data-stu-id="93251-219">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="93251-220">Przejdźmy do jednego przykładu.</span><span class="sxs-lookup"><span data-stu-id="93251-220">Let's walk through one example.</span></span> <span data-ttu-id="93251-221">Należy wziąć pod uwagę tę metodę, która oblicza odchylenie standardowe dla sekwencji liczb:</span><span class="sxs-lookup"><span data-stu-id="93251-221">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="93251-222">Te przykłady obliczają Niepoprawione odchylenie standardowe próbki.</span><span class="sxs-lookup"><span data-stu-id="93251-222">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="93251-223">Skorygowana formuła przykładowego odchylenia standardowego podzieli sumę kwadratów różnic od średniej przez (N-1), a nie N, jako metodę rozszerzenia `Average`.</span><span class="sxs-lookup"><span data-stu-id="93251-223">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="93251-224">Zapoznaj się z tekstem statystyk, aby uzyskać szczegółowe informacje o różnicach między tymi formułami dotyczącymi odchylenia standardowego.</span><span class="sxs-lookup"><span data-stu-id="93251-224">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="93251-225">Poprzedni kod jest zgodny z formułą Textbook dla odchylenia standardowego.</span><span class="sxs-lookup"><span data-stu-id="93251-225">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="93251-226">Tworzy poprawną odpowiedź, ale jest nieefektywną implementacją.</span><span class="sxs-lookup"><span data-stu-id="93251-226">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="93251-227">Ta metoda wylicza dwa razy sekwencję: raz, aby utworzyć średnią, i raz, aby utworzyć średnią kwadratu różnicy średniej.</span><span class="sxs-lookup"><span data-stu-id="93251-227">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="93251-228">(Należy pamiętać, że zapytania LINQ są oceniane opóźnieniem, więc obliczenie różnic między średnią i średnią z tych różnic powoduje tylko jedno Wyliczenie).</span><span class="sxs-lookup"><span data-stu-id="93251-228">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="93251-229">Istnieje alternatywna formuła, która oblicza odchylenie standardowe przy użyciu tylko jednego wyliczenia sekwencji.</span><span class="sxs-lookup"><span data-stu-id="93251-229">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="93251-230">To obliczenie generuje dwie wartości, ponieważ wylicza sekwencję: sumę wszystkich elementów w sekwencji i sumę każdej wartości kwadratowej:</span><span class="sxs-lookup"><span data-stu-id="93251-230">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="93251-231">Ta wersja Wylicza sekwencję dokładnie raz.</span><span class="sxs-lookup"><span data-stu-id="93251-231">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="93251-232">Ale nie jest to kod wielokrotnego użytku.</span><span class="sxs-lookup"><span data-stu-id="93251-232">But it's not reusable code.</span></span> <span data-ttu-id="93251-233">W trakcie pracy można się dowiedzieć, że wiele różnych obliczeń statystycznych używa liczby elementów w sekwencji, sumy sekwencji i sumy kwadratów sekwencji.</span><span class="sxs-lookup"><span data-stu-id="93251-233">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="93251-234">Refaktoryzacjmy metodę i piszą metodę narzędzia, która produkuje wszystkie trzy wartości.</span><span class="sxs-lookup"><span data-stu-id="93251-234">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="93251-235">Wszystkie trzy wartości mogą być zwracane jako krotki.</span><span class="sxs-lookup"><span data-stu-id="93251-235">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="93251-236">Zaktualizujmy tę metodę, tak aby trzy wartości obliczane podczas wyliczania były przechowywane w spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="93251-236">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="93251-237">Tworzy tę wersję:</span><span class="sxs-lookup"><span data-stu-id="93251-237">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="93251-238">Obsługa refaktoryzacji programu Visual Studio ułatwia wyodrębnienie funkcji podstawowych statystyk do metody prywatnej.</span><span class="sxs-lookup"><span data-stu-id="93251-238">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="93251-239">Zapewnia metodę `private static`, która zwraca typ krotki z trzema wartościami `Sum`, `SumOfSquares` i `Count`:</span><span class="sxs-lookup"><span data-stu-id="93251-239">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]
 
<span data-ttu-id="93251-240">Język umożliwia korzystanie z kilku opcji, których można użyć, jeśli chcesz zrobić kilka szybkiej edycji ręcznie.</span><span class="sxs-lookup"><span data-stu-id="93251-240">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="93251-241">Najpierw można użyć deklaracji `var` w celu zainicjowania wyniku krotki z wywołania metody `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="93251-241">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="93251-242">Można również utworzyć trzy zmienne dyskretne wewnątrz metody `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="93251-242">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="93251-243">Wersja końcowa jest pokazana w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="93251-243">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="93251-244">Tej ostatecznej wersji można użyć dla każdej metody, która wymaga tych trzech wartości lub dowolnego podzbioru.</span><span class="sxs-lookup"><span data-stu-id="93251-244">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="93251-245">Język obsługuje inne opcje zarządzania nazwami elementów w tych metodach zwracających spójność krotek.</span><span class="sxs-lookup"><span data-stu-id="93251-245">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="93251-246">Można usunąć nazwy pól z deklaracji wartości zwracanej i zwrócić spójną krotkę:</span><span class="sxs-lookup"><span data-stu-id="93251-246">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="93251-247">Pola tej krotki mają nazwę `Item1`, `Item2` i `Item3`.</span><span class="sxs-lookup"><span data-stu-id="93251-247">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="93251-248">Zaleca się dostarczanie nazw semantycznych do elementów krotek zwracanych z metod.</span><span class="sxs-lookup"><span data-stu-id="93251-248">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="93251-249">Inny idiom, gdzie krotke mogą być przydatne podczas tworzenia zapytań LINQ.</span><span class="sxs-lookup"><span data-stu-id="93251-249">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="93251-250">Ostatecznie przewidywany wynik często zawiera niektóre z właściwości wybranych obiektów, ale nie wszystkie.</span><span class="sxs-lookup"><span data-stu-id="93251-250">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="93251-251">Tradycyjnie można projektować wyniki zapytania w sekwencji obiektów, które były typu anonimowego.</span><span class="sxs-lookup"><span data-stu-id="93251-251">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="93251-252">Przedstawiamy wiele ograniczeń, głównie ponieważ typy anonimowe nie mogą wygodnie nazywać się w zwracanym typie dla metody.</span><span class="sxs-lookup"><span data-stu-id="93251-252">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="93251-253">Alternatywa przy użyciu `object` lub `dynamic` jako typ wyniku ma znaczny koszt wydajności.</span><span class="sxs-lookup"><span data-stu-id="93251-253">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="93251-254">Zwracanie sekwencji typu krotki jest proste, a nazwy i typy elementów są dostępne w czasie kompilacji i za pomocą narzędzi IDE.</span><span class="sxs-lookup"><span data-stu-id="93251-254">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="93251-255">Rozważmy na przykład aplikację do zrobienia.</span><span class="sxs-lookup"><span data-stu-id="93251-255">For example, consider a ToDo application.</span></span> <span data-ttu-id="93251-256">Można zdefiniować klasę podobną do następującej, aby reprezentować pojedynczy wpis na liście zadań do wykonania:</span><span class="sxs-lookup"><span data-stu-id="93251-256">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="93251-257">Aplikacje mobilne mogą obsługiwać zwartą postać bieżących elementów do wykonania, które wyświetlają tylko tytuł.</span><span class="sxs-lookup"><span data-stu-id="93251-257">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="93251-258">To zapytanie LINQ spowodowałoby projekcję zawierającą tylko identyfikator i tytuł.</span><span class="sxs-lookup"><span data-stu-id="93251-258">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="93251-259">Metoda zwracająca sekwencję krotek powoduje, że projekt jest dobrze:</span><span class="sxs-lookup"><span data-stu-id="93251-259">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="93251-260">W C# 7,1, projekcje krotek umożliwiają tworzenie nazwanych krotek przy użyciu elementów w sposób podobny do nazw właściwości w typach anonimowych.</span><span class="sxs-lookup"><span data-stu-id="93251-260">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="93251-261">W powyższym kodzie instrukcja `select` w projekcji zapytania tworzy krotkę, która ma elementy `ID` i `Title`.</span><span class="sxs-lookup"><span data-stu-id="93251-261">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="93251-262">Nazwana krotka może być częścią podpisu.</span><span class="sxs-lookup"><span data-stu-id="93251-262">The named tuple can be part of the signature.</span></span> <span data-ttu-id="93251-263">Pozwala ona narzędziom kompilatora i IDE zapewnić statyczne sprawdzanie, czy wynik jest prawidłowo używany.</span><span class="sxs-lookup"><span data-stu-id="93251-263">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="93251-264">Nazwana krotka również zawiera informacje o typie statycznym, więc nie ma potrzeby używania kosztownych funkcji czasu wykonywania, takich jak odbicie lub dynamiczne powiązanie, aby pracować z wynikami.</span><span class="sxs-lookup"><span data-stu-id="93251-264">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="93251-265">Dekonstrukcja</span><span class="sxs-lookup"><span data-stu-id="93251-265">Deconstruction</span></span>

<span data-ttu-id="93251-266">Wszystkie elementy w spójnej kolekcji można rozpakować przez *odbudowę* krotki zwracanej przez metodę.</span><span class="sxs-lookup"><span data-stu-id="93251-266">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="93251-267">Istnieją trzy różne podejścia do dekonstrukcji krotek.</span><span class="sxs-lookup"><span data-stu-id="93251-267">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="93251-268">Najpierw można jawnie zadeklarować typ każdego pola wewnątrz nawiasów, aby utworzyć zmienne dyskretne dla każdego elementu w spójnej kolekcji:</span><span class="sxs-lookup"><span data-stu-id="93251-268">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="93251-269">Można również zadeklarować niejawnie wpisane zmienne dla każdego pola w spójnej kolekcji przy użyciu słowa kluczowego `var` poza nawiasami:</span><span class="sxs-lookup"><span data-stu-id="93251-269">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="93251-270">Istnieje również możliwość użycia słowa kluczowego `var` z dowolnymi lub wszystkimi deklaracjami zmiennych w nawiasach.</span><span class="sxs-lookup"><span data-stu-id="93251-270">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span> 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="93251-271">Nie można użyć określonego typu poza nawiasami, nawet jeśli każde pole w krotek ma ten sam typ.</span><span class="sxs-lookup"><span data-stu-id="93251-271">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="93251-272">Można także rozbudowy krotek z istniejącymi deklaracjami:</span><span class="sxs-lookup"><span data-stu-id="93251-272">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="93251-273">Nie można mieszać istniejących deklaracji z deklaracjami wewnątrz nawiasów.</span><span class="sxs-lookup"><span data-stu-id="93251-273">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="93251-274">Na przykład następujące elementy są niedozwolone: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="93251-274">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="93251-275">Powoduje to CS8184 błędu, ponieważ *x* jest zadeklarowany wewnątrz nawiasów, a *y* jest poprzednio zadeklarowany w innym miejscu.</span><span class="sxs-lookup"><span data-stu-id="93251-275">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="93251-276">Dekonstrukcja typów zdefiniowanych przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="93251-276">Deconstructing user-defined types</span></span>

<span data-ttu-id="93251-277">Każdy typ krotki można rozbudować, jak pokazano powyżej.</span><span class="sxs-lookup"><span data-stu-id="93251-277">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="93251-278">Można również łatwo włączyć dekonstrukcja na dowolnym typie zdefiniowanym przez użytkownika (klasy, struktury, a nawet interfejsy).</span><span class="sxs-lookup"><span data-stu-id="93251-278">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="93251-279">Autor typu może zdefiniować jedną lub więcej metod `Deconstruct`, które przypisują wartości do dowolnej liczby zmiennych `out` reprezentujących elementy danych, które tworzą typ.</span><span class="sxs-lookup"><span data-stu-id="93251-279">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="93251-280">Na przykład następujący typ `Person` definiuje metodę `Deconstruct`, która dekonstruuje obiekt osoby do elementów reprezentujących imię i nazwisko:</span><span class="sxs-lookup"><span data-stu-id="93251-280">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="93251-281">Metoda dekonstrukcja umożliwia przypisanie z `Person` do dwóch ciągów reprezentujących właściwości `FirstName` i `LastName`:</span><span class="sxs-lookup"><span data-stu-id="93251-281">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="93251-282">Można włączyć dekonstrukcja nawet dla typów, które nie zostały utworzone.</span><span class="sxs-lookup"><span data-stu-id="93251-282">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="93251-283">Metoda `Deconstruct` może być metodą rozszerzenia, która rozpakuje dostępne elementy członkowskie danych obiektu.</span><span class="sxs-lookup"><span data-stu-id="93251-283">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="93251-284">W poniższym przykładzie przedstawiono typ `Student` pochodzący z typu `Person` i metodę rozszerzającą, która dekonstrukcjauje `Student` do trzech zmiennych reprezentujących `FirstName`, `LastName` i `GPA`:</span><span class="sxs-lookup"><span data-stu-id="93251-284">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="93251-285">Obiekt `Student` ma teraz dwie dostępne metody `Deconstruct`: Metoda rozszerzająca zadeklarowana dla typów `Student` i element członkowski typu `Person`.</span><span class="sxs-lookup"><span data-stu-id="93251-285">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="93251-286">Oba należą do zakresu, które umożliwiają rozbudowanie `Student` w dwie zmienne lub trzy.</span><span class="sxs-lookup"><span data-stu-id="93251-286">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="93251-287">Jeśli student zostanie przypisany do trzech zmiennych, zwracane są imiona, nazwisko, nazwisko i GPA.</span><span class="sxs-lookup"><span data-stu-id="93251-287">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="93251-288">Jeśli student zostanie przypisany do dwóch zmiennych, zwracane są tylko imię i nazwisko.</span><span class="sxs-lookup"><span data-stu-id="93251-288">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="93251-289">Należy ostrożnie definiować wiele metod `Deconstruct` w klasie lub hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="93251-289">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="93251-290">Wiele metod `Deconstruct`, które mają taką samą liczbę parametrów `out`, może szybko spowodować niejasności.</span><span class="sxs-lookup"><span data-stu-id="93251-290">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="93251-291">Obiekty wywołujące mogą nie być w stanie łatwo wywołać żądanej metody `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="93251-291">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="93251-292">W tym przykładzie istnieje minimalna szansa na niejednoznaczne wywołanie, ponieważ metoda `Deconstruct` dla `Person` ma dwa parametry wyjściowe, a metoda `Deconstruct` dla `Student` ma trzy.</span><span class="sxs-lookup"><span data-stu-id="93251-292">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="93251-293">Operatory dekonstrukcji nie uczestniczą w testowaniu równości.</span><span class="sxs-lookup"><span data-stu-id="93251-293">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="93251-294">Poniższy przykład generuje błąd kompilatora CS0019:</span><span class="sxs-lookup"><span data-stu-id="93251-294">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="93251-295">Metoda `Deconstruct` może skonwertować obiekt `Person` `p` do krotki zawierającej dwa ciągi, ale nie ma zastosowania w kontekście testów równości.</span><span class="sxs-lookup"><span data-stu-id="93251-295">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="93251-296">Krotki jako parametry out</span><span class="sxs-lookup"><span data-stu-id="93251-296">Tuples as out parameters</span></span>

<span data-ttu-id="93251-297">Krotki mogą być używane *jako parametry out*.</span><span class="sxs-lookup"><span data-stu-id="93251-297">Tuples can be used as out parameters *themselves*.</span></span> <span data-ttu-id="93251-298">Nie należy mylić z żadną niejednoznaczność wymienioną wcześniej w sekcji [dekonstrukcja](#deconstruction) .</span><span class="sxs-lookup"><span data-stu-id="93251-298">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="93251-299">W wywołaniu metody jest potrzebne tylko opisywanie kształtu krotki:</span><span class="sxs-lookup"><span data-stu-id="93251-299">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="93251-300">Alternatywnie możesz użyć [_nienazwanej_](#named-and-unnamed-tuples) krotki i odwołać się do jego pól jako `Item1` i `Item2`:</span><span class="sxs-lookup"><span data-stu-id="93251-300">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="93251-301">Wniosek</span><span class="sxs-lookup"><span data-stu-id="93251-301">Conclusion</span></span> 

<span data-ttu-id="93251-302">Nowy język i obsługa biblioteki nazwanych krotek znacznie ułatwiają pracę z projektami korzystającymi ze struktur danych, które przechowują wiele elementów, ale nie definiują zachowania, jako klas i struktur.</span><span class="sxs-lookup"><span data-stu-id="93251-302">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="93251-303">Używanie krotek dla tych typów jest łatwe i zwięzłe.</span><span class="sxs-lookup"><span data-stu-id="93251-303">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="93251-304">Uzyskujesz wszystkie korzyści ze sprawdzenia typu statycznego bez konieczności tworzenia typów przy użyciu bardziej pełnej składni `class` lub `struct`.</span><span class="sxs-lookup"><span data-stu-id="93251-304">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="93251-305">Nawet dlatego są one najbardziej przydatne w przypadku metod narzędziowych `private` lub `internal`.</span><span class="sxs-lookup"><span data-stu-id="93251-305">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="93251-306">Tworzenie typów zdefiniowanych przez użytkownika, `class` lub `struct`, gdy metody publiczne zwracają wartość, która ma wiele elementów.</span><span class="sxs-lookup"><span data-stu-id="93251-306">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
