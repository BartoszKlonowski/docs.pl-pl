---
title: Typy krotki — przewodnik po językach C#
description: 'Dowiedz się więcej o typach nienazwanych i nazwanych krotek w c #'
ms.date: 05/15/2018
ms.technology: csharp-fundamentals
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 9ce9e1d4395d1a75f36004384ec215c615cd9802
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156912"
---
# <a name="c-tuple-types"></a><span data-ttu-id="f32c3-103">Typy krotki Języka C#</span><span class="sxs-lookup"><span data-stu-id="f32c3-103">C# tuple types</span></span>

<span data-ttu-id="f32c3-104">Krotek C# to typy zdefiniowane przy użyciu lekkiej składni.</span><span class="sxs-lookup"><span data-stu-id="f32c3-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="f32c3-105">Zalety obejmują prostszą składnię, reguły konwersji na podstawie liczby (określane jako kardynalność) i typy elementów oraz spójne reguły dotyczące kopii, testów równości i przypisań.</span><span class="sxs-lookup"><span data-stu-id="f32c3-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="f32c3-106">Jako kompromis krotek nie obsługują niektórych idiomów obiektowych związanych z dziedziczeniem.</span><span class="sxs-lookup"><span data-stu-id="f32c3-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="f32c3-107">Możesz uzyskać przegląd w sekcji na [krotek w Co nowego w Języku C# 7.0](whats-new/csharp-7.md#tuples) artykułu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="f32c3-108">W tym artykule dowiesz się, reguły języka regulujące krotek w języku C# 7.0 i nowszych wersjach, różne sposoby ich używania i wstępne wskazówki dotyczące pracy z krotek.</span><span class="sxs-lookup"><span data-stu-id="f32c3-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="f32c3-109">Nowe funkcje krotek wymagają <xref:System.ValueTuple> typów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="f32c3-110">Należy dodać pakiet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) NuGet, aby używać go na platformach, które nie zawierają typów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="f32c3-111">Jest to podobne do innych funkcji języka, które opierają się na typy dostarczane w ramach.</span><span class="sxs-lookup"><span data-stu-id="f32c3-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="f32c3-112">Przykłady obejmują `async` `await` i opierając `INotifyCompletion` się na interfejsie i `IEnumerable<T>`LINQ opierając się na .</span><span class="sxs-lookup"><span data-stu-id="f32c3-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="f32c3-113">Jednak mechanizm dostarczania zmienia się, ponieważ .NET staje się coraz bardziej niezależny od platformy.</span><span class="sxs-lookup"><span data-stu-id="f32c3-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="f32c3-114">Program .NET Framework nie zawsze może być dostarczany w tym samym rytmie co kompilator języka.</span><span class="sxs-lookup"><span data-stu-id="f32c3-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="f32c3-115">Gdy nowe funkcje języka polegać na nowych typów, te typy będą dostępne jako pakiety NuGet, gdy funkcje języka wysyłać.</span><span class="sxs-lookup"><span data-stu-id="f32c3-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="f32c3-116">Jak te nowe typy zostaną dodane do interfejsu API standardu .NET i dostarczane jako część struktury, wymóg pakietu NuGet zostaną usunięte.</span><span class="sxs-lookup"><span data-stu-id="f32c3-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="f32c3-117">Zacznijmy od powodów dodawania nowej obsługi krotki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="f32c3-118">Metody zwracają pojedynczy obiekt.</span><span class="sxs-lookup"><span data-stu-id="f32c3-118">Methods return a single object.</span></span> <span data-ttu-id="f32c3-119">Krotek umożliwiają pakowanie wielu wartości w tym pojedynczym obiekcie łatwiej.</span><span class="sxs-lookup"><span data-stu-id="f32c3-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="f32c3-120">Program .NET Framework `Tuple` ma już klasy ogólne.</span><span class="sxs-lookup"><span data-stu-id="f32c3-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="f32c3-121">Klasy te miały jednak dwa główne ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="f32c3-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="f32c3-122">Po pierwsze, `Tuple` klasy nazwały `Item1` `Item2`swoje właściwości , i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="f32c3-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="f32c3-123">Nazwy te nie posiadają żadnych informacji semantycznych.</span><span class="sxs-lookup"><span data-stu-id="f32c3-123">Those names carry no semantic information.</span></span> <span data-ttu-id="f32c3-124">Korzystanie `Tuple` z tych typów nie umożliwia komunikowania znaczenie każdej z właściwości.</span><span class="sxs-lookup"><span data-stu-id="f32c3-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="f32c3-125">Nowe funkcje języka umożliwiają deklarowanie i używanie semantycznie znaczących nazw elementów w krotce.</span><span class="sxs-lookup"><span data-stu-id="f32c3-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="f32c3-126">Klasy `Tuple` powodują więcej problemów z wydajnością, ponieważ są one typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="f32c3-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="f32c3-127">Użycie jednego `Tuple` z typów oznacza przydzielanie obiektów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="f32c3-128">Na gorących ścieżkach przydzielanie wielu małych obiektów może mieć wymierny wpływ na wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f32c3-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="f32c3-129">W związku z tym obsługa języka dla `ValueTuple` krotek wykorzystuje nowe struktury.</span><span class="sxs-lookup"><span data-stu-id="f32c3-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="f32c3-130">Aby uniknąć tych braków, `class` można `struct` utworzyć lub do przenoszenia wielu elementów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="f32c3-131">Niestety, to więcej pracy dla Ciebie, i to przesłania intencji projektu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="f32c3-132">Tworzenie `struct` lub `class` oznacza, że definiujesz typ z danymi i zachowaniem.</span><span class="sxs-lookup"><span data-stu-id="f32c3-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="f32c3-133">Wiele razy, po prostu chcesz przechowywać wiele wartości w jednym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="f32c3-134">Funkcje języka i `ValueTuple` struktury ogólne wymuszają regułę, której nie można dodać do tych typów krotki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="f32c3-135">Wszystkie `ValueTuple` typy są *zmienne struktury*.</span><span class="sxs-lookup"><span data-stu-id="f32c3-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="f32c3-136">Każde pole członkowskie jest polem publicznym.</span><span class="sxs-lookup"><span data-stu-id="f32c3-136">Each member field is a public field.</span></span> <span data-ttu-id="f32c3-137">To sprawia, że są bardzo lekkie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-137">That makes them very lightweight.</span></span> <span data-ttu-id="f32c3-138">Oznacza to jednak, że krotek nie należy używać tam, gdzie ważna jest niezmienność.</span><span class="sxs-lookup"><span data-stu-id="f32c3-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="f32c3-139">Krotek są zarówno prostsze i `class` `struct` bardziej elastyczne kontenery danych niż i typy.</span><span class="sxs-lookup"><span data-stu-id="f32c3-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="f32c3-140">Zbadajmy te różnice.</span><span class="sxs-lookup"><span data-stu-id="f32c3-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="f32c3-141">Nazwane i nienazwane krotek</span><span class="sxs-lookup"><span data-stu-id="f32c3-141">Named and unnamed tuples</span></span>

<span data-ttu-id="f32c3-142">Struktura `ValueTuple` ma pola `Item1`o `Item2` `Item3`nazwie , , i tak dalej, podobne `Tuple` do właściwości zdefiniowanych w istniejących typach.</span><span class="sxs-lookup"><span data-stu-id="f32c3-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="f32c3-143">Nazwy te są jedynymi nazwami, których można używać dla *nienazwanych krotek.*</span><span class="sxs-lookup"><span data-stu-id="f32c3-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="f32c3-144">Jeśli do krotki nie podasz żadnych alternatywnych nazw pól, utworzono nienazwaną krotkę:</span><span class="sxs-lookup"><span data-stu-id="f32c3-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="f32c3-145">Krotka w poprzednim przykładzie została zainicjowana przy użyciu stałych literału i nie będzie mieć nazwy elementów utworzone przy użyciu *rzutowania nazwy pola krotki* w Języku C# 7.1.</span><span class="sxs-lookup"><span data-stu-id="f32c3-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="f32c3-146">Jednak podczas inicjowania krotki, można użyć nowych funkcji języka, które dają lepsze nazwy dla każdego pola.</span><span class="sxs-lookup"><span data-stu-id="f32c3-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="f32c3-147">W ten sposób tworzy *nazwane krotki*.</span><span class="sxs-lookup"><span data-stu-id="f32c3-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="f32c3-148">Nazwane krotek nadal mają `Item1` `Item2`elementy `Item3` o nazwie , i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="f32c3-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="f32c3-149">Ale mają też synonimy dla każdego z tych elementów, które zostały nazwane.</span><span class="sxs-lookup"><span data-stu-id="f32c3-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="f32c3-150">Nazwanego krotki można utworzyć, określając nazwy dla każdego elementu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="f32c3-151">Jednym ze sposobów jest określenie nazw jako części inicjowania krotki:</span><span class="sxs-lookup"><span data-stu-id="f32c3-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="f32c3-152">Te synonimy są obsługiwane przez kompilator i język, dzięki czemu można skutecznie używać nazwanych krotek.</span><span class="sxs-lookup"><span data-stu-id="f32c3-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="f32c3-153">IDEs i redaktorzy mogą odczytywać te nazwy semantyczne przy użyciu interfejsów API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="f32c3-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="f32c3-154">Można odwoływać się do elementów nazwanej krotki przez te nazwy semantyczne w dowolnym miejscu w tym samym zestawie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="f32c3-155">Kompilator zastępuje nazwy zdefiniowane odpowiednikami `Item*` podczas generowania skompilowanych danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="f32c3-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="f32c3-156">Skompilowany język pośredni (MSIL) nie zawiera nazw, które zostały podane przez te elementy.</span><span class="sxs-lookup"><span data-stu-id="f32c3-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="f32c3-157">Począwszy od Języka C# 7.1 nazwy pól dla krotki mogą być dostarczane ze zmiennych używanych do inicjowania krotki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="f32c3-158">Jest to określane jako **[inicjatory projekcji krotki](#tuple-projection-initializers)**.</span><span class="sxs-lookup"><span data-stu-id="f32c3-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="f32c3-159">Poniższy kod tworzy krotkę o nazwie `accumulation` z elementami `count` (liczba całkowita) i `sum` (double).</span><span class="sxs-lookup"><span data-stu-id="f32c3-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="f32c3-160">Kompilator musi komunikować te nazwy utworzone dla krotek, które są zwracane z publicznych metod lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="f32c3-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="f32c3-161">W takich przypadkach kompilator dodaje <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> atrybut na metodę.</span><span class="sxs-lookup"><span data-stu-id="f32c3-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="f32c3-162">Ten atrybut <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> zawiera właściwość list, która zawiera nazwy nadane każdemu z elementów w krotce.</span><span class="sxs-lookup"><span data-stu-id="f32c3-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="f32c3-163">Narzędzia programistyczne, takie jak Visual Studio, również przeczytać, że metadane i zapewniają IntelliSense i inne funkcje przy użyciu nazw pól metadanych.</span><span class="sxs-lookup"><span data-stu-id="f32c3-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="f32c3-164">Ważne jest, aby zrozumieć te podstawowe podstawy nowych krotek i `ValueTuple` typu, aby zrozumieć zasady przypisywania nazwanych krotek do siebie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="f32c3-165">Inicjatory projekcji krotki</span><span class="sxs-lookup"><span data-stu-id="f32c3-165">Tuple projection initializers</span></span>

<span data-ttu-id="f32c3-166">Ogólnie rzecz biorąc inicjatory projekcji krotki działają przy użyciu nazwy zmiennej lub pola z prawej strony instrukcji inicjowania krotki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="f32c3-167">Jeśli nadano jawną nazwę, która ma pierwszeństwo przed każdą wyświetlaną nazwą.</span><span class="sxs-lookup"><span data-stu-id="f32c3-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="f32c3-168">Na przykład w następującym inicjatorze `localVariableOne` `localVariableTwo`elementy są `explicitFieldOne` i `explicitFieldTwo`, nie i:</span><span class="sxs-lookup"><span data-stu-id="f32c3-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="f32c3-169">Dla każdego pola, w którym nie podano jawnej nazwy, wyświetlana jest odpowiednia nazwa niejawna.</span><span class="sxs-lookup"><span data-stu-id="f32c3-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="f32c3-170">Nie ma wymogu podawania nazw semantycznych, jawnie lub niejawnie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="f32c3-171">Następujący inicjator `Item1`ma nazwy `42` `stringContent`pól , których wartość jest i , którego wartość jest "Odpowiedź na wszystko":</span><span class="sxs-lookup"><span data-stu-id="f32c3-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="f32c3-172">Istnieją dwa warunki, w których nazwy pól kandydata nie są rzutowane na pole krotki:</span><span class="sxs-lookup"><span data-stu-id="f32c3-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="f32c3-173">Gdy nazwa kandydata jest zarezerwowana nazwa krotki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="f32c3-174">Przykłady obejmują `Item3` `ToString`, `Rest`lub .</span><span class="sxs-lookup"><span data-stu-id="f32c3-174">Examples include `Item3`, `ToString`, or `Rest`.</span></span>
1. <span data-ttu-id="f32c3-175">Gdy nazwa kandydata jest duplikatem innej nazwy pola krotki, jawnej lub niejawnej.</span><span class="sxs-lookup"><span data-stu-id="f32c3-175">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="f32c3-176">Warunki te uniknąć dwuznaczności.</span><span class="sxs-lookup"><span data-stu-id="f32c3-176">These conditions avoid ambiguity.</span></span> <span data-ttu-id="f32c3-177">Nazwy te spowodowałyby niejednoznaczność, gdyby były używane jako nazwy pól dla pola w krotce.</span><span class="sxs-lookup"><span data-stu-id="f32c3-177">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="f32c3-178">Żaden z tych warunków nie powoduje błędów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="f32c3-178">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="f32c3-179">Zamiast tego elementy bez wyświetlanych nazw nie mają dla nich wyświetlanych nazw semantycznych.</span><span class="sxs-lookup"><span data-stu-id="f32c3-179">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="f32c3-180">W poniższych przykładach przedstawiono następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="f32c3-180">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="f32c3-181">Sytuacje te nie powodują błędów kompilatora, ponieważ byłoby to zmiana podziału dla kodu napisanego za pomocą języka C# 7.0, gdy projekcje nazw pól krotki nie były dostępne.</span><span class="sxs-lookup"><span data-stu-id="f32c3-181">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="f32c3-182">Równość i krotek</span><span class="sxs-lookup"><span data-stu-id="f32c3-182">Equality and tuples</span></span>

<span data-ttu-id="f32c3-183">Począwszy od Języka C# 7.3 `==` `!=` typy krotki obsługują i operatorów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-183">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="f32c3-184">Operatory te działają, porównując każdy element członkowski argumentu left do każdego elementu członkowskiego argumentu po prawej kolejności.</span><span class="sxs-lookup"><span data-stu-id="f32c3-184">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="f32c3-185">Porównania te są zwarte.</span><span class="sxs-lookup"><span data-stu-id="f32c3-185">These comparisons short-circuit.</span></span> <span data-ttu-id="f32c3-186">Przestaną oceniać członków, gdy tylko jedna para nie będzie równa.</span><span class="sxs-lookup"><span data-stu-id="f32c3-186">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="f32c3-187">Poniższe przykłady kodu `==`używają , ale wszystkie `!=`reguły porównania mają zastosowanie do .</span><span class="sxs-lookup"><span data-stu-id="f32c3-187">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="f32c3-188">Poniższy przykład kodu przedstawia porównanie równości dla dwóch par liczb całkowitych:</span><span class="sxs-lookup"><span data-stu-id="f32c3-188">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="f32c3-189">Istnieje kilka reguł, które sprawiają, że testy równości krotki są wygodniejsze.</span><span class="sxs-lookup"><span data-stu-id="f32c3-189">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="f32c3-190">Równość krotki wykonuje [konwersje zniesione,](~/_csharplang/spec/conversions.md#lifted-conversion-operators) jeśli jedna z krotek jest stałą wartością null, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="f32c3-190">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="f32c3-191">Równość krotki wykonuje również niejawne konwersje na każdym elementem członkowskim obu krotek.</span><span class="sxs-lookup"><span data-stu-id="f32c3-191">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="f32c3-192">Należą do nich konwersje zniesione, poszerzenie konwersji lub inne konwersje niejawne.</span><span class="sxs-lookup"><span data-stu-id="f32c3-192">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="f32c3-193">W poniższych przykładach przedstawiono, że całkowita 2-krotka można porównać do długiej krotki 2 ze względu na niejawną konwersję z liczby całkowitej na długą:</span><span class="sxs-lookup"><span data-stu-id="f32c3-193">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="f32c3-194">Nazwy członków krotki nie uczestniczą w testach równości.</span><span class="sxs-lookup"><span data-stu-id="f32c3-194">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="f32c3-195">Jednak jeśli jeden z argumentów jest literału krotki z jawnymi nazwami, kompilator generuje ostrzeżenie CS8383, jeśli te nazwy nie są zgodne z nazwami innego operandu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-195">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="f32c3-196">W przypadku, gdy oba operandy są literałami krotki, ostrzeżenie znajduje się na prawym operand, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="f32c3-196">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="f32c3-197">Na koniec krotek może zawierać zagnieżdżonych krotek.</span><span class="sxs-lookup"><span data-stu-id="f32c3-197">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="f32c3-198">Równość krotki porównuje "kształt" każdego operandu za pomocą zagnieżdżonych krotek, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="f32c3-198">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="f32c3-199">Jest to błąd czasu kompilacji, aby porównać dwie krotki dla równości (lub nierówności), gdy mają różne kształty.</span><span class="sxs-lookup"><span data-stu-id="f32c3-199">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="f32c3-200">Kompilator nie będzie próbował żadnej dekonstrukcji zagnieżdżonych krotek w celu ich porównania.</span><span class="sxs-lookup"><span data-stu-id="f32c3-200">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="f32c3-201">Przypisanie i krotek</span><span class="sxs-lookup"><span data-stu-id="f32c3-201">Assignment and tuples</span></span>

<span data-ttu-id="f32c3-202">Język obsługuje przypisanie między typami krotki, które mają taką samą liczbę elementów, gdzie każdy element po prawej stronie można niejawnie konwertować na odpowiedni element po lewej stronie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-202">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="f32c3-203">Inne konwersje nie są uwzględniane w przypadku przypisań.</span><span class="sxs-lookup"><span data-stu-id="f32c3-203">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="f32c3-204">Jest to błąd czasu kompilacji, aby przypisać jedną krotkę do innej, gdy mają różne kształty.</span><span class="sxs-lookup"><span data-stu-id="f32c3-204">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="f32c3-205">Kompilator nie będzie próbował żadnej dekonstrukcji zagnieżdżonych krotek w celu ich przypisania.</span><span class="sxs-lookup"><span data-stu-id="f32c3-205">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="f32c3-206">Przyjrzyjmy się rodzajom przypisań, które są dozwolone między typami krotki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-206">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="f32c3-207">Należy wziąć pod uwagę te zmienne używane w poniższych przykładach:</span><span class="sxs-lookup"><span data-stu-id="f32c3-207">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="f32c3-208">Pierwsze dwie zmienne `unnamed` i `anonymous` nie mają nazwy semantyczne przewidziane dla elementów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-208">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="f32c3-209">Nazwy pól `Item1` są `Item2`i .</span><span class="sxs-lookup"><span data-stu-id="f32c3-209">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="f32c3-210">Ostatnie dwie zmienne `named` i `differentName` mają nazwy semantyczne podane dla elementów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-210">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="f32c3-211">Te dwie krotki mają różne nazwy elementów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-211">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="f32c3-212">Wszystkie cztery z tych krotek mają taką samą liczbę elementów (określane jako "kardynalność"), a typy tych elementów są identyczne.</span><span class="sxs-lookup"><span data-stu-id="f32c3-212">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="f32c3-213">W związku z tym wszystkie te zadania działają:</span><span class="sxs-lookup"><span data-stu-id="f32c3-213">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="f32c3-214">Należy zauważyć, że nazwy krotek nie są przypisane.</span><span class="sxs-lookup"><span data-stu-id="f32c3-214">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="f32c3-215">Wartości elementów są przypisywane zgodnie z kolejnością elementów w krotce.</span><span class="sxs-lookup"><span data-stu-id="f32c3-215">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="f32c3-216">Krotek różnych typów lub liczb elementów nie można przypisać:</span><span class="sxs-lookup"><span data-stu-id="f32c3-216">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="f32c3-217">Krotek jako wartości zwracane metody</span><span class="sxs-lookup"><span data-stu-id="f32c3-217">Tuples as method return values</span></span>

<span data-ttu-id="f32c3-218">Jednym z najczęstszych zastosowań krotek jest jako wartość zwracana metody.</span><span class="sxs-lookup"><span data-stu-id="f32c3-218">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="f32c3-219">Przejdźmy przez jeden przykład.</span><span class="sxs-lookup"><span data-stu-id="f32c3-219">Let's walk through one example.</span></span> <span data-ttu-id="f32c3-220">Należy wziąć pod uwagę tę metodę, która oblicza odchylenie standardowe dla sekwencji liczb:</span><span class="sxs-lookup"><span data-stu-id="f32c3-220">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="f32c3-221">W tych przykładach obliczasię nieskorygowane odchylenie standardowe próbki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-221">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="f32c3-222">Skorygowana standardowa formuła odchylenia próbki podzieliłaby sumę kwadratowych różnic od średniej przez (N-1) zamiast N, tak jak robi to metoda `Average` rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="f32c3-222">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="f32c3-223">Zapoznaj się z tekstem statystyk, aby uzyskać więcej informacji na temat różnic między tymi formułami odchylenia standardowego.</span><span class="sxs-lookup"><span data-stu-id="f32c3-223">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="f32c3-224">Poprzedni kod jest zgodny z formułą podręcznika dla odchylenia standardowego.</span><span class="sxs-lookup"><span data-stu-id="f32c3-224">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="f32c3-225">Daje poprawną odpowiedź, ale jest to nieefektywna implementacja.</span><span class="sxs-lookup"><span data-stu-id="f32c3-225">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="f32c3-226">Ta metoda wylicza sekwencję dwa razy: Raz do wytworzenia średniej, a raz do wytworzenia średniej kwadratu różnicy średniej.</span><span class="sxs-lookup"><span data-stu-id="f32c3-226">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="f32c3-227">(Należy pamiętać, że zapytania LINQ są oceniane leniwie, więc obliczenia różnic od średniej i średniej z tych różnic sprawia, że tylko jedno wyliczenie.)</span><span class="sxs-lookup"><span data-stu-id="f32c3-227">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="f32c3-228">Istnieje alternatywna formuła, która oblicza odchylenie standardowe przy użyciu tylko jednego wyliczenia sekwencji.</span><span class="sxs-lookup"><span data-stu-id="f32c3-228">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="f32c3-229">To obliczenia tworzy dwie wartości, ponieważ wylicza sekwencję: suma wszystkich elementów w sekwencji i suma każdej wartości do kwadratu:</span><span class="sxs-lookup"><span data-stu-id="f32c3-229">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="f32c3-230">Ta wersja wylicza sekwencję dokładnie raz.</span><span class="sxs-lookup"><span data-stu-id="f32c3-230">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="f32c3-231">Ale to nie jest kod wielokrotnego użytku.</span><span class="sxs-lookup"><span data-stu-id="f32c3-231">But it's not reusable code.</span></span> <span data-ttu-id="f32c3-232">Podczas pracy można znaleźć, że wiele różnych obliczeń statystycznych używać liczby elementów w sekwencji, suma sekwencji i suma kwadratów sekwencji.</span><span class="sxs-lookup"><span data-stu-id="f32c3-232">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="f32c3-233">Refaktoryzujmy tę metodę i napiszmy metodę użyteczną, która tworzy wszystkie trzy z tych wartości.</span><span class="sxs-lookup"><span data-stu-id="f32c3-233">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="f32c3-234">Wszystkie trzy wartości mogą być zwracane jako krotka.</span><span class="sxs-lookup"><span data-stu-id="f32c3-234">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="f32c3-235">Zaktualizujmy tę metodę, aby trzy wartości obliczone podczas wyliczenia były przechowywane w krotce.</span><span class="sxs-lookup"><span data-stu-id="f32c3-235">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="f32c3-236">To tworzy tę wersję:</span><span class="sxs-lookup"><span data-stu-id="f32c3-236">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="f32c3-237">Obsługa refaktoryzacji programu Visual Studio ułatwia wyodrębnianie funkcji podstawowych statystyk do metody prywatnej.</span><span class="sxs-lookup"><span data-stu-id="f32c3-237">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="f32c3-238">To daje `private static` metodę, która zwraca typ krotki `Sum` `SumOfSquares`z `Count`trzema wartościami , i :</span><span class="sxs-lookup"><span data-stu-id="f32c3-238">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]

<span data-ttu-id="f32c3-239">Język umożliwia kilka opcji, które można użyć, jeśli chcesz dokonać kilku szybkich edycji ręcznie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-239">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="f32c3-240">Najpierw można użyć `var` deklaracji do zainicjowania wyniku krotki z wywołania `ComputeSumAndSumOfSquares` metody.</span><span class="sxs-lookup"><span data-stu-id="f32c3-240">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="f32c3-241">Wewnątrz `ComputeSumAndSumOfSquares` metody można również utworzyć trzy zmienne dyskretne.</span><span class="sxs-lookup"><span data-stu-id="f32c3-241">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="f32c3-242">Ostateczna wersja jest pokazana w następującym kodzie:</span><span class="sxs-lookup"><span data-stu-id="f32c3-242">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="f32c3-243">Ta ostateczna wersja może służyć dla dowolnej metody, która wymaga tych trzech wartości lub dowolnego podzbioru z nich.</span><span class="sxs-lookup"><span data-stu-id="f32c3-243">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="f32c3-244">Język obsługuje inne opcje w zarządzaniu nazwy elementów w tych metod zwracania krotki.</span><span class="sxs-lookup"><span data-stu-id="f32c3-244">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="f32c3-245">Można usunąć nazwy pól z deklaracji wartości zwracanej i zwrócić nienazwaną krotkę:</span><span class="sxs-lookup"><span data-stu-id="f32c3-245">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="f32c3-246">Pola tej krotki `Item1`są `Item2`nazywane `Item3`, i .</span><span class="sxs-lookup"><span data-stu-id="f32c3-246">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="f32c3-247">Zaleca się podanie nazw semantycznych elementom krotek zwracanych z metod.</span><span class="sxs-lookup"><span data-stu-id="f32c3-247">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="f32c3-248">Innym idiomem, gdzie krotek mogą być przydatne jest podczas tworzenia zapytań LINQ.</span><span class="sxs-lookup"><span data-stu-id="f32c3-248">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="f32c3-249">Ostateczny przewidywany wynik często zawiera niektóre, ale nie wszystkie właściwości wybranych obiektów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-249">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="f32c3-250">Tradycyjnie rzutować wyniki kwerendy do sekwencji obiektów, które były typu anonimowego.</span><span class="sxs-lookup"><span data-stu-id="f32c3-250">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="f32c3-251">To przedstawiło wiele ograniczeń, głównie dlatego, że typy anonimowe nie można wygodnie nazwać w typie zwracanym dla metody.</span><span class="sxs-lookup"><span data-stu-id="f32c3-251">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="f32c3-252">Alternatywy `object` przy `dynamic` użyciu lub jako typ wyniku przyszedł ze znacznymi kosztami wydajności.</span><span class="sxs-lookup"><span data-stu-id="f32c3-252">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="f32c3-253">Zwracanie sekwencji typu krotki jest łatwe, a nazwy i typy elementów są dostępne w czasie kompilacji i za pośrednictwem narzędzi IDE.</span><span class="sxs-lookup"><span data-stu-id="f32c3-253">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="f32c3-254">Rozważmy na przykład aplikację DoDo.</span><span class="sxs-lookup"><span data-stu-id="f32c3-254">For example, consider a ToDo application.</span></span> <span data-ttu-id="f32c3-255">Można zdefiniować klasę podobną do następującej do reprezentowania pojedynczego wpisu na liście ToDo:</span><span class="sxs-lookup"><span data-stu-id="f32c3-255">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="f32c3-256">Aplikacje mobilne mogą obsługiwać kompaktową formę bieżących elementów do wykonania, która wyświetla tylko tytuł.</span><span class="sxs-lookup"><span data-stu-id="f32c3-256">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="f32c3-257">To zapytanie LINQ będzie rzutowanie, które zawiera tylko identyfikator i tytuł.</span><span class="sxs-lookup"><span data-stu-id="f32c3-257">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="f32c3-258">Metoda, która zwraca sekwencję krotek wyraża, że projekt dobrze:</span><span class="sxs-lookup"><span data-stu-id="f32c3-258">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="f32c3-259">W języku C# 7.1 rzutowania krotki umożliwiają tworzenie nazwanych krotek przy użyciu elementów, w sposób podobny do nazewnictwa właściwości w typach anonimowych.</span><span class="sxs-lookup"><span data-stu-id="f32c3-259">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="f32c3-260">W powyższym kodzie instrukcja `select` w projekcji kwerendy `ID` `Title`tworzy krotkę, która ma elementy i .</span><span class="sxs-lookup"><span data-stu-id="f32c3-260">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="f32c3-261">Nazwana krotka może być częścią podpisu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-261">The named tuple can be part of the signature.</span></span> <span data-ttu-id="f32c3-262">Umożliwia kompilatora i IDE narzędzia zapewniają statyczne sprawdzanie, że używasz wynik poprawnie.</span><span class="sxs-lookup"><span data-stu-id="f32c3-262">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="f32c3-263">Nazwany krotka również przenosi informacje o typie statycznym, więc nie ma potrzeby używania kosztownych funkcji czasu wykonywania, takich jak odbicie lub dynamiczne powiązanie do pracy z wynikami.</span><span class="sxs-lookup"><span data-stu-id="f32c3-263">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="f32c3-264">Dekonstrukcji</span><span class="sxs-lookup"><span data-stu-id="f32c3-264">Deconstruction</span></span>

<span data-ttu-id="f32c3-265">Można rozpakować wszystkie elementy w krotce, *dekonstruując* krotkę zwróconą przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f32c3-265">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="f32c3-266">Istnieją trzy różne podejścia do dekonstrukcji krotek.</span><span class="sxs-lookup"><span data-stu-id="f32c3-266">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="f32c3-267">Najpierw można jawnie zadeklarować typ każdego pola w nawiasach, aby utworzyć zmienne dyskretne dla każdego z elementów w krotce:</span><span class="sxs-lookup"><span data-stu-id="f32c3-267">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="f32c3-268">Można również zadeklarować niejawnie wpisane zmienne dla każdego `var` pola w krotce przy użyciu słowa kluczowego poza nawiasami:</span><span class="sxs-lookup"><span data-stu-id="f32c3-268">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="f32c3-269">Jest również legalne użycie `var` słowa kluczowego z dowolnymi lub wszystkimi deklaracjami zmiennych w nawiasach.</span><span class="sxs-lookup"><span data-stu-id="f32c3-269">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span>

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="f32c3-270">Nie można użyć określonego typu poza nawiasami, nawet jeśli każde pole w krotce ma ten sam typ.</span><span class="sxs-lookup"><span data-stu-id="f32c3-270">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="f32c3-271">Można dekonstruować krotek z istniejących deklaracji, jak również:</span><span class="sxs-lookup"><span data-stu-id="f32c3-271">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="f32c3-272">Nie można mieszać istniejących deklaracji z deklaracjami wewnątrz nawiasów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-272">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="f32c3-273">Na przykład, następujące nie `(var x, y) = MyMethod();`jest dozwolone: .</span><span class="sxs-lookup"><span data-stu-id="f32c3-273">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="f32c3-274">Powoduje to błąd CS8184, ponieważ *x* jest zadeklarowany wewnątrz nawiasów i *y* jest wcześniej zadeklarowany w innym miejscu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-274">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="f32c3-275">Dekonstrukcja typów zdefiniowanych przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="f32c3-275">Deconstructing user-defined types</span></span>

<span data-ttu-id="f32c3-276">Każdy typ krotki może zostać zdekonstruowany, jak pokazano powyżej.</span><span class="sxs-lookup"><span data-stu-id="f32c3-276">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="f32c3-277">Jest również łatwe do włączania dekonstrukcji na dowolnym typie zdefiniowanym przez użytkownika (klasy, struktury, a nawet interfejsy).</span><span class="sxs-lookup"><span data-stu-id="f32c3-277">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="f32c3-278">Autor typu można zdefiniować `Deconstruct` jedną lub więcej metod, które `out` przypisują wartości do dowolnej liczby zmiennych reprezentujących elementy danych, które tworzą typ.</span><span class="sxs-lookup"><span data-stu-id="f32c3-278">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="f32c3-279">Na przykład następujący `Person` typ definiuje `Deconstruct` metodę, która dekonstruuje obiekt osoby do elementów reprezentujących imię i nazwisko:</span><span class="sxs-lookup"><span data-stu-id="f32c3-279">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="f32c3-280">Metoda dekonstrukcji umożliwia przypisanie z `Person` dwóch ciągów, reprezentujących `FirstName` i `LastName` właściwości:</span><span class="sxs-lookup"><span data-stu-id="f32c3-280">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="f32c3-281">Dekonstrukcji można włączyć nawet w przypadku typów, których nie autoryzowano.</span><span class="sxs-lookup"><span data-stu-id="f32c3-281">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="f32c3-282">Metoda `Deconstruct` może być metodą rozszerzenia, która rozpakowuje dostępne elementy członkowskie danych obiektu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-282">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="f32c3-283">Poniższy przykład przedstawia `Student` typ, pochodzące `Person` z typu i metody rozszerzenia, `Student` która dekonstruuje na `FirstName`trzy `LastName`zmienne, `GPA`reprezentujących , , i :</span><span class="sxs-lookup"><span data-stu-id="f32c3-283">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="f32c3-284">Obiekt `Student` ma teraz `Deconstruct` dwie dostępne metody: metodę `Student` rozszerzenia zadeklarowaną dla `Person` typów i element członkowski typu.</span><span class="sxs-lookup"><span data-stu-id="f32c3-284">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="f32c3-285">Oba są w zakresie i `Student` który umożliwia dekonstrukcji do dwóch zmiennych lub trzech.</span><span class="sxs-lookup"><span data-stu-id="f32c3-285">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="f32c3-286">Jeśli przypiszesz studenta do trzech zmiennych, zostaną zwrócone imię, nazwisko i GPA.</span><span class="sxs-lookup"><span data-stu-id="f32c3-286">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="f32c3-287">Jeśli przypiszesz studenta do dwóch zmiennych, zwracane są tylko imię i nazwisko.</span><span class="sxs-lookup"><span data-stu-id="f32c3-287">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="f32c3-288">Należy zachować ostrożność, definiując wiele `Deconstruct` metod w klasie lub hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="f32c3-288">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="f32c3-289">Wiele `Deconstruct` metod, które mają `out` taką samą liczbę parametrów może szybko powodować niejasności.</span><span class="sxs-lookup"><span data-stu-id="f32c3-289">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="f32c3-290">Dzwoniący mogą nie być w `Deconstruct` stanie łatwo wywołać żądaną metodę.</span><span class="sxs-lookup"><span data-stu-id="f32c3-290">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="f32c3-291">W tym przykładzie istnieje minimalna szansa na `Deconstruct` niejednoznaczne wywołanie, ponieważ metoda ma `Person` dwa parametry wyjściowe, a `Deconstruct` metoda ma `Student` trzy.</span><span class="sxs-lookup"><span data-stu-id="f32c3-291">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="f32c3-292">Operatorzy dekonstrukcji nie uczestniczą w testowaniu równości.</span><span class="sxs-lookup"><span data-stu-id="f32c3-292">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="f32c3-293">Poniższy przykład generuje błąd kompilatora CS0019:</span><span class="sxs-lookup"><span data-stu-id="f32c3-293">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="f32c3-294">Metoda `Deconstruct` może przekonwertować `Person` obiekt `p` do krotki zawierającej dwa ciągi, ale nie ma zastosowania w kontekście testów równości.</span><span class="sxs-lookup"><span data-stu-id="f32c3-294">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="f32c3-295">Krotek jako parametry out</span><span class="sxs-lookup"><span data-stu-id="f32c3-295">Tuples as out parameters</span></span>

<span data-ttu-id="f32c3-296">Krotek można używać jako *samych*parametrów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-296">Tuples can be used as out parameters *themselves*.</span></span> <span data-ttu-id="f32c3-297">Nie należy mylić z żadną dwuznacznością wspomnianą wcześniej w sekcji [dekonstrukcji.](#deconstruction)</span><span class="sxs-lookup"><span data-stu-id="f32c3-297">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="f32c3-298">W wywołaniu metody należy opisać tylko kształt krotki:</span><span class="sxs-lookup"><span data-stu-id="f32c3-298">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="f32c3-299">Alternatywnie można użyć [_nienazwanej_](#named-and-unnamed-tuples) krotki i `Item1` odwoływać się do jej pól jako i: `Item2`</span><span class="sxs-lookup"><span data-stu-id="f32c3-299">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="f32c3-300">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="f32c3-300">Conclusion</span></span>

<span data-ttu-id="f32c3-301">Obsługa nowego języka i biblioteki dla nazwanych krotek znacznie ułatwia pracę z projektami, które używają struktur danych, które przechowują wiele elementów, ale nie definiują zachowanie, jak klasy i struktury zrobić.</span><span class="sxs-lookup"><span data-stu-id="f32c3-301">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="f32c3-302">Jest to łatwe i zwięzłe w użyciu krotek dla tych typów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-302">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="f32c3-303">Otrzymasz wszystkie zalety sprawdzania typu statycznego, bez konieczności tworzenia `class` typów `struct` przy użyciu bardziej pełne lub składni.</span><span class="sxs-lookup"><span data-stu-id="f32c3-303">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="f32c3-304">Mimo to, są one najbardziej przydatne `private`dla `internal`metod użytkowych, które są , lub .</span><span class="sxs-lookup"><span data-stu-id="f32c3-304">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="f32c3-305">Tworzenie typów zdefiniowanych `class` przez `struct` użytkownika lub typy, gdy metody publiczne zwracają wartość, która ma wiele elementów.</span><span class="sxs-lookup"><span data-stu-id="f32c3-305">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
