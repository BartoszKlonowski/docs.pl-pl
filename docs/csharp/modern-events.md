---
title: Wzorzec zdarzeń zaktualizowane środowiska .NET Core
description: Dowiedz się, jak wzorzec zdarzeń platformy .NET Core umożliwia elastyczność dzięki wstecznej zgodności oraz sposób implementacji przetwarzanie zdarzeń bezpieczne subskrybentami async.
ms.date: 06/20/2016
ms.assetid: 9aa627c3-3222-4094-9ca8-7e88e1071e06
ms.openlocfilehash: 3cab80a0f4fcd3343fdeff265135f1503c036514
ms.sourcegitcommit: c93fd5139f9efcf6db514e3474301738a6d1d649
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/27/2018
ms.locfileid: "50188485"
---
# <a name="the-updated-net-core-event-pattern"></a><span data-ttu-id="12ce6-103">Wzorzec zdarzeń zaktualizowane środowiska .NET Core</span><span class="sxs-lookup"><span data-stu-id="12ce6-103">The Updated .NET Core Event Pattern</span></span>

[<span data-ttu-id="12ce6-104">Poprzednie</span><span class="sxs-lookup"><span data-stu-id="12ce6-104">Previous</span></span>](event-pattern.md)

<span data-ttu-id="12ce6-105">Poprzednim artykule omówiono najbardziej typowe wzorce zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="12ce6-105">The previous article discussed the most common event patterns.</span></span> <span data-ttu-id="12ce6-106">.NET core zawiera wzorzec mniej restrykcyjne.</span><span class="sxs-lookup"><span data-stu-id="12ce6-106">.NET Core has a more relaxed pattern.</span></span> <span data-ttu-id="12ce6-107">W tej wersji `EventHandler<TEventArgs>` definicja zawiera już ograniczenie, `TEventArgs` musi być klasą pochodną `System.EventArgs`.</span><span class="sxs-lookup"><span data-stu-id="12ce6-107">In this version, the `EventHandler<TEventArgs>` definition no longer has the constraint that `TEventArgs` must be a class derived from `System.EventArgs`.</span></span>

<span data-ttu-id="12ce6-108">Zwiększa elastyczność i jest wstecznie zgodna.</span><span class="sxs-lookup"><span data-stu-id="12ce6-108">This increases flexibility for you, and is backwards compatible.</span></span> <span data-ttu-id="12ce6-109">Zacznijmy od elastyczność.</span><span class="sxs-lookup"><span data-stu-id="12ce6-109">Let's start with the flexibility.</span></span> <span data-ttu-id="12ce6-110">Klasa System.EventArgs wprowadza jednej metody: `MemberwiseClone()`, która tworzy płytką kopię obiektu.</span><span class="sxs-lookup"><span data-stu-id="12ce6-110">The class System.EventArgs introduces one method: `MemberwiseClone()`, which creates a shallow copy of the object.</span></span>
<span data-ttu-id="12ce6-111">Metoda musi używać odbicia w celu wdrożenia jej funkcjonalność dla dowolnej klasy pochodnej `EventArgs`.</span><span class="sxs-lookup"><span data-stu-id="12ce6-111">That method must use reflection in order to implement its functionality for any class derived from `EventArgs`.</span></span> <span data-ttu-id="12ce6-112">Funkcja jest łatwiejsze do utworzenia w określonej klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="12ce6-112">That functionality is easier to create in a specific derived class.</span></span> <span data-ttu-id="12ce6-113">Oznacza to skutecznie pochodząca od System.EventArgs to ograniczenie, które ogranicza projektów, ale nie zapewnia żadnych dodatkowych korzyści.</span><span class="sxs-lookup"><span data-stu-id="12ce6-113">That effectively means that deriving from System.EventArgs is a constraint that limits your designs, but does not provide any additional benefit.</span></span>
<span data-ttu-id="12ce6-114">W rzeczywistości można zmieniać definicje typów elementów `FileFoundArgs` i `SearchDirectoryArgs` tak, aby nie pochodzą one od `EventArgs`.</span><span class="sxs-lookup"><span data-stu-id="12ce6-114">In fact, you can change the definitions of `FileFoundArgs` and `SearchDirectoryArgs` so that they do not derive from `EventArgs`.</span></span>
<span data-ttu-id="12ce6-115">Program będzie działać tak samo.</span><span class="sxs-lookup"><span data-stu-id="12ce6-115">The program will work exactly the same.</span></span>

<span data-ttu-id="12ce6-116">Możesz również zmienić `SearchDirectoryArgs` na strukturę co więcej zmiany:</span><span class="sxs-lookup"><span data-stu-id="12ce6-116">You could also change the `SearchDirectoryArgs` to a struct, if you make one more change:</span></span>

[!code-csharp[SearchDir](../../samples/csharp/events/Program.cs#DeclareSearchEvent "Define search directory event")]

<span data-ttu-id="12ce6-117">Kolejna zmiana jest wywołanie konstruktora domyślnego przed wchodzenie do konstruktora, która inicjuje wszystkie pola.</span><span class="sxs-lookup"><span data-stu-id="12ce6-117">The additional change is to call the default constructor before entering the constructor that initializes all the fields.</span></span> <span data-ttu-id="12ce6-118">Bez tego dodatku, regułami C# może zgłosić, że właściwości są dostępne przed zostały przypisane.</span><span class="sxs-lookup"><span data-stu-id="12ce6-118">Without that addition, the rules of C# would report that the properties are being accessed before they have been assigned.</span></span>

<span data-ttu-id="12ce6-119">Nie należy zmieniać `FileFoundArgs` z klasy (typ odwołania) na strukturę (typ wartości).</span><span class="sxs-lookup"><span data-stu-id="12ce6-119">You should not change the `FileFoundArgs` from a class (reference type) to a struct (value type).</span></span> <span data-ttu-id="12ce6-120">To, ponieważ protokół obsługę anulowania, wymaga, że argumenty zdarzenia są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="12ce6-120">That's because the protocol for handling cancel requires that the event arguments are passed by reference.</span></span> <span data-ttu-id="12ce6-121">Jeśli wprowadzono tę samą zmianę klasa wyszukiwania pliku nigdy nie może obserwować zmiany wprowadzone przez wszystkich subskrybentów zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="12ce6-121">If you made the same change, the file search class could never observe any changes made by any of the event subscribers.</span></span> <span data-ttu-id="12ce6-122">Nową kopię struktury będzie używana dla każdego subskrybenta, a tej kopii będzie kopię innej niż ta, widoczne dla obiektu wyszukiwania pliku.</span><span class="sxs-lookup"><span data-stu-id="12ce6-122">A new copy of the structure would be used for each subscriber, and that copy would be a different copy than the one seen by the file search object.</span></span>

<span data-ttu-id="12ce6-123">Następnie zastanówmy się, jak ta zmiana może być wstecznie zgodne.</span><span class="sxs-lookup"><span data-stu-id="12ce6-123">Next, let's consider how this change can be backwards compatible.</span></span>
<span data-ttu-id="12ce6-124">Usuwanie ograniczenia, nie ma wpływu na istniejący kod.</span><span class="sxs-lookup"><span data-stu-id="12ce6-124">The removal of the constraint does not affect any existing code.</span></span> <span data-ttu-id="12ce6-125">Wszelkie istniejące typy argumentów zdarzenia dziedziczą z `System.EventArgs`.</span><span class="sxs-lookup"><span data-stu-id="12ce6-125">Any existing event argument types do still derive from `System.EventArgs`.</span></span>
<span data-ttu-id="12ce6-126">Wstecz zgodność jest główną przyczyną Dlaczego będą one nadal dziedziczyć `System.EventArgs`.</span><span class="sxs-lookup"><span data-stu-id="12ce6-126">Backwards compatibility is one major reason why they will continue to derive from `System.EventArgs`.</span></span> <span data-ttu-id="12ce6-127">Żadnych istniejących subskrybentów zdarzeń będzie subskrybentów do zdarzenia, a następnie klasycznego wzorca.</span><span class="sxs-lookup"><span data-stu-id="12ce6-127">Any existing event subscribers will be subscribers to an event that followed the classic pattern.</span></span>

<span data-ttu-id="12ce6-128">Po każdym podobnej logiki argumentu zdarzenia utworzony typ teraz nie będzie zawierało żadnych subskrybentów w żadnych istniejących bazach kodu.</span><span class="sxs-lookup"><span data-stu-id="12ce6-128">Following similar logic, any event argument type created now would not have any subscribers in any existing codebases.</span></span> <span data-ttu-id="12ce6-129">Nowe typy zdarzeń, które nie pochodzą z `System.EventArgs` będzie przerwać tych ścieżek bazowych kodu.</span><span class="sxs-lookup"><span data-stu-id="12ce6-129">New event types that do not derive from `System.EventArgs` will not break those codebases.</span></span>

## <a name="events-with-async-subscribers"></a><span data-ttu-id="12ce6-130">Zdarzenia przy użyciu Async subskrybentów</span><span class="sxs-lookup"><span data-stu-id="12ce6-130">Events with Async subscribers</span></span>

<span data-ttu-id="12ce6-131">Masz jeden wzorzec końcowego Aby dowiedzieć się więcej: jak poprawnie zapisać subskrybentów zdarzeń, które wywołują kod asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="12ce6-131">You have one final pattern to learn: How to correctly write event subscribers that call async code.</span></span> <span data-ttu-id="12ce6-132">Żądania został opisany w artykule na [async i await](async.md).</span><span class="sxs-lookup"><span data-stu-id="12ce6-132">The challenge is described in the article on [async and await](async.md).</span></span> <span data-ttu-id="12ce6-133">Metody asynchroniczne mogą mieć zwracać typ void, ale jest zdecydowanie odradzane.</span><span class="sxs-lookup"><span data-stu-id="12ce6-133">Async methods can have a void return type, but that is strongly discouraged.</span></span> <span data-ttu-id="12ce6-134">Gdy kod dla subskrybentów zdarzeń wywołuje metody asynchronicznej, masz nie wyboru, a do utworzenia `async void` metody.</span><span class="sxs-lookup"><span data-stu-id="12ce6-134">When your event subscriber code calls an async method, you have no choice but to create an `async void` method.</span></span> <span data-ttu-id="12ce6-135">Podpis programu obsługi zdarzeń go wymaga.</span><span class="sxs-lookup"><span data-stu-id="12ce6-135">The event handler signature requires it.</span></span>

<span data-ttu-id="12ce6-136">Należy uzgodnić tych wskazówkach przeciwstawnym.</span><span class="sxs-lookup"><span data-stu-id="12ce6-136">You need to reconcile this opposing guidance.</span></span> <span data-ttu-id="12ce6-137">Jakiś sposób, należy utworzyć bezpiecznego `async void` metody.</span><span class="sxs-lookup"><span data-stu-id="12ce6-137">Somehow, you must create a safe `async void` method.</span></span> <span data-ttu-id="12ce6-138">Podstawowe informacje potrzebne do zaimplementowania wzorca znajdują się poniżej:</span><span class="sxs-lookup"><span data-stu-id="12ce6-138">The basics of the pattern you need to implement are below:</span></span>

```csharp
worker.StartWorking += async (sender, eventArgs) =>
{
    try 
    {
        await DoWorkAsync();
    }
    catch (Exception e)
    {
        //Some form of logging.
        Console.WriteLine($"Async task failure: {e.ToString()}");
        // Consider gracefully, and quickly exiting.
    }
};
```

<span data-ttu-id="12ce6-139">Najpierw zwróć uwagę, że program obsługi jest oznaczona jako async obsługi.</span><span class="sxs-lookup"><span data-stu-id="12ce6-139">First, notice that the handler is marked as an async handler.</span></span> <span data-ttu-id="12ce6-140">Ponieważ jest ona obecnie przypisywana do obsługi zdarzeń typ delegata, ma zwracać typ void.</span><span class="sxs-lookup"><span data-stu-id="12ce6-140">Because it is being assigned to an event handler delegate type, it will have a void return type.</span></span> <span data-ttu-id="12ce6-141">Oznacza to, musi wykonać wzoru pokazanego w procedurze obsługi i zezwala na wszystkie wyjątki zostanie wygenerowany poza kontekstem programu async obsługi.</span><span class="sxs-lookup"><span data-stu-id="12ce6-141">That means you must follow the pattern shown in the handler, and not allow any exceptions to be thrown out of the context of the async handler.</span></span> <span data-ttu-id="12ce6-142">Ponieważ zwraca zadanie, nie istnieje żadne zadanie, które mogą zgłosić błąd, wprowadzając stanie błędnym.</span><span class="sxs-lookup"><span data-stu-id="12ce6-142">Because it does not return a task, there is no task that can report the error by entering the faulted state.</span></span> <span data-ttu-id="12ce6-143">Ponieważ metoda async, metoda po prostu nie można zgłosić wyjątek.</span><span class="sxs-lookup"><span data-stu-id="12ce6-143">Because the method is async, the method can't simply throw the exception.</span></span> <span data-ttu-id="12ce6-144">(Wywoływania metody ma kontynuowanie wykonywania, ponieważ jest on `async`.) Rzeczywiste działanie zostanie określony inaczej dla różnych środowisk.</span><span class="sxs-lookup"><span data-stu-id="12ce6-144">(The calling method has continued execution because it is `async`.) The actual runtime behavior will be defined differently for different environments.</span></span> <span data-ttu-id="12ce6-145">Może rozwiązać niniejszą wątku, może rozwiązać niniejszą program lub może on pozostawić program w stanie nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="12ce6-145">It may terminate the thread, it may terminate the program, or it may leave the program in an undetermined state.</span></span> <span data-ttu-id="12ce6-146">Żaden z nich są dobre wyniki.</span><span class="sxs-lookup"><span data-stu-id="12ce6-146">None of those are good outcomes.</span></span>

<span data-ttu-id="12ce6-147">Dlatego zawijania instrukcji czekania asynchroniczne zadanie w własne bloku try.</span><span class="sxs-lookup"><span data-stu-id="12ce6-147">That's why you should wrap the await statement for the async Task in your own try block.</span></span> <span data-ttu-id="12ce6-148">To spowodować uszkodzoną zadań, po zalogowaniu błędu.</span><span class="sxs-lookup"><span data-stu-id="12ce6-148">If it does cause a faulted task, you can log the error.</span></span> <span data-ttu-id="12ce6-149">Jeśli jest to błąd, z którego nie można odzyskać aplikacji, można zakończyć program, szybko i bezpiecznie</span><span class="sxs-lookup"><span data-stu-id="12ce6-149">If it is an error from which your application cannot recover, you can exit the program quickly and gracefully</span></span>

<span data-ttu-id="12ce6-150">Są ważne aktualizacje wzorce zdarzeń platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="12ce6-150">Those are the major updates to the .NET event pattern.</span></span> <span data-ttu-id="12ce6-151">Zobaczysz wiele przykładów wcześniejszych wersji w bibliotekach, z którymi pracujesz.</span><span class="sxs-lookup"><span data-stu-id="12ce6-151">You will see many examples of the earlier versions in the libraries you work with.</span></span> <span data-ttu-id="12ce6-152">Jednak należy zrozumieć, jakie najnowsze wzorce są również.</span><span class="sxs-lookup"><span data-stu-id="12ce6-152">However, you should understand what the latest patterns are as well.</span></span>

<span data-ttu-id="12ce6-153">Następny artykuł w tej serii pomaga rozróżnić przy użyciu `delegates` i `events` w projektach.</span><span class="sxs-lookup"><span data-stu-id="12ce6-153">The next article in this series helps you distinguish between using `delegates` and `events` in your designs.</span></span> <span data-ttu-id="12ce6-154">Są one podobne pojęcia, a ten artykuł pomoże Ci najlepszych decyzji programów.</span><span class="sxs-lookup"><span data-stu-id="12ce6-154">They are similar concepts, and that article will help you make the best decision for your programs.</span></span>

[<span data-ttu-id="12ce6-155">Next</span><span class="sxs-lookup"><span data-stu-id="12ce6-155">Next</span></span>](distinguish-delegates-events.md)
