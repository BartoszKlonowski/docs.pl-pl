---
title: "Metody — przewodnik C#"
description: "Przegląd metod, parametrów metod i wartości zwracane — metoda"
keywords: .NET, .NET Core, C#
author: rpetrusha
ms.author: ronpet
ms.date: 10/26/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: 48127d5168ace7733f29f78dc3f72d9c0d051e4e
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2018
---
# <a name="methods"></a><span data-ttu-id="2df82-104">Metody</span><span class="sxs-lookup"><span data-stu-id="2df82-104">Methods</span></span> #

<span data-ttu-id="2df82-105">Metoda jest blok kodu, który zawiera serię instrukcji.</span><span class="sxs-lookup"><span data-stu-id="2df82-105">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="2df82-106">Program powoduje, że instrukcje, które ma być wykonane przez wywołanie metody i określanie żadnych argumentów wymaganej metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-106">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="2df82-107">W języku C# co wykonanie instrukcji jest wykonywane w kontekście metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-107">In C#, every executed instruction is performed in the context of a method.</span></span> <span data-ttu-id="2df82-108">`Main` Metoda jest punkt wejścia dla każdej aplikacji C# i jest wywoływane przez środowisko uruchomieniowe języka wspólnego (CLR), gdy program jest uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="2df82-108">The `Main` method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</span></span>

> [!NOTE]
> <span data-ttu-id="2df82-109">W tym temacie omówiono nazwane metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-109">This topic discusses named methods.</span></span> <span data-ttu-id="2df82-110">Aby uzyskać informacje na temat funkcji anonimowych, zobacz [funkcje anonimowe](programming-guide/statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="2df82-110">For information about anonymous functions, see [Anonymous Functions](programming-guide/statements-expressions-operators/anonymous-functions.md).</span></span>

<span data-ttu-id="2df82-111">Ten temat zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="2df82-111">This topic contains the following sections:</span></span>

- [<span data-ttu-id="2df82-112">Podpisy — metoda</span><span class="sxs-lookup"><span data-stu-id="2df82-112">Method signatures</span></span>](#signatures)
- [<span data-ttu-id="2df82-113">Wywołanie metody</span><span class="sxs-lookup"><span data-stu-id="2df82-113">Method invocation</span></span>](#invocation)
- [<span data-ttu-id="2df82-114">Dziedziczona i przesłoniętej metody</span><span class="sxs-lookup"><span data-stu-id="2df82-114">Inherited and overridden methods</span></span>](#inherited)
- [<span data-ttu-id="2df82-115">Przekazywanie parametrów</span><span class="sxs-lookup"><span data-stu-id="2df82-115">Passing parameters</span></span>](#passing)
  - [<span data-ttu-id="2df82-116">Przekazywanie parametrów przez wartość</span><span class="sxs-lookup"><span data-stu-id="2df82-116">Passing parameters by value</span></span>](#byval)
  - [<span data-ttu-id="2df82-117">Przekazywanie parametrów przez odwołanie</span><span class="sxs-lookup"><span data-stu-id="2df82-117">Passing parameters by reference</span></span>](#byref)
  - [<span data-ttu-id="2df82-118">Tablice parametrów</span><span class="sxs-lookup"><span data-stu-id="2df82-118">Parameter arrays</span></span>](#paramarray)
- [<span data-ttu-id="2df82-119">Opcjonalne parametry i argumenty</span><span class="sxs-lookup"><span data-stu-id="2df82-119">Optional parameters and arguments</span></span>](#optional)
- [<span data-ttu-id="2df82-120">Wartości zwracane</span><span class="sxs-lookup"><span data-stu-id="2df82-120">Return values</span></span>](#return)
- [<span data-ttu-id="2df82-121">Metody rozszerzenia</span><span class="sxs-lookup"><span data-stu-id="2df82-121">Extension methods</span></span>](#extension)
- [<span data-ttu-id="2df82-122">Metody asynchroniczne</span><span class="sxs-lookup"><span data-stu-id="2df82-122">Async Methods</span></span>](#async)
- [<span data-ttu-id="2df82-123">Elementy członkowskie z wyrażeniem w treści</span><span class="sxs-lookup"><span data-stu-id="2df82-123">Expression-bodied members</span></span>](#expr)
- [<span data-ttu-id="2df82-124">Iteratory</span><span class="sxs-lookup"><span data-stu-id="2df82-124">Iterators</span></span>](#iterators)

<a name="signatures"></a>
## <a name="method-signatures"></a><span data-ttu-id="2df82-125">Podpisy — metoda</span><span class="sxs-lookup"><span data-stu-id="2df82-125">Method signatures</span></span> ##

<span data-ttu-id="2df82-126">Metody są zadeklarowane w `class` lub `struct` , określając:</span><span class="sxs-lookup"><span data-stu-id="2df82-126">Methods are declared in a `class` or `struct` by specifying:</span></span>

- <span data-ttu-id="2df82-127">Opcjonalny dostęp na poziomie, takich jak `public` lub `private`.</span><span class="sxs-lookup"><span data-stu-id="2df82-127">An optional access level, such as `public` or `private`.</span></span> <span data-ttu-id="2df82-128">Wartość domyślna to `private`.</span><span class="sxs-lookup"><span data-stu-id="2df82-128">The default is `private`.</span></span>
- <span data-ttu-id="2df82-129">Modyfikatory opcjonalne, takie jak `abstract` lub `sealed`.</span><span class="sxs-lookup"><span data-stu-id="2df82-129">Optional modifiers such as `abstract` or `sealed`.</span></span>
- <span data-ttu-id="2df82-130">Wartość zwracana lub `void` Jeśli metoda ma wartość none.</span><span class="sxs-lookup"><span data-stu-id="2df82-130">The return value, or `void` if the method has none.</span></span>
- <span data-ttu-id="2df82-131">Nazwa metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-131">The method name.</span></span>
- <span data-ttu-id="2df82-132">Parametry metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-132">Any method parameters.</span></span> <span data-ttu-id="2df82-133">Parametry metody są ujęte w nawiasy i są oddzielone przecinkami.</span><span class="sxs-lookup"><span data-stu-id="2df82-133">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="2df82-134">Puste nawiasy wskazują, że metoda nie wymaga parametrów.</span><span class="sxs-lookup"><span data-stu-id="2df82-134">Empty parentheses indicate that the method requires no parameters.</span></span>

<span data-ttu-id="2df82-135">Części te tworzą razem podpis metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-135">These parts together form the method signature.</span></span>

> [!NOTE]
> <span data-ttu-id="2df82-136">Typem zwracanym metody nie jest częścią podpis metody na potrzeby przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-136">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="2df82-137">Jednak jest częścią podpis metody podczas określania zgodności między delegata i wskazujący do metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-137">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="2df82-138">W poniższym przykładzie zdefiniowano klasę o nazwie `Motorcycle` zawiera pięć metod:</span><span class="sxs-lookup"><span data-stu-id="2df82-138">The following example defines a class named `Motorcycle` that contains five methods:</span></span>

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

<span data-ttu-id="2df82-139">Należy pamiętać, że `Motorcycle` klasa zawiera metody przeciążonej `Drive`.</span><span class="sxs-lookup"><span data-stu-id="2df82-139">Note that the `Motorcycle` class includes an overloaded method, `Drive`.</span></span> <span data-ttu-id="2df82-140">Dwie metody mają taką samą nazwę, ale należy zróżnicować ich typy parametrów.</span><span class="sxs-lookup"><span data-stu-id="2df82-140">Two methods have the same name, but must be differentiated by their parameter types.</span></span>

<a name="invocation"></a>
## <a name="method-invocation"></a><span data-ttu-id="2df82-141">Wywołanie metody</span><span class="sxs-lookup"><span data-stu-id="2df82-141">Method invocation</span></span> ##

<span data-ttu-id="2df82-142">Metody mogą być *wystąpienia* lub *statycznych*.</span><span class="sxs-lookup"><span data-stu-id="2df82-142">Methods can be either *instance* or *static*.</span></span> <span data-ttu-id="2df82-143">Wywoływanie metody wystąpienia wymaga utworzenia wystąpienia obiektu, a następnie wywołać metodę dla tego obiektu; metody wystąpienia działa na to wystąpienie i jego dane.</span><span class="sxs-lookup"><span data-stu-id="2df82-143">Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</span></span> <span data-ttu-id="2df82-144">Wywołanie metody statycznej odwołując nazwę typu, do którego należy metoda; Działanie metody statyczne nie działają na dane wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="2df82-144">You invoke a static method by referencing the name of the type to which the method belongs; static methods operate do not operate on instance data.</span></span> <span data-ttu-id="2df82-145">Próba wywołania metody statycznej za pomocą wystąpienia obiektu generuje błąd kompilatora.</span><span class="sxs-lookup"><span data-stu-id="2df82-145">Attempting to call a static method through an object instance generates a compiler error.</span></span>

<span data-ttu-id="2df82-146">Wywoływanie metody jest podobne do uzyskiwania dostępu do pola.</span><span class="sxs-lookup"><span data-stu-id="2df82-146">Calling a method is like accessing a field.</span></span> <span data-ttu-id="2df82-147">Po nazwie obiektu (w przypadku wywoływania metody wystąpienia) lub nazwa typu (jeśli wywołujesz `static` metody), Dodaj okres, nazwę metody i nawiasów.</span><span class="sxs-lookup"><span data-stu-id="2df82-147">After the object name (if you are calling an instance method) or the type name (if you are calling a `static` method), add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="2df82-148">Argumenty są wyświetlane w nawiasach i są oddzielone przecinkami.</span><span class="sxs-lookup"><span data-stu-id="2df82-148">Arguments are listed within the parentheses, and are separated by commas.</span></span>

<span data-ttu-id="2df82-149">Definicja metody określa nazwy i typy parametrów, które są wymagane.</span><span class="sxs-lookup"><span data-stu-id="2df82-149">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="2df82-150">Gdy obiekt wywołujący wywołuje metodę, zapewnia konkretnych wartości, nazywanych argumenty dla każdego parametru.</span><span class="sxs-lookup"><span data-stu-id="2df82-150">When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</span></span> <span data-ttu-id="2df82-151">Argumenty muszą być zgodne z typem parametru, ale nazwa argumentu, jeśli jest on używany w wywoływanym kodzie nie ma być taki sam, jak parametr o nazwie w metodzie.</span><span class="sxs-lookup"><span data-stu-id="2df82-151">The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="2df82-152">W poniższym przykładzie `Square` metoda zawiera jeden parametr typu `int` o nazwie *i*.</span><span class="sxs-lookup"><span data-stu-id="2df82-152">In the following example, the `Square` method includes a single parameter of type `int` named *i*.</span></span> <span data-ttu-id="2df82-153">Pierwsza metoda wywołania przekazuje `Square` metody zmienną typu `int` o nazwie *num*; druga, stałej liczbowej; a trzeci, wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="2df82-153">The first method call passes the `Square` method a variable of type `int` named *num*; the second, a numeric constant; and the third, an expression.</span></span>

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

<span data-ttu-id="2df82-154">Argumenty pozycyjne; używane najczęściej wywołania metody dostarcza mu argumentów w tej samej kolejności jak parametry metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-154">The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</span></span> <span data-ttu-id="2df82-155">Metody `Motorcycle` klasa może zostać wywołana w związku z tym jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="2df82-155">The methods of the `Motorcycle` class can therefore be called as in the following example.</span></span> <span data-ttu-id="2df82-156">Wywołanie `Drive` metody, na przykład zawiera dwa argumenty, które odpowiadają tych dwóch parametrów w składni metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-156">The call to the `Drive` method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</span></span> <span data-ttu-id="2df82-157">Wartość staje się pierwszym `miles` parametr, druga wartość `speed` parametru.</span><span class="sxs-lookup"><span data-stu-id="2df82-157">The first becomes the value of the `miles` parameter, the second the value of the `speed` parameter.</span></span>

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

<span data-ttu-id="2df82-158">Można również używać *argumentami nazwanymi* zamiast argumenty pozycyjne podczas wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-158">You can also used *named arguments* instead of positional arguments when invoking a method.</span></span> <span data-ttu-id="2df82-159">Przy użyciu nazwane argumenty, określ nazwę parametru znakiem dwukropka (":") i argumentu.</span><span class="sxs-lookup"><span data-stu-id="2df82-159">When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</span></span> <span data-ttu-id="2df82-160">Argumenty metody może występować w dowolnej kolejności tak długo, jak podano wszystkich wymaganych argumentów.</span><span class="sxs-lookup"><span data-stu-id="2df82-160">Arguments to the method can appear in any order, as long as all required arguments are present.</span></span> <span data-ttu-id="2df82-161">W poniższym przykładzie użyto nazwanych argumentów do wywołania `TestMotorcycle.Drive` metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-161">The following example uses named arguments to invoke the `TestMotorcycle.Drive` method.</span></span> <span data-ttu-id="2df82-162">W tym przykładzie nazwane argumenty są przekazywane w przeciwną kolejności w liście parametrów metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-162">In this example, the named arguments are passed in the opposite order from the method's parameter list.</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

<span data-ttu-id="2df82-163">Można wywołać metody za pomocą obu argumentów pozycyjnych i argumentami nazwanymi.</span><span class="sxs-lookup"><span data-stu-id="2df82-163">You can invoke a method using both positional arguments and named arguments.</span></span> <span data-ttu-id="2df82-164">Argument pozycyjny nie może jednak wykonać nazwany argument.</span><span class="sxs-lookup"><span data-stu-id="2df82-164">However, a positional argument cannot follow a named argument.</span></span> <span data-ttu-id="2df82-165">Poniższy przykład przedstawia wywoływanie `TestMotorcycle.Drive` metody z poprzedniego przykładu przy użyciu jeden argument pozycyjny i jednego argumentu nazwanego.</span><span class="sxs-lookup"><span data-stu-id="2df82-165">The following example invokes the `TestMotorcycle.Drive` method from the previous example using one positional argument and one named argument.</span></span>

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

 <a name="inherited"></a>
 ##<a name="inherited-and-overridden-methods"></a><span data-ttu-id="2df82-166">Dziedziczona i przesłoniętej metody</span><span class="sxs-lookup"><span data-stu-id="2df82-166">Inherited and overridden methods</span></span> ##

<span data-ttu-id="2df82-167">Oprócz elementów członkowskich, które są jawnie zdefiniowane w typie typ dziedziczy elementów członkowskich zdefiniowanych w jej klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="2df82-167">In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</span></span> <span data-ttu-id="2df82-168">Ponieważ wszystkie typy w systemie typ zarządzany dziedziczy pośrednio ani bezpośrednio po <xref:System.Object> klasa, wszystkie typy dziedziczy jej elementów członkowskich, takich jak <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, i <xref:System.Object.ToString>.</span><span class="sxs-lookup"><span data-stu-id="2df82-168">Since all types in the managed type system inherit directly or indirectly from the <xref:System.Object> class, all types inherit its members, such as <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, and <xref:System.Object.ToString>.</span></span> <span data-ttu-id="2df82-169">W poniższym przykładzie zdefiniowano `Person` klasy, tworzy dwa `Person` obiekty i wywołuje `Person.Equals` metodę, aby sprawdzić, czy dwa obiekty są równe.</span><span class="sxs-lookup"><span data-stu-id="2df82-169">The following example defines a `Person` class, instantiates two `Person` objects, and calls the `Person.Equals` method to determine whether the two objects are equal.</span></span> <span data-ttu-id="2df82-170">`Equals` Metody, jednak nie jest zdefiniowany w `Person` klasy; został on odziedziczony po <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="2df82-170">The `Equals` method, however, is not defined in the `Person` class; it is inherited from <xref:System.Object>.</span></span>

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

<span data-ttu-id="2df82-171">Typy, można zastąpić dziedziczone elementy członkowskie przy użyciu `override` — słowo kluczowe i udostępnia implementację dla przeciążonej.</span><span class="sxs-lookup"><span data-stu-id="2df82-171">Types can override inherited members by using the `override` keyword and providing an implementation for the overridden method.</span></span> <span data-ttu-id="2df82-172">Podpis metody musi być taka sama jak przesłoniętej metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-172">The method signature must be the same as that of the overridden method.</span></span> <span data-ttu-id="2df82-173">Poniższy przykład przypomina poprzedni, z wyjątkiem tego, że zastępuje on <xref:System.Object.Equals(System.Object)> metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-173">The following example is like the previous one, except that it overrides the <xref:System.Object.Equals(System.Object)> method.</span></span> <span data-ttu-id="2df82-174">(Zastępuje ona również <xref:System.Object.GetHashCode> metody, ponieważ te dwie metody są przeznaczone do zapewnić spójne wyniki.)</span><span class="sxs-lookup"><span data-stu-id="2df82-174">(It also overrides the <xref:System.Object.GetHashCode> method, since the two methods are intended to provide consistent results.)</span></span>

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>
## <a name="passing-parameters"></a><span data-ttu-id="2df82-175">Przekazywanie parametrów</span><span class="sxs-lookup"><span data-stu-id="2df82-175">Passing parameters</span></span> ##

<span data-ttu-id="2df82-176">Typy w języku C# są albo *typów wartości* lub *typy referencyjne*.</span><span class="sxs-lookup"><span data-stu-id="2df82-176">Types in C# are either *value types* or *reference types*.</span></span> <span data-ttu-id="2df82-177">Listę typów wartości wbudowanych, zobacz [i zmiennymi](./tour-of-csharp/types-and-variables.md).</span><span class="sxs-lookup"><span data-stu-id="2df82-177">For a list of built-in value types, see [Types and variables](./tour-of-csharp/types-and-variables.md).</span></span> <span data-ttu-id="2df82-178">Domyślnie oraz typy wartości i typy referencyjne są przekazywane do metody przez wartość.</span><span class="sxs-lookup"><span data-stu-id="2df82-178">By default, both value types and reference types are passed to a method by value.</span></span>

<a name="byval"></a>
### <a name="passing-parameters-by-value"></a><span data-ttu-id="2df82-179">Przekazywanie parametrów przez wartość</span><span class="sxs-lookup"><span data-stu-id="2df82-179">Passing parameters by value</span></span> ###

<span data-ttu-id="2df82-180">Gdy typ wartości jest przekazywany do metody przez wartość, kopię obiektu, a nie samego obiektu jest przekazywany do metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-180">When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</span></span> <span data-ttu-id="2df82-181">W związku z tym zmiany wprowadzone w obiekcie w nazwie metody nie mają wpływu na oryginalny obiekt zwrócona sterowania do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="2df82-181">Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="2df82-182">Poniższy przykład przekazuje do metody typu wartości przez wartość i wywołaną metodę próbuje zmienić wartość typu wartości.</span><span class="sxs-lookup"><span data-stu-id="2df82-182">The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</span></span> <span data-ttu-id="2df82-183">Definiuje zmienną typu `int`, który jest typem wartości, inicjuje jego wartość 20 i przekazuje je do metody o nazwie `ModifyValue` która zmieni wartość zmiennej do 30.</span><span class="sxs-lookup"><span data-stu-id="2df82-183">It defines a variable of type `int`, which is a value type, initializes its value to 20, and passes it to a method named `ModifyValue` that changes the variable's value to 30.</span></span> <span data-ttu-id="2df82-184">Gdy metoda zwróci wartość, jednak wartość zmiennej pozostanie bez zmian.</span><span class="sxs-lookup"><span data-stu-id="2df82-184">When the method returns, however, the variable's value remains unchanged.</span></span>

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

<span data-ttu-id="2df82-185">Jeśli obiekt typu referencyjnego jest przekazywany do metody według wartości, odwołania do obiektu jest przekazywany przez wartość.</span><span class="sxs-lookup"><span data-stu-id="2df82-185">When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</span></span> <span data-ttu-id="2df82-186">Oznacza to, że metoda odbiera nie sam obiekt, ale argument, który wskazuje lokalizację, do obiektu.</span><span class="sxs-lookup"><span data-stu-id="2df82-186">That is, the method receives not the object itself, but an argument that indicates the location of the object.</span></span> <span data-ttu-id="2df82-187">Jeśli zmienisz element członkowski obiektu przy użyciu tego odwołania, zmiana ta jest uwzględniana w obiekcie zwrócona do wywoływania metody kontroli.</span><span class="sxs-lookup"><span data-stu-id="2df82-187">If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</span></span> <span data-ttu-id="2df82-188">Jednak zastępuje obiekt przekazany do metody nie ma wpływu na oryginalny obiekt zwrócona sterowania do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="2df82-188">However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="2df82-189">W poniższym przykładzie zdefiniowano klasę (który jest typem referencyjnym) o nazwie `SampleRefType`.</span><span class="sxs-lookup"><span data-stu-id="2df82-189">The following example defines a class (which is a reference type) named `SampleRefType`.</span></span> <span data-ttu-id="2df82-190">Metoda tworzy `SampleRefType` obiektów, przypisuje 44 do jego `value` pól i przekazuje obiekt do `ModifyObject` metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-190">It instantiates a `SampleRefType` object, assigns 44 to its `value` field, and passes the object to the `ModifyObject` method.</span></span> <span data-ttu-id="2df82-191">W tym przykładzie jest zasadniczo sam efekt co w poprzednim przykładzie — przekazuje argumentu przez wartość do metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-191">This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</span></span> <span data-ttu-id="2df82-192">Ale ponieważ jest używany typ referencyjny, wynik jest inny.</span><span class="sxs-lookup"><span data-stu-id="2df82-192">But because a reference type is used, the result is different.</span></span> <span data-ttu-id="2df82-193">Ze zmianami, które jest przeprowadzane w `ModifyObject` do `obj.value` pola również zmiany `value` pole argumentu, `rt`w `Main` metodę 33, jako dane wyjściowe w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="2df82-193">The modification that is made in `ModifyObject` to the `obj.value` field also changes the `value` field of the argument, `rt`, in the `Main` method to 33, as the output from the example shows.</span></span>

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>
### <a name="passing-parameters-by-reference"></a><span data-ttu-id="2df82-194">Przekazywanie parametrów przez odwołanie</span><span class="sxs-lookup"><span data-stu-id="2df82-194">Passing parameters by reference</span></span> ###

<span data-ttu-id="2df82-195">Należy przekazać parametr przez odwołanie, jeśli chcesz zmienić wartości argumentu w metodzie i chcesz refect zmiana, gdy formant powróci do wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-195">You pass a parameter by reference when you want to change the value of an argument in a method and want to refect that change when control returns to the calling method.</span></span> <span data-ttu-id="2df82-196">Aby przekazać parametr przez odwołanie, należy użyć [ `ref` ](language-reference/keywords/ref.md) lub [ `out` ](language-reference/keywords/out-parameter-modifier.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="2df82-196">To pass a parameter by reference, you use the [`ref`](language-reference/keywords/ref.md) or [`out`](language-reference/keywords/out-parameter-modifier.md) keyword.</span></span> <span data-ttu-id="2df82-197">Można również przekazać wartość przez odwołanie, aby unikać kopiowania, ale nadal uniemożliwiają zmiany przy użyciu [ `in` ](language-reference/keywords/in-parameter-modifier.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="2df82-197">You can also pass a value by reference to avoid copying but still prevent modifications using the [`in`](language-reference/keywords/in-parameter-modifier.md) keyword.</span></span>

<span data-ttu-id="2df82-198">Poniższy przykład jest taki sam jak poprzedni, z wyjątkiem wartość jest przekazywana przez odwołanie do `ModifyValue` metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-198">The following example is identical to the previous one, except the value is passed by reference to the `ModifyValue` method.</span></span> <span data-ttu-id="2df82-199">Wartość parametru jest modyfikacji w `ModifyValue` metody, zmianę wartości jest odzwierciedlone zwrócona sterowania do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="2df82-199">When the value of the parameter is modified in the `ModifyValue` method, the change in value is reflected when control returns to the caller.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

<span data-ttu-id="2df82-200">Typowe wzorzec, który korzysta z parametrami ref obejmuje zamianę wartości zmiennych.</span><span class="sxs-lookup"><span data-stu-id="2df82-200">A common pattern that uses by ref parameters involves swapping the values of variables.</span></span> <span data-ttu-id="2df82-201">Dwie zmienne są przekazywane do metody przez odwołanie, a metoda zamienia ich zawartość.</span><span class="sxs-lookup"><span data-stu-id="2df82-201">You pass two variables to a method by reference, and the method swaps their contents.</span></span> <span data-ttu-id="2df82-202">Poniższy przykład zamienia wartości będące liczbami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="2df82-202">The following example swaps integer values.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

<span data-ttu-id="2df82-203">Przekazywanie parametrów typu Odwołanie umożliwia zmianę wartości odwołania do samej siebie, a nie wartość jego poszczególne elementy lub pól.</span><span class="sxs-lookup"><span data-stu-id="2df82-203">Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</span></span>

<a name="paramarray"></a>
### <a name="parameter-arrays"></a><span data-ttu-id="2df82-204">Tablice parametrów</span><span class="sxs-lookup"><span data-stu-id="2df82-204">Parameter arrays</span></span> ###

<span data-ttu-id="2df82-205">Czasami wymaganie określić dokładną liczbą argumentów do metody są restrykcyjne.</span><span class="sxs-lookup"><span data-stu-id="2df82-205">Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</span></span> <span data-ttu-id="2df82-206">Za pomocą `params` — słowo kluczowe, aby wskazać, że parametr jest tablicą parametrów, musisz zezwolić na metodę do wywołania z różną liczbą argumentów.</span><span class="sxs-lookup"><span data-stu-id="2df82-206">By using the `params` keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</span></span> <span data-ttu-id="2df82-207">Parametr oznaczane `params` — słowo kluczowe musi być typem tablicy i musi być ostatnim parametrem na liście parametrów metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-207">The parameter tagged with the `params` keyword must must be an array type, and it must be the last parameter in the method's parameter list.</span></span>

<span data-ttu-id="2df82-208">Obiekt wywołujący następnie można wywołać metody na trzy sposoby:</span><span class="sxs-lookup"><span data-stu-id="2df82-208">A caller can then invoke the method in either of three ways:</span></span>

- <span data-ttu-id="2df82-209">Przez przekazanie tablicy odpowiedniego typu, który zawiera odpowiednią liczbę elementów.</span><span class="sxs-lookup"><span data-stu-id="2df82-209">By passing an array of the appropriate type that contains the desired number of elements.</span></span>
- <span data-ttu-id="2df82-210">Przez przekazanie rozdzielana przecinkami lista oddzielne argumenty odpowiedniego typu metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-210">By passing a comma-separated list of individual arguments of the appropriate type to the method.</span></span>
- <span data-ttu-id="2df82-211">Zapewniając nie argument tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="2df82-211">By not providing an argument to the parameter array.</span></span>

<span data-ttu-id="2df82-212">W poniższym przykładzie zdefiniowano metodę o nazwie `DoStringOperation` wykonująca operację ciągu określonego przez jej pierwszy parametr `StringOperation` element członkowski wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="2df82-212">The following example defines a method named `DoStringOperation` that performs the string operation specified by its first parameter, a `StringOperation` enumeration member.</span></span> <span data-ttu-id="2df82-213">Ciągi, na których jest do wykonania tej operacji są zdefiniowane w tablicy parametrów.</span><span class="sxs-lookup"><span data-stu-id="2df82-213">The strings upon which it is to perform the operation are defined by a parameter array.</span></span> <span data-ttu-id="2df82-214">`Main` Metody przedstawiono wszystkie trzy sposoby wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-214">The `Main` method illustrates all three ways of invoking the method.</span></span> <span data-ttu-id="2df82-215">Należy pamiętać, że metoda oznakowane `params` — słowo kluczowe muszą być przygotowane do obsługi sytuacji, w których nie podano argumentu dla tablicy parametrów, aby jego wartość wynosi `null`.</span><span class="sxs-lookup"><span data-stu-id="2df82-215">Note that the method tagged with the `params` keyword must be prepared to handle the case in which no argument is supplied for the parameter array, so that its value is `null`.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref108.cs#108)]

<a name="optional"></a>
## <a name="optional-parameters-and-arguments"></a><span data-ttu-id="2df82-216">Opcjonalne parametry i argumenty</span><span class="sxs-lookup"><span data-stu-id="2df82-216">Optional parameters and arguments</span></span> ##

<span data-ttu-id="2df82-217">Definicja metody można określić, że parametry są wymagane lub ich są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="2df82-217">A method definition can specify that its parameters are required or that they are optional.</span></span> <span data-ttu-id="2df82-218">Domyślnie nie są wymagane parametry.</span><span class="sxs-lookup"><span data-stu-id="2df82-218">By default, parameters are required.</span></span> <span data-ttu-id="2df82-219">Parametry opcjonalne są określone przez dołączenie wartości domyślnej parametru w definicji metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-219">Optional parameters are specified by including the parameter's default value in the method definition.</span></span> <span data-ttu-id="2df82-220">Po wywołaniu metody, jeśli nie podano argumentu dla parametru opcjonalnego, zamiast niego jest używana wartość domyślna.</span><span class="sxs-lookup"><span data-stu-id="2df82-220">When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</span></span>

<span data-ttu-id="2df82-221">Wartość domyślna parametru musi być przypisany przez jedną z następujących rodzajów wyrażeń:</span><span class="sxs-lookup"><span data-stu-id="2df82-221">The parameter's default value must be assigned by one of the following kinds of expressions:</span></span>

- <span data-ttu-id="2df82-222">Stała, takich jak literał lub numer.</span><span class="sxs-lookup"><span data-stu-id="2df82-222">A constant, such as a literal string or number.</span></span>
- <span data-ttu-id="2df82-223">Wyrażenie w postaci `new ValType`, gdzie `ValType` jest typem wartości.</span><span class="sxs-lookup"><span data-stu-id="2df82-223">An expression of the form `new ValType`, where `ValType` is a value type.</span></span> <span data-ttu-id="2df82-224">Należy pamiętać, że wywołuje to typ wartości niejawne domyślnego konstruktora, który nie jest faktycznego elementu członkowskiego typu.</span><span class="sxs-lookup"><span data-stu-id="2df82-224">Note that this invokes the value type's implicit default constructor, which is not an actual member of the type.</span></span>
- <span data-ttu-id="2df82-225">Wyrażenie w postaci `default(ValType)`, gdzie `ValType` jest typem wartości.</span><span class="sxs-lookup"><span data-stu-id="2df82-225">An expression of the form `default(ValType)`, where `ValType` is a value type.</span></span>

<span data-ttu-id="2df82-226">Jeśli metoda obejmuje zarówno wymaganych i opcjonalnych parametrów, opcjonalne parametry są definiowane na końcu listy parametrów po wszystkich wymaganych parametrów.</span><span class="sxs-lookup"><span data-stu-id="2df82-226">If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</span></span>

<span data-ttu-id="2df82-227">W poniższym przykładzie zdefiniowano metody `ExampleMethod`, która ma wymagana i dwa parametry opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="2df82-227">The following example defines a method, `ExampleMethod`, that has one required and two optional parameters.</span></span>

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

<span data-ttu-id="2df82-228">Jeśli w wywołaniu metody z wielu argumentów opcjonalnych argumentów pozycyjnych, wywołujący podać argument wszystkie parametry opcjonalne od pierwszego do ostatnią, dla którego podano argumentu.</span><span class="sxs-lookup"><span data-stu-id="2df82-228">If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</span></span> <span data-ttu-id="2df82-229">W przypadku programu `ExampleMethod` metody, na przykład, jeśli element wywołujący dostarcza argument `description` parametru, jego należy również podać po jednej dla `optionalInt` parametru.</span><span class="sxs-lookup"><span data-stu-id="2df82-229">In the case of the  `ExampleMethod` method, for example, if the caller supplies an argument for the `description` parameter, it must also supply one for the `optionalInt` parameter.</span></span> <span data-ttu-id="2df82-230">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` to wywołanie prawidłowej metody; `opt.ExampleMethod(2, , "Addition of 2 and 0);` generuje "Brak argumentu" błąd kompilatora.</span><span class="sxs-lookup"><span data-stu-id="2df82-230">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` is a valid method call; `opt.ExampleMethod(2, , "Addition of 2 and 0);` generates an "Argument missing" compiler error.</span></span>

<span data-ttu-id="2df82-231">Jeśli metoda jest wywoływana przy użyciu argumentów nazwanych lub kombinacja argumentów pozycyjnych i nazwane, wywołujący można pominąć argumenty, które należy wykonać ostatni argument pozycyjny w wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-231">If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</span></span>

<span data-ttu-id="2df82-232">Następujące przykładowe wywołania `ExampleMethod` metody trzy razy.</span><span class="sxs-lookup"><span data-stu-id="2df82-232">The following example calls the `ExampleMethod` method three times.</span></span>  <span data-ttu-id="2df82-233">Wywołania metody dwa pierwsze użycie argumentów pozycyjnych.</span><span class="sxs-lookup"><span data-stu-id="2df82-233">The first two method calls use positional arguments.</span></span> <span data-ttu-id="2df82-234">Pierwszy pomija oba argumenty opcjonalne, podczas gdy druga pomija ostatni argument.</span><span class="sxs-lookup"><span data-stu-id="2df82-234">The first omits both optional arguments, while the second omits the last argument.</span></span> <span data-ttu-id="2df82-235">Trzeci wywołanie metody dostarcza argument pozycyjny dla wymaganego parametru, ale używa nazwany argument podania wartości do `description` parametru pomijając `optionalInt` argumentu.</span><span class="sxs-lookup"><span data-stu-id="2df82-235">The third method call supplies a positional argument for the required parameter, but uses a named argument to supply a value to the `description` parameter while omitting the `optionalInt` argument.</span></span>

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

<span data-ttu-id="2df82-236">Korzystanie z parametrów ma wpływ na *przeciążenia*, czy w sposób, w którym kompilator języka C# Określa, które przeładowanie określonego powinna być wywoływana przez wywołanie metody, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="2df82-236">The use of optional parameters affects *overload resolution*, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</span></span>

- <span data-ttu-id="2df82-237">Metoda, indeksator lub Konstruktor jest kandydatem do wykonania, jeśli każdego z jego parametrów jest opcjonalny, albo odpowiada według nazwy lub stanie pojedynczy argument w instrukcji wywołującego, oraz że argument można przekonwertować na typ parametru.</span><span class="sxs-lookup"><span data-stu-id="2df82-237">A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</span></span>
- <span data-ttu-id="2df82-238">Jeśli zostanie znaleziony więcej niż jednego kandydata, zasady rozpoznawania przeciążenia preferowanych konwersje są stosowane do argumentów, które zostały jawnie określone.</span><span class="sxs-lookup"><span data-stu-id="2df82-238">If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</span></span> <span data-ttu-id="2df82-239">Pominięcia Argumenty opcjonalne parametry są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="2df82-239">Omitted arguments for optional parameters are ignored.</span></span>
- <span data-ttu-id="2df82-240">Jeśli dwa kandydatów zostaną ocenione jako jednakowo dobry, preferencji prowadzi do kandydujących, który nie ma następujące parametry opcjonalne dla których argumenty zostały pominięte w wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="2df82-240">If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</span></span> <span data-ttu-id="2df82-241">Jest to konsekwencją Ogólne preferencji w wiązaniem dla elementów, które mają mniej parametrów.</span><span class="sxs-lookup"><span data-stu-id="2df82-241">This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</span></span>

 <a name="return"></a>
 ## <a name="return-values"></a><span data-ttu-id="2df82-242">Zwracane wartości</span><span class="sxs-lookup"><span data-stu-id="2df82-242">Return values</span></span> ##

<span data-ttu-id="2df82-243">Metody może zwracać wartości do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="2df82-243">Methods can return a value to the caller.</span></span> <span data-ttu-id="2df82-244">Jeśli nie jest zwracany typ (typ wyświetlanych przed nazwę metody) `void`, metoda może zwracać wartości przy użyciu `return` — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="2df82-244">If the return type (the type listed before the method name) is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="2df82-245">Instrukcja zawierająca `return` — słowo kluczowe następuje zmienna, stała lub wyrażenie, które jest zgodny z typem zwracanym zwraca tę wartość do wywołującego metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-245">A statement with the `return` keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</span></span> <span data-ttu-id="2df82-246">Metod innych niż void zwracany typ muszą korzystać z `return` — słowo kluczowe, aby zwrócić wartość.</span><span class="sxs-lookup"><span data-stu-id="2df82-246">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="2df82-247">`return` — Słowo kluczowe również zatrzymuje wykonywanie metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-247">The `return` keyword also stops the execution of the method.</span></span>

<span data-ttu-id="2df82-248">Jeśli typem zwracanym jest `void`, `return` instrukcji bez wartości, warto nadal zatrzymuje wykonywanie metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-248">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="2df82-249">Bez `return` — słowo kluczowe, metoda spowoduje zatrzymanie wykonywania, gdy zostanie osiągnięty koniec bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="2df82-249">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span>

<span data-ttu-id="2df82-250">Na przykład użyć te dwie metody `return` — słowo kluczowe do zwrócenia liczb całkowitych:</span><span class="sxs-lookup"><span data-stu-id="2df82-250">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

<span data-ttu-id="2df82-251">Aby użyć wartość zwracana z metody, metody wywołującej użyć wywołania metody sam gdziekolwiek się, że wartość tego samego typu będą wystarczające.</span><span class="sxs-lookup"><span data-stu-id="2df82-251">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="2df82-252">Można także przypisać zwracana wartość do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="2df82-252">You can also assign the return value to a variable.</span></span> <span data-ttu-id="2df82-253">Na przykład następujący przykładowy kod dwóch realizację tego samego celu:</span><span class="sxs-lookup"><span data-stu-id="2df82-253">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

<span data-ttu-id="2df82-254">Przy użyciu zmiennej lokalnej, w tym przypadku `result`, aby przechowywać wartość jest opcjonalna.</span><span class="sxs-lookup"><span data-stu-id="2df82-254">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="2df82-255">Może pomóc zwiększyć czytelność kodu, lub może być konieczne, jeśli zachodzi potrzeba przechowywania oryginalnej wartości argumentu dla całego zakresu metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-255">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="2df82-256">Czasami ma metodę do zwrócenia więcej niż jedną wartość.</span><span class="sxs-lookup"><span data-stu-id="2df82-256">Sometimes, you want your method to return more than a single value.</span></span> <span data-ttu-id="2df82-257">Począwszy od wersji 7.0 C#, można to zrobić łatwo za pomocą *typu krotki* i *literały spójnej kolekcji*.</span><span class="sxs-lookup"><span data-stu-id="2df82-257">Starting with C# 7.0, you can do this easily by using *tuple types* and *tuple literals*.</span></span> <span data-ttu-id="2df82-258">Typ krotki definiuje typy danych elementów spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="2df82-258">The tuple type defines the data types of the tuple's elements.</span></span> <span data-ttu-id="2df82-259">Literały krotki zawierają rzeczywiste wartości zwracane spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="2df82-259">Tuple literals provide the actual values of the returned tuple.</span></span> <span data-ttu-id="2df82-260">W poniższym przykładzie `(string, string, string, int)` definiuje typ krotki, która jest zwracana w wyniku `GetPersonalInfo` metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-260">In the following example, `(string, string, string, int)` defines the tuple type that is returned by the `GetPersonalInfo` method.</span></span> <span data-ttu-id="2df82-261">Wyrażenie `(per.FirstName, per.MiddleName, per.LastName, per.Age)` jest literałem; metoda zwraca nazwę pierwszego, drugie imię i nazwisko, wraz z wiek, z spójnej kolekcji `PersonInfo` obiektu.</span><span class="sxs-lookup"><span data-stu-id="2df82-261">The expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` is the tuple literal; the method returns the first, middle, and last name, along with the age, of a `PersonInfo` object.</span></span>

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    if (per != null)
       return (per.FirstName, per.MiddleName, per.LastName, per.Age);
    else
       return null;
}
```

<span data-ttu-id="2df82-262">Obiekt wywołujący będą mogły używać zwrócony krotki z kodu podobne do poniższych:</span><span class="sxs-lookup"><span data-stu-id="2df82-262">The caller can then consume the returned tuple with code like the following:</span></span>

```csharp
var person = GetPersonalInfo("111111111")
if (person != null)
   Console.WriteLine("{person.Item1} {person.Item3}: age = {person.Item4}");
```

<span data-ttu-id="2df82-263">Można również przypisać nazwy do elementów spójnej kolekcji w definicji typu krotki.</span><span class="sxs-lookup"><span data-stu-id="2df82-263">Names can also be assigned to the tuple elements in the tuple type definition.</span></span> <span data-ttu-id="2df82-264">W poniższym przykładzie przedstawiono alternatywnej wersji `GetPersonalInfo` metody, która używa o nazwie elementy:</span><span class="sxs-lookup"><span data-stu-id="2df82-264">The following example shows an alternate version of the `GetPersonalInfo` method that uses named elements:</span></span>

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    if (per != null)
       return (per.FirstName, per.MiddleName, per.LastName, per.Age);
    else
       return null;
}
```

<span data-ttu-id="2df82-265">Poprzednie wywołanie `GetPersonInfo` metoda może być modyfikowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="2df82-265">The previous call to the `GetPersonInfo` method can then be modified as follows:</span></span>

```csharp
var person = GetPersonalInfo("111111111");
if (person != null)
   Console.WriteLine("{person.FName} {person.LName}: age = {person.Age}");
```

<span data-ttu-id="2df82-266">Jeśli metoda jest przekazywana tablicy jako argument i modyfikuje wartość poszczególne elementy, nie jest konieczne metoda ma zwracać tablicy, chociaż można wybrać w tym celu dobrej stylu lub funkcjonalności przepływu wartości.</span><span class="sxs-lookup"><span data-stu-id="2df82-266">If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</span></span>  <span data-ttu-id="2df82-267">To dlatego C# przekazuje wszystkie typy referencyjne przez wartość i wartość odwołania do tablicy jest wskaźnik do tablicy.</span><span class="sxs-lookup"><span data-stu-id="2df82-267">This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="2df82-268">W poniższym przykładzie zmienia zawartość `values` tablicy, które zostały wprowadzone w `DoubleValues` metody są według przez kodu, który zawiera odwołanie do tablicy.</span><span class="sxs-lookup"><span data-stu-id="2df82-268">In the following example, changes to the contents of the `values` array that are made in the `DoubleValues` method are observable by any code that has a reference to the array.</span></span>

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

 <a name="exten"></a>
 ## <a name="extension-methods"></a><span data-ttu-id="2df82-269">Metody rozszerzenia</span><span class="sxs-lookup"><span data-stu-id="2df82-269">Extension methods</span></span> ##

<span data-ttu-id="2df82-270">Zazwyczaj istnieją dwa sposoby dodawania metody do istniejącego typu:</span><span class="sxs-lookup"><span data-stu-id="2df82-270">Ordinarily, there are two ways to add a method to an existing type:</span></span>

- <span data-ttu-id="2df82-271">Modyfikowanie kodu źródłowego dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="2df82-271">Modify the source code for that type.</span></span> <span data-ttu-id="2df82-272">Nie możesz tego zrobić, jeśli nie ma typu kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="2df82-272">You cannot do this, of course, if you do not own the type's source code.</span></span> <span data-ttu-id="2df82-273">I staje się on na istotne zmiany po dodaniu pola danych prywatne, do obsługi metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-273">And this becomes a breaking change if you also add any private data fields to support the method.</span></span>
- <span data-ttu-id="2df82-274">Zdefiniuj nowej metody w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="2df82-274">Define the new method in a derived class.</span></span> <span data-ttu-id="2df82-275">Metody nie można dodać w ten sposób używanie dziedziczenia dla innych typów, takich jak struktury i wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="2df82-275">A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</span></span> <span data-ttu-id="2df82-276">Nie można być również wykorzystywane do "Dodaj" metodę do klasy zapieczętowanej.</span><span class="sxs-lookup"><span data-stu-id="2df82-276">Nor can it be used to "add" a method to a sealed class.</span></span>

<span data-ttu-id="2df82-277">Metody rozszerzenia umożliwiają "Dodaj" metody do istniejącego typu bez modyfikowania samego typu i wdrożeniu nowej metody w typie dziedziczonym.</span><span class="sxs-lookup"><span data-stu-id="2df82-277">Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</span></span> <span data-ttu-id="2df82-278">Metody rozszerzenia również nie musi znajdować się w tym samym zestawie co typ rozszerzany przez niego.</span><span class="sxs-lookup"><span data-stu-id="2df82-278">The extension method also does not have to reside in the same assembly as the type it extends.</span></span> <span data-ttu-id="2df82-279">Wywoływanie metody rozszerzenia, tak jakby był on członkiem zdefiniowanego typu.</span><span class="sxs-lookup"><span data-stu-id="2df82-279">You call an extension method as if it were a defined member of a type.</span></span>

<span data-ttu-id="2df82-280">Aby uzyskać więcej informacji, zobacz [metody rozszerzenia](programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="2df82-280">For more information, see [Extension Methods](programming-guide/classes-and-structs/extension-methods.md).</span></span>

<a name="async"></a>
## <a name="async-methods"></a><span data-ttu-id="2df82-281">Metody asynchroniczne</span><span class="sxs-lookup"><span data-stu-id="2df82-281">Async Methods</span></span> ##

<span data-ttu-id="2df82-282">Korzystając z funkcji asynchronicznych, można wywoływać metod asynchronicznych bez za pomocą jawnego wywołania zwrotne i ręcznie dzielenia kodu wielu metod lub wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="2df82-282">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="2df82-283">Po zaznaczeniu metodę o [async](language-reference/keywords/async.md) modyfikator, można użyć [await](language-reference/keywords/await.md) operatora w metodzie.</span><span class="sxs-lookup"><span data-stu-id="2df82-283">If you mark a method with the [async](language-reference/keywords/async.md) modifier, you can use the [await](language-reference/keywords/await.md) operator in the method.</span></span> <span data-ttu-id="2df82-284">Gdy kontrolować osiągnie `await` wyrażenia w metodzie asynchronicznej formantu zwraca do wywołującego, gdy oczekiwano zadanie nie zostało ukończone i postęp w metodzie z `await` — słowo kluczowe jest wstrzymana, aż do zakończenia oczekiwano zadań.</span><span class="sxs-lookup"><span data-stu-id="2df82-284">When control reaches an `await` expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the `await` keyword is suspended until the awaited task completes.</span></span> <span data-ttu-id="2df82-285">Po zakończeniu zadania wykonywania można wznowić w metodzie.</span><span class="sxs-lookup"><span data-stu-id="2df82-285">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="2df82-286">Metoda asynchroniczna zwraca do obiektu wywołującego po napotkaniu pierwszego oczekiwano obiekt, który nie został jeszcze ukończony lub pobiera na końcu metody asynchronicznej cokolwiek nastąpi najpierw.</span><span class="sxs-lookup"><span data-stu-id="2df82-286">An async method returns to the caller when either it encounters the first awaited object that’s not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="2df82-287">Metoda asynchroniczna może mieć typ zwracany <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, lub `void`.</span><span class="sxs-lookup"><span data-stu-id="2df82-287">An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or `void`.</span></span> <span data-ttu-id="2df82-288">`void` Zwracany typ jest używany głównie w celu definiowania metod obsługi zdarzeń, gdy `void` zwracany typ jest wymagany.</span><span class="sxs-lookup"><span data-stu-id="2df82-288">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="2df82-289">Metoda asynchroniczna zwracająca `void` nie jest oczekiwane, a obiekt wywołujący metody zwracające typ void nie może przechwytywać wyjątki, które metoda zgłasza.</span><span class="sxs-lookup"><span data-stu-id="2df82-289">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="2df82-290">C# 7, po wydaniu, ułatwi to ograniczenie, aby umożliwić metody asynchronicznej [do zwrócenia dowolnego typu zadania przypominającej](https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md).</span><span class="sxs-lookup"><span data-stu-id="2df82-290">C# 7, when it is released, will ease this restriction to allow an async method [to return any task-like type](https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md).</span></span>

<span data-ttu-id="2df82-291">W poniższym przykładzie `DelayAsync` jest to metoda asynchroniczna, która zawiera instrukcję return, która zwraca liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="2df82-291">In the following example, `DelayAsync` is an async method that has a return statement that returns an integer.</span></span> <span data-ttu-id="2df82-292">Ponieważ jest to metoda asynchroniczna, jego deklaracji metody musi mieć typ zwracany `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="2df82-292">Because it is an async method, its method declaration must have a return type of `Task<int>`.</span></span> <span data-ttu-id="2df82-293">Ponieważ typ zwracany jest `Task<int>`, oceny `await` wyrażenie w `DoSomethingAsync` tworzy całkowitą w następujący sposób `int result = await delayTask` pokazuje instrukcji.</span><span class="sxs-lookup"><span data-stu-id="2df82-293">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer, as the following `int result = await delayTask` statement demonstrates.</span></span>

[!code-csharp[csSnippets.Methods#102](../../samples/snippets/csharp/concepts/methods/async1.cs#102)]

<span data-ttu-id="2df82-294">Metoda asynchroniczna nie można zadeklarować żadnego [w](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), lub [limit](language-reference/keywords/out-parameter-modifier.md) parametrów, ale można wywołać metody, które mają takie parametry.</span><span class="sxs-lookup"><span data-stu-id="2df82-294">An async method can't declare any [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), or [out](language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

 <span data-ttu-id="2df82-295">Aby uzyskać więcej informacji na temat metod asynchronicznych, zobacz [programowanie asynchroniczne z Async i Await](async.md), [przepływ sterowania w aplikacjach asynchronicznych](programming-guide/concepts/async/control-flow-in-async-programs.md), i [Async zwracać typów](programming-guide/concepts/async/async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="2df82-295">For more information about async methods, see [Asynchronous Programming with Async and Await](async.md), [Control Flow in Async Programs](programming-guide/concepts/async/control-flow-in-async-programs.md), and [Async Return Types](programming-guide/concepts/async/async-return-types.md).</span></span>

<a name="expr"></a>
## <a name="expression-bodied-members"></a><span data-ttu-id="2df82-296">Zabudowanych wyrażenia elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="2df82-296">Expression-bodied members</span></span> ##

<span data-ttu-id="2df82-297">Jest często mają definicje — metoda, która po prostu zwrot wynik wyrażenia, lub które mają jednej instrukcji jako treść metody.</span><span class="sxs-lookup"><span data-stu-id="2df82-297">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span>  <span data-ttu-id="2df82-298">Brak skrót do definiowania tych metod, za pomocą składni `=>`:</span><span class="sxs-lookup"><span data-stu-id="2df82-298">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="2df82-299">Jeśli metoda zwraca `void` lub jest to metoda asynchroniczna treści metody musi być wyrażeniem instrukcji (tak samo jak w przypadku wyrażeń lambda).</span><span class="sxs-lookup"><span data-stu-id="2df82-299">If the method returns `void` or is an async method, the body of the method must be a statement expression (same as with lambdas).</span></span>  <span data-ttu-id="2df82-300">Właściwości i indeksatorów, muszą być w trybie tylko do odczytu i nie należy używać `get` akcesor — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="2df82-300">For properties and indexers, they must be read-only, and you do not use the `get` accessor keyword.</span></span>

<a name="iterators"></a>
## <a name="iterators"></a><span data-ttu-id="2df82-301">Iteratory</span><span class="sxs-lookup"><span data-stu-id="2df82-301">Iterators</span></span> ##

<span data-ttu-id="2df82-302">Iteratora wykonuje niestandardowych iteracji w kolekcji, takie jak listy lub tablicy.</span><span class="sxs-lookup"><span data-stu-id="2df82-302">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="2df82-303">Używa iteratora [yield return](language-reference/keywords/yield.md) instrukcji, aby zwracany był każdy element jednym naraz.</span><span class="sxs-lookup"><span data-stu-id="2df82-303">An iterator uses the [yield return](language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="2df82-304">Gdy `yield return` osiągnięciu instrukcji bieżącej lokalizacji jest zapamiętanych tak, aby obiekt wywołujący może zażądać następnego elementu w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="2df82-304">When a `yield return` statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</span></span>

<span data-ttu-id="2df82-305">Może być zwracany typ iteratora <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, lub <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="2df82-305">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="2df82-306">Aby uzyskać więcej informacji, zobacz [Iteratory](programming-guide/concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="2df82-306">For more information, see [Iterators](programming-guide/concepts/iterators.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="2df82-307">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="2df82-307">See also</span></span> ##

<span data-ttu-id="2df82-308">[Modyfikatory dostępu](language-reference/keywords/access-modifiers.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-308">[Access Modifiers](language-reference/keywords/access-modifiers.md) </span></span>  
<span data-ttu-id="2df82-309">[Klasy statyczne i statyczni członkowie klas](programming-guide/classes-and-structs/static-classes-and-static-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-309">[Static Classes and Static Class Members](programming-guide/classes-and-structs/static-classes-and-static-class-members.md) </span></span>  
<span data-ttu-id="2df82-310">[Dziedziczenie](programming-guide/classes-and-structs/inheritance.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-310">[Inheritance](programming-guide/classes-and-structs/inheritance.md) </span></span>  
<span data-ttu-id="2df82-311">[Klasy abstrakcyjne i zapieczętowane oraz członkowie klas](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-311">[Abstract and Sealed Classes and Class Members](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span></span>  
<span data-ttu-id="2df82-312">[Parametry](language-reference/keywords/params.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-312">[params](language-reference/keywords/params.md) </span></span>  
<span data-ttu-id="2df82-313">[out](language-reference/keywords/out-parameter-modifier.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-313">[out](language-reference/keywords/out-parameter-modifier.md) </span></span>  
<span data-ttu-id="2df82-314">[REF](language-reference/keywords/ref.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-314">[ref](language-reference/keywords/ref.md) </span></span>  
<span data-ttu-id="2df82-315">[in](language-reference/keywords/in-parameter-modifier.md) </span><span class="sxs-lookup"><span data-stu-id="2df82-315">[in](language-reference/keywords/in-parameter-modifier.md) </span></span>  
[<span data-ttu-id="2df82-316">Przekazywanie parametrów</span><span class="sxs-lookup"><span data-stu-id="2df82-316">Passing Parameters</span></span>](programming-guide/classes-and-structs/passing-parameters.md)
