---
title: Semantykę odwołania z typami wartości
description: Zrozumieć funkcje językowe, co minimalizuje bezpiecznie kopiowania struktury
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 778897dc92f8a94178ebbbed7704c0dfe2397729
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/28/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="7df53-103">Semantykę odwołania z typami wartości</span><span class="sxs-lookup"><span data-stu-id="7df53-103">Reference semantics with value types</span></span>

<span data-ttu-id="7df53-104">Zaletą używania typów wartości jest, aby uniknąć często Alokacje sterty.</span><span class="sxs-lookup"><span data-stu-id="7df53-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="7df53-105">Wadą jest to, że są one kopiowane wartości.</span><span class="sxs-lookup"><span data-stu-id="7df53-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="7df53-106">Ta zależnościami utrudnia zoptymalizować algorytmy, które pracują w dużych ilości danych.</span><span class="sxs-lookup"><span data-stu-id="7df53-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="7df53-107">Nowe funkcje języka C# 7.2 zapewniają mechanizmy, które Włącz semantykę przekazywany przez odwołanie z typami wartości.</span><span class="sxs-lookup"><span data-stu-id="7df53-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="7df53-108">Rozsądny sposób używać tych funkcji, aby zminimalizować zarówno alokacji i operacje kopiowania.</span><span class="sxs-lookup"><span data-stu-id="7df53-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="7df53-109">Ten artykuł opisuje te nowe funkcje.</span><span class="sxs-lookup"><span data-stu-id="7df53-109">This article explores those new features.</span></span>

<span data-ttu-id="7df53-110">Większość przykładowy kod w tym artykule przedstawiono funkcje dodane w języku C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="7df53-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="7df53-111">Aby można było używać tych funkcji, należy skonfigurować projektu do języka C# 7,2 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="7df53-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="7df53-112">Visual Studio można użyć, aby go wybrać.</span><span class="sxs-lookup"><span data-stu-id="7df53-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="7df53-113">Dla każdego projektu, zaznacz **projektu** z menu, następnie **właściwości**.</span><span class="sxs-lookup"><span data-stu-id="7df53-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="7df53-114">Wybierz **kompilacji** i kliknij polecenie **zaawansowane**.</span><span class="sxs-lookup"><span data-stu-id="7df53-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="7df53-115">Z tego miejsca skonfiguruj wersji językowej.</span><span class="sxs-lookup"><span data-stu-id="7df53-115">From there, configure the language version.</span></span> <span data-ttu-id="7df53-116">Wybierz opcję "7.2" lub "najnowszej".</span><span class="sxs-lookup"><span data-stu-id="7df53-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="7df53-117">W razie potrzeby można edytować *csproj* plik i dodać następującego węzła:</span><span class="sxs-lookup"><span data-stu-id="7df53-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="7df53-118">Można użyć "7,2" lub "najnowszej" dla wartości.</span><span class="sxs-lookup"><span data-stu-id="7df53-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="7df53-119">Przekazywanie argumentów poprzez odwołanie tylko do odczytu</span><span class="sxs-lookup"><span data-stu-id="7df53-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="7df53-120">C# 7.2 dodaje `in` — słowo kluczowe, aby mogła uzupełniać istniejące `ref` i `out` słowa kluczowe, aby przekazywać argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7df53-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="7df53-121">`in` — Słowo kluczowe określa przekazywanie argumentów poprzez odwołanie, ale wywołaną metodę nie modyfikuje wartość.</span><span class="sxs-lookup"><span data-stu-id="7df53-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="7df53-122">To dodawanie zapewnia pełne słownictwa Express z celem projektu.</span><span class="sxs-lookup"><span data-stu-id="7df53-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="7df53-123">Typy wartości są kopiowane, gdy przekazana do metody o nazwie, jeśli nie określisz żadnego z następujących modyfikatorów w podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="7df53-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="7df53-124">Każdy z tych Modyfikatory Określa, że typ wartości jest przekazywana przez odwołanie, unikając kopiowania.</span><span class="sxs-lookup"><span data-stu-id="7df53-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="7df53-125">Każdy modyfikator wyraża innego zamiaru:</span><span class="sxs-lookup"><span data-stu-id="7df53-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="7df53-126">`out`: Ta metoda określa wartość argumentu używany jako parametr.</span><span class="sxs-lookup"><span data-stu-id="7df53-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="7df53-127">`ref`: Ta metoda może ustawić wartość argumentu używany jako parametr.</span><span class="sxs-lookup"><span data-stu-id="7df53-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="7df53-128">`in`: Ta metoda nie modyfikuje wartość argumentu używany jako parametr.</span><span class="sxs-lookup"><span data-stu-id="7df53-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="7df53-129">Dodaj `in` modyfikator do przekazywania argumentu przez odwołanie ani deklarować zamiaru projektowania przekazywać argumentów przez odwołanie, aby uniknąć niepotrzebnych kopiowania.</span><span class="sxs-lookup"><span data-stu-id="7df53-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="7df53-130">Nie chcesz zmodyfikować obiekt używany jako tego argumentu.</span><span class="sxs-lookup"><span data-stu-id="7df53-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="7df53-131">Poniższy kod przedstawia przykład metodę, która oblicza odległość między dwoma punktami w przestrzeni 3D.</span><span class="sxs-lookup"><span data-stu-id="7df53-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="7df53-132">Argumenty są dwie struktury, że każdy zawiera trzy symulacyjnych.</span><span class="sxs-lookup"><span data-stu-id="7df53-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="7df53-133">Wartość o podwójnej precyzji jest 8 bajtów, dzięki czemu każdy argument jest 24 bajty.</span><span class="sxs-lookup"><span data-stu-id="7df53-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="7df53-134">Określając `in` modyfikator, należy przekazać 4-bajtowych lub 8-bajtowych odwołanie do tych argumentów, w zależności od architektury komputera.</span><span class="sxs-lookup"><span data-stu-id="7df53-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="7df53-135">Różnica w rozmiarze jest mały, ale jego można szybko dodać po aplikacji wywołuje tę metodę w pętli ścisłej przy użyciu wielu różnych wartości.</span><span class="sxs-lookup"><span data-stu-id="7df53-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="7df53-136">`in` Uzupełnia modyfikator `out` i `ref` także inne sposoby.</span><span class="sxs-lookup"><span data-stu-id="7df53-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="7df53-137">Nie można utworzyć przeciążenia metody, które różnią się jedynie w związku z występowaniem `in`, `out`, lub `ref`.</span><span class="sxs-lookup"><span data-stu-id="7df53-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="7df53-138">Te nowe reguły rozszerzania zawsze ma zdefiniowany dla tego samego zachowania `out` i `ref` parametrów.</span><span class="sxs-lookup"><span data-stu-id="7df53-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="7df53-139">`in` Modyfikator mogą być stosowane do dowolnego członka, który przyjmuje parametry: metody, delegatów, wyrażenia lambda, funkcje lokalne, indeksatorów, operatorów.</span><span class="sxs-lookup"><span data-stu-id="7df53-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="7df53-140">W odróżnieniu od `ref` i `out` argumenty, można użyć wartości literałów ani stałe dla argumentu `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="7df53-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="7df53-141">Ponadto, w przeciwieństwie do `ref` lub `out` parametr, nie trzeba zastosować `in` modyfikator w miejsce wywołania.</span><span class="sxs-lookup"><span data-stu-id="7df53-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="7df53-142">Poniższy kod przedstawia dwa przykłady wywołania metody `CalculateDistance` metody.</span><span class="sxs-lookup"><span data-stu-id="7df53-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="7df53-143">Pierwszy korzysta z dwóch zmiennych lokalnych przekazywana przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7df53-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="7df53-144">Drugi zawiera zmiennej tymczasowej utworzone jako część wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="7df53-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="7df53-145">Istnieje kilka sposobów, w których kompilator zapewnia, które tylko do odczytu rodzaj `in` argument jest wymuszana.</span><span class="sxs-lookup"><span data-stu-id="7df53-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="7df53-146">Przede wszystkim wywołaną metodę nie można przypisać bezpośrednio do `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="7df53-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="7df53-147">Bezpośrednio nie można przypisać do dowolnego pola `in` parametru, jeśli ta wartość jest `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="7df53-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="7df53-148">Ponadto nie można przekazać `in` parametr przy użyciu dowolnej metody `ref` lub `out` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="7df53-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="7df53-149">Te reguły dotyczą wszystkie pola z `in` podany parametr pole jest `struct` typu i parametru jest również `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="7df53-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="7df53-150">W rzeczywistości te reguły mają zastosowanie dla wielu warstw dostępu do elementu członkowskiego podane, są typy na wszystkich poziomach dostęp do elementu członkowskiego `structs`.</span><span class="sxs-lookup"><span data-stu-id="7df53-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="7df53-151">Wymusza kompilator, który `struct` typów przekazywane jako `in` argumentów i ich `struct` elementy członkowskie są zmienne tylko do odczytu, gdy jest używany jako argumenty do innych metod.</span><span class="sxs-lookup"><span data-stu-id="7df53-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="7df53-152">Korzystanie z `in` parametry pozwala uniknąć potencjalne koszty wydajności tworzenia kopii.</span><span class="sxs-lookup"><span data-stu-id="7df53-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="7df53-153">Nie zmienia semantykę wszystkie wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="7df53-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="7df53-154">W związku z tym nie należy określić `in` modyfikator w miejsce wywołania.</span><span class="sxs-lookup"><span data-stu-id="7df53-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="7df53-155">Jednakże, pomijając `in` modyfikator w witrynie wywołania informuje kompilator czy może on być kopię argumentu z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="7df53-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="7df53-156">Istnieje niejawna konwersja, ale nie tożsamości konwersja z typu argumentu na typ parametru.</span><span class="sxs-lookup"><span data-stu-id="7df53-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="7df53-157">Argument jest wyrażeniem, ale nie ma zmienną znane magazynu.</span><span class="sxs-lookup"><span data-stu-id="7df53-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="7df53-158">Istnieje inna obecności lub braku `in`.</span><span class="sxs-lookup"><span data-stu-id="7df53-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="7df53-159">W takim przypadku wartość przeciążenia jest lepszym dopasowaniem.</span><span class="sxs-lookup"><span data-stu-id="7df53-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="7df53-160">Reguły te są przydatne, jak aktualizacji istniejącego kodu do argumenty odwołania tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="7df53-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="7df53-161">Wewnątrz wywołaną metodę można wywołać dowolnej metody wystąpienia używanego przez wartości parametrów.</span><span class="sxs-lookup"><span data-stu-id="7df53-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="7df53-162">W tych przypadkach kopię `in` utworzeniu parametru.</span><span class="sxs-lookup"><span data-stu-id="7df53-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="7df53-163">Ponieważ kompilator można utworzyć zmiennej tymczasowej dla każdego `in` parametru, można również określić wartości domyślnej dla żadnego `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="7df53-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="7df53-164">Poniższy kod określa punkt początkowy (punkt 0,0) z wartością domyślną dla drugiego punktu:</span><span class="sxs-lookup"><span data-stu-id="7df53-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="7df53-165">Aby wymusić kompilatora do odczytu tylko argument jest przekazywany przez odwołanie, określ `in` modifer na argumenty w witrynie wywołanie, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="7df53-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="7df53-166">To zachowanie ułatwia przyjęcie `in` parametry z czasem w dużej codebases, gdy wzrost wydajności są możliwe.</span><span class="sxs-lookup"><span data-stu-id="7df53-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="7df53-167">Możesz dodać `in` modyfikator do metody sygnatur pierwszy.</span><span class="sxs-lookup"><span data-stu-id="7df53-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="7df53-168">Następnie można dodać `in` modyfikator na callsites i Utwórz `readonly struct` typów, aby włączyć kompilatora uniknąć tworzenia obrony kopie `in` parametrów w więcej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="7df53-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="7df53-169">`in` Parametr oznaczenia można również typy odwołań lub wartości liczbowe.</span><span class="sxs-lookup"><span data-stu-id="7df53-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="7df53-170">Jednak korzyści w obu przypadkach są minimalne, jeśli istnieje.</span><span class="sxs-lookup"><span data-stu-id="7df53-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="7df53-171">`ref readonly` Zwraca</span><span class="sxs-lookup"><span data-stu-id="7df53-171">`ref readonly` returns</span></span>

<span data-ttu-id="7df53-172">Można również zwrócić przez odwołanie typu wartości, ale nie zezwalaj na obiekt wywołujący modyfikowanie tej wartości.</span><span class="sxs-lookup"><span data-stu-id="7df53-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="7df53-173">Użyj `ref readonly` modyfikator Express celem tego projektu.</span><span class="sxs-lookup"><span data-stu-id="7df53-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="7df53-174">Czy są zwracane jest odwołanie do istniejących danych, ale nie zezwala na modyfikowanie powiadomi czytników.</span><span class="sxs-lookup"><span data-stu-id="7df53-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="7df53-175">Kompilator wymusza, że obiekt wywołujący nie można zmodyfikować odwołania.</span><span class="sxs-lookup"><span data-stu-id="7df53-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="7df53-176">Próby bezpośrednio przypisać wartość generuje błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="7df53-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="7df53-177">Jednak kompilator nie wiadomo, jeśli metoda dowolnego elementu członkowskiego modyfikuje stan struktury.</span><span class="sxs-lookup"><span data-stu-id="7df53-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="7df53-178">Aby upewnić się, że obiekt nie jest modyfikowany, kompilator tworzy kopię i wywołuje element członkowski odwołań za pomocą tej kopii.</span><span class="sxs-lookup"><span data-stu-id="7df53-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="7df53-179">Wszystkie modyfikacje są obrony ją.</span><span class="sxs-lookup"><span data-stu-id="7df53-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="7df53-180">Istnieje prawdopodobieństwo, że przy użyciu biblioteki `Point3D` często użyje źródła w całym kodzie.</span><span class="sxs-lookup"><span data-stu-id="7df53-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="7df53-181">Każde wystąpienie tworzy nowy obiekt na stosie.</span><span class="sxs-lookup"><span data-stu-id="7df53-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="7df53-182">Może być korzystne utworzyć stałą i zwracać jej przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7df53-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="7df53-183">Jednak jeśli zwraca odwołanie do wewnętrznej pamięci masowej, może zajść potrzeba wymuszenia, że obiekt wywołujący nie można zmodyfikować magazynu, do którego istnieje odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7df53-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="7df53-184">Poniższy kod definiuje właściwości tylko do odczytu, która zwraca `readonly ref` do `Point3D` , który określa punkt początkowy.</span><span class="sxs-lookup"><span data-stu-id="7df53-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="7df53-185">Tworzenie kopii tylko do odczytu ref zwracany jest prosty: tylko przypisz go do zmiennej, nie jest zadeklarowana z `ref readonly` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="7df53-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="7df53-186">Kompilator generuje kod, aby skopiować obiekt w ramach przypisania.</span><span class="sxs-lookup"><span data-stu-id="7df53-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="7df53-187">Po przypisaniu zmiennej `ref readonly return`, można określić `ref readonly` zmiennej lub przez wartość kopię tylko do odczytu odwołania:</span><span class="sxs-lookup"><span data-stu-id="7df53-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="7df53-188">Pierwsze przypisanie w poprzednim kodzie tworzy kopię `Origin` stała i przypisuje, które skopiować.</span><span class="sxs-lookup"><span data-stu-id="7df53-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="7df53-189">Drugi przypisuje odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7df53-189">The second assigns a reference.</span></span> <span data-ttu-id="7df53-190">Zwróć uwagę, że `readonly` modyfikator musi być częścią deklaracja zmiennej.</span><span class="sxs-lookup"><span data-stu-id="7df53-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="7df53-191">Nie można zmodyfikować odwołania, do którego się odwołuje.</span><span class="sxs-lookup"><span data-stu-id="7df53-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="7df53-192">Próbuje zrobić spowodować błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="7df53-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="7df53-193">`readonly struct` Typ</span><span class="sxs-lookup"><span data-stu-id="7df53-193">`readonly struct` type</span></span>

<span data-ttu-id="7df53-194">Stosowanie `ref readonly` na wykorzystanie dużym natężeniu ruchu struktury mogą być wystarczające.</span><span class="sxs-lookup"><span data-stu-id="7df53-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="7df53-195">Innym razem, można utworzyć niezmienialny struktury.</span><span class="sxs-lookup"><span data-stu-id="7df53-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="7df53-196">Zawsze można następnie przekazać przez odwołanie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="7df53-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="7df53-197">Czy rozwiązanie usuwa ataku kopiuje tego miejsce, gdy uzyskujesz dostęp do metody struktury używane jako `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="7df53-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="7df53-198">Możesz to zrobić, tworząc `readonly struct` typu.</span><span class="sxs-lookup"><span data-stu-id="7df53-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="7df53-199">Możesz dodać `readonly` modyfikatora w deklaracji struktury.</span><span class="sxs-lookup"><span data-stu-id="7df53-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="7df53-200">Kompilator wymusza, że wszystkie elementy członkowskie wystąpień struktury są `readonly`; `struct` musi być niezmienialne.</span><span class="sxs-lookup"><span data-stu-id="7df53-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="7df53-201">Istnieją inne optymalizacje dla `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="7df53-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="7df53-202">Można użyć `in` modyfikator w każdej lokalizacji gdzie `readonly struct` jest argumentem.</span><span class="sxs-lookup"><span data-stu-id="7df53-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="7df53-203">Ponadto można zwrócić `readonly struct` jako `ref return` po zwróconego obiektu, którego okres istnienia wykracza poza zakres metoda zwraca obiekt.</span><span class="sxs-lookup"><span data-stu-id="7df53-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="7df53-204">Na koniec kompilator generuje kod efektywniejsze podczas wywoływania członkami `readonly struct`: `this` odwołania, zamiast kopiowania odbiornika, jest zawsze `in` parametr przekazywany przez odwołanie do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="7df53-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="7df53-205">Tego rodzaju optymalizacji zapisuje więcej kopiowania, korzystając z `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="7df53-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="7df53-206">`Point3D` Jest doskonałym kandydatem do tej zmiany.</span><span class="sxs-lookup"><span data-stu-id="7df53-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="7df53-207">Poniższy kod przedstawia zaktualizowaną `ReadonlyPoint3D` struktury:</span><span class="sxs-lookup"><span data-stu-id="7df53-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="7df53-208">`ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="7df53-208">`ref struct` type</span></span>

<span data-ttu-id="7df53-209">Inna funkcja języka powiązane jest możliwość zadeklarować typu wartości, który musi znajdować się na stosie.</span><span class="sxs-lookup"><span data-stu-id="7df53-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="7df53-210">Innymi słowy te typy nigdy nie można utworzyć na stercie członkiem innej klasy.</span><span class="sxs-lookup"><span data-stu-id="7df53-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="7df53-211">Główną motywacją do tej funkcji został <xref:System.Span%601> i powiązanych struktury.</span><span class="sxs-lookup"><span data-stu-id="7df53-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="7df53-212"><xref:System.Span%601> może zawierać wskaźnika zarządzane jako jeden z jego elementów członkowskich, inne są długość zakresu.</span><span class="sxs-lookup"><span data-stu-id="7df53-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="7df53-213">Wdrażana jest nieco inaczej ponieważ C# nie obsługuje wskaźników do pamięci zarządzanej poza niebezpiecznym kontekście.</span><span class="sxs-lookup"><span data-stu-id="7df53-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="7df53-214">Wszelkie zapisu, która zmienia wskaźnika oraz długość nie jest atomic.</span><span class="sxs-lookup"><span data-stu-id="7df53-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="7df53-215">Oznacza to, że <xref:System.Span%601> będzie podlegać poza zakresem błędy lub innego typu naruszenia bezpieczeństwa zostały nie ograniczone do ramki stosu pojedynczego.</span><span class="sxs-lookup"><span data-stu-id="7df53-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="7df53-216">Ponadto zwykle umieszczenie wskaźnika zarządzanego na stercie GC ulega awarii podczas JIT.</span><span class="sxs-lookup"><span data-stu-id="7df53-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="7df53-217">Może być podobne wymagania dotyczące pracy z pamięci utworzone za pomocą [ `stackalloc` ](language-reference/keywords/stackalloc.md) lub w przypadku używania pamięci z międzyoperacyjnego interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="7df53-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="7df53-218">Można definiować własnych `ref struct` typy dla tych potrzeb.</span><span class="sxs-lookup"><span data-stu-id="7df53-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="7df53-219">W tym artykule, zobacz przykłady użycia `Span<T>` dla uproszczenia.</span><span class="sxs-lookup"><span data-stu-id="7df53-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="7df53-220">`ref struct` Deklaracji deklaruje struktury tego typu musi być na stosie.</span><span class="sxs-lookup"><span data-stu-id="7df53-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="7df53-221">Reguły języka zapewnienia bezpiecznego korzystania z tych typów.</span><span class="sxs-lookup"><span data-stu-id="7df53-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="7df53-222">Inne typy zadeklarowane jako `ref struct` obejmują <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="7df53-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="7df53-223">Celem porządkowania `ref struct` typu jako zmienną przydzielony stos wprowadzono kilka reguł, które kompilator wymusza dla wszystkich `ref struct` typów.</span><span class="sxs-lookup"><span data-stu-id="7df53-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="7df53-224">Nie można polu `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="7df53-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="7df53-225">Nie można przypisać `ref struct` typ zmiennej typu `object`, `dynamic`, albo typu interfejsu.</span><span class="sxs-lookup"><span data-stu-id="7df53-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="7df53-226">Nie można zadeklarować `ref struct` jako element członkowski klasy lub struktury normalnego.</span><span class="sxs-lookup"><span data-stu-id="7df53-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="7df53-227">Nie można deklarować zmiennych lokalnych, które są `ref struct` typów w metodach asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="7df53-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="7df53-228">Można je zadeklarować w metod synchronicznych, które zwracają `Task`, `Task<T>` lub typów zadań.</span><span class="sxs-lookup"><span data-stu-id="7df53-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="7df53-229">Nie można zadeklarować `ref struct` zmiennych lokalnych w iteratorach.</span><span class="sxs-lookup"><span data-stu-id="7df53-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="7df53-230">Nie można przechwycić `ref struct` zmiennych w wyrażeniach lambda lub funkcje lokalne.</span><span class="sxs-lookup"><span data-stu-id="7df53-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="7df53-231">Upewnij się, te ograniczenia nie używasz przypadkowo `ref struct` w taki sposób, który można podwyższyć sterty zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="7df53-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="7df53-232">`readonly ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="7df53-232">`readonly ref struct` type</span></span>

<span data-ttu-id="7df53-233">Deklarowanie struktury jako `readonly ref` łączy korzyści i ograniczeń dotyczących `ref struct` i `readonly struct` delcarations.</span><span class="sxs-lookup"><span data-stu-id="7df53-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="7df53-234">W poniższym przykładzie pokazano deklaracja `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="7df53-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="7df53-235">Wnioski</span><span class="sxs-lookup"><span data-stu-id="7df53-235">Conclusions</span></span>

<span data-ttu-id="7df53-236">Te ulepszenia języka C# są przeznaczone dla algorytmów krytyczne wydajności, których alokacji pamięci może być krytyczne znaczenie dla osiągnięcia niezbędne wydajności.</span><span class="sxs-lookup"><span data-stu-id="7df53-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="7df53-237">Może się okazać, że nie są często używane te funkcje w kodzie zostanie zapisany.</span><span class="sxs-lookup"><span data-stu-id="7df53-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="7df53-238">Jednak te ulepszenia zostały przyjęte w wielu lokalizacjach w programie .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7df53-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="7df53-239">Jak coraz więcej interfejsów API należy używać tych funkcji, zobaczysz poprawy wydajności własnych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="7df53-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
