---
title: Semantyka odwołań z typami wartości
description: Omówienie funkcji języka, które bezpiecznie zminimalizować kopiowania struktury
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/08/2018
ms.locfileid: "44209527"
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="52ef9-103">Semantyka odwołań z typami wartości</span><span class="sxs-lookup"><span data-stu-id="52ef9-103">Reference semantics with value types</span></span>

<span data-ttu-id="52ef9-104">Zaletą używania typów wartości jest, aby uniknąć często alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="52ef9-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="52ef9-105">Wadą jest to, że są one kopiowane przez wartość.</span><span class="sxs-lookup"><span data-stu-id="52ef9-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="52ef9-106">To kosztem utrudnienie Optymalizowanie algorytmów, które działają na dużych ilości danych.</span><span class="sxs-lookup"><span data-stu-id="52ef9-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="52ef9-107">Nowe funkcje języka w języku C# 7.2 zapewniają mechanizmy, które umożliwiają semantyki przekazywany przez odwołanie z typami wartości.</span><span class="sxs-lookup"><span data-stu-id="52ef9-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="52ef9-108">Należy uważnie używać tych funkcji do minimum zarówno alokacji i operacje kopiowania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="52ef9-109">W tym artykule przeanalizowano tych nowych funkcji.</span><span class="sxs-lookup"><span data-stu-id="52ef9-109">This article explores those new features.</span></span>

<span data-ttu-id="52ef9-110">Duża część przykładowego kodu w tym artykule przedstawiono funkcje dodane w języku C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="52ef9-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="52ef9-111">Aby można było używać tych funkcji, należy skonfigurować projekt do języka C# 7.2 lub nowsza.</span><span class="sxs-lookup"><span data-stu-id="52ef9-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="52ef9-112">Aby uzyskać więcej informacji na temat ustawiania wersji języka zobacz [skonfigurować wersję językową](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="52ef9-112">For more information on setting the language version see [configure the language version](language-reference/configure-language-version.md).</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="52ef9-113">Przekazywanie argumentów poprzez odwołanie tylko do odczytu</span><span class="sxs-lookup"><span data-stu-id="52ef9-113">Passing arguments by readonly reference</span></span>

<span data-ttu-id="52ef9-114">Dodaje w języku C# 7.2 `in` słowa kluczowego jako uzupełnienie istniejących `ref` i `out` słów kluczowych, aby przekazywać argumentów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-114">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="52ef9-115">`in` — Słowo kluczowe Określa, przekazywanie argumentu przez odwołanie, ale wywoływanej metody nie modyfikuje wartości.</span><span class="sxs-lookup"><span data-stu-id="52ef9-115">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="52ef9-116">To dodawanie zapewnia pełną słownictwa wyrażenia zgodną z planem projektu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-116">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="52ef9-117">Typy wartości są kopiowane, gdy przekazywane do metody o nazwie, jeśli nie określisz dowolną z następujących modyfikatorów w podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="52ef9-117">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="52ef9-118">Każda z tych modyfikatorów Określa, że typ wartości jest przekazywany przez odwołanie, unikając kopiowania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-118">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="52ef9-119">Każdy modyfikator wyraża innego zamiaru:</span><span class="sxs-lookup"><span data-stu-id="52ef9-119">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="52ef9-120">`out`: Ta metoda ustawia wartość argumentu jako parametr.</span><span class="sxs-lookup"><span data-stu-id="52ef9-120">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="52ef9-121">`ref`: Ta metoda może ustawić wartość argumentu jako parametr.</span><span class="sxs-lookup"><span data-stu-id="52ef9-121">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="52ef9-122">`in`: Ta metoda nie modyfikuje wartość argumentu jako parametr.</span><span class="sxs-lookup"><span data-stu-id="52ef9-122">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="52ef9-123">Dodaj `in` modyfikator do przekazywania argumentu przez odwołanie i Zadeklaruj swoje założenia projektowe, aby przekazywać argumentów przez odwołanie, aby uniknąć niepotrzebnego kopiowania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-123">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="52ef9-124">Nie zamierzasz zmodyfikować obiekt używany w roli tego argumentu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-124">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="52ef9-125">Poniższy kod przedstawia przykład metody, które oblicza odległość między dwoma punktami w przestrzeni 3D.</span><span class="sxs-lookup"><span data-stu-id="52ef9-125">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="52ef9-126">Argumenty są dwie struktury, że każdy zawiera trzech liczb typu Double.</span><span class="sxs-lookup"><span data-stu-id="52ef9-126">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="52ef9-127">Wartość o podwójnej precyzji jest 8 bajtów, dzięki czemu każdy argument jest 24 bajty.</span><span class="sxs-lookup"><span data-stu-id="52ef9-127">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="52ef9-128">Określając `in` modyfikatora, należy przekazać odwołanie 4-bajtowych lub 8 bajtów do tych argumentów, w zależności od architektury komputera.</span><span class="sxs-lookup"><span data-stu-id="52ef9-128">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="52ef9-129">Różnica w rozmiarze jest mała, ale jego można szybko dodać gdy Twoja aplikacja wywołuje tę metodę w pętli za pomocą wielu różnych wartości.</span><span class="sxs-lookup"><span data-stu-id="52ef9-129">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="52ef9-130">`in` Uzupełniające modyfikator `out` i `ref` w inny sposób, jak również.</span><span class="sxs-lookup"><span data-stu-id="52ef9-130">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="52ef9-131">Nie można utworzyć przeciążenia metody, które różnią się tylko w obecności właściwości `in`, `out`, lub `ref`.</span><span class="sxs-lookup"><span data-stu-id="52ef9-131">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="52ef9-132">Te nowe reguły rozszerzyć takie samo zachowanie, które zawsze miały zostały zdefiniowane dla `out` i `ref` parametrów.</span><span class="sxs-lookup"><span data-stu-id="52ef9-132">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="52ef9-133">`in` Modyfikator mogą być stosowane do wszystkich elementów członkowskich, która przyjmuje parametry: metod delegatów, wyrażeń lambda, funkcji lokalnych, indeksatory, operatorów.</span><span class="sxs-lookup"><span data-stu-id="52ef9-133">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="52ef9-134">W odróżnieniu od `ref` i `out` argumentów, możesz użyć wartości literałów lub stałe dla argumentu dla `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="52ef9-134">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="52ef9-135">Ponadto, w odróżnieniu od `ref` lub `out` parametru, nie trzeba zastosować `in` modyfikator w witrynie wywołania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-135">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="52ef9-136">Poniższy kod pokazuje dwa przykłady wywoływania `CalculateDistance` metody.</span><span class="sxs-lookup"><span data-stu-id="52ef9-136">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="52ef9-137">Pierwszy używa dwóch zmiennych lokalnych, przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-137">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="52ef9-138">Drugi zawiera zmienną tymczasową utworzonych jako część wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="52ef9-138">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="52ef9-139">Istnieje kilka sposobów, w których kompilator zapewnia, które tylko do odczytu rodzaj `in` argument jest wymuszany.</span><span class="sxs-lookup"><span data-stu-id="52ef9-139">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="52ef9-140">Po pierwsze, wywoływanej metody nie można przypisać bezpośrednio do `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="52ef9-140">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="52ef9-141">Bezpośrednio nie można przypisać do dowolnego pola `in` parametr, gdy ta wartość jest `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-141">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="52ef9-142">Ponadto nie można przekazać `in` parametr przy użyciu dowolnej metody `ref` lub `out` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="52ef9-142">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="52ef9-143">Te reguły mają zastosowanie do dowolnego pola `in` parametru podane, pole jest `struct` typu, a parametr jest również `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-143">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="52ef9-144">W rzeczywistości te reguły stosuje się na wiele warstw dostępu do elementu członkowskiego, pod warunkiem typy na wszystkich poziomach dostępu do elementu członkowskiego `structs`.</span><span class="sxs-lookup"><span data-stu-id="52ef9-144">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="52ef9-145">Kompilator wymusza, który `struct` typy przekazane jako `in` argumentów i ich `struct` elementy członkowskie są zmienne tylko do odczytu, gdy jest używana jako argumenty do innych metod.</span><span class="sxs-lookup"><span data-stu-id="52ef9-145">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="52ef9-146">Korzystanie z `in` parametry pozwala uniknąć potencjalnych kosztów wydajności tworzenia kopii.</span><span class="sxs-lookup"><span data-stu-id="52ef9-146">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="52ef9-147">Nie zmienia semantykę każde wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="52ef9-147">It does not change the semantics of any method call.</span></span> <span data-ttu-id="52ef9-148">W związku z tym, nie należy określić `in` modyfikator w witrynie wywołania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-148">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="52ef9-149">Jednakże, pomijając `in` modyfikator w witrynie wywołania informuje kompilator, że może on być kopię argumentu z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="52ef9-149">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="52ef9-150">Istnieje niejawna konwersja, ale nie tożsamość konwersję z typu argumentu z typem parametru.</span><span class="sxs-lookup"><span data-stu-id="52ef9-150">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="52ef9-151">Argument jest wyrażeniem, ale nie ma zmienną znanych magazynu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-151">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="52ef9-152">Istnieje przeciążenie różni się obecności lub braku `in`.</span><span class="sxs-lookup"><span data-stu-id="52ef9-152">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="52ef9-153">W takim przypadku według wartości przeciążenia ma lepsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-153">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="52ef9-154">Reguły te są przydatne w przypadku aktualizowania istniejącego kodu do argumenty odwołania tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-154">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="52ef9-155">Wewnątrz metody o nazwie możesz wywołać dowolnej metody wystąpienia, która używa parametrów wielowartościowych.</span><span class="sxs-lookup"><span data-stu-id="52ef9-155">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="52ef9-156">W tych przypadkach kopię `in` utworzeniu parametru.</span><span class="sxs-lookup"><span data-stu-id="52ef9-156">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="52ef9-157">Ponieważ kompilator może tworzyć zmiennej tymczasowej dla każdej `in` parametru, można również określić wartości domyślnych dla każdej `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="52ef9-157">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="52ef9-158">Poniższy kod określa pochodzenia (punkt 0,0) jako wartość domyślna dla drugi punkt:</span><span class="sxs-lookup"><span data-stu-id="52ef9-158">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="52ef9-159">Aby wymusić na kompilatorze odczytu tylko argument jest przekazywany przez odwołanie, należy określić `in` modifer dla argumentów w witrynie wywołania, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="52ef9-159">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="52ef9-160">To zachowanie ułatwia przyjęcie `in` parametrów wraz z upływem czasu w dużych bazach kodu, gdzie możliwe są wzrost wydajności.</span><span class="sxs-lookup"><span data-stu-id="52ef9-160">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="52ef9-161">Możesz dodać `in` modyfikatora podpisy metod pierwszy.</span><span class="sxs-lookup"><span data-stu-id="52ef9-161">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="52ef9-162">Następnie należy dodać `in` modyfikator na callsites i utworzyć `readonly struct` typy umożliwiające kompilatorowi unikanie tworzenia kopii obrony `in` parametrów w większej liczby lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="52ef9-162">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="52ef9-163">`in` Nazwy parametru może również służyć za pomocą typów referencyjnych lub wartości liczbowych.</span><span class="sxs-lookup"><span data-stu-id="52ef9-163">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="52ef9-164">Jednak korzyści w obu przypadkach są minimalne, jeśli istnieje.</span><span class="sxs-lookup"><span data-stu-id="52ef9-164">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="52ef9-165">`ref readonly` Zwraca</span><span class="sxs-lookup"><span data-stu-id="52ef9-165">`ref readonly` returns</span></span>

<span data-ttu-id="52ef9-166">Można również zwrócić przez odwołanie, typ wartości, ale zabronić wywołującego od modyfikowania tej wartości.</span><span class="sxs-lookup"><span data-stu-id="52ef9-166">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="52ef9-167">Użyj `ref readonly` modyfikatora express przeznaczenie tego projektu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-167">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="52ef9-168">Czy są zwracanie odwołania do istniejących danych, ale nie zezwala na modyfikowanie, powiadamia czytników.</span><span class="sxs-lookup"><span data-stu-id="52ef9-168">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="52ef9-169">Kompilator wymusza to, że obiekt wywołujący nie można zmodyfikować odwołania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-169">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="52ef9-170">Podejmowana jest próba przypisania wartości bezpośrednio wygenerować błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="52ef9-170">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="52ef9-171">Jednak kompilator nie wiadomo, jeśli metoda dowolnego elementu członkowskiego modyfikuje stan struktury.</span><span class="sxs-lookup"><span data-stu-id="52ef9-171">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="52ef9-172">Aby upewnić się, że obiekt nie jest modyfikowany, kompilator tworzy kopię i wywołuje element członkowski odwołań za pomocą tej kopii.</span><span class="sxs-lookup"><span data-stu-id="52ef9-172">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="52ef9-173">Wszystkie modyfikacje są tym kopia obronna.</span><span class="sxs-lookup"><span data-stu-id="52ef9-173">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="52ef9-174">Istnieje prawdopodobieństwo, że przy użyciu biblioteki `Point3D` często użyje źródła w całym kodzie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-174">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="52ef9-175">Każde wystąpienie tworzy nowy obiekt na stosie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-175">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="52ef9-176">Może być korzystne, aby utworzyć stałą i przywrócić go przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-176">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="52ef9-177">Jednak jeśli zwracane odwołanie do pamięci wewnętrznej, możesz chcieć wymusić, że obiekt wywołujący nie można zmodyfikować odwołania magazynu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-177">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="52ef9-178">Poniższy kod definiuje właściwość tylko do odczytu, która zwraca `readonly ref` do `Point3D` , który określa punkt początkowy.</span><span class="sxs-lookup"><span data-stu-id="52ef9-178">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="52ef9-179">Tworzenie kopii tylko do odczytu ref zwracany jest proste: wystarczy przypisać ją do zmiennej nie jest zadeklarowana za pomocą `ref readonly` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="52ef9-179">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="52ef9-180">Kompilator generuje kod, aby skopiować obiekt w ramach przypisania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-180">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="52ef9-181">Po przypisaniu zmiennej, aby `ref readonly return`, można określić `ref readonly` zmiennej lub kopię przez wartość odniesienia tylko do odczytu:</span><span class="sxs-lookup"><span data-stu-id="52ef9-181">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="52ef9-182">Pierwsze przypisanie w poprzednim kodzie tworzy kopię `Origin` stałych i przypisuje kopiujących.</span><span class="sxs-lookup"><span data-stu-id="52ef9-182">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="52ef9-183">Drugi przypisuje odwołania.</span><span class="sxs-lookup"><span data-stu-id="52ef9-183">The second assigns a reference.</span></span> <span data-ttu-id="52ef9-184">Należy zauważyć, że `readonly` modyfikator musi być częścią deklaracja zmiennej.</span><span class="sxs-lookup"><span data-stu-id="52ef9-184">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="52ef9-185">Nie można zmodyfikować odwołania, do którego się odwołuje.</span><span class="sxs-lookup"><span data-stu-id="52ef9-185">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="52ef9-186">Próba wykonania tej czynności powoduje błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="52ef9-186">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="52ef9-187">`readonly struct` Typ</span><span class="sxs-lookup"><span data-stu-id="52ef9-187">`readonly struct` type</span></span>

<span data-ttu-id="52ef9-188">Stosowanie `ref readonly` do zastosowań o dużym natężeniu ruchu struktury mogą być wystarczające.</span><span class="sxs-lookup"><span data-stu-id="52ef9-188">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="52ef9-189">W innych sytuacjach można utworzyć niemodyfikowalny struktury.</span><span class="sxs-lookup"><span data-stu-id="52ef9-189">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="52ef9-190">Zawsze można następnie przekazać według odwołania tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-190">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="52ef9-191">Czy rozwiązanie usuwa ataku kopiuje tego miejsce, gdy uzyskujesz dostęp do metod struktury, używane jako `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="52ef9-191">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="52ef9-192">Możesz to zrobić, tworząc `readonly struct` typu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-192">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="52ef9-193">Możesz dodać `readonly` modyfikatora deklaracji struktury.</span><span class="sxs-lookup"><span data-stu-id="52ef9-193">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="52ef9-194">Kompilator wymusza na to, że wszystkie składowe wystąpienia struktury są `readonly`; `struct` musi być niezmienialne.</span><span class="sxs-lookup"><span data-stu-id="52ef9-194">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="52ef9-195">Istnieją inne optymalizacje dla `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="52ef9-195">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="52ef9-196">Możesz użyć `in` modyfikator w każdym miejscu gdzie `readonly struct` jest argumentem.</span><span class="sxs-lookup"><span data-stu-id="52ef9-196">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="52ef9-197">Ponadto, można zwrócić `readonly struct` jako `ref return` kiedy jest zwracany obiekt, którego okres istnienia wykracza poza zakres metoda zwraca obiekt.</span><span class="sxs-lookup"><span data-stu-id="52ef9-197">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="52ef9-198">Na koniec, kompilator generuje kod bardziej efektywne, gdy wywołujesz członkowie `readonly struct`: `this` odwołanie, zamiast kopii receiver, jest zawsze `in` parametr przekazywany przez odwołanie do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="52ef9-198">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="52ef9-199">Tego rodzaju optymalizacji zapisuje więcej kopiowanie, gdy używasz `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="52ef9-199">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="52ef9-200">`Point3D` Jest doskonałym kandydatem do tej zmiany.</span><span class="sxs-lookup"><span data-stu-id="52ef9-200">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="52ef9-201">Poniższy kod przedstawia zaktualizowaną `ReadonlyPoint3D` strukturę:</span><span class="sxs-lookup"><span data-stu-id="52ef9-201">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="52ef9-202">`ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="52ef9-202">`ref struct` type</span></span>

<span data-ttu-id="52ef9-203">Kolejną funkcją języka powiązane jest zdolność do deklarowania typu wartości, która musi być na stosie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-203">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="52ef9-204">Innymi słowy te typy nigdy nie można utworzyć na stosie jest członkiem innej klasy.</span><span class="sxs-lookup"><span data-stu-id="52ef9-204">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="52ef9-205">Główną motywacją do tej funkcji został <xref:System.Span%601> i pokrewne struktury.</span><span class="sxs-lookup"><span data-stu-id="52ef9-205">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="52ef9-206"><xref:System.Span%601> może zawierać wskaźnika zarządzanych jako jeden z jej członków, inne są długość zakresu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-206"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="52ef9-207">Wdrażana jest nieco inaczej ponieważ języka C# nie obsługuje wskaźników do pamięci zarządzanej poza niebezpieczny kontekst.</span><span class="sxs-lookup"><span data-stu-id="52ef9-207">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="52ef9-208">Wszelkie zapisu, która zmienia się wskaźnik i długość nie jest atomic.</span><span class="sxs-lookup"><span data-stu-id="52ef9-208">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="52ef9-209">Oznacza to, że <xref:System.Span%601> byłoby podlegają poza zakresem błędy lub inne naruszenia bezpieczeństwa typu nie, nie jest ona ograniczona do ramki stosu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-209">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="52ef9-210">Ponadto umieszczenie wskaźnika zarządzanych na stercie GC zazwyczaj kończy się niepowodzeniem w momencie JIT.</span><span class="sxs-lookup"><span data-stu-id="52ef9-210">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="52ef9-211">Masz podobnych wymaganiach dotyczących pracy z pamięcią utworzone za pomocą [ `stackalloc` ](language-reference/keywords/stackalloc.md) lub w przypadku używania pamięci za pomocą międzyoperacyjnych interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="52ef9-211">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="52ef9-212">Definiowanie swoich własnych `ref struct` typy dla tych wymagań.</span><span class="sxs-lookup"><span data-stu-id="52ef9-212">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="52ef9-213">W tym artykule, zobacz przykłady użycia `Span<T>` dla uproszczenia.</span><span class="sxs-lookup"><span data-stu-id="52ef9-213">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="52ef9-214">`ref struct` Deklaracji deklaruje strukturę tego typu muszą znajdować się na stosie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-214">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="52ef9-215">Reguły języka zapewnienia bezpiecznego korzystania z tych typów.</span><span class="sxs-lookup"><span data-stu-id="52ef9-215">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="52ef9-216">Inne typy zadeklarowane jako `ref struct` obejmują <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="52ef9-216">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="52ef9-217">Celem zachowywaniu `ref struct` wpisz zmienną przydzielanych ze stosów wprowadza kilka reguł, które kompilator wymusza dla wszystkich `ref struct` typów.</span><span class="sxs-lookup"><span data-stu-id="52ef9-217">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="52ef9-218">Nie można polu `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="52ef9-218">You can't box a `ref struct`.</span></span> <span data-ttu-id="52ef9-219">Nie można przypisać `ref struct` typ do zmiennej typu `object`, `dynamic`, lub dowolny typ interfejsu.</span><span class="sxs-lookup"><span data-stu-id="52ef9-219">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="52ef9-220">Nie można zadeklarować `ref struct` jako członek klasy lub struktury normalny.</span><span class="sxs-lookup"><span data-stu-id="52ef9-220">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="52ef9-221">Nie można zadeklarować zmienne lokalne, które są `ref struct` typów w metodach asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="52ef9-221">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="52ef9-222">Można zadeklarować je metod synchronicznych, które zwracają `Task`, `Task<T>` lub typu przypominającego zadanie.</span><span class="sxs-lookup"><span data-stu-id="52ef9-222">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="52ef9-223">Nie można zadeklarować `ref struct` zmiennych lokalnych w iteratorach.</span><span class="sxs-lookup"><span data-stu-id="52ef9-223">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="52ef9-224">Nie można dokonać przechwytu `ref struct` zmiennych w wyrażeniach lambda lub funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="52ef9-224">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="52ef9-225">Te ograniczenia, upewnij się, nie używasz przypadkowo `ref struct` w taki sposób, który można podwyższyć poziom do zarządzanej sterty.</span><span class="sxs-lookup"><span data-stu-id="52ef9-225">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="52ef9-226">`readonly ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="52ef9-226">`readonly ref struct` type</span></span>

<span data-ttu-id="52ef9-227">Deklarowanie struktury jako `readonly ref` łączy korzyści i ograniczeń dotyczących `ref struct` i `readonly struct` deklaracji.</span><span class="sxs-lookup"><span data-stu-id="52ef9-227">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> 

<span data-ttu-id="52ef9-228">W poniższym przykładzie pokazano deklaracji `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="52ef9-228">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="52ef9-229">Wnioski</span><span class="sxs-lookup"><span data-stu-id="52ef9-229">Conclusions</span></span>

<span data-ttu-id="52ef9-230">Te ulepszenia języka C# są przeznaczone dla algorytmów krytyczne wydajności, gdzie alokacji pamięci może być mają kluczowe znaczenie dla osiągnięcia niezbędne wydajności.</span><span class="sxs-lookup"><span data-stu-id="52ef9-230">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="52ef9-231">Może się okazać, że nie są często używane funkcje te w kodzie, którą piszesz.</span><span class="sxs-lookup"><span data-stu-id="52ef9-231">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="52ef9-232">Jednak te ulepszenia zostały przyjęte w wielu lokalizacjach w programie .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="52ef9-232">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="52ef9-233">Ponieważ coraz więcej interfejsy API korzystać z tych funkcji, zobaczysz wydajności własnych aplikacji, zwiększyć.</span><span class="sxs-lookup"><span data-stu-id="52ef9-233">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
