---
title: Właściwości
description: Dowiedz się więcej o C# właściwości, które zawierają funkcje sprawdzania poprawności, obliczonych wartości, obliczanie z opóźnieniem i zmienić właściwości powiadomienia.
ms.date: 04/25/2018
ms.openlocfilehash: d4fa7b6117bec63c41318dd4bcc3850ce55a5907
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61675783"
---
# <a name="properties"></a><span data-ttu-id="f62b5-103">Właściwości</span><span class="sxs-lookup"><span data-stu-id="f62b5-103">Properties</span></span>

<span data-ttu-id="f62b5-104">Właściwości są obywatelami pierwszej klasy w C#.</span><span class="sxs-lookup"><span data-stu-id="f62b5-104">Properties are first class citizens in C#.</span></span> <span data-ttu-id="f62b5-105">Język definiuje składnia, która umożliwia programistom pisanie kodu, który dokładnie odzwierciedla ich celem projektu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-105">The language defines syntax that enables developers to write code that accurately expresses their design intent.</span></span>

<span data-ttu-id="f62b5-106">Właściwości zachowują się jak pola, gdy są one używane.</span><span class="sxs-lookup"><span data-stu-id="f62b5-106">Properties behave like fields when they are accessed.</span></span>
<span data-ttu-id="f62b5-107">Jednak w przeciwieństwie do pola, właściwości są implementowane za pomocą metody dostępu, które definiują instrukcje wykonania, gdy właściwość jest dostępny lub przypisane.</span><span class="sxs-lookup"><span data-stu-id="f62b5-107">However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.</span></span>

## <a name="property-syntax"></a><span data-ttu-id="f62b5-108">Składnia właściwości</span><span class="sxs-lookup"><span data-stu-id="f62b5-108">Property syntax</span></span>

<span data-ttu-id="f62b5-109">Składnia właściwości jest naturalnym rozszerzeniem pola.</span><span class="sxs-lookup"><span data-stu-id="f62b5-109">The syntax for properties is a natural extension to fields.</span></span> <span data-ttu-id="f62b5-110">Pole definiuje lokalizację magazynu:</span><span class="sxs-lookup"><span data-stu-id="f62b5-110">A field defines a storage location:</span></span>

[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]

<span data-ttu-id="f62b5-111">Definicja właściwości zawiera deklaracje dla `get` i `set` metodę dostępu, która pobiera i przypisuje wartość tej właściwości:</span><span class="sxs-lookup"><span data-stu-id="f62b5-111">A property definition contains declarations for a `get` and `set` accessor that retrieves and assigns the value of that property:</span></span>

[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]

<span data-ttu-id="f62b5-112">Składnia powyżej jest *auto-właściwości* składni.</span><span class="sxs-lookup"><span data-stu-id="f62b5-112">The syntax shown above is the *auto property* syntax.</span></span> <span data-ttu-id="f62b5-113">Kompilator generuje lokalizację magazynu dla pola, które tworzy kopię zapasową właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-113">The compiler generates the storage location for the field that backs up the property.</span></span> <span data-ttu-id="f62b5-114">Kompilator implementuje również treści `get` i `set` metod dostępu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-114">The compiler also implements the body of the `get` and `set` accessors.</span></span>

<span data-ttu-id="f62b5-115">Czasami musisz zainicjować właściwość, która ma wartość inną niż domyślna dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-115">Sometimes, you need to initialize a property to a value other than the default for its type.</span></span>  <span data-ttu-id="f62b5-116">C#Umożliwia, ustawiając wartość po zamykającego nawiasu klamrowego dla właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-116">C# enables that by setting a value after the closing brace for the property.</span></span> <span data-ttu-id="f62b5-117">Lepiej wartość początkową dla `FirstName` właściwość, aby być ciągiem pustym zamiast `null`.</span><span class="sxs-lookup"><span data-stu-id="f62b5-117">You may prefer the initial value for the `FirstName` property to be the empty string rather than `null`.</span></span> <span data-ttu-id="f62b5-118">Określ, jak pokazano poniżej:</span><span class="sxs-lookup"><span data-stu-id="f62b5-118">You would specify that as shown below:</span></span>

[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]

<span data-ttu-id="f62b5-119">Inicjowanie określonych jest najbardziej przydatne do właściwości tylko do odczytu, jak zobaczysz w dalszej części tego artykułu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-119">Specific initialization is most useful for read-only properties, as you'll see later in this article.</span></span>

<span data-ttu-id="f62b5-120">Można również definiować magazynu samodzielnie, jak pokazano poniżej:</span><span class="sxs-lookup"><span data-stu-id="f62b5-120">You can also define the storage yourself, as shown below:</span></span>

[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]

<span data-ttu-id="f62b5-121">Jeśli implementacja właściwości jest pojedyncze wyrażenie, możesz użyć *elementy członkowskie z wyrażeniem* dla metody pobierającej lub ustawiającej:</span><span class="sxs-lookup"><span data-stu-id="f62b5-121">When a property implementation is a single expression, you can use *expression-bodied members* for the getter or setter:</span></span>

[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]

<span data-ttu-id="f62b5-122">To uproszczoną składnię będzie używany, gdy to stosowne, w tym artykule.</span><span class="sxs-lookup"><span data-stu-id="f62b5-122">This simplified syntax will be used where applicable throughout this article.</span></span>

<span data-ttu-id="f62b5-123">Definicja właściwości przedstawionych powyżej jest właściwością odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-123">The property definition shown above is a read-write property.</span></span> <span data-ttu-id="f62b5-124">Zwróć uwagę, słowo kluczowe `value` w metodzie dostępu set.</span><span class="sxs-lookup"><span data-stu-id="f62b5-124">Notice the keyword `value` in the set accessor.</span></span> <span data-ttu-id="f62b5-125">`set` Akcesor zawsze ma jeden parametr o nazwie `value`.</span><span class="sxs-lookup"><span data-stu-id="f62b5-125">The `set` accessor always has a single parameter named `value`.</span></span> <span data-ttu-id="f62b5-126">`get` Dostępu musi zwracać wartość, która jest konwertowany na typ właściwości (`string` w tym przykładzie).</span><span class="sxs-lookup"><span data-stu-id="f62b5-126">The `get` accessor must return a value that is convertible to the type of the property (`string` in this example).</span></span>

<span data-ttu-id="f62b5-127">To podstawy składni.</span><span class="sxs-lookup"><span data-stu-id="f62b5-127">That's the basics of the syntax.</span></span> <span data-ttu-id="f62b5-128">Istnieje wiele różnych odmiany, które obsługują szereg idiomy innego projektu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-128">There are many different variations that support a variety of different design idioms.</span></span> <span data-ttu-id="f62b5-129">Umożliwia Eksplorowanie i Dowiedz się opcje składnię dla każdego.</span><span class="sxs-lookup"><span data-stu-id="f62b5-129">Let's explore, and learn the syntax options for each.</span></span>

## <a name="scenarios"></a><span data-ttu-id="f62b5-130">Scenariusze</span><span class="sxs-lookup"><span data-stu-id="f62b5-130">Scenarios</span></span>

<span data-ttu-id="f62b5-131">Powyższe przykłady wykazało, że jeden z najprostszym przypadków definicji właściwości: właściwości odczytu / zapisu o nie nastąpi sprawdzanie poprawności.</span><span class="sxs-lookup"><span data-stu-id="f62b5-131">The examples above showed one of the simplest cases of property definition: a read-write property with no validation.</span></span> <span data-ttu-id="f62b5-132">Pisząc kod chcesz w `get` i `set` metod dostępu, możesz utworzyć wiele różnych scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="f62b5-132">By writing the code you want in the `get` and `set` accessors, you can create many different scenarios.</span></span>

### <a name="validation"></a><span data-ttu-id="f62b5-133">Walidacja</span><span class="sxs-lookup"><span data-stu-id="f62b5-133">Validation</span></span>

<span data-ttu-id="f62b5-134">Można wpisać kod w `set` metody dostępu, upewnij się, że wartości, reprezentowane przez właściwość zawsze prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="f62b5-134">You can write code in the `set` accessor to ensure that the values represented by a property are always valid.</span></span> <span data-ttu-id="f62b5-135">Na przykład, załóżmy, że jedna reguła dla `Person` klasa jest, że nazwa nie może być puste lub biały znak.</span><span class="sxs-lookup"><span data-stu-id="f62b5-135">For example, suppose one rule for the `Person` class is that the name cannot be blank or white space.</span></span> <span data-ttu-id="f62b5-136">Czy zapisać, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="f62b5-136">You would write that as follows:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]

<span data-ttu-id="f62b5-137">Poprzedni przykład można uprościć za pomocą`throw` wyrażenia w ramach sprawdzania poprawności metody ustawiającej właściwość:</span><span class="sxs-lookup"><span data-stu-id="f62b5-137">The preceding example can be simplified by using a`throw` expression as part of the property setter validation:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]

<span data-ttu-id="f62b5-138">W powyższym przykładzie wymusza, zasada, że imię nie może być pusta lub biały znak.</span><span class="sxs-lookup"><span data-stu-id="f62b5-138">The example above enforces the rule that the first name must not be blank or white space.</span></span> <span data-ttu-id="f62b5-139">Jeśli Deweloper zapisuje</span><span class="sxs-lookup"><span data-stu-id="f62b5-139">If a developer writes</span></span>

```csharp
hero.FirstName = "";
```

<span data-ttu-id="f62b5-140">Przypisanie zgłasza `ArgumentException`.</span><span class="sxs-lookup"><span data-stu-id="f62b5-140">That assignment throws an `ArgumentException`.</span></span> <span data-ttu-id="f62b5-141">Ponieważ dostępu set z właściwość musi zwracać typ void, możesz zgłaszać błędy w metody dostępu set, zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f62b5-141">Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.</span></span>

<span data-ttu-id="f62b5-142">Możesz rozszerzyć ten tej samej składni, aby wszystkie potrzebne w tym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-142">You can extend this same syntax to anything needed in your scenario.</span></span> <span data-ttu-id="f62b5-143">Możesz sprawdzić relacje między różnymi właściwościami lub przeprowadzić walidacji względem żadnych warunków zewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="f62b5-143">You can check the relationships between different properties, or validate against any external conditions.</span></span> <span data-ttu-id="f62b5-144">Dowolne, prawidłowe C# są prawidłowe w metoda dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-144">Any valid C# statements are valid in a property accessor.</span></span>

### <a name="read-only"></a><span data-ttu-id="f62b5-145">tylko do odczytu</span><span class="sxs-lookup"><span data-stu-id="f62b5-145">Read-only</span></span>

<span data-ttu-id="f62b5-146">Do tej pory wszystkie definicje właściwości przejrzanych są publiczne metody dostępu właściwości odczytu/zapisu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-146">Up to this point, all the property definitions you have seen are read/write properties with public accessors.</span></span> <span data-ttu-id="f62b5-147">To nie jedyne prawidłowe ułatwień dostępu dla właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-147">That's not the only valid accessibility for properties.</span></span>
<span data-ttu-id="f62b5-148">Można utworzyć właściwości tylko do odczytu, lub oferowanie różnej dostępności zestawu i pobieranie metod dostępu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-148">You can create read-only properties, or give different accessibility to the set and get accessors.</span></span> <span data-ttu-id="f62b5-149">Załóżmy, że Twoje `Person` klasy należy włączyć tylko zmiana wartości `FirstName` właściwości z innych metod w tej klasie.</span><span class="sxs-lookup"><span data-stu-id="f62b5-149">Suppose that your `Person` class should only enable changing the value of the `FirstName` property from other methods in that class.</span></span> <span data-ttu-id="f62b5-150">Można nadać metody dostępu set `private` ułatwień dostępu, zamiast `public`:</span><span class="sxs-lookup"><span data-stu-id="f62b5-150">You could give the set accessor `private` accessibility instead of `public`:</span></span>

[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]

<span data-ttu-id="f62b5-151">Teraz `FirstName` właściwości są dostępne z dowolnego kodu, ale można przypisać tylko z innym kodem `Person` klasy.</span><span class="sxs-lookup"><span data-stu-id="f62b5-151">Now, the `FirstName` property can be accessed from any code, but it can only be assigned from other code in the `Person` class.</span></span>

<span data-ttu-id="f62b5-152">Można dodać żadnych modyfikator dostępu ograniczające albo zestaw lub uzyskaj metod dostępu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-152">You can add any restrictive access modifier to either the set or get accessors.</span></span> <span data-ttu-id="f62b5-153">Wszelkie modyfikator dostępu, które można umieścić na poszczególne metody dostępu musi być bardziej ograniczone niż modyfikator dostępu dla definicji właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-153">Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.</span></span> <span data-ttu-id="f62b5-154">Powyżej jest legalna ponieważ `FirstName` właściwość `public`, ale metody dostępu set `private`.</span><span class="sxs-lookup"><span data-stu-id="f62b5-154">The above is legal because the `FirstName` property is `public`, but the set accessor is `private`.</span></span> <span data-ttu-id="f62b5-155">Nie można zadeklarować `private` właściwość o `public` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-155">You could not declare a `private` property with a `public` accessor.</span></span> <span data-ttu-id="f62b5-156">Deklaracje właściwości mogą być także zadeklarowane `protected`, `internal`, `protected internal`, lub nawet `private`.</span><span class="sxs-lookup"><span data-stu-id="f62b5-156">Property declarations can also be declared `protected`, `internal`, `protected internal`, or, even `private`.</span></span>

<span data-ttu-id="f62b5-157">Jest również dozwolone umieść modyfikator bardziej restrykcyjne na `get` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-157">It is also legal to place the more restrictive modifier on the `get` accessor.</span></span> <span data-ttu-id="f62b5-158">Na przykład można mieć `public` właściwości, ograniczając jednocześnie `get` metody dostępu `private`.</span><span class="sxs-lookup"><span data-stu-id="f62b5-158">For example, you could have a `public` property, but restrict the `get` accessor to `private`.</span></span> <span data-ttu-id="f62b5-159">Ten scenariusz rzadko odbywa się w praktyce.</span><span class="sxs-lookup"><span data-stu-id="f62b5-159">That scenario is rarely done in practice.</span></span>

<span data-ttu-id="f62b5-160">Można również ograniczyć modyfikacje właściwości, tak że można ustawić tylko w konstruktorze lub inicjatorze właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-160">You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.</span></span> <span data-ttu-id="f62b5-161">Możesz zmodyfikować `Person` klasy, więc w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="f62b5-161">You can modify the `Person` class so as follows:</span></span>

[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]

<span data-ttu-id="f62b5-162">Ta funkcja jest najczęściej używana do inicjowania kolekcji, które są widoczne jako właściwości tylko do odczytu:</span><span class="sxs-lookup"><span data-stu-id="f62b5-162">This feature is most commonly used for initializing collections that are exposed as read-only properties:</span></span>

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a><span data-ttu-id="f62b5-163">Obliczone właściwości</span><span class="sxs-lookup"><span data-stu-id="f62b5-163">Computed properties</span></span>

<span data-ttu-id="f62b5-164">Właściwość nie trzeba zwrócić wartość pola elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f62b5-164">A property does not need to simply return the value of a member field.</span></span> <span data-ttu-id="f62b5-165">Można utworzyć właściwości, które zwracają obliczoną wartością.</span><span class="sxs-lookup"><span data-stu-id="f62b5-165">You can create properties that return a computed value.</span></span> <span data-ttu-id="f62b5-166">Możemy rozwinąć `Person` obiekt do zwrotu pełną nazwę, obliczana przez złączenie imiona i nazwiska:</span><span class="sxs-lookup"><span data-stu-id="f62b5-166">Let's expand the `Person` object to return the full name, computed by concatenating the first and last names:</span></span>

[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]

<span data-ttu-id="f62b5-167">Przykład powyżej używa [Interpolacja ciągów](../csharp/language-reference/tokens/interpolated.md) funkcję, aby utworzyć sformatowany ciąg, aby uzyskać pełną nazwę.</span><span class="sxs-lookup"><span data-stu-id="f62b5-167">The example above uses the [string interpolation](../csharp/language-reference/tokens/interpolated.md) feature to create the formatted string for the full name.</span></span>

<span data-ttu-id="f62b5-168">Można również użyć *wyrażeniem składowej*, który zapewnia bardziej zwięzły sposób tworzenia obliczone `FullName` właściwości:</span><span class="sxs-lookup"><span data-stu-id="f62b5-168">You can also use an *expression-bodied member*, which provides a more succinct way to create the computed `FullName` property:</span></span>

[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]

<span data-ttu-id="f62b5-169">*Elementy członkowskie z wyrażeniem* użyj *wyrażenia lambda* Składnia służąca do definiowania metod, które zawierać pojedyncze wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="f62b5-169">*Expression-bodied members* use the *lambda expression* syntax to define methods that contain a single expression.</span></span> <span data-ttu-id="f62b5-170">W tym miejscu to wyrażenie zwraca pełną nazwę obiektu osoba.</span><span class="sxs-lookup"><span data-stu-id="f62b5-170">Here, that expression returns the full name for the person object.</span></span>

### <a name="cached-evaluated-properties"></a><span data-ttu-id="f62b5-171">Właściwości ocenianą pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="f62b5-171">Cached evaluated properties</span></span>

<span data-ttu-id="f62b5-172">Możesz mieszać koncepcji obliczona właściwość z magazynu i utworzyć *buforowane szacowanych*.</span><span class="sxs-lookup"><span data-stu-id="f62b5-172">You can mix the concept of a computed property with storage and create a *cached evaluated property*.</span></span>  <span data-ttu-id="f62b5-173">Na przykład, można zaktualizować `FullName` właściwość tak, aby tylko formatowanie ciągów wystąpiły po raz pierwszy uzyskano go:</span><span class="sxs-lookup"><span data-stu-id="f62b5-173">For example, you could update the `FullName` property so that the string formatting only happened the first time it was accessed:</span></span>

[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]

<span data-ttu-id="f62b5-174">Powyższy kod zawiera usterkę, mimo że.</span><span class="sxs-lookup"><span data-stu-id="f62b5-174">The above code contains a bug though.</span></span> <span data-ttu-id="f62b5-175">Jeśli kod aktualizuje wartość jednej `FirstName` lub `LastName` właściwość, wcześniej ocenianą `fullName` pole jest nieprawidłowe.</span><span class="sxs-lookup"><span data-stu-id="f62b5-175">If code updates the value of either the `FirstName` or `LastName` property, the previously evaluated `fullName` field is invalid.</span></span> <span data-ttu-id="f62b5-176">Możesz zmodyfikować `set` metod dostępu `FirstName` i `LastName` właściwość tak, aby `fullName` pole jest obliczane ponownie:</span><span class="sxs-lookup"><span data-stu-id="f62b5-176">You modify the `set` accessors of the `FirstName` and `LastName` property so that the `fullName` field is calculated again:</span></span>

[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]

<span data-ttu-id="f62b5-177">Daje w wyniku tej wersji ostatecznej `FullName` właściwości tylko wtedy, gdy jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="f62b5-177">This final version evaluates the `FullName` property only when needed.</span></span>
<span data-ttu-id="f62b5-178">Jeśli poprzednio obliczonej wersji jest prawidłowy, jest używany.</span><span class="sxs-lookup"><span data-stu-id="f62b5-178">If the previously calculated version is valid, it's used.</span></span> <span data-ttu-id="f62b5-179">Jeśli inna zmiana stanu unieważnia wcześniej obliczeniowe wersji, zostaną obliczone go ponownie.</span><span class="sxs-lookup"><span data-stu-id="f62b5-179">If another state change invalidates the previously calculated version, it will be recalculated.</span></span> <span data-ttu-id="f62b5-180">Deweloperzy korzystający z tej klasy nie trzeba wiedzieć, szczegółowe informacje o implementacji.</span><span class="sxs-lookup"><span data-stu-id="f62b5-180">Developers that use this class do not need to know the details of the implementation.</span></span> <span data-ttu-id="f62b5-181">Żadna z tych wewnętrznych zmian wpływa na korzystanie z obiektu osoby.</span><span class="sxs-lookup"><span data-stu-id="f62b5-181">None of these internal changes affect the use of the Person object.</span></span> <span data-ttu-id="f62b5-182">To jest powód klucza do używania właściwości do udostępnienia danych elementów członkowskich obiektu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-182">That's the key reason for using Properties to expose data members of an object.</span></span>

### <a name="attaching-attributes-to-auto-implemented-properties"></a><span data-ttu-id="f62b5-183">Trwa dołączanie atrybutów, które mają automatycznie implementowanych właściwości</span><span class="sxs-lookup"><span data-stu-id="f62b5-183">Attaching attributes to auto-implemented properties</span></span>

<span data-ttu-id="f62b5-184">Począwszy od C# 7.3, atrybuty pól mogą być dołączane do pola pomocniczego wygenerowanego przez kompilator automatycznie implementowane właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-184">Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.</span></span> <span data-ttu-id="f62b5-185">Na przykład, należy wziąć pod uwagę poprawkę do `Person` klasę, która dodaje całkowitą liczbą unikatowych `Id` właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-185">For example, consider a revision to the `Person` class that adds a unique integer `Id` property.</span></span>
<span data-ttu-id="f62b5-186">Piszesz`Id` właściwości przy użyciu automatycznie implementowanych właściwości, ale projekt, nie wywołuje potrzeby utrwalania `Id` właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-186">You write the`Id` property using an auto-implemented property, but your design does not call for persisting the `Id` property.</span></span> <span data-ttu-id="f62b5-187"><xref:System.NonSerializedAttribute> Mogą być dołączane tylko do pól, a nie właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-187">The <xref:System.NonSerializedAttribute> can only be attached to fields, not properties.</span></span> <span data-ttu-id="f62b5-188">Możesz dołączyć <xref:System.NonSerializedAttribute> na pole zapasowe dla `Id` właściwości przy użyciu `field:` Specyfikator atrybutu, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="f62b5-188">You can attach the <xref:System.NonSerializedAttribute> to the backing field for the `Id` property by using the `field:` specifier on the attribute, as shown in the following example:</span></span>

[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]

<span data-ttu-id="f62b5-189">Ta metoda działa w przypadku każdego atrybutu, który można dołączyć do pola pomocniczego na automatycznie implementowane właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-189">This technique works for any attribute you attach to the backing field on the auto-implemented property.</span></span>

### <a name="implementing-inotifypropertychanged"></a><span data-ttu-id="f62b5-190">Implementing INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="f62b5-190">Implementing INotifyPropertyChanged</span></span>

<span data-ttu-id="f62b5-191">Końcowe scenariusz, w których trzeba napisać kod w metodzie dostępu właściwości służy do obsługi <xref:System.ComponentModel.INotifyPropertyChanged> interfejs używany do powiadamiania klientów powiązania danych, których wartość została zmieniona.</span><span class="sxs-lookup"><span data-stu-id="f62b5-191">A final scenario where you need to write code in a property accessor is to support the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding clients that a value has changed.</span></span> <span data-ttu-id="f62b5-192">Po zmianie wartości właściwości, wywołuje obiekt <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> zdarzenie, aby wskazać zmianę.</span><span class="sxs-lookup"><span data-stu-id="f62b5-192">When the value of a property changes, the object raises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> event to indicate the change.</span></span> <span data-ttu-id="f62b5-193">Dane, tworzenie powiązań bibliotek, z kolei zaktualizować wyświetlanych elementów w oparciu o zmiany.</span><span class="sxs-lookup"><span data-stu-id="f62b5-193">The data binding libraries, in turn, update display elements based on that change.</span></span> <span data-ttu-id="f62b5-194">Poniższy kod pokazuje, jak możesz również zaimplementować `INotifyPropertyChanged` dla `FirstName` właściwości tej klasy osoby.</span><span class="sxs-lookup"><span data-stu-id="f62b5-194">The code below shows how you would implement `INotifyPropertyChanged` for the `FirstName` property of this person class.</span></span>

[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]

<span data-ttu-id="f62b5-195">`?.` Operator jest nazywany *operatora warunkowego wartości null*.</span><span class="sxs-lookup"><span data-stu-id="f62b5-195">The `?.` operator is called the *null conditional operator*.</span></span> <span data-ttu-id="f62b5-196">Sprawdza odwołanie o wartości null ewaluacją po prawej stronie operatora.</span><span class="sxs-lookup"><span data-stu-id="f62b5-196">It checks for a null reference before evaluating the right side of the operator.</span></span> <span data-ttu-id="f62b5-197">Wynik końcowy jest to, że w przypadku subskrybentów do `PropertyChanged` zdarzeń, kod, aby wygenerować zdarzenie nie jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="f62b5-197">The end result is that if there are no subscribers to the `PropertyChanged` event, the code to raise the event doesn't execute.</span></span> <span data-ttu-id="f62b5-198">Będzie ona zgłaszają `NullReferenceException` bez to sprawdzać w takiej sytuacji.</span><span class="sxs-lookup"><span data-stu-id="f62b5-198">It would throw a `NullReferenceException` without this check in that case.</span></span> <span data-ttu-id="f62b5-199">Aby uzyskać więcej informacji, zobacz [`events`](delegates-events.md).</span><span class="sxs-lookup"><span data-stu-id="f62b5-199">For more information, see [`events`](delegates-events.md).</span></span> <span data-ttu-id="f62b5-200">W tym przykładzie użyto również nowe `nameof` operatora konwersji z symboli nazwy właściwości na jego reprezentację tekstową.</span><span class="sxs-lookup"><span data-stu-id="f62b5-200">This example also uses the new `nameof` operator to convert from the property name symbol to its text representation.</span></span>
<span data-ttu-id="f62b5-201">Za pomocą `nameof` można zmniejszyć liczbę błędów, w którym błędnie wpisano nazwę właściwości.</span><span class="sxs-lookup"><span data-stu-id="f62b5-201">Using `nameof` can reduce errors where you have mistyped the name of the property.</span></span>

<span data-ttu-id="f62b5-202">Implementowanie ponownie <xref:System.ComponentModel.INotifyPropertyChanged> jest przykładem przypadek, w którym można wpisać kod w swojej metody dostępu na potrzeby scenariuszy należy.</span><span class="sxs-lookup"><span data-stu-id="f62b5-202">Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an example of a case where you can write code in your accessors to support the scenarios you need.</span></span>

## <a name="summing-up"></a><span data-ttu-id="f62b5-203">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="f62b5-203">Summing up</span></span>

<span data-ttu-id="f62b5-204">Właściwości są formą inteligentne pola w klasie lub obiektu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-204">Properties are a form of smart fields in a class or object.</span></span> <span data-ttu-id="f62b5-205">Z poza nim, są wyświetlane takie jak pola obiektu.</span><span class="sxs-lookup"><span data-stu-id="f62b5-205">From outside the object, they appear like fields in the object.</span></span> <span data-ttu-id="f62b5-206">Jednak właściwości można zaimplementować przy użyciu pełnej paletę C# funkcji.</span><span class="sxs-lookup"><span data-stu-id="f62b5-206">However, properties can be implemented using the full palette of C# functionality.</span></span>
<span data-ttu-id="f62b5-207">Możesz podać sprawdzania poprawności, różnej dostępności, obliczanie z opóźnieniem lub wszelkie wymagania potrzebnych dla swoich scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="f62b5-207">You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.</span></span>
