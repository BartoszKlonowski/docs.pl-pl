---
title: Dopasowanie wzoru - Przewodnik C#
description: 'Dowiedz się więcej o wyrażeniach dopasowywania wzorców w języku C #'
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: bb6baf3771024d02b2027f81fd35b8be4872cf6e
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249236"
---
# <a name="pattern-matching"></a><span data-ttu-id="fd13c-103">Dopasowanie wzorca</span><span class="sxs-lookup"><span data-stu-id="fd13c-103">Pattern Matching</span></span>

<span data-ttu-id="fd13c-104">Wzorce testują, czy wartość ma określony *kształt*i mogą *wyodrębniać* informacje z wartości, gdy ma pasujący kształt.</span><span class="sxs-lookup"><span data-stu-id="fd13c-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="fd13c-105">Dopasowywanie wzorców zapewnia bardziej zwięzłą składnię dla algorytmów, które są już używane dzisiaj.</span><span class="sxs-lookup"><span data-stu-id="fd13c-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="fd13c-106">Algorytmy dopasowywania wzorców są już tworzą przy użyciu istniejącej składni.</span><span class="sxs-lookup"><span data-stu-id="fd13c-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="fd13c-107">Piszesz `if` `switch` lub instrukcje, które testują wartości.</span><span class="sxs-lookup"><span data-stu-id="fd13c-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="fd13c-108">Następnie, gdy te instrukcje są zgodne, wyodrębnić i użyć informacji z tej wartości.</span><span class="sxs-lookup"><span data-stu-id="fd13c-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="fd13c-109">Nowe elementy składni są rozszerzeniami instrukcji, które znasz `is` `switch`już: i .</span><span class="sxs-lookup"><span data-stu-id="fd13c-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="fd13c-110">Te nowe rozszerzenia łączą testowanie wartości i wyodrębnianie tych informacji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="fd13c-111">W tym artykule przyjrzymy się nowej składni, aby pokazać, jak umożliwia czytelny, zwięzły kod.</span><span class="sxs-lookup"><span data-stu-id="fd13c-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="fd13c-112">Dopasowywanie wzorców umożliwia idiomy, w których dane i kod są oddzielone, w przeciwieństwie do projektów obiektowych, w których dane i metody, które nimi manipulują, są ściśle powiązane.</span><span class="sxs-lookup"><span data-stu-id="fd13c-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="fd13c-113">Aby zilustrować te nowe idiomy, pracujmy ze strukturami reprezentującymi kształty geometryczne przy użyciu instrukcji dopasowywania szyku.</span><span class="sxs-lookup"><span data-stu-id="fd13c-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="fd13c-114">Prawdopodobnie znasz hierarchie klas i tworzenie [metod wirtualnych i zastąpione metody](methods.md#inherited) dostosowywania zachowania obiektu na podstawie typu środowiska wykonawczego obiektu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="fd13c-115">Te techniki nie są możliwe dla danych, które nie są zorganizowane w hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="fd13c-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="fd13c-116">Gdy dane i metody są oddzielne, potrzebne są inne narzędzia.</span><span class="sxs-lookup"><span data-stu-id="fd13c-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="fd13c-117">Nowe konstrukcje *dopasowywania wzorców* umożliwiają czystsze składni do badania danych i manipulowania przepływem sterowania na podstawie dowolnego warunku tych danych.</span><span class="sxs-lookup"><span data-stu-id="fd13c-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="fd13c-118">Już piszesz `if` `switch` instrukcje i testuje wartość zmiennej.</span><span class="sxs-lookup"><span data-stu-id="fd13c-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="fd13c-119">Piszesz `is` instrukcje, które testują typ zmiennej.</span><span class="sxs-lookup"><span data-stu-id="fd13c-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="fd13c-120">*Dopasowanie wzorca* dodaje nowe możliwości do tych instrukcji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="fd13c-121">W tym artykule zostanie zbudowana metoda obliczania obszaru o różnych kształtach geometrycznych.</span><span class="sxs-lookup"><span data-stu-id="fd13c-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="fd13c-122">Ale zrobisz to bez uciekania się do technik obiektowych i tworzenia hierarchii klas dla różnych kształtów.</span><span class="sxs-lookup"><span data-stu-id="fd13c-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="fd13c-123">Zamiast tego użyjesz *dopasowania wzorca.*</span><span class="sxs-lookup"><span data-stu-id="fd13c-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="fd13c-124">Podczas przechodzenia przez ten przykład, kontrast ten kod z jak będzie on zorganizowany jako hierarchii obiektów.</span><span class="sxs-lookup"><span data-stu-id="fd13c-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="fd13c-125">Gdy dane, które należy zbadać i manipulować nie jest hierarchią klas, dopasowywanie wzorców umożliwia eleganckie projekty.</span><span class="sxs-lookup"><span data-stu-id="fd13c-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="fd13c-126">Zamiast zaczynać od abstrakcyjnej definicji kształtu i dodawać różne określone klasy kształtów, zacznijmy od prostych definicji tylko danych dla każdego z kształtów geometrycznych:</span><span class="sxs-lookup"><span data-stu-id="fd13c-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="fd13c-127">Z tych struktur napiszmy metodę, która oblicza obszar pewnego kształtu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="fd13c-128">Wyrażenie `is` wzorca typu</span><span class="sxs-lookup"><span data-stu-id="fd13c-128">The `is` type pattern expression</span></span>

<span data-ttu-id="fd13c-129">Przed C# 7.0, należy przetestować każdy typ `if` w `is` serii i instrukcji:</span><span class="sxs-lookup"><span data-stu-id="fd13c-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="fd13c-130">Ten kod powyżej jest klasycznym *wyrażeniem wzorca typu:* Testujesz zmienną, aby określić jej typ i podejmujesz inną akcję na podstawie tego typu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="fd13c-131">Ten kod staje się prostszy przy użyciu rozszerzeń do wyrażenia, `is` aby przypisać zmienną, jeśli test zakończy się pomyślnie:</span><span class="sxs-lookup"><span data-stu-id="fd13c-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="fd13c-132">W tej zaktualizowanej `is` wersji wyrażenie testuje zmienną i przypisuje ją do nowej zmiennej odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="fd13c-133">Należy również zauważyć, że `Rectangle` ta wersja `struct`zawiera typ, który jest .</span><span class="sxs-lookup"><span data-stu-id="fd13c-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="fd13c-134">Nowe `is` wyrażenie działa z typami wartości, a także typami odwołań.</span><span class="sxs-lookup"><span data-stu-id="fd13c-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="fd13c-135">Reguły języka dla wyrażeń dopasowywania wzorców pomagają uniknąć nadużywania wyników wyrażenia dopasowania.</span><span class="sxs-lookup"><span data-stu-id="fd13c-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="fd13c-136">W powyższym przykładzie `s`zmienne `c` `r` , i są tylko w zakresie i zdecydowanie `true` przypisane, gdy odpowiednie wyrażenia dopasowania wzorca mają wyniki.</span><span class="sxs-lookup"><span data-stu-id="fd13c-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="fd13c-137">Jeśli spróbujesz użyć jednej zmiennej w innej lokalizacji, kod generuje błędy kompilatora.</span><span class="sxs-lookup"><span data-stu-id="fd13c-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="fd13c-138">Przeanalizujmy obie te reguły szczegółowo, począwszy od zakresu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="fd13c-139">Zmienna `c` jest w zakresie `else` tylko w `if` gałęzi pierwszej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="fd13c-140">Zmienna `s` jest w zakresie `ComputeAreaModernIs`w metodzie .</span><span class="sxs-lookup"><span data-stu-id="fd13c-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="fd13c-141">Dzieje się tak, ponieważ `if` każda gałąź instrukcji ustanawia oddzielny zakres dla zmiennych.</span><span class="sxs-lookup"><span data-stu-id="fd13c-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="fd13c-142">Jednak sama `if` instrukcja nie.</span><span class="sxs-lookup"><span data-stu-id="fd13c-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="fd13c-143">Oznacza to, że `if` zmienne zadeklarowane w `if` instrukcji znajdują się w tym samym zakresie co instrukcja (metoda w tym przypadku). To zachowanie nie jest specyficzne dla dopasowania wzorca, ale `if` jest `else` zdefiniowane zachowanie dla zakresów zmiennych i instrukcji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="fd13c-144">Zmienne `c` i `s` są przypisywane, `if` gdy odpowiednie instrukcje są prawdziwe ze względu na zdecydowanie przypisany, gdy true mechanizmu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="fd13c-145">Przykłady w tym temacie używają zalecanej `is` konstrukcji, w której wyrażenie `true` dopasowania wzorca zdecydowanie przypisuje zmienną dopasowania w gałęzi `if` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="fd13c-146">Można odwrócić logikę, mówiąc, `if (!(shape is Square s))` a zmienna `s` będzie `false` zdecydowanie przypisany tylko w gałęzi.</span><span class="sxs-lookup"><span data-stu-id="fd13c-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="fd13c-147">Chociaż jest to prawidłowe C#, nie jest zalecane, ponieważ jest bardziej mylące, aby postępować zgodnie z logiką.</span><span class="sxs-lookup"><span data-stu-id="fd13c-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="fd13c-148">Te reguły oznaczają, że jest mało prawdopodobne, aby przypadkowo uzyskać dostęp do wyniku wyrażenia dopasowania wzorca, gdy ten wzorzec nie został spełniony.</span><span class="sxs-lookup"><span data-stu-id="fd13c-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="fd13c-149">Używanie instrukcji `switch` dopasowywania wzorców</span><span class="sxs-lookup"><span data-stu-id="fd13c-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="fd13c-150">W miarę upływu czasu może być konieczne obsługiwanie innych typów kształtów.</span><span class="sxs-lookup"><span data-stu-id="fd13c-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="fd13c-151">Wraz ze wzrostem liczby testujących warunków, okaże się, `is` że używanie wyrażeń dopasowywania wzorców może stać się uciążliwe.</span><span class="sxs-lookup"><span data-stu-id="fd13c-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="fd13c-152">Oprócz wymagania `if` instrukcji dla każdego typu, który `is` chcesz sprawdzić, wyrażenia są ograniczone do testowania, jeśli dane wejściowe pasuje do jednego typu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="fd13c-153">W takim przypadku okaże się, `switch` że wyrażenia dopasowania wzorca staje się lepszym wyborem.</span><span class="sxs-lookup"><span data-stu-id="fd13c-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="fd13c-154">Tradycyjna `switch` instrukcja była wyrażeniem wzorca: obsługiwała stały wzorzec.</span><span class="sxs-lookup"><span data-stu-id="fd13c-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="fd13c-155">Można porównać zmienną z dowolną `case` stałą używaną w instrukcji:</span><span class="sxs-lookup"><span data-stu-id="fd13c-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="fd13c-156">Jedynym wzorcem obsługiwanym przez instrukcję `switch` był stały wzorzec.</span><span class="sxs-lookup"><span data-stu-id="fd13c-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="fd13c-157">Ponadto był ograniczony do typów `string` liczbowych i typu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="fd13c-158">Te ograniczenia zostały usunięte i można teraz `switch` napisać instrukcję przy użyciu wzorca typu:</span><span class="sxs-lookup"><span data-stu-id="fd13c-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="fd13c-159">Instrukcja `switch` dopasowywania wzorców używa znanej składni dla deweloperów, którzy używali tradycyjnej instrukcji w stylu `switch` C.</span><span class="sxs-lookup"><span data-stu-id="fd13c-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="fd13c-160">Każdy `case` jest oceniany i kod poniżej warunku, który pasuje do zmiennej wejściowej jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="fd13c-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="fd13c-161">Wykonanie kodu nie może "przepaść" z jednego wyrażenia sprawy do następnego; składnia `case` instrukcji wymaga, aby `case` każdy koniec `break` `return`z `goto`, , lub .</span><span class="sxs-lookup"><span data-stu-id="fd13c-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="fd13c-162">Instrukcje, `goto` aby przejść do innej etykiety są prawidłowe tylko dla wzorca stałego (instrukcja classic switch).</span><span class="sxs-lookup"><span data-stu-id="fd13c-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="fd13c-163">Istnieją ważne nowe zasady `switch` regulujące oświadczenie.</span><span class="sxs-lookup"><span data-stu-id="fd13c-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="fd13c-164">Ograniczenia dotyczące typu zmiennej w `switch` wyrażeniu zostały usunięte.</span><span class="sxs-lookup"><span data-stu-id="fd13c-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="fd13c-165">Każdy typ, `object` takich jak w tym przykładzie, mogą być używane.</span><span class="sxs-lookup"><span data-stu-id="fd13c-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="fd13c-166">Wyrażenia sprawy nie są już ograniczone do wartości stałych.</span><span class="sxs-lookup"><span data-stu-id="fd13c-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="fd13c-167">Usunięcie tego ograniczenia oznacza, że `switch` zmiana kolejności sekcji może zmienić zachowanie programu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="fd13c-168">Gdy jest ograniczona do wartości `case` stałych, nie więcej `switch` niż jedna etykieta może odpowiadać wartości wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="fd13c-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="fd13c-169">Połącz to z `switch` regułą, że każda sekcja nie może przechodzić do następnej sekcji, a następnie, że `switch` sekcje mogą być zmieniane w dowolnej kolejności bez wpływu na zachowanie.</span><span class="sxs-lookup"><span data-stu-id="fd13c-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="fd13c-170">Teraz, z bardziej `switch` uogólnionymi wyrażeniami, liczy się kolejność każdej sekcji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="fd13c-171">Wyrażenia `switch` są oceniane w kolejności tekstowej.</span><span class="sxs-lookup"><span data-stu-id="fd13c-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="fd13c-172">Wykonanie przenosi się `switch` do pierwszej `switch` etykiety, która pasuje do wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="fd13c-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="fd13c-173">Sprawa `default` zostanie wykonana tylko wtedy, gdy żadne inne etykiety przypadków nie są zgodne.</span><span class="sxs-lookup"><span data-stu-id="fd13c-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="fd13c-174">Sprawa `default` jest oceniana jako ostatnia, niezależnie od kolejności tekstowej.</span><span class="sxs-lookup"><span data-stu-id="fd13c-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="fd13c-175">Jeśli nie ma `default` przypadku, a żadna z innych `case` instrukcji dopasowania, `switch` wykonanie jest kontynuowane w instrukcji po instrukcji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="fd13c-176">Żaden z `case` kodów etykiet nie jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="fd13c-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="fd13c-177">`when`klauzule `case` w wyrażeniach</span><span class="sxs-lookup"><span data-stu-id="fd13c-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="fd13c-178">Dla tych kształtów, które mają obszar 0, `when` można `case` tworzyć specjalne przypadki, używając klauzuli na etykiecie.</span><span class="sxs-lookup"><span data-stu-id="fd13c-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="fd13c-179">Kwadrat o długości bocznej 0 lub okrąg o promieniu 0 ma obszar 0.</span><span class="sxs-lookup"><span data-stu-id="fd13c-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="fd13c-180">Można określić ten `when` warunek `case` przy użyciu klauzuli na etykiecie:</span><span class="sxs-lookup"><span data-stu-id="fd13c-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="fd13c-181">Ta zmiana pokazuje kilka ważnych punktów dotyczących nowej składni.</span><span class="sxs-lookup"><span data-stu-id="fd13c-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="fd13c-182">Po pierwsze, wiele `case` etykiet można `switch` zastosować do jednej sekcji.</span><span class="sxs-lookup"><span data-stu-id="fd13c-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="fd13c-183">Blok instrukcji jest wykonywany, gdy `true`którykolwiek z tych etykiet jest .</span><span class="sxs-lookup"><span data-stu-id="fd13c-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="fd13c-184">W tym przypadku, `switch` jeśli wyrażenie jest okrąg lub kwadrat z 0 obszar, metoda zwraca stałą 0.</span><span class="sxs-lookup"><span data-stu-id="fd13c-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="fd13c-185">W tym przykładzie wprowadzono dwie `case` różne zmienne `switch` w dwóch etykiet dla pierwszego bloku.</span><span class="sxs-lookup"><span data-stu-id="fd13c-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="fd13c-186">Należy zauważyć, że `switch` instrukcje w tym bloku `c` nie używają zmiennych `s` (dla okręgu) lub (dla kwadratu).</span><span class="sxs-lookup"><span data-stu-id="fd13c-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="fd13c-187">Żadna z tych zmiennych nie `switch` jest zdecydowanie przypisana w tym bloku.</span><span class="sxs-lookup"><span data-stu-id="fd13c-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="fd13c-188">Jeśli którykolwiek z tych przypadków są zgodne, wyraźnie jedna ze zmiennych została przypisana.</span><span class="sxs-lookup"><span data-stu-id="fd13c-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="fd13c-189">Jednak nie można stwierdzić, *który* został przypisany w czasie kompilacji, ponieważ każdy przypadek może być zgodny w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="fd13c-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="fd13c-190">Z tego powodu w większości `case` razy, gdy używasz wielu etykiet dla tego `case` samego bloku, nie wprowadzisz nowej `when` zmiennej w instrukcji lub użyjesz tylko zmiennej w klauzuli.</span><span class="sxs-lookup"><span data-stu-id="fd13c-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="fd13c-191">Po dodaniu tych kształtów o obszarze 0 dodajmy jeszcze kilka typów kształtów: prostokąt i trójkąt:</span><span class="sxs-lookup"><span data-stu-id="fd13c-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="fd13c-192">Ten zestaw zmian `case` dodaje etykiety dla zdegenerowanych przypadków oraz etykiety i bloki dla każdego z nowych kształtów.</span><span class="sxs-lookup"><span data-stu-id="fd13c-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="fd13c-193">Na koniec możesz dodać `null` sprawę, aby upewnić `null`się, że argument nie jest:</span><span class="sxs-lookup"><span data-stu-id="fd13c-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="fd13c-194">Specjalne zachowanie `null` dla wzorca jest `null` interesujące, ponieważ stała we wzorcu nie ma typu, ale może być konwertowana na dowolny typ odwołania lub typ wartości nullable.</span><span class="sxs-lookup"><span data-stu-id="fd13c-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="fd13c-195">Zamiast konwertować a `null` do dowolnego typu, `null` język definiuje, że wartość nie będzie pasować do wzorca typu, niezależnie od typu skompilowania zmiennej.</span><span class="sxs-lookup"><span data-stu-id="fd13c-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="fd13c-196">To zachowanie sprawia, że `switch` nowy `is` wzorzec typu opartego jest zgodny z instrukcją: `is` instrukcje zawsze zwracają, `false` gdy sprawdzana wartość jest `null`.</span><span class="sxs-lookup"><span data-stu-id="fd13c-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="fd13c-197">Jest to również prostsze: po sprawdzeniu typu nie trzeba dodatkowego sprawdzania wartości null.</span><span class="sxs-lookup"><span data-stu-id="fd13c-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="fd13c-198">Widać, że z faktu, że nie ma żadnych null kontroli w każdym z bloków sprawy powyżej: nie są one konieczne, ponieważ dopasowanie wzorca typu gwarantuje wartość inną niż null.</span><span class="sxs-lookup"><span data-stu-id="fd13c-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="fd13c-199">`var`deklaracje `case` w wyrażeniach</span><span class="sxs-lookup"><span data-stu-id="fd13c-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="fd13c-200">Wprowadzenie `var` jako jedno z wyrażeń dopasowania wprowadza nowe reguły do dopasowania wzorca.</span><span class="sxs-lookup"><span data-stu-id="fd13c-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="fd13c-201">Pierwsza reguła jest, że deklaracja `var` jest zgodna z regułami wnioskowania o typie normalnym: Typ jest wywnioskowany jako typ statyczny wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="fd13c-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="fd13c-202">Z tej reguły typ zawsze pasuje.</span><span class="sxs-lookup"><span data-stu-id="fd13c-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="fd13c-203">Druga reguła jest, że deklaracja `var` nie ma null sprawdzić, że inne wyrażenia wzorca typu obejmują.</span><span class="sxs-lookup"><span data-stu-id="fd13c-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="fd13c-204">Oznacza to, że zmienna może mieć wartość null, a w takim przypadku konieczne jest sprawdzenie wartości null.</span><span class="sxs-lookup"><span data-stu-id="fd13c-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="fd13c-205">Te dwie reguły oznaczają, że `var` w `case` wielu przypadkach deklaracja `default` w wyrażeniu spełnia te same warunki co wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="fd13c-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="fd13c-206">Ponieważ każda sprawa nie domyślna `default` jest `default` preferowana w przypadku, sprawa nigdy nie zostanie wykonana.</span><span class="sxs-lookup"><span data-stu-id="fd13c-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="fd13c-207">Kompilator nie emituje ostrzeżenie w `default` tych przypadkach, gdy sprawa została napisana, ale nigdy nie zostanie wykonana.</span><span class="sxs-lookup"><span data-stu-id="fd13c-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="fd13c-208">Jest to zgodne `switch` z bieżącym zachowaniem instrukcji, w którym wymieniono wszystkie możliwe przypadki.</span><span class="sxs-lookup"><span data-stu-id="fd13c-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="fd13c-209">Trzecia reguła wprowadza zastosowania, `var` w których przypadek może być przydatny.</span><span class="sxs-lookup"><span data-stu-id="fd13c-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="fd13c-210">Wyobraź sobie, że robisz dopasowanie wzorca, gdzie dane wejściowe jest ciągiem i szukasz znanych wartości poleceń.</span><span class="sxs-lookup"><span data-stu-id="fd13c-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="fd13c-211">Możesz napisać coś takiego:</span><span class="sxs-lookup"><span data-stu-id="fd13c-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="fd13c-212">Przypadek `var` jest `null`zgodny, pusty ciąg lub dowolny ciąg, który zawiera tylko biały znak.</span><span class="sxs-lookup"><span data-stu-id="fd13c-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="fd13c-213">Należy zauważyć, że poprzedni `?.` kod używa operatora, aby upewnić <xref:System.NullReferenceException>się, że nie przypadkowo zgłosić .</span><span class="sxs-lookup"><span data-stu-id="fd13c-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="fd13c-214">Sprawa `default` obsługuje wszelkie inne wartości ciągu, które nie są zrozumiałe przez tego parsera polecenia.</span><span class="sxs-lookup"><span data-stu-id="fd13c-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="fd13c-215">Jest to jeden z przykładów, `var` w którym można `default` rozważyć wyrażenie sprawy, które różni się od wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="fd13c-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="fd13c-216">Wnioski</span><span class="sxs-lookup"><span data-stu-id="fd13c-216">Conclusions</span></span>

<span data-ttu-id="fd13c-217">*Konstrukcje dopasowywania wzorców* umożliwiają łatwe zarządzanie przepływem sterowania między różnymi zmiennymi i typami, które nie są powiązane z hierarchią dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="fd13c-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="fd13c-218">Można również kontrolować logikę, aby użyć dowolnego warunku testowego na zmiennej.</span><span class="sxs-lookup"><span data-stu-id="fd13c-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="fd13c-219">Umożliwia wzorce i idiomy, które będą potrzebne częściej podczas tworzenia większej liczby aplikacji rozproszonych, gdzie dane i metody, które manipulują tymi danymi są oddzielne.</span><span class="sxs-lookup"><span data-stu-id="fd13c-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="fd13c-220">Można zauważyć, że struktury kształtu używane w tym przykładzie nie zawierają żadnych metod, tylko właściwości tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="fd13c-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="fd13c-221">Dopasowanie wzorca działa z dowolnym typem danych.</span><span class="sxs-lookup"><span data-stu-id="fd13c-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="fd13c-222">Piszesz wyrażenia, które badają obiekt i podejmujesz decyzje przepływu sterowania na podstawie tych warunków.</span><span class="sxs-lookup"><span data-stu-id="fd13c-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="fd13c-223">Porównaj kod z tego przykładu z projektem, który wynika `Shape` z tworzenia hierarchii klas dla abstrakcyjnych i specyficznych kształtów pochodnych, z których każdy ma własną implementację metody wirtualnej do obliczania obszaru.</span><span class="sxs-lookup"><span data-stu-id="fd13c-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="fd13c-224">Często okaże się, że wyrażenia dopasowywania wzorców może być bardzo przydatne narzędzie podczas pracy z danymi i chcesz oddzielić obawy dotyczące magazynu danych od problemów zachowania.</span><span class="sxs-lookup"><span data-stu-id="fd13c-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="fd13c-225">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="fd13c-225">See also</span></span>

- [<span data-ttu-id="fd13c-226">Samouczek: Rozszerzanie typów danych za pomocą funkcji dopasowywania wzorców</span><span class="sxs-lookup"><span data-stu-id="fd13c-226">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
