---
title: Dopasowanie wzorca — Przewodnik C#
description: 'Informacje na temat wyrażeń dopasowania wzorców w języku C #'
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: aabd8afe9a94022557275adb313ca3bf95da7548
ms.sourcegitcommit: b4a46f6d7ebf44c0035627d00924164bcae2db30
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/29/2020
ms.locfileid: "91438025"
---
# <a name="pattern-matching"></a><span data-ttu-id="f5011-103">Dopasowanie wzorca</span><span class="sxs-lookup"><span data-stu-id="f5011-103">Pattern Matching</span></span>

<span data-ttu-id="f5011-104">Wzorzec testuje, że wartość ma określony *kształt*i może *wyodrębnić* informacje z wartości, gdy ma pasujący kształt.</span><span class="sxs-lookup"><span data-stu-id="f5011-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="f5011-105">Dopasowanie wzorca zawiera bardziej zwięzłą składnię dla algorytmów, które już dzisiaj używały.</span><span class="sxs-lookup"><span data-stu-id="f5011-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="f5011-106">Można już tworzyć algorytmy dopasowywania wzorców przy użyciu istniejącej składni.</span><span class="sxs-lookup"><span data-stu-id="f5011-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="f5011-107">Należy napisać `if` lub `switch` instrukcji, które są wartościami testowymi.</span><span class="sxs-lookup"><span data-stu-id="f5011-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="f5011-108">Następnie, gdy te instrukcje są zgodne, wyodrębnisz i użyjesz informacji z tej wartości.</span><span class="sxs-lookup"><span data-stu-id="f5011-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="f5011-109">Nowe elementy składni są rozszerzeniami do instrukcji, które są już znane: `is` i `switch` .</span><span class="sxs-lookup"><span data-stu-id="f5011-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="f5011-110">Te nowe rozszerzenia łączą testowanie wartości i wyodrębniają te informacje.</span><span class="sxs-lookup"><span data-stu-id="f5011-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="f5011-111">W tym artykule poznasz nową składnię, aby pokazać, jak to umożliwia czytelny, zwięzły kod.</span><span class="sxs-lookup"><span data-stu-id="f5011-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="f5011-112">Dopasowywanie wzorców umożliwia idiomy, w których dane i kod są oddzielane, w przeciwieństwie do projektów zorientowanych obiektowo, w przypadku których dane i metody manipulowania nimi są ściśle sprzężone.</span><span class="sxs-lookup"><span data-stu-id="f5011-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="f5011-113">Aby zilustrować te nowe idiomy, przyjrzyjmy się strukturom, które reprezentują kształty geometryczne przy użyciu instrukcji dopasowania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="f5011-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="f5011-114">Prawdopodobnie wiesz już, jak tworzyć hierarchie klas i tworzyć [metody wirtualne i zastąpione metody,](methods.md#inherited) aby dostosować zachowanie obiektów na podstawie typu środowiska uruchomieniowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="f5011-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="f5011-115">Te techniki nie są możliwe w przypadku danych, które nie są strukturalne w hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="f5011-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="f5011-116">Gdy dane i metody są oddzielone, potrzebne są inne narzędzia.</span><span class="sxs-lookup"><span data-stu-id="f5011-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="f5011-117">Nowe konstrukcje *dopasowania wzorców* umożliwiają oczyszczarkę składnię do badania danych i manipulowania przepływem sterowania na podstawie dowolnego warunku tych danych.</span><span class="sxs-lookup"><span data-stu-id="f5011-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="f5011-118">Należy już napisać `if` instrukcje i `switch` przetestować wartość zmiennej.</span><span class="sxs-lookup"><span data-stu-id="f5011-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="f5011-119">Należy napisać `is` instrukcje, które testują typ zmiennej.</span><span class="sxs-lookup"><span data-stu-id="f5011-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="f5011-120">*Dopasowanie wzorca* dodaje nowe możliwości do tych instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f5011-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="f5011-121">W tym artykule utworzysz metodę, która oblicza obszar różnych kształtów geometrycznych.</span><span class="sxs-lookup"><span data-stu-id="f5011-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="f5011-122">Jednak należy to zrobić bez konieczności wykonywania technik zorientowanych obiektowo i tworzenia hierarchii klas dla różnych kształtów.</span><span class="sxs-lookup"><span data-stu-id="f5011-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="f5011-123">Zamiast tego użyjesz *dopasowania do wzorca* .</span><span class="sxs-lookup"><span data-stu-id="f5011-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="f5011-124">Korzystając z tego przykładu, należy pokontraście ten kod, tak aby był on strukturalny jako hierarchia obiektów.</span><span class="sxs-lookup"><span data-stu-id="f5011-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="f5011-125">Gdy dane, które należy wykonać podczas wykonywania zapytania i manipulowania, nie są hierarchią klas, dopasowanie wzorców umożliwia tworzenie eleganckich projektów.</span><span class="sxs-lookup"><span data-stu-id="f5011-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="f5011-126">Zamiast rozpoczynać się od definicji kształtu abstrakcyjnego i dodawać różne klasy kształtów, zacznijmy zamiast od prostych definicji zawierających tylko dane dla każdego z kształtów geometrycznych:</span><span class="sxs-lookup"><span data-stu-id="f5011-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="f5011-127">Z tych struktur Napiszmy metodę, która oblicza obszar pewnego kształtu.</span><span class="sxs-lookup"><span data-stu-id="f5011-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="f5011-128">`is`Wyrażenie wzorca typu</span><span class="sxs-lookup"><span data-stu-id="f5011-128">The `is` type pattern expression</span></span>

<span data-ttu-id="f5011-129">Przed C# 7,0 należy przetestować każdy typ w szeregu `if` i `is` instrukcjach:</span><span class="sxs-lookup"><span data-stu-id="f5011-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="f5011-130">Ten kod powyżej jest wyrażeniem klasycznym *wzorca typu*: testujesz zmienną, aby określić jej typ i wykonując inną akcję na podstawie tego typu.</span><span class="sxs-lookup"><span data-stu-id="f5011-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="f5011-131">Ten kod będzie prostszy przy użyciu rozszerzeń do `is` wyrażenia, aby przypisać zmienną, jeśli test zakończy się pomyślnie:</span><span class="sxs-lookup"><span data-stu-id="f5011-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="f5011-132">W tej zaktualizowanej wersji `is` wyrażenie testuje zmienną i przypisze ją do nowej zmiennej odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="f5011-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="f5011-133">Należy również zauważyć, że ta wersja zawiera `Rectangle` Typ, który jest `struct` .</span><span class="sxs-lookup"><span data-stu-id="f5011-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="f5011-134">Nowe `is` wyrażenie działa z typami wartości, a także typami referencyjnymi.</span><span class="sxs-lookup"><span data-stu-id="f5011-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="f5011-135">Reguły języka dla wyrażeń dopasowania wzorców pomagają uniknąć nieprawidłowych wyników wyrażenia dopasowania.</span><span class="sxs-lookup"><span data-stu-id="f5011-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="f5011-136">W powyższym przykładzie zmienne `s` , `c` , i `r` są tylko w zakresie i ostatecznie przypisane, gdy odpowiednie wyrażenia dopasowania wzorców mają `true` wyniki.</span><span class="sxs-lookup"><span data-stu-id="f5011-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="f5011-137">Jeśli spróbujesz użyć dowolnej zmiennej w innej lokalizacji, kod generuje błędy kompilatora.</span><span class="sxs-lookup"><span data-stu-id="f5011-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="f5011-138">Sprawdźmy szczegóły obu tych reguł, rozpoczynając od zakresu.</span><span class="sxs-lookup"><span data-stu-id="f5011-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="f5011-139">Zmienna `c` znajduje się w zakresie tylko w `else` gałęzi pierwszej `if` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f5011-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="f5011-140">Zmienna `s` jest w zakresie w metodzie `ComputeAreaModernIs` .</span><span class="sxs-lookup"><span data-stu-id="f5011-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="f5011-141">Jest tak dlatego, że każda gałąź `if` instrukcji tworzy oddzielny zakres dla zmiennych.</span><span class="sxs-lookup"><span data-stu-id="f5011-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="f5011-142">Jednak `if` sama instrukcja nie jest.</span><span class="sxs-lookup"><span data-stu-id="f5011-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="f5011-143">Oznacza to, że zmienne zadeklarowane w `if` instrukcji znajdują się w tym samym zakresie co `if` instrukcja (metoda w tym przypadku).</span><span class="sxs-lookup"><span data-stu-id="f5011-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case).</span></span> <span data-ttu-id="f5011-144">To zachowanie nie jest specyficzne dla dopasowania do wzorca, ale jest zachowaniem zdefiniowanym dla zakresów zmiennych i `if` `else` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f5011-144">This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="f5011-145">Zmienne `c` i `s` są przypisywane, gdy odpowiednie `if` instrukcje są prawdziwe ze względu na to, że jest on w nieskończony sposób przypisany do rzeczywistego mechanizmu.</span><span class="sxs-lookup"><span data-stu-id="f5011-145">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="f5011-146">Przykłady w tym temacie wykorzystują zalecaną konstrukcję, w której wyrażenie dopasowania do wzorca `is` ostatecznie przypisuje zmienną Match w `true` gałęzi `if` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f5011-146">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="f5011-147">Można wycofać logikę, wypowiadając `if (!(shape is Square s))` , a zmienna `s` może być ostatecznie przypisana tylko w `false` gałęzi.</span><span class="sxs-lookup"><span data-stu-id="f5011-147">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="f5011-148">Chociaż jest to prawidłowy język C#, nie jest to zalecane, ponieważ jest bardziej trudne do przestrzegania logiki.</span><span class="sxs-lookup"><span data-stu-id="f5011-148">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="f5011-149">Te reguły oznaczają, że nie jest możliwe przypadkowe uzyskanie dostępu do wyniku wyrażenia dopasowania do wzorca, gdy ten wzorzec nie został spełniony.</span><span class="sxs-lookup"><span data-stu-id="f5011-149">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="f5011-150">Używanie instrukcji dopasowania wzorca `switch`</span><span class="sxs-lookup"><span data-stu-id="f5011-150">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="f5011-151">Gdy przejdzie czas, może być konieczne obsługę innych typów kształtów.</span><span class="sxs-lookup"><span data-stu-id="f5011-151">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="f5011-152">W miarę zwiększania się liczby testowanych warunków można się dowiedzieć, że użycie `is` wyrażeń dopasowania wzorców może stać się nieskomplikowany.</span><span class="sxs-lookup"><span data-stu-id="f5011-152">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="f5011-153">Oprócz wymagania `if` instrukcji dla każdego typu, który chcesz sprawdzić, `is` wyrażenia są ograniczone do testowania, jeśli dane wejściowe są zgodne z pojedynczym typem.</span><span class="sxs-lookup"><span data-stu-id="f5011-153">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="f5011-154">W tym przypadku zobaczysz, że `switch` wyrażenia dopasowania wzorców staną się lepszym wyborem.</span><span class="sxs-lookup"><span data-stu-id="f5011-154">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="f5011-155">Tradycyjna `switch` instrukcja była wyrażeniem wzorca: obsługuje stałe wzorce.</span><span class="sxs-lookup"><span data-stu-id="f5011-155">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="f5011-156">Można porównać zmienną z dowolną stałą używaną w `case` instrukcji:</span><span class="sxs-lookup"><span data-stu-id="f5011-156">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="f5011-157">Jedyny wzorzec obsługiwany przez `switch` instrukcję był wzorcem stałym.</span><span class="sxs-lookup"><span data-stu-id="f5011-157">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="f5011-158">Jest ona bardziej ograniczona do typów liczbowych i `string` typu.</span><span class="sxs-lookup"><span data-stu-id="f5011-158">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="f5011-159">Te ograniczenia zostały usunięte i można teraz napisać `switch` instrukcję przy użyciu wzorca typu:</span><span class="sxs-lookup"><span data-stu-id="f5011-159">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="f5011-160">W instrukcji dopasowania wzorca `switch` używana jest znana składnia dla deweloperów, którzy używali tradycyjnej `switch` instrukcji języka C.</span><span class="sxs-lookup"><span data-stu-id="f5011-160">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="f5011-161">Każdy `case` z nich jest obliczany, a kod pod warunkiem, który jest zgodny z zmienną wejściową jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="f5011-161">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="f5011-162">Wykonanie kodu nie może "przechodzenie" z jednego wyrażenia case do następnego; Składnia `case` instrukcji wymaga, aby każde `case` zakończenie z `break` , `return` lub `goto` .</span><span class="sxs-lookup"><span data-stu-id="f5011-162">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="f5011-163">`goto`Instrukcje do przeskoczenia do innej etykiety są prawidłowe tylko dla wzorca stałej (instrukcji switch klasycznego).</span><span class="sxs-lookup"><span data-stu-id="f5011-163">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="f5011-164">Istnieją ważne nowe zasady dotyczące zasad `switch` .</span><span class="sxs-lookup"><span data-stu-id="f5011-164">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="f5011-165">Ograniczenia dotyczące typu zmiennej w `switch` wyrażeniu zostały usunięte.</span><span class="sxs-lookup"><span data-stu-id="f5011-165">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="f5011-166">Można użyć dowolnego typu, takiego jak `object` w tym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f5011-166">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="f5011-167">Wyrażenia case nie są już ograniczone do wartości stałych.</span><span class="sxs-lookup"><span data-stu-id="f5011-167">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="f5011-168">Usunięcie tego ograniczenia oznacza, że zmiany kolejności `switch` w sekcjach mogą zmienić zachowanie programu.</span><span class="sxs-lookup"><span data-stu-id="f5011-168">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="f5011-169">Gdy są ograniczone do wartości stałych, nie więcej niż jedna `case` etykieta może pasować do wartości `switch` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="f5011-169">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="f5011-170">Połącz ten element z regułą, która `switch` nie może przechodzić do kolejnej sekcji, a następnie `switch` Przemieść sekcje w dowolnej kolejności bez wpływu na zachowanie.</span><span class="sxs-lookup"><span data-stu-id="f5011-170">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="f5011-171">Teraz, w przypadku bardziej uogólnionych `switch` wyrażeń, kolejność każdej sekcji jest ważna.</span><span class="sxs-lookup"><span data-stu-id="f5011-171">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="f5011-172">`switch`Wyrażenia są oceniane w kolejności tekstowej.</span><span class="sxs-lookup"><span data-stu-id="f5011-172">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="f5011-173">Wykonanie przenosi do pierwszej `switch` etykiety, która pasuje do `switch` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="f5011-173">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="f5011-174">`default`Przypadek zostanie wykonany tylko wtedy, gdy żadne inne etykiety case nie pasują do siebie.</span><span class="sxs-lookup"><span data-stu-id="f5011-174">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="f5011-175">`default`Wielkość liter jest szacowana jako Ostatnia, niezależnie od ich kolejności tekstu.</span><span class="sxs-lookup"><span data-stu-id="f5011-175">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="f5011-176">Jeśli nie ma żadnego `default` przypadku, a żadna z innych instrukcji nie jest `case` zgodna, wykonanie kontynuuje się w instrukcji następującej po `switch` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f5011-176">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="f5011-177">Żaden z `case` kodów etykiet nie jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="f5011-177">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="f5011-178">`when` klauzule w `case` wyrażeniach</span><span class="sxs-lookup"><span data-stu-id="f5011-178">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="f5011-179">Można tworzyć specjalne przypadki dla tych kształtów, które mają 0 obszarów, używając `when` klauzuli na `case` etykiecie.</span><span class="sxs-lookup"><span data-stu-id="f5011-179">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="f5011-180">Kwadrat o długości bocznej 0 lub Okręg o promieniu 0 ma powierzchnię 0.</span><span class="sxs-lookup"><span data-stu-id="f5011-180">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="f5011-181">Należy określić warunek przy użyciu `when` klauzuli na `case` etykiecie:</span><span class="sxs-lookup"><span data-stu-id="f5011-181">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="f5011-182">Ta zmiana pokazuje kilka ważnych punktów dotyczących nowej składni.</span><span class="sxs-lookup"><span data-stu-id="f5011-182">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="f5011-183">Najpierw `case` można zastosować wiele etykiet do jednej `switch` sekcji.</span><span class="sxs-lookup"><span data-stu-id="f5011-183">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="f5011-184">Blok instrukcji jest wykonywany, gdy dowolna z tych etykiet jest `true` .</span><span class="sxs-lookup"><span data-stu-id="f5011-184">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="f5011-185">W tym przypadku, jeśli `switch` wyrażenie jest okrąg lub kwadrat z 0 obszaru, metoda zwraca stałą 0.</span><span class="sxs-lookup"><span data-stu-id="f5011-185">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="f5011-186">W tym przykładzie wprowadzono dwie różne zmienne w dwóch `case` etykietach dla pierwszego `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="f5011-186">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="f5011-187">Zauważ, że instrukcje w tym `switch` bloku nie używają zmiennych `c` (dla okręgu) lub `s` (dla kwadratu).</span><span class="sxs-lookup"><span data-stu-id="f5011-187">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="f5011-188">Żadna z tych zmiennych nie jest ostatecznie przypisana w tym `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="f5011-188">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="f5011-189">Jeśli jeden z tych przypadków jest zgodny, wyraźnie jedna ze zmiennych została przypisana.</span><span class="sxs-lookup"><span data-stu-id="f5011-189">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="f5011-190">Nie jest jednak możliwe informowanie, *które* zostało przypisane w czasie kompilacji, ponieważ każdy przypadek może być zgodny w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="f5011-190">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="f5011-191">Z tego powodu najczęściej w przypadku używania wielu `case` etykiet dla tego samego bloku nie zostanie wprowadzona nowa zmienna w `case` instrukcji lub w klauzuli zostanie użyta tylko zmienna `when` .</span><span class="sxs-lookup"><span data-stu-id="f5011-191">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="f5011-192">Po dodaniu tych kształtów w obszarze 0 Dodajmy kilka typów kształtów: prostokąt i Trójkąt:</span><span class="sxs-lookup"><span data-stu-id="f5011-192">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="f5011-193">Ten zestaw zmian dodaje `case` etykiety dla przypadku wygenerowania i etykiety i bloki dla każdego nowego kształtu.</span><span class="sxs-lookup"><span data-stu-id="f5011-193">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="f5011-194">Na koniec możesz dodać przypadek, `null` Aby upewnić się, że argument nie jest `null` :</span><span class="sxs-lookup"><span data-stu-id="f5011-194">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="f5011-195">Specjalne zachowanie `null` wzorca jest interesujące, ponieważ stała `null` w wzorcu nie ma typu, ale można ją przekonwertować na dowolny typ referencyjny lub typ wartości null.</span><span class="sxs-lookup"><span data-stu-id="f5011-195">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="f5011-196">Zamiast konwersji `null` do dowolnego typu, język definiuje, że `null` wartość nie będzie zgodna ze wzorcem typu, niezależnie od typu czasu kompilacji zmiennej.</span><span class="sxs-lookup"><span data-stu-id="f5011-196">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="f5011-197">To zachowanie powoduje, że nowy `switch` wzorzec typu opartego na typie jest spójny z `is` instrukcją: `is` instrukcje zawsze zwracają, `false` gdy sprawdzana wartość jest `null` .</span><span class="sxs-lookup"><span data-stu-id="f5011-197">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="f5011-198">Jest również prostsze: po sprawdzeniu typu nie jest wymagane dodatkowe sprawdzenie wartości null.</span><span class="sxs-lookup"><span data-stu-id="f5011-198">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="f5011-199">Można sprawdzić, czy nie ma żadnych testów null w żadnym z bloków Case powyższych przykładów: nie jest to konieczne, ponieważ dopasowanie wzorca typu gwarantuje wartość różną od null.</span><span class="sxs-lookup"><span data-stu-id="f5011-199">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="f5011-200">`var` deklaracje w `case` wyrażeniach</span><span class="sxs-lookup"><span data-stu-id="f5011-200">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="f5011-201">Wprowadzenie `var` jako jednego z wyrażeń dopasowania wprowadza nowe reguły do dopasowania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="f5011-201">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="f5011-202">Pierwsza reguła polega na tym, że `var` Deklaracja jest zgodna z regułami wnioskowania o typie normalnym: typ jest wywnioskowany jako typ statyczny wyrażenia Switch.</span><span class="sxs-lookup"><span data-stu-id="f5011-202">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="f5011-203">W tej regule typ zawsze jest zgodny.</span><span class="sxs-lookup"><span data-stu-id="f5011-203">From that rule, the type always matches.</span></span>

<span data-ttu-id="f5011-204">Druga reguła polega na tym, że `var` Deklaracja nie ma sprawdzenia wartości null, która zawiera inne wyrażenia wzorca typu.</span><span class="sxs-lookup"><span data-stu-id="f5011-204">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="f5011-205">Oznacza to, że zmienna może mieć wartość null, a w takim przypadku konieczne jest sprawdzenie wartości null.</span><span class="sxs-lookup"><span data-stu-id="f5011-205">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="f5011-206">Te dwie reguły oznaczają, że w wielu przypadkach `var` Deklaracja w `case` wyrażeniu dopasowuje te same warunki co `default` wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="f5011-206">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="f5011-207">Ponieważ każdy przypadek inny niż domyślny jest preferowany w `default` przypadku, `default` przypadek nigdy nie zostanie wykonany.</span><span class="sxs-lookup"><span data-stu-id="f5011-207">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="f5011-208">Kompilator nie emituje ostrzeżenia w przypadkach, gdy `default` sprawa została zapisywana, ale nigdy nie zostanie wykonana.</span><span class="sxs-lookup"><span data-stu-id="f5011-208">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="f5011-209">Jest to zgodne z obecnym `switch` zachowaniem instrukcji w przypadku, gdy wszystkie możliwe przypadki zostały wymienione.</span><span class="sxs-lookup"><span data-stu-id="f5011-209">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="f5011-210">Trzecia reguła wprowadza użycie w przypadku, gdy `var` może być przydatne w przypadku.</span><span class="sxs-lookup"><span data-stu-id="f5011-210">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="f5011-211">Załóżmy, że wykonujesz dopasowanie do wzorca, gdzie dane wejściowe są ciągiem i wyszukujesz znane wartości poleceń.</span><span class="sxs-lookup"><span data-stu-id="f5011-211">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="f5011-212">Można napisać coś takiego jak:</span><span class="sxs-lookup"><span data-stu-id="f5011-212">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="f5011-213">`var`Wielkość liter jest zgodna z `null` ciągiem pustym lub dowolnym ciągiem zawierającym tylko biały znak.</span><span class="sxs-lookup"><span data-stu-id="f5011-213">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="f5011-214">Zwróć uwagę, że poprzedni kod używa `?.` operatora, aby upewnić się, że nie zgłosi przypadkowo <xref:System.NullReferenceException> .</span><span class="sxs-lookup"><span data-stu-id="f5011-214">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="f5011-215">`default`Przypadek obsługuje wszelkie inne wartości ciągów, które nie są zrozumiałe dla tego analizatora poleceń.</span><span class="sxs-lookup"><span data-stu-id="f5011-215">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="f5011-216">Jest to jeden przykład, w którym warto rozważyć `var` wyrażenie CASE, które różni się od `default` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="f5011-216">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="f5011-217">Wnioski</span><span class="sxs-lookup"><span data-stu-id="f5011-217">Conclusions</span></span>

<span data-ttu-id="f5011-218">*Konstrukcje dopasowania wzorców* umożliwiają łatwe zarządzanie przepływem sterowania między różnymi zmiennymi i typami, które nie są powiązane z hierarchią dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="f5011-218">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="f5011-219">Możesz również sterować logiką, aby używać dowolnego warunku, który można testować na zmiennej.</span><span class="sxs-lookup"><span data-stu-id="f5011-219">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="f5011-220">Umożliwia ona wzorce i idiomy, które będą potrzebne częściej, podczas tworzenia bardziej rozproszonych aplikacji, w przypadku których dane i metody manipulowania nimi są osobne.</span><span class="sxs-lookup"><span data-stu-id="f5011-220">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="f5011-221">Zauważ, że struktury kształtu używane w tym przykładzie nie zawierają żadnych metod, tylko właściwości tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="f5011-221">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="f5011-222">Dopasowanie wzorca współdziała z dowolnym typem danych.</span><span class="sxs-lookup"><span data-stu-id="f5011-222">Pattern Matching works with any data type.</span></span> <span data-ttu-id="f5011-223">Można pisać wyrażenia, które badają obiekt, i podejmować decyzje dotyczące przepływu sterowania na podstawie tych warunków.</span><span class="sxs-lookup"><span data-stu-id="f5011-223">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="f5011-224">Porównaj kod z tego przykładu z projektem, który byłby następujący po utworzeniu hierarchii klas dla abstrakcyjnych `Shape` i specyficznych kształtów pochodnych z własnym implementacją metody wirtualnej w celu obliczenia obszaru.</span><span class="sxs-lookup"><span data-stu-id="f5011-224">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="f5011-225">Często należy zauważyć, że wyrażenia dopasowania wzorców mogą być bardzo użytecznym narzędziem podczas pracy z danymi i chcą oddzielić problemy związane z przechowywaniem danych od problemów z zachowaniem.</span><span class="sxs-lookup"><span data-stu-id="f5011-225">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="f5011-226">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f5011-226">See also</span></span>

- [<span data-ttu-id="f5011-227">Samouczek: używanie dopasowania wzorców do tworzenia algorytmów opartych na typach i danych</span><span class="sxs-lookup"><span data-stu-id="f5011-227">Tutorial: Use pattern matching to build type-driven and data-driven algorithms</span></span>](tutorials/pattern-matching.md)
