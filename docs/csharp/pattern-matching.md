---
title: Dopasowywanie wzorców — przewodnik po językach C#
description: 'Dowiedz się więcej o wyrażeniach dopasowywania wzorców w c #'
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 0c302499543c90bd01427e2791435968d580f644
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79170387"
---
# <a name="pattern-matching"></a><span data-ttu-id="9ca7b-103">Dopasowanie wzorca</span><span class="sxs-lookup"><span data-stu-id="9ca7b-103">Pattern Matching</span></span>

<span data-ttu-id="9ca7b-104">Wzorce testują, że wartość ma określony *kształt*i może *wyodrębnić* informacje z wartości, gdy ma pasujący kształt.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="9ca7b-105">Dopasowanie wzorców zapewnia bardziej zwięzłą składnię dla algorytmów, których już używasz dzisiaj.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="9ca7b-106">Algorytmy dopasowywania wzorców są już tworzone przy użyciu istniejącej składni.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="9ca7b-107">`if` Piszesz `switch` lub instrukcje, które testują wartości.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="9ca7b-108">Następnie, gdy te instrukcje są zgodne, wyodrębnić i używać informacji z tej wartości.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="9ca7b-109">Nowe elementy składni są rozszerzeniami instrukcji, które `is` już `switch`znasz: i .</span><span class="sxs-lookup"><span data-stu-id="9ca7b-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="9ca7b-110">Te nowe rozszerzenia łączą testowanie wartości i wyodrębnianie tych informacji.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="9ca7b-111">W tym artykule przyjrzymy się nowej składni, aby pokazać, jak umożliwia czytelny, zwięzły kod.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="9ca7b-112">Dopasowywanie wzorców umożliwia idiomy, w których dane i kod są oddzielone, w przeciwieństwie do projektów obiektowych, w których dane i metody, które nimi manipulują, są ściśle powiązane.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="9ca7b-113">Aby zilustrować te nowe idiomy, pracujmy ze strukturami reprezentującymi kształty geometryczne przy użyciu instrukcji dopasowywania wzorców.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="9ca7b-114">Prawdopodobnie znasz hierarchie klas i tworzenie [metod wirtualnych i przesłoniętych metod](methods.md#inherited) dostosowywania zachowania obiektu na podstawie typu środowiska uruchomieniowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="9ca7b-115">Te techniki nie są możliwe dla danych, które nie są zorganizowane w hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="9ca7b-116">Gdy dane i metody są oddzielne, potrzebne są inne narzędzia.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="9ca7b-117">Nowe konstrukcje *dopasowywania wzorców* umożliwiają czystsze składni do zbadania danych i manipulować przepływem sterowania na podstawie dowolnego warunku tych danych.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="9ca7b-118">Już `if` piszesz `switch` instrukcje i że test wartości zmiennej.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="9ca7b-119">Piszesz `is` instrukcje, które testują typ zmiennej.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="9ca7b-120">*Dopasowanie wzorca* dodaje nowe możliwości do tych instrukcji.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="9ca7b-121">W tym artykule stworzysz metodę, która oblicza obszar różnych kształtów geometrycznych.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="9ca7b-122">Ale zrobisz to bez uciekania się do technik obiektowych i budowania hierarchii klas dla różnych kształtów.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="9ca7b-123">Zamiast tego *użyjesz dopasowania wzorców.*</span><span class="sxs-lookup"><span data-stu-id="9ca7b-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="9ca7b-124">Podczas przechodzenia przez ten przykład, kontrast ten kod z jak będzie zorganizowany jako hierarchii obiektów.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="9ca7b-125">Gdy dane, które należy zbadać i manipulować nie jest hierarchii klas, dopasowanie wzorca umożliwia eleganckie projekty.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="9ca7b-126">Zamiast zaczynać od abstrakcyjnej definicji kształtu i dodawać różne klasy kształtów, zacznijmy od prostych definicji danych tylko dla każdego z kształtów geometrycznych:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="9ca7b-127">Z tych struktur napiszmy metodę, która oblicza obszar pewnego kształtu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="9ca7b-128">Wyrażenie `is` wzorca typu</span><span class="sxs-lookup"><span data-stu-id="9ca7b-128">The `is` type pattern expression</span></span>

<span data-ttu-id="9ca7b-129">Przed C# 7.0, należy przetestować każdy typ `if` w `is` serii i instrukcje:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="9ca7b-130">Ten powyższy kod jest klasycznym wyrażeniem *wzorca typu:* Testujesz zmienną, aby określić jej typ i podjąć inną akcję na podstawie tego typu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="9ca7b-131">Ten kod staje się prostszy `is` przy użyciu rozszerzeń do wyrażenia, aby przypisać zmienną, jeśli test zakończy się pomyślnie:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="9ca7b-132">W tej zaktualizowanej `is` wersji wyrażenie testuje zmienną i przypisuje ją do nowej zmiennej właściwego typu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="9ca7b-133">Należy również zauważyć, że `Rectangle` ta wersja `struct`zawiera typ, który jest .</span><span class="sxs-lookup"><span data-stu-id="9ca7b-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="9ca7b-134">Nowe `is` wyrażenie działa z typami wartości, a także typami odwołań.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="9ca7b-135">Reguły języka dla wyrażeń dopasowywania wzorców ułatwiają unikanie nadużywania wyników wyrażenia dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="9ca7b-136">W powyższym przykładzie zmienne `s` `c`, `r` i są tylko w zakresie i zdecydowanie przypisane, `true` gdy odpowiednie wyrażenia dopasowania wzorca mają wyniki.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="9ca7b-137">Jeśli spróbujesz użyć jednej ze zmiennych w innej lokalizacji, kod generuje błędy kompilatora.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="9ca7b-138">Przeanalizujmy szczegółowo obie te reguły, zaczynając od zakresu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="9ca7b-139">Zmienna `c` znajduje się w `else` zakresie tylko `if` w gałęzi pierwszej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="9ca7b-140">Zmienna `s` znajduje się w `ComputeAreaModernIs`zakresie w metodzie .</span><span class="sxs-lookup"><span data-stu-id="9ca7b-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="9ca7b-141">Dzieje się tak, ponieważ `if` każda gałąź instrukcji ustanawia osobny zakres zmiennych.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="9ca7b-142">Jednak samo `if` stwierdzenie nie.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="9ca7b-143">Oznacza to, że `if` zmienne zadeklarowane w instrukcji `if` znajdują się w tym samym zakresie co instrukcja (metoda w tym przypadku). To zachowanie nie jest specyficzne dla dopasowania wzorca, ale jest `if` `else` zdefiniowane zachowanie dla zmiennych zakresów i instrukcji.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="9ca7b-144">Zmienne `c` i `s` są przypisane, gdy `if` odpowiednie instrukcje są prawdziwe ze względu na zdecydowanie przypisane, gdy mechanizm true.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="9ca7b-145">Przykłady w tym temacie użyć zalecanej konstrukcji, gdzie wyrażenie dopasowania `is` wzorca zdecydowanie przypisuje zmienną dopasowania w `true` gałęzi `if` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="9ca7b-146">Można odwrócić logikę, `if (!(shape is Square s))` mówiąc, `s` a zmienna będzie `false` zdecydowanie przypisana tylko w gałęzi.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="9ca7b-147">Chociaż jest to prawidłowy C#, nie jest zalecane, ponieważ jest bardziej mylące, aby postępować zgodnie z logiką.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="9ca7b-148">Te reguły oznaczają, że jest mało prawdopodobne, aby przypadkowo uzyskać dostęp do wyniku wyrażenia dopasowania wzorca, gdy ten wzorzec nie został spełniony.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="9ca7b-149">Korzystanie z `switch` instrukcji dopasowywania wzorców</span><span class="sxs-lookup"><span data-stu-id="9ca7b-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="9ca7b-150">W miarę upływu czasu może być konieczne wsparcie innych typów kształtów.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="9ca7b-151">Wraz ze wzrostem liczby testów, które testujesz, `is` przekonasz się, że użycie wyrażenia pasującego do wzorca może stać się kłopotliwe.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="9ca7b-152">Oprócz wymagających `if` instrukcji dla każdego typu, który `is` chcesz sprawdzić, wyrażenia są ograniczone do testowania, jeśli dane wejściowe pasuje do pojedynczego typu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="9ca7b-153">W takim przypadku przekonasz `switch` się, że wyrażenia pasujące do wzorca stają się lepszym wyborem.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="9ca7b-154">Tradycyjna `switch` instrukcja była wyrażeniewzorcem: obsługiwała wzorzec stały.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="9ca7b-155">Można porównać zmienną z dowolną `case` stałą używaną w instrukcji:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="9ca7b-156">Jedynym wzorcem obsługiwanym `switch` przez instrukcję był stały wzorzec.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="9ca7b-157">Był on ponadto ograniczony do `string` typów liczbowych i typu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="9ca7b-158">Te ograniczenia zostały usunięte, a teraz `switch` można napisać instrukcję przy użyciu wzorca typu:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="9ca7b-159">Instrukcja `switch` dopasowania wzorca używa znanej składni deweloperom, `switch` którzy używali tradycyjnej instrukcji w stylu C.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="9ca7b-160">Każdy `case` jest oceniany, a kod poniżej warunku, który pasuje do zmiennej wejściowej jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="9ca7b-161">Wykonanie kodu nie może "wpaść" z jednego wyrażenia sprawy do następnego; `case` składnia instrukcji wymaga, aby `case` każdy `break`koniec `return`z `goto`, lub .</span><span class="sxs-lookup"><span data-stu-id="9ca7b-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="9ca7b-162">Instrukcje, `goto` aby przejść do innej etykiety są prawidłowe tylko dla wzorca stałego (instrukcja przełącznika klasycznego).</span><span class="sxs-lookup"><span data-stu-id="9ca7b-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="9ca7b-163">Istnieją ważne nowe zasady `switch` regulujące oświadczenie.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="9ca7b-164">Ograniczenia dotyczące typu zmiennej w `switch` wyrażeniu zostały usunięte.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="9ca7b-165">Można użyć dowolnego `object` typu, takiego jak w tym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="9ca7b-166">Wyrażenia przypadków nie są już ograniczone do wartości stałych.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="9ca7b-167">Usunięcie tego ograniczenia oznacza, `switch` że zmiana kolejności sekcji może zmienić zachowanie programu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="9ca7b-168">Gdy ograniczone do wartości stałych, `case` nie więcej niż `switch` jedna etykieta może odpowiadać wartości wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="9ca7b-169">Połącz to z `switch` regułą, że każda sekcja nie może przechodzić do następnej sekcji, a następnie, że `switch` sekcje mogą być rozmieszczone w dowolnej kolejności bez wpływu na zachowanie.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="9ca7b-170">Teraz, z bardziej `switch` uogólnionym wyrażeniami, kolejność każdej sekcji ma znaczenie.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="9ca7b-171">Wyrażenia `switch` są obliczane w kolejności tekstowej.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="9ca7b-172">Wykonywanie przenosi do `switch` pierwszej `switch` etykiety, która pasuje do wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="9ca7b-173">Sprawa `default` zostanie wykonana tylko wtedy, gdy nie są zgodne żadne inne etykiety przypadków.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="9ca7b-174">Sprawa `default` jest oceniana jako ostatnia, niezależnie od kolejności tekstowej.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="9ca7b-175">Jeśli nie ma `default` żadnego przypadku i `case` żadna z pozostałych instrukcji nie `switch` jest zgodna, wykonanie jest kontynuowane w instrukcji następującej po instrukcji.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="9ca7b-176">Żaden z `case` etykiet kod jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="9ca7b-177">`when`klauzule `case` w wyrażeniach</span><span class="sxs-lookup"><span data-stu-id="9ca7b-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="9ca7b-178">Można tworzyć specjalne przypadki dla tych kształtów, `when` które mają `case` obszar 0, używając klauzuli na etykiecie.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="9ca7b-179">Kwadrat o długości bocznej 0 lub okrąg o promieniu 0 ma obszar 0.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="9ca7b-180">Należy określić ten `when` warunek `case` przy użyciu klauzuli na etykiecie:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="9ca7b-181">Ta zmiana pokazuje kilka ważnych punktów dotyczących nowej składni.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="9ca7b-182">Najpierw można `case` zastosować wiele etykiet `switch` do jednej sekcji.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="9ca7b-183">Blok instrukcji jest wykonywany, gdy `true`dowolna z tych etykiet jest .</span><span class="sxs-lookup"><span data-stu-id="9ca7b-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="9ca7b-184">W tym przypadku `switch` jeśli wyrażenie jest okrąg lub kwadrat z obszaru 0, metoda zwraca stałą 0.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="9ca7b-185">W tym przykładzie przedstawiono dwie różne `case` zmienne w `switch` dwóch etykietach dla pierwszego bloku.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="9ca7b-186">Należy zauważyć, że `switch` instrukcje w tym bloku `c` nie używają zmiennych `s` (dla okręgu) lub (dla kwadratu).</span><span class="sxs-lookup"><span data-stu-id="9ca7b-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="9ca7b-187">Żadna z tych zmiennych nie jest `switch` zdecydowanie przypisana w tym bloku.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="9ca7b-188">Jeśli którykolwiek z tych przypadków są zgodne, wyraźnie jedna ze zmiennych została przypisana.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="9ca7b-189">Jednak nie można powiedzieć, *który* został przypisany w czasie kompilacji, ponieważ w obu przypadkach może być dopasowywany w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="9ca7b-190">Z tego powodu większość razy, `case` gdy używasz wielu etykiet dla tego samego bloku, `case` nie będzie wprowadzać nową zmienną `when` w instrukcji lub będzie używać tylko zmiennej w klauzuli.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="9ca7b-191">Po dodaniu tych kształtów z obszarem 0 dodajmy jeszcze kilka typów kształtów: prostokąt i trójkąt:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="9ca7b-192">Ten zestaw zmian `case` dodaje etykiety dla zdegenerowanego przypadku oraz etykiety i bloki dla każdego z nowych kształtów.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="9ca7b-193">Na koniec można `null` dodać sprawę, aby upewnić `null`się, że argument nie jest:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="9ca7b-194">Specjalne zachowanie wzorca `null` jest interesujące, `null` ponieważ stała we wzorcu nie ma typu, ale można przekonwertować na dowolny typ odwołania lub typ nullable.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="9ca7b-195">Zamiast konwertować `null` na dowolny typ, język `null` definiuje, że wartość nie będzie zgodna z żadnym wzorcem typu, niezależnie od typu kompilacji zmiennej.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="9ca7b-196">To zachowanie sprawia, że nowy `switch` `is` wzorzec typu na podstawie zgodne z instrukcją: `is` instrukcje zawsze zwracają, `false` gdy sprawdzana wartość jest `null`.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="9ca7b-197">Jest to również prostsze: po sprawdzeniu typu nie potrzebujesz dodatkowego sprawdzania wartości null.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="9ca7b-198">Widać, że z faktu, że nie ma żadnych kontroli null w każdym z bloków sprawy poszczególnych przykładów: nie są one konieczne, ponieważ dopasowanie wzorca typu gwarantuje wartość nienull.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="9ca7b-199">`var`deklaracje `case` w wyrażeniach</span><span class="sxs-lookup"><span data-stu-id="9ca7b-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="9ca7b-200">Wprowadzenie `var` jako jedno z wyrażeń dopasowania wprowadza nowe reguły do dopasowania wzorca.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="9ca7b-201">Pierwsza reguła jest, że `var` deklaracja jest zgodna z regułami wnioskowania normalnego typu: Typ jest wywnioskować, aby być statyczny typ wyrażenia przełącznika.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="9ca7b-202">Z tej reguły typ zawsze pasuje.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="9ca7b-203">Druga reguła jest, że `var` deklaracja nie ma sprawdzania wartości null, które zawierają inne wyrażenia wzorca typu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="9ca7b-204">Oznacza to, że zmienna może mieć wartość null, a w takim przypadku konieczne jest sprawdzenie zerowe.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="9ca7b-205">Te dwie reguły oznaczają, że `var` w wielu `case` przypadkach deklaracja w `default` wyrażeniu odpowiada tym samym warunkom co wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="9ca7b-206">Ponieważ każda sprawa niedomyślna `default` jest preferowana w przypadku, `default` sprawa nigdy nie zostanie wykonana.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="9ca7b-207">Kompilator nie emituje ostrzeżenie w tych `default` przypadkach, gdy sprawa została napisana, ale nigdy nie zostanie wykonana.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="9ca7b-208">Jest to zgodne `switch` z zachowaniem bieżącej instrukcji, gdzie wszystkie możliwe przypadki zostały wymienione.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="9ca7b-209">Trzecia reguła wprowadza zastosowania, w `var` których przypadek może być przydatny.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="9ca7b-210">Wyobraź sobie, że robisz dopasowanie wzorca, gdzie dane wejściowe jest ciąg iem i szukasz znanych wartości poleceń.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="9ca7b-211">Możesz napisać coś takiego:</span><span class="sxs-lookup"><span data-stu-id="9ca7b-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="9ca7b-212">Sprawa `var` pasuje `null`, pusty ciąg lub dowolny ciąg, który zawiera tylko biały znak.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="9ca7b-213">Należy zauważyć, że poprzedni `?.` kod używa operatora, aby upewnić <xref:System.NullReferenceException>się, że nie przypadkowo throw .</span><span class="sxs-lookup"><span data-stu-id="9ca7b-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="9ca7b-214">Sprawa `default` obsługuje inne wartości ciągu, które nie są rozumiane przez ten analizator poleceń.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="9ca7b-215">Jest to jeden przykład, w `var` którym warto rozważyć `default` wyrażenie sprawy, które różni się od wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="9ca7b-216">Wnioski</span><span class="sxs-lookup"><span data-stu-id="9ca7b-216">Conclusions</span></span>

<span data-ttu-id="9ca7b-217">*Konstrukcje dopasowywania wzorców* umożliwiają łatwe zarządzanie przepływem sterowania między różnymi zmiennymi i typami, które nie są powiązane przez hierarchię dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="9ca7b-218">Można również kontrolować logikę, aby użyć dowolnego warunku, który testujesz na zmiennej.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="9ca7b-219">Umożliwia wzorce i idiomy, które będą potrzebne częściej podczas tworzenia bardziej rozproszonych aplikacji, gdzie dane i metody, które manipulują tymi danymi są oddzielne.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="9ca7b-220">Można zauważyć, że struktury kształtu używane w tym przykładzie nie zawierają żadnych metod, tylko właściwości tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="9ca7b-221">Dopasowanie wzorca działa z dowolnym typem danych.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="9ca7b-222">Piszesz wyrażenia, które sprawdzają obiekt i podejmują decyzje dotyczące przepływu sterowania na podstawie tych warunków.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="9ca7b-223">Porównaj kod z tego przykładu z projektem, który `Shape` będzie wynikać z tworzenia hierarchii klas dla abstrakcyjnych i określonych kształtów pochodnych każdy z własną implementację metody wirtualnej do obliczania obszaru.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="9ca7b-224">Często okazuje się, że wyrażenia dopasowywania wzorców może być bardzo przydatne narzędzie podczas pracy z danymi i chcesz oddzielić problemy przechowywania danych od problemów zachowania.</span><span class="sxs-lookup"><span data-stu-id="9ca7b-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="9ca7b-225">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="9ca7b-225">See also</span></span>

- [<span data-ttu-id="9ca7b-226">Samouczek: Korzystanie z funkcji dopasowywania wzorców w celu rozszerzenia typów danych</span><span class="sxs-lookup"><span data-stu-id="9ca7b-226">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
