---
title: Dopasowanie wzorca — przewodnik C#
description: Dowiedz się więcej o wzorzec dopasowany wyrażenia w języku C#
ms.date: 01/24/2017
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 0f95ac8b16939173e6cfd7304b9cbe52526b5169
ms.sourcegitcommit: 15109844229ade1c6449f48f3834db1b26907824
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/07/2018
---
# <a name="pattern-matching"></a><span data-ttu-id="855a6-103">Dopasowanie wzorca</span><span class="sxs-lookup"><span data-stu-id="855a6-103">Pattern Matching</span></span> #

<span data-ttu-id="855a6-104">Wzorce przetestować, czy wartość ma określony *kształtu*i można je *wyodrębnić* informacji z wartości, jeśli ma odpowiedniego kształtu.</span><span class="sxs-lookup"><span data-stu-id="855a6-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="855a6-105">Dopasowanie wzorca zapewnia bardziej zwięzły składni algorytmów używanych już dzisiaj.</span><span class="sxs-lookup"><span data-stu-id="855a6-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="855a6-106">Już tworzyć przy użyciu składni istniejące algorytmy dopasowywania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="855a6-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="855a6-107">Możesz zapisać `if` lub `switch` instrukcji, które wartości testowe.</span><span class="sxs-lookup"><span data-stu-id="855a6-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="855a6-108">Następnie gdy te instrukcje są zgodne, można wyodrębnić i używać informacji z tej wartości.</span><span class="sxs-lookup"><span data-stu-id="855a6-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="855a6-109">Nowe elementy składni są rozszerzenia instrukcje znasz już: `is` i `switch`.</span><span class="sxs-lookup"><span data-stu-id="855a6-109">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="855a6-110">Testowanie wartości i wyodrębniania informacji łączyć tych nowych rozszerzeń.</span><span class="sxs-lookup"><span data-stu-id="855a6-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="855a6-111">W tym temacie wyjaśniono, nowej składni, aby pokazać, jak umożliwia do odczytu i zwięzłe kodu.</span><span class="sxs-lookup"><span data-stu-id="855a6-111">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="855a6-112">Dopasowanie wzorca umożliwia idioms, w którym dane i kod są rozdzielone, w przeciwieństwie do projektów obiektowej gdzie danych i metod, które manipulować nimi są bezpośrednio powiązane.</span><span class="sxs-lookup"><span data-stu-id="855a6-112">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="855a6-113">Aby zilustrować te nowe idioms, teraz współpracować z struktur reprezentujących geometrycznych kształtów za pomocą instrukcji dopasowywania do wzorca.</span><span class="sxs-lookup"><span data-stu-id="855a6-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="855a6-114">Znasz prawdopodobnie Tworzenie klasy hierarchie i tworzenie [metody wirtualne i przesłoniętej metody](methods.md#inherited) Aby dostosować zachowanie obiektu na podstawie typu środowiska uruchomieniowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="855a6-114">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="855a6-115">Te techniki nie są możliwe w dla danych, który nie jest strukturę hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="855a6-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="855a6-116">Gdy dane i metody są oddzielone, należy innych narzędzi.</span><span class="sxs-lookup"><span data-stu-id="855a6-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="855a6-117">Nowy *dopasowanie wzorca* konstrukcji włączyć składni czyszczący do badania danych i manipulowania przepływu sterowania na podstawie warunku żadnych danych.</span><span class="sxs-lookup"><span data-stu-id="855a6-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="855a6-118">Już zapisu `if` instrukcje i `switch` test który wartość zmiennej.</span><span class="sxs-lookup"><span data-stu-id="855a6-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="855a6-119">Możesz zapisać `is` instrukcji, które test typ zmiennej.</span><span class="sxs-lookup"><span data-stu-id="855a6-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="855a6-120">*Dopasowanie wzorca* dodaje nowe funkcje do tych instrukcji.</span><span class="sxs-lookup"><span data-stu-id="855a6-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="855a6-121">W tym temacie będzie kompilacji metodę, która oblicza obszaru różnych kształtów geometrycznych.</span><span class="sxs-lookup"><span data-stu-id="855a6-121">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="855a6-122">Jednak należy go to zrobić bez konieczności techniki obiektowej i tworzenie hierarchii klas dla różnych kształtów.</span><span class="sxs-lookup"><span data-stu-id="855a6-122">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="855a6-123">Użyjesz *dopasowanie wzorca* zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="855a6-123">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="855a6-124">Do dalszego podkreślić, że firma Microsoft nie korzysta z dziedziczenia, należy podjąć każdego kształtu `struct` zamiast klasy.</span><span class="sxs-lookup"><span data-stu-id="855a6-124">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="855a6-125">Należy pamiętać, że różne `struct` typów nie można określić typowe typu zdefiniowanego przez użytkownika podstawowego, dlatego dziedziczenia nie jest możliwe projektu.</span><span class="sxs-lookup"><span data-stu-id="855a6-125">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="855a6-126">Podczas wykonywania kroków w tym przykładzie, natomiast ten kod z jak może być struktura jako hierarchię obiektów.</span><span class="sxs-lookup"><span data-stu-id="855a6-126">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="855a6-127">Po danych należy zbadać i manipulowania nie jest hierarchia klas, dopasowanie wzorca umożliwia bardzo atrakcyjny projektów.</span><span class="sxs-lookup"><span data-stu-id="855a6-127">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="855a6-128">Zamiast rozpoczyna się od definicji kształtu abstrakcyjna i dodawanie klas inny kształt, Zacznijmy zamiast tego proste danych tylko definicje dla wszystkich kształtów:</span><span class="sxs-lookup"><span data-stu-id="855a6-128">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="855a6-129">Z tych struktur Napisz metodę, która oblicza obszaru niektórych kształtu.</span><span class="sxs-lookup"><span data-stu-id="855a6-129">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="855a6-130">`is` Wpisz wyrażenie wzorca</span><span class="sxs-lookup"><span data-stu-id="855a6-130">The `is` type pattern expression</span></span>

<span data-ttu-id="855a6-131">Przed C# 7.0, konieczne będzie przetestuj poszczególne typy w szeregu `if` i `is` instrukcji:</span><span class="sxs-lookup"><span data-stu-id="855a6-131">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="855a6-132">Czy powyższy kod jest wyrażeniem klasycznego *wzorzec typu*: w przypadku testowania zmiennej do określenia jej typu i wykonywania różnych akcji, na podstawie tego typu.</span><span class="sxs-lookup"><span data-stu-id="855a6-132">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="855a6-133">Ten kod staje się prostsze przy użyciu rozszerzeń `is` wyrażenie, które można przypisać zmiennej Jeśli test zakończy się pomyślnie:</span><span class="sxs-lookup"><span data-stu-id="855a6-133">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="855a6-134">W tym zaktualizowaną wersję `is` wyrażenie testów zmiennej i przypisuje go do nowej zmiennej prawidłowego typu.</span><span class="sxs-lookup"><span data-stu-id="855a6-134">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="855a6-135">Ponadto zawiadomienia, które ta wersja zawiera `Rectangle` typu, który jest `struct`.</span><span class="sxs-lookup"><span data-stu-id="855a6-135">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="855a6-136">Nowe `is` wyrażenie współpracuje z typów wartości, a także typy referencyjne.</span><span class="sxs-lookup"><span data-stu-id="855a6-136">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="855a6-137">Reguły języka wyrażeń dopasowania wzorca pomóc w uniknięciu niewłaściwie korzysta z wyników wyrażenie dopasowania.</span><span class="sxs-lookup"><span data-stu-id="855a6-137">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="855a6-138">W przykładzie przedstawionym powyżej zmienne `s`, `c`, i `r` tylko w zakresie i ostatecznie przypisane przypadku wyrażenia dopasowania wzorca odpowiednich `true` wyników.</span><span class="sxs-lookup"><span data-stu-id="855a6-138">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="855a6-139">Jeśli spróbujesz użyć zmiennej albo w innym miejscu kodu generuje błędy kompilatora.</span><span class="sxs-lookup"><span data-stu-id="855a6-139">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="855a6-140">Przeanalizujmy oba te reguły szczegółowo, począwszy od zakresu.</span><span class="sxs-lookup"><span data-stu-id="855a6-140">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="855a6-141">Zmienna `c` znajduje się w zakresie tylko w `else` gałęzi pierwszego `if` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="855a6-141">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="855a6-142">Zmienna `s` znajduje się w zakresie w metodzie `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="855a6-142">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="855a6-143">Wynika to z każdej gałęzi `if` instrukcji ustanawia oddzielnymi zakresami zmiennych.</span><span class="sxs-lookup"><span data-stu-id="855a6-143">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="855a6-144">Jednak `if` nie obsługuje instrukcji sam.</span><span class="sxs-lookup"><span data-stu-id="855a6-144">However, the `if` statement itself does not.</span></span> <span data-ttu-id="855a6-145">Oznacza to, że zmienne zadeklarowane w `if` instrukcji znajdują się w tym samym zakresie co `if` instrukcji (metoda w tym przypadku.) To zachowanie nie jest specyficzne dla dopasowania wzorca, ale jest zdefiniowane zachowanie dla zmiennej zakresów i `if` i `else` instrukcje.</span><span class="sxs-lookup"><span data-stu-id="855a6-145">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="855a6-146">Zmienne `c` i `s` są przypisane, kiedy odpowiednio `if` instrukcje są spełnione ze względu na przypisane ostatecznie gdy true mechanizmu.</span><span class="sxs-lookup"><span data-stu-id="855a6-146">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="855a6-147">Przykłady w tym temacie Użyj zalecanych konstrukcji, którego dopasowania wzorca `is` wyrażenie ostatecznie przypisuje zmiennej dopasowania w `true` gałęzi `if` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="855a6-147">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="855a6-148">Logika może odtworzyć mówiąc `if (!(shape is Square s))` i zmienna `s` będzie można zdecydowanie przypisać tylko w `false` gałęzi.</span><span class="sxs-lookup"><span data-stu-id="855a6-148">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="855a6-149">Jest to prawidłowy C#, nie zaleca się, ponieważ jest bardziej skomplikowane, postępuj zgodnie z logiką.</span><span class="sxs-lookup"><span data-stu-id="855a6-149">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="855a6-150">Te reguły oznacza, że jesteś w stanie przypadkowo uzyskiwać dostęp do wyniku wyrażenia dopasowania wzorca w przypadku tego wzorca nie zostało spełnione.</span><span class="sxs-lookup"><span data-stu-id="855a6-150">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="855a6-151">Za pomocą dopasowywania do wzorca `switch` — instrukcje</span><span class="sxs-lookup"><span data-stu-id="855a6-151">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="855a6-152">Zgodnie z upływem czasu, konieczne może być obsługuje inne typy kształtu.</span><span class="sxs-lookup"><span data-stu-id="855a6-152">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="855a6-153">Wraz z rozwojem liczbę warunków podczas testowania, znajdują się to przy użyciu `is` wzorzec dopasowany wyrażenia może być skomplikowane.</span><span class="sxs-lookup"><span data-stu-id="855a6-153">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="855a6-154">Oprócz wymagające `if` instrukcje dla każdego typu, aby sprawdzić, `is` wyrażenia są ograniczone do testowania, jeśli pasuje do jednego typu danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="855a6-154">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="855a6-155">W takim przypadku znajdziesz który `switch` wyrażenia dopasowania wzorca staje się lepszym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="855a6-155">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="855a6-156">Tradycyjne `switch` instrukcja została wyrażenia wzorca: on obsługiwany wzorzec stałej.</span><span class="sxs-lookup"><span data-stu-id="855a6-156">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="855a6-157">Można porównać zmienną do dowolnego stała używane w `case` instrukcji:</span><span class="sxs-lookup"><span data-stu-id="855a6-157">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="855a6-158">Tylko wzorca obsługiwane przez `switch` instrukcja została stałe wzorzec.</span><span class="sxs-lookup"><span data-stu-id="855a6-158">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="855a6-159">Dalsze została ograniczona do liczbowych typów i `string` typu.</span><span class="sxs-lookup"><span data-stu-id="855a6-159">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="855a6-160">Te ograniczenia zostały usunięte, a teraz zapisać `switch` instrukcję, używając ze wzorcem typu:</span><span class="sxs-lookup"><span data-stu-id="855a6-160">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="855a6-161">Dopasowanie wzorca `switch` używana składnia znane deweloperom, którzy użyli tradycyjnych stylu języka C `switch` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="855a6-161">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="855a6-162">Każdy `case` jest obliczane i wykonywany jest kod poniżej warunek, który odpowiada zmiennej wejściowego.</span><span class="sxs-lookup"><span data-stu-id="855a6-162">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="855a6-163">Wykonanie kodu nie może "przechodzić" z jednego wyrażenia case do następnego; Składnia `case` instrukcji wymaga, aby każdy `case` kończyć `break`, `return`, lub `goto`.</span><span class="sxs-lookup"><span data-stu-id="855a6-163">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="855a6-164">`goto` Instrukcje, aby przejść do innej etykiety są prawidłowe tylko w wzorcu stałej instrukcji switch klasycznego.</span><span class="sxs-lookup"><span data-stu-id="855a6-164">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="855a6-165">Brak ważnych nowe zasady `switch` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="855a6-165">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="855a6-166">Ograniczenia dotyczące typu zmiennej w `switch` wyrażenia zostały usunięte.</span><span class="sxs-lookup"><span data-stu-id="855a6-166">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="855a6-167">Dowolny typ, takich jak `object` w tym przykładzie, może być używany.</span><span class="sxs-lookup"><span data-stu-id="855a6-167">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="855a6-168">Wyrażenia case nie są ograniczone do wartości stałych.</span><span class="sxs-lookup"><span data-stu-id="855a6-168">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="855a6-169">Usunięcie tego ograniczenia oznacza, że zmiana kolejności `switch` sekcje mogą zmienić zachowanie programu.</span><span class="sxs-lookup"><span data-stu-id="855a6-169">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="855a6-170">Gdy ograniczone do wartości stałej ma więcej niż jeden `case` etykiety może być zgodna z wartością `switch` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="855a6-170">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="855a6-171">Połączenie wyniku z regułą który co `switch` sekcji nie musi przechodzić do następnej sekcji i zostały wykonane, który `switch` sekcje można zmieniać w dowolnej kolejności bez wpływu na zachowanie.</span><span class="sxs-lookup"><span data-stu-id="855a6-171">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="855a6-172">Teraz z więcej uogólniony `switch` wyrażenia, kolejność każdej sekcji ma znaczenie.</span><span class="sxs-lookup"><span data-stu-id="855a6-172">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="855a6-173">`switch` Wyrażenia są przetwarzane w kolejności tekstową.</span><span class="sxs-lookup"><span data-stu-id="855a6-173">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="855a6-174">Wykonanie przenoszone jest do pierwszej `switch` etykiety, który odpowiada `switch` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="855a6-174">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="855a6-175">Należy pamiętać, że `default` przypadku będą wykonywane tylko, jeśli innych przypadków etykiety nie są zgodne.</span><span class="sxs-lookup"><span data-stu-id="855a6-175">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="855a6-176">`default` Przypadek jest obliczane, niezależnie od ich kolejność tekstową.</span><span class="sxs-lookup"><span data-stu-id="855a6-176">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="855a6-177">W przypadku nie `default` sprawy i brak innych `case` instrukcje są zgodne, wykonanie jest kontynuowane od następujących instrukcji `switch` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="855a6-177">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="855a6-178">Żadna z `case` wykonywany jest kod etykiety.</span><span class="sxs-lookup"><span data-stu-id="855a6-178">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="855a6-179">`when` klauzule `case` wyrażenia</span><span class="sxs-lookup"><span data-stu-id="855a6-179">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="855a6-180">Możesz wprowadzić specjalne przypadki tych kształty, których obszaru 0 za pomocą `when` klauzuli na `case` etykiety.</span><span class="sxs-lookup"><span data-stu-id="855a6-180">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="855a6-181">Kwadrat o długości boku 0 lub koło z protokołem radius 0 ma obszar 0.</span><span class="sxs-lookup"><span data-stu-id="855a6-181">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="855a6-182">Można ją określić za pomocą tego warunku `when` klauzuli na `case` etykiety:</span><span class="sxs-lookup"><span data-stu-id="855a6-182">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="855a6-183">Ta zmiana przedstawiono kilka ważnych kwestii o nowej składni.</span><span class="sxs-lookup"><span data-stu-id="855a6-183">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="855a6-184">Najpierw wielu `case` etykiety może odnosić się do jednego `switch` sekcji.</span><span class="sxs-lookup"><span data-stu-id="855a6-184">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="855a6-185">Blok instrukcji jest wykonywana po jest dowolny z tych etykiet `true`.</span><span class="sxs-lookup"><span data-stu-id="855a6-185">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="855a6-186">W tym przypadku jeśli `switch` wyrażenie jest koło lub kwadrat z obszaru 0, metoda zwraca stała 0.</span><span class="sxs-lookup"><span data-stu-id="855a6-186">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="855a6-187">W tym przykładzie przedstawiono dwie różne zmienne w dwóch `case` etykiet w pierwszym `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="855a6-187">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="855a6-188">Należy zauważyć, że instrukcje w tym `switch` bloku nie należy używać albo zmienne `c` (dla okręgu) lub `s` (dla wartości kwadratu).</span><span class="sxs-lookup"><span data-stu-id="855a6-188">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="855a6-189">Zdecydowanie nie żadna z tych zmiennych nie przypisano w tym `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="855a6-189">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="855a6-190">Jeśli jeden z tych przypadkach są zgodne, wyraźnie zmiennych zostały przypisane.</span><span class="sxs-lookup"><span data-stu-id="855a6-190">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="855a6-191">Jednak nie można sprawdzić *którego* przypisano w czasie kompilacji, ponieważ w obu przypadkach można dopasować w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="855a6-191">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="855a6-192">Z tego powodu większość czasu kiedy używanych jest wiele `case` etykiety dla tego samego bloku, nie będzie powodować nową zmienną w `case` instrukcji, lub tylko użyć zmiennej w `when` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="855a6-192">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="855a6-193">Mające dodać te kształty z obszaru 0, możemy dodać kilka typów więcej kształtów: prostokąt i trójkąt:</span><span class="sxs-lookup"><span data-stu-id="855a6-193">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="855a6-194">Dodaje ten zestaw zmian `case` etykiet w przypadku degeneracji i etykiety i bloków dla wszystkich nowych kształtów.</span><span class="sxs-lookup"><span data-stu-id="855a6-194">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="855a6-195">Na koniec można dodać `null` wielkości liter, aby zapewnić argument nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="855a6-195">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="855a6-196">Specjalnego zachowania w przypadku `null` wzorzec jest ciekawe ponieważ stała `null` we wzorcu nie ma typu, ale mogą być konwertowane do dowolnego typu odwołanie lub typ dopuszczający wartość null.</span><span class="sxs-lookup"><span data-stu-id="855a6-196">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="855a6-197">Zamiast przekonwertować `null` do dowolnego typu język definiuje, które `null` wartość będzie zgodny z żadnym wzorcem typu, niezależnie od typu zmienną kompilacji.</span><span class="sxs-lookup"><span data-stu-id="855a6-197">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="855a6-198">To zachowanie sprawia, że nowe `switch` na podstawie typu wzorzec zgodne z `is` instrukcji: `is` instrukcje zawsze zwracają `false` gdy wartość sprawdzany jest `null`.</span><span class="sxs-lookup"><span data-stu-id="855a6-198">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="855a6-199">Jest również prostsze: po sprawdzeniu typ nie jest potrzebny dodatkowy sprawdzania wartości null.</span><span class="sxs-lookup"><span data-stu-id="855a6-199">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="855a6-200">Widać, że z faktu, że nie istnieją żadne null sprawdza w żadnym przypadku bloków powyższe przykłady: nie są niezbędne, ponieważ pasujących do wzorca typu gwarantuje wartość inną niż null.</span><span class="sxs-lookup"><span data-stu-id="855a6-200">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="855a6-201">`var` deklaracje w `case` wyrażenia</span><span class="sxs-lookup"><span data-stu-id="855a6-201">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="855a6-202">Wprowadzenie `var` jako jednego z wyrażeń dopasowania wprowadzono nowe reguły do dopasowania wzorca.</span><span class="sxs-lookup"><span data-stu-id="855a6-202">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="855a6-203">Pierwsza reguła jest to, że `var` zasady wnioskowania typu normalne znajduje się za deklaracją: typu jest wywnioskowany do statycznego typu wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="855a6-203">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="855a6-204">Od tej zasady zawsze zgodny typ.</span><span class="sxs-lookup"><span data-stu-id="855a6-204">From that rule, the type always matches.</span></span>

<span data-ttu-id="855a6-205">Jest drugą regułę, która `var` deklaracji nie ma wartości null Sprawdź, czy zawierają inne wyrażenia wzorca typu.</span><span class="sxs-lookup"><span data-stu-id="855a6-205">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="855a6-206">Oznacza to, zmienna może mieć wartości null, a w takim przypadku sprawdzania wartości null jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="855a6-206">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="855a6-207">Te dwie reguły oznaczają, że w wielu przypadkach `var` deklaracji w `case` wyrażenie dopasowuje z. `default` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="855a6-207">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="855a6-208">Ponieważ w przypadku wszelkich innych niż domyślne jest preferowana względem `default` przypadku `default` przypadku nigdy nie będą wykonywane.</span><span class="sxs-lookup"><span data-stu-id="855a6-208">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="855a6-209">Kompilator nie Emituj ostrzeżenie w przypadkach, gdy `default` przypadku została zapisana, ale nigdy nie będą wykonywane.</span><span class="sxs-lookup"><span data-stu-id="855a6-209">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="855a6-210">Jest to zgodne z bieżącą `switch` zachowaniem instrukcji, gdzie zostały wymienione wszystkich możliwych przypadków.</span><span class="sxs-lookup"><span data-stu-id="855a6-210">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="855a6-211">Trzeci regułę wprowadzono używa gdzie `var` przypadku mogą być użyteczne.</span><span class="sxs-lookup"><span data-stu-id="855a6-211">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="855a6-212">Wyobraź sobie robią dopasowania wzorca, gdy dane wejściowe jest ciągiem i szukasz polecenia znane wartości.</span><span class="sxs-lookup"><span data-stu-id="855a6-212">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="855a6-213">Można napisać wyglądać mniej więcej tak:</span><span class="sxs-lookup"><span data-stu-id="855a6-213">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="855a6-214">`var` Przypadek dopasowań `null`, ciągiem pustym lub dowolny ciąg, który zawiera tylko biały znak.</span><span class="sxs-lookup"><span data-stu-id="855a6-214">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="855a6-215">Należy zauważyć, że w poprzednim kodzie użyto `?.` operatora, aby upewnić się, że jej nie przypadkowo zgłasza <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="855a6-215">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="855a6-216">`default` Przypadku obsługuje innych wartości ciągu, które nie jest rozpoznawany przez parser tego polecenia.</span><span class="sxs-lookup"><span data-stu-id="855a6-216">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="855a6-217">To jest przykład których warto wziąć pod uwagę `var` przypadek wyrażenie, które różni się od `default` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="855a6-217">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="855a6-218">Wnioski</span><span class="sxs-lookup"><span data-stu-id="855a6-218">Conclusions</span></span>

<span data-ttu-id="855a6-219">*Konstrukcje dopasowywania do wzorca* umożliwiają łatwe zarządzanie przepływu sterowania spośród różnych zmiennych i typy, które nie są powiązane przez hierarchię dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="855a6-219">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="855a6-220">Można też kontrolować logiki używać żadnych warunek, który należy przetestować w zmiennej.</span><span class="sxs-lookup"><span data-stu-id="855a6-220">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="855a6-221">Umożliwia wzorców i idioms, które należy częściej podczas tworzenia więcej aplikacji rozproszonych, w którym dane i metody, które manipulowania danych są oddzielone.</span><span class="sxs-lookup"><span data-stu-id="855a6-221">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="855a6-222">Można zauważyć struktury kształtu używany w tym przykładzie nie zawierają żadnych metod, właściwości tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="855a6-222">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="855a6-223">Dopasowywanie do wzorca współpracuje z dowolnego typu danych.</span><span class="sxs-lookup"><span data-stu-id="855a6-223">Pattern Matching works with any data type.</span></span> <span data-ttu-id="855a6-224">Napisz wyrażeń, które badają obiekt, a następnie podjąć decyzje dotyczące przepływu sterowania na podstawie tych warunków.</span><span class="sxs-lookup"><span data-stu-id="855a6-224">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="855a6-225">Porównanie kodu z tego przykładu z projektu, który w wyniku tworzenia hierarchii klas dla abstrakcyjnego `Shape` i określonych pochodnych kształty z własnych implementacji metody wirtualnej do obliczenia.</span><span class="sxs-lookup"><span data-stu-id="855a6-225">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="855a6-226">Często okazuje się wyrażenia dopasowania wzorca może być bardzo przydatne narzędzie podczas pracy z danych, aby oddzielić od problemów zachowanie dotyczy magazynu danych.</span><span class="sxs-lookup"><span data-stu-id="855a6-226">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

