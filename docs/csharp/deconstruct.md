---
title: Dekonstrukcja krotek i innych typów
description: Dowiedz się, jak zdekonstruować krotek i innych typów.
ms.technology: csharp-fundamentals
ms.date: 11/23/2017
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: d238f6f520653befb1464377094b93e34dde0eca
ms.sourcegitcommit: 927b7ea6b2ea5a440c8f23e3e66503152eb85591
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/16/2020
ms.locfileid: "81463126"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="4f58c-103">Dekonstrukcja krotek i innych typów</span><span class="sxs-lookup"><span data-stu-id="4f58c-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="4f58c-104">Krotka zapewnia lekki sposób pobierania wielu wartości z wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="4f58c-104">A tuple provides a lightweight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="4f58c-105">Ale po pobraniu krotki, trzeba obsługiwać jego poszczególnych elementów.</span><span class="sxs-lookup"><span data-stu-id="4f58c-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="4f58c-106">Robi to na podstawie elementu po elemencie jest uciążliwe, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4f58c-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="4f58c-107">Metoda `QueryCityData` zwraca 3-krotki, a każdy z jego elementów jest przypisany do zmiennej w oddzielnej operacji.</span><span class="sxs-lookup"><span data-stu-id="4f58c-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="4f58c-108">Pobieranie wielu wartości pól i właściwości z obiektu może być równie uciążliwe: należy przypisać pole lub wartość właściwości do zmiennej na podstawie elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4f58c-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="4f58c-109">Począwszy od języka C# 7.0, można pobrać wiele elementów z krotki lub pobrać wiele pól, właściwości i obliczonych wartości z obiektu w jednej operacji *dekonstrukcji.*</span><span class="sxs-lookup"><span data-stu-id="4f58c-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="4f58c-110">Podczas dekonstrukcji krotki, należy przypisać jej elementy do poszczególnych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="4f58c-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="4f58c-111">Podczas dekonstruowania obiektu do poszczególnych zmiennych przypisywane są wybrane wartości.</span><span class="sxs-lookup"><span data-stu-id="4f58c-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="4f58c-112">Dekonstruowanie krotki</span><span class="sxs-lookup"><span data-stu-id="4f58c-112">Deconstructing a tuple</span></span>

<span data-ttu-id="4f58c-113">C# funkcje wbudowanej obsługi dekonstrukcji krotek, co pozwala rozpakować wszystkie elementy w krocie w jednej operacji.</span><span class="sxs-lookup"><span data-stu-id="4f58c-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="4f58c-114">Ogólna składnia dekonstrukcji krotki jest podobna do składni definiowania jednej: należy ująć zmienne, do których każdy element ma być przypisany w nawiasach po lewej stronie instrukcji przypisania.</span><span class="sxs-lookup"><span data-stu-id="4f58c-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="4f58c-115">Na przykład następująca instrukcja przypisuje elementy 4-krotki do czterech oddzielnych zmiennych:</span><span class="sxs-lookup"><span data-stu-id="4f58c-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="4f58c-116">Istnieją trzy sposoby dekonstrukcji krotki:</span><span class="sxs-lookup"><span data-stu-id="4f58c-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="4f58c-117">Można jawnie zadeklarować typ każdego pola wewnątrz nawiasów.</span><span class="sxs-lookup"><span data-stu-id="4f58c-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="4f58c-118">W poniższym przykładzie użyto tego podejścia do dekonstrukcji 3-krotki zwracane `QueryCityData` przez metodę.</span><span class="sxs-lookup"><span data-stu-id="4f58c-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="4f58c-119">Można użyć `var` słowa kluczowego, tak aby C# wywnioskować typ każdej zmiennej.</span><span class="sxs-lookup"><span data-stu-id="4f58c-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="4f58c-120">Słowo kluczowe `var` jest umieszczane poza nawiasami.</span><span class="sxs-lookup"><span data-stu-id="4f58c-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="4f58c-121">W poniższym przykładzie użyto inference typu podczas dekonstrukcji 3-krotka zwrócona `QueryCityData` przez metodę.</span><span class="sxs-lookup"><span data-stu-id="4f58c-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="4f58c-122">Można również użyć `var` słowa kluczowego indywidualnie z dowolnej lub wszystkich deklaracji zmiennych wewnątrz nawiasów.</span><span class="sxs-lookup"><span data-stu-id="4f58c-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="4f58c-123">Jest to uciążliwe i nie jest zalecane.</span><span class="sxs-lookup"><span data-stu-id="4f58c-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="4f58c-124">Na koniec można zdekonstruować krotki na zmienne, które zostały już zadeklarowane.</span><span class="sxs-lookup"><span data-stu-id="4f58c-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="4f58c-125">Należy zauważyć, że nie można określić określonego typu poza nawiasami, nawet jeśli każde pole w krocie ma ten sam typ.</span><span class="sxs-lookup"><span data-stu-id="4f58c-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="4f58c-126">Powoduje to wygenerowanie błędu kompilatora CS8136, "Formularz dekonstrukcji 'var (...)' nie zezwala na określony typ dla 'var'.".</span><span class="sxs-lookup"><span data-stu-id="4f58c-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="4f58c-127">Należy również przypisać każdy element krotki do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="4f58c-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="4f58c-128">Jeśli pominięto jakiekolwiek elementy, kompilator generuje błąd CS8132, "Nie można zdekonstruować krotki elementów 'x' na zmienne 'y'."</span><span class="sxs-lookup"><span data-stu-id="4f58c-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="4f58c-129">Należy zauważyć, że nie można mieszać deklaracji i przypisań do istniejących zmiennych po lewej stronie dekonstrukcji.</span><span class="sxs-lookup"><span data-stu-id="4f58c-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="4f58c-130">Kompilator generuje błąd CS8184, "dekonstrukcja nie można mieszać deklaracji i wyrażeń po lewej stronie."</span><span class="sxs-lookup"><span data-stu-id="4f58c-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="4f58c-131">gdy członkowie obejmują nowo zadeklarowane i istniejące zmienne.</span><span class="sxs-lookup"><span data-stu-id="4f58c-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="4f58c-132">Dekonstruowanie elementów krotki z odrzutami</span><span class="sxs-lookup"><span data-stu-id="4f58c-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="4f58c-133">Często podczas dekonstrukcji krotki, jesteś zainteresowany wartości tylko niektóre elementy.</span><span class="sxs-lookup"><span data-stu-id="4f58c-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="4f58c-134">Począwszy od języka C# 7.0, można skorzystać z obsługi języka C#dla *odrzuceń,* które są zmienne tylko do zapisu, których wartości zostały wybrane do zignorowania.</span><span class="sxs-lookup"><span data-stu-id="4f58c-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="4f58c-135">Odrzucenie jest oznaczane przez znak\_podkreślenia (" ") w przypisaniu.</span><span class="sxs-lookup"><span data-stu-id="4f58c-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="4f58c-136">Możesz odrzucić dowolną liczbę wartości; wszystkie są reprezentowane przez `_`pojedynczy odrzut, .</span><span class="sxs-lookup"><span data-stu-id="4f58c-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="4f58c-137">Poniższy przykład ilustruje użycie krotek z odrzutami.</span><span class="sxs-lookup"><span data-stu-id="4f58c-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="4f58c-138">Metoda `QueryCityDataForYears` zwraca 6-krotka z nazwą miasta, jego obszar, rok, populacji miasta w tym roku, drugi rok, a populacja miasta w tym drugim roku.</span><span class="sxs-lookup"><span data-stu-id="4f58c-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="4f58c-139">Przykład pokazuje zmianę populacji między tymi dwoma latami.</span><span class="sxs-lookup"><span data-stu-id="4f58c-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="4f58c-140">Z danych dostępnych z krotki, nie jesteśmy obojętni na obszar miasta, i znamy nazwę miasta i dwie daty w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="4f58c-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="4f58c-141">W rezultacie jesteśmy zainteresowani tylko dwie wartości populacji przechowywane w krotki i może obsługiwać jego pozostałe wartości jako odrzuca.</span><span class="sxs-lookup"><span data-stu-id="4f58c-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

## <a name="deconstructing-user-defined-types"></a><span data-ttu-id="4f58c-142">Dekonstrukcja typów zdefiniowanych przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="4f58c-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="4f58c-143">C# nie oferuje wbudowanej obsługi dekonstrukcji typów nieprzeznaczających krotki.</span><span class="sxs-lookup"><span data-stu-id="4f58c-143">C# does not offer built-in support for deconstructing non-tuple types.</span></span> <span data-ttu-id="4f58c-144">Jednak jako autor klasy, struktury lub interfejsu, można zezwolić wystąpienia typu, które mają być zdekonstruowane `Deconstruct` przez implementację jednej lub więcej metod.</span><span class="sxs-lookup"><span data-stu-id="4f58c-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="4f58c-145">Metoda zwraca void, a każda wartość, która ma zostać zdekonstruowana, jest wskazywana przez parametr [out](language-reference/keywords/out-parameter-modifier.md) w podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="4f58c-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="4f58c-146">Na przykład następująca `Deconstruct` `Person` metoda klasy zwraca imię pierwszego, środkowego i nazwiska:</span><span class="sxs-lookup"><span data-stu-id="4f58c-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="4f58c-147">Następnie można zdekonstruować `Person` wystąpienie `p` klasy o nazwie z przypisaniem, takie jak następujące:</span><span class="sxs-lookup"><span data-stu-id="4f58c-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="4f58c-148">Poniższy przykład przeciąża `Deconstruct` metodę zwracania różnych kombinacji właściwości `Person` obiektu.</span><span class="sxs-lookup"><span data-stu-id="4f58c-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="4f58c-149">Zwrot poszczególnych przeciążeń:</span><span class="sxs-lookup"><span data-stu-id="4f58c-149">Individual overloads return:</span></span>

- <span data-ttu-id="4f58c-150">Imię i nazwisko.</span><span class="sxs-lookup"><span data-stu-id="4f58c-150">A first and last name.</span></span>
- <span data-ttu-id="4f58c-151">Imię pierwsze, ostatnie i drugie.</span><span class="sxs-lookup"><span data-stu-id="4f58c-151">A first, last, and middle name.</span></span>
- <span data-ttu-id="4f58c-152">Imię, nazwisko, nazwa miasta i nazwa państwa.</span><span class="sxs-lookup"><span data-stu-id="4f58c-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="4f58c-153">Ponieważ można przeciążyć `Deconstruct` metodę, aby odzwierciedlić grupy danych, które `Deconstruct` są powszechnie wyodrębniane z obiektu, należy uważać, aby zdefiniować metody z podpisów, które są charakterystyczne i jednoznaczne.</span><span class="sxs-lookup"><span data-stu-id="4f58c-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="4f58c-154">Wiele `Deconstruct` metod, które mają `out` taką samą liczbę `out` parametrów lub taką samą liczbę i typ parametrów w innej kolejności może powodować zamieszanie.</span><span class="sxs-lookup"><span data-stu-id="4f58c-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span>

<span data-ttu-id="4f58c-155">Przeciążona `Deconstruct` metoda w poniższym przykładzie ilustruje jedno możliwe źródło zamieszania.</span><span class="sxs-lookup"><span data-stu-id="4f58c-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="4f58c-156">Pierwsze przeciążenie zwraca imię, drugie imię, nazwisko i `Person` wiek obiektu w tej kolejności.</span><span class="sxs-lookup"><span data-stu-id="4f58c-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="4f58c-157">Drugie przeciążenie zwraca informacje o nazwie tylko wraz z rocznym dochodem, ale imię pierwsze, środkowe i nazwisko są w innej kolejności.</span><span class="sxs-lookup"><span data-stu-id="4f58c-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="4f58c-158">Ułatwia to mylić kolejność argumentów podczas dekonstrukcji `Person` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4f58c-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="4f58c-159">Dekonstrukcja typu zdefiniowanego przez użytkownika za pomocą odrzutów</span><span class="sxs-lookup"><span data-stu-id="4f58c-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="4f58c-160">Podobnie jak w przypadku [krotek,](#deconstructing-tuple-elements-with-discards)można użyć odrzutów, aby `Deconstruct` zignorować wybrane elementy zwrócone metodą.</span><span class="sxs-lookup"><span data-stu-id="4f58c-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="4f58c-161">Każdy odrzut jest definiowany\_przez zmienną o nazwie " ", a pojedyncza operacja dekonstrukcji może zawierać wiele odrzutów.</span><span class="sxs-lookup"><span data-stu-id="4f58c-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="4f58c-162">Poniższy przykład dekonstruuje `Person` obiekt na cztery ciągi (imię i nazwisko, miasto i stan), ale odrzuca nazwisko i stan.</span><span class="sxs-lookup"><span data-stu-id="4f58c-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="4f58c-163">Dekonstrukcja typu zdefiniowanego przez użytkownika za pomocą metody rozszerzenia</span><span class="sxs-lookup"><span data-stu-id="4f58c-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="4f58c-164">Jeśli nie został autor klasy, struktury lub interfejsu, nadal można zdekonstruować obiekty tego `Deconstruct` typu, implementując jedną lub więcej [metod rozszerzenia,](programming-guide/classes-and-structs/extension-methods.md) aby zwrócić wartości, w których jesteś zainteresowany.</span><span class="sxs-lookup"><span data-stu-id="4f58c-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="4f58c-165">Poniższy przykład definiuje `Deconstruct` dwie metody <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> rozszerzenia dla klasy.</span><span class="sxs-lookup"><span data-stu-id="4f58c-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="4f58c-166">Pierwszy zwraca zestaw wartości, które wskazują właściwości, w tym jej typ, czy jest statyczne lub wystąpienie, czy jest tylko do odczytu i czy jest indeksowany.</span><span class="sxs-lookup"><span data-stu-id="4f58c-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="4f58c-167">Drugi wskazuje dostępność obiektu.</span><span class="sxs-lookup"><span data-stu-id="4f58c-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="4f58c-168">Ponieważ dostępność get i set akcesory mogą się różnić, wartości logiczne wskazują, czy właściwość ma oddzielne get i set akcesorów i, jeśli tak, czy mają taką samą dostępność.</span><span class="sxs-lookup"><span data-stu-id="4f58c-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="4f58c-169">Jeśli istnieje tylko jeden akcesor lub zarówno get i `access` set akcesor mają taką samą dostępność, zmienna wskazuje dostępność właściwości jako całości.</span><span class="sxs-lookup"><span data-stu-id="4f58c-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="4f58c-170">W przeciwnym razie dostępność get i set akcesory są wskazywane przez `getAccess` i `setAccess` zmienne.</span><span class="sxs-lookup"><span data-stu-id="4f58c-170">Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="4f58c-171">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="4f58c-171">See also</span></span>

- [<span data-ttu-id="4f58c-172">Odrzucenia</span><span class="sxs-lookup"><span data-stu-id="4f58c-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="4f58c-173">Krotki</span><span class="sxs-lookup"><span data-stu-id="4f58c-173">Tuples</span></span>](tuples.md)
