---
title: Deconstructing krotek i innych typów
description: Dowiedz się, jak deconstruct krotek i innych typów.
author: rpetrusha
ms.author: ronpet
ms.date: 07/18/2016
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: 726a391a4a747e5446e252e669c5b16248a5e0ad
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
ms.locfileid: "33217748"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="f0ad3-103">Deconstructing krotek i innych typów</span><span class="sxs-lookup"><span data-stu-id="f0ad3-103">Deconstructing tuples and other types</span></span> #

<span data-ttu-id="f0ad3-104">Krotka zawiera lekki sposób pobierania wiele wartości z wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-104">A tuple provides a light-weight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="f0ad3-105">Jednak po pobraniu spójnej kolekcji, do obsługi jego poszczególne elementy.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="f0ad3-106">Na podstawie elementów — jest to obciążeniem, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="f0ad3-107">`QueryCityData` Metoda zwraca krotka 3 i wszystkich jego elementów jest przypisany do zmiennej w oddzielnych operacji.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="f0ad3-108">Pobieranie wielu pól i wartości właściwości z obiektu może być skomplikowane jednakowo: należy przypisać wartość pola lub właściwości do zmiennej na podstawie elementu członkowskiego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span> 

<span data-ttu-id="f0ad3-109">Począwszy od wersji 7.0 C#, możesz pobrać wiele elementów z spójnej kolekcji lub pobrać wiele pola, właściwości i obliczonych wartości z obiektu w jednym *deconstruct* operacji.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="f0ad3-110">Gdy deconstruct spójnej kolekcji, jego elementy są przypisywane do poszczególnych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="f0ad3-111">Gdy deconstruct obiektu, można przypisać wybranych wartości poszczególnych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-111">When you deconstruct an object, you assign selected values to individual variables.</span></span> 

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="f0ad3-112">Deconstructing spójnych kolekcji</span><span class="sxs-lookup"><span data-stu-id="f0ad3-112">Deconstructing a tuple</span></span>

<span data-ttu-id="f0ad3-113">C# funkcje wbudowane obsługę deconstructing krotek, co umożliwia rozpakować wszystkie elementy w spójnej kolekcji w ramach jednej operacji.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="f0ad3-114">Ogólna składnia deconstructing Krotka jest podobny do składni do definiowania jedną: ujmij zmienne, do których każdy element ma być przypisana w nawiasach po lewej stronie instrukcji przypisania.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="f0ad3-115">Na przykład następująca instrukcja przypisuje elementy krotka 4 do czterech oddzielnych zmiennych:</span><span class="sxs-lookup"><span data-stu-id="f0ad3-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="f0ad3-116">Istnieją trzy sposoby deconstruct spójnych kolekcji:</span><span class="sxs-lookup"><span data-stu-id="f0ad3-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="f0ad3-117">Można jawnie deklarować typu każdego pola w nawiasach.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="f0ad3-118">W poniższym przykładzie użyto takie podejście do deconstruct krotki 3 zwrócony przez `QueryCityData` metody.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="f0ad3-119">Można użyć `var` — słowo kluczowe, tak że C# wnioskuje typ każdej zmiennej.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="f0ad3-120">Możesz umieścić `var` — słowo kluczowe poza nawiasów.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="f0ad3-121">W poniższym przykładzie użyto wnioskowanie o typie, gdy deconstructing krotki 3 zwrócony przez `QueryCityData` metody.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>
 
    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="f0ad3-122">Można również użyć `var` — słowo kluczowe indywidualnie z dowolnego lub wszystkich deklaracji zmiennych wewnątrz nawiasów.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span> 

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="f0ad3-123">To jest skomplikowane i nie jest zalecane.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="f0ad3-124">Ponadto może deconstruct spójnej kolekcji do zmiennych, które już zadeklarowany.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="f0ad3-125">Zauważ, że nie można określić określonego typu poza nawiasy, nawet w przypadku każdego pola w spójnej kolekcji ma tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="f0ad3-126">Generuje błąd kompilatora CS8136 "Deconstruction formularza"var (...)"nie zezwala na określony typ dla"var".".</span><span class="sxs-lookup"><span data-stu-id="f0ad3-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="f0ad3-127">Należy pamiętać, że należy również przypisać każdy element spójna kolekcja znajdująca się do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="f0ad3-128">W przypadku pominięcia elementów, kompilator generuje błąd CS8132 "Nie może deconstruct spójnych kolekcji z elementów" x"do zmiennych"y"."</span><span class="sxs-lookup"><span data-stu-id="f0ad3-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="f0ad3-129">Należy pamiętać, że nie można mieszać deklaracje i przypisania do istniejących zmiennych po lewej stronie deconstruction.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="f0ad3-130">Kompilator generuje błąd CS8184 "deconstruction nie można mieszać wyrażeń z lewego-nadwozia1-strony i deklaracje".</span><span class="sxs-lookup"><span data-stu-id="f0ad3-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="f0ad3-131">gdy członków obejmują zmienne nowo zadeklarowane i istniejące.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="f0ad3-132">Odrzuca deconstructing spójnej kolekcji elementów z</span><span class="sxs-lookup"><span data-stu-id="f0ad3-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="f0ad3-133">Często zdarza się deconstructing krotka, interesują Cię wartości tylko niektórych elementów.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="f0ad3-134">Począwszy od wersji 7.0 C#, możesz korzystać C# dla obsługi *odrzuca*, które są zmienne tylko do zapisu wartości, którego wybrano opcję Ignoruj.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="f0ad3-135">Odrzucenia jest wskazywany przez się od znaku podkreślenia ("\_") w ramach przypisania.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="f0ad3-136">Można odrzucić dowolną liczbę wartości jak; wszystkie są reprezentowane przez jeden odrzucenia, `_`.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="f0ad3-137">Poniższy przykład przedstawia użycie spójnych kolekcji zawierający odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="f0ad3-138">`QueryCityDataForYears` Metoda zwraca krotka 6 nazwą miasta, jego obszar, roku, miasta wypełniania tego roku, drugiego roku i wypełniania Miasto drugiego roku.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="f0ad3-139">W przykładzie zmiany w populacji między te dwa lata.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="f0ad3-140">Danych dostępne w spójnej kolekcji, jesteśmy unconcerned z obszarem mieście i wiemy, nazwę miejscowości i dwiema datami w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="f0ad3-141">W związku z tym możemy tylko w przypadku zainteresowani dwa wypełniania wartościami przechowywanymi w spójnej kolekcji, a może obsłużyć pozostałych wartości jako odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="f0ad3-142">Deconstructing typy danych zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="f0ad3-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="f0ad3-143">Typy parametrów nie nie oferuje wbudowaną obsługę odrzuca.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-143">Non-tuple types do not offer built-in support for discards.</span></span> <span data-ttu-id="f0ad3-144">Jednak autor klasy, struktury lub interfejsu, można zezwolić wystąpień typu, który ma być deconstructed zaimplementowanie co najmniej jeden `Deconstruct` metody.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="f0ad3-145">Metoda zwraca wartość typu void i każdej wartości można deconstructed jest określane przez [limit](language-reference/keywords/out-parameter-modifier.md) parametru w podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="f0ad3-146">Na przykład następująca `Deconstruct` metody `Person` klasy zwraca nazwę pierwszego, drugie imię i nazwisko:</span><span class="sxs-lookup"><span data-stu-id="f0ad3-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="f0ad3-147">Następnie można deconstruct wystąpienia `Person` klasy o nazwie `p` z przydziałem podobnie do następującej:</span><span class="sxs-lookup"><span data-stu-id="f0ad3-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="f0ad3-148">Następujący przykład przeciążeń `Deconstruct` metodę, aby zwrócić różnych kombinacji właściwości `Person` obiektu.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="f0ad3-149">Zwróć poszczególnych przeciążenia:</span><span class="sxs-lookup"><span data-stu-id="f0ad3-149">Individual overloads return:</span></span>

- <span data-ttu-id="f0ad3-150">Imię i nazwisko.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-150">A first and last name.</span></span>
- <span data-ttu-id="f0ad3-151">First, last i drugie imię.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-151">A first, last, and middle name.</span></span>
- <span data-ttu-id="f0ad3-152">Podaj pierwsze imię, nazwisko, nazwę miejscowości i nazwę stanu.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="f0ad3-153">Ponieważ można przeciążać `Deconstruct` metody w celu uwzględnienia grupy danych, które zwykle są wyodrębniane z obiektu należy zachować ostrożność zdefiniować `Deconstruct` metod podpisy charakterystyczne i jednoznaczny.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="f0ad3-154">Wiele `Deconstruct` metod, które mają taką samą liczbę `out` parametrów lub taka sama liczbę i typ `out` parametrów w innej kolejności może spowodować ryzyko pomyłek.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span> 

<span data-ttu-id="f0ad3-155">Przeciążone `Deconstruct` metody w poniższym przykładzie przedstawiono jeden możliwe źródło pomyłek.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="f0ad3-156">Zwraca pierwszy przeciążenia imię, drugie imię, nazwisko i wiek `Person` obiektu w podanej kolejności.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="f0ad3-157">Drugi przeciążenia zwraca informacje o nazwę tylko wraz z rocznego dochodu, ale nazwa pierwszego, drugie imię i nazwisko są w innym porządku.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="f0ad3-158">Dzięki temu łatwo pomylić Kolejność argumentów, gdy deconstructing `Person` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="f0ad3-159">Typ zdefiniowany przez użytkownika z deconstructing odrzuca</span><span class="sxs-lookup"><span data-stu-id="f0ad3-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="f0ad3-160">Podobnie jak w [krotek](#deconstructing-tuple-elements-with-discards), można zignorować wybranych elementów zwróconych przez odrzucenia `Deconstruct` metody.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="f0ad3-161">Każdy odrzucenia jest definiowana za pomocą zmiennej o nazwie "\_", i operacją pojedynczego deconstruction może obejmować wiele odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="f0ad3-162">Poniższy przykład deconstructs `Person` obiektu do czterech ciągów (imiona i nazwiska, miasta i stan) ale odrzuca nazwisko i stanu.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="f0ad3-163">Deconstructing typu zdefiniowanego przez użytkownika z metody rozszerzenia</span><span class="sxs-lookup"><span data-stu-id="f0ad3-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="f0ad3-164">Jeśli nie możesz tworzyć klasy, struktury lub interfejsu, można nadal deconstruct obiekty tego typu, implementując co najmniej jeden `Deconstruct` [metody rozszerzenia](programming-guide/classes-and-structs/extension-methods.md) zwracać wartości, w których Cię.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span> 

<span data-ttu-id="f0ad3-165">W poniższym przykładzie zdefiniowano dwa `Deconstruct` metody rozszerzenia dla <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="f0ad3-166">Pierwszy zwraca zestaw wartości, których wskazania charakterystyki właściwości, w tym jego typ jest statyczny lub wystąpienia, czy jest tylko do odczytu i czy jest indeksowany.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="f0ad3-167">Drugi wskazuje właściwość ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="f0ad3-168">Ponieważ dostępność elementu get i metody dostępu set może się różnić, wartościami logicznymi wskazują, czy właściwość zawiera osobne get i set metody dostępu i jeśli tak, czy mają one tą samą dostępnością.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="f0ad3-169">Czy istnieje tylko jedną metodę dostępu zarówno get, jak i metody dostępu set mieć tą samą dostępnością `access` zmienna wskazuje dostępność właściwość jako całość.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="f0ad3-170">W przeciwnym razie wartość dostępność get i set metody dostępu są oznaczone accessaccessibility jest określane przez `getAccess` i `setAccess` zmiennych.</span><span class="sxs-lookup"><span data-stu-id="f0ad3-170">Otherwise, the accessibility of the get and set accessors are indicated by the accessaccessibility is indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]
 
## <a name="see-also"></a><span data-ttu-id="f0ad3-171">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="f0ad3-171">See also</span></span>
<span data-ttu-id="f0ad3-172">[Odrzuca](discards.md) </span><span class="sxs-lookup"><span data-stu-id="f0ad3-172">[Discards](discards.md) </span></span>  
[<span data-ttu-id="f0ad3-173">Krotki</span><span class="sxs-lookup"><span data-stu-id="f0ad3-173">Tuples</span></span>](tuples.md)  
