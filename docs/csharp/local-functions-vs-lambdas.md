---
title: Funkcje lokalne a wyrażenia lambda
description: Dowiedz się, dlaczego funkcje lokalne mogą być lepszym wyborem niż wyrażenia lambda.
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 13cc3fe47bbcd6a465347a6c991b2006586c78fa
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173344"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="c2997-103">Funkcje lokalne w porównaniu z wyrażeniami lambda</span><span class="sxs-lookup"><span data-stu-id="c2997-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="c2997-104">Na pierwszy rzut oka [funkcje lokalne](programming-guide/classes-and-structs/local-functions.md) i [wyrażenia lambda](./programming-guide/statements-expressions-operators/lambda-expressions.md) są bardzo podobne.</span><span class="sxs-lookup"><span data-stu-id="c2997-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="c2997-105">W wielu przypadkach wybór między używaniem wyrażeń lambda a funkcjami lokalnymi jest kwestią stylu i osobistych preferencji.</span><span class="sxs-lookup"><span data-stu-id="c2997-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="c2997-106">Istnieją jednak rzeczywiste różnice w tym, gdzie można użyć jednego lub drugiego, że należy pamiętać.</span><span class="sxs-lookup"><span data-stu-id="c2997-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="c2997-107">Przyjrzyjmy się różnice między funkcji lokalnej i lambda wyrażenie implementacje algorytmu czynnikowego.</span><span class="sxs-lookup"><span data-stu-id="c2997-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="c2997-108">Najpierw wersja za pomocą funkcji lokalnej:</span><span class="sxs-lookup"><span data-stu-id="c2997-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="c2997-109">Kontrast, że implementacja z wersją, która używa wyrażeń lambda:</span><span class="sxs-lookup"><span data-stu-id="c2997-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="c2997-110">Funkcje lokalne mają nazwy.</span><span class="sxs-lookup"><span data-stu-id="c2997-110">The local functions have names.</span></span> <span data-ttu-id="c2997-111">Wyrażenia lambda są metody anonimowe, które są przypisane `Func` `Action` do zmiennych, które są lub typy.</span><span class="sxs-lookup"><span data-stu-id="c2997-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="c2997-112">Podczas deklarowania funkcji lokalnej typy argumentów i zwracane są częścią deklaracji funkcji.</span><span class="sxs-lookup"><span data-stu-id="c2997-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="c2997-113">Zamiast być częścią treści wyrażenia lambda, typy argumentów i zwracane są częścią deklaracji typu zmiennego wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="c2997-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="c2997-114">Te dwie różnice mogą spowodować jaśniejszy kod.</span><span class="sxs-lookup"><span data-stu-id="c2997-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="c2997-115">Funkcje lokalne mają inne reguły dla określonego przypisania niż wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="c2997-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="c2997-116">Deklaracja funkcji lokalnej można odwoływać się z dowolnej lokalizacji kodu, gdzie jest w zakresie.</span><span class="sxs-lookup"><span data-stu-id="c2997-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="c2997-117">Wyrażenie lambda musi być przypisane do zmiennej delegata, zanim będzie dostępny (lub wywoływany za pośrednictwem delegata odwołującego się do wyrażenia lambda). Należy zauważyć, że wersja przy użyciu wyrażenia lambda musi zadeklarować i zainicjować wyrażenie lambda, `nthFactorial` przed zdefiniowaniem go.</span><span class="sxs-lookup"><span data-stu-id="c2997-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="c2997-118">Nie wykonanie tego powoduje błąd czasu kompilacji `nthFactorial` dla odwoływania się przed przypisaniem go.</span><span class="sxs-lookup"><span data-stu-id="c2997-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="c2997-119">Różnice te oznaczają, że algorytmy cykliczne są łatwiejsze do tworzenia przy użyciu funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="c2997-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="c2997-120">Można zadeklarować i zdefiniować funkcję lokalną, która wywołuje się.</span><span class="sxs-lookup"><span data-stu-id="c2997-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="c2997-121">Wyrażenia Lambda muszą być zadeklarowane i przypisane wartość domyślną, zanim będą mogły być ponownie przypisane do treści, która odwołuje się do tego samego wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="c2997-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="c2997-122">Reguły przypisania określonego również wpływać na wszystkie zmienne, które są przechwytywane przez funkcję lokalną lub lambda wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="c2997-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="c2997-123">Zarówno funkcje lokalne, jak i reguły wyrażenia lambda wymagają, aby wszystkie przechwycone zmienne były zdecydowanie przypisywane w punkcie, w którym funkcja lokalna lub wyrażenie lambda są konwertowane na pełnomocnika.</span><span class="sxs-lookup"><span data-stu-id="c2997-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="c2997-124">Różnica polega na tym, że wyrażenia lambda są konwertowane na delegatów, gdy są one zadeklarowane.</span><span class="sxs-lookup"><span data-stu-id="c2997-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="c2997-125">Funkcje lokalne są konwertowane na delegatów tylko wtedy, gdy są używane jako pełnomocnik.</span><span class="sxs-lookup"><span data-stu-id="c2997-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="c2997-126">Jeśli deklarujesz funkcję lokalną i odwołujesz się do niej tylko, wywołując ją jak metodę, nie zostanie ona przekonwertowana na pełnomocnika.</span><span class="sxs-lookup"><span data-stu-id="c2997-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="c2997-127">Ta reguła umożliwia zadeklarowanie funkcji lokalnej w dowolnej dogodnej lokalizacji w jej otaczającym zakresie.</span><span class="sxs-lookup"><span data-stu-id="c2997-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="c2997-128">Często deklaruje się funkcje lokalne na końcu metody nadrzędnej, po wszystkich instrukcjach zwrotu.</span><span class="sxs-lookup"><span data-stu-id="c2997-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="c2997-129">Po trzecie kompilator może wykonać analizę statyczną, która umożliwia funkcje lokalne, aby zdecydowanie przypisać przechwycone zmienne w otaczającym zakresie.</span><span class="sxs-lookup"><span data-stu-id="c2997-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="c2997-130">Rozważmy następujący przykład:</span><span class="sxs-lookup"><span data-stu-id="c2997-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="c2997-131">Kompilator można `LocalFunction` określić, `y` że zdecydowanie przypisuje po wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="c2997-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="c2997-132">Ponieważ `LocalFunction` jest wywoływana przed instrukcją, `return` `y` `return` jest zdecydowanie przypisany do instrukcji.</span><span class="sxs-lookup"><span data-stu-id="c2997-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="c2997-133">Analiza, która umożliwia analizę przykładową, umożliwia czwartą różnicę.</span><span class="sxs-lookup"><span data-stu-id="c2997-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="c2997-134">W zależności od ich użycia funkcje lokalne można uniknąć alokacji sterty, które są zawsze niezbędne dla wyrażeń lambda.</span><span class="sxs-lookup"><span data-stu-id="c2997-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="c2997-135">Jeśli funkcja lokalna nigdy nie jest konwertowana na delegata, a żadna ze zmiennych przechwyconych przez funkcję lokalną nie jest przechwytywana przez inne lambdas lub funkcje lokalne, które są konwertowane na delegatów, kompilator może uniknąć alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="c2997-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="c2997-136">Rozważmy ten przykład asynchronii:</span><span class="sxs-lookup"><span data-stu-id="c2997-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="c2997-137">Zamknięcie dla tego wyrażenia lambda `index` `name` zawiera `address`, i zmienne.</span><span class="sxs-lookup"><span data-stu-id="c2997-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="c2997-138">W przypadku funkcji lokalnych obiekt, który implementuje zamknięcie `struct` może być typem.</span><span class="sxs-lookup"><span data-stu-id="c2997-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="c2997-139">Ten typ struktury będzie przekazywany przez odwołanie do funkcji lokalnej.</span><span class="sxs-lookup"><span data-stu-id="c2997-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="c2997-140">Ta różnica we wdrażaniu pozwoli zaoszczędzić na alokacji.</span><span class="sxs-lookup"><span data-stu-id="c2997-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="c2997-141">Wystąpienie niezbędne dla wyrażeń lambda oznacza dodatkowe alokacje pamięci, które mogą być czynnikiem wydajności w ścieżkach kodu o krytycznym znaczeniu dla czasu.</span><span class="sxs-lookup"><span data-stu-id="c2997-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="c2997-142">Funkcje lokalne nie ponoszą tego narzutu.</span><span class="sxs-lookup"><span data-stu-id="c2997-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="c2997-143">W powyższym przykładzie wersja funkcji lokalnych ma 2 mniej alokacji niż wersja wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="c2997-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="c2997-144">Odpowiednik funkcji lokalnej tej metody używa również klasy do zamknięcia.</span><span class="sxs-lookup"><span data-stu-id="c2997-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="c2997-145">Czy zamknięcie dla funkcji lokalnej jest `class` implementowana `struct` jako lub a jest szczegół implementacji.</span><span class="sxs-lookup"><span data-stu-id="c2997-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="c2997-146">Funkcja lokalna `struct` może używać, podczas gdy lambda zawsze będzie używać `class`.</span><span class="sxs-lookup"><span data-stu-id="c2997-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="c2997-147">Jedną z zalet końcowych nie wykazano w tym przykładzie jest, że `yield return` funkcje lokalne mogą być implementowane jako iteratory, przy użyciu składni do tworzenia sekwencji wartości.</span><span class="sxs-lookup"><span data-stu-id="c2997-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="c2997-148">Instrukcja `yield return` nie jest dozwolone w wyrażeniach lambda.</span><span class="sxs-lookup"><span data-stu-id="c2997-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="c2997-149">Podczas gdy funkcje lokalne mogą wydawać się zbędne dla wyrażeń lambda, w rzeczywistości służą one różnym celom i mają różne zastosowania.</span><span class="sxs-lookup"><span data-stu-id="c2997-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="c2997-150">Funkcje lokalne są bardziej efektywne dla przypadku, gdy chcesz napisać funkcję, która jest wywoływana tylko z kontekstu innej metody.</span><span class="sxs-lookup"><span data-stu-id="c2997-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
