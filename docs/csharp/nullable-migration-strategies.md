---
title: Zaktualizuj bazę kodu w celu użycia typów referencyjnych dopuszczających wartości null
description: Wybierz najlepszą strategię uaktualniania bazy kodu do używania typów referencyjnych dopuszczających wartość null.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: ab0970247c7e3f3c20d7fdb40ef035c4ba1d8b01
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2020
ms.locfileid: "95099327"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="b03b6-103">Aktualizowanie bibliotek do używania typów referencyjnych dopuszczających wartości null i przekazywanie reguł dopuszczających wartość null do wywoływania</span><span class="sxs-lookup"><span data-stu-id="b03b6-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="b03b6-104">Dodanie [typów referencyjnych dopuszczających wartość null](nullable-references.md) oznacza, czy można zadeklarować, czy `null` wartość jest dozwolona, czy nieoczekiwana dla każdej zmiennej.</span><span class="sxs-lookup"><span data-stu-id="b03b6-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="b03b6-105">Ponadto można zastosować wiele atrybutów:,,,,, `AllowNull` `DisallowNull` `MaybeNull` `NotNull` `NotNullWhen` `MaybeNullWhen` , i `NotNullIfNotNull` Aby całkowicie opisać Stany null argumentu i wartości zwracane.</span><span class="sxs-lookup"><span data-stu-id="b03b6-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="b03b6-106">Zapewnia to doskonałe środowisko podczas pisania kodu.</span><span class="sxs-lookup"><span data-stu-id="b03b6-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="b03b6-107">Są wyświetlane ostrzeżenia, jeśli zmienna niedopuszczający wartości null może być ustawiona na wartość `null` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="b03b6-108">Są wyświetlane ostrzeżenia, jeśli zmienna dopuszczająca wartość null nie jest sprawdzana przed usunięciem odwołania do niej.</span><span class="sxs-lookup"><span data-stu-id="b03b6-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="b03b6-109">Aktualizowanie bibliotek może zająć trochę czasu, ale Payoffs.</span><span class="sxs-lookup"><span data-stu-id="b03b6-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="b03b6-110">Więcej informacji udostępnianych kompilatorowi o tym, *kiedy* `null` wartość jest dozwolona lub zabroniona, użytkownicy otrzymają lepszych ostrzeżeń dotyczących interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="b03b6-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="b03b6-111">Zacznijmy od znanego przykładu.</span><span class="sxs-lookup"><span data-stu-id="b03b6-111">Let's start with a familiar example.</span></span> <span data-ttu-id="b03b6-112">Wyobraź sobie, że biblioteka zawiera następujący interfejs API do pobrania ciągu zasobu:</span><span class="sxs-lookup"><span data-stu-id="b03b6-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="b03b6-113">Poprzedni przykład jest zgodny ze znajomym `Try*` wzorcem w programie .NET.</span><span class="sxs-lookup"><span data-stu-id="b03b6-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="b03b6-114">Istnieją dwa argumenty odwołania dla tego interfejsu API: `key` i `message` parametru.</span><span class="sxs-lookup"><span data-stu-id="b03b6-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="b03b6-115">Ten interfejs API ma następujące reguły dotyczące wartości null tych argumentów:</span><span class="sxs-lookup"><span data-stu-id="b03b6-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="b03b6-116">Obiekty wywołujące nie powinny być przekazywane `null` jako argument dla elementu `key` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="b03b6-117">Obiekty wywołujące mogą przekazywać zmienną, której wartość jest `null` argumentem dla `message` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="b03b6-118">Jeśli `TryGetMessage` Metoda zwraca `true` , wartość `message` nie jest równa null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="b03b6-119">Jeśli wartość zwracana jest `false,` wartością parametru `message` (i jego stan zerowy) ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="b03b6-120">Reguła dla `key` może być całkowicie wyrażona przez typ zmiennej: `key` powinien być typem referencyjnym, który nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="b03b6-121">`message`Parametr jest bardziej skomplikowany.</span><span class="sxs-lookup"><span data-stu-id="b03b6-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="b03b6-122">Umożliwia `null` jako argument, ale gwarantuje, że w przypadku powodzenia ten `out` argument nie ma wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="b03b6-123">W tych scenariuszach potrzebujesz bogatszego słownictwa do opisywania oczekiwań.</span><span class="sxs-lookup"><span data-stu-id="b03b6-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="b03b6-124">Aktualizacja biblioteki dla odwołań do wartości null wymaga więcej niż przestawianie `?` niektórych zmiennych i nazw typów.</span><span class="sxs-lookup"><span data-stu-id="b03b6-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="b03b6-125">Powyższy przykład pokazuje, że należy przejrzeć interfejsy API i uwzględnić oczekiwania dla każdego argumentu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="b03b6-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="b03b6-126">Należy wziąć pod uwagę gwarancje wartości zwracanej, a także wszystkie `out` lub `ref` argumenty dla zwracanej metody.</span><span class="sxs-lookup"><span data-stu-id="b03b6-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="b03b6-127">Następnie Przekaż te reguły do kompilatora, a kompilator dostarczy ostrzeżenia, gdy wywołujący nie przestrzegają tych reguł.</span><span class="sxs-lookup"><span data-stu-id="b03b6-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="b03b6-128">To działanie jest czasochłonne.</span><span class="sxs-lookup"><span data-stu-id="b03b6-128">This work takes time.</span></span> <span data-ttu-id="b03b6-129">Zacznijmy od strategii, aby dowiedzieć się, w jaki sposób biblioteka lub aplikacja doznała wartość null, przy jednoczesnym zrównoważeniu innych wymagań.</span><span class="sxs-lookup"><span data-stu-id="b03b6-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements.</span></span> <span data-ttu-id="b03b6-130">Zobaczysz, jak zrównoważyć bieżące programowanie, włączając typy referencyjne dopuszczające wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="b03b6-131">Nauczysz się wyzwań dla definicji typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="b03b6-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="b03b6-132">Dowiesz się, jak zastosować atrybuty do opisywania warunków wstępnych i postanowień dotyczących poszczególnych interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="b03b6-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="b03b6-133">Wybierz strategię dla typów referencyjnych dopuszczających wartość null</span><span class="sxs-lookup"><span data-stu-id="b03b6-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="b03b6-134">Pierwszy wybór polega na tym, czy typy odwołań dopuszczające wartość null mają być domyślnie włączone czy wyłączone.</span><span class="sxs-lookup"><span data-stu-id="b03b6-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="b03b6-135">Istnieją dwie strategie:</span><span class="sxs-lookup"><span data-stu-id="b03b6-135">You have two strategies:</span></span>

- <span data-ttu-id="b03b6-136">Włącz typy referencyjne dopuszczające wartość null dla całego projektu i wyłącz je w kodzie, który nie jest gotowy.</span><span class="sxs-lookup"><span data-stu-id="b03b6-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="b03b6-137">Włącz tylko typy referencyjne dopuszczające wartość null dla kodu, który jest oznaczony adnotacją dla typów referencyjnych dopuszczających wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="b03b6-138">Pierwsza strategia działa najlepiej, gdy dodajesz inne funkcje do biblioteki, gdy zaktualizujesz ją do typów referencyjnych dopuszczających wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="b03b6-139">Cały nowy projekt ma świadomość dopuszczający wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-139">All new development is nullable aware.</span></span> <span data-ttu-id="b03b6-140">Gdy aktualizujesz istniejący kod, włączasz typy odwołań do wartości null w tych klasach.</span><span class="sxs-lookup"><span data-stu-id="b03b6-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="b03b6-141">Postępując zgodnie z pierwszą strategią, wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="b03b6-141">Following this first strategy, you do the following steps:</span></span>

1. <span data-ttu-id="b03b6-142">Włącz typy referencyjne dopuszczające wartość null dla całego projektu przez dodanie `<Nullable>enable</Nullable>` elementu do plików *csproj* .</span><span class="sxs-lookup"><span data-stu-id="b03b6-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="b03b6-143">Dodaj `#nullable disable` pragmę do każdego pliku źródłowego w projekcie.</span><span class="sxs-lookup"><span data-stu-id="b03b6-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="b03b6-144">Podczas pracy nad każdym plikiem Usuń pragmę i rozwiąż wszelkie ostrzeżenia.</span><span class="sxs-lookup"><span data-stu-id="b03b6-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="b03b6-145">Ta pierwsza strategia ma więcej zadań z góry, aby dodać pragmę do każdego pliku.</span><span class="sxs-lookup"><span data-stu-id="b03b6-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="b03b6-146">Korzyść polega na tym, że każdy nowy plik kodu dodany do projektu będzie miał włączoną wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="b03b6-147">Każda nowa służbowa będzie mieć świadomość wartości null; należy zaktualizować tylko istniejący kod.</span><span class="sxs-lookup"><span data-stu-id="b03b6-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="b03b6-148">Druga strategia działa lepiej, jeśli biblioteka jest stabilna, a głównym celem rozwoju jest przyjęcie typów referencyjnych dopuszczających wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-148">The second strategy works better if the library is stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="b03b6-149">W przypadku dodawania adnotacji do interfejsów API należy włączyć typy odwołań do wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="b03b6-150">Po zakończeniu włączać dla całego projektu typy referencyjne dopuszczające wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="b03b6-151">Postępując zgodnie z tą drugą strategią, wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="b03b6-151">Following this second strategy you do the following steps:</span></span>

1. <span data-ttu-id="b03b6-152">Dodaj `#nullable enable` pragmę do pliku, dla którego chcesz wprowadzić wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="b03b6-153">Rozwiązywanie wszelkich ostrzeżeń.</span><span class="sxs-lookup"><span data-stu-id="b03b6-153">Address any warnings.</span></span>
1. <span data-ttu-id="b03b6-154">Wykonaj te dwa pierwsze kroki, dopóki cała biblioteka nie doznała wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="b03b6-155">Włącz Typy dopuszczające wartość null dla całego projektu przez dodanie `<Nullable>enable</Nullable>` elementu do plików *csproj* .</span><span class="sxs-lookup"><span data-stu-id="b03b6-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="b03b6-156">Usuń `#nullable enable` dyrektywy pragma, ponieważ nie są już potrzebne.</span><span class="sxs-lookup"><span data-stu-id="b03b6-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="b03b6-157">Ta druga strategia ma mniej pracy z góry.</span><span class="sxs-lookup"><span data-stu-id="b03b6-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="b03b6-158">Wadą jest to, że pierwsze zadanie podczas tworzenia nowego pliku to dodanie dyrektywy pragma i przekazanie jej do wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="b03b6-159">Jeśli wszyscy deweloperzy w zespole zapomnili, nowy kod jest teraz w zaległości prac, aby umożliwić sobie dopełnienie kodu do wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="b03b6-160">Które z tych strategii są wybierane, zależy od tego, jak dużo aktywnego programowania odbywa się w projekcie.</span><span class="sxs-lookup"><span data-stu-id="b03b6-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="b03b6-161">Im bardziej dojrzały i stabilny projekt, tym lepiej druga strategia.</span><span class="sxs-lookup"><span data-stu-id="b03b6-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="b03b6-162">Im więcej funkcji jest opracowywanych, tym lepsza jest pierwsza strategia.</span><span class="sxs-lookup"><span data-stu-id="b03b6-162">The more features being developed, the better the first strategy.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b03b6-163">Globalny kontekst dopuszczający wartość null nie ma zastosowania do wygenerowanych plików kodu.</span><span class="sxs-lookup"><span data-stu-id="b03b6-163">The global nullable context does not apply for generated code files.</span></span> <span data-ttu-id="b03b6-164">W ramach którejkolwiek z tych strategii kontekst dopuszczający wartość null jest *wyłączony* dla każdego pliku źródłowego oznaczonego jako wygenerowany.</span><span class="sxs-lookup"><span data-stu-id="b03b6-164">Under either strategy, the nullable context is *disabled* for any source file marked as generated.</span></span> <span data-ttu-id="b03b6-165">Oznacza to, że wszystkie interfejsy API w wygenerowanych plikach nie są adnotacjami.</span><span class="sxs-lookup"><span data-stu-id="b03b6-165">This means any APIs in generated files are not annotated.</span></span> <span data-ttu-id="b03b6-166">Istnieją cztery sposoby, aby plik został oznaczony jako wygenerowany:</span><span class="sxs-lookup"><span data-stu-id="b03b6-166">There are four ways a file is marked as generated:</span></span>
>
> 1. <span data-ttu-id="b03b6-167">W pliku. editorconfig Określ `generated_code = true` w sekcji, która odnosi się do tego plik.</span><span class="sxs-lookup"><span data-stu-id="b03b6-167">In the .editorconfig, specify `generated_code = true` in a section that applies to that file.</span></span>
> 1. <span data-ttu-id="b03b6-168">Umieść `<auto-generated>` lub `<auto-generated/>` w komentarzu w górnej części pliku.</span><span class="sxs-lookup"><span data-stu-id="b03b6-168">Put `<auto-generated>` or `<auto-generated/>` in a comment at the top of the file.</span></span> <span data-ttu-id="b03b6-169">Może znajdować się w dowolnym wierszu tego komentarza, ale blok komentarza musi być pierwszym elementem w pliku.</span><span class="sxs-lookup"><span data-stu-id="b03b6-169">It can be on any line in that comment, but the comment block must be the first element in the file.</span></span>
> 1. <span data-ttu-id="b03b6-170">Uruchom nazwę pliku z *TemporaryGeneratedFile_*</span><span class="sxs-lookup"><span data-stu-id="b03b6-170">Start the file name with *TemporaryGeneratedFile_*</span></span>
> 1. <span data-ttu-id="b03b6-171">Zakończ nazwę pliku z rozszerzeniem *. Designer.cs*, *. generated.cs*, *. g.cs* lub *. g.i.cs*.</span><span class="sxs-lookup"><span data-stu-id="b03b6-171">End the file name with *.designer.cs*, *.generated.cs*, *.g.cs*, or *.g.i.cs*.</span></span>
>
> <span data-ttu-id="b03b6-172">Generatory mogą wyrazić zgodę na użycie [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="b03b6-172">Generators can opt-in using the [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) preprocessor directive.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="b03b6-173">Czy ostrzeżenia o wartościach null wprowadzają istotne zmiany?</span><span class="sxs-lookup"><span data-stu-id="b03b6-173">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="b03b6-174">Przed włączeniem typów referencyjnych dopuszczających wartości null, zmienne są uznawane za *Oblivious dopuszczające wartość null*.</span><span class="sxs-lookup"><span data-stu-id="b03b6-174">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="b03b6-175">Po włączeniu typów referencyjnych dopuszczających wartości null wszystkie te zmienne *nie dopuszczają wartości null*.</span><span class="sxs-lookup"><span data-stu-id="b03b6-175">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="b03b6-176">Kompilator będzie wystawiał ostrzeżenia, jeśli te zmienne nie są zainicjowane do wartości innych niż null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-176">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="b03b6-177">Inne prawdopodobnie Źródło ostrzeżeń ma zwracane wartości, gdy wartość nie została zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="b03b6-177">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="b03b6-178">Pierwszym krokiem w rozwiązywaniu ostrzeżeń kompilatora jest użycie `?` adnotacji dla parametrów i zwracanych typów, aby wskazać, kiedy argumenty lub wartości zwracane mogą mieć wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-178">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="b03b6-179">Gdy zmienne odwołania nie mogą mieć wartości null, oryginalna deklaracja jest poprawna.</span><span class="sxs-lookup"><span data-stu-id="b03b6-179">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="b03b6-180">W miarę wykonywania tego zadania nie można tylko naprawić ostrzeżeń.</span><span class="sxs-lookup"><span data-stu-id="b03b6-180">As you do this task, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="b03b6-181">Im bardziej istotny jest sposób, aby kompilator mógł zrozumieć zamiar dla potencjalnych wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-181">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="b03b6-182">Podczas badania ostrzeżeń możesz przejść do następnej głównej decyzji dotyczącej biblioteki.</span><span class="sxs-lookup"><span data-stu-id="b03b6-182">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="b03b6-183">Czy chcesz rozważyć modyfikowanie sygnatur interfejsów API, aby dokładniej komunikować swój projekt?</span><span class="sxs-lookup"><span data-stu-id="b03b6-183">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="b03b6-184">Lepszym podpisem interfejsu API dla `TryGetMessage` metody analizowanej wcześniej mogą być:</span><span class="sxs-lookup"><span data-stu-id="b03b6-184">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="b03b6-185">Wartość zwracana wskazuje powodzenie lub niepowodzenie i przenosi wartość w przypadku znalezienia wartości.</span><span class="sxs-lookup"><span data-stu-id="b03b6-185">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="b03b6-186">W wielu przypadkach zmiana sygnatur interfejsów API może poprawić sposób, w jaki komunikują się wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-186">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="b03b6-187">Jednak w przypadku bibliotek publicznych lub bibliotek z dużymi bazami użytkowników można preferować nie wprowadzać żadnych zmian sygnatury interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="b03b6-187">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="b03b6-188">W tych przypadkach i innych wspólnych wzorców można zastosować atrybuty, aby dokładniej zdefiniować, kiedy może być argument lub wartość zwracana `null` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-188">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="b03b6-189">Bez względu na to, czy można zmienić powierzchnię interfejsu API, prawdopodobnie okaże się, że tylko adnotacje typu nie są wystarczające do opisywania `null` wartości argumentów lub zwracanych wartości.</span><span class="sxs-lookup"><span data-stu-id="b03b6-189">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="b03b6-190">W tych przypadkach można zastosować atrybuty, aby dokładniej opisać interfejs API.</span><span class="sxs-lookup"><span data-stu-id="b03b6-190">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="b03b6-191">Atrybuty rozszerzonego typu</span><span class="sxs-lookup"><span data-stu-id="b03b6-191">Attributes extend type annotations</span></span>

<span data-ttu-id="b03b6-192">Dodano kilka atrybutów w celu wyrażenia dodatkowych informacji o stanie null zmiennych.</span><span class="sxs-lookup"><span data-stu-id="b03b6-192">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="b03b6-193">Wszystkie kod, który zapisano przed C# 8 wprowadziły typy odwołań dopuszczających wartości null, miał *wartość null Oblivious*.</span><span class="sxs-lookup"><span data-stu-id="b03b6-193">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="b03b6-194">Oznacza to, że jakakolwiek zmienna typu referencyjnego może mieć wartość null, ale sprawdzanie wartości null nie jest wymagane.</span><span class="sxs-lookup"><span data-stu-id="b03b6-194">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="b03b6-195">Gdy kod *dopuszcza wartość null*, te reguły zostaną zmienione.</span><span class="sxs-lookup"><span data-stu-id="b03b6-195">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="b03b6-196">Typy odwołań nigdy nie powinny być `null` wartościami, a typy referencyjne dopuszczające wartość null muszą zostać sprawdzone przed `null` usunięciem odwołania.</span><span class="sxs-lookup"><span data-stu-id="b03b6-196">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="b03b6-197">Reguły interfejsów API mogą być bardziej skomplikowane, jak pokazano w `TryGetValue` scenariuszu interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="b03b6-197">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="b03b6-198">Wiele interfejsów API ma bardziej złożone reguły dla sytuacji, gdy zmienne mogą być lub niemożliwe `null` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-198">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="b03b6-199">W takich przypadkach atrybuty są używane do wyrażania tych reguł.</span><span class="sxs-lookup"><span data-stu-id="b03b6-199">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="b03b6-200">Atrybuty opisujące semantykę interfejsu API znajdują się w artykule na temat [atrybutów, które wpływają na analizę wartości null](./language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="b03b6-200">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="b03b6-201">Definicje generyczne i wartości null</span><span class="sxs-lookup"><span data-stu-id="b03b6-201">Generic definitions and nullability</span></span>

<span data-ttu-id="b03b6-202">Poprawne powiadamianie o stanie null typów ogólnych i metod ogólnych wymaga szczególnej uwagi.</span><span class="sxs-lookup"><span data-stu-id="b03b6-202">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="b03b6-203">Dodatkowa opieka wynika z faktu, że typ wartości null i typ referencyjny dopuszczający wartość null są zasadniczo różne.</span><span class="sxs-lookup"><span data-stu-id="b03b6-203">The extra care stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="b03b6-204">`int?`Jest synonimem dla `Nullable<int>` , w którym `string?` jest `string` atrybut dodany przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="b03b6-204">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="b03b6-205">Wynika to z tego, że kompilator nie może wygenerować poprawnego kodu dla programu `T?` bez znajomości if `T` `class` lub `struct` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-205">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="b03b6-206">Ten fakt nie oznacza, że nie można użyć typu dopuszczającego wartość null (typ wartości lub typ referencyjny) jako argumentu typu dla zamkniętego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="b03b6-206">This fact doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="b03b6-207">Oba `List<string?>` i `List<int?>` są prawidłowymi wystąpieniami `List<T>` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-207">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="b03b6-208">Oznacza to, że nie można użyć `T?` w deklaracji klasy generycznej ani metody bez ograniczeń.</span><span class="sxs-lookup"><span data-stu-id="b03b6-208">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="b03b6-209">Na przykład <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> nie zostanie zmieniony na Return `T?` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-209">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="b03b6-210">Ograniczenie to można przezwyciężyć, dodając `struct` `class` ograniczenie or.</span><span class="sxs-lookup"><span data-stu-id="b03b6-210">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="b03b6-211">W przypadku każdego z tych ograniczeń kompilator wie, jak generować kod dla obu `T` i `T?` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-211">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="b03b6-212">Możesz chcieć ograniczyć typy używane dla argumentu typu ogólnego jako niedopuszczające wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-212">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="b03b6-213">Można to zrobić, dodając `notnull` ograniczenie dla tego argumentu typu.</span><span class="sxs-lookup"><span data-stu-id="b03b6-213">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="b03b6-214">Po zastosowaniu tego ograniczenia argument typu nie może być typem dopuszczającym wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-214">When that constraint is applied, the type argument must not be a nullable type.</span></span>

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a><span data-ttu-id="b03b6-215">Właściwości późnego inicjowania, Transfer danych obiektów i wartości null</span><span class="sxs-lookup"><span data-stu-id="b03b6-215">Late-initialized properties, Data Transfer Objects, and nullability</span></span>

<span data-ttu-id="b03b6-216">Wskazanie wartości null właściwości, które są opóźnione, oznacza ustawienie po konstrukcji, może wymagać specjalnego założenia, aby zapewnić, że Klasa nadal prawidłowo wyraża pierwotny cel projektowania.</span><span class="sxs-lookup"><span data-stu-id="b03b6-216">Indicating the nullability of properties that are late-initialized, meaning set after construction, may require special consideration to ensure that your class continues to correctly express the original design intent.</span></span>

<span data-ttu-id="b03b6-217">Typy zawierające właściwości z opóźnieniem, takie jak obiekty Transfer danych (DTO), często są tworzone przez bibliotekę zewnętrzną, taką jak baza danych ORM (mapowanie relacyjne obiektów), Deserializator lub inny składnik, który automatycznie wypełnia właściwości z innego źródła.</span><span class="sxs-lookup"><span data-stu-id="b03b6-217">Types that contain late-initialized properties, such as Data Transfer Objects (DTOs), are often instantiated by an external library, like a database ORM (Object Relational Mapper), a deserializer, or some other component that automatically populates properties from another source.</span></span>

<span data-ttu-id="b03b6-218">Rozważmy następujące klasy DTO przed włączeniem typów referencyjnych dopuszczających wartości null, które reprezentują studenta:</span><span class="sxs-lookup"><span data-stu-id="b03b6-218">Consider the following DTO class, prior to enabling nullable reference types, that represents a student:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

<span data-ttu-id="b03b6-219">Celem projektowania (wskazywanym w tym przypadku przez `Required` atrybut) jest sugeruje, że w tym systemie `FirstName` właściwości i `LastName` są **obowiązkowe**, a tym samym nie wartości null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-219">The design intent (indicated in this case by the `Required` attribute) suggests that in this system, the `FirstName` and `LastName` properties are **mandatory**, and therefore not null.</span></span>

<span data-ttu-id="b03b6-220">`VehicleRegistration`Właściwość nie jest **obowiązkowa**, więc może mieć wartość null.</span><span class="sxs-lookup"><span data-stu-id="b03b6-220">The `VehicleRegistration` property is **not mandatory**, so may be null.</span></span>

<span data-ttu-id="b03b6-221">Po włączeniu typów referencyjnych dopuszczających wartości null można wskazać, które właściwości DTO mogą dopuszczać wartości null, spójne z pierwotnym zamiarem:</span><span class="sxs-lookup"><span data-stu-id="b03b6-221">When you enable nullable reference types, you want to indicate which properties on your DTO may be nullable, consistent with your original intent:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="b03b6-222">Dla tego DTO jedyną właściwością, która może mieć wartość null, jest ``VehicleRegistration`` .</span><span class="sxs-lookup"><span data-stu-id="b03b6-222">For this DTO, the only property that may be null is ``VehicleRegistration``.</span></span>

<span data-ttu-id="b03b6-223">Jednak kompilator generuje `CS8618` ostrzeżenia dla obu `FirstName` i `LastName` , wskazujący, że właściwości niedopuszczające wartości null są inicjowane.</span><span class="sxs-lookup"><span data-stu-id="b03b6-223">However, the compiler raises `CS8618` warnings for both `FirstName` and `LastName`, indicating the non-nullable properties are uninitialized.</span></span>

<span data-ttu-id="b03b6-224">Dostępne są trzy opcje, które umożliwiają rozwiązanie ostrzeżeń kompilatora w taki sposób, aby zachować oryginalny cel.</span><span class="sxs-lookup"><span data-stu-id="b03b6-224">There are three options available to you that resolve the compiler warnings in a way that maintains the original intent.</span></span> <span data-ttu-id="b03b6-225">Wszystkie te opcje są prawidłowe; należy wybrać ten, który najlepiej odpowiada stylowi kodowania i wymaganiom projektu.</span><span class="sxs-lookup"><span data-stu-id="b03b6-225">Any of these options are valid; you should choose the one that best suits your coding style and design requirements.</span></span>

### <a name="initialize-in-the-constructor"></a><span data-ttu-id="b03b6-226">Zainicjuj w konstruktorze</span><span class="sxs-lookup"><span data-stu-id="b03b6-226">Initialize in the constructor</span></span>

<span data-ttu-id="b03b6-227">Idealnym sposobem na rozwiązanie niezainicjowanych ostrzeżeń jest zainicjowanie właściwości w konstruktorze:</span><span class="sxs-lookup"><span data-stu-id="b03b6-227">The ideal way to resolve the uninitialized warnings is to initialize the properties in the constructor:</span></span>

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="b03b6-228">Takie podejście działa tylko wtedy, gdy biblioteka używana do tworzenia wystąpienia klasy obsługuje przekazywanie parametrów w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="b03b6-228">This approach only works if the library that you use to instantiate the class supports passing parameters in the constructor.</span></span>

<span data-ttu-id="b03b6-229">Biblioteka może obsługiwać przekazywanie *niektórych* właściwości w konstruktorze, ale nie wszystkich.</span><span class="sxs-lookup"><span data-stu-id="b03b6-229">A library may support passing *some* properties in the constructor, but not all.</span></span> <span data-ttu-id="b03b6-230">Na przykład EF Core obsługuje [powiązanie konstruktora](/ef/core/modeling/constructors) dla normalnych właściwości kolumn, ale nie właściwości nawigacji.</span><span class="sxs-lookup"><span data-stu-id="b03b6-230">For example, EF Core supports [constructor binding](/ef/core/modeling/constructors) for normal column properties, but not navigation properties.</span></span>

<span data-ttu-id="b03b6-231">Zapoznaj się z dokumentacją biblioteki, która tworzy wystąpienie klasy, aby zrozumieć zakres, do którego obsługuje powiązanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="b03b6-231">Check the documentation on the library that instantiates your class, to understand the extent to which it supports constructor binding.</span></span>

### <a name="property-with-nullable-backing-field"></a><span data-ttu-id="b03b6-232">Właściwość z polem zapasowym dopuszczającym wartość null</span><span class="sxs-lookup"><span data-stu-id="b03b6-232">Property with nullable backing field</span></span>

<span data-ttu-id="b03b6-233">Jeśli powiązanie konstruktora nie będzie działało dla Ciebie, jednym ze sposobów na zaradzenie sobie z tym problemem jest posiadanie właściwości niedopuszczających wartości null przy użyciu pola zapasowego dopuszczającego wartość null:</span><span class="sxs-lookup"><span data-stu-id="b03b6-233">If constructor binding won't work for you, one way to deal with this problem is to have a non-nullable property with a nullable backing field:</span></span>

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

<span data-ttu-id="b03b6-234">W tym scenariuszu, jeśli `FirstName` dostęp do właściwości zostanie uzyskany przed jej zainicjowaniem, kod zgłosi `InvalidOperationException` , ponieważ kontrakt interfejsu API został użyty nieprawidłowo.</span><span class="sxs-lookup"><span data-stu-id="b03b6-234">In this scenario, if the `FirstName` property is accessed before it has been initialized, then the code throws an `InvalidOperationException`, because the API contract has been used incorrectly.</span></span>

<span data-ttu-id="b03b6-235">Należy wziąć pod uwagę, że niektóre biblioteki mogą mieć specjalne uwagi dotyczące korzystania z pól zapasowych.</span><span class="sxs-lookup"><span data-stu-id="b03b6-235">Consider that some libraries may have special considerations when using backing fields.</span></span> <span data-ttu-id="b03b6-236">Na przykład może być konieczne skonfigurowanie EF Core, aby prawidłowo używać [pól zapasowych](/ef/core/modeling/backing-field) .</span><span class="sxs-lookup"><span data-stu-id="b03b6-236">For example, EF Core may need to be configured to use [backing fields](/ef/core/modeling/backing-field) correctly.</span></span>

### <a name="initialize-the-property-to-null"></a><span data-ttu-id="b03b6-237">Zainicjuj Właściwość wartością null</span><span class="sxs-lookup"><span data-stu-id="b03b6-237">Initialize the property to null</span></span>

<span data-ttu-id="b03b6-238">Terser alternatywą dla korzystania z pola zapasowego dopuszczającego wartość null lub jeśli biblioteka, która tworzy wystąpienie klasy, nie jest zgodna z tym podejściem, można zainicjować właściwość `null` bezpośrednio, z pomocą operatora null-łagodniejszej ( `!` ):</span><span class="sxs-lookup"><span data-stu-id="b03b6-238">As a terser alternative to using a nullable backing field, or if the library that instantiates your class isn't compatible with that approach, you can initialize the property to `null` directly, with the help of the null-forgiving operator (`!`):</span></span>

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

<span data-ttu-id="b03b6-239">W czasie wykonywania nigdy nie obserwujesz rzeczywistej wartości null, chyba że w wyniku błędu programowania, uzyskując dostęp do właściwości, zanim zostanie on prawidłowo zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="b03b6-239">You'll never observe an actual null value at runtime except as a result of a programming bug, by accessing the property before it has been properly initialized.</span></span>

## <a name="see-also"></a><span data-ttu-id="b03b6-240">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="b03b6-240">See also</span></span>

- [<span data-ttu-id="b03b6-241">Migrowanie istniejącej bazy kodu do odwołań do wartości null</span><span class="sxs-lookup"><span data-stu-id="b03b6-241">Migrate an existing codebase to nullable references</span></span>](tutorials/upgrade-to-nullable-references.md)
- [<span data-ttu-id="b03b6-242">Praca z typami odwołań do wartości null w EF Core</span><span class="sxs-lookup"><span data-stu-id="b03b6-242">Working with Nullable Reference Types in EF Core</span></span>](/ef/core/miscellaneous/nullable-reference-types)
