---
title: Zaktualizuj bazę kodu w celu użycia typów referencyjnych dopuszczających wartości null
description: Wybierz najlepszą strategię uaktualniania bazy kodu do używania typów referencyjnych dopuszczających wartość null.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: 5909eb9ffe1f5398fc2eb74848b82f8fe9516548
ms.sourcegitcommit: fff146ba3fd1762c8c432d95c8b877825ae536fc
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/08/2020
ms.locfileid: "82975334"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="6a66e-103">Aktualizowanie bibliotek do używania typów referencyjnych dopuszczających wartości null i przekazywanie reguł dopuszczających wartość null do wywoływania</span><span class="sxs-lookup"><span data-stu-id="6a66e-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="6a66e-104">Dodanie [typów referencyjnych dopuszczających wartość null](nullable-references.md) oznacza, czy można zadeklarować, czy `null` wartość jest dozwolona, czy nieoczekiwana dla każdej zmiennej.</span><span class="sxs-lookup"><span data-stu-id="6a66e-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="6a66e-105">Ponadto można zastosować wiele atrybutów `AllowNull`:, `DisallowNull`, `MaybeNull` `NotNull` `NotNullWhen`,,, `MaybeNullWhen`, i `NotNullIfNotNull` aby całkowicie opisać Stany null argumentu i wartości zwracane.</span><span class="sxs-lookup"><span data-stu-id="6a66e-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="6a66e-106">Zapewnia to doskonałe środowisko podczas pisania kodu.</span><span class="sxs-lookup"><span data-stu-id="6a66e-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="6a66e-107">Są wyświetlane ostrzeżenia, jeśli zmienna niedopuszczający wartości null może być `null`ustawiona na wartość.</span><span class="sxs-lookup"><span data-stu-id="6a66e-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="6a66e-108">Są wyświetlane ostrzeżenia, jeśli zmienna dopuszczająca wartość null nie jest sprawdzana przed usunięciem odwołania do niej.</span><span class="sxs-lookup"><span data-stu-id="6a66e-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="6a66e-109">Aktualizowanie bibliotek może zająć trochę czasu, ale Payoffs.</span><span class="sxs-lookup"><span data-stu-id="6a66e-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="6a66e-110">Więcej informacji udostępnianych kompilatorowi o tym, *kiedy* `null` wartość jest dozwolona lub zabroniona, użytkownicy otrzymają lepszych ostrzeżeń dotyczących interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6a66e-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="6a66e-111">Zacznijmy od znanego przykładu.</span><span class="sxs-lookup"><span data-stu-id="6a66e-111">Let's start with a familiar example.</span></span> <span data-ttu-id="6a66e-112">Wyobraź sobie, że biblioteka zawiera następujący interfejs API do pobrania ciągu zasobu:</span><span class="sxs-lookup"><span data-stu-id="6a66e-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="6a66e-113">Poprzedni przykład jest zgodny ze znajomym `Try*` wzorcem w programie .NET.</span><span class="sxs-lookup"><span data-stu-id="6a66e-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="6a66e-114">Istnieją dwa argumenty odwołania dla tego interfejsu API: `key` i `message` parametru.</span><span class="sxs-lookup"><span data-stu-id="6a66e-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="6a66e-115">Ten interfejs API ma następujące reguły dotyczące wartości null tych argumentów:</span><span class="sxs-lookup"><span data-stu-id="6a66e-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="6a66e-116">Obiekty wywołujące nie `null` powinny być przekazywane jako `key`argument dla elementu.</span><span class="sxs-lookup"><span data-stu-id="6a66e-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="6a66e-117">Obiekty wywołujące mogą przekazywać zmienną, której `null` wartość jest argumentem `message`dla.</span><span class="sxs-lookup"><span data-stu-id="6a66e-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="6a66e-118">Jeśli `TryGetMessage` Metoda zwraca `true`, wartość `message` nie jest równa null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="6a66e-119">Jeśli wartość zwracana jest `false,` wartością parametru `message` (i jego stan zerowy) ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="6a66e-120">Reguła dla `key` może być całkowicie wyrażona przez typ zmiennej: `key` powinien być typem referencyjnym, który nie dopuszcza wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="6a66e-121">`message` Parametr jest bardziej skomplikowany.</span><span class="sxs-lookup"><span data-stu-id="6a66e-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="6a66e-122">Umożliwia `null` jako argument, ale gwarantuje, że w przypadku powodzenia ten `out` argument nie ma wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="6a66e-123">W tych scenariuszach potrzebujesz bogatszego słownictwa do opisywania oczekiwań.</span><span class="sxs-lookup"><span data-stu-id="6a66e-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="6a66e-124">Aktualizacja biblioteki dla odwołań do wartości null wymaga więcej niż `?` przestawianie niektórych zmiennych i nazw typów.</span><span class="sxs-lookup"><span data-stu-id="6a66e-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="6a66e-125">Powyższy przykład pokazuje, że należy przejrzeć interfejsy API i uwzględnić oczekiwania dla każdego argumentu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="6a66e-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="6a66e-126">Należy wziąć pod uwagę gwarancje wartości zwracanej, `out` a `ref` także wszystkie lub argumenty dla zwracanej metody.</span><span class="sxs-lookup"><span data-stu-id="6a66e-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="6a66e-127">Następnie Przekaż te reguły do kompilatora, a kompilator dostarczy ostrzeżenia, gdy wywołujący nie przestrzegają tych reguł.</span><span class="sxs-lookup"><span data-stu-id="6a66e-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="6a66e-128">To działanie jest czasochłonne.</span><span class="sxs-lookup"><span data-stu-id="6a66e-128">This work takes time.</span></span> <span data-ttu-id="6a66e-129">Zacznijmy od strategii, aby dowiedzieć się, jak Twoja biblioteka lub aplikacja doznała wartości null, a także zrównoważyć inne wymagania i elementy dostarczane.</span><span class="sxs-lookup"><span data-stu-id="6a66e-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements and deliverables.</span></span> <span data-ttu-id="6a66e-130">Zobaczysz, jak zrównoważyć bieżące programowanie, włączając typy referencyjne dopuszczające wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="6a66e-131">Nauczysz się wyzwań dla definicji typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="6a66e-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="6a66e-132">Dowiesz się, jak zastosować atrybuty do opisywania warunków wstępnych i postanowień dotyczących poszczególnych interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="6a66e-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="6a66e-133">Wybierz strategię dla typów referencyjnych dopuszczających wartość null</span><span class="sxs-lookup"><span data-stu-id="6a66e-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="6a66e-134">Pierwszy wybór polega na tym, czy typy odwołań dopuszczające wartość null mają być domyślnie włączone czy wyłączone.</span><span class="sxs-lookup"><span data-stu-id="6a66e-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="6a66e-135">Istnieją dwie strategie:</span><span class="sxs-lookup"><span data-stu-id="6a66e-135">You have two strategies:</span></span>

- <span data-ttu-id="6a66e-136">Włącz typy referencyjne dopuszczające wartość null dla całego projektu i wyłącz je w kodzie, który nie jest gotowy.</span><span class="sxs-lookup"><span data-stu-id="6a66e-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="6a66e-137">Włącz tylko typy referencyjne dopuszczające wartość null dla kodu, który jest oznaczony adnotacją dla typów referencyjnych dopuszczających wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="6a66e-138">Pierwsza strategia działa najlepiej, gdy dodajesz inne funkcje do biblioteki, gdy zaktualizujesz ją do typów referencyjnych dopuszczających wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="6a66e-139">Cały nowy projekt ma świadomość dopuszczający wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-139">All new development is nullable aware.</span></span> <span data-ttu-id="6a66e-140">Gdy aktualizujesz istniejący kod, włączasz typy odwołań do wartości null w tych klasach.</span><span class="sxs-lookup"><span data-stu-id="6a66e-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="6a66e-141">Postępując zgodnie z pierwszą strategią, wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="6a66e-141">Following this first strategy, you do the following:</span></span>

1. <span data-ttu-id="6a66e-142">Włącz typy referencyjne dopuszczające wartość null dla całego projektu `<Nullable>enable</Nullable>` przez dodanie elementu do plików *csproj* .</span><span class="sxs-lookup"><span data-stu-id="6a66e-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="6a66e-143">Dodaj `#nullable disable` pragmę do każdego pliku źródłowego w projekcie.</span><span class="sxs-lookup"><span data-stu-id="6a66e-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="6a66e-144">Podczas pracy nad każdym plikiem Usuń pragmę i rozwiąż wszelkie ostrzeżenia.</span><span class="sxs-lookup"><span data-stu-id="6a66e-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="6a66e-145">Ta pierwsza strategia ma więcej zadań z góry, aby dodać pragmę do każdego pliku.</span><span class="sxs-lookup"><span data-stu-id="6a66e-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="6a66e-146">Korzyść polega na tym, że każdy nowy plik kodu dodany do projektu będzie miał włączoną wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="6a66e-147">Każda nowa służbowa będzie mieć świadomość wartości null; należy zaktualizować tylko istniejący kod.</span><span class="sxs-lookup"><span data-stu-id="6a66e-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="6a66e-148">Druga strategia działa lepiej, jeśli biblioteka jest ogólnie stabilna, a głównym celem rozwoju jest przyjęcie typów referencyjnych dopuszczających wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-148">The second strategy works better if the library is generally stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="6a66e-149">W przypadku dodawania adnotacji do interfejsów API należy włączyć typy odwołań do wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="6a66e-150">Po zakończeniu włączać dla całego projektu typy referencyjne dopuszczające wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="6a66e-151">Postępując zgodnie z tą drugą strategią, należy wykonać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="6a66e-151">Following this second strategy you do the following:</span></span>

1. <span data-ttu-id="6a66e-152">Dodaj `#nullable enable` pragmę do pliku, dla którego chcesz wprowadzić wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="6a66e-153">Rozwiązywanie wszelkich ostrzeżeń.</span><span class="sxs-lookup"><span data-stu-id="6a66e-153">Address any warnings.</span></span>
1. <span data-ttu-id="6a66e-154">Wykonaj te dwa pierwsze kroki, dopóki cała biblioteka nie doznała wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="6a66e-155">Włącz Typy dopuszczające wartość null dla całego projektu przez `<Nullable>enable</Nullable>` dodanie elementu do plików *csproj* .</span><span class="sxs-lookup"><span data-stu-id="6a66e-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="6a66e-156">Usuń `#nullable enable` dyrektywy pragma, ponieważ nie są już potrzebne.</span><span class="sxs-lookup"><span data-stu-id="6a66e-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="6a66e-157">Ta druga strategia ma mniej pracy z góry.</span><span class="sxs-lookup"><span data-stu-id="6a66e-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="6a66e-158">Wadą jest to, że pierwsze zadanie podczas tworzenia nowego pliku to dodanie dyrektywy pragma i przekazanie jej do wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="6a66e-159">Jeśli wszyscy deweloperzy w zespole zapomnili, nowy kod jest teraz w zaległości prac, aby umożliwić sobie dopełnienie kodu do wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="6a66e-160">Które z tych strategii są wybierane, zależy od tego, jak dużo aktywnego programowania odbywa się w projekcie.</span><span class="sxs-lookup"><span data-stu-id="6a66e-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="6a66e-161">Im bardziej dojrzały i stabilny projekt, tym lepiej druga strategia.</span><span class="sxs-lookup"><span data-stu-id="6a66e-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="6a66e-162">Im więcej funkcji jest opracowywanych, tym lepsza jest pierwsza strategia.</span><span class="sxs-lookup"><span data-stu-id="6a66e-162">The more features being developed, the better the first strategy.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="6a66e-163">Czy ostrzeżenia o wartościach null wprowadzają istotne zmiany?</span><span class="sxs-lookup"><span data-stu-id="6a66e-163">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="6a66e-164">Przed włączeniem typów referencyjnych dopuszczających wartości null, zmienne są uznawane za *Oblivious dopuszczające wartość null*.</span><span class="sxs-lookup"><span data-stu-id="6a66e-164">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="6a66e-165">Po włączeniu typów referencyjnych dopuszczających wartości null wszystkie te zmienne *nie dopuszczają wartości null*.</span><span class="sxs-lookup"><span data-stu-id="6a66e-165">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="6a66e-166">Kompilator będzie wystawiał ostrzeżenia, jeśli te zmienne nie są zainicjowane do wartości innych niż null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-166">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="6a66e-167">Inne prawdopodobnie Źródło ostrzeżeń ma zwracane wartości, gdy wartość nie została zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="6a66e-167">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="6a66e-168">Pierwszym krokiem w rozwiązywaniu ostrzeżeń kompilatora jest użycie `?` adnotacji dla parametrów i zwracanych typów, aby wskazać, kiedy argumenty lub wartości zwracane mogą mieć wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-168">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="6a66e-169">Gdy zmienne odwołania nie mogą mieć wartości null, oryginalna deklaracja jest poprawna.</span><span class="sxs-lookup"><span data-stu-id="6a66e-169">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="6a66e-170">W takim przypadku cel nie tylko naprawi ostrzeżenia.</span><span class="sxs-lookup"><span data-stu-id="6a66e-170">As you do this, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="6a66e-171">Im bardziej istotny jest sposób, aby kompilator mógł zrozumieć zamiar dla potencjalnych wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-171">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="6a66e-172">Podczas badania ostrzeżeń możesz przejść do następnej głównej decyzji dotyczącej biblioteki.</span><span class="sxs-lookup"><span data-stu-id="6a66e-172">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="6a66e-173">Czy chcesz rozważyć modyfikowanie sygnatur interfejsów API, aby dokładniej komunikować swój projekt?</span><span class="sxs-lookup"><span data-stu-id="6a66e-173">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="6a66e-174">Lepszym podpisem interfejsu API `TryGetMessage` dla metody analizowanej wcześniej mogą być:</span><span class="sxs-lookup"><span data-stu-id="6a66e-174">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="6a66e-175">Wartość zwracana wskazuje powodzenie lub niepowodzenie i przenosi wartość w przypadku znalezienia wartości.</span><span class="sxs-lookup"><span data-stu-id="6a66e-175">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="6a66e-176">W wielu przypadkach zmiana sygnatur interfejsów API może poprawić sposób, w jaki komunikują się wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-176">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="6a66e-177">Jednak w przypadku bibliotek publicznych lub bibliotek z dużymi bazami użytkowników można preferować nie wprowadzać żadnych zmian sygnatury interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6a66e-177">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="6a66e-178">W tych przypadkach i innych wspólnych wzorców można zastosować atrybuty, aby dokładniej zdefiniować, kiedy może być `null`argument lub wartość zwracana.</span><span class="sxs-lookup"><span data-stu-id="6a66e-178">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="6a66e-179">Bez względu na to, czy można zmienić powierzchnię interfejsu API, prawdopodobnie okaże się, że tylko adnotacje typu nie są `null` wystarczające do opisywania wartości argumentów lub zwracanych wartości.</span><span class="sxs-lookup"><span data-stu-id="6a66e-179">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="6a66e-180">W tych przypadkach można zastosować atrybuty, aby dokładniej opisać interfejs API.</span><span class="sxs-lookup"><span data-stu-id="6a66e-180">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="6a66e-181">Atrybuty rozszerzonego typu</span><span class="sxs-lookup"><span data-stu-id="6a66e-181">Attributes extend type annotations</span></span>

<span data-ttu-id="6a66e-182">Dodano kilka atrybutów w celu wyrażenia dodatkowych informacji o stanie null zmiennych.</span><span class="sxs-lookup"><span data-stu-id="6a66e-182">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="6a66e-183">Wszystkie kod, który zapisano przed C# 8 wprowadziły typy odwołań dopuszczających wartości null, miał *wartość null Oblivious*.</span><span class="sxs-lookup"><span data-stu-id="6a66e-183">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="6a66e-184">Oznacza to, że jakakolwiek zmienna typu referencyjnego może mieć wartość null, ale sprawdzanie wartości null nie jest wymagane.</span><span class="sxs-lookup"><span data-stu-id="6a66e-184">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="6a66e-185">Gdy kod *dopuszcza wartość null*, te reguły zostaną zmienione.</span><span class="sxs-lookup"><span data-stu-id="6a66e-185">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="6a66e-186">Typy odwołań nigdy nie powinny być `null` wartościami, a typy referencyjne dopuszczające wartość null `null` muszą zostać sprawdzone przed usunięciem odwołania.</span><span class="sxs-lookup"><span data-stu-id="6a66e-186">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="6a66e-187">Reguły interfejsów API mogą być bardziej skomplikowane, jak pokazano w scenariuszu `TryGetValue` interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6a66e-187">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="6a66e-188">Wiele interfejsów API ma bardziej złożone reguły dla sytuacji, gdy zmienne mogą być `null`lub niemożliwe.</span><span class="sxs-lookup"><span data-stu-id="6a66e-188">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="6a66e-189">W takich przypadkach atrybuty są używane do wyrażania tych reguł.</span><span class="sxs-lookup"><span data-stu-id="6a66e-189">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="6a66e-190">Atrybuty opisujące semantykę interfejsu API znajdują się w artykule na temat [atrybutów, które wpływają na analizę wartości null](./language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="6a66e-190">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="6a66e-191">Definicje generyczne i wartości null</span><span class="sxs-lookup"><span data-stu-id="6a66e-191">Generic definitions and nullability</span></span>

<span data-ttu-id="6a66e-192">Poprawne powiadamianie o stanie null typów ogólnych i metod ogólnych wymaga szczególnej uwagi.</span><span class="sxs-lookup"><span data-stu-id="6a66e-192">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="6a66e-193">Wynika to z faktu, że typ wartości null i typ referencyjny dopuszczający wartość null są zasadniczo różne.</span><span class="sxs-lookup"><span data-stu-id="6a66e-193">This stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="6a66e-194">Jest `int?` synonimem dla `Nullable<int>`, w którym `string?` jest `string` atrybut dodany przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="6a66e-194">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="6a66e-195">Wynika to z tego, że kompilator nie może wygenerować `T?` poprawnego kodu `T` dla programu `class` bez znajomości `struct`if lub.</span><span class="sxs-lookup"><span data-stu-id="6a66e-195">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="6a66e-196">Nie oznacza to, że nie można użyć typu dopuszczającego wartości null (typu wartości lub typu referencyjnego) jako argumentu typu dla zamkniętego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="6a66e-196">This doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="6a66e-197">Oba `List<string?>` i `List<int?>` są prawidłowymi wystąpieniami `List<T>`.</span><span class="sxs-lookup"><span data-stu-id="6a66e-197">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="6a66e-198">Oznacza to, że nie można użyć `T?` w deklaracji klasy generycznej ani metody bez ograniczeń.</span><span class="sxs-lookup"><span data-stu-id="6a66e-198">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="6a66e-199">Na przykład <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> nie zostanie zmieniony na Return `T?`.</span><span class="sxs-lookup"><span data-stu-id="6a66e-199">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="6a66e-200">Ograniczenie to można przezwyciężyć, dodając `struct` ograniczenie `class` or.</span><span class="sxs-lookup"><span data-stu-id="6a66e-200">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="6a66e-201">W przypadku każdego z tych ograniczeń kompilator wie, jak generować kod dla obu `T` i. `T?`</span><span class="sxs-lookup"><span data-stu-id="6a66e-201">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="6a66e-202">Możesz chcieć ograniczyć typy używane dla argumentu typu ogólnego jako niedopuszczające wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-202">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="6a66e-203">Można to zrobić, dodając `notnull` ograniczenie dla tego argumentu typu.</span><span class="sxs-lookup"><span data-stu-id="6a66e-203">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="6a66e-204">Po zastosowaniu tego ograniczenia argument typu nie może być typem dopuszczającym wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-204">When that constraint is applied, the type argument must not be a nullable type.</span></span>

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a><span data-ttu-id="6a66e-205">Właściwości późnego inicjowania, Transfer danych obiektów i wartości null</span><span class="sxs-lookup"><span data-stu-id="6a66e-205">Late-initialized properties, Data Transfer Objects and nullability</span></span>

<span data-ttu-id="6a66e-206">Wskazanie wartości null właściwości, które są opóźnione, oznacza ustawienie po konstrukcji, może wymagać specjalnego założenia, aby zapewnić, że Klasa nadal prawidłowo wyraża pierwotny cel projektowania.</span><span class="sxs-lookup"><span data-stu-id="6a66e-206">Indicating the nullability of properties that are late-initialized, meaning set after construction, may require special consideration to ensure that your class continues to correctly express the original design intent.</span></span>

<span data-ttu-id="6a66e-207">Typy zawierające właściwości z opóźnieniem, takie jak obiekty Transfer danych (DTO), często są tworzone przez bibliotekę zewnętrzną, taką jak baza danych ORM (mapowanie relacyjne obiektów), Deserializator lub inny składnik, który automatycznie wypełnia właściwości z innego źródła.</span><span class="sxs-lookup"><span data-stu-id="6a66e-207">Types that contain late-initialized properties, such as Data Transfer Objects (DTOs), are often instantiated by an external library, like a database ORM (Object Relational Mapper), a deserializer, or some other component that automatically populates properties from another source.</span></span>

<span data-ttu-id="6a66e-208">Rozważmy następujące klasy DTO przed włączeniem typów referencyjnych dopuszczających wartości null, które reprezentują studenta:</span><span class="sxs-lookup"><span data-stu-id="6a66e-208">Consider the following DTO class, prior to enabling nullable reference types, that represents a student:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

<span data-ttu-id="6a66e-209">Celem projektowania (wskazywanym w tym przypadku `Required` przez atrybut) jest sugeruje, że w tym systemie właściwości `FirstName` i `LastName` są **obowiązkowe**, a tym samym nie wartości null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-209">The design intent (indicated in this case by the `Required` attribute) suggests that in this system, the `FirstName` and `LastName` properties are **mandatory**, and therefore not null.</span></span>

<span data-ttu-id="6a66e-210">`VehicleRegistration` Właściwość nie jest **obowiązkowa**, więc może mieć wartość null.</span><span class="sxs-lookup"><span data-stu-id="6a66e-210">The `VehicleRegistration` property is **not mandatory**, so may be null.</span></span>

<span data-ttu-id="6a66e-211">W przypadku włączania typów referencyjnych dopuszczających wartości null można wskazać DTO, które właściwości mogą dopuszczać wartości null, spójne z pierwotnym zamiarem:</span><span class="sxs-lookup"><span data-stu-id="6a66e-211">When you enable nullable reference types, you want to indicate on our DTO which of the properties may be nullable, consistent with your original intent:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="6a66e-212">Dla tego DTO jedyną właściwością, która może mieć wartość null ``VehicleRegistration``, jest.</span><span class="sxs-lookup"><span data-stu-id="6a66e-212">For this DTO, the only property that may be null is ``VehicleRegistration``.</span></span>

<span data-ttu-id="6a66e-213">Jednak kompilator generuje `CS8618` ostrzeżenia dla obu `FirstName` i `LastName`, wskazujący, że właściwości niedopuszczające wartości null są inicjowane.</span><span class="sxs-lookup"><span data-stu-id="6a66e-213">However, the compiler raises `CS8618` warnings for both `FirstName` and `LastName`, indicating the non-nullable properties are uninitialized.</span></span>

<span data-ttu-id="6a66e-214">Dostępne są trzy opcje, które umożliwiają rozwiązanie ostrzeżeń kompilatora w taki sposób, aby zachować oryginalny cel.</span><span class="sxs-lookup"><span data-stu-id="6a66e-214">There are three options available to you that resolve the compiler warnings in a way that maintains the original intent.</span></span> <span data-ttu-id="6a66e-215">Wszystkie te opcje są prawidłowe; należy wybrać ten, który najlepiej odpowiada stylowi kodowania i wymaganiom projektu.</span><span class="sxs-lookup"><span data-stu-id="6a66e-215">Any of these options are valid; you should choose the one that best suits your coding style and design requirements.</span></span>

### <a name="initialize-in-the-constructor"></a><span data-ttu-id="6a66e-216">Zainicjuj w konstruktorze</span><span class="sxs-lookup"><span data-stu-id="6a66e-216">Initialize in the constructor</span></span>

<span data-ttu-id="6a66e-217">Idealnym sposobem na rozwiązanie niezainicjowanych ostrzeżeń jest zainicjowanie właściwości w konstruktorze:</span><span class="sxs-lookup"><span data-stu-id="6a66e-217">The ideal way to resolve the uninitialized warnings is to initialize the properties in the constructor:</span></span>

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="6a66e-218">Takie podejście działa tylko wtedy, gdy biblioteka używana do tworzenia wystąpienia klasy obsługuje przekazywanie parametrów w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="6a66e-218">This approach only works if the library that you use to instantiate the class supports passing parameters in the constructor.</span></span>

<span data-ttu-id="6a66e-219">Ponadto biblioteka może obsługiwać przekazywanie *niektórych* właściwości w konstruktorze, ale nie wszystkich.</span><span class="sxs-lookup"><span data-stu-id="6a66e-219">In addition, a library may support passing *some* properties in the constructor, but not all.</span></span>
<span data-ttu-id="6a66e-220">Na przykład EF Core obsługuje [powiązanie konstruktora](/ef/core/modeling/constructors) dla normalnych właściwości kolumn, ale nie właściwości nawigacji.</span><span class="sxs-lookup"><span data-stu-id="6a66e-220">For example, EF Core supports [constructor binding](/ef/core/modeling/constructors) for normal column properties, but not navigation properties.</span></span>

<span data-ttu-id="6a66e-221">Zapoznaj się z dokumentacją biblioteki, która tworzy wystąpienie klasy, aby zrozumieć zakres, do którego obsługuje powiązanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="6a66e-221">Check the documentation on the library that instantiates your class, to understand the extent to which it supports constructor binding.</span></span>

### <a name="property-with-nullable-backing-field"></a><span data-ttu-id="6a66e-222">Właściwość z polem zapasowym dopuszczającym wartość null</span><span class="sxs-lookup"><span data-stu-id="6a66e-222">Property with nullable backing field</span></span>

<span data-ttu-id="6a66e-223">Jeśli powiązanie konstruktora nie będzie działało dla Ciebie, jednym ze sposobów na zaradzenie sobie z tym problemem jest posiadanie właściwości niedopuszczających wartości null przy użyciu pola zapasowego dopuszczającego wartość null:</span><span class="sxs-lookup"><span data-stu-id="6a66e-223">If constructor binding won't work for you, one way to deal with this problem is to have a non-nullable property with a nullable backing field:</span></span>

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

<span data-ttu-id="6a66e-224">W tym scenariuszu, jeśli `FirstName` dostęp do właściwości zostanie uzyskany przed jej zainicjowaniem, kod zgłosi `InvalidOperationException`, ponieważ kontrakt interfejsu API został użyty nieprawidłowo.</span><span class="sxs-lookup"><span data-stu-id="6a66e-224">In this scenario, if the `FirstName` property is accessed before it has been initialized, then the code throws an `InvalidOperationException`, because the API contract has been used incorrectly.</span></span>

<span data-ttu-id="6a66e-225">Należy wziąć pod uwagę, że niektóre biblioteki mogą mieć specjalne uwagi dotyczące korzystania z pól zapasowych.</span><span class="sxs-lookup"><span data-stu-id="6a66e-225">You should consider that some libraries may have special considerations when using backing fields.</span></span> <span data-ttu-id="6a66e-226">Na przykład może być konieczne skonfigurowanie EF Core, aby prawidłowo używać [pól zapasowych](/ef/core/modeling/backing-field) .</span><span class="sxs-lookup"><span data-stu-id="6a66e-226">For example, EF Core may need to be configured to use [backing fields](/ef/core/modeling/backing-field) correctly.</span></span>

### <a name="initialize-the-property-to-null"></a><span data-ttu-id="6a66e-227">Zainicjuj Właściwość wartością null</span><span class="sxs-lookup"><span data-stu-id="6a66e-227">Initialize the property to null</span></span>

<span data-ttu-id="6a66e-228">Terser alternatywą dla korzystania z pola zapasowego dopuszczającego wartość null lub jeśli biblioteka, która tworzy wystąpienie klasy, nie jest zgodna z tym podejściem, można po prostu `null` zainicjować właściwość bezpośrednio, z pomocą operatora null-łagodniejszej (`!`):</span><span class="sxs-lookup"><span data-stu-id="6a66e-228">As a terser alternative to using a nullable backing field, or if the library that instantiates your class is not compatible with that approach, you can simply initialize the property to `null` directly, with the help of the null-forgiving operator (`!`):</span></span>

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

<span data-ttu-id="6a66e-229">W czasie wykonywania nigdy nie będzie obserwować rzeczywistej wartości null, chyba że w wyniku błędu programowania, uzyskując dostęp do właściwości, zanim zostanie on prawidłowo zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="6a66e-229">You will never observe an actual null value at runtime except as a result of a programming bug, by accessing the property before it has been properly initialized.</span></span>

## <a name="see-also"></a><span data-ttu-id="6a66e-230">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="6a66e-230">See also</span></span>

- [<span data-ttu-id="6a66e-231">Migrowanie istniejącej bazy kodu do odwołań do wartości null</span><span class="sxs-lookup"><span data-stu-id="6a66e-231">Migrate an existing codebase to nullable references</span></span>](tutorials/upgrade-to-nullable-references.md)
- [<span data-ttu-id="6a66e-232">Praca z typami odwołań do wartości null w EF Core</span><span class="sxs-lookup"><span data-stu-id="6a66e-232">Working with Nullable Reference Types in EF Core</span></span>](/ef/core/miscellaneous/nullable-reference-types)
