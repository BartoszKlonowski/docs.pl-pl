---
title: Drzewa wyrażeń — objaśnienie
description: Informacje na temat drzew wyrażeń i jak są one przydatne do przekształcania algorytmy dla zewnętrznych wykonania i kontroli kodu przed jej wykonanie.
ms.date: 06/20/2016
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 3bad826bb58ff361688d3e13497343661e7edbd3
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61646608"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="1c1b0-103">Drzewa wyrażeń — objaśnienie</span><span class="sxs-lookup"><span data-stu-id="1c1b0-103">Expression Trees Explained</span></span>

[<span data-ttu-id="1c1b0-104">Poprzednie — omówienie</span><span class="sxs-lookup"><span data-stu-id="1c1b0-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="1c1b0-105">Drzewo wyrażenia jest strukturą danych, który definiuje kodu.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="1c1b0-106">Są one oparte na tych samych struktur, które kompilator używa do analizowania kodu i generuje skompilowanych danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="1c1b0-107">Omówione w tym samouczku, można zauważyć znacznej liczby podobieństwa między drzew wyrażeń i typy używane w interfejsach API Roslyn do tworzenia [analizatory i CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="1c1b0-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="1c1b0-108">(Analizatory i CodeFixes są pakiety NuGet, przeprowadzania analizy statycznej kodu, które może sugerować potencjalne rozwiązania dla deweloperów). Podstawowe koncepcje są podobne, a wynik końcowy to struktura danych, która umożliwia zbadanie kodu źródłowego w znaczący sposób.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="1c1b0-109">Jednak drzew wyrażeń są oparte na zupełnie innego zestawu klas i interfejsów API niż interfejsów API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="1c1b0-110">Oto prosty przykład.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-110">Let's look at a simple example.</span></span>
<span data-ttu-id="1c1b0-111">Oto wiersz kodu:</span><span class="sxs-lookup"><span data-stu-id="1c1b0-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="1c1b0-112">W przypadku analizowania to jako drzewa wyrażenie drzewa zawiera kilka węzłów.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="1c1b0-113">Węzeł najbardziej zewnętrznej jest deklaracja zmiennej instrukcji z przypisaniem (`var sum = 1 + 2;`) tego węzła najbardziej zewnętrznej zawiera kilka węzłów podrzędnych: deklaracja zmiennej, operator przypisania i wyrażenie reprezentujące po prawej stronie znaku równości.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="1c1b0-114">Czy wyrażenie jest dalsze podzielone na wyrażeniach, które reprezentują operacja dodawania i lewy i prawy argumenty operacji dodawania.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="1c1b0-115">Teraz nieco bardziej do szczegółów wyrażeń, które składają się po prawej stronie znaku równości.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="1c1b0-116">Wyrażenie jest `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="1c1b0-117">To wyrażenia binarnego.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-117">That's a binary expression.</span></span> <span data-ttu-id="1c1b0-118">Dokładniej mówiąc jest to wyrażenie binarne dodawania.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="1c1b0-119">Wyrażenie binarne dodanie ma dwa elementy podrzędne, reprezentujący lewy i prawy węzłów wyrażenie dodawania.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="1c1b0-120">W tym miejscu oba węzły są stałe wyrażenia: Lewy operand jest wartością `1`, prawy operand jest to wartość `2`.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="1c1b0-121">Wizualnie całą instrukcję jest drzewo: Możesz rozpoczynają się od węzła głównego i przesyłane do każdego węzła w drzewie Aby wyświetlić kod, który tworzy instrukcji:</span><span class="sxs-lookup"><span data-stu-id="1c1b0-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="1c1b0-122">Deklaracja zmiennej instrukcji z przypisaniem (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  * <span data-ttu-id="1c1b0-123">Deklaracja niejawnego typu zmiennej (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="1c1b0-124">Słowa kluczowego var niejawne (`var`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="1c1b0-125">Nazwa zmiennej deklaracji (`sum`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-125">Variable name declaration (`sum`)</span></span>
  * <span data-ttu-id="1c1b0-126">Operator przypisania (`=`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-126">Assignment operator (`=`)</span></span>
  * <span data-ttu-id="1c1b0-127">Wyrażenie binarne dodawania (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="1c1b0-128">Lewy operand (`1`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="1c1b0-129">Operator dodawania (`+`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="1c1b0-130">Prawy operand (`2`)</span><span class="sxs-lookup"><span data-stu-id="1c1b0-130">Right operand (`2`)</span></span>

<span data-ttu-id="1c1b0-131">Może to wyglądać skomplikowane, ale możliwości są ogromne.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="1c1b0-132">Następujące ten sam proces możesz rozłożyć części wyrażenia dużo bardziej skomplikowany.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="1c1b0-133">Należy wziąć pod uwagę następujące wyrażenie:</span><span class="sxs-lookup"><span data-stu-id="1c1b0-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="1c1b0-134">Powyższe wyrażenie jest również deklaracji zmiennej z przydziałem.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="1c1b0-135">W tym wypadku po prawej stronie przypisania jest dużo bardziej skomplikowany drzewa.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="1c1b0-136">Nie zamierzam rozłożyć to wyrażenie, ale należy wziąć pod uwagę, co może być w różnych węzłach.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="1c1b0-137">Brak wywołania metody, przy użyciu bieżącego obiektu jako odbiornik, który ma jawnie `this` odbiornik, który nie jest.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="1c1b0-138">Brak wywołania metody, przy użyciu innych obiektów odbiorcy, stałe argumentów o różnych typach.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="1c1b0-139">A na koniec jest operator binarny dodawania.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="1c1b0-140">W zależności od typu zwracanego `SecretSauceFunction()` lub `MoreSecretSauce()`, tego operatora binarnego dodawania może być wywołanie metody do operatora dodawania zgodnym z przesłoniętą rozpoznawania do wywołania metody statycznej operatora binarnego dodawania zdefiniowanej dla klasy.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="1c1b0-141">Pomimo tego postrzegany złożoności powyższe wyrażenie tworzy strukturę drzewa, którego nastąpi przejście, jak łatwo, jak pierwszy przykład.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="1c1b0-142">Można zachować przechodzenie węzłów podrzędnych można znaleźć węzły liści w wyrażeniu.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="1c1b0-143">Węzły nadrzędne będzie odwołują się do ich elementy podrzędne, a każdy węzeł ma właściwość, która opisuje, w jaki rodzaj węzła jest.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="1c1b0-144">Struktura drzewa wyrażenie jest bardzo spójne.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="1c1b0-145">Gdy znasz już podstawy, można zrozumieć nawet najbardziej złożonego kodu, gdy jest przedstawiana jako drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="1c1b0-146">Elegancji w strukturze danych wyjaśnia sposób, w jaki C# kompilatora można analizować najbardziej złożone C# programów i Utwórz odpowiednie dane wyjściowe z kodu źródłowego skomplikowane.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="1c1b0-147">Gdy zapoznanie się ze struktury drzewa wyrażeń, możesz znaleźć, wiedzy, które zostały zgromadzone szybko umożliwia pracę z wielu bardziej zaawansowanych scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="1c1b0-148">Brak niwelujące w drzewach wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="1c1b0-149">Oprócz tłumaczenia algorytmów do wykonania w innych środowiskach, drzew wyrażeń może służyć ułatwiające zapis algorytmy, które inspekcji kodu przed jego wykonaniem.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="1c1b0-150">Można napisać metodę, której argumenty są wyrażeniami i Sprawdź te wyrażenia przed wykonaniem kodu.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="1c1b0-151">Drzewo wyrażenia jest pełną reprezentację kod: możesz zobaczyć wartości dowolne wyrażenie podrzędne.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="1c1b0-152">Możesz zobaczyć nazwy metod i właściwości.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-152">You can see method and property names.</span></span> <span data-ttu-id="1c1b0-153">Wartość dowolnego wyrażenia stałe są widoczne.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="1c1b0-154">Można także przekonwertować drzewo wyrażenia na delegata pliku wykonywalnego i wykonywania kodu.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="1c1b0-155">Interfejsy API dla drzew wyrażeń umożliwiają tworzenie drzewa, które reprezentują prawie konstrukcji prawidłowy kod.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="1c1b0-156">Jednak aby zachować tak proste, jak to możliwe, niektóre C# idiomy nie można utworzyć w drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="1c1b0-157">Przykładem jest wyrażenia asynchroniczne (przy użyciu `async` i `await` słów kluczowych).</span><span class="sxs-lookup"><span data-stu-id="1c1b0-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="1c1b0-158">Jeśli Twoje potrzeby wymagają algorytmy asynchroniczne, będziesz potrzebować do manipulowania `Task` obiektów bezpośrednio, zamiast polegać na temat obsługi kompilatora.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="1c1b0-159">Innym jest podczas tworzenia pętli.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-159">Another is in creating loops.</span></span> <span data-ttu-id="1c1b0-160">Zazwyczaj można tworzyć przy użyciu `for`, `foreach`, `while` lub `do` pętli.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="1c1b0-161">Jak zobaczysz [dalej w tej serii](expression-trees-building.md), interfejsy API dla drzew wyrażeń obsługuje wyrażenie jednej pętli z `break` i `continue` wyrażeń, które kontrolują, powtarzając pętli.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="1c1b0-162">Jedyną operacją, której nie można wykonać, jest zmodyfikowanie drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="1c1b0-163">Drzewa wyrażeń są danymi niezmiennymi struktury.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="1c1b0-164">Chcąc mutować (Zmień) wyrażenie drzewa, należy utworzyć nowe drzewo, który jest kopią oryginał, ale o odpowiednie zmiany.</span><span class="sxs-lookup"><span data-stu-id="1c1b0-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="1c1b0-165">Dalej — Typy platform obsługujące drzewa wyrażeń</span><span class="sxs-lookup"><span data-stu-id="1c1b0-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
