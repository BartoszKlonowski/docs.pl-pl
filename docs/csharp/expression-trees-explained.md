---
title: Drzewa wyrażeń — objaśnienie
description: Dowiedz się więcej o drzewach wyrażeń i jak są one przydatne w tłumaczeniu algorytmów do wykonywania zewnętrznego i inspekcji kodu przed jego wykonaniem.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036992"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="26fb9-103">Drzewa wyrażeń — objaśnienie</span><span class="sxs-lookup"><span data-stu-id="26fb9-103">Expression Trees Explained</span></span>

[<span data-ttu-id="26fb9-104">Poprzedni -- Przegląd</span><span class="sxs-lookup"><span data-stu-id="26fb9-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="26fb9-105">Drzewo wyrażeń jest strukturą danych, która definiuje kod.</span><span class="sxs-lookup"><span data-stu-id="26fb9-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="26fb9-106">Są one oparte na tych samych strukturach, które kompilator używa do analizowania kodu i generowania skompilowanych danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="26fb9-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="26fb9-107">Jak przeczytać ten samouczek, można zauważyć sporo podobieństwa między drzewa wyrażenia i typy używane w interfejsach API Roslyn do tworzenia [analizatorów i codefixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="26fb9-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="26fb9-108">(Analizatory i poprawki kodu są pakiety NuGet, które wykonują analizę statyczną na kod i może sugerować potencjalne poprawki dla dewelopera.) Pojęcia są podobne, a wynik końcowy jest struktura danych, która umożliwia badanie kodu źródłowego w znaczący sposób.</span><span class="sxs-lookup"><span data-stu-id="26fb9-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="26fb9-109">Jednak drzewa wyrażeń są oparte na zupełnie inny zestaw klas i interfejsów API niż interfejsy API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="26fb9-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="26fb9-110">Spójrzmy na prosty przykład.</span><span class="sxs-lookup"><span data-stu-id="26fb9-110">Let's look at a simple example.</span></span>
<span data-ttu-id="26fb9-111">Oto wiersz kodu:</span><span class="sxs-lookup"><span data-stu-id="26fb9-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="26fb9-112">Jeśli było analizować to jako drzewo wyrażeń, drzewo zawiera kilka węzłów.</span><span class="sxs-lookup"><span data-stu-id="26fb9-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="26fb9-113">Węzeł najbardziej oddalony jest zmienną instrukcją`var sum = 1 + 2;`deklaracji z przypisaniem ( ) Ten najbardziej oddalony węzeł zawiera kilka węzłów podrzędnych: deklarację zmiennej, operator przypisania i wyrażenie reprezentujące prawą stronę znaku równości.</span><span class="sxs-lookup"><span data-stu-id="26fb9-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="26fb9-114">To wyrażenie jest dalej podzielone na wyrażenia, które reprezentują operację dodawania i lewy i prawy argument dodawania.</span><span class="sxs-lookup"><span data-stu-id="26fb9-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="26fb9-115">Przejdźmy nieco bardziej do wyrażeń, które składają się na prawą stronę znaku równości.</span><span class="sxs-lookup"><span data-stu-id="26fb9-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="26fb9-116">Wyrażenie to `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="26fb9-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="26fb9-117">To wyrażenie binarne.</span><span class="sxs-lookup"><span data-stu-id="26fb9-117">That's a binary expression.</span></span> <span data-ttu-id="26fb9-118">Dokładniej, jest to wyrażenie dodawania binarnego.</span><span class="sxs-lookup"><span data-stu-id="26fb9-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="26fb9-119">Wyrażenie dodania binarnego ma dwa elementy podrzędne, reprezentujące lewe i prawe węzły wyrażenia dodawania.</span><span class="sxs-lookup"><span data-stu-id="26fb9-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="26fb9-120">W tym miejscu oba węzły są wyrażeniami stałymi: Lewy operand jest wartością `1`, a prawym operandem jest wartość `2`.</span><span class="sxs-lookup"><span data-stu-id="26fb9-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="26fb9-121">Wizualnie cała instrukcja jest drzewem: można rozpocząć w węźle głównym i przejść do każdego węzła w drzewie, aby zobaczyć kod, który składa się na instrukcję:</span><span class="sxs-lookup"><span data-stu-id="26fb9-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="26fb9-122">Instrukcja deklaracji zmiennej z przypisaniem (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="26fb9-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="26fb9-123">Deklaracja typu`var sum`zmiennej niejawnej ( )</span><span class="sxs-lookup"><span data-stu-id="26fb9-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="26fb9-124">Niejawne`var`słowo kluczowe var ( )</span><span class="sxs-lookup"><span data-stu-id="26fb9-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="26fb9-125">Deklaracja nazwy`sum`zmiennej ( )</span><span class="sxs-lookup"><span data-stu-id="26fb9-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="26fb9-126">Operator przypisania (`=`)</span><span class="sxs-lookup"><span data-stu-id="26fb9-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="26fb9-127">Wyrażenie dodawania`1 + 2`binarnego ( )</span><span class="sxs-lookup"><span data-stu-id="26fb9-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="26fb9-128">Lewy operand`1`( )</span><span class="sxs-lookup"><span data-stu-id="26fb9-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="26fb9-129">Operator dodawania (`+`)</span><span class="sxs-lookup"><span data-stu-id="26fb9-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="26fb9-130">Prawy argument`2`( )</span><span class="sxs-lookup"><span data-stu-id="26fb9-130">Right operand (`2`)</span></span>

<span data-ttu-id="26fb9-131">To może wyglądać skomplikowanie, ale jest bardzo potężny.</span><span class="sxs-lookup"><span data-stu-id="26fb9-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="26fb9-132">Po tym samym procesie można rozłożyć znacznie bardziej skomplikowane wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="26fb9-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="26fb9-133">Należy wziąć pod uwagę to wyrażenie:</span><span class="sxs-lookup"><span data-stu-id="26fb9-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="26fb9-134">Wyrażenie powyżej jest również deklaracja zmiennej z przypisania.</span><span class="sxs-lookup"><span data-stu-id="26fb9-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="26fb9-135">W tym przypadku po prawej stronie przypisania jest znacznie bardziej skomplikowane drzewo.</span><span class="sxs-lookup"><span data-stu-id="26fb9-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="26fb9-136">Nie zamierzam się rozkładać tego wyrażenia, ale zastanów się, jakie mogą być różne węzły.</span><span class="sxs-lookup"><span data-stu-id="26fb9-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="26fb9-137">Istnieją wywołania metody przy użyciu bieżącego obiektu jako `this` odbiornika, który ma odbiornik jawny, taki, który nie.</span><span class="sxs-lookup"><span data-stu-id="26fb9-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="26fb9-138">Istnieją wywołania metody przy użyciu innych obiektów odbiornika, istnieją stałe argumenty różnych typów.</span><span class="sxs-lookup"><span data-stu-id="26fb9-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="26fb9-139">I wreszcie, istnieje operator dodawania binarnego.</span><span class="sxs-lookup"><span data-stu-id="26fb9-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="26fb9-140">W zależności od typu `SecretSauceFunction()` `MoreSecretSauce()`zwracanego lub , że operator dodawania binarnego może być wywołanie metody do operatora zastępowanego dodawania, rozpoznawanie do wywołania metody statycznej do operatora dodawania binarnego zdefiniowane dla klasy.</span><span class="sxs-lookup"><span data-stu-id="26fb9-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="26fb9-141">Pomimo tej postrzeganej złożoności, wyrażenie powyżej tworzy strukturę drzewa, które mogą być poruszane tak łatwo, jak w pierwszej próbce.</span><span class="sxs-lookup"><span data-stu-id="26fb9-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="26fb9-142">Można zachować przechodzenie przez węzły podrzędne, aby znaleźć węzły liścia w wyrażeniu.</span><span class="sxs-lookup"><span data-stu-id="26fb9-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="26fb9-143">Węzły nadrzędne będą miały odwołania do ich podrzędnych, a każdy węzeł ma właściwość, która opisuje, jaki rodzaj węzła jest.</span><span class="sxs-lookup"><span data-stu-id="26fb9-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="26fb9-144">Struktura drzewa wyrażeń jest bardzo spójna.</span><span class="sxs-lookup"><span data-stu-id="26fb9-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="26fb9-145">Po nauczeniu się podstaw, można zrozumieć nawet najbardziej złożonykod, gdy jest reprezentowany jako drzewo wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="26fb9-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="26fb9-146">Elegancja w strukturze danych wyjaśnia, jak kompilator C# można analizować najbardziej złożonych programów C# i utworzyć odpowiednie dane wyjściowe z tego skomplikowanego kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="26fb9-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="26fb9-147">Po zapoznaniu się ze strukturą drzew ekspresji, przekonasz się, że wiedza, którą szybko zdobędziesz, pozwala pracować z wieloma coraz bardziej zaawansowanymi scenariuszami.</span><span class="sxs-lookup"><span data-stu-id="26fb9-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="26fb9-148">Istnieje niesamowita moc wyrażania drzew.</span><span class="sxs-lookup"><span data-stu-id="26fb9-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="26fb9-149">Oprócz tłumaczenia algorytmów do wykonania w innych środowiskach drzewa wyrażeń mogą służyć do ułatwienia pisania algorytmów, które sprawdzają kod przed jego wykonaniem.</span><span class="sxs-lookup"><span data-stu-id="26fb9-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="26fb9-150">Można napisać metodę, której argumenty są wyrażeniami, a następnie zbadać te wyrażenia przed wykonaniem kodu.</span><span class="sxs-lookup"><span data-stu-id="26fb9-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="26fb9-151">Drzewo wyrażeń jest pełną reprezentacją kodu: można zobaczyć wartości dowolnego wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="26fb9-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="26fb9-152">Można wyświetlić nazwy metody i właściwości.</span><span class="sxs-lookup"><span data-stu-id="26fb9-152">You can see method and property names.</span></span> <span data-ttu-id="26fb9-153">Można zobaczyć wartość wszystkich wyrażeń stałych.</span><span class="sxs-lookup"><span data-stu-id="26fb9-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="26fb9-154">Można również przekonwertować drzewo wyrażeń na delegata wykonywalnego i wykonać kod.</span><span class="sxs-lookup"><span data-stu-id="26fb9-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="26fb9-155">Interfejsy API dla drzew wyrażeń umożliwiają tworzenie drzew, które reprezentują prawie wszystkie prawidłowe konstrukcji kodu.</span><span class="sxs-lookup"><span data-stu-id="26fb9-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="26fb9-156">Jednak aby zachować rzeczy tak proste, jak to możliwe, niektóre idiomy C# nie można utworzyć w drzewie wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="26fb9-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="26fb9-157">Jednym z przykładów są wyrażenia asynchroniczne (przy użyciu `async` słów kluczowych). `await`</span><span class="sxs-lookup"><span data-stu-id="26fb9-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="26fb9-158">Jeśli twoje potrzeby wymagają algorytmów asynchronicznych, należy `Task` manipulować obiektami bezpośrednio, a nie polegać na obsłudze kompilatora.</span><span class="sxs-lookup"><span data-stu-id="26fb9-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="26fb9-159">Innym jest tworzenie pętli.</span><span class="sxs-lookup"><span data-stu-id="26fb9-159">Another is in creating loops.</span></span> <span data-ttu-id="26fb9-160">Zazwyczaj można je utworzyć `for`za `foreach` `while` pomocą `do` , , lub pętle.</span><span class="sxs-lookup"><span data-stu-id="26fb9-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="26fb9-161">Jak zobaczysz [w dalszej części tej serii](expression-trees-building.md), interfejsy API `break` `continue` dla drzew wyrażeń obsługują wyrażenie pojedynczej pętli, z i wyrażenia, które kontrolują powtarzanie pętli.</span><span class="sxs-lookup"><span data-stu-id="26fb9-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="26fb9-162">Jedyną rzeczą, której nie można zrobić, jest modyfikowanie drzewa wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="26fb9-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="26fb9-163">Drzewa wyrażeń są niezmienne struktury danych.</span><span class="sxs-lookup"><span data-stu-id="26fb9-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="26fb9-164">Aby zmutować (zmienić) drzewo wyrażeń, należy utworzyć nowe drzewo, które jest kopią oryginału, ale z żądanymi zmianami.</span><span class="sxs-lookup"><span data-stu-id="26fb9-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="26fb9-165">Dalej - Typy struktury obsługujące drzewa wyrażeń</span><span class="sxs-lookup"><span data-stu-id="26fb9-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
