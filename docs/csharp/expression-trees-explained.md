---
title: "Wyjaśniono drzew wyrażeń"
description: "Więcej informacji na temat drzew wyrażeń i jak są one przydatne w tłumaczenie algorytmów dla zewnętrznych wykonywania i kontroli kodu przed jej wykonanie."
keywords: .NET, .NET core
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 1de856a139ac7a6dee25f1dae54924e33f14a33b
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2017
---
# <a name="expression-trees-explained"></a><span data-ttu-id="5453c-104">Wyjaśniono drzew wyrażeń</span><span class="sxs-lookup"><span data-stu-id="5453c-104">Expression Trees Explained</span></span>

[<span data-ttu-id="5453c-105">Poprzednie — omówienie</span><span class="sxs-lookup"><span data-stu-id="5453c-105">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="5453c-106">Drzewo wyrażenia jest strukturą danych, który definiuje kodu.</span><span class="sxs-lookup"><span data-stu-id="5453c-106">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="5453c-107">Są one oparte na tej samej struktury, używane do analizowania kodu i generowanie skompilowanych danych wyjściowych kompilatora.</span><span class="sxs-lookup"><span data-stu-id="5453c-107">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="5453c-108">Omówione w tym samouczku, można zauważyć dość nieco podobieństwa między drzew wyrażeń i typy używane w interfejsach API Roslyn do budowania [analizatory i CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="5453c-108">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="5453c-109">(Analizatory i CodeFixes są pakiety NuGet, które wykonują analizy statycznej na kod i może sugerować potencjalne rozwiązania dla dewelopera). Pojęcia są podobne, a w rezultacie jest strukturą danych, umożliwiający kontroli kodu źródłowego w znaczący sposób.</span><span class="sxs-lookup"><span data-stu-id="5453c-109">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="5453c-110">Jednak drzew wyrażeń są oparte na zbiór całkiem klasy i interfejsy API niż Roslyn interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="5453c-110">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>
    
<span data-ttu-id="5453c-111">Oto prosty przykład.</span><span class="sxs-lookup"><span data-stu-id="5453c-111">Let's look at a simple example.</span></span>
<span data-ttu-id="5453c-112">Oto wiersz kodu:</span><span class="sxs-lookup"><span data-stu-id="5453c-112">Here's a line of code:</span></span>
```csharp
var sum = 1 + 2;
```
<span data-ttu-id="5453c-113">Gdyby analizowanie to jako drzewo wyrażenia drzewa zawiera kilka węzłów.</span><span class="sxs-lookup"><span data-stu-id="5453c-113">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="5453c-114">Najbardziej zewnętrznego węzeł jest deklaracja zmiennej instrukcji za pomocą przypisania (`var sum = 1 + 2;`) tego węzła peryferyjnych zawiera kilka węzłów podrzędnych: deklaracja zmiennej, operatora przypisania i reprezentujący po prawej stronie znaku równości.</span><span class="sxs-lookup"><span data-stu-id="5453c-114">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="5453c-115">Czy wyrażenie jest podzielona na wyrażeń, które reprezentują operacja dodawania i lewy i prawy argumentów operacji dodawania.</span><span class="sxs-lookup"><span data-stu-id="5453c-115">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="5453c-116">Umożliwia przechodzenie bardziej do wyrażeń, które składają się z prawej strony znaku równości.</span><span class="sxs-lookup"><span data-stu-id="5453c-116">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="5453c-117">Wyrażenie jest `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="5453c-117">The expression is `1 + 2`.</span></span> <span data-ttu-id="5453c-118">To wyrażenie binarne.</span><span class="sxs-lookup"><span data-stu-id="5453c-118">That's a binary expression.</span></span> <span data-ttu-id="5453c-119">W szczególności jest to wyrażenie binarne dodawania.</span><span class="sxs-lookup"><span data-stu-id="5453c-119">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="5453c-120">Wyrażenie binarne dodanie ma dwa elementy podrzędne, reprezentujący lewy i prawy węzły wyrażenia dodawania.</span><span class="sxs-lookup"><span data-stu-id="5453c-120">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="5453c-121">W tym miejscu oba węzły są wyrażenia stałe: lewy argument operacji jest wartość `1`, prawy operand jest to wartość `2`.</span><span class="sxs-lookup"><span data-stu-id="5453c-121">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="5453c-122">Efekty wizualne, całą instrukcję jest drzewo: można uruchomić w węźle głównym i przesyłane do każdego węzła w drzewie, aby wyświetlić kod, który stanowi instrukcji:</span><span class="sxs-lookup"><span data-stu-id="5453c-122">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="5453c-123">Deklaracja zmiennej instrukcji za pomocą przypisania (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="5453c-123">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
    * <span data-ttu-id="5453c-124">Deklaracja zmiennej typu niejawnego (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="5453c-124">Implicit variable type declaration (`var sum`)</span></span>
        - <span data-ttu-id="5453c-125">Niejawne var — słowo kluczowe (`var`)</span><span class="sxs-lookup"><span data-stu-id="5453c-125">Implicit var keyword (`var`)</span></span>
        - <span data-ttu-id="5453c-126">Nazwa zmiennej deklaracji (`sum`)</span><span class="sxs-lookup"><span data-stu-id="5453c-126">Variable name declaration (`sum`)</span></span>
    * <span data-ttu-id="5453c-127">Operator przypisania (`=`)</span><span class="sxs-lookup"><span data-stu-id="5453c-127">Assignment operator (`=`)</span></span>
    * <span data-ttu-id="5453c-128">Wyrażenie binarne dodawania (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="5453c-128">Binary addition expression (`1 + 2`)</span></span>
        - <span data-ttu-id="5453c-129">Lewej strony (`1`)</span><span class="sxs-lookup"><span data-stu-id="5453c-129">Left operand (`1`)</span></span>
        - <span data-ttu-id="5453c-130">Operator dodawania (`+`)</span><span class="sxs-lookup"><span data-stu-id="5453c-130">Addition operator (`+`)</span></span>
        - <span data-ttu-id="5453c-131">Prawy argument operacji (`2`)</span><span class="sxs-lookup"><span data-stu-id="5453c-131">Right operand (`2`)</span></span>

<span data-ttu-id="5453c-132">Może to wyglądać skomplikowane, ale jest bardzo zaawansowaną.</span><span class="sxs-lookup"><span data-stu-id="5453c-132">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="5453c-133">Po tym samym procesie rozkładają się znacznie bardziej złożonych.</span><span class="sxs-lookup"><span data-stu-id="5453c-133">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="5453c-134">Należy wziąć pod uwagę tego wyrażenia:</span><span class="sxs-lookup"><span data-stu-id="5453c-134">Consider this expression:</span></span>
```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="5453c-135">Powyższe wyrażenie jest również deklaracji zmiennej z przydziałem.</span><span class="sxs-lookup"><span data-stu-id="5453c-135">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="5453c-136">W tym wystąpieniu po prawej stronie przypisania jest znacznie bardziej skomplikowane drzewa.</span><span class="sxs-lookup"><span data-stu-id="5453c-136">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="5453c-137">Nie użyjemy dekompozycji to wyrażenie, ale należy wziąć pod uwagę, co może być w różnych węzłach.</span><span class="sxs-lookup"><span data-stu-id="5453c-137">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="5453c-138">Brak przy użyciu bieżącego obiektu jako odbiornik, który ma jawnego wywołania metody `this` odbiornika, który nie obsługuje.</span><span class="sxs-lookup"><span data-stu-id="5453c-138">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="5453c-139">Brak wywołania metody, przy użyciu innych obiektów odbiornik, stałych argumentów o różnych typach.</span><span class="sxs-lookup"><span data-stu-id="5453c-139">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="5453c-140">A na koniec jest operator binarny dodawania.</span><span class="sxs-lookup"><span data-stu-id="5453c-140">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="5453c-141">W zależności od typu zwracanego przez `SecretSauceFunction()` lub `MoreSecretSauce()`, że operator binarny dodawania może być wywołanie metody operator dodawania przesłonięte, rozpoznawania wywołanie metody statycznej operatora binarnego dodawania zdefiniowanej dla klasy.</span><span class="sxs-lookup"><span data-stu-id="5453c-141">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="5453c-142">Pomimo tego postrzegana złożoności powyższe wyrażenie tworzy strukturę drzewa, która może zostać przesłane bez pierwszej próbie.</span><span class="sxs-lookup"><span data-stu-id="5453c-142">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="5453c-143">Można zachować przechodzenie węzłów podrzędnych można znaleźć w wyrażeniu węzłów liści.</span><span class="sxs-lookup"><span data-stu-id="5453c-143">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="5453c-144">Węzły nadrzędne będzie zawierać odwołań do ich elementy podrzędne, a każdy węzeł ma właściwość, która opisuje rodzaj węzła jest.</span><span class="sxs-lookup"><span data-stu-id="5453c-144">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="5453c-145">Struktura drzewa wyrażenia jest bardzo spójna.</span><span class="sxs-lookup"><span data-stu-id="5453c-145">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="5453c-146">Gdy znasz już podstawy, można zrozumieć nawet najbardziej złożoną kodu, kiedy jest reprezentowany jako drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="5453c-146">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="5453c-147">Przejrzysty wygląd w strukturze danych wyjaśniono, jak analizować najbardziej złożonych programów C# i utworzyć odpowiednie dane wyjściowe z tego kodu źródłowego skomplikowane kompilatora C#.</span><span class="sxs-lookup"><span data-stu-id="5453c-147">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="5453c-148">Po zapoznanie się ze struktury drzewa wyrażeń, zostanie ustalone, że wiedzy, które zostały uzyskane w szybko umożliwia pracę z wielu bardziej zaawansowanych scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="5453c-148">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="5453c-149">Brak wyjątkowo wydajnego na drzewa wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="5453c-149">There is incredible power to expression trees.</span></span>

<span data-ttu-id="5453c-150">Oprócz tłumaczenia algorytmy do wykonania w innych środowiskach, drzew wyrażeń można ułatwić zapisu algorytmów inspekcji przed jego wykonaniem kodu.</span><span class="sxs-lookup"><span data-stu-id="5453c-150">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="5453c-151">Można napisanie metody, którego argumenty wyrażenia, a następnie sprawdź te wyrażenia przed wykonaniem kodu.</span><span class="sxs-lookup"><span data-stu-id="5453c-151">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="5453c-152">Drzewo wyrażenia jest reprezentację pełnego kodu: można zobaczyć wartości wszystkie wyrażenia podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="5453c-152">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="5453c-153">Nazwy metod i właściwości jest widoczny.</span><span class="sxs-lookup"><span data-stu-id="5453c-153">You can see method and property names.</span></span> <span data-ttu-id="5453c-154">Można zobaczyć wartość wszystkie wyrażenia stałej.</span><span class="sxs-lookup"><span data-stu-id="5453c-154">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="5453c-155">Można również przekonwertować drzewo wyrażenia wykonywalnego delegata i wykonywania kodu.</span><span class="sxs-lookup"><span data-stu-id="5453c-155">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="5453c-156">Interfejsy API do drzewa wyrażeń umożliwiają tworzenie drzewa reprezentujących prawie konstrukcji prawidłowy kod.</span><span class="sxs-lookup"><span data-stu-id="5453c-156">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="5453c-157">Jednak aby rzeczy, wystarczy, niektóre idioms C# nie można utworzyć drzewa wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="5453c-157">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="5453c-158">Przykładem jest asynchronicznego wyrażenia (przy użyciu `async` i `await` słowa kluczowe).</span><span class="sxs-lookup"><span data-stu-id="5453c-158">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="5453c-159">Jeśli Twoje potrzeby wymagają asynchroniczne algorytmów, będzie potrzebny do manipulowania `Task` obiekty bezpośrednio, zamiast polegać na obsługa kompilatora.</span><span class="sxs-lookup"><span data-stu-id="5453c-159">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="5453c-160">Inny jest utworzenie pętli.</span><span class="sxs-lookup"><span data-stu-id="5453c-160">Another is in creating loops.</span></span> <span data-ttu-id="5453c-161">Zazwyczaj w celu utworzenia tych elementów przy użyciu `for`, `foreach`, `while` lub `do` pętli.</span><span class="sxs-lookup"><span data-stu-id="5453c-161">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="5453c-162">Jak można zauważyć [dalej w tej serii](expression-trees-building.md), interfejsy API do drzewa wyrażeń obsługuje wyrażenia jednej pętli z `break` i `continue` wyrażeń sterujących powtarzające się pętli.</span><span class="sxs-lookup"><span data-stu-id="5453c-162">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="5453c-163">Jedyną operacją, której nie można wykonać, jest zmodyfikowanie drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="5453c-163">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="5453c-164">Drzewa wyrażeń są niezmienne danych struktury.</span><span class="sxs-lookup"><span data-stu-id="5453c-164">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="5453c-165">Jeśli chcesz zmodyfikować (Zmień) wyrażenie drzewa, należy utworzyć nowe drzewo będący kopię oryginału, ale odpowiednie zmiany.</span><span class="sxs-lookup"><span data-stu-id="5453c-165">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span> 

[<span data-ttu-id="5453c-166">Dalej--Framework typy obsługi drzewa wyrażeń</span><span class="sxs-lookup"><span data-stu-id="5453c-166">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
