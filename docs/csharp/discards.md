---
title: Odrzuca — Przewodnik po języku C#
description: Opisano obsługę języka C# w odrzucenia, które są nieprzypisane, discardable zmienne i sposoby, w którym można odrzucenia.
author: rpetrusha
ms.author: ronpet
ms.date: 07/21/2017
ms.openlocfilehash: 761fb69d3bc774975caf63b8aa665f8c19c0430a
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61646673"
---
# <a name="discards---c-guide"></a><span data-ttu-id="b9079-103">Odrzuca — Przewodnik po języku C#</span><span class="sxs-lookup"><span data-stu-id="b9079-103">Discards - C# Guide</span></span>

<span data-ttu-id="b9079-104">Począwszy od języka C# 7.0, C# obsługuje odrzuca, służą do tymczasowego, fikcyjnego zmiennych, które są celowo nieużywane w kodzie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b9079-104">Starting with C# 7.0, C# supports discards, which are temporary, dummy variables that are intentionally unused in application code.</span></span> <span data-ttu-id="b9079-105">Odrzuca są równoważne nieprzypisane zmiennych; nie mają wartości.</span><span class="sxs-lookup"><span data-stu-id="b9079-105">Discards are equivalent to unassigned variables; they do not have a value.</span></span> <span data-ttu-id="b9079-106">Ponieważ jest zmienną pojedynczego odrzucenia, a tej zmiennej nie może jeszcze być alokowana magazynu, odrzucenia może zmniejszyć alokacji pamięci.</span><span class="sxs-lookup"><span data-stu-id="b9079-106">Because there is only a single discard variable, and that variable may not even be allocated storage, discards can reduce memory allocations.</span></span> <span data-ttu-id="b9079-107">Ponieważ ich zamiar zwykłego kodu, zwiększyć jego czytelność i łatwość konserwacji.</span><span class="sxs-lookup"><span data-stu-id="b9079-107">Because they make the intent of your code clear, they enhance its readability and maintainability.</span></span>

<span data-ttu-id="b9079-108">Można wskazać, że zmienna jest odrzucenia, przypisując go znak podkreślenia (`_`) jako jego nazwę.</span><span class="sxs-lookup"><span data-stu-id="b9079-108">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="b9079-109">Na przykład, następujące wywołanie metody zwraca 3-krotka, w którym wartości pierwszego i drugiego to odrzutów i *obszaru* poprzednio zadeklarowana zmienna, należy ustawić odpowiadającego składnika trzeciej zwrócony przez  *GetCityInformation*:</span><span class="sxs-lookup"><span data-stu-id="b9079-109">For example, the following method call returns a 3-tuple in which the first and second values are discards and *area* is a previously declared variable to be set to the corresponding third component returned by *GetCityInformation*:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="b9079-110">W języku C# 7.0 odrzucenia są obsługiwane w przypisania w następujących okolicznościach:</span><span class="sxs-lookup"><span data-stu-id="b9079-110">In C# 7.0, discards are supported in assignments in the following contexts:</span></span>

- <span data-ttu-id="b9079-111">Krotki i obiekt [dekonstrukcja](deconstruct.md).</span><span class="sxs-lookup"><span data-stu-id="b9079-111">Tuple and object [deconstruction](deconstruct.md).</span></span>
- <span data-ttu-id="b9079-112">Za pomocą dopasowywania do wzorca [jest](language-reference/keywords/is.md) i [Przełącz](language-reference/keywords/switch.md).</span><span class="sxs-lookup"><span data-stu-id="b9079-112">Pattern matching with [is](language-reference/keywords/is.md) and [switch](language-reference/keywords/switch.md).</span></span>
- <span data-ttu-id="b9079-113">Wywołania do metod z `out` parametrów.</span><span class="sxs-lookup"><span data-stu-id="b9079-113">Calls to methods with `out` parameters.</span></span>
- <span data-ttu-id="b9079-114">Autonomiczny `_` gdy nie `_` znajduje się w zakresie.</span><span class="sxs-lookup"><span data-stu-id="b9079-114">A standalone `_` when no `_` is in scope.</span></span>

<span data-ttu-id="b9079-115">Gdy `_` jest prawidłowy odrzucenia próby pobrania jej wartość lub użyj jej w operacji przypisania generuje błąd kompilatora CS0301, "Nazwa"\_"nie istnieje w bieżącym kontekście".</span><span class="sxs-lookup"><span data-stu-id="b9079-115">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' does not exist in the current context".</span></span> <span data-ttu-id="b9079-116">Jest to spowodowane `_` nie jest przypisywana wartość i nie może jeszcze być przypisany lokalizacji magazynu.</span><span class="sxs-lookup"><span data-stu-id="b9079-116">This is because `_` is not assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="b9079-117">W przypadku rzeczywista zmienna, nie może odrzucić więcej niż jedną wartość, tak jak w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="b9079-117">If it were an actual variable, you could not discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="b9079-118">Dekonstrukcja krotki i obiektu</span><span class="sxs-lookup"><span data-stu-id="b9079-118">Tuple and object deconstruction</span></span>

<span data-ttu-id="b9079-119">Odrzuca są szczególnie przydatne w pracy z krotek, gdy kod aplikacji używa niektórych elementów krotki, ale ignoruje inne osoby.</span><span class="sxs-lookup"><span data-stu-id="b9079-119">Discards are particularly useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="b9079-120">Na przykład następująca `QueryCityDataForYears` metoda zwraca 6-krotka nazwą miasta, jego obszaru, roku, to miasto populację na potrzeby tego roku, drugiego roku i miasta populację na potrzeby tego drugiego roku.</span><span class="sxs-lookup"><span data-stu-id="b9079-120">For example, the following `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="b9079-121">W przykładzie pokazano zmianę populacji między te dwa lata.</span><span class="sxs-lookup"><span data-stu-id="b9079-121">The example shows the change in population between those two years.</span></span> <span data-ttu-id="b9079-122">Dane udostępniła spójnej kolekcji, jesteśmy unconcerned z obszarem miasta i wiemy, nazwę miasta i dwiema datami w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="b9079-122">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="b9079-123">W rezultacie firma Microsoft interesują jedynie wartości dwóch populacji, przechowywane w spójnej kolekcji i może obsługiwać jego pozostałe wartości jako odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="b9079-123">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

<span data-ttu-id="b9079-124">Aby uzyskać więcej informacji na temat dekonstrukcja krotek przy użyciu odrzucenia, zobacz [Dekonstrukcja krotek i innych typów](deconstruct.md#deconstructing-tuple-elements-with-discards).</span><span class="sxs-lookup"><span data-stu-id="b9079-124">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="b9079-125">`Deconstruct` Metody klasy, struktury lub interfejsu umożliwia również pobrać i dekonstruować określonego zestawu danych z obiektu.</span><span class="sxs-lookup"><span data-stu-id="b9079-125">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="b9079-126">Możesz użyć odrzucenia, jeśli interesują Cię Praca z podzbiorem śródwierszową wartości.</span><span class="sxs-lookup"><span data-stu-id="b9079-126">You can use discards when you are interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="b9079-127">Poniższy przykład deconstructs `Person` obiektu do czterech ciągów (imiona i nazwiska, miasta i stanu), ale odrzuca nazwisko i stanu.</span><span class="sxs-lookup"><span data-stu-id="b9079-127">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs)]

<span data-ttu-id="b9079-128">Aby uzyskać więcej informacji na temat dekonstrukcja typy zdefiniowane przez użytkownika przy użyciu odrzucenia, zobacz [Dekonstrukcja krotek i innych typów](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span><span class="sxs-lookup"><span data-stu-id="b9079-128">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch-and-is"></a><span data-ttu-id="b9079-129">Za pomocą dopasowywania do wzorca `switch` i `is`</span><span class="sxs-lookup"><span data-stu-id="b9079-129">Pattern matching with `switch` and `is`</span></span>

<span data-ttu-id="b9079-130">*Odrzucić wzorzec* mogą być używane w dopasowywania do wzorca z [jest](language-reference/keywords/is.md) i [Przełącz](language-reference/keywords/switch.md) słów kluczowych.</span><span class="sxs-lookup"><span data-stu-id="b9079-130">The *discard pattern* can be used in pattern matching with the [is](language-reference/keywords/is.md) and [switch](language-reference/keywords/switch.md) keywords.</span></span> <span data-ttu-id="b9079-131">Każde wyrażenie zawsze zgodny ze wzorcem odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="b9079-131">Every expression always matches the discard pattern.</span></span>

<span data-ttu-id="b9079-132">W poniższym przykładzie zdefiniowano `ProvidesFormatInfo` metody, która używa [jest](language-reference/keywords/is.md) instrukcje, aby określić, czy zawiera obiekt <xref:System.IFormatProvider> implementacji i testów czy obiekt jest `null`.</span><span class="sxs-lookup"><span data-stu-id="b9079-132">The following example defines a `ProvidesFormatInfo` method that uses [is](language-reference/keywords/is.md) statements to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="b9079-133">Używa również wzorca odrzucania obsługi obiektów innych niż null innego typu.</span><span class="sxs-lookup"><span data-stu-id="b9079-133">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

[!code-csharp[discard-pattern](../../samples/snippets/csharp/programming-guide/discards/discard-pattern2.cs)]

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="b9079-134">Wywołania metod za pomocą parametrów out</span><span class="sxs-lookup"><span data-stu-id="b9079-134">Calls to methods with out parameters</span></span>

<span data-ttu-id="b9079-135">Podczas wywoływania `Deconstruct` metody typu zdefiniowanego przez użytkownika (wystąpienia klasy, struktury lub interfejsu), możesz odrzucić wartości poszczególnych dekonstruować `out` argumentów.</span><span class="sxs-lookup"><span data-stu-id="b9079-135">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="b9079-136">Ale można również odrzucić wartość `out` argumentów podczas wywoływania dowolnej metody z parametrem out.</span><span class="sxs-lookup"><span data-stu-id="b9079-136">But you can also discard the value of `out` arguments when calling any method with an out parameter.</span></span>

<span data-ttu-id="b9079-137">Poniższy przykład wywołuje [DateTime.TryParse (ciąg, out daty/godziny)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) metodę, aby określić, czy reprezentacją ciągu daty jest nieprawidłowy w bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="b9079-137">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="b9079-138">Ponieważ przykład dotyczy tylko w przypadku sprawdzania poprawności ciągu daty i nie ich w celu wyodrębnienia Data, analizowania `out` argument do metody jest odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="b9079-138">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

[!code-csharp[discard-with-out](../../samples/snippets/csharp/programming-guide/discards/discard-out1.cs)]

## <a name="a-standalone-discard"></a><span data-ttu-id="b9079-139">Odrzuć autonomiczny</span><span class="sxs-lookup"><span data-stu-id="b9079-139">A standalone discard</span></span>

<span data-ttu-id="b9079-140">Odrzucenia autonomiczny służy do wskazania jakakolwiek zmienna, która zostanie zignorowany.</span><span class="sxs-lookup"><span data-stu-id="b9079-140">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="b9079-141">W poniższym przykładzie użyto odrzucenia autonomiczne do ignorowania <xref:System.Threading.Tasks.Task> obiektu zwróconego przez operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="b9079-141">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="b9079-142">Skutkuje to pomijania wyjątek, który zgłasza operacji, jak zbliża się zakończyć.</span><span class="sxs-lookup"><span data-stu-id="b9079-142">This has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span>

[!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard1.cs)]

<span data-ttu-id="b9079-143">Należy pamiętać, że `_` jest również prawidłowym identyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="b9079-143">Note that `_` is also a valid identifier.</span></span> <span data-ttu-id="b9079-144">Gdy jest używana poza kontekstem obsługiwanych, `_` jest traktowany jako prawidłową zmienną, ale nie jako odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="b9079-144">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="b9079-145">Jeśli nazwany identyfikator `_` jest już w zakresie użytkowania `_` jako autonomiczny odrzucenia może doprowadzić do:</span><span class="sxs-lookup"><span data-stu-id="b9079-145">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="b9079-146">Przypadkowe modyfikacji wartości w zakresie `_` zmiennej, przypisując jej wartość zamierzony odrzucenia.</span><span class="sxs-lookup"><span data-stu-id="b9079-146">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="b9079-147">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="b9079-147">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#1)]

- <span data-ttu-id="b9079-148">Błąd kompilatora za naruszenie bezpieczeństwa typu.</span><span class="sxs-lookup"><span data-stu-id="b9079-148">A compiler error for violating type safety.</span></span> <span data-ttu-id="b9079-149">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="b9079-149">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#2)]

- <span data-ttu-id="b9079-150">Błąd kompilatora CS0136, "element lokalny lub parametr o nazwie"\_"nie można zadeklarować w tym zakresie, ponieważ w tym nazwa jest używana w otaczającym zakresie lokalnym do zdefiniowania elementu lokalnego lub parametru."</span><span class="sxs-lookup"><span data-stu-id="b9079-150">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="b9079-151">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="b9079-151">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#3)]

## <a name="see-also"></a><span data-ttu-id="b9079-152">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="b9079-152">See also</span></span>

- [<span data-ttu-id="b9079-153">Dekonstrukcja krotek i innych typów</span><span class="sxs-lookup"><span data-stu-id="b9079-153">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="b9079-154">`is` Słowo kluczowe</span><span class="sxs-lookup"><span data-stu-id="b9079-154">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="b9079-155">`switch` Słowo kluczowe</span><span class="sxs-lookup"><span data-stu-id="b9079-155">`switch` keyword</span></span>](language-reference/keywords/switch.md)
