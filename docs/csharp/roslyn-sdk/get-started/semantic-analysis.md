---
title: Rozpoczynanie pracy z usługą analiza semantyki
description: Ten samouczek zawiera omówienie pracy z semantycznego analizy przy użyciu zestawu .NET SDK kompilatora.
ms.date: 02/06/2018
ms.custom: mvc
ms.openlocfilehash: dac733cba1d60a1bd24f5308717f4933cd620319
ms.sourcegitcommit: 0aca6c5d166d7961a1e354c248495645b97a1dc5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/01/2019
ms.locfileid: "58760056"
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="e2a6f-103">Rozpoczynanie pracy z usługą analiza semantyki</span><span class="sxs-lookup"><span data-stu-id="e2a6f-103">Get started with semantic analysis</span></span>

<span data-ttu-id="e2a6f-104">W tym samouczku przyjęto założenie, że znasz składnię interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="e2a6f-105">[Rozpoczynanie pracy z usługą analiza składni](syntax-analysis.md) artykuł zawiera wprowadzenie wystarczające.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="e2a6f-106">W ramach tego samouczka, możesz zapoznać się z **Symbol** i **powiązanie interfejsów API**.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="e2a6f-107">Te interfejsy API, podaj informacje o _znaczenia semantycznego_ programu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="e2a6f-108">Umożliwiają one pytania i odpowiedzi na pytania dotyczące typów reprezentowanych przez dowolny symbol w programie.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="e2a6f-109">Należy zainstalować **zestawu SDK platformy kompilatora .NET**:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="e2a6f-110">Opis kompilacji i symboli</span><span class="sxs-lookup"><span data-stu-id="e2a6f-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="e2a6f-111">Więcej pracy przy użyciu zestawu .NET SDK kompilatora zapoznanie się ze różnice między API składni i semantyczne interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="e2a6f-112">**API składni** pozwala przyjrzeć się _struktury_ programu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="e2a6f-113">Jednak często potrzebują więcej informacji na temat semantykę lub _znaczenie_ programu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="e2a6f-114">Gdy plik luźne kodu lub fragment kodu w języku VB lub C# mogą być syntaktycznie analizowane w izolacji, nie ma sensu zadawać pytania, takie jak "co to jest typ zmiennej" w odkurzający.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-114">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="e2a6f-115">Znaczenie Nazwa typu, który może być zależny od odwołania do zestawów, importowanej przestrzeni nazw lub innych plików kodu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="e2a6f-116">Te odpowiedzi na pytania za pomocą **semantycznego API**, konkretnie <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="e2a6f-117">Wystąpienie <xref:Microsoft.CodeAnalysis.Compilation> jest porównywalna do pojedynczego projektu widziany przez kompilator i reprezentuje wszystkie elementy potrzebne do kompilowania programów Visual Basic lub C#.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="e2a6f-118">**Kompilacji** zawiera zestaw plików źródłowych do skompilowania, odwołania do zestawów i opcje kompilatora.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="e2a6f-119">Można przyczyny, informacje o znaczeniu kod przy użyciu wszystkie pozostałe informacje w tym kontekście.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="e2a6f-120">A <xref:Microsoft.CodeAnalysis.Compilation> umożliwia znalezienie **symbole** -jednostki, takie jak typy, przestrzenie nazw, składowych i zmiennych, które nazwy i inne wyrażenia odnoszą się do.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="e2a6f-121">Proces przypisywania nazw oraz wyrażenia z **symbole** nosi nazwę **powiązanie**.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="e2a6f-122">Podobnie jak <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> jest specyficzny dla języka pochodne klasy abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="e2a6f-123">Podczas tworzenia wystąpienia obiektu kompilacji, należy wywołać metodę fabryki na <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (lub <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) klasy.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="e2a6f-124">Tworzenie zapytań symboli</span><span class="sxs-lookup"><span data-stu-id="e2a6f-124">Querying symbols</span></span>

<span data-ttu-id="e2a6f-125">W tym samouczku przyjrzymy się programu "Hello World" ponownie.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="e2a6f-126">Tym razem zapytania symbole w programie, aby zrozumieć, jakie typy reprezentują te symbole.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="e2a6f-127">Zapytanie dla typów w przestrzeni nazw i Dowiedz się, jak znaleźć dostępnych metod w danym typie.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="e2a6f-128">Zostanie wyświetlony gotowy kod dla tego przykładu w [repozytorium GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="e2a6f-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="e2a6f-129">Typy drzewo składni umożliwiają dziedziczenia opisano różne elementy składni, które są prawidłowe w różnych lokalizacjach w programie.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="e2a6f-130">Za pomocą tych interfejsów API często oznacza, że właściwości rzutowania lub elementy członkowskie kolekcji dla określonych typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="e2a6f-131">W poniższych przykładach przydziałów i rzutowania są osobnych instrukcji, za pomocą jawnie wpisanych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="e2a6f-132">Może odczytywać kod, aby zobaczyć typów zwracanych interfejsu API i typ środowiska uruchomieniowego zwracanych obiektów.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="e2a6f-133">W praktyce jest bardziej powszechne, aby używać niejawnie wpisane zmienne i zależą od nazwy interfejsu API do opisu typów obiektów sprawdzane.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="e2a6f-134">Utwórz nowy język C# **narzędzie do analizy kodu autonomicznego** projektu:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="e2a6f-135">W programie Visual Studio, wybierz **pliku** > **New** > **projektu** Aby wyświetlić okno dialogowe Nowy projekt.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="e2a6f-136">W obszarze **Visual C#** > **rozszerzalności**, wybierz **narzędzie do analizy kodu autonomicznego**.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="e2a6f-137">Nazwij swój projekt "**SemanticQuickStart**" i kliknij przycisk OK.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="e2a6f-138">Możesz zacząć analizować podstawowe "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="e2a6f-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="e2a6f-139">Program przedstawionej wcześniej.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-139">program shown earlier.</span></span>
<span data-ttu-id="e2a6f-140">Dodaj tekst programu Witaj świecie jako stała w swojej `Program` klasy:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="e2a6f-141">Następnie dodaj następujący kod do drzewa składni tekstu kodu w kompilacji `programText` stałej.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="e2a6f-142">Dodaj następujący wiersz do Twojej `Main` metody:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="e2a6f-143">Następnie kompilacji <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> z drzewa już utworzony.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="e2a6f-144">Zależy od przykładu "Hello World" <xref:System.String> i <xref:System.Console> typów.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="e2a6f-145">Należy odwoływać się do zestawu, który deklaruje tych dwóch typów w kompilacji.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="e2a6f-146">Dodaj następujący wiersz do Twojej `Main` metodę, aby utworzyć zbiór drzewo składni, w tym odwołanie do zestawu, odpowiednie:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="e2a6f-147"><xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> Metoda dodaje odwołania do kompilacji.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="e2a6f-148"><xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> Metoda ładuje zestaw jako odwołanie.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="e2a6f-149">Zapytania semantycznego modelu analizy biznesowej</span><span class="sxs-lookup"><span data-stu-id="e2a6f-149">Querying the semantic model</span></span>

<span data-ttu-id="e2a6f-150">Po utworzeniu <xref:Microsoft.CodeAnalysis.Compilation> możesz poprosić go dla <xref:Microsoft.CodeAnalysis.SemanticModel> dla każdego <xref:Microsoft.CodeAnalysis.SyntaxTree> zawarte w tym <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="e2a6f-151">Model semantyczny można traktować jako źródło dla wszystkich informacji, które normalnie otrzymamy od funkcji intellisense.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="e2a6f-152">Element <xref:Microsoft.CodeAnalysis.SemanticModel> może odpowiedzieć na pytania "Co nazw znajdują się w zakresie, w tym miejscu?", "jakie elementy członkowskie są dostępne z tej metody?", "jakie zmienne są używane w tym bloku tekstu?" i "Co to nazwa/wyrażenie odwołuje się do?"</span><span class="sxs-lookup"><span data-stu-id="e2a6f-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="e2a6f-153">Dodaj ten instrukcję, aby utworzyć model semantyczny:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="e2a6f-154">Nazwa powiązania</span><span class="sxs-lookup"><span data-stu-id="e2a6f-154">Binding a name</span></span>

<span data-ttu-id="e2a6f-155"><xref:Microsoft.CodeAnalysis.Compilation> Tworzy <xref:Microsoft.CodeAnalysis.SemanticModel> z <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="e2a6f-156">Po utworzeniu modelu, można je w celu znalezienia pierwszego zapytania `using` dyrektywy i pobieranie informacji o symbolach dla `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="e2a6f-157">Dodaj następujące dwa wiersze do Twojej `Main` metodę, aby utworzyć model semantyczny i pobrać symboli dla pierwszego instrukcję using:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="e2a6f-158">Poprzedni kod pokazuje jak powiązać nazwę w pierwszym `using` dyrektywy do pobrania <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> dla `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="e2a6f-159">Powyższy kod ilustruje także użycie **składnia model** można znaleźć struktury kodu; możesz użyć **semantycznego modelu analizy biznesowej** zrozumienie jego znaczenie.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="e2a6f-160">**Składnia model** odnajduje ciąg `System` za pomocą instrukcji.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="e2a6f-161">**Semantycznego modelu analizy biznesowej** zawiera wszystkie informacje dotyczące typów zdefiniowanych w `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="e2a6f-162">Z <xref:Microsoft.CodeAnalysis.SymbolInfo> obiektu można uzyskać <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> przy użyciu <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e2a6f-163">Ta właściwość zwraca symbol, którego to wyrażenie odwołuje się.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="e2a6f-164">W wyrażeniach, które nie odwołuje się do obiektów (np. literały numeryczne) tej właściwości jest `null`.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="e2a6f-165">Gdy <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> nie ma wartości null, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> wskazuje typ symbolu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="e2a6f-166">W tym przykładzie <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> właściwość <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2a6f-167">Dodaj następujący kod, aby Twoje `Main` metody.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="e2a6f-168">Pobiera symbol `System` przestrzeni nazw, a następnie wyświetla wszystkie podrzędne przestrzenie nazw zadeklarowanych w `System` przestrzeni nazw:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="e2a6f-169">Uruchom program i powinien zostać wyświetlony następujący komunikat:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-169">Run the program and you should see the following output:</span></span>

```
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="e2a6f-170">Dane wyjściowe będą zawierać każdej przestrzeni nazw, który jest podrzędna przestrzeń nazw z `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="e2a6f-171">Wyświetla każdej przestrzeni nazw, który znajduje się w tej kompilacji, który odwołuje się tylko do zestawu gdzie `System.String` jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="e2a6f-172">Wszystkie przestrzenie nazw zadeklarowanych w innych zestawach nie są znane w tej kompilacji</span><span class="sxs-lookup"><span data-stu-id="e2a6f-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="e2a6f-173">Powiązanie wyrażenia</span><span class="sxs-lookup"><span data-stu-id="e2a6f-173">Binding an expression</span></span>

<span data-ttu-id="e2a6f-174">Poprzedni kod pokazuje, jak znaleźć symboli przez powiązanie z nazwą.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="e2a6f-175">Istnieją inne wyrażenia w programie C#, która może być powiązana, których nie ma nazwy.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="e2a6f-176">Aby zademonstrować tę możliwość, umożliwia dostęp do powiązania do prostych literału ciągu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="e2a6f-177">Program "Hello World" zawiera <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="e2a6f-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="e2a6f-178">ciąg wyświetlany w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-178">string displayed to the console.</span></span>

<span data-ttu-id="e2a6f-179">Znajdź "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="e2a6f-179">You find the "Hello, World!"</span></span> <span data-ttu-id="e2a6f-180">ciąg, umieszczając pojedynczy ciąg literału w programie.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="e2a6f-181">Następnie po zlokalizowaniu węzeł składni, uzyskać informacje dotyczące typu dla tego węzła z modelu semantycznego.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="e2a6f-182">Dodaj następujący kod, aby Twoje `Main` metody:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="e2a6f-183"><xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> Struktura zawiera <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> właściwość, która umożliwia dostęp do informacji semantycznych o typie literału.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="e2a6f-184">W tym przykładzie to `string` typu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="e2a6f-185">Dodaj deklarację, że ta właściwość umożliwia przypisanie do zmiennej lokalnej:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="e2a6f-186">Aby ukończyć ten samouczek, utworzymy kwerenda LINQ, która tworzy sekwencję wszystkich metod publicznych zadeklarowanych w `string` wpisz zwracające `string`.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="e2a6f-187">To zapytanie pobiera złożony, więc ją skompilować wiersz po wierszu, odtworzyć go jako pojedynczego zapytania.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="e2a6f-188">Źródło dla tego zapytania jest sekwencja wszystkich elementów członkowskich zadeklarowanych w `string` typu:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="e2a6f-189">Tej sekwencji źródłowej zawiera wszystkie elementy członkowskie, w tym jej właściwości i pola, więc filtrować za pomocą <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> metodę, aby znaleźć elementy, które są <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> obiektów:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-189">That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="e2a6f-190">Następnie dodaj inny filtr, aby zwrócić tylko tych metod, które są publiczne ale zwracane `string`:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="e2a6f-191">Wybierz tylko właściwości name i tylko unikatowych nazw, usuwając wszystkie przeciążenia:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="e2a6f-192">Możesz również tworzyć pełne zapytanie przy użyciu składni zapytań LINQ i następnie wyświetlić nazwy metody, w konsoli:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 "Build and display the results of the query.")]

<span data-ttu-id="e2a6f-193">Skompiluj i uruchom program.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-193">Build and run the program.</span></span> <span data-ttu-id="e2a6f-194">Powinny zostać wyświetlone następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="e2a6f-194">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="e2a6f-195">Semantyczne interfejsu API został użyty do znalezienia i wyświetlać informacje na temat symboli, które są dostępne w ramach tego programu.</span><span class="sxs-lookup"><span data-stu-id="e2a6f-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
