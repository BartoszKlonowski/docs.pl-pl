---
title: Wprowadzenie do analizy składni (interfejsy API Roslyn)
description: Wprowadzenie do przechodzenia, wykonywania zapytań i eksplorowania drzew składni.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: d4163e8aadf577a5a5cbed225b26a0ec8390277e
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/25/2019
ms.locfileid: "75347001"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="e1cbe-103">Wprowadzenie do analizy składni</span><span class="sxs-lookup"><span data-stu-id="e1cbe-103">Get started with syntax analysis</span></span>

<span data-ttu-id="e1cbe-104">W tym samouczku poznasz **składnię interfejsu API**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="e1cbe-105">Interfejs API składni zapewnia dostęp do struktur danych, które opisują C# program lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="e1cbe-106">Te struktury danych mają wystarczającą ilość szczegółów, aby można było w pełni reprezentować każdy program dowolnego rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="e1cbe-107">Struktury te mogą opisywać kompletne programy, które kompilują i działają poprawnie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="e1cbe-108">Mogą również opisywać niekompletne programy podczas pisania ich w edytorze.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="e1cbe-109">Aby włączyć to wyrażenie bogate, struktury danych i interfejsy API, które składają się na interfejs API składni, muszą być złożone.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="e1cbe-110">Zacznijmy od tego, jak wygląda struktura danych dla typowego programu "Hello world":</span><span class="sxs-lookup"><span data-stu-id="e1cbe-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="e1cbe-111">Spójrz na tekst poprzedniego programu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-111">Look at the text of the previous program.</span></span> <span data-ttu-id="e1cbe-112">Rozpoznajesz znane elementy.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-112">You recognize familiar elements.</span></span> <span data-ttu-id="e1cbe-113">Cały tekst reprezentuje pojedynczy plik źródłowy lub **jednostkę kompilacji**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="e1cbe-114">Trzy pierwsze wiersze tego pliku źródłowego **używają dyrektyw**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="e1cbe-115">Pozostałe źródło jest zawarte w **deklaracji przestrzeni nazw**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="e1cbe-116">Deklaracja przestrzeni nazw zawiera podrzędną **deklarację klasy**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="e1cbe-117">Deklaracja klasy zawiera jedną **deklarację metody**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="e1cbe-118">Interfejs API składni tworzy strukturę drzewa z elementem głównym reprezentującym jednostkę kompilacji.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="e1cbe-119">Węzły w drzewie reprezentują dyrektywy using, deklarację przestrzeni nazw i wszystkie inne elementy programu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="e1cbe-120">Struktura drzewa przechodzi do najniższych poziomów: ciąg "Hello world!"</span><span class="sxs-lookup"><span data-stu-id="e1cbe-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="e1cbe-121">jest **tokenem literału ciągu** , który jest elementem podrzędnym **argumentu**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="e1cbe-122">Interfejs API składni zapewnia dostęp do struktury programu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="e1cbe-123">Można wykonywać zapytania dotyczące określonych rozwiązań kodu, przeszukać całe drzewo, aby zrozumieć kod i utworzyć nowe drzewa modyfikując istniejące drzewo.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="e1cbe-124">Ten krótki opis zawiera przegląd rodzaju informacji dostępnych przy użyciu interfejsu API składni.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="e1cbe-125">Interfejs API składni nie ma więcej niż formalny interfejs API, który opisuje znane konstrukcje kodu, które znasz C#.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="e1cbe-126">Pełne możliwości obejmują informacje o sposobie formatowania kodu, w tym podziały wierszy, biały znak i wcięcia.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="e1cbe-127">Korzystając z tych informacji, można w pełni przedstawić kod jako zapisany i odczytany przez programistów lub kompilator.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="e1cbe-128">Użycie tej struktury umożliwia współpracę z kodem źródłowym na poziomie głęboko zrozumiałym.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="e1cbe-129">Nie są już ciągami tekstowymi, ale dane reprezentują strukturę C# programu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="e1cbe-130">Aby rozpocząć, musisz zainstalować **zestaw SDK .NET compiler platform**:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="e1cbe-131">Opis drzew składni</span><span class="sxs-lookup"><span data-stu-id="e1cbe-131">Understanding syntax trees</span></span>

<span data-ttu-id="e1cbe-132">Składnia interfejsu API do analizy struktury C# kodu jest używana.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="e1cbe-133">**Interfejs API składni** udostępnia analizatory, drzewa składni i narzędzia do analizowania i konstruowania drzew składniowych.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="e1cbe-134">Jest to sposób wyszukiwania kodu dla określonych elementów składniowych lub odczytywania kodu dla programu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="e1cbe-135">Drzewo składni jest strukturą danych używaną przez kompilatory C# i Visual Basic, aby zrozumieć C# i Visual Basic programy.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="e1cbe-136">Drzewa składni są tworzone przez ten sam parser, który jest uruchamiany, gdy projekt jest skompilowany lub deweloper trafi na F5.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="e1cbe-137">Drzewa składni mają pełną wierność w języku; każdy bit informacji w pliku kodu jest reprezentowany w drzewie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="e1cbe-138">Zapisanie drzewa składni do tekstu powoduje odtworzenie dokładnego, przeanalizowanego tekstu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="e1cbe-139">Drzewa składniowe są również **niezmienne**; Po utworzeniu drzewa składni nie można go zmienić.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="e1cbe-140">Odbiorcy drzew mogą analizować drzewa na wielu wątkach, bez blokowania ani innych miar współbieżności, wiedząc, że dane nigdy nie ulegną zmianie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="e1cbe-141">Za pomocą interfejsów API można tworzyć nowe drzewa, które są wynikiem modyfikacji istniejącego drzewa.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="e1cbe-142">Cztery główne bloki konstrukcyjne drzew składni są następujące:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="e1cbe-143">Klasa <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, wystąpienie reprezentujące całe drzewo analizy.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="e1cbe-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> jest klasą abstrakcyjną, która ma pochodne specyficzne dla języka.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="e1cbe-145">Metody analizy klasy <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (lub <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) służą do analizowania tekstu w C# lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or Visual Basic.</span></span>
* <span data-ttu-id="e1cbe-146">Klasa <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>, wystąpienia reprezentujące konstrukcje składniowe, takie jak deklaracje, instrukcje, klauzule i wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="e1cbe-147">Struktura <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>, która reprezentuje pojedyncze słowo kluczowe, identyfikator, operator lub interpunkcja.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="e1cbe-148">A wreszcie struktura <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>, która reprezentuje składniowo nieznaczące bity informacji, takie jak odstęp między tokenami, dyrektywy przetwarzania wstępnego i komentarze.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="e1cbe-149">Kwizy, tokeny i węzły składają się hierarchicznie w celu utworzenia drzewa, które całkowicie reprezentuje wszystko w fragmencie Visual Basic lub C# kodu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="e1cbe-150">Tę strukturę można zobaczyć przy użyciu okna **Syntax Visualizer** .</span><span class="sxs-lookup"><span data-stu-id="e1cbe-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="e1cbe-151">W programie Visual Studio wybierz pozycję **wyświetl** > innych **Syntax Visualizer** **Windows** > .</span><span class="sxs-lookup"><span data-stu-id="e1cbe-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="e1cbe-152">Na przykład poprzedni C# plik źródłowy zbadany przy użyciu **Syntax Visualizer** wygląda następująco:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="e1cbe-153">**SyntaxNode**: Blue | **SyntaxToken**: zielony | **SyntaxTrivia**: czerwony ![C# pliku kodu](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="e1cbe-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="e1cbe-154">Przechodząc do tej struktury drzewa, można znaleźć dowolne instrukcje, wyrażenie, token lub bit białych znaków w pliku kodu.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="e1cbe-155">Chociaż można znaleźć coś w pliku kodu przy użyciu składni interfejsów API, większość scenariuszy obejmuje badanie małych fragmentów kodu lub wyszukiwanie konkretnych instrukcji lub fragmentów.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="e1cbe-156">Dwa przykłady, które obserwują typowe zastosowania do przeglądania struktury kodu lub wyszukiwania pojedynczych instrukcji.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="e1cbe-157">Przechodzenie między drzewami</span><span class="sxs-lookup"><span data-stu-id="e1cbe-157">Traversing trees</span></span>

<span data-ttu-id="e1cbe-158">Węzły w drzewie składni można przeanalizować na dwa sposoby.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="e1cbe-159">Można przechodzić przez drzewo, aby zbadać każdy węzeł, lub można wykonywać zapytania dotyczące określonych elementów lub węzłów.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="e1cbe-160">Ręczne przechodzenie</span><span class="sxs-lookup"><span data-stu-id="e1cbe-160">Manual traversal</span></span>

<span data-ttu-id="e1cbe-161">Gotowy kod dla tego przykładu można zobaczyć w [naszym repozytorium GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="e1cbe-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="e1cbe-162">Typy drzewa składni używają dziedziczenia do opisywania różnych elementów składni, które są prawidłowe w różnych lokalizacjach w programie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="e1cbe-163">Użycie tych interfejsów API często oznacza rzutowanie właściwości lub członków kolekcji na określone typy pochodne.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="e1cbe-164">W poniższych przykładach przypisanie i rzutowania są oddzielnymi instrukcjami przy użyciu jawnie wpisanych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="e1cbe-165">Kod można odczytać, aby wyświetlić typy zwracane przez interfejs API i typ środowiska uruchomieniowego zwracanych obiektów.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="e1cbe-166">W rzeczywistości jest to bardziej powszechne użycie niejawnie wpisanych zmiennych i poleganie na nazwach interfejsów API do opisywania typu badanych obiektów.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="e1cbe-167">Utwórz nowy C# projekt **Narzędzia do analizy kodu autonomicznego** :</span><span class="sxs-lookup"><span data-stu-id="e1cbe-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="e1cbe-168">W programie Visual Studio wybierz kolejno pozycje **plik** > **Nowy** > **projekt** , aby wyświetlić okno dialogowe Nowy projekt.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="e1cbe-169">W obszarze **rozszerzalność** **Visual C#**  > wybierz pozycję **Narzędzie do analizy kodu autonomicznego**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="e1cbe-170">Nadaj projektowi nazwę "**SyntaxTreeManualTraversal**" i kliknij przycisk OK.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="e1cbe-171">Zamierzasz analizować podstawową "Hello world!"</span><span class="sxs-lookup"><span data-stu-id="e1cbe-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="e1cbe-172">pokazany wcześniej program.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-172">program shown earlier.</span></span>
<span data-ttu-id="e1cbe-173">Dodaj tekst dla programu Hello world jako stałą w klasie `Program`:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="e1cbe-174">Następnie Dodaj następujący kod, aby skompilować **drzewo składni** dla tekstu kodu w `programText` stałej.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="e1cbe-175">Dodaj następujący wiersz do metody `Main`:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="e1cbe-176">Te dwa wiersze tworzą drzewo i pobierają węzeł główny tego drzewa.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="e1cbe-177">Teraz można przeanalizować węzły w drzewie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="e1cbe-178">Dodaj te wiersze do metody `Main`, aby wyświetlić niektóre właściwości węzła głównego w drzewie:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="e1cbe-179">Uruchom aplikację, aby zobaczyć, co Twój kod wykrył w węźle głównym w tym drzewie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="e1cbe-180">Zwykle przejdziesz do drzewa, aby dowiedzieć się więcej o kodzie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="e1cbe-181">W tym przykładzie analizujesz kod, który znasz, aby poznać interfejsy API.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="e1cbe-182">Dodaj następujący kod, aby przeanalizować pierwszego członka węzła `root`:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="e1cbe-183">Ten element członkowski jest <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1cbe-184">Reprezentuje wszystko w zakresie deklaracji `namespace HelloWorld`.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="e1cbe-185">Dodaj następujący kod, aby ocenić, które węzły są zadeklarowane wewnątrz przestrzeni nazw `HelloWorld`:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="e1cbe-186">Uruchom program, aby zobaczyć, co się stało.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="e1cbe-187">Teraz, gdy znasz deklarację <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, Zadeklaruj nową zmienną tego typu, aby sprawdzić deklarację klasy.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="e1cbe-188">Ta klasa zawiera tylko jeden element członkowski: Metoda `Main`.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="e1cbe-189">Dodaj następujący kod, aby znaleźć metodę `Main` i rzutować ją na <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="e1cbe-190">Węzeł deklaracji metody zawiera wszystkie informacje o składni metody.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="e1cbe-191">Umożliwia wyświetlenie zwracanego typu metody `Main`, liczby i typów argumentów oraz tekstu treści metody.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="e1cbe-192">Dodaj następujący kod:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="e1cbe-193">Uruchom program, aby wyświetlić wszystkie wykryte informacje o tym programie:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="e1cbe-194">Metody zapytań</span><span class="sxs-lookup"><span data-stu-id="e1cbe-194">Query methods</span></span>

<span data-ttu-id="e1cbe-195">Oprócz przechodzenia między drzewami można także eksplorować drzewo składni przy użyciu metod zapytania zdefiniowanych w <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1cbe-196">Metody te powinny być od razu znane dla każdego, kto zna wyrażenie XPath.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="e1cbe-197">Za pomocą tych metod można szybko znaleźć elementy w drzewie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="e1cbe-198"><xref:Microsoft.CodeAnalysis.SyntaxNode> ma metody zapytania, takie jak <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> i <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="e1cbe-199">Za pomocą tych metod zapytania można znaleźć argument metody `Main` jako alternatywę dla nawigowania po drzewie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="e1cbe-200">Dodaj następujący kod na dole metody `Main`:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="e1cbe-201">Pierwsza instrukcja używa wyrażenia LINQ i metody <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, aby zlokalizować ten sam parametr jak w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="e1cbe-202">Uruchom program i sprawdź, czy wyrażenie LINQ znalazło ten sam parametr co ręczne nawigowanie po drzewie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="e1cbe-203">Przykład używa instrukcji `WriteLine`, aby wyświetlić informacje o drzewach składni w miarę ich przechodzenia.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="e1cbe-204">Więcej informacji można również uzyskać, uruchamiając gotowy program w debugerze.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="e1cbe-205">Można zapoznać się z większą liczbą właściwości i metod, które są częścią drzewa składni utworzonego dla programu Hello World.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="e1cbe-206">Instruktaże składniowe</span><span class="sxs-lookup"><span data-stu-id="e1cbe-206">Syntax walkers</span></span>

<span data-ttu-id="e1cbe-207">Często chcesz znaleźć wszystkie węzły określonego typu w drzewie składni, na przykład każdą deklarację właściwości w pliku.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="e1cbe-208">Rozszerzając klasę <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> i zastępując metodę <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)>, przetwarzasz każdą deklarację właściwości w drzewie składni bez uprzedniego znajomości swojej struktury.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="e1cbe-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> jest szczególnym rodzajem <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor>, które rekursywnie odwiedza węzeł i każdy z jego elementów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="e1cbe-210">Ten przykład implementuje <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, który analizuje drzewo składni.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="e1cbe-211">Zbiera `using` dyrektywy znalezionych, które nie importuje `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="e1cbe-212">Utwórz nowy C# projekt **Narzędzia do analizy kodu autonomicznego** ; Nadaj mu nazwę "**SyntaxWalker**".</span><span class="sxs-lookup"><span data-stu-id="e1cbe-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="e1cbe-213">Gotowy kod dla tego przykładu można zobaczyć w [naszym repozytorium GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="e1cbe-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="e1cbe-214">Przykład w witrynie GitHub zawiera projekty opisane w tym samouczku.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="e1cbe-215">Tak jak w poprzednim przykładzie, można zdefiniować stałą ciągu, aby pomieścić tekst programu, który ma być analizowany:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="e1cbe-216">Ten tekst źródłowy zawiera dyrektywy `using` rozłożone na cztery różne lokalizacje: na poziomie pliku, w przestrzeni nazw najwyższego poziomu i w dwóch zagnieżdżonych obszarach nazw.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="e1cbe-217">Ten przykład wyróżnia scenariusz podstawowy dla użycia klasy <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> do wykonywania zapytań w kodzie.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="e1cbe-218">Aby znaleźć deklaracje, można odwiedzać każdy węzeł w głównym drzewie składni.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="e1cbe-219">Zamiast tego należy utworzyć klasę pochodną i zastąpić metodę, która jest wywoływana tylko wtedy, gdy bieżący węzeł drzewa jest dyrektywą using.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="e1cbe-220">Odwiedzający nie wykonuje żadnej pracy na żadnym innym typie węzła.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="e1cbe-221">Ta pojedyncza Metoda analizuje poszczególne instrukcje `using` i tworzy kolekcję przestrzeni nazw, które nie znajdują się w `System` przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="e1cbe-222">Tworzysz <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, który analizuje wszystkie instrukcje `using`, ale tylko instrukcje `using`.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="e1cbe-223">Po zdefiniowaniu tekstu programu należy utworzyć `SyntaxTree` i uzyskać katalog główny tego drzewa:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="e1cbe-224">Następnie utwórz nową klasę.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-224">Next, create a new class.</span></span> <span data-ttu-id="e1cbe-225">W programie Visual Studio wybierz pozycję **projekt** > **Dodaj nowy element**.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="e1cbe-226">W oknie dialogowym **Dodaj nowy element** wpisz *UsingCollector.cs* jako nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="e1cbe-227">Zaimplementowanie funkcji odwiedzającej `using` w klasie `UsingCollector`.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="e1cbe-228">Zacznij od wprowadzenia klasy `UsingCollector` pochodnej z <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="e1cbe-229">Potrzebujesz magazynu, w którym będą przechowywane węzły przestrzeni nazw, które są zbierane.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="e1cbe-230">Zadeklaruj publiczną właściwość tylko do odczytu w klasie `UsingCollector`; Ta zmienna służy do przechowywania odnalezionych <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> węzłów:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="e1cbe-231">Klasa bazowa, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implementuje logikę, aby odwiedzać każdy węzeł w drzewie składni.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="e1cbe-232">Klasa pochodna przesłania metody wywoływane dla określonych odpowiednich węzłów.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="e1cbe-233">W tym przypadku interesuje Cię `using` dyrektywę.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="e1cbe-234">Oznacza to, że należy zastąpić metodę <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="e1cbe-235">Jeden z argumentów tej metody jest obiektem <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="e1cbe-236">Jest to ważna korzyść przy użyciu osób odwiedzających: wywołuje zastąpione metody z argumentami, które są już rzutowane na określony typ węzła.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="e1cbe-237">Klasa <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> ma właściwość <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name>, która przechowuje nazwę importowanej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="e1cbe-238">Jest to <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1cbe-239">Dodaj następujący kod w <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> przesłonięciu:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="e1cbe-240">Podobnie jak w przypadku wcześniejszego przykładu dodano szereg instrukcji `WriteLine`, które ułatwią zrozumienie tej metody.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="e1cbe-241">Możesz zobaczyć, kiedy jest wywoływana, i jakie argumenty są do niego przesyłane za każdym razem.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="e1cbe-242">Na koniec należy dodać dwa wiersze kodu, aby utworzyć `UsingCollector` i odwiedzać węzeł główny, zbierając wszystkie instrukcje `using`.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="e1cbe-243">Następnie Dodaj pętlę `foreach`, aby wyświetlić wszystkie instrukcje `using` znalezione przez moduł zbierający:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="e1cbe-244">Skompiluj i uruchom program.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-244">Compile and run the program.</span></span> <span data-ttu-id="e1cbe-245">Powinny zostać wyświetlone następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="e1cbe-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="e1cbe-246">Gratulacje!</span><span class="sxs-lookup"><span data-stu-id="e1cbe-246">Congratulations!</span></span> <span data-ttu-id="e1cbe-247">**Interfejs API składni** jest używany do lokalizowania określonych rodzajów C# instrukcji i deklaracji w C# kodzie źródłowym.</span><span class="sxs-lookup"><span data-stu-id="e1cbe-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
