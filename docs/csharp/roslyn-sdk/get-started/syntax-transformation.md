---
title: Wprowadzenie do transformacji składni (interfejsy API Roslyn)
description: Wprowadzenie do przechodzenia, wykonywania zapytań i przechodzenia drzew składni.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 5045dca839daba1070b34720e72cc9c4f7b94828
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240613"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="a54c6-103">Wprowadzenie do transformacji składni</span><span class="sxs-lookup"><span data-stu-id="a54c6-103">Get started with syntax transformation</span></span>

<span data-ttu-id="a54c6-104">Ten samouczek opiera się na pojęciach i technikach eksplorowanych w [temacie Rozpocznij analizę składni](syntax-analysis.md) i rozpocznij pracę z przewodnikiem Szybki start [analizy semantycznej.](semantic-analysis.md)</span><span class="sxs-lookup"><span data-stu-id="a54c6-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="a54c6-105">Jeśli jeszcze tego nie zrobiłeś, należy ukończyć te szybkie uruchamianie przed rozpoczęciem tego.</span><span class="sxs-lookup"><span data-stu-id="a54c6-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="a54c6-106">W tym przewodniku Szybki start można eksplorować techniki tworzenia i przekształcania drzew składni.</span><span class="sxs-lookup"><span data-stu-id="a54c6-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="a54c6-107">W połączeniu z technikami, których nauczyłeś się w poprzednich przewodnikach Szybki start, tworzysz swoją pierwszą refaktoryzacją wiersza polecenia!</span><span class="sxs-lookup"><span data-stu-id="a54c6-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="a54c6-108">Niezmienność i platforma kompilatora .NET</span><span class="sxs-lookup"><span data-stu-id="a54c6-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="a54c6-109">**Niezmienność** jest podstawową zasadą platformy kompilatora .NET.</span><span class="sxs-lookup"><span data-stu-id="a54c6-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="a54c6-110">Niezmienne struktury danych nie można zmienić po ich utworzeniu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="a54c6-111">Niezmienne struktury danych mogą być bezpiecznie udostępniane i analizowane przez wielu konsumentów jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="a54c6-112">Nie ma niebezpieczeństwa, że jeden konsument wpływa na drugiego w nieprzewidywalny sposób.</span><span class="sxs-lookup"><span data-stu-id="a54c6-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="a54c6-113">Analizator nie wymaga blokad lub innych środków współbieżności.</span><span class="sxs-lookup"><span data-stu-id="a54c6-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="a54c6-114">Ta reguła ma zastosowanie do drzew składni, kompilacji, symboli, modeli semantycznych i każdej innej napotkanej struktury danych.</span><span class="sxs-lookup"><span data-stu-id="a54c6-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="a54c6-115">Zamiast modyfikować istniejące struktury, interfejsy API tworzą nowe obiekty na podstawie określonych różnic w stosunku do starych.</span><span class="sxs-lookup"><span data-stu-id="a54c6-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="a54c6-116">Ta koncepcja jest stosowana do drzew składni, aby utworzyć nowe drzewa przy użyciu przekształceń.</span><span class="sxs-lookup"><span data-stu-id="a54c6-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="a54c6-117">Tworzenie i przekształcanie drzew</span><span class="sxs-lookup"><span data-stu-id="a54c6-117">Create and transform trees</span></span>

<span data-ttu-id="a54c6-118">Wybierz jedną z dwóch strategii dla przekształceń składni.</span><span class="sxs-lookup"><span data-stu-id="a54c6-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="a54c6-119">**Metody fabryczne** są najlepiej używane podczas wyszukiwania określonych węzłów do zastąpienia lub określonych lokalizacji, w których chcesz wstawić nowy kod.</span><span class="sxs-lookup"><span data-stu-id="a54c6-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="a54c6-120">**Ponowne moduły zapisujące** są najlepsze, gdy chcesz zeskanować cały projekt w poszukiwaniu wzorców kodu, które chcesz zastąpić.</span><span class="sxs-lookup"><span data-stu-id="a54c6-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="a54c6-121">Tworzenie węzłów z metodami fabrycznymi</span><span class="sxs-lookup"><span data-stu-id="a54c6-121">Create nodes with factory methods</span></span>

<span data-ttu-id="a54c6-122">Pierwsza transformacja składni demonstruje metody fabryczne.</span><span class="sxs-lookup"><span data-stu-id="a54c6-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="a54c6-123">Zamierzasz zastąpić oświadczenie `using System.Collections;` `using System.Collections.Generic;` oświadczeniem.</span><span class="sxs-lookup"><span data-stu-id="a54c6-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="a54c6-124">W tym przykładzie pokazano, jak tworzyć <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> obiekty przy użyciu metod <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> fabrycznych.</span><span class="sxs-lookup"><span data-stu-id="a54c6-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="a54c6-125">Dla każdego rodzaju **węzła**, **tokenu**lub **ciekawostki** istnieje metoda fabryczna, która tworzy wystąpienie tego typu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="a54c6-126">Drzewa składni można tworzyć, redagując węzły hierarchicznie w sposób oddolny.</span><span class="sxs-lookup"><span data-stu-id="a54c6-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="a54c6-127">Następnie przekształcisz istniejący program zastępując istniejące węzły nowym utworzonym drzewem.</span><span class="sxs-lookup"><span data-stu-id="a54c6-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="a54c6-128">Uruchom program Visual Studio i utwórz nowy projekt narzędzia do **analizy kodu autonomicznego** języka C#.</span><span class="sxs-lookup"><span data-stu-id="a54c6-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="a54c6-129">W programie Visual Studio wybierz pozycję **Plik** > **nowy** > **projekt,** aby wyświetlić okno dialogowe Nowy projekt.</span><span class="sxs-lookup"><span data-stu-id="a54c6-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="a54c6-130">W obszarze**Rozszerzalność** **języka Visual C#** > wybierz **autonomiczne narzędzie do analizy kodu**.</span><span class="sxs-lookup"><span data-stu-id="a54c6-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="a54c6-131">Ten szybki start ma dwa przykładowe projekty, więc nazwij rozwiązanie **SyntaxTransformationQuickStart**i nazwij projekt **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="a54c6-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="a54c6-132">Kliknij przycisk **OK**.</span><span class="sxs-lookup"><span data-stu-id="a54c6-132">Click **OK**.</span></span>

<span data-ttu-id="a54c6-133">Ten projekt <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> używa metod klasy <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> do konstruowania reprezentujących `System.Collections.Generic` obszar nazw.</span><span class="sxs-lookup"><span data-stu-id="a54c6-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="a54c6-134">Dodaj następujące za pomocą dyrektywy `Program.cs` do góry pliku, aby <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> zaimportować metody <xref:System.Console> fabryki klasy i metody, dzięki czemu można ich używać później bez ich kwalifikowania:</span><span class="sxs-lookup"><span data-stu-id="a54c6-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="a54c6-135">Utworzysz **węzły składni nazw,** aby utworzyć `using System.Collections.Generic;` drzewo reprezentujące instrukcję.</span><span class="sxs-lookup"><span data-stu-id="a54c6-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="a54c6-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>jest klasą podstawową dla czterech typów nazw, które pojawiają się w języku C#.</span><span class="sxs-lookup"><span data-stu-id="a54c6-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="a54c6-137">Skomponuj te cztery typy nazw razem, aby utworzyć dowolną nazwę, która może pojawić się w języku C#:</span><span class="sxs-lookup"><span data-stu-id="a54c6-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="a54c6-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, który reprezentuje proste nazwy `System` pojedynczego identyfikatora, takie jak i `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="a54c6-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="a54c6-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, który reprezentuje typ ogólny lub `List<int>`nazwę metody, taką jak .</span><span class="sxs-lookup"><span data-stu-id="a54c6-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="a54c6-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, która reprezentuje kwalifikowaną nazwę `<left-name>.<right-identifier-or-generic-name>` formularza, `System.IO`taką jak .</span><span class="sxs-lookup"><span data-stu-id="a54c6-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="a54c6-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, który reprezentuje nazwę przy użyciu złożenia extern alias taki . `LibraryV2::Foo`</span><span class="sxs-lookup"><span data-stu-id="a54c6-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="a54c6-142"><xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> Metoda służy do tworzenia <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> węzła.</span><span class="sxs-lookup"><span data-stu-id="a54c6-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="a54c6-143">Dodaj następujący kod `Main` w `Program.cs`metodzie w:</span><span class="sxs-lookup"><span data-stu-id="a54c6-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="a54c6-144">Poprzedni kod tworzy <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> obiekt i przypisuje go `name`do zmiennej .</span><span class="sxs-lookup"><span data-stu-id="a54c6-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="a54c6-145">Wiele interfejsów API Roslyn zwraca klasy podstawowe, aby ułatwić pracę z powiązanymi typami.</span><span class="sxs-lookup"><span data-stu-id="a54c6-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="a54c6-146">Zmienna `name`, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>a , może być <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>ponownie użyty podczas tworzenia .</span><span class="sxs-lookup"><span data-stu-id="a54c6-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="a54c6-147">Nie należy używać wnioskowania o typie podczas tworzenia próbki.</span><span class="sxs-lookup"><span data-stu-id="a54c6-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="a54c6-148">Zautomatyzujesz ten krok w tym projekcie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="a54c6-149">Nazwa została utworzona.</span><span class="sxs-lookup"><span data-stu-id="a54c6-149">You've created the name.</span></span> <span data-ttu-id="a54c6-150">Teraz nadszedł czas, aby zbudować więcej węzłów <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>w drzewie, budując .</span><span class="sxs-lookup"><span data-stu-id="a54c6-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="a54c6-151">Nowe drzewo `name` używa jako lewej nazwy i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> nowego `Collections` obszaru nazw jako prawej <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>strony .</span><span class="sxs-lookup"><span data-stu-id="a54c6-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="a54c6-152">Dodaj następujący kod do pliku `program.cs`:</span><span class="sxs-lookup"><span data-stu-id="a54c6-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="a54c6-153">Uruchom kod ponownie i zobacz wyniki.</span><span class="sxs-lookup"><span data-stu-id="a54c6-153">Run the code again, and see the results.</span></span> <span data-ttu-id="a54c6-154">Budujesz drzewo węzłów, które reprezentuje kod.</span><span class="sxs-lookup"><span data-stu-id="a54c6-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="a54c6-155">Będziesz kontynuować ten wzorzec, aby utworzyć <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> dla obszaru `System.Collections.Generic`nazw .</span><span class="sxs-lookup"><span data-stu-id="a54c6-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="a54c6-156">Dodaj następujący kod do pliku `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="a54c6-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="a54c6-157">Uruchom program ponownie, aby zobaczyć, że masz skompilować drzewo dla kodu do dodania.</span><span class="sxs-lookup"><span data-stu-id="a54c6-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="a54c6-158">Tworzenie zmodyfikowanego drzewa</span><span class="sxs-lookup"><span data-stu-id="a54c6-158">Create a modified tree</span></span>

<span data-ttu-id="a54c6-159">Zbudowano małe drzewo składni, które zawiera jedną instrukcję.</span><span class="sxs-lookup"><span data-stu-id="a54c6-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="a54c6-160">Interfejsy API do tworzenia nowych węzłów są właściwym wyborem do tworzenia pojedynczych instrukcji lub innych małych bloków kodu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="a54c6-161">Jednak aby utworzyć większe bloki kodu, należy użyć metod, które zastępują węzły lub wstawić węzły do istniejącego drzewa.</span><span class="sxs-lookup"><span data-stu-id="a54c6-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="a54c6-162">Pamiętaj, że drzewa składni są niezmienne.</span><span class="sxs-lookup"><span data-stu-id="a54c6-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="a54c6-163">**Interfejs API składni** nie zapewnia żadnego mechanizmu modyfikowania istniejącego drzewa składni po zakończeniu budowy.</span><span class="sxs-lookup"><span data-stu-id="a54c6-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="a54c6-164">Zamiast tego zapewnia metody, które produkują nowe drzewa na podstawie zmian do istniejących.</span><span class="sxs-lookup"><span data-stu-id="a54c6-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="a54c6-165">`With*`metody są zdefiniowane w konkretnych klas, <xref:Microsoft.CodeAnalysis.SyntaxNode> które pochodzą z lub <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> w metod rozszerzenia zadeklarowanych w klasie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="a54c6-166">Metody te tworzą nowy węzeł, stosując zmiany do istniejących właściwości podrzędnych węzła.</span><span class="sxs-lookup"><span data-stu-id="a54c6-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="a54c6-167">Ponadto metoda <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> rozszerzenia może służyć do zastąpienia węzła malejąco w poddrzewie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="a54c6-168">Ta metoda aktualizuje również element nadrzędny, aby wskazać nowo utworzonego elementu podrzędnego i powtarza ten proces w górę całego drzewa - proces znany jako _ponowne obracanie_ drzewa.</span><span class="sxs-lookup"><span data-stu-id="a54c6-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="a54c6-169">Następnym krokiem jest utworzenie drzewa, które reprezentuje cały (mały) program, a następnie zmodyfikować go.</span><span class="sxs-lookup"><span data-stu-id="a54c6-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="a54c6-170">Dodaj następujący kod na początku `Program` klasy:</span><span class="sxs-lookup"><span data-stu-id="a54c6-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="a54c6-171">Przykładowy kod `System.Collections` używa obszaru nazw, a `System.Collections.Generic` nie obszaru nazw.</span><span class="sxs-lookup"><span data-stu-id="a54c6-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="a54c6-172">Następnie dodaj następujący kod do dolnej części `Main` metody, aby przeanalizować tekst i utworzyć drzewo:</span><span class="sxs-lookup"><span data-stu-id="a54c6-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="a54c6-173">W tym <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> przykładzie użyto metody, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> aby zastąpić nazwę w węźle z jednym skonstruowane w poprzednim kodzie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="a54c6-174">Utwórz <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nowy węzeł <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> przy użyciu `System.Collections` metody, aby zaktualizować nazwę o nazwę utworzoną w poprzednim kodzie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="a54c6-175">Dodaj następujący kod do dolnej części `Main` metody:</span><span class="sxs-lookup"><span data-stu-id="a54c6-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="a54c6-176">Uruchom program i przyjrzyj się uważnie wyjściu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="a54c6-177">Nie `newusing` został umieszczony w drzewie głównym.</span><span class="sxs-lookup"><span data-stu-id="a54c6-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="a54c6-178">Oryginalne drzewo nie zostało zmienione.</span><span class="sxs-lookup"><span data-stu-id="a54c6-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="a54c6-179">Dodaj następujący kod <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> przy użyciu metody rozszerzenia, aby utworzyć nowe drzewo.</span><span class="sxs-lookup"><span data-stu-id="a54c6-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="a54c6-180">Nowe drzewo jest wynikiem zastąpienia istniejącego importu zaktualizowanym `newUsing` węzłem.</span><span class="sxs-lookup"><span data-stu-id="a54c6-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="a54c6-181">To nowe drzewo można przypisać `root` do istniejącej zmiennej:</span><span class="sxs-lookup"><span data-stu-id="a54c6-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="a54c6-182">Uruchom program ponownie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-182">Run the program again.</span></span> <span data-ttu-id="a54c6-183">Tym razem drzewo poprawnie importuje `System.Collections.Generic` obszar nazw.</span><span class="sxs-lookup"><span data-stu-id="a54c6-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="a54c6-184">Przekształcanie drzew za pomocą`SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="a54c6-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="a54c6-185">Metody `With*` <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> i zapewniają wygodne środki do przekształcania poszczególnych gałęzi drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="a54c6-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="a54c6-186">Klasa <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> wykonuje wiele przekształceń w drzewie składni.</span><span class="sxs-lookup"><span data-stu-id="a54c6-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="a54c6-187">Klasa <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> jest podklasą <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a54c6-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a54c6-188">Stosuje <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> transformację do określonego typu <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="a54c6-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="a54c6-189">Przekształcenia można stosować do wielu <xref:Microsoft.CodeAnalysis.SyntaxNode> typów obiektów wszędzie tam, gdzie pojawiają się w drzewie składni.</span><span class="sxs-lookup"><span data-stu-id="a54c6-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="a54c6-190">Drugi projekt w tym przewodniku Szybki start tworzy refaktoryzacji wiersza polecenia, który usuwa jawne typy w deklaracjach zmiennych lokalnych w dowolnym miejscu, że wnioskowanie typu może być używany.</span><span class="sxs-lookup"><span data-stu-id="a54c6-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="a54c6-191">Utwórz nowy projekt narzędzia do **analizy kodu autonomicznego** języka C#.</span><span class="sxs-lookup"><span data-stu-id="a54c6-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="a54c6-192">W programie Visual Studio `SyntaxTransformationQuickStart` kliknij prawym przyciskiem myszy węzeł rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="a54c6-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="a54c6-193">Wybierz **pozycję Dodaj** > **nowy projekt,** aby wyświetlić okno **dialogowe Nowy projekt**.</span><span class="sxs-lookup"><span data-stu-id="a54c6-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="a54c6-194">W obszarze**Rozszerzalność** **języka Visual C#** > wybierz pozycję **Autonomiczne narzędzie do analizy kodu**.</span><span class="sxs-lookup"><span data-stu-id="a54c6-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="a54c6-195">Nazwij `TransformationCS` projekt i kliknij przycisk OK.</span><span class="sxs-lookup"><span data-stu-id="a54c6-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="a54c6-196">Pierwszym krokiem jest utworzenie klasy, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> która pochodzi z do wykonywania przekształceń.</span><span class="sxs-lookup"><span data-stu-id="a54c6-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="a54c6-197">Dodaj nowy plik klasy do projektu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-197">Add a new class file to the project.</span></span> <span data-ttu-id="a54c6-198">W programie Visual Studio wybierz pozycję **Project** > **Add Class...**. W **Add New Item** oknie `TypeInferenceRewriter.cs` dialogowym Dodawanie nowego elementu jako nazwa pliku.</span><span class="sxs-lookup"><span data-stu-id="a54c6-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="a54c6-199">Dodaj następujące dyrektywy do `TypeInferenceRewriter.cs` pliku:</span><span class="sxs-lookup"><span data-stu-id="a54c6-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="a54c6-200">Następnie upewnij `TypeInferenceRewriter` się, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> że klasa rozszerza klasę:</span><span class="sxs-lookup"><span data-stu-id="a54c6-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="a54c6-201">Dodaj następujący kod, aby zadeklarować prywatne pole <xref:Microsoft.CodeAnalysis.SemanticModel> tylko do odczytu, aby pomieścić i zainicjować je w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="a54c6-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="a54c6-202">To pole będzie potrzebne później, aby określić, gdzie można użyć wnioskowania o typie:</span><span class="sxs-lookup"><span data-stu-id="a54c6-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="a54c6-203">Zastąp <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> metodę:</span><span class="sxs-lookup"><span data-stu-id="a54c6-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="a54c6-204">Wiele interfejsów API Roslyn zadeklarować zwracać typy, które są klasami podstawowymi rzeczywistych typów czasu wykonywania zwracanych.</span><span class="sxs-lookup"><span data-stu-id="a54c6-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="a54c6-205">W wielu scenariuszach jeden rodzaj węzła może zostać całkowicie zastąpiony przez inny rodzaj węzła lub nawet usunięty.</span><span class="sxs-lookup"><span data-stu-id="a54c6-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="a54c6-206">W tym przykładzie <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> metoda <xref:Microsoft.CodeAnalysis.SyntaxNode>zwraca , zamiast pochodnego <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>typu .</span><span class="sxs-lookup"><span data-stu-id="a54c6-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="a54c6-207">To przepisanie <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> zwraca nowy węzeł na podstawie istniejącego.</span><span class="sxs-lookup"><span data-stu-id="a54c6-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="a54c6-208">Ten szybki start obsługuje deklaracje zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="a54c6-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="a54c6-209">Można rozszerzyć go do innych `foreach` deklaracji, `for` takich jak pętle, pętle, wyrażenia LINQ i wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="a54c6-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="a54c6-210">Ponadto ta przepisana zmieni jedynie deklaracje najprostszej formy:</span><span class="sxs-lookup"><span data-stu-id="a54c6-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="a54c6-211">Jeśli chcesz eksplorować samodzielnie, należy rozważyć rozszerzenie gotowego przykładu dla tych typów deklaracji zmiennych:</span><span class="sxs-lookup"><span data-stu-id="a54c6-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="a54c6-212">Dodaj następujący kod do treści `VisitLocalDeclarationStatement` metody, aby pominąć przepisywanie tych form deklaracji:</span><span class="sxs-lookup"><span data-stu-id="a54c6-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="a54c6-213">Metoda wskazuje, że nie ma na `node` nowo przepisanie odbywa się przez zwrócenie parametru niezmodyfikowane.</span><span class="sxs-lookup"><span data-stu-id="a54c6-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="a54c6-214">Jeśli żadne z `if` tych wyrażeń nie są spełnione, węzeł reprezentuje możliwą deklarację z inicjowaniem.</span><span class="sxs-lookup"><span data-stu-id="a54c6-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="a54c6-215">Dodaj te instrukcje, aby wyodrębnić nazwę typu określoną <xref:Microsoft.CodeAnalysis.SemanticModel> w deklaracji i powiązać ją za pomocą pola w celu uzyskania symbolu typu:</span><span class="sxs-lookup"><span data-stu-id="a54c6-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="a54c6-216">Teraz dodaj tę instrukcję, aby powiązać wyrażenie inicjatora:</span><span class="sxs-lookup"><span data-stu-id="a54c6-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="a54c6-217">Na koniec dodaj `if` następującą instrukcję, `var` aby zastąpić istniejącą nazwę typu słowem kluczowym, jeśli typ wyrażenia inicjatora pasuje do określonego typu:</span><span class="sxs-lookup"><span data-stu-id="a54c6-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="a54c6-218">Warunek jest wymagany, ponieważ deklaracja może rzutować wyrażenie inicjatora do klasy podstawowej lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="a54c6-219">Jeśli jest to pożądane, typy po lewej i prawej stronie przypisania nie są zgodne.</span><span class="sxs-lookup"><span data-stu-id="a54c6-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="a54c6-220">Usunięcie jawnego typu w takich przypadkach spowoduje zmianę semantyki programu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="a54c6-221">`var`jest określony jako identyfikator, a nie `var` słowo kluczowe, ponieważ jest kontekstowe słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="a54c6-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="a54c6-222">Ciekawostki wiodące i końcowe (biały znak) są przenoszone `var` ze starej nazwy typu do słowa kluczowego w celu zachowania pionowego odstępu i wcięcia.</span><span class="sxs-lookup"><span data-stu-id="a54c6-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="a54c6-223">Jest to prostsze w użyciu, `ReplaceNode` a nie `With*` do przekształcania, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> ponieważ nazwa typu jest rzeczywiście wnukiem deklaracji instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a54c6-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="a54c6-224">Zakończyłeś `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="a54c6-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="a54c6-225">Teraz wróć `Program.cs` do pliku, aby zakończyć przykład.</span><span class="sxs-lookup"><span data-stu-id="a54c6-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="a54c6-226">Utwórz <xref:Microsoft.CodeAnalysis.Compilation> test i <xref:Microsoft.CodeAnalysis.SemanticModel> uzyskaj z niego.</span><span class="sxs-lookup"><span data-stu-id="a54c6-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="a54c6-227">Użyj <xref:Microsoft.CodeAnalysis.SemanticModel> tego, `TypeInferenceRewriter`aby spróbować swojego pliku .</span><span class="sxs-lookup"><span data-stu-id="a54c6-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="a54c6-228">Zrobisz ten krok jako ostatni.</span><span class="sxs-lookup"><span data-stu-id="a54c6-228">You'll do this step last.</span></span> <span data-ttu-id="a54c6-229">W międzyczasie zadeklarować zmienną zastępczą reprezentującą kompilację testu:</span><span class="sxs-lookup"><span data-stu-id="a54c6-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="a54c6-230">Po wstrzymaniu chwili powinien zostać wyświetlony błąd squiggle pojawiają się raportowanie, że żadna metoda nie `CreateTestCompilation` istnieje.</span><span class="sxs-lookup"><span data-stu-id="a54c6-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="a54c6-231">Naciśnij **klawisze Ctrl+Period,** aby otworzyć żarówkę, a następnie naciśnij klawisz Enter, aby wywołać polecenie **Wygeneruj ciąg wycinkowy metody.**</span><span class="sxs-lookup"><span data-stu-id="a54c6-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="a54c6-232">To polecenie wygeneruje wycinek metody dla `CreateTestCompilation` metody w `Program` klasie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="a54c6-233">Wrócisz, aby wypełnić tę metodę później:</span><span class="sxs-lookup"><span data-stu-id="a54c6-233">You'll come back to fill in this method later:</span></span>

![C# Generowanie metody z użycia](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="a54c6-235">Zapisz następujący kod do iterate nad każdym <xref:Microsoft.CodeAnalysis.SyntaxTree> w teście <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="a54c6-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="a54c6-236">Dla każdego z nich, `TypeInferenceRewriter` zainicjować <xref:Microsoft.CodeAnalysis.SemanticModel> nowy z dla tego drzewa:</span><span class="sxs-lookup"><span data-stu-id="a54c6-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="a54c6-237">Wewnątrz `foreach` utworzonej instrukcji dodaj następujący kod, aby wykonać transformację na każdym drzewie źródłowym.</span><span class="sxs-lookup"><span data-stu-id="a54c6-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="a54c6-238">Ten kod warunkowo zapisuje nowe przekształcone drzewo, jeśli zostały wprowadzone jakiekolwiek zmiany.</span><span class="sxs-lookup"><span data-stu-id="a54c6-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="a54c6-239">Przepisowanie należy modyfikować drzewa tylko wtedy, gdy napotka jedną lub więcej deklaracji zmiennych lokalnych, które mogą być uproszczone przy użyciu wnioskowania o typie:</span><span class="sxs-lookup"><span data-stu-id="a54c6-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="a54c6-240">Pod kodem `File.WriteAllText` powinny być widoczne squiggles.</span><span class="sxs-lookup"><span data-stu-id="a54c6-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="a54c6-241">Wybierz żarówkę i dodaj `using System.IO;` niezbędną instrukcję.</span><span class="sxs-lookup"><span data-stu-id="a54c6-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="a54c6-242">Jesteś prawie gotowy!</span><span class="sxs-lookup"><span data-stu-id="a54c6-242">You're almost done!</span></span> <span data-ttu-id="a54c6-243">Po raz kolejny pozostało jeszcze <xref:Microsoft.CodeAnalysis.Compilation>krok: utworzenie testu .</span><span class="sxs-lookup"><span data-stu-id="a54c6-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="a54c6-244">Ponieważ nie używasz wnioskowania o typie w ogóle podczas tego szybkiego startu, byłoby to doskonały przypadek testowy.</span><span class="sxs-lookup"><span data-stu-id="a54c6-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="a54c6-245">Niestety tworzenie kompilacji z pliku projektu C# wykracza poza zakres tego instruktażeu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="a54c6-246">Ale na szczęście, jeśli uważnie przestrzegałeś instrukcji, jest nadzieja.</span><span class="sxs-lookup"><span data-stu-id="a54c6-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="a54c6-247">Zastąp zawartość metody `CreateTestCompilation` następującym kodem.</span><span class="sxs-lookup"><span data-stu-id="a54c6-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="a54c6-248">Tworzy kompilację testową, która przypadkowo pasuje do projektu opisanego w tym przewodniku Szybki start:</span><span class="sxs-lookup"><span data-stu-id="a54c6-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="a54c6-249">Trzymajcie kciuki i uruchamiajcie projekt.</span><span class="sxs-lookup"><span data-stu-id="a54c6-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="a54c6-250">W programie Visual Studio wybierz pozycję **Debuguj** > **debugowanie rozpocznij debugowanie**.</span><span class="sxs-lookup"><span data-stu-id="a54c6-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="a54c6-251">Program Visual Studio powinien monitować o zmianę plików w projekcie.</span><span class="sxs-lookup"><span data-stu-id="a54c6-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="a54c6-252">Kliknij przycisk "**Tak dla wszystkich**", aby ponownie załadować zmodyfikowane pliki.</span><span class="sxs-lookup"><span data-stu-id="a54c6-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="a54c6-253">Zbadaj je, aby obserwować swoją awesomeness.</span><span class="sxs-lookup"><span data-stu-id="a54c6-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="a54c6-254">Należy zauważyć, ile czystsze kod wygląda bez wszystkich tych jawne i nadmiarowe specyfikatory typu.</span><span class="sxs-lookup"><span data-stu-id="a54c6-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="a54c6-255">Gratulacje!</span><span class="sxs-lookup"><span data-stu-id="a54c6-255">Congratulations!</span></span> <span data-ttu-id="a54c6-256">Interfejsy **API kompilatora** zostały użyte do napisania własnego refaktoryzacji, który przeszukuje wszystkie pliki w projekcie C# dla niektórych wzorców składni, analizuje semantykę kodu źródłowego, który pasuje do tych wzorców i przekształca go.</span><span class="sxs-lookup"><span data-stu-id="a54c6-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="a54c6-257">Jesteś teraz oficjalnie refaktoryzacji autora!</span><span class="sxs-lookup"><span data-stu-id="a54c6-257">You're now officially refactoring author!</span></span>
