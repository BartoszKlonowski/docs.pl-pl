---
title: Korzystanie z modelu składni platformy SDK platformy kompilatora .NET
description: Ten przegląd zawiera zrozumienie typów używanych do rozumienia i manipulowania węzłami składni.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fc1b1f5ae5ec985425c8d6aec49ef7f830ea9162
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "75740477"
---
# <a name="work-with-syntax"></a><span data-ttu-id="95a6e-103">Korzystanie ze składni</span><span class="sxs-lookup"><span data-stu-id="95a6e-103">Work with syntax</span></span>

<span data-ttu-id="95a6e-104">**Drzewo składni** jest podstawową strukturą danych uwidacznioną przez interfejsy API kompilatora.</span><span class="sxs-lookup"><span data-stu-id="95a6e-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="95a6e-105">Drzewa te reprezentują leksykalne i syntaktyczne struktury kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="95a6e-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="95a6e-106">Służą one dwóm ważnym celom:</span><span class="sxs-lookup"><span data-stu-id="95a6e-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="95a6e-107">Aby umożliwić narzędzia — takie jak IDE, dodatki, narzędzia do analizy kodu i refaktoryzacji — aby wyświetlić i przetworzyć strukturę składni kodu źródłowego w projekcie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="95a6e-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="95a6e-108">Aby włączyć narzędzia — takie jak refaktoryzacji i IDE - do tworzenia, modyfikowania i zmiany rozmieszczenia kodu źródłowego w sposób naturalny bez konieczności używania bezpośrednich zmian tekstu.</span><span class="sxs-lookup"><span data-stu-id="95a6e-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="95a6e-109">Tworząc i manipulując drzewami, narzędzia można łatwo tworzyć i zmieniać rozmieszczenie kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="95a6e-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="95a6e-110">Drzewa składni</span><span class="sxs-lookup"><span data-stu-id="95a6e-110">Syntax trees</span></span>

<span data-ttu-id="95a6e-111">Drzewa składni są podstawową strukturą używaną do kompilacji, analizy kodu, wiązania, refaktoryzacji, funkcji IDE i generowania kodu.</span><span class="sxs-lookup"><span data-stu-id="95a6e-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="95a6e-112">Żadna część kodu źródłowego nie jest rozumiana bez jego uprzedniego zidentyfikowania i sklasyfikowania w jednym z wielu znanych elementów języka strukturalnego.</span><span class="sxs-lookup"><span data-stu-id="95a6e-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="95a6e-113">Drzewa składni mają trzy kluczowe atrybuty.</span><span class="sxs-lookup"><span data-stu-id="95a6e-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="95a6e-114">Pierwszym atrybutem jest to, że drzewa składni posiadają wszystkie informacje źródłowe w pełnej wierności.</span><span class="sxs-lookup"><span data-stu-id="95a6e-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="95a6e-115">Oznacza to, że drzewo składni zawiera wszystkie informacje znalezione w tekście źródłowym, każdą konstrukcję gramatyczną, każdy token leksykalne i wszystko inne pomiędzy, w tym biały znak, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="95a6e-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="95a6e-116">Na przykład każdy dosłowny wymieniony w źródle jest reprezentowany dokładnie tak, jak został wpisany.</span><span class="sxs-lookup"><span data-stu-id="95a6e-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="95a6e-117">Drzewa składni reprezentują również błędy w kodzie źródłowym, gdy program jest niekompletny lub nieprawidłowo sformułowany przez reprezentowanie pominiętych lub brakujących tokenów w drzewie składni.</span><span class="sxs-lookup"><span data-stu-id="95a6e-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>

<span data-ttu-id="95a6e-118">Umożliwia to drugi atrybut drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="95a6e-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="95a6e-119">Drzewo składni uzyskane z analizatora może spowodować, że tekst został przeanalizowany.</span><span class="sxs-lookup"><span data-stu-id="95a6e-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="95a6e-120">Z dowolnego węzła składni można uzyskać reprezentację tekstu poddrzewa zakorzenionew tym węźle.</span><span class="sxs-lookup"><span data-stu-id="95a6e-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="95a6e-121">Oznacza to, że drzewa składni mogą służyć jako sposób konstruowania i edytowania tekstu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="95a6e-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="95a6e-122">Tworząc drzewo, które zostały utworzone przez domniemanie równoważny tekst i edytując drzewo składni, tworząc nowe drzewo ze zmian w istniejącym drzewie, skutecznie edytowałeś tekst.</span><span class="sxs-lookup"><span data-stu-id="95a6e-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="95a6e-123">Trzeci atrybut drzewa składni jest, że są one niezmienne i wątku bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="95a6e-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="95a6e-124">Oznacza to, że po drzewo jest uzyskiwany, jest migawką bieżącego stanu kodu i nigdy się nie zmienia.</span><span class="sxs-lookup"><span data-stu-id="95a6e-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="95a6e-125">Dzięki temu wielu użytkowników do interakcji z tym samym drzewem składni w tym samym czasie w różnych wątków bez blokowania lub powielania.</span><span class="sxs-lookup"><span data-stu-id="95a6e-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="95a6e-126">Ponieważ drzewa są niezmienne i nie można wprowadzać żadnych modyfikacji bezpośrednio do drzewa, metody fabryki pomagają tworzyć i modyfikować drzewa składni, tworząc dodatkowe migawki drzewa.</span><span class="sxs-lookup"><span data-stu-id="95a6e-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="95a6e-127">Drzewa są wydajne w sposobie ponownego wykorzystania podstawowych węzłów, dzięki czemu nowa wersja może być szybko przebudowana i z niewielką ilością dodatkowej pamięci.</span><span class="sxs-lookup"><span data-stu-id="95a6e-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="95a6e-128">Drzewo składni jest dosłownie strukturą danych drzewa, w której niekońcowe elementy konstrukcyjne są nadrzędne dla innych elementów.</span><span class="sxs-lookup"><span data-stu-id="95a6e-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="95a6e-129">Każde drzewo składni składa się z węzłów, tokenów i ciekawostek.</span><span class="sxs-lookup"><span data-stu-id="95a6e-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="95a6e-130">Węzły składni</span><span class="sxs-lookup"><span data-stu-id="95a6e-130">Syntax nodes</span></span>

<span data-ttu-id="95a6e-131">Węzły składni są jednym z podstawowych elementów drzew składni.</span><span class="sxs-lookup"><span data-stu-id="95a6e-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="95a6e-132">Te węzły reprezentują konstrukcje składni, takie jak deklaracje, instrukcje, klauzule i wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="95a6e-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="95a6e-133">Każda kategoria węzłów składni jest reprezentowana przez oddzielną klasę wyprowadzoną z <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a6e-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95a6e-134">Zestaw klas węzłów nie jest rozszerzalny.</span><span class="sxs-lookup"><span data-stu-id="95a6e-134">The set of node classes is not extensible.</span></span>

<span data-ttu-id="95a6e-135">Wszystkie węzły składni są węzłami niekońcowymw drzewie składni, co oznacza, że zawsze mają inne węzły i tokeny jako podrzędne.</span><span class="sxs-lookup"><span data-stu-id="95a6e-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="95a6e-136">Jako element podrzędny innego węzła każdy węzeł ma węzeł nadrzędny, do których można uzyskać dostęp za pośrednictwem <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="95a6e-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="95a6e-137">Ponieważ węzły i drzewa są niezmienne, element nadrzędny węzła nigdy się nie zmienia.</span><span class="sxs-lookup"><span data-stu-id="95a6e-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="95a6e-138">Katalog główny drzewa ma null nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="95a6e-138">The root of the tree has a null parent.</span></span>

<span data-ttu-id="95a6e-139">Każdy węzeł ma <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> metodę, która zwraca listę węzłów podrzędnych w kolejności na podstawie ich pozycji w tekście źródłowym.</span><span class="sxs-lookup"><span data-stu-id="95a6e-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="95a6e-140">Ta lista nie zawiera tokenów.</span><span class="sxs-lookup"><span data-stu-id="95a6e-140">This list does not contain tokens.</span></span> <span data-ttu-id="95a6e-141">Każdy węzeł ma również metody do zbadania <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>Descendants, takich jak , , lub <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - które reprezentują listę wszystkich węzłów, tokenów lub ciekawostki, które istnieją w poddrzewie zakorzenione w tym węźle.</span><span class="sxs-lookup"><span data-stu-id="95a6e-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the sub-tree rooted by that node.</span></span>

<span data-ttu-id="95a6e-142">Ponadto każda podklasa węzła składni udostępnia wszystkie te same właściwości podrzędne za pośrednictwem właściwości silnie typowane.</span><span class="sxs-lookup"><span data-stu-id="95a6e-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="95a6e-143">Na przykład <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> klasa węzła ma trzy dodatkowe właściwości <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>specyficzne <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>dla <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>operatorów binarnych: , , i .</span><span class="sxs-lookup"><span data-stu-id="95a6e-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="95a6e-144">Typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jest <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> typ <xref:Microsoft.CodeAnalysis.SyntaxToken>jest .</span><span class="sxs-lookup"><span data-stu-id="95a6e-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="95a6e-145">Niektóre węzły składni mają opcjonalne elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="95a6e-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="95a6e-146">Na przykład <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> ma opcjonalny <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="95a6e-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="95a6e-147">Jeśli dziecko nie jest obecny, właściwość zwraca null.</span><span class="sxs-lookup"><span data-stu-id="95a6e-147">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="95a6e-148">Tokeny składni</span><span class="sxs-lookup"><span data-stu-id="95a6e-148">Syntax tokens</span></span>

<span data-ttu-id="95a6e-149">Tokeny składni są terminalami gramatyki językowej, reprezentującymi najmniejsze fragmenty składni kodu.</span><span class="sxs-lookup"><span data-stu-id="95a6e-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="95a6e-150">Nigdy nie są rodzicami innych węzłów lub tokenów.</span><span class="sxs-lookup"><span data-stu-id="95a6e-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="95a6e-151">Tokeny składni składają się ze słów kluczowych, identyfikatorów, literałów i znaków interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="95a6e-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="95a6e-152">Dla celów wydajności <xref:Microsoft.CodeAnalysis.SyntaxToken> typ jest typem wartości CLR.</span><span class="sxs-lookup"><span data-stu-id="95a6e-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="95a6e-153">W związku z tym w przeciwieństwie do węzłów składni, istnieje tylko jedna struktura dla wszystkich rodzajów tokenów z kombinacją właściwości, które mają znaczenie w zależności od rodzaju tokenu, który jest reprezentowany.</span><span class="sxs-lookup"><span data-stu-id="95a6e-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="95a6e-154">Na przykład token literału całkowitego reprezentuje wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="95a6e-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="95a6e-155">Oprócz nieprzetworzonego tekstu źródłowego, który obejmuje token, <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> token literału ma właściwość, która informuje o dokładnej wartości zdekodowanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="95a6e-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="95a6e-156">Ta właściwość jest <xref:System.Object> wpisana jako, ponieważ może być jednym z wielu typów pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="95a6e-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="95a6e-157">Właściwość <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> informuje o tych samych informacjach, <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> co właściwość; jednak ta właściwość jest <xref:System.String>zawsze wpisana jako .</span><span class="sxs-lookup"><span data-stu-id="95a6e-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="95a6e-158">Identyfikator w tekście źródłowym Języka C# może zawierać znaki ucieczki Unicode, ale składnia samej sekwencji ucieczki nie jest uważana za część nazwy identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="95a6e-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="95a6e-159">Tak więc, mimo że nieprzetworzony tekst łączony przez <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> token zawiera sekwencję ucieczki, właściwość nie.</span><span class="sxs-lookup"><span data-stu-id="95a6e-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="95a6e-160">Zamiast tego zawiera znaki Unicode identyfikowane przez escape.</span><span class="sxs-lookup"><span data-stu-id="95a6e-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="95a6e-161">Na przykład jeśli tekst źródłowy zawiera `\u03C0`identyfikator <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> napisany jako , `π`a następnie właściwość dla tego tokenu zwróci .</span><span class="sxs-lookup"><span data-stu-id="95a6e-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="95a6e-162">Ciekawostki składni</span><span class="sxs-lookup"><span data-stu-id="95a6e-162">Syntax trivia</span></span>

<span data-ttu-id="95a6e-163">Ciekawostki składni reprezentują części tekstu źródłowego, które są w dużej mierze nieistotne dla normalnego zrozumienia kodu, takie jak białe pole, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="95a6e-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="95a6e-164">Podobnie jak tokeny składni, ciekawostki są typami wartości.</span><span class="sxs-lookup"><span data-stu-id="95a6e-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="95a6e-165">Pojedynczy <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> typ jest używany do opisania wszelkiego rodzaju ciekawostek.</span><span class="sxs-lookup"><span data-stu-id="95a6e-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="95a6e-166">Ponieważ ciekawostki nie są częścią składni języka normalnego i mogą być wyświetlane w dowolnym miejscu między dowolnymi dwoma tokenami, nie są one uwzględniane w drzewie składni jako element podrzędny węzła.</span><span class="sxs-lookup"><span data-stu-id="95a6e-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="95a6e-167">Jednak ponieważ są one ważne podczas implementowania funkcji, takich jak refaktoryzacji i zachować pełną wierność z tekstem źródłowym, istnieją one jako część drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="95a6e-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="95a6e-168">Możesz uzyskać dostęp do ciekawostek, sprawdzając token <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> lub <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> kolekcje.</span><span class="sxs-lookup"><span data-stu-id="95a6e-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="95a6e-169">Gdy tekst źródłowy jest analizowany, sekwencje ciekawostki są skojarzone z tokenami.</span><span class="sxs-lookup"><span data-stu-id="95a6e-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="95a6e-170">Ogólnie rzecz biorąc token jest właścicielem wszelkich ciekawostek po nim w tym samym wierszu do następnego tokenu.</span><span class="sxs-lookup"><span data-stu-id="95a6e-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="95a6e-171">Wszelkie ciekawostki po tym wierszu jest skojarzony z następującym tokenem.</span><span class="sxs-lookup"><span data-stu-id="95a6e-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="95a6e-172">Pierwszy token w pliku źródłowym pobiera wszystkie początkowe ciekawostki, a ostatnia sekwencja ciekawostek w pliku jest przyklejona do tokenu końca pliku, który w przeciwnym razie ma zerową szerokość.</span><span class="sxs-lookup"><span data-stu-id="95a6e-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="95a6e-173">W przeciwieństwie do węzłów składni i tokenów, ciekawostki składni nie mają właściwości rodziców.</span><span class="sxs-lookup"><span data-stu-id="95a6e-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="95a6e-174">Jednak ponieważ są one częścią drzewa i każdy jest skojarzony z pojedynczym tokenem, można uzyskać dostęp do tokenu, który jest skojarzony z przy użyciu <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="95a6e-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="95a6e-175">Obejmuje</span><span class="sxs-lookup"><span data-stu-id="95a6e-175">Spans</span></span>

<span data-ttu-id="95a6e-176">Każdy węzeł, token lub ciekawostki zna jego pozycję w tekście źródłowym i liczbę znaków, na których się składa.</span><span class="sxs-lookup"><span data-stu-id="95a6e-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="95a6e-177">Pozycja tekstowa jest reprezentowana jako 32-bitowa liczba całkowita, która jest indeksem zerowym. `char`</span><span class="sxs-lookup"><span data-stu-id="95a6e-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="95a6e-178">Obiekt <xref:Microsoft.CodeAnalysis.Text.TextSpan> jest pozycją początku i liczbą znaków, oba reprezentowane jako liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="95a6e-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="95a6e-179">Jeśli <xref:Microsoft.CodeAnalysis.Text.TextSpan> ma długość zerową, odnosi się do lokalizacji między dwoma znakami.</span><span class="sxs-lookup"><span data-stu-id="95a6e-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="95a6e-180">Każdy węzeł ma <xref:Microsoft.CodeAnalysis.Text.TextSpan> dwie <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> właściwości: i <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a6e-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="95a6e-181">Właściwość <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> jest zakres tekstu od początku pierwszego tokenu w poddrzewie węzła do końca ostatniego tokenu.</span><span class="sxs-lookup"><span data-stu-id="95a6e-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="95a6e-182">Zakres ten nie zawiera żadnych wiodących lub końcowych ciekawostki.</span><span class="sxs-lookup"><span data-stu-id="95a6e-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="95a6e-183">Właściwość <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> jest zakres tekstu, który zawiera normalny zakres węzła, plus zakres wszelkich wiodących lub końcowych ciekawostki.</span><span class="sxs-lookup"><span data-stu-id="95a6e-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="95a6e-184">Przykład:</span><span class="sxs-lookup"><span data-stu-id="95a6e-184">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="95a6e-185">Węzeł instrukcji wewnątrz bloku ma zakres wskazany przez pojedyncze pionowe pręty (|).</span><span class="sxs-lookup"><span data-stu-id="95a6e-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="95a6e-186">Zawiera znaki `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="95a6e-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="95a6e-187">Pełny zakres jest oznaczony podwójnymi pionowymi prętami (||).</span><span class="sxs-lookup"><span data-stu-id="95a6e-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="95a6e-188">Zawiera te same znaki, co zakres i znaki związane z wiodącymi i kończącymi się ciekawostkami.</span><span class="sxs-lookup"><span data-stu-id="95a6e-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="95a6e-189">Rodzaje</span><span class="sxs-lookup"><span data-stu-id="95a6e-189">Kinds</span></span>

<span data-ttu-id="95a6e-190">Każdy węzeł, token lub ciekawostki <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> ma <xref:System.Int32?displayProperty=nameWithType>właściwość typu , która identyfikuje dokładny element składni reprezentowany.</span><span class="sxs-lookup"><span data-stu-id="95a6e-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="95a6e-191">Tę wartość można rzutować na wyliczenie specyficzne dla języka.</span><span class="sxs-lookup"><span data-stu-id="95a6e-191">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="95a6e-192">Każdy język, C# lub Visual `SyntaxKind` Basic, ma<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>pojedyncze wyliczenie ( i , odpowiednio), który zawiera listę wszystkich możliwych węzłów, tokenów i elementów ciekawostki w gramatyki.</span><span class="sxs-lookup"><span data-stu-id="95a6e-192">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="95a6e-193">Ta konwersja może być wykonana <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> automatycznie, uzyskując dostęp do metod lub <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="95a6e-193">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="95a6e-194">Właściwość <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> umożliwia łatwe rozróżnianie typów węzłów składni, które mają tę samą klasę węzła.</span><span class="sxs-lookup"><span data-stu-id="95a6e-194">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="95a6e-195">Dla tokenów i ciekawostki ta właściwość jest jedynym sposobem, aby odróżnić jeden typ elementu od innego.</span><span class="sxs-lookup"><span data-stu-id="95a6e-195">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="95a6e-196">Na przykład jedna <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> klasa <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>ma <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> , i jako dzieci.</span><span class="sxs-lookup"><span data-stu-id="95a6e-196">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="95a6e-197">Właściwość <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>rozróżnia, czy <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>jest <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> to , , lub rodzaj węzła składni.</span><span class="sxs-lookup"><span data-stu-id="95a6e-197">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="95a6e-198">Errors</span><span class="sxs-lookup"><span data-stu-id="95a6e-198">Errors</span></span>

<span data-ttu-id="95a6e-199">Nawet jeśli tekst źródłowy zawiera błędy składni, pełne drzewo składni, które można w obie strony do źródła jest narażony.</span><span class="sxs-lookup"><span data-stu-id="95a6e-199">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="95a6e-200">Gdy analizator napotka kod, który nie jest zgodny ze zdefiniowaną składnią języka, używa jednej z dwóch technik do utworzenia drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="95a6e-200">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="95a6e-201">Po pierwsze, jeśli analizator oczekuje określonego rodzaju tokenu, ale go nie znajdzie, może wstawić brakujący token do drzewa składni w lokalizacji, której oczekiwano tokenu.</span><span class="sxs-lookup"><span data-stu-id="95a6e-201">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="95a6e-202">Brakujący token reprezentuje rzeczywisty token, który był oczekiwany, ale ma <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> pusty `true`zakres, a jego właściwość zwraca .</span><span class="sxs-lookup"><span data-stu-id="95a6e-202">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="95a6e-203">Po drugie analizator może pominąć tokeny, dopóki nie znajdzie jeden, gdzie można kontynuować analizowanie.</span><span class="sxs-lookup"><span data-stu-id="95a6e-203">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="95a6e-204">W takim przypadku pominięte tokeny są dołączone jako węzeł ciekawostki z rodzaju <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="95a6e-204">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
