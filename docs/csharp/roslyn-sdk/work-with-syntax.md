---
title: Użyj zestawu SDK platformy kompilatora .NET modelu składni
description: Ten przegląd zawiera opis typów, używaną do zrozumienia i manipulowania składni węzłów.
author: billwagner
ms.author: wiwagn
ms.date: 10/15/2017
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 09d07e6257ad7d32d75328a8c1850888b4d0b937
ms.sourcegitcommit: c883637b41ee028786edceece4fa872939d2e64c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/26/2018
---
# <a name="work-with-syntax"></a><span data-ttu-id="c3618-103">Praca z składni</span><span class="sxs-lookup"><span data-stu-id="c3618-103">Work with syntax</span></span>

<span data-ttu-id="c3618-104">**Drzewa składni** to struktura danych podstawowych udostępnianych przez kompilator interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="c3618-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="c3618-105">Drzewa te reprezentuje strukturę leksykalne i składni kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="c3618-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="c3618-106">Służą one ważne do dwóch celów:</span><span class="sxs-lookup"><span data-stu-id="c3618-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="c3618-107">Umożliwia narzędzia — takie jak IDE dodatków, kodu narzędzi analizy i refaktoryzacje — Zobacz i przetwarzać składni struktury kodu źródłowego w projekcie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="c3618-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="c3618-108">Aby włączyć narzędzia — takie jak refaktoryzacje i IDE — do tworzenia, modyfikowania i rozmieszczanie kodu źródłowego w sposób fizycznych bez konieczności edytowanych wartości tekstowych bezpośredniego użycia.</span><span class="sxs-lookup"><span data-stu-id="c3618-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="c3618-109">Tworzenie i manipulowanie drzewa, narzędzia łatwo tworzyć i rozmieszczanie kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="c3618-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="c3618-110">Drzewa składni</span><span class="sxs-lookup"><span data-stu-id="c3618-110">Syntax trees</span></span>

<span data-ttu-id="c3618-111">Drzewa składni są podstawowej struktury używany dla kompilacji, analizy kodu, powiązanie, refaktoryzacji funkcje IDE i generowania kodu.</span><span class="sxs-lookup"><span data-stu-id="c3618-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="c3618-112">Żadna część kod źródłowy jest rozpoznawany bez najpierw są zidentyfikowane i przydzielone do jednego z wielu elementów dobrze znanego strukturalnych języka.</span><span class="sxs-lookup"><span data-stu-id="c3618-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span> 

<span data-ttu-id="c3618-113">Drzewa składni ma trzy atrybuty klucza.</span><span class="sxs-lookup"><span data-stu-id="c3618-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="c3618-114">Pierwszy atrybut jest, że drzewa składni przechowywać wszystkie informacje o źródle w pełnej rozdzielczości.</span><span class="sxs-lookup"><span data-stu-id="c3618-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="c3618-115">Oznacza to, że drzewa składni zawiera każdą informacji zamieszczonych w tekst źródłowy, co gramatyczne konstrukcja co leksykalne token i wszystkie inne w między, w tym spacji, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="c3618-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including whitespace, comments, and preprocessor directives.</span></span> <span data-ttu-id="c3618-116">Na przykład każdy literał wymienionych w źródle jest reprezentowany dokładnie tak, jak została zapisana.</span><span class="sxs-lookup"><span data-stu-id="c3618-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="c3618-117">Gdy program jest niekompletna lub nieprawidłowo sformułowany przez reprezentujący pominięto lub brak tokenów w drzewie składni drzewa składni także reprezentować błędów w kodzie źródłowym.</span><span class="sxs-lookup"><span data-stu-id="c3618-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>  

<span data-ttu-id="c3618-118">Dzięki temu drugi atrybut drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="c3618-119">Drzewo składni uzyskane z analizatora może wygenerować dokładne tekst, który został zanalizowany z.</span><span class="sxs-lookup"><span data-stu-id="c3618-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="c3618-120">Z poziomu każdego węzła składni jest możliwość uzyskania Reprezentacja tekstowa typu poddrzewa początek w tym węźle.</span><span class="sxs-lookup"><span data-stu-id="c3618-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="c3618-121">Oznacza to, że drzewa składni mogą być używane jako sposobu konstruowania i edytować tekst źródłowy.</span><span class="sxs-lookup"><span data-stu-id="c3618-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="c3618-122">Tworząc drzewa posiadanego co za tym idzie utworzone równoważne tekstu i edytując drzewo składni, co nowego drzew zmiany poza do istniejącego drzewa, należy skutecznie edytować tekst.</span><span class="sxs-lookup"><span data-stu-id="c3618-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span> 

<span data-ttu-id="c3618-123">Trzeci atrybutu drzewa składni te są niezmienne i bezpieczne wątkowo.</span><span class="sxs-lookup"><span data-stu-id="c3618-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="c3618-124">Oznacza to, że po uzyskaniu drzewa jest migawką bieżącego stanu kodu i nie ulega zmianie.</span><span class="sxs-lookup"><span data-stu-id="c3618-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="c3618-125">Dzięki temu wielu użytkownikom na interakcję z tym samym drzewie składni w tym samym czasie w różnych wątkach bez blokowania lub dublowania.</span><span class="sxs-lookup"><span data-stu-id="c3618-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="c3618-126">Ponieważ drzewa są niezmienne i żadne zmiany nie jest możliwe bezpośrednio do drzewa, metodami factory pomóc tworzyć i modyfikować drzewa składni przez tworzenie migawek dodatkowe drzewa.</span><span class="sxs-lookup"><span data-stu-id="c3618-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="c3618-127">Drzewa są wydajne w sposób ich ponowne użycie węzłów podrzędnych, nowa wersja może zostać również przebudowany szybko i z niewielkim dodatkową pamięć.</span><span class="sxs-lookup"><span data-stu-id="c3618-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="c3618-128">Drzewo składni jest dosłownie drzewa strukturą danych, gdy inny niż końcowy elementy nadrzędne inne elementy.</span><span class="sxs-lookup"><span data-stu-id="c3618-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="c3618-129">Każdy drzewa składni składa się z węzłów, tokeny i elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>  

## <a name="syntax-nodes"></a><span data-ttu-id="c3618-130">Składnia węzłów</span><span class="sxs-lookup"><span data-stu-id="c3618-130">Syntax nodes</span></span>

<span data-ttu-id="c3618-131">Składnia węzły są jednym z podstawowe elementy drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="c3618-132">Te węzły reprezentują konstrukcje składni takich jak deklaracje, instrukcje klauzule i wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="c3618-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="c3618-133">Każda kategoria węzłów składni jest reprezentowana przez oddzielne klasy pochodzącej od <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c3618-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3618-134">Zestaw klas węzeł nie jest rozszerzony.</span><span class="sxs-lookup"><span data-stu-id="c3618-134">The set of node classes is not extensible.</span></span> 

<span data-ttu-id="c3618-135">Wszystkie węzły składni jest inny niż końcowy węzłów w drzewie składni, co oznacza, że mają one zawsze innych węzłów i tokenów jako elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="c3618-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="c3618-136">Jako element podrzędny innego węzła, każdy węzeł ma węzła nadrzędnego, który jest możliwy za pośrednictwem <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="c3618-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c3618-137">Ponieważ węzły i drzew są niezmienne, nadrzędnego węzła nigdy nie zmienia się.</span><span class="sxs-lookup"><span data-stu-id="c3618-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="c3618-138">Korzeń drzewa ma element nadrzędny wartości null.</span><span class="sxs-lookup"><span data-stu-id="c3618-138">The root of the tree has a null parent.</span></span>  

<span data-ttu-id="c3618-139">Każdy węzeł ma <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> metodę, która zwraca listę węzłów podrzędnych w kolejności sekwencyjnej, na podstawie ich położenia w tekście źródła.</span><span class="sxs-lookup"><span data-stu-id="c3618-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="c3618-140">Ta lista nie zawiera tokenów.</span><span class="sxs-lookup"><span data-stu-id="c3618-140">This list does not contain tokens.</span></span> <span data-ttu-id="c3618-141">Każdy węzeł ma również metody do sprawdzenia elementów podrzędnych, takich jak <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, lub <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> -reprezentujące listę wszystkich węzłów, tokeny lub elementy towarzyszące składni, który istnieje w poddrzewie odblokowany dostęp do tego węzła.</span><span class="sxs-lookup"><span data-stu-id="c3618-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia, that exist in the sub-tree rooted by that node.</span></span>  

<span data-ttu-id="c3618-142">Ponadto te same elementy podrzędne za pośrednictwem właściwości jednoznacznie przedstawia każdego podklasy węzeł składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="c3618-143">Na przykład <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> klasa węzła ma trzy dodatkowe właściwości specyficzne dla operatorów binarnych: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="c3618-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="c3618-144">Typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jest <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, a typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> jest <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="c3618-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="c3618-145">Niektóre węzły składni mają opcjonalne elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="c3618-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="c3618-146">Na przykład <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> ma opcjonalny <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="c3618-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="c3618-147">Jeśli nie ma elementu podrzędnego, właściwość zwraca wartość null.</span><span class="sxs-lookup"><span data-stu-id="c3618-147">If the child is not present, the property returns null.</span></span> 

## <a name="syntax-tokens"></a><span data-ttu-id="c3618-148">Tokeny składni</span><span class="sxs-lookup"><span data-stu-id="c3618-148">Syntax tokens</span></span>

<span data-ttu-id="c3618-149">Składnia tokeny są terminali gramatyki języka, reprezentująca najmniejszą składni fragmentów kodu.</span><span class="sxs-lookup"><span data-stu-id="c3618-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="c3618-150">Nigdy nie są one nadrzędnych innych węzłów lub tokenów.</span><span class="sxs-lookup"><span data-stu-id="c3618-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="c3618-151">Tokeny składni składają się z słów kluczowych, identyfikatory, literały i znaków interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="c3618-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span> 

<span data-ttu-id="c3618-152">Ze względów wydajności <xref:Microsoft.CodeAnalysis.SyntaxToken> typem jest typ wartości CLR.</span><span class="sxs-lookup"><span data-stu-id="c3618-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="c3618-153">W związku z tym w przeciwieństwie do węzłów składni istnieje tylko jeden struktury dla wszystkich rodzajów tokenów z różnymi właściwości, które mają znaczenie w zależności od rodzaju token, który jest reprezentowanego.</span><span class="sxs-lookup"><span data-stu-id="c3618-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="c3618-154">Na przykład token literału liczby całkowitej reprezentuje wartość numeryczną.</span><span class="sxs-lookup"><span data-stu-id="c3618-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="c3618-155">Oprócz tekst źródłowy raw obejmuje tokenu, token literału ma <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> właściwości, które pozwalają określić dokładnie zdekodować wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="c3618-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="c3618-156">Ta właściwość jest typu <xref:System.Object> ponieważ może to być jeden z wielu typów pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="c3618-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="c3618-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> Właściwości informuje te same informacje co <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> właściwości; jednak ta właściwość jest zawsze typu jako <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="c3618-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="c3618-158">Identyfikator w C# tekst źródłowy może zawierać znaki specjalne Unicode, ale składni sekwencji unikowej sam nie jest uznawany za część nazwy identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="c3618-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="c3618-159">Tak, chociaż nieprzetworzony tekst objęte token zawiera sekwencji unikowej <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> nie obsługuje właściwości.</span><span class="sxs-lookup"><span data-stu-id="c3618-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="c3618-160">Zamiast tego zawiera znaków Unicode, identyfikowane przez ucieczki.</span><span class="sxs-lookup"><span data-stu-id="c3618-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="c3618-161">Na przykład, jeśli tekst źródłowy zawiera identyfikator zapisywane jako `\u03C0`, a następnie <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> zwróci właściwości dla tego tokena `π`.</span><span class="sxs-lookup"><span data-stu-id="c3618-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="c3618-162">Elementy towarzyszące składni składni</span><span class="sxs-lookup"><span data-stu-id="c3618-162">Syntax trivia</span></span>

<span data-ttu-id="c3618-163">Elementy towarzyszące składni składni reprezentują części tekstu źródłowego, które przede wszystkim nieważny do normalnej wiedzę na temat kodu, na przykład spacji, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="c3618-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as whitespace, comments, and preprocessor directives.</span></span> <span data-ttu-id="c3618-164">Podobnie jak tokeny składni elementy towarzyszące składni są typów wartości.</span><span class="sxs-lookup"><span data-stu-id="c3618-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="c3618-165">Pojedynczy <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> typ jest używany do opisania wszystkich rodzajów elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="c3618-166">Ponieważ elementy towarzyszące składni nie są częścią składni języka normalne i może występować w dowolnym miejscu między dwoma tokenów, ich nie znajdują się w drzewie składni jako element podrzędny węzła.</span><span class="sxs-lookup"><span data-stu-id="c3618-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="c3618-167">Jeszcze ponieważ są one ważne podczas wykonywania funkcji, takich jak refaktoryzacji i obsługa pełnej rozdzielczości na tekst źródłowy, są dostępne jako część drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="c3618-168">Elementy towarzyszące składni można uzyskać dostęp, sprawdzając token <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> lub <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c3618-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="c3618-169">Gdy zostanie przeanalizowany tekst źródłowy, sekwencje elementy towarzyszące składni są skojarzone z tokenów.</span><span class="sxs-lookup"><span data-stu-id="c3618-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="c3618-170">Ogólnie rzecz biorąc token jest właścicielem wszystkie elementy towarzyszące składni po nim w tym samym wierszu do następnego tokenu.</span><span class="sxs-lookup"><span data-stu-id="c3618-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="c3618-171">Wszystkie elementy towarzyszące składni po tym wierszu jest skojarzony z następującego tokenu.</span><span class="sxs-lookup"><span data-stu-id="c3618-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="c3618-172">Pierwszym tokenie w pliku źródłowym pobiera wszystkie początkowej elementy towarzyszące składni i przyczepiana jest ostatnią sekwencję elementy towarzyszące składni w pliku na token końca pliku, które w przeciwnym razie ma zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="c3618-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="c3618-173">W przeciwieństwie do węzłów składni i tokeny składni elementy towarzyszące składni nie mają elementów nadrzędnych.</span><span class="sxs-lookup"><span data-stu-id="c3618-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="c3618-174">Jeszcze, ponieważ są one częścią drzewa, a każdy jest skojarzony z jednym token, użytkownik może uzyskać dostępu do tokenu nie jest skojarzona z przy użyciu <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="c3618-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="c3618-175">Zakresy</span><span class="sxs-lookup"><span data-stu-id="c3618-175">Spans</span></span>

<span data-ttu-id="c3618-176">Wszystkie węzły, token i elementy towarzyszące składni wie jej położenie w obrębie tekst źródłowy i liczbę znaków, który składa się z.</span><span class="sxs-lookup"><span data-stu-id="c3618-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="c3618-177">Położenie tekstu jest reprezentowany jako liczba całkowita 32-bitowy, który jest liczony od zera `char` indeksu.</span><span class="sxs-lookup"><span data-stu-id="c3618-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="c3618-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> obiekt jest położenie początku i liczbę znaków, zarówno prezentowane w postaci liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="c3618-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="c3618-179">Jeśli <xref:Microsoft.CodeAnalysis.Text.TextSpan> ma zerową długość, odnosi się do lokalizacji między znakami.</span><span class="sxs-lookup"><span data-stu-id="c3618-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="c3618-180">Każdy węzeł ma dwa <xref:Microsoft.CodeAnalysis.Text.TextSpan> właściwości: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> i <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span><span class="sxs-lookup"><span data-stu-id="c3618-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span></span> 

<span data-ttu-id="c3618-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> Właściwość jest zakres tekstu od początku pierwszym tokenie w poddrzewie węzła na końcu ostatniego tokena.</span><span class="sxs-lookup"><span data-stu-id="c3618-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="c3618-182">Ten zakres nie obejmuje żadnych wiodących lub końcowych elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="c3618-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> Właściwość jest zakres tekstu, zawierający zakres normalnej węzła, a także zakres dowolnego wiodących lub końcowych elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="c3618-184">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="c3618-184">For example:</span></span> 

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="c3618-185">Węzeł instrukcji wewnątrz bloku ma należy do zakresu wskazanej przez pojedynczy pionowych słupków (|).</span><span class="sxs-lookup"><span data-stu-id="c3618-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="c3618-186">Zawiera on znaki `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="c3618-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="c3618-187">Pełny zakres jest określane przez dwa razy pionowych słupków (|).</span><span class="sxs-lookup"><span data-stu-id="c3618-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="c3618-188">Zawiera te same znaki jako zakres i skojarzone z elementy towarzyszące składni wiodące i końcowe znaki.</span><span class="sxs-lookup"><span data-stu-id="c3618-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="c3618-189">Typy</span><span class="sxs-lookup"><span data-stu-id="c3618-189">Kinds</span></span>

<span data-ttu-id="c3618-190">Każdy węzeł, token lub elementy towarzyszące składni ma <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> właściwość typu <xref:System.Int32?displayProperty=nameWithType>, który identyfikuje element dokładna składnia reprezentowany.</span><span class="sxs-lookup"><span data-stu-id="c3618-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="c3618-191">Ta wartość mogą być rzutowane na wyliczenie specyficzny dla języka; każdego języka C# i VB, ma jeden `SyntaxKind` — wyliczenie (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> i <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>odpowiednio) która wyświetla listę wszystkich możliwych węzłów, tokeny i elementy towarzyszące składni elementów, w gramatyce.</span><span class="sxs-lookup"><span data-stu-id="c3618-191">This value can be cast to a language-specific enumeration; each language, C# or VB, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="c3618-192">Ta konwersja może odbywać się automatycznie po zalogowaniu się do <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> lub <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="c3618-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="c3618-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> Właściwości umożliwia łatwe ujednoznacznienia składni węzeł typów, które korzystać z tej samej klasy węzła.</span><span class="sxs-lookup"><span data-stu-id="c3618-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="c3618-194">Tokeny i elementy towarzyszące składni ta właściwość jest jedynym sposobem, aby odróżnić jeden typ elementu z innej.</span><span class="sxs-lookup"><span data-stu-id="c3618-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span> 

<span data-ttu-id="c3618-195">Na przykład, jeden <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> klasa ma <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jako elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="c3618-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="c3618-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> Właściwości odróżnia czy jest <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, lub <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> rodzaj węzła składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="c3618-197">błędy</span><span class="sxs-lookup"><span data-stu-id="c3618-197">Errors</span></span>

<span data-ttu-id="c3618-198">Nawet wtedy, gdy tekst źródłowy zawiera błędy składni, drzewa pełnej składni, który jest round-wysyłanych i zwracanych jest ze źródłem jest widoczne.</span><span class="sxs-lookup"><span data-stu-id="c3618-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="c3618-199">Gdy analizator napotka kod, który jest niezgodny ze zdefiniowanym składni języka, użyto jednego z dwóch metod można utworzyć drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="c3618-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="c3618-200">Najpierw jeśli analizator oczekuje określonego rodzaju token, ale nie zostanie znaleziona, jego może wstawić Brak tokenu do drzewa składni w lokalizacji oczekiwany token.</span><span class="sxs-lookup"><span data-stu-id="c3618-200">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="c3618-201">Brak tokenu reprezentuje rzeczywisty tokenu, który był oczekiwany, ale ma pusty zakres, a jego <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> zwraca właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="c3618-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="c3618-202">Po drugie analizator pominąć tokeny aż do znalezienia punktu, gdzie można kontynuować, analizowanie.</span><span class="sxs-lookup"><span data-stu-id="c3618-202">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="c3618-203">W takim przypadku pominięto tokeny są dołączone jako węzeł elementy towarzyszące składni o rodzaju <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="c3618-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
