---
title: Użyj modelu składni .NET Compiler Platform SDK
description: To omówienie zawiera opis typów używanych do zrozumienia i manipulowania węzłami składni.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: 87b79c3af4958299fcd966dcc4b04868f88675c7
ms.sourcegitcommit: fff146ba3fd1762c8c432d95c8b877825ae536fc
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/08/2020
ms.locfileid: "82975917"
---
# <a name="work-with-syntax"></a><span data-ttu-id="ea488-103">Korzystanie ze składni</span><span class="sxs-lookup"><span data-stu-id="ea488-103">Work with syntax</span></span>

<span data-ttu-id="ea488-104">**Drzewo składni** jest podstawową strukturą danych uwidocznioną przez interfejsy API kompilatora.</span><span class="sxs-lookup"><span data-stu-id="ea488-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="ea488-105">Te drzewa reprezentują strukturę leksykalną i składnię kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="ea488-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="ea488-106">Służą one do dwóch istotnych celów:</span><span class="sxs-lookup"><span data-stu-id="ea488-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="ea488-107">Aby umożliwić korzystanie z narzędzi, takich jak środowisko IDE, dodatki, narzędzia do analizy kodu i refaktoryzacje — aby zobaczyć i przetworzyć strukturę składni kodu źródłowego w projekcie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ea488-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="ea488-108">Aby włączyć narzędzia — takie jak refaktoryzacje i środowisko IDE — do tworzenia, modyfikowania i ponownego rozmieszczania kodu źródłowego w naturalny sposób bez konieczności używania bezpośredniej edycji tekstu.</span><span class="sxs-lookup"><span data-stu-id="ea488-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having to use direct text edits.</span></span> <span data-ttu-id="ea488-109">Tworząc i manipulowania drzewami, narzędzia mogą łatwo tworzyć i zmieniać rozmieszczenie kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="ea488-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="ea488-110">Drzewa składni</span><span class="sxs-lookup"><span data-stu-id="ea488-110">Syntax trees</span></span>

<span data-ttu-id="ea488-111">Drzewa składni są podstawową strukturą używaną do kompilowania, analizy kodu, powiązania, refaktoryzacji, funkcji środowiska IDE i generowania kodu.</span><span class="sxs-lookup"><span data-stu-id="ea488-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="ea488-112">Żadna część kodu źródłowego nie jest zrozumiała bez jej pierwszego zidentyfikowania i sklasyfikowania do jednego z wielu dobrze znanych elementów języka strukturalnego.</span><span class="sxs-lookup"><span data-stu-id="ea488-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="ea488-113">Drzewa składni mają trzy atrybuty klucza.</span><span class="sxs-lookup"><span data-stu-id="ea488-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="ea488-114">Pierwszym atrybutem jest to, że drzewa składni przechowują wszystkie informacje źródłowe z pełną dokładnością.</span><span class="sxs-lookup"><span data-stu-id="ea488-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="ea488-115">Oznacza to, że drzewo składni zawiera wszystkie informacje znajdujące się w tekście źródłowym, każda konstrukcja gramatyczna, każdy token leksykalny i wszystkie inne elementy między, w tym białe znaki, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="ea488-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="ea488-116">Na przykład każdy literał wymieniony w źródle jest reprezentowany dokładnie w takiej postaci, w jakiej został wprowadzony.</span><span class="sxs-lookup"><span data-stu-id="ea488-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="ea488-117">Drzewa składni reprezentują także błędy w kodzie źródłowym, gdy program jest niekompletny lub nieprawidłowo sformułowany przez reprezentowanie pominiętych lub brakujących tokenów w drzewie składni.</span><span class="sxs-lookup"><span data-stu-id="ea488-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>

<span data-ttu-id="ea488-118">Umożliwia to drugi atrybut drzew składni.</span><span class="sxs-lookup"><span data-stu-id="ea488-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="ea488-119">Drzewo składni uzyskane z parsera może generować dokładny tekst, z którego przeprowadzono analizę.</span><span class="sxs-lookup"><span data-stu-id="ea488-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="ea488-120">Z dowolnego węzła składni można uzyskać tekstową reprezentację poddrzewa podrzędnego znajdującego się w tym węźle.</span><span class="sxs-lookup"><span data-stu-id="ea488-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="ea488-121">Oznacza to, że drzewa składni mogą służyć jako sposób konstruowania i edytowania tekstu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="ea488-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="ea488-122">Tworząc drzewo posiadane przez implikacje utworzenia równoważnego tekstu i edytując drzewo składni, wprowadzając nowe drzewo poza zmiany do istniejącego drzewa, możesz efektywnie edytować tekst.</span><span class="sxs-lookup"><span data-stu-id="ea488-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="ea488-123">Trzeci atrybut drzew składni polega na tym, że są one niezmienne i bezpieczne wątkowo.</span><span class="sxs-lookup"><span data-stu-id="ea488-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="ea488-124">Oznacza to, że po uzyskaniu drzewa jest on migawką bieżącego stanu kodu i nigdy nie ulega zmianie.</span><span class="sxs-lookup"><span data-stu-id="ea488-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="ea488-125">Dzięki temu wielu użytkowników może jednocześnie korzystać z tego samego drzewa składni w różnych wątkach bez blokowania ani duplikowania.</span><span class="sxs-lookup"><span data-stu-id="ea488-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="ea488-126">Ponieważ drzewa są niezmienne i nie można wprowadzać modyfikacji bezpośrednio do drzewa, metody fabryki ułatwiają tworzenie i modyfikowanie drzew składniowych przez tworzenie dodatkowych migawek drzewa.</span><span class="sxs-lookup"><span data-stu-id="ea488-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="ea488-127">Drzewa są wydajne w sposób, w jaki ponownie korzystają z węzłów źródłowych, więc nową wersję można skompilować szybko i przy użyciu małej ilości dodatkowej pamięci.</span><span class="sxs-lookup"><span data-stu-id="ea488-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="ea488-128">Drzewo składni jest dosłownie strukturą danych drzewa, w której elementy strukturalne niebędące elementami nadrzędnymi innych elementów są nadrzędne.</span><span class="sxs-lookup"><span data-stu-id="ea488-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="ea488-129">Każde drzewo składni składa się z węzłów, tokenów i kwizy.</span><span class="sxs-lookup"><span data-stu-id="ea488-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="ea488-130">Węzły składni</span><span class="sxs-lookup"><span data-stu-id="ea488-130">Syntax nodes</span></span>

<span data-ttu-id="ea488-131">Węzły składni są jednym z głównych elementów drzew składni.</span><span class="sxs-lookup"><span data-stu-id="ea488-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="ea488-132">Te węzły reprezentują konstrukcje składniowe, takie jak deklaracje, instrukcje, klauzule i wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="ea488-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="ea488-133">Każda kategoria węzłów składni jest reprezentowana przez oddzielną klasę pochodną <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>od.</span><span class="sxs-lookup"><span data-stu-id="ea488-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ea488-134">Zestaw klas węzłów nie jest rozszerzalny.</span><span class="sxs-lookup"><span data-stu-id="ea488-134">The set of node classes is not extensible.</span></span>

<span data-ttu-id="ea488-135">Wszystkie węzły składni nie są węzłami terminalu w drzewie składni, co oznacza, że zawsze mają inne węzły i tokeny jako elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="ea488-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="ea488-136">Jako element podrzędny innego węzła każdy węzeł ma węzeł nadrzędny, do którego można uzyskać dostęp za pomocą <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="ea488-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ea488-137">Ponieważ węzły i drzewa są niezmienne, nadrzędny węzeł nigdy nie ulega zmianie.</span><span class="sxs-lookup"><span data-stu-id="ea488-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="ea488-138">Katalog główny drzewa ma element nadrzędny o wartości null.</span><span class="sxs-lookup"><span data-stu-id="ea488-138">The root of the tree has a null parent.</span></span>

<span data-ttu-id="ea488-139">Każdy węzeł ma <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> metodę, która zwraca listę węzłów podrzędnych w kolejności sekwencyjnej na podstawie ich położenia w tekście źródłowym.</span><span class="sxs-lookup"><span data-stu-id="ea488-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="ea488-140">Ta lista nie zawiera tokenów.</span><span class="sxs-lookup"><span data-stu-id="ea488-140">This list does not contain tokens.</span></span> <span data-ttu-id="ea488-141">Każdy węzeł ma także metody do badania elementów podrzędnych, takich jak <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>lub <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> reprezentujące listę wszystkich węzłów, tokenów lub kwizy, które istnieją w poddrzewie głównym, które znajdują się na tym węźle.</span><span class="sxs-lookup"><span data-stu-id="ea488-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the sub-tree rooted by that node.</span></span>

<span data-ttu-id="ea488-142">Ponadto każda podklasa węzłów węzła uwidacznia wszystkie te same elementy podrzędne za pomocą właściwości silnie wpisanych.</span><span class="sxs-lookup"><span data-stu-id="ea488-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="ea488-143">Na przykład <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> Klasa węzła ma trzy dodatkowe właściwości specyficzne dla operatorów <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>binarnych:, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, i. <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right></span><span class="sxs-lookup"><span data-stu-id="ea488-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="ea488-144"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> Typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>jest, i typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> to. <xref:Microsoft.CodeAnalysis.SyntaxToken></span><span class="sxs-lookup"><span data-stu-id="ea488-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="ea488-145">Niektóre węzły składni mają opcjonalne elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="ea488-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="ea488-146">Na przykład, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> ma opcjonalnie <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="ea488-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="ea488-147">Jeśli element podrzędny nie istnieje, właściwość zwraca wartość null.</span><span class="sxs-lookup"><span data-stu-id="ea488-147">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="ea488-148">Tokeny składni</span><span class="sxs-lookup"><span data-stu-id="ea488-148">Syntax tokens</span></span>

<span data-ttu-id="ea488-149">Tokeny składni to terminale gramatyki języka, reprezentujące najmniejsze fragmenty składni kodu.</span><span class="sxs-lookup"><span data-stu-id="ea488-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="ea488-150">Nigdy nie są nadrzędne w stosunku do innych węzłów lub tokenów.</span><span class="sxs-lookup"><span data-stu-id="ea488-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="ea488-151">Tokeny składni składają się z słów kluczowych, identyfikatorów, literałów i znaków interpunkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="ea488-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="ea488-152">W celu zapewnienia wydajności <xref:Microsoft.CodeAnalysis.SyntaxToken> typ jest typem wartości CLR.</span><span class="sxs-lookup"><span data-stu-id="ea488-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="ea488-153">W związku z tym w przeciwieństwie do węzłów składni istnieje tylko jedna struktura dla wszystkich rodzajów tokenów z mieszaniem właściwości, które mają znaczenie w zależności od rodzaju reprezentowanego tokenu.</span><span class="sxs-lookup"><span data-stu-id="ea488-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="ea488-154">Na przykład token literału Integer reprezentuje wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="ea488-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="ea488-155">Oprócz pierwotnego tekstu źródła, który obejmuje token, token literału ma <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> właściwość, która informuje o dokładnej zdekodowanej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="ea488-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="ea488-156">Ta właściwość jest wpisana jako <xref:System.Object> ponieważ może być jednym z wielu typów pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="ea488-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="ea488-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> Właściwość informuje o tym te same informacje, co <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> Właściwość; Jednak ta właściwość zawsze jest wpisana jako <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="ea488-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="ea488-158">Identyfikator w tekście źródłowym języka C# może zawierać znaki ucieczki Unicode, a mimo to składnia sekwencji unikowej nie jest uważana za część nazwy identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="ea488-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="ea488-159">Mimo że nieprzetworzony tekst objęty tokenem zawiera sekwencję ucieczki, <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> właściwość nie jest.</span><span class="sxs-lookup"><span data-stu-id="ea488-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="ea488-160">Zamiast tego zawiera znaki Unicode identyfikowane przez Escape.</span><span class="sxs-lookup"><span data-stu-id="ea488-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="ea488-161">Na przykład, jeśli tekst źródłowy zawiera identyfikator zapisany jako `\u03C0`, wówczas właściwość dla tego <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> tokenu zwróci `π`wartość.</span><span class="sxs-lookup"><span data-stu-id="ea488-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="ea488-162">Kwizy składni</span><span class="sxs-lookup"><span data-stu-id="ea488-162">Syntax trivia</span></span>

<span data-ttu-id="ea488-163">Składnia kwizy reprezentuje części tekstu źródłowego, które są w znacznym stopniu nieważne do normalnego poznania kodu, takie jak białe znaki, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="ea488-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="ea488-164">Podobnie jak tokeny składniowe, kwizy są typami wartości.</span><span class="sxs-lookup"><span data-stu-id="ea488-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="ea488-165">Pojedynczy <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> typ jest używany do opisywania wszystkich rodzajów kwizy.</span><span class="sxs-lookup"><span data-stu-id="ea488-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="ea488-166">Ponieważ kwizy nie są częścią standardowej składni języka i mogą znajdować się w dowolnym miejscu między dwoma tokenami, nie są uwzględniane w drzewie składni jako element podrzędny węzła.</span><span class="sxs-lookup"><span data-stu-id="ea488-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="ea488-167">Jeszcze ponieważ są one ważne podczas implementowania funkcji, takiej jak Refaktoryzacja i aby zachować pełną wierność z tekstem źródłowym, są one dostępne jako część drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="ea488-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="ea488-168">Dostęp do kwizy można uzyskać, sprawdzając token <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> lub <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> kolekcje.</span><span class="sxs-lookup"><span data-stu-id="ea488-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="ea488-169">Po przeanalizowaniu tekstu źródłowego sekwencje kwizy są skojarzone z tokenami.</span><span class="sxs-lookup"><span data-stu-id="ea488-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="ea488-170">Ogólnie rzecz biorąc, token jest własnością dowolnego kwizy po tej samej linii do następnego tokenu.</span><span class="sxs-lookup"><span data-stu-id="ea488-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="ea488-171">Wszystkie kwizy po tym wierszu są skojarzone z poniższym tokenem.</span><span class="sxs-lookup"><span data-stu-id="ea488-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="ea488-172">Pierwszy token w pliku źródłowym pobiera wszystkie początkowe kwizy, a Ostatnia sekwencja kwizy w pliku jest prostopadła do tokenu końca pliku, w przeciwnym razie ma zerową szerokość.</span><span class="sxs-lookup"><span data-stu-id="ea488-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="ea488-173">W przeciwieństwie do węzłów składni i tokenów składnia kwizy nie ma elementów nadrzędnych.</span><span class="sxs-lookup"><span data-stu-id="ea488-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="ea488-174">Jeszcze ponieważ są one częścią drzewa, a każda z nich jest skojarzona z pojedynczym tokenem, można uzyskać dostęp do tokenu skojarzonego z użyciem <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="ea488-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="ea488-175">Obejmuje</span><span class="sxs-lookup"><span data-stu-id="ea488-175">Spans</span></span>

<span data-ttu-id="ea488-176">Każdy węzeł, token lub kwizy wie swoją pozycję w tekście źródłowym oraz liczbę znaków, które zawiera.</span><span class="sxs-lookup"><span data-stu-id="ea488-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="ea488-177">Pozycja tekstowa jest reprezentowana jako 32-bitowa liczba całkowita, która jest indeksem liczonym `char` od zera.</span><span class="sxs-lookup"><span data-stu-id="ea488-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="ea488-178"><xref:Microsoft.CodeAnalysis.Text.TextSpan> Obiekt jest pozycją początkową i liczbą znaków, reprezentowanych jako liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="ea488-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="ea488-179">Jeśli <xref:Microsoft.CodeAnalysis.Text.TextSpan> ma zerową długość, odnosi się do lokalizacji między dwoma znakami.</span><span class="sxs-lookup"><span data-stu-id="ea488-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="ea488-180">Każdy węzeł ma dwie <xref:Microsoft.CodeAnalysis.Text.TextSpan> właściwości: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> i <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span><span class="sxs-lookup"><span data-stu-id="ea488-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="ea488-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> Właściwość jest zakresem tekstu od początku pierwszego tokenu w poddrzewie węzła do końca ostatniego tokenu.</span><span class="sxs-lookup"><span data-stu-id="ea488-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="ea488-182">Ten zakres nie obejmuje żadnych kwizy wiodących ani końcowych.</span><span class="sxs-lookup"><span data-stu-id="ea488-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="ea488-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> Właściwość jest zakresem tekstu, który obejmuje normalny zakres węzła oraz zakres wszystkich wiodących lub końcowych kwizy.</span><span class="sxs-lookup"><span data-stu-id="ea488-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="ea488-184">Przykład:</span><span class="sxs-lookup"><span data-stu-id="ea488-184">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="ea488-185">Węzeł instrukcji wewnątrz bloku ma zakres wskazany przez pojedyncze pionowe słupki (|).</span><span class="sxs-lookup"><span data-stu-id="ea488-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="ea488-186">Zawiera znaki `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="ea488-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="ea488-187">Pełny zakres jest wskazywany przez podwójne pionowe słupki (| |).</span><span class="sxs-lookup"><span data-stu-id="ea488-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="ea488-188">Zawiera te same znaki, jak zakres i znaki skojarzone z kwizy wiodące i końcowe.</span><span class="sxs-lookup"><span data-stu-id="ea488-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="ea488-189">Rodzaje</span><span class="sxs-lookup"><span data-stu-id="ea488-189">Kinds</span></span>

<span data-ttu-id="ea488-190">Każdy węzeł, token lub kwizy ma <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> właściwość typu <xref:System.Int32?displayProperty=nameWithType>, która identyfikuje dokładnie przedstawiony element składni.</span><span class="sxs-lookup"><span data-stu-id="ea488-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="ea488-191">Ta wartość może być rzutowana na Wyliczenie specyficzne dla języka.</span><span class="sxs-lookup"><span data-stu-id="ea488-191">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="ea488-192">Każdy język, C# lub Visual Basic, ma pojedyncze `SyntaxKind` Wyliczenie (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>odpowiednio), które wyświetla listę wszystkich możliwych węzłów, tokenów i elementów kwizy w gramatyce.</span><span class="sxs-lookup"><span data-stu-id="ea488-192">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="ea488-193">Tę konwersję można wykonać automatycznie, uzyskując <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> dostęp <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> do metod rozszerzenia lub.</span><span class="sxs-lookup"><span data-stu-id="ea488-193">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="ea488-194"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> Właściwość umożliwia łatwe Uściślanie typów węzłów składni, które współużytkują tę samą klasę węzła.</span><span class="sxs-lookup"><span data-stu-id="ea488-194">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="ea488-195">W przypadku tokenów i kwizy ta właściwość jest jedynym sposobem odróżnienia jednego typu elementu od innego.</span><span class="sxs-lookup"><span data-stu-id="ea488-195">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="ea488-196">Na <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> przykład pojedyncza Klasa <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>ma, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jako elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="ea488-196">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="ea488-197"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> Właściwość <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>określa, czy jest to węzeł składni, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>czy też <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> .</span><span class="sxs-lookup"><span data-stu-id="ea488-197">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="ea488-198">Errors</span><span class="sxs-lookup"><span data-stu-id="ea488-198">Errors</span></span>

<span data-ttu-id="ea488-199">Nawet wtedy, gdy tekst źródłowy zawiera błędy składni, ujawniane jest pełne drzewo składni, które jest dwustronnie obsługiwane dla źródła.</span><span class="sxs-lookup"><span data-stu-id="ea488-199">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="ea488-200">Gdy analizator napotka kod, który nie jest zgodny ze zdefiniowaną składnią języka, używa jednej z dwóch technik do tworzenia drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="ea488-200">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="ea488-201">Po pierwsze, jeśli Analizator oczekuje określonego rodzaju tokenu, ale nie znajdzie go, może wstawić brakującego tokenu do drzewa składni w lokalizacji, w której Oczekiwano tokenu.</span><span class="sxs-lookup"><span data-stu-id="ea488-201">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="ea488-202">Brakujący token reprezentuje rzeczywisty token, który był oczekiwany, ale ma pusty zakres, a jego <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> Właściwość zwraca. `true`</span><span class="sxs-lookup"><span data-stu-id="ea488-202">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="ea488-203">Po drugie Analizator może pominąć tokeny do momentu znalezienia, gdzie można kontynuować analizowanie.</span><span class="sxs-lookup"><span data-stu-id="ea488-203">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="ea488-204">W takim przypadku pominięte tokeny są dołączane jako węzeł kwizy o rodzaju <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="ea488-204">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
