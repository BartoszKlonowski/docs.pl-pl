---
title: Użyj modelu składni zestawu SDK platformy kompilatora .NET
description: Ten przegląd zawiera opis typów, używaną do manipulowania składni węzłów.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: a48d48168dffdb439c984f5b4209019514b3b970
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61706601"
---
# <a name="work-with-syntax"></a><span data-ttu-id="643f5-103">Korzystanie ze składni</span><span class="sxs-lookup"><span data-stu-id="643f5-103">Work with syntax</span></span>

<span data-ttu-id="643f5-104">**Drzewo składni** to struktura danych podstawowych udostępnianych przez kompilator interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="643f5-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="643f5-105">Drzewa te reprezentują leksykalne i składniowych struktury kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="643f5-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="643f5-106">Służą one dwie ważne do celów:</span><span class="sxs-lookup"><span data-stu-id="643f5-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="643f5-107">Umożliwia narzędzi — takich jak środowisko IDE dodatków, kodu narzędzi do analizy i operacje refaktoryzacji — Aby wyświetlić i przetworzyć strukturę składni kodu źródłowego w projekcie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="643f5-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="643f5-108">Aby włączyć narzędzia — takie jak operacje refaktoryzacji i środowisko IDE — do tworzenia, modyfikowania i rozmieszczanie kodu źródłowego w naturalny sposób bez konieczności zmiany tekstu bezpośredniego użycia.</span><span class="sxs-lookup"><span data-stu-id="643f5-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="643f5-109">Tworzenie i manipulowanie drzewa, narzędzia łatwo można tworzyć i rozmieszczanie kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="643f5-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="643f5-110">Drzewa składni</span><span class="sxs-lookup"><span data-stu-id="643f5-110">Syntax trees</span></span>

<span data-ttu-id="643f5-111">Drzewa składni są podstawowej struktury używany dla kompilacji, analizy kodu, powiązanie, refaktoryzacji i generowanie kodu funkcji środowiska IDE.</span><span class="sxs-lookup"><span data-stu-id="643f5-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="643f5-112">Żadna część kodu źródłowego jest zrozumiałe bez niego najpierw jest zidentyfikowany i dzieli na jeden z wielu elementów dobrze znanego języka strukturalnych.</span><span class="sxs-lookup"><span data-stu-id="643f5-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span> 

<span data-ttu-id="643f5-113">Drzewa składni ma trzy atrybuty kluczy.</span><span class="sxs-lookup"><span data-stu-id="643f5-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="643f5-114">Pierwszy atrybut jest, że drzewa składni przechowywać wszystkie informacje o źródle w pełnej rozdzielczości.</span><span class="sxs-lookup"><span data-stu-id="643f5-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="643f5-115">Oznacza to, że drzewo składni zawiera każdy fragment informacji w tekst źródłowy, co gramatyczne konstrukcji, każdy token leksykalne i wszystkie inne się między tym biały znak, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="643f5-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="643f5-116">Na przykład każdy literał wymienione w źródle jest reprezentowany dokładnie tak, jak została zapisana.</span><span class="sxs-lookup"><span data-stu-id="643f5-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="643f5-117">Drzewa składni również reprezentować błędów w kodzie źródłowym, gdy program jest niekompletny lub uszkodzony, poprzez reprezentowanie pominięto lub brak tokenów w drzewie składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>  

<span data-ttu-id="643f5-118">Dzięki temu drugi atrybut drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="643f5-119">Drzewo składni, uzyskany z analizatora może wygenerować tekstu do dokładnego dopasowania, który był analizowany z.</span><span class="sxs-lookup"><span data-stu-id="643f5-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="643f5-120">Z poziomu każdego węzła składnia jest można uzyskać tekstowa reprezentacja poddrzewie na tym węźle.</span><span class="sxs-lookup"><span data-stu-id="643f5-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="643f5-121">Oznacza to, że składnia drzewa mogą być używane jako sposobu konstruowania i edytować tekst źródłowy.</span><span class="sxs-lookup"><span data-stu-id="643f5-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="643f5-122">Tworząc drzewo posiadanych przez domniemanie, utworzony tekst równoważnym i edytując drzewo składni wprowadzanie nowego drzewa poza zmiany w istniejącym drzewie, edytowano skutecznie tekstu.</span><span class="sxs-lookup"><span data-stu-id="643f5-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span> 

<span data-ttu-id="643f5-123">Trzeci atrybut drzewa składni jest są niezmienne i metodą o bezpiecznych wątkach.</span><span class="sxs-lookup"><span data-stu-id="643f5-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="643f5-124">Oznacza to, że po uzyskaniu drzewa jest migawką bieżącego stanu kod i nigdy się nie zmienia.</span><span class="sxs-lookup"><span data-stu-id="643f5-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="643f5-125">To umożliwia wielu użytkownikom na interakcję z tym samym drzewie składni w tym samym czasie w różnych wątkach, bez blokowania lub dublowania.</span><span class="sxs-lookup"><span data-stu-id="643f5-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="643f5-126">Ponieważ drzewa są niezmienne i żadnych modyfikacji nie jest możliwe bezpośrednio do drzewa, metodach fabryki pomagają tworzyć i modyfikować drzewa składni, tworząc dodatkowe migawek drzewa.</span><span class="sxs-lookup"><span data-stu-id="643f5-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="643f5-127">Drzewa są efektywne w sposób ich ponownego użycia węzłów podrzędnych, więc nowej wersji można ponownie skompilować szybko i przy niewielkim dodatkową pamięć.</span><span class="sxs-lookup"><span data-stu-id="643f5-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="643f5-128">Drzewo składni jest dosłownie struktury drzewa danych, której elementy strukturalne-terminal nadrzędnego inne elementy.</span><span class="sxs-lookup"><span data-stu-id="643f5-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="643f5-129">Każdy drzewo składni składa się z węzłów, tokenów i elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>  

## <a name="syntax-nodes"></a><span data-ttu-id="643f5-130">Składnia węzłów</span><span class="sxs-lookup"><span data-stu-id="643f5-130">Syntax nodes</span></span>

<span data-ttu-id="643f5-131">Składnia węzły są jednym z podstawowe elementy drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="643f5-132">Węzły te reprezentują konstrukcji składniowych, takich jak deklaracje, instrukcje, klauzule i wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="643f5-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="643f5-133">Każda kategoria węzłów składnia jest reprezentowany przez oddzielne klasy pochodzącej od <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="643f5-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="643f5-134">Zestaw klas węzeł nie jest rozszerzalny.</span><span class="sxs-lookup"><span data-stu-id="643f5-134">The set of node classes is not extensible.</span></span> 

<span data-ttu-id="643f5-135">Wszystkie węzły składni są-terminal węzłów w drzewie składni, co oznacza, że mają one zawsze inne węzły i tokenów jako elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="643f5-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="643f5-136">Jako element podrzędny innego węzła, każdy węzeł ma węzła nadrzędnego, który jest możliwy za pośrednictwem <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="643f5-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="643f5-137">Ponieważ węzłów i drzewa są niezmienne, element nadrzędny węzła nigdy się nie zmienia.</span><span class="sxs-lookup"><span data-stu-id="643f5-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="643f5-138">Główny drzewa ma element nadrzędny o wartości null.</span><span class="sxs-lookup"><span data-stu-id="643f5-138">The root of the tree has a null parent.</span></span>  

<span data-ttu-id="643f5-139">Każdy węzeł ma <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> metody, która zwraca listę węzłów podrzędnych w kolejności sekwencyjnej, w oparciu o ich pozycji w tekście źródłowym.</span><span class="sxs-lookup"><span data-stu-id="643f5-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="643f5-140">Ta lista nie zawiera tokenów.</span><span class="sxs-lookup"><span data-stu-id="643f5-140">This list does not contain tokens.</span></span> <span data-ttu-id="643f5-141">Każdy węzeł ma również metody, aby sprawdzić elementy podrzędne, takie jak <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, lub <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> — reprezentujące listy wszystkich węzłów, tokenów i elementy towarzyszące składni, która istnieje w poddrzewie odblokowany dostęp do tego węzła.</span><span class="sxs-lookup"><span data-stu-id="643f5-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia, that exist in the sub-tree rooted by that node.</span></span>  

<span data-ttu-id="643f5-142">Ponadto każda podklasa węzeł składni udostępnia te same elementy podrzędne za pośrednictwem silnie typizowane właściwości.</span><span class="sxs-lookup"><span data-stu-id="643f5-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="643f5-143">Na przykład <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> klasa węzła ma trzy dodatkowe właściwości specyficzne dla operatorów binarnych: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="643f5-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="643f5-144">Typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jest <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>oraz typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> jest <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="643f5-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="643f5-145">Niektóre węzły składni mają opcjonalne elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="643f5-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="643f5-146">Na przykład <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> ma opcjonalny <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="643f5-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="643f5-147">Jeśli nie ma elementu podrzędnego, właściwości zwracają wartość zero.</span><span class="sxs-lookup"><span data-stu-id="643f5-147">If the child is not present, the property returns null.</span></span> 

## <a name="syntax-tokens"></a><span data-ttu-id="643f5-148">Składnia tokenów</span><span class="sxs-lookup"><span data-stu-id="643f5-148">Syntax tokens</span></span>

<span data-ttu-id="643f5-149">Składnia tokeny są terminali gramatyki języka, reprezentująca najmniejszą składni fragmentów kodu.</span><span class="sxs-lookup"><span data-stu-id="643f5-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="643f5-150">Nigdy nie są one elementy nadrzędne w innych węzłach lub tokenów.</span><span class="sxs-lookup"><span data-stu-id="643f5-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="643f5-151">Tokeny składni składają się z słów kluczowych, identyfikatory, literałów i znaki interpunkcyjne.</span><span class="sxs-lookup"><span data-stu-id="643f5-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span> 

<span data-ttu-id="643f5-152">Ze względów wydajności <xref:Microsoft.CodeAnalysis.SyntaxToken> typ jest typem wartości CLR.</span><span class="sxs-lookup"><span data-stu-id="643f5-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="643f5-153">W związku z tym w przeciwieństwie do składni węzłów, istnieje tylko jedna struktura dla wszystkich rodzajów tokenów przy użyciu kombinacji właściwości, które mają znaczenie w zależności od rodzaju token, który jest reprezentowanego.</span><span class="sxs-lookup"><span data-stu-id="643f5-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="643f5-154">Na przykład tokenu literał liczby całkowitej reprezentuje wartość numeryczną.</span><span class="sxs-lookup"><span data-stu-id="643f5-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="643f5-155">Oprócz tekst źródłowy pierwotne tokenu zakresy, token literału ma <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> właściwość, która informuje, dokładną zdekodować wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="643f5-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="643f5-156">Ta właściwość jest wpisana jako <xref:System.Object> ponieważ może to być jeden z wielu typów pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="643f5-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="643f5-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> Właściwość zawiera informacje, te same informacje co <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> właściwości; jednak ta właściwość jest zawsze jako wpisana <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="643f5-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="643f5-158">Identyfikator w C# tekst źródłowy może zawierać znaków ucieczki Unicode jeszcze składnia sekwencji ucieczki, sama nie jest uważany za część nazwy identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="643f5-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="643f5-159">Tak, mimo że nieprzetworzony tekst objęte token obejmują sekwencja unikowa <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> nie obsługuje właściwości.</span><span class="sxs-lookup"><span data-stu-id="643f5-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="643f5-160">Zamiast tego zawiera znaki Unicode, identyfikowany przez znak ucieczki.</span><span class="sxs-lookup"><span data-stu-id="643f5-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="643f5-161">Na przykład, jeśli tekst źródłowy zawiera identyfikator zapisywane jako `\u03C0`, a następnie <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> właściwość dla tego tokenu będzie zwracać `π`.</span><span class="sxs-lookup"><span data-stu-id="643f5-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="643f5-162">Elementy towarzyszące składni składni</span><span class="sxs-lookup"><span data-stu-id="643f5-162">Syntax trivia</span></span>

<span data-ttu-id="643f5-163">Elementy towarzyszące składni składni reprezentują części tekst źródłowy, które są w dużym stopniu nieznaczące normalne zrozumienie kodu, takich jak biały znak, komentarze i dyrektywy preprocesora.</span><span class="sxs-lookup"><span data-stu-id="643f5-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="643f5-164">Podobnie jak tokeny składni elementy towarzyszące składni są typami wartości.</span><span class="sxs-lookup"><span data-stu-id="643f5-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="643f5-165">Pojedynczy <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> typ jest używany do opisania wszelkiego rodzaju elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="643f5-166">Ponieważ elementy towarzyszące składni nie są częścią składni języka normalne i może występować w dowolnym miejscu między wszystkie dwa tokeny, są one nie uwzględnione w drzewie składni jako element podrzędny węzła.</span><span class="sxs-lookup"><span data-stu-id="643f5-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="643f5-167">Jeszcze ponieważ są one ważne podczas implementowania funkcji, takich jak Refaktoryzacja i zapewnić pełną zgodność z tekst źródłowy, są dostępne jako część drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="643f5-168">Elementy towarzyszące składni można uzyskać dostęp, sprawdzając, czy token <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> lub <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="643f5-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="643f5-169">Gdy zostanie przeanalizowany tekst źródłowy, sekwencji elementy towarzyszące składni są skojarzone z tokenami.</span><span class="sxs-lookup"><span data-stu-id="643f5-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="643f5-170">Ogólnie rzecz biorąc token jest właścicielem wszelkie elementy towarzyszące składni po nim w tym samym wierszu, aż do następnego tokenu.</span><span class="sxs-lookup"><span data-stu-id="643f5-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="643f5-171">Wszystkie elementy towarzyszące składni po tym wierszu jest skojarzony z następującego tokenu.</span><span class="sxs-lookup"><span data-stu-id="643f5-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="643f5-172">Pierwszy token w pliku źródłowym pobiera wszystkie początkowe elementy towarzyszące składni i kumulowany jest ostatnią sekwencję elementy towarzyszące składni w pliku na token końca pliku, która w przeciwnym razie ma zerowej szerokości.</span><span class="sxs-lookup"><span data-stu-id="643f5-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="643f5-173">W przeciwieństwie do składni węzłów i tokenów składnia elementy towarzyszące składni nie mają elementów nadrzędnych.</span><span class="sxs-lookup"><span data-stu-id="643f5-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="643f5-174">Jeszcze, ponieważ są one częścią drzewa, a każda jest skojarzony z pojedynczy token, dostęp można uzyskać tokenu jest skojarzony z przy użyciu <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="643f5-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="643f5-175">Zakresy</span><span class="sxs-lookup"><span data-stu-id="643f5-175">Spans</span></span>

<span data-ttu-id="643f5-176">Każdy węzeł, token lub elementy towarzyszące składni zna jego pozycja w tekście źródłowym i liczbę znaków, który składa się z.</span><span class="sxs-lookup"><span data-stu-id="643f5-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="643f5-177">Położenie tekstu jest reprezentowany jako 32-bitową liczbę całkowitą, która jest liczony od zera `char` indeksu.</span><span class="sxs-lookup"><span data-stu-id="643f5-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="643f5-178">Element <xref:Microsoft.CodeAnalysis.Text.TextSpan> obiektu pozycję początkową i liczba znaków, zarówno w postaci liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="643f5-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="643f5-179">Jeśli <xref:Microsoft.CodeAnalysis.Text.TextSpan> ma zerową długość, odwołuje się do lokalizacji między dwoma znakami.</span><span class="sxs-lookup"><span data-stu-id="643f5-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="643f5-180">Każdy węzeł ma dwa <xref:Microsoft.CodeAnalysis.Text.TextSpan> właściwości: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> i <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span><span class="sxs-lookup"><span data-stu-id="643f5-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span></span> 

<span data-ttu-id="643f5-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> Właściwość jest zakres tekstu od początku pierwszym tokenem w poddrzewie węzła do końca ostatni token.</span><span class="sxs-lookup"><span data-stu-id="643f5-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="643f5-182">Ten zakres nie obejmuje żadnych wiodących ani końcowych elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="643f5-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> Właściwość jest obszaru tekstu, który obejmuje podrzędnego span normalne oraz zakres dowolnego wiodących ani końcowych elementy towarzyszące składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="643f5-184">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="643f5-184">For example:</span></span> 

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="643f5-185">Węzeł instrukcji wewnątrz bloku zawiera zakres wskazywany przez pojedynczy pionowych słupków (|).</span><span class="sxs-lookup"><span data-stu-id="643f5-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="643f5-186">Zawiera on znaki `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="643f5-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="643f5-187">Pełny zakres jest wskazywany przez podwójne paski pionowej (|).</span><span class="sxs-lookup"><span data-stu-id="643f5-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="643f5-188">Zawiera te same znaki, jako zakres i znaków skojarzonych elementy towarzyszące składni początkowe i końcowe.</span><span class="sxs-lookup"><span data-stu-id="643f5-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="643f5-189">Rodzaje</span><span class="sxs-lookup"><span data-stu-id="643f5-189">Kinds</span></span>

<span data-ttu-id="643f5-190">Każdy węzeł, token lub elementy towarzyszące składni ma <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> właściwość typu <xref:System.Int32?displayProperty=nameWithType>, który identyfikuje element dokładna składnia reprezentowany.</span><span class="sxs-lookup"><span data-stu-id="643f5-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="643f5-191">Ta wartość może być rzutowany na wyliczenie specyficzny dla języka; Każdy język C# lub VB, ma jeden `SyntaxKind` wyliczenia (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> i <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>odpowiednio), zawiera listę wszystkich możliwych węzłów, tokenów i elementy towarzyszące składni elementów, w gramatyce.</span><span class="sxs-lookup"><span data-stu-id="643f5-191">This value can be cast to a language-specific enumeration; each language, C# or VB, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="643f5-192">Ta konwersja może odbywać się automatycznie, uzyskując dostęp do <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> lub <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="643f5-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="643f5-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> Właściwość zezwala na Uściślanie proste typy węzłów składni, które mają tej samej klasie w węźle.</span><span class="sxs-lookup"><span data-stu-id="643f5-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="643f5-194">Tokeny i elementy towarzyszące składni ta właściwość jest jedynym sposobem, aby odróżnić jeden typ elementu z innego.</span><span class="sxs-lookup"><span data-stu-id="643f5-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span> 

<span data-ttu-id="643f5-195">Na przykład pojedynczy <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> klasa ma <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, i <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jako elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="643f5-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="643f5-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> Właściwość różnic między usługą, czy jest ono <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, lub <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> rodzaj węzła składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="643f5-197">błędy</span><span class="sxs-lookup"><span data-stu-id="643f5-197">Errors</span></span>

<span data-ttu-id="643f5-198">Nawet wtedy, gdy tekst źródłowy zawiera błędy składni, jest udostępniany drzewa pełną składnię, która jest wysyłanych do źródła.</span><span class="sxs-lookup"><span data-stu-id="643f5-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="643f5-199">Gdy analizator składni napotka kod, który jest niezgodny ze zdefiniowanych składni języka, używa jednego z dwóch technik tworzenia drzewa składni.</span><span class="sxs-lookup"><span data-stu-id="643f5-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="643f5-200">Po pierwsze Jeśli parser oczekuje określonego rodzaju token, ale nie zostanie znaleziona, jego może Wstawianie Brak tokenu drzewa składni w lokalizacji, oczekiwany token.</span><span class="sxs-lookup"><span data-stu-id="643f5-200">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="643f5-201">Brak tokenu reprezentuje rzeczywisty token, który był oczekiwany, ale ma pusty zakres i jego <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> właściwość zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="643f5-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="643f5-202">Po drugie analizator może pominąć tokenów, dopóki nie zostanie znaleziony taki, gdzie można kontynuować, analizowanie.</span><span class="sxs-lookup"><span data-stu-id="643f5-202">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="643f5-203">W tym przypadku pominiętych tokeny są dołączone jako węzeł elementy towarzyszące składni z rodzajem <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="643f5-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
