---
title: Pisanie bezpiecznego i wydajnego kodu C#
description: Ostatnie ulepszenia języka C# umożliwiają pisanie weryfikowalny kod bezpieczny, który wydajność wcześniej skojarzone z niebezpiecznym kodem.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: bb53264f61192c042da469ba687da6c472e8c6d4
ms.sourcegitcommit: 2514f4e3655081dcfe1b22470c0c28500f952c42
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/18/2020
ms.locfileid: "79506986"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="3a84c-103">Pisanie bezpiecznego i wydajnego kodu C#</span><span class="sxs-lookup"><span data-stu-id="3a84c-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="3a84c-104">Nowe funkcje w języku C# umożliwiają pisanie weryfikowalny bezpieczny kod z lepszą wydajność.</span><span class="sxs-lookup"><span data-stu-id="3a84c-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="3a84c-105">Jeśli starannie zastosujesz te techniki, mniej scenariuszy wymaga niebezpiecznego kodu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="3a84c-106">Te funkcje ułatwiają używanie odwołań do typów wartości jako argumentów metody i zwracanych metod.</span><span class="sxs-lookup"><span data-stu-id="3a84c-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="3a84c-107">Po wykonaniu bezpiecznie, techniki te zminimalizować kopiowanie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="3a84c-108">Za pomocą typów wartości, można zminimalizować liczbę alokacji i wyrzucania elementów bezużytecznych przechodzi.</span><span class="sxs-lookup"><span data-stu-id="3a84c-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="3a84c-109">Wiele przykładowego kodu w tym artykule używa funkcji dodanych w języku C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="3a84c-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="3a84c-110">Aby korzystać z tych funkcji, należy skonfigurować projekt do używania języka C# 7.2 lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="3a84c-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="3a84c-111">Aby uzyskać więcej informacji na temat ustawiania wersji [językowej, zobacz konfigurowanie wersji językowej](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="3a84c-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="3a84c-112">W tym artykule skupiono się na technikach efektywnego zarządzania zasobami.</span><span class="sxs-lookup"><span data-stu-id="3a84c-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="3a84c-113">Jedną z zalet przy użyciu typów wartości jest to, że często unikają alokacji sterty.</span><span class="sxs-lookup"><span data-stu-id="3a84c-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="3a84c-114">Wadą jest to, że są one kopiowane przez wartość.</span><span class="sxs-lookup"><span data-stu-id="3a84c-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="3a84c-115">Ten kompromis utrudnia optymalizację algorytmów, które działają na dużych ilościach danych.</span><span class="sxs-lookup"><span data-stu-id="3a84c-115">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="3a84c-116">Nowe funkcje języka w języku C# 7.2 zapewniają mechanizmy, które umożliwiają bezpieczne wydajny kod przy użyciu odwołań do typów wartości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="3a84c-117">Użyj tych funkcji mądrze, aby zminimalizować zarówno alokacji i operacji kopiowania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="3a84c-118">W tym artykule omówiono te nowe funkcje.</span><span class="sxs-lookup"><span data-stu-id="3a84c-118">This article explores those new features.</span></span>

<span data-ttu-id="3a84c-119">W tym artykule skupiono się na następujących technikach zarządzania zasobami:</span><span class="sxs-lookup"><span data-stu-id="3a84c-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="3a84c-120">Zadeklaruj, [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) aby wyrazić, że typ jest **niezmienny** [`in`](language-reference/keywords/in-parameter-modifier.md) i umożliwia kompilatorowi zapisywanie kopii podczas korzystania z parametrów.</span><span class="sxs-lookup"><span data-stu-id="3a84c-120">Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="3a84c-121">Jeśli typ nie może być niezmienne, zadeklarować `struct` członków, `readonly` aby wskazać, że element członkowski nie modyfikuje stanu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-121">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="3a84c-122">Użyj [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) zwracanego, gdy zwracana wartość jest `struct` większa niż <xref:System.IntPtr.Size?displayProperty=nameWithType> i okres istnienia magazynu jest większy niż metoda zwracająca wartość.</span><span class="sxs-lookup"><span data-stu-id="3a84c-122">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="3a84c-123">Gdy rozmiar a `readonly struct` jest <xref:System.IntPtr.Size?displayProperty=nameWithType>większy niż , należy `in` przekazać go jako parametr ze względu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="3a84c-123">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="3a84c-124">Nigdy nie `struct` przekazuje `in` jako parametr, chyba `readonly` że jest zadeklarowany `readonly` za pomocą modyfikatora lub metoda wywołuje tylko członków struktury.</span><span class="sxs-lookup"><span data-stu-id="3a84c-124">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="3a84c-125">Naruszenie tych wskazówek może negatywnie wpłynąć na wydajność i może prowadzić do niejasnego zachowania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-125">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="3a84c-126">Użyj [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), lub `readonly ref struct` takiego <xref:System.Span%601> <xref:System.ReadOnlySpan%601> typu lub do pracy z pamięcią jako sekwencji bajtów.</span><span class="sxs-lookup"><span data-stu-id="3a84c-126">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="3a84c-127">Techniki te zmuszają do zrównoważenia dwóch konkurencyjnych celów w odniesieniu do **odniesień** i **wartości.**</span><span class="sxs-lookup"><span data-stu-id="3a84c-127">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="3a84c-128">Zmienne, które są [typami odwołań,](programming-guide/types/index.md#reference-types) przechowują odwołanie do lokalizacji w pamięci.</span><span class="sxs-lookup"><span data-stu-id="3a84c-128">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="3a84c-129">Zmienne, które są [typami wartości](programming-guide/types/index.md#value-types) bezpośrednio zawierają ich wartość.</span><span class="sxs-lookup"><span data-stu-id="3a84c-129">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="3a84c-130">Różnice te podkreślają kluczowe różnice, które są ważne dla zarządzania zasobami pamięci.</span><span class="sxs-lookup"><span data-stu-id="3a84c-130">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="3a84c-131">**Typy wartości** są zazwyczaj kopiowane po przekazaniu do metody lub zwrócone z metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-131">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="3a84c-132">To zachowanie obejmuje kopiowanie `this` wartości podczas wywoływania elementów członkowskich typu wartości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-132">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="3a84c-133">Koszt kopii jest powiązany z rozmiarem typu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-133">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="3a84c-134">**Typy odwołań** są przydzielane na zarządzanym stosie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-134">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="3a84c-135">Każdy nowy obiekt wymaga nowej alokacji, a następnie musi zostać odzyskany.</span><span class="sxs-lookup"><span data-stu-id="3a84c-135">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="3a84c-136">Obie te operacje zająć trochę czasu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-136">Both these operations take time.</span></span> <span data-ttu-id="3a84c-137">Odwołanie jest kopiowane, gdy typ odwołania jest przekazywany jako argument do metody lub zwracany z metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-137">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="3a84c-138">W tym artykule użyto następującego przykładowego pojęcia struktury 3D-point, aby wyjaśnić te zalecenia:</span><span class="sxs-lookup"><span data-stu-id="3a84c-138">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="3a84c-139">Różne przykłady używają różnych implementacji tej koncepcji.</span><span class="sxs-lookup"><span data-stu-id="3a84c-139">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="3a84c-140">Deklarowanie struktur tylko do odczytu dla niezmiennych typów wartości</span><span class="sxs-lookup"><span data-stu-id="3a84c-140">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="3a84c-141">Deklarowanie `struct` przy `readonly` użyciu modyfikatora informuje kompilator, że intencją jest utworzenie typu niezmienne.</span><span class="sxs-lookup"><span data-stu-id="3a84c-141">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="3a84c-142">Kompilator wymusza tę decyzję o projekcie z następującymi regułami:</span><span class="sxs-lookup"><span data-stu-id="3a84c-142">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="3a84c-143">Wszyscy członkowie terenu muszą być`readonly`</span><span class="sxs-lookup"><span data-stu-id="3a84c-143">All field members must be `readonly`</span></span>
- <span data-ttu-id="3a84c-144">Wszystkie właściwości muszą być tylko do odczytu, w tym właściwości automatycznie zaimplementowane.</span><span class="sxs-lookup"><span data-stu-id="3a84c-144">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="3a84c-145">Te dwie reguły są wystarczające, `readonly struct` aby upewnić się, że żaden członek zmienia stan tej struktury.</span><span class="sxs-lookup"><span data-stu-id="3a84c-145">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="3a84c-146">Jest `struct` niezmienny.</span><span class="sxs-lookup"><span data-stu-id="3a84c-146">The `struct` is immutable.</span></span> <span data-ttu-id="3a84c-147">Struktura `Point3D` może być zdefiniowana jako niezmienna struktura, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="3a84c-147">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="3a84c-148">Postępuj zgodnie z tym zaleceniem, gdy intencją projektu jest utworzenie niezmiennego typu wartości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-148">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="3a84c-149">Wszelkie ulepszenia wydajności są dodatkową korzyścią.</span><span class="sxs-lookup"><span data-stu-id="3a84c-149">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="3a84c-150">Wyraźnie `readonly struct` wyraża swój zamiar projektu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-150">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="3a84c-151">Deklarowanie tylko do odczytu członków, gdy nie można niezmiennie być niezmienną strukturą</span><span class="sxs-lookup"><span data-stu-id="3a84c-151">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="3a84c-152">W języku C# 8.0 i nowszych, gdy typ struktury jest modyfikowalna, należy zadeklarować członków, które nie powodują `readonly`mutacji.</span><span class="sxs-lookup"><span data-stu-id="3a84c-152">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="3a84c-153">Należy wziąć pod uwagę inną aplikację, która wymaga struktury punktów 3D, ale musi obsługiwać zmienność.</span><span class="sxs-lookup"><span data-stu-id="3a84c-153">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="3a84c-154">Następująca wersja struktury punktów 3D `readonly` dodaje modyfikator tylko do tych elementów członkowskich, które nie modyfikują struktury.</span><span class="sxs-lookup"><span data-stu-id="3a84c-154">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="3a84c-155">Postępuj zgodnie z tym przykładem, gdy projekt musi obsługiwać modyfikacje struktury przez niektórych członków, ale nadal chcesz korzyści z wymuszania tylko na niektórych elementach członkowskich:</span><span class="sxs-lookup"><span data-stu-id="3a84c-155">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="3a84c-156">W poprzednim przykładzie przedstawiono wiele lokalizacji, `readonly` w których można zastosować modyfikator: metody, właściwości i akcesory właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-156">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="3a84c-157">Jeśli używasz właściwości automatycznie implementowane, kompilator dodaje `readonly` `get` modyfikator do akcesora dla właściwości odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-157">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="3a84c-158">Kompilator dodaje `readonly` modyfikator do automatycznie implementowanych deklaracji właściwości dla `get` właściwości tylko akcesor.</span><span class="sxs-lookup"><span data-stu-id="3a84c-158">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="3a84c-159">Dodanie `readonly` modyfikatora do elementów członkowskich, które nie mutują stanu zapewnia dwie powiązane korzyści.</span><span class="sxs-lookup"><span data-stu-id="3a84c-159">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="3a84c-160">Po pierwsze kompilator wymusza intencji.</span><span class="sxs-lookup"><span data-stu-id="3a84c-160">First, the compiler enforces your intent.</span></span> <span data-ttu-id="3a84c-161">Ten element członkowski nie może mutować stanu struktury ani nie może uzyskać `readonly`dostępu do elementu członkowskiego, który nie jest również oznaczony.</span><span class="sxs-lookup"><span data-stu-id="3a84c-161">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="3a84c-162">Po drugie kompilator nie utworzy `in` kopii obronnych `readonly` parametrów podczas uzyskiwania dostępu do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="3a84c-162">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="3a84c-163">Kompilator można dokonać tej optymalizacji bezpiecznie, ponieważ gwarantuje, że nie `struct` jest modyfikowany przez element członkowski. `readonly`</span><span class="sxs-lookup"><span data-stu-id="3a84c-163">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="3a84c-164">Jeśli `ref readonly return` to możliwe, używaj instrukcji dla dużych struktur</span><span class="sxs-lookup"><span data-stu-id="3a84c-164">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="3a84c-165">Wartości można zwracać przez odwołanie, gdy zwracana wartość nie jest lokalna dla metody zwracającej.</span><span class="sxs-lookup"><span data-stu-id="3a84c-165">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="3a84c-166">Zwracanie przez odwołanie oznacza, że kopiowane jest tylko odwołanie, a nie struktura.</span><span class="sxs-lookup"><span data-stu-id="3a84c-166">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="3a84c-167">W poniższym przykładzie `Origin` właściwość nie `ref` może użyć zwrotu, ponieważ zwracana wartość jest zmienną lokalną:</span><span class="sxs-lookup"><span data-stu-id="3a84c-167">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="3a84c-168">Jednak następująca definicja właściwości mogą być zwracane przez odwołanie, ponieważ zwracana wartość jest elementem statycznym:</span><span class="sxs-lookup"><span data-stu-id="3a84c-168">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="3a84c-169">Nie chcesz, aby osoby wywołujące modyfikujące początek układu `ref readonly`współrzędnych, więc należy zwrócić wartość przez:</span><span class="sxs-lookup"><span data-stu-id="3a84c-169">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="3a84c-170">Powrót `ref readonly` umożliwia zapisanie kopiowania większych struktur i zachowanie niezmienności wewnętrznych elementów członkowskich danych.</span><span class="sxs-lookup"><span data-stu-id="3a84c-170">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="3a84c-171">W miejscu wywołania dzwoniący dokonują `Origin` wyboru, `ref readonly` aby użyć właściwości jako lub jako wartości:</span><span class="sxs-lookup"><span data-stu-id="3a84c-171">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="3a84c-172">Pierwsze przypisanie w poprzednim kodzie tworzy `Origin` kopię stałej i przypisuje tę kopię.</span><span class="sxs-lookup"><span data-stu-id="3a84c-172">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="3a84c-173">Drugi przypisuje odwołanie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-173">The second assigns a reference.</span></span> <span data-ttu-id="3a84c-174">Należy zauważyć, że `readonly` modyfikator musi być częścią deklaracji zmiennej.</span><span class="sxs-lookup"><span data-stu-id="3a84c-174">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="3a84c-175">Odwołanie, do którego się odnosi, nie może być modyfikowane.</span><span class="sxs-lookup"><span data-stu-id="3a84c-175">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="3a84c-176">Próby w tym celu powodują błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="3a84c-176">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="3a84c-177">Modyfikator `readonly` jest wymagany w `originReference`deklaracji .</span><span class="sxs-lookup"><span data-stu-id="3a84c-177">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="3a84c-178">Kompilator wymusza, że wywołujący nie można zmodyfikować odwołania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-178">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="3a84c-179">Próbuje przypisać wartość bezpośrednio wygenerować błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="3a84c-179">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="3a84c-180">Jednak kompilator nie może wiedzieć, czy dowolna metoda elementu członkowskiego modyfikuje stan struktury.</span><span class="sxs-lookup"><span data-stu-id="3a84c-180">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="3a84c-181">Aby upewnić się, że obiekt nie jest modyfikowany, kompilator tworzy kopię i wywołuje odwołania do elementów członkowskich przy użyciu tej kopii.</span><span class="sxs-lookup"><span data-stu-id="3a84c-181">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="3a84c-182">Wszelkie modyfikacje są do tej kopii obronnej.</span><span class="sxs-lookup"><span data-stu-id="3a84c-182">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="3a84c-183">Zastosuj `in` modyfikator `readonly struct` do parametrów większych niż`System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="3a84c-183">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="3a84c-184">Słowo `in` kluczowe uzupełnia `ref` `out` istniejące i słowa kluczowe, aby przekazać argumenty przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-184">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="3a84c-185">Słowo `in` kluczowe określa przekazywanie argumentu przez odwołanie, ale wywołana metoda nie modyfikuje wartości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-185">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="3a84c-186">Ten dodatek zapewnia pełne słownictwo, aby wyrazić swoje intencje projektowe.</span><span class="sxs-lookup"><span data-stu-id="3a84c-186">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="3a84c-187">Typy wartości są kopiowane po przekazaniu do metody wywoływanej, gdy nie określisz żadnego z następujących modyfikatorów w podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-187">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="3a84c-188">Każdy z tych modyfikatorów określa, że zmienna jest przekazywana przez odwołanie, unikając kopiowania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-188">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="3a84c-189">Każdy modyfikator wyraża inny zamiar:</span><span class="sxs-lookup"><span data-stu-id="3a84c-189">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="3a84c-190">`out`: Ta metoda ustawia wartość argumentu używanego jako ten parametr.</span><span class="sxs-lookup"><span data-stu-id="3a84c-190">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="3a84c-191">`ref`: Ta metoda może ustawić wartość argumentu użytego jako ten parametr.</span><span class="sxs-lookup"><span data-stu-id="3a84c-191">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="3a84c-192">`in`: Ta metoda nie modyfikuje wartości argumentu użytego jako ten parametr.</span><span class="sxs-lookup"><span data-stu-id="3a84c-192">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="3a84c-193">Dodaj `in` modyfikator, aby przekazać argument przez odwołanie i zadeklarować zamiar projektu przekazać argumenty przez odwołanie, aby uniknąć niepotrzebnego kopiowania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-193">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="3a84c-194">Nie zamierzasz modyfikować obiektu używanego jako ten argument.</span><span class="sxs-lookup"><span data-stu-id="3a84c-194">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="3a84c-195">Praktyka ta często poprawia wydajność dla typów wartości <xref:System.IntPtr.Size?displayProperty=nameWithType>odczytu, które są większe niż .</span><span class="sxs-lookup"><span data-stu-id="3a84c-195">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a84c-196">W przypadku`sbyte`typów `byte` `short`prostych `ushort` `int`( `uint` `long`, `ulong` `char`, `float` `double`, `decimal` `bool`, `enum` , , , , , , i , i , i typy), wszelkie potencjalne przyrosty wydajności są minimalne.</span><span class="sxs-lookup"><span data-stu-id="3a84c-196">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="3a84c-197">W rzeczywistości wydajność może ulec pogorszeniu przy użyciu funkcji <xref:System.IntPtr.Size?displayProperty=nameWithType>pass-by-reference dla typów mniejszych niż .</span><span class="sxs-lookup"><span data-stu-id="3a84c-197">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="3a84c-198">Poniższy kod przedstawia przykład metody, która oblicza odległość między dwoma punktami w przestrzeni 3D.</span><span class="sxs-lookup"><span data-stu-id="3a84c-198">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="3a84c-199">Argumenty są dwie struktury, które zawierają trzy podwaja.</span><span class="sxs-lookup"><span data-stu-id="3a84c-199">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="3a84c-200">Double jest 8 bajtów, więc każdy argument jest 24 bajtów.</span><span class="sxs-lookup"><span data-stu-id="3a84c-200">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="3a84c-201">Określając `in` modyfikator, należy przekazać 4-bajtowe lub 8-bajtowe odwołanie do tych argumentów, w zależności od architektury maszyny.</span><span class="sxs-lookup"><span data-stu-id="3a84c-201">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="3a84c-202">Różnica w rozmiarze jest mała, ale sumuje się, gdy aplikacja wywołuje tę metodę w wąskiej pętli przy użyciu wielu różnych wartości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-202">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="3a84c-203">Modyfikator `in` `out` uzupełnia `ref` i w inny sposób, jak również.</span><span class="sxs-lookup"><span data-stu-id="3a84c-203">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="3a84c-204">Nie można utworzyć przeciążenia metody, które różnią się `in` `out`tylko `ref`w obecności , lub .</span><span class="sxs-lookup"><span data-stu-id="3a84c-204">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="3a84c-205">Te nowe reguły rozszerzają to `out` samo `ref` zachowanie, które zawsze było zdefiniowane dla i parametry.</span><span class="sxs-lookup"><span data-stu-id="3a84c-205">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="3a84c-206">Podobnie `out` jak `ref` modyfikatory i typy wartości `in` nie są zapakowane, ponieważ modyfikator jest stosowany.</span><span class="sxs-lookup"><span data-stu-id="3a84c-206">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="3a84c-207">Modyfikator `in` może być stosowany do dowolnego elementu członkowskiego, który przyjmuje parametry: metody, delegatów, lambdas, funkcje lokalne, indeksatory, operatory.</span><span class="sxs-lookup"><span data-stu-id="3a84c-207">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="3a84c-208">Inną cechą parametrów `in` jest użycie wartości literału lub `in` stałych dla argumentu do parametru.</span><span class="sxs-lookup"><span data-stu-id="3a84c-208">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="3a84c-209">Ponadto, w `ref` `out` przeciwieństwie do lub parametru, `in` nie trzeba stosować modyfikator w witrynie wywołania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-209">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="3a84c-210">Poniższy kod pokazuje dwa przykłady `CalculateDistance` wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-210">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="3a84c-211">Pierwszy używa dwóch zmiennych lokalnych przekazanych przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-211">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="3a84c-212">Drugi zawiera zmienną tymczasową utworzoną jako część wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-212">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="3a84c-213">Istnieje kilka sposobów, w którym kompilator wymusza `in` charakter tylko do odczytu argumentu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-213">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="3a84c-214">Przede wszystkim wywołana metoda nie może bezpośrednio `in` przypisać do parametru.</span><span class="sxs-lookup"><span data-stu-id="3a84c-214">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="3a84c-215">Nie można bezpośrednio przypisać do żadnego `in` pola parametru, `struct` gdy ta wartość jest typem.</span><span class="sxs-lookup"><span data-stu-id="3a84c-215">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="3a84c-216">Ponadto nie można przekazać parametr `in` do żadnej metody `ref` `out` przy użyciu lub modyfikatora.</span><span class="sxs-lookup"><span data-stu-id="3a84c-216">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="3a84c-217">Reguły te mają zastosowanie `in` do dowolnego pola `struct` parametru, pod warunkiem, że pole jest typem, a parametr jest również typem. `struct`</span><span class="sxs-lookup"><span data-stu-id="3a84c-217">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="3a84c-218">W rzeczywistości te reguły mają zastosowanie do wielu warstw dostępu do `structs`elementów członkowskich, pod warunkiem, że typy na wszystkich poziomach dostępu do elementów członkowskich są .</span><span class="sxs-lookup"><span data-stu-id="3a84c-218">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="3a84c-219">Kompilator wymusza, `struct` `in` że typy przekazywane jako argumenty i ich `struct` elementy członkowskie są zmienne tylko do odczytu, gdy są używane jako argumenty do innych metod.</span><span class="sxs-lookup"><span data-stu-id="3a84c-219">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="3a84c-220">Zastosowanie parametrów `in` może uniknąć potencjalnych kosztów wydajności tworzenia kopii.</span><span class="sxs-lookup"><span data-stu-id="3a84c-220">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="3a84c-221">Nie zmienia semantyki żadnych wywołań metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-221">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="3a84c-222">W związku z tym nie trzeba `in` określać modyfikator w witrynie wywołania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-222">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="3a84c-223">Pominięcie modyfikatora `in` w witrynie wywołania informuje kompilator, że jest dozwolone, aby wykonać kopię argumentu z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="3a84c-223">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="3a84c-224">Istnieje konwersja niejawna, ale nie konwersja tożsamości z typu argumentu do typu parametru.</span><span class="sxs-lookup"><span data-stu-id="3a84c-224">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="3a84c-225">Argument jest wyrażeniem, ale nie ma znanej zmiennej magazynu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-225">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="3a84c-226">Istnieje przeciążenie, które różni się obecnością lub brakiem `in`pliku .</span><span class="sxs-lookup"><span data-stu-id="3a84c-226">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="3a84c-227">W takim przypadku przeciążenie według wartości jest lepsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-227">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="3a84c-228">Te reguły są przydatne podczas aktualizowania istniejącego kodu w celu użycia argumentów odwołania tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-228">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="3a84c-229">Wewnątrz metody wywoływane można wywołać dowolną metodę wystąpienia, która używa przez parametry wartości.</span><span class="sxs-lookup"><span data-stu-id="3a84c-229">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="3a84c-230">W tych przypadkach tworzona `in` jest kopia parametru.</span><span class="sxs-lookup"><span data-stu-id="3a84c-230">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="3a84c-231">Ponieważ kompilator może utworzyć zmienną tymczasową dla dowolnego `in` parametru, można również określić wartości domyślne dla dowolnego `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="3a84c-231">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="3a84c-232">Poniższy kod określa początek (punkt 0,0) jako wartość domyślną dla drugiego punktu:</span><span class="sxs-lookup"><span data-stu-id="3a84c-232">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="3a84c-233">Aby wymusić kompilator do przekazywania argumentów `in` tylko do odczytu przez odwołanie, należy określić modyfikator argumentów w witrynie wywołania, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="3a84c-233">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="3a84c-234">To zachowanie ułatwia przyjęcie `in` parametrów w czasie w dużych baz kodu, gdzie wzrost wydajności są możliwe.</span><span class="sxs-lookup"><span data-stu-id="3a84c-234">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="3a84c-235">Najpierw dodajesz `in` modyfikator do podpisów metod.</span><span class="sxs-lookup"><span data-stu-id="3a84c-235">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="3a84c-236">Następnie można dodać `in` modyfikator w witrynach wywołań i utworzyć `readonly struct` typy, aby `in` włączyć kompilator, aby uniknąć tworzenia kopii obronnych parametrów w większej liczbie lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="3a84c-236">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="3a84c-237">Oznaczenie `in` parametru może być również używane z typami odniesienia lub wartościami liczbowymi.</span><span class="sxs-lookup"><span data-stu-id="3a84c-237">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="3a84c-238">Jednak korzyści w obu przypadkach są minimalne, jeśli w ogóle.</span><span class="sxs-lookup"><span data-stu-id="3a84c-238">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="3a84c-239">Unikaj modyfikowalnych struktur `in` jako argumentu</span><span class="sxs-lookup"><span data-stu-id="3a84c-239">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="3a84c-240">Techniki opisane powyżej wyjaśniają, jak uniknąć kopii, zwracając odwołania i przekazując wartości przez odniesienie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-240">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="3a84c-241">Te techniki działają najlepiej, gdy typy argumentów są zadeklarowane jako `readonly struct` typy.</span><span class="sxs-lookup"><span data-stu-id="3a84c-241">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="3a84c-242">W przeciwnym razie kompilator musi utworzyć **kopie obronne** w wielu sytuacjach, aby wymusić readonly-ness żadnych argumentów.</span><span class="sxs-lookup"><span data-stu-id="3a84c-242">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="3a84c-243">Rozważmy następujący przykład, który oblicza odległość punktu 3D od początku układu współrzędnych:</span><span class="sxs-lookup"><span data-stu-id="3a84c-243">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="3a84c-244">Struktura `Point3D` *nie* jest tylko do odczytu struktury.</span><span class="sxs-lookup"><span data-stu-id="3a84c-244">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="3a84c-245">Istnieje sześć różnych wywołań dostępu do właściwości w treści tej metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-245">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="3a84c-246">Przy pierwszym badaniu, można było pomyśleć, że te dostępy były bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="3a84c-246">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="3a84c-247">Po tym `get` wszystkim akcesor nie należy modyfikować stan obiektu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-247">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="3a84c-248">Ale nie ma reguły językowej, która to wymusza.</span><span class="sxs-lookup"><span data-stu-id="3a84c-248">But there's no language rule that enforces that.</span></span> <span data-ttu-id="3a84c-249">To tylko wspólna konwencja.</span><span class="sxs-lookup"><span data-stu-id="3a84c-249">It's only a common convention.</span></span> <span data-ttu-id="3a84c-250">Każdy typ można `get` zaimplementować akcesor, który zmodyfikował stan wewnętrzny.</span><span class="sxs-lookup"><span data-stu-id="3a84c-250">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="3a84c-251">Bez gwarancji niektórych języków kompilator musi utworzyć tymczasową kopię argumentu `readonly` przed wywołaniem dowolnego elementu członkowskiego nie oznaczone modyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="3a84c-251">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="3a84c-252">Magazyn tymczasowy jest tworzony na stosie, wartości argumentu są kopiowane do magazynu tymczasowego, a wartość jest `this` kopiowana do stosu dla każdego elementu członkowskiego jako argument.</span><span class="sxs-lookup"><span data-stu-id="3a84c-252">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="3a84c-253">W wielu sytuacjach te kopie szkodzą wydajności na tyle, że przekazywanie przez wartość jest szybsze niż `readonly struct` przekazywanie przez odczyt tylko odwołanie, gdy typ argumentu nie jest a, a metoda wywołuje członków, które nie są oznaczone. `readonly`</span><span class="sxs-lookup"><span data-stu-id="3a84c-253">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="3a84c-254">Jeśli zaznaczysz wszystkie metody, które nie `readonly`modyfikują stanu struktury jako , kompilator może bezpiecznie określić, że stan struktury nie jest modyfikowany, a kopia obronna nie jest potrzebna.</span><span class="sxs-lookup"><span data-stu-id="3a84c-254">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="3a84c-255">Zamiast tego, jeśli obliczanie odległości używa niezmiennej `ReadonlyPoint3D`struktury, obiekty tymczasowe nie są potrzebne:</span><span class="sxs-lookup"><span data-stu-id="3a84c-255">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="3a84c-256">Kompilator generuje bardziej wydajny kod podczas `readonly struct`wywoływania członków : Odwołanie, `this` zamiast kopii odbiornika, jest zawsze parametrem przekazywanym `in` przez odwołanie do metody elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="3a84c-256">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="3a84c-257">Ta optymalizacja zapisuje kopiowanie, gdy używasz `readonly struct` jako argumentu. `in`</span><span class="sxs-lookup"><span data-stu-id="3a84c-257">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="3a84c-258">Nie należy przekazywać typu wartości nullable jako `in` argument.</span><span class="sxs-lookup"><span data-stu-id="3a84c-258">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="3a84c-259">Typ <xref:System.Nullable%601> nie jest zadeklarowany jako struktura tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-259">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="3a84c-260">Oznacza to, że kompilator musi generować kopie obronne dla dowolnego `in` nullable argument typu wartości przekazywane do metody przy użyciu modyfikatora w deklaracji parametru.</span><span class="sxs-lookup"><span data-stu-id="3a84c-260">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="3a84c-261">Możesz zobaczyć przykładowy program, który pokazuje różnice w wydajności przy użyciu [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) w naszym [repozytorium przykładów](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) w usłudze GitHub.</span><span class="sxs-lookup"><span data-stu-id="3a84c-261">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="3a84c-262">Porównuje przekazywanie modyfikowalne struktury przez wartość i przez odwołanie z przekazywania niezmienne struktury przez wartość i przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-262">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="3a84c-263">Użycie niezmiennej struktury i przekazywania przez odwołanie jest najszybsze.</span><span class="sxs-lookup"><span data-stu-id="3a84c-263">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="3a84c-264">Używanie `ref struct` typów do pracy z blokami lub pamięcią na jednej ramce stosu</span><span class="sxs-lookup"><span data-stu-id="3a84c-264">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="3a84c-265">Powiązana funkcja języka jest możliwość deklarowania typu wartości, które muszą być ograniczone do pojedynczej ramki stosu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-265">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="3a84c-266">To ograniczenie umożliwia kompilatorowi dokonać kilku optymalizacji.</span><span class="sxs-lookup"><span data-stu-id="3a84c-266">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="3a84c-267">Główną motywacją dla <xref:System.Span%601> tej funkcji były i powiązane struktury.</span><span class="sxs-lookup"><span data-stu-id="3a84c-267">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="3a84c-268">Ulepszenia wydajności można uzyskać za pomocą nowych i zaktualizowanych interfejsów API platformy <xref:System.Span%601> .NET, które korzystają z tego typu.</span><span class="sxs-lookup"><span data-stu-id="3a84c-268">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="3a84c-269">Mogą mieć podobne wymagania pracy z [`stackalloc`](language-reference/operators/stackalloc.md) pamięcią utworzoną przy użyciu lub podczas korzystania z pamięci z interfejsów API międzyop.</span><span class="sxs-lookup"><span data-stu-id="3a84c-269">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="3a84c-270">Można zdefiniować `ref struct` własne typy dla tych potrzeb.</span><span class="sxs-lookup"><span data-stu-id="3a84c-270">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="3a84c-271">`readonly ref struct`Typu</span><span class="sxs-lookup"><span data-stu-id="3a84c-271">`readonly ref struct` type</span></span>

<span data-ttu-id="3a84c-272">Deklarowanie struktury jako `readonly ref` łączy korzyści i ograniczenia `ref struct` `readonly struct` i deklaracje.</span><span class="sxs-lookup"><span data-stu-id="3a84c-272">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="3a84c-273">Pamięć używana przez readonly span jest ograniczona do jednej ramki stosu, a pamięć używana przez readonly span nie może być modyfikowana.</span><span class="sxs-lookup"><span data-stu-id="3a84c-273">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="3a84c-274">Wnioski</span><span class="sxs-lookup"><span data-stu-id="3a84c-274">Conclusions</span></span>

<span data-ttu-id="3a84c-275">Za pomocą typów wartości minimalizuje liczbę operacji alokacji:</span><span class="sxs-lookup"><span data-stu-id="3a84c-275">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="3a84c-276">Magazyn dla typów wartości jest stos przydzielony dla zmiennych lokalnych i argumentów metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-276">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="3a84c-277">Magazyn dla typów wartości, które są członkami innych obiektów jest przydzielany jako część tego obiektu, a nie jako oddzielna alokacja.</span><span class="sxs-lookup"><span data-stu-id="3a84c-277">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="3a84c-278">Magazyn dla wartości zwracanej typu wartości jest przydzielany stos.</span><span class="sxs-lookup"><span data-stu-id="3a84c-278">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="3a84c-279">Kontrast, że z typami odwołań w tych samych sytuacjach:</span><span class="sxs-lookup"><span data-stu-id="3a84c-279">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="3a84c-280">Magazyn dla typów odwołań są przydzielane sterty dla zmiennych lokalnych i argumentów metody.</span><span class="sxs-lookup"><span data-stu-id="3a84c-280">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="3a84c-281">Odwołanie jest przechowywane na stosie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-281">The reference is stored on the stack.</span></span>
- <span data-ttu-id="3a84c-282">Magazyn dla typów odwołań, które są członkami innych obiektów są oddzielnie przydzielane na stosie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-282">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="3a84c-283">Obiekt zawierający przechowuje odwołanie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-283">The containing object stores the reference.</span></span>
- <span data-ttu-id="3a84c-284">Magazyn dla wartości zwracanej typu referencyjnego jest przydzielany na stercie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-284">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="3a84c-285">Odwołanie do tego magazynu jest przechowywany na stosie.</span><span class="sxs-lookup"><span data-stu-id="3a84c-285">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="3a84c-286">Minimalizowanie alokacji wiąże się z kompromisami.</span><span class="sxs-lookup"><span data-stu-id="3a84c-286">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="3a84c-287">Skopiuj więcej pamięci, gdy rozmiar `struct` jest większy niż rozmiar odwołania.</span><span class="sxs-lookup"><span data-stu-id="3a84c-287">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="3a84c-288">Odwołanie jest zazwyczaj 64 bitów lub 32 bitów i zależy od procesora komputera docelowego.</span><span class="sxs-lookup"><span data-stu-id="3a84c-288">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="3a84c-289">Te kompromisy zazwyczaj mają minimalny wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="3a84c-289">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="3a84c-290">Jednak w przypadku dużych struktur lub większych kolekcji zwiększa się wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="3a84c-290">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="3a84c-291">Wpływ może być duży w ciasnych pętlach i gorących ścieżkach dla programów.</span><span class="sxs-lookup"><span data-stu-id="3a84c-291">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="3a84c-292">Te ulepszenia języka C# są przeznaczone do algorytmów o krytycznym znaczeniu dla wydajności, gdzie minimalizowanie alokacji pamięci jest głównym czynnikiem w osiągnięciu niezbędnej wydajności.</span><span class="sxs-lookup"><span data-stu-id="3a84c-292">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="3a84c-293">Może się okazać, że często nie używasz tych funkcji w kodzie, który piszesz.</span><span class="sxs-lookup"><span data-stu-id="3a84c-293">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="3a84c-294">Jednak te ulepszenia zostały przyjęte w całej .NET.</span><span class="sxs-lookup"><span data-stu-id="3a84c-294">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="3a84c-295">Ponieważ coraz więcej interfejsów API korzysta z tych funkcji, zobaczysz, że wydajność aplikacji zostanie ulepszona.</span><span class="sxs-lookup"><span data-stu-id="3a84c-295">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="3a84c-296">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="3a84c-296">See also</span></span>

- [<span data-ttu-id="3a84c-297">słowo kluczowe ref</span><span class="sxs-lookup"><span data-stu-id="3a84c-297">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="3a84c-298">Wartości zwracane ref i zmienne lokalne ref</span><span class="sxs-lookup"><span data-stu-id="3a84c-298">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
