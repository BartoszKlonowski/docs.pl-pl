---
title: Co nowego w języku C# 9,0 — przewodnik w języku C#
description: Zapoznaj się z omówieniem nowych funkcji dostępnych w języku C# 9,0.
ms.date: 09/04/2020
ms.openlocfilehash: dbc104cb0bbfc965b0cc055429713538f62ed0e8
ms.sourcegitcommit: 34968a61e9bac0f6be23ed6ffb837f52d2390c85
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/17/2020
ms.locfileid: "94687363"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="46433-103">Co nowego w języku C# 9.0</span><span class="sxs-lookup"><span data-stu-id="46433-103">What's new in C# 9.0</span></span>

<span data-ttu-id="46433-104">W języku c# 9,0 dodano następujące funkcje i ulepszenia języka C#:</span><span class="sxs-lookup"><span data-stu-id="46433-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="46433-105">Rekordy</span><span class="sxs-lookup"><span data-stu-id="46433-105">Records</span></span>](#record-types)
- [<span data-ttu-id="46433-106">Metody ustawiające tylko do inicjowania</span><span class="sxs-lookup"><span data-stu-id="46433-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="46433-107">Instrukcje najwyższego poziomu</span><span class="sxs-lookup"><span data-stu-id="46433-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="46433-108">Ulepszenia dopasowania wzorców</span><span class="sxs-lookup"><span data-stu-id="46433-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="46433-109">Liczby całkowite o wielkości natywnej</span><span class="sxs-lookup"><span data-stu-id="46433-109">Native sized integers</span></span>
- <span data-ttu-id="46433-110">Wskaźniki funkcji</span><span class="sxs-lookup"><span data-stu-id="46433-110">Function pointers</span></span>
- <span data-ttu-id="46433-111">Pomiń emitowanie flagi localsinit</span><span class="sxs-lookup"><span data-stu-id="46433-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="46433-112">Nowe wyrażenia z typem docelowym</span><span class="sxs-lookup"><span data-stu-id="46433-112">Target-typed new expressions</span></span>
- <span data-ttu-id="46433-113">statyczne funkcje anonimowe</span><span class="sxs-lookup"><span data-stu-id="46433-113">static anonymous functions</span></span>
- <span data-ttu-id="46433-114">Wyrażenia warunkowe z typem docelowym</span><span class="sxs-lookup"><span data-stu-id="46433-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="46433-115">Kowariantne typy zwracane</span><span class="sxs-lookup"><span data-stu-id="46433-115">Covariant return types</span></span>
- <span data-ttu-id="46433-116">`GetEnumerator`Obsługa rozszerzeń dla `foreach` pętli</span><span class="sxs-lookup"><span data-stu-id="46433-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="46433-117">Parametry odrzucania wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="46433-117">Lambda discard parameters</span></span>
- <span data-ttu-id="46433-118">Atrybuty funkcji lokalnych</span><span class="sxs-lookup"><span data-stu-id="46433-118">Attributes on local functions</span></span>
- <span data-ttu-id="46433-119">Inicjatory modułów</span><span class="sxs-lookup"><span data-stu-id="46433-119">Module initializers</span></span>
- <span data-ttu-id="46433-120">Nowe funkcje dla metod częściowych</span><span class="sxs-lookup"><span data-stu-id="46433-120">New features for partial methods</span></span>

<span data-ttu-id="46433-121">Język C# 9,0 jest obsługiwany w **programie .NET 5**.</span><span class="sxs-lookup"><span data-stu-id="46433-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="46433-122">Aby uzyskać więcej informacji, zobacz [wersja języka C#](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="46433-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="46433-123">Najnowszą wersję zestawu SDK platformy .NET można pobrać ze [strony plików do pobrania platformy .NET](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="46433-123">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="46433-124">Typy rekordów</span><span class="sxs-lookup"><span data-stu-id="46433-124">Record types</span></span>

<span data-ttu-id="46433-125">W języku C# 9,0 wprowadzono \**_typy rekordów_* _, które są typu referencyjnego, który dostarcza metody, które umożliwiają syntezę wartości dla równości.</span><span class="sxs-lookup"><span data-stu-id="46433-125">C# 9.0 introduces \**_record types_* _, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="46433-126">Rekordy są domyślnie niezmienne.</span><span class="sxs-lookup"><span data-stu-id="46433-126">Records are immutable by default.</span></span>

<span data-ttu-id="46433-127">Typy rekordów ułatwiają tworzenie niemodyfikowalnych typów referencyjnych w programie .NET.</span><span class="sxs-lookup"><span data-stu-id="46433-127">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="46433-128">Historycznie typy .NET są w znacznym stopniu klasyfikowane jako typy referencyjne (w tym klasy i typy anonimowe) i typy wartości (w tym struktury i krotki).</span><span class="sxs-lookup"><span data-stu-id="46433-128">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="46433-129">Chociaż zaleca się niezmienne typy wartości, modyfikowalne typy wartości nie często wprowadzają błędy.</span><span class="sxs-lookup"><span data-stu-id="46433-129">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="46433-130">Zmienne typu wartości przechowują wartości, więc zmiany są wprowadzane do kopii oryginalnych danych, gdy typy wartości są przekazywane do metod.</span><span class="sxs-lookup"><span data-stu-id="46433-130">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="46433-131">Istnieje wiele zalet, aby również niezmienne typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="46433-131">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="46433-132">Te zalety są bardziej wymawiane w współbieżnych programach z udostępnionymi danymi.</span><span class="sxs-lookup"><span data-stu-id="46433-132">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="46433-133">Niestety, w języku C# wymuszono napisanie całkiem dowolnego dodatkowego kodu w celu utworzenia niemodyfikowalnych typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="46433-133">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="46433-134">Rekordy zapewniają deklarację typu dla niezmiennego typu referencyjnego, który używa semantyki wartości dla równości.</span><span class="sxs-lookup"><span data-stu-id="46433-134">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="46433-135">W metodach syntezy dla kodów równości i wyznaczania wartości skrótu należy wziąć pod uwagę dwa rekordy równe, jeśli ich właściwości są równe.</span><span class="sxs-lookup"><span data-stu-id="46433-135">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="46433-136">Należy wziąć pod uwagę tę definicję:</span><span class="sxs-lookup"><span data-stu-id="46433-136">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="46433-137">Definicja rekordu tworzy `Person` Typ, który zawiera dwie właściwości ReadOnly: `FirstName` i `LastName` .</span><span class="sxs-lookup"><span data-stu-id="46433-137">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="46433-138">`Person`Typ jest typem referencyjnym.</span><span class="sxs-lookup"><span data-stu-id="46433-138">The `Person` type is a reference type.</span></span> <span data-ttu-id="46433-139">Jeśli szukasz języka IL, jest on klasą.</span><span class="sxs-lookup"><span data-stu-id="46433-139">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="46433-140">Jest to niezmienne w przypadku, gdy żadna z właściwości nie może być modyfikowana po utworzeniu.</span><span class="sxs-lookup"><span data-stu-id="46433-140">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="46433-141">W przypadku zdefiniowania typu rekordu, kompilator umożliwia wyszukanie kilku innych metod:</span><span class="sxs-lookup"><span data-stu-id="46433-141">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="46433-142">Metody porównania równości opartej na wartościach</span><span class="sxs-lookup"><span data-stu-id="46433-142">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="46433-143">Przesłoń dla <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="46433-143">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="46433-144">Kopiowanie i klonowanie elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="46433-144">Copy and Clone members</span></span>
- <span data-ttu-id="46433-145">`PrintMembers` i <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="46433-145">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="46433-146">Rekordy obsługują dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="46433-146">Records support inheritance.</span></span> <span data-ttu-id="46433-147">Można zadeklarować nowy rekord pochodzący z `Person` następujących metod:</span><span class="sxs-lookup"><span data-stu-id="46433-147">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="46433-148">Możesz również zapieczętować rekordy, aby zapobiec dalszemu występowaniu:</span><span class="sxs-lookup"><span data-stu-id="46433-148">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="46433-149">Kompilator syntezuje różne wersje powyższych metod.</span><span class="sxs-lookup"><span data-stu-id="46433-149">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="46433-150">Sygnatury metod są zależne od tego, czy typ rekordu jest zapieczętowany i czy bezpośrednia klasa bazowa to obiekt.</span><span class="sxs-lookup"><span data-stu-id="46433-150">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="46433-151">Rekordy powinny mieć następujące możliwości:</span><span class="sxs-lookup"><span data-stu-id="46433-151">Records should have the following capabilities:</span></span>

- <span data-ttu-id="46433-152">Równość jest oparta na wartości i zawiera sprawdzenie, czy typy pasują do siebie.</span><span class="sxs-lookup"><span data-stu-id="46433-152">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="46433-153">Na przykład wartość `Student` nie może być równa `Person` , nawet jeśli dwa rekordy mają tę samą nazwę.</span><span class="sxs-lookup"><span data-stu-id="46433-153">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="46433-154">Rekordy mają wygenerowaną spójną reprezentację ciągu.</span><span class="sxs-lookup"><span data-stu-id="46433-154">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="46433-155">Rekordy obsługują konstrukcję kopiowania.</span><span class="sxs-lookup"><span data-stu-id="46433-155">Records support copy construction.</span></span> <span data-ttu-id="46433-156">Poprawna konstrukcja kopii musi zawierać hierarchie dziedziczenia i właściwości dodawane przez deweloperów.</span><span class="sxs-lookup"><span data-stu-id="46433-156">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="46433-157">Rekordy można kopiować z modyfikacją.</span><span class="sxs-lookup"><span data-stu-id="46433-157">Records can be copied with modification.</span></span> <span data-ttu-id="46433-158">Te operacje kopiowania i modyfikowania obsługują mutację nieniszczącą.</span><span class="sxs-lookup"><span data-stu-id="46433-158">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="46433-159">Oprócz znanych `Equals` przeciążeń, i kompilator umożliwia wypróbowanie `operator ==` `operator !=` nowej `EqualityContract` właściwości.</span><span class="sxs-lookup"><span data-stu-id="46433-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="46433-160">Właściwość zwraca `Type` obiekt, który jest zgodny z typem rekordu.</span><span class="sxs-lookup"><span data-stu-id="46433-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="46433-161">Jeśli typem podstawowym jest `object` , właściwość jest `virtual` .</span><span class="sxs-lookup"><span data-stu-id="46433-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="46433-162">Jeśli typ podstawowy jest innym typem rekordu, właściwość jest `override` .</span><span class="sxs-lookup"><span data-stu-id="46433-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="46433-163">Jeśli typem rekordu jest `sealed` , właściwość jest `sealed` .</span><span class="sxs-lookup"><span data-stu-id="46433-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="46433-164">W syntezie są `GetHashCode` stosowane `GetHashCode` wszystkie właściwości i pola zadeklarowane w typie podstawowym oraz typ rekordu.</span><span class="sxs-lookup"><span data-stu-id="46433-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="46433-165">Te metody, które zostały opisane w tej metodzie, wymuszają równość opartych na wartościach w hierarchii dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="46433-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="46433-166">Oznacza to, że `Student` nigdy nie będzie traktowane jako równe a `Person` o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="46433-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="46433-167">Typy dwóch rekordów muszą być zgodne oraz wszystkie właściwości, które są współużytkowane przez typy rekordów równe.</span><span class="sxs-lookup"><span data-stu-id="46433-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="46433-168">Rekordy mają również konstruktory z syntezą i metodę "Clone" służącą do tworzenia kopii.</span><span class="sxs-lookup"><span data-stu-id="46433-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="46433-169">Konstruktor z syntezą ma jeden parametr typu rekordu.</span><span class="sxs-lookup"><span data-stu-id="46433-169">The synthesized constructor has a single parameter of the record type.</span></span> <span data-ttu-id="46433-170">Tworzy nowy rekord z tymi samymi wartościami dla wszystkich właściwości rekordu.</span><span class="sxs-lookup"><span data-stu-id="46433-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="46433-171">Ten konstruktor jest prywatny, jeśli rekord jest zapieczętowany, w przeciwnym razie jest chroniony.</span><span class="sxs-lookup"><span data-stu-id="46433-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="46433-172">Synteza "klonowanie" obsługuje konstrukcję kopiowania dla hierarchii rekordów.</span><span class="sxs-lookup"><span data-stu-id="46433-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="46433-173">Termin "klon" jest w cudzysłowie, ponieważ rzeczywista nazwa jest generowana przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="46433-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="46433-174">Nie można utworzyć metody o nazwie `Clone` w typie rekordu.</span><span class="sxs-lookup"><span data-stu-id="46433-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="46433-175">Synteza "klon" zwraca typ rekordu, który jest kopiowany przy użyciu wysyłki wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="46433-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="46433-176">Kompilator dodaje różne Modyfikatory dla metody "Clone" w zależności od modyfikatorów dostępu w `record` :</span><span class="sxs-lookup"><span data-stu-id="46433-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="46433-177">Jeśli typem rekordu jest `abstract` , Metoda "klonowanie" jest również `abstract` .</span><span class="sxs-lookup"><span data-stu-id="46433-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="46433-178">Jeśli typ podstawowy nie jest `object` , metoda jest również `override` .</span><span class="sxs-lookup"><span data-stu-id="46433-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="46433-179">Dla typów rekordów, które nie są, `abstract` gdy typem podstawowym jest `object` :</span><span class="sxs-lookup"><span data-stu-id="46433-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="46433-180">Jeśli rekord ma wartość `sealed` , żadne dodatkowe Modyfikatory nie są dodawane do metody "klonowania" (oznacza to, że nie jest `virtual` ).</span><span class="sxs-lookup"><span data-stu-id="46433-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="46433-181">Jeśli rekord nie jest `sealed` , Metoda "Clone" ma wartość `virtual` .</span><span class="sxs-lookup"><span data-stu-id="46433-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="46433-182">Dla typów rekordów, które nie są, `abstract` gdy typ podstawowy nie jest `object` :</span><span class="sxs-lookup"><span data-stu-id="46433-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="46433-183">Jeśli rekordem jest `sealed` , Metoda "klonowanie" jest również `sealed` .</span><span class="sxs-lookup"><span data-stu-id="46433-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="46433-184">Jeśli rekord nie jest `sealed` , Metoda "Clone" ma wartość `override` .</span><span class="sxs-lookup"><span data-stu-id="46433-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="46433-185">Wynik wszystkich tych reguł jest implementowany spójnie dla każdej hierarchii typów rekordów.</span><span class="sxs-lookup"><span data-stu-id="46433-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="46433-186">Dwa rekordy są równe siebie, jeśli ich właściwości są równe, a ich typy są takie same, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="46433-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="46433-187">Kompilator syntezuje dwie metody, które obsługują wydruk wyjściowy: <xref:System.Object.ToString> przesłonięcie i `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="46433-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="46433-188">`PrintMembers`Przyjmuje <xref:System.Text.StringBuilder?displayProperty=nameWithType> jako argument.</span><span class="sxs-lookup"><span data-stu-id="46433-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="46433-189">Dodaje rozdzieloną przecinkami listę nazw właściwości i wartości dla wszystkich właściwości w typie rekordu.</span><span class="sxs-lookup"><span data-stu-id="46433-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="46433-190">`PrintMembers` wywołuje podstawową implementację wszystkich rekordów pochodzących z innych rekordów.</span><span class="sxs-lookup"><span data-stu-id="46433-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="46433-191"><xref:System.Object.ToString>Zastąpienie zwraca ciąg utworzony przez `PrintMembers` , ujęty w `{` i `}` .</span><span class="sxs-lookup"><span data-stu-id="46433-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="46433-192">Na przykład <xref:System.Object.ToString> Metoda `Student` zwraca `string` podobne do poniższego kodu:</span><span class="sxs-lookup"><span data-stu-id="46433-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="46433-193">Przykłady pokazane do użycia tradycyjną składnią do deklarowania właściwości.</span><span class="sxs-lookup"><span data-stu-id="46433-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="46433-194">Istnieje bardziej zwięzła forma o nazwie _*_rekordy pozycyjne_*_.</span><span class="sxs-lookup"><span data-stu-id="46433-194">There's a more concise form called _*_positional records_*_.</span></span>  <span data-ttu-id="46433-195">Oto trzy typy rekordów zdefiniowane wcześniej jako rekordy pozycyjne:</span><span class="sxs-lookup"><span data-stu-id="46433-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="46433-196">Te deklaracje tworzą takie same funkcje jak wcześniejsza wersja (z kilkoma dodatkowymi funkcjami wymienionymi w poniższej sekcji).</span><span class="sxs-lookup"><span data-stu-id="46433-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="46433-197">Te deklaracje kończą się średnikiem zamiast nawiasów, ponieważ te rekordy nie dodają dodatkowych metod.</span><span class="sxs-lookup"><span data-stu-id="46433-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="46433-198">Możesz również dodać treść i dołączyć wszelkie dodatkowe metody:</span><span class="sxs-lookup"><span data-stu-id="46433-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="46433-199">Kompilator tworzy `Deconstruct` metodę dla rekordów pozycyjnych.</span><span class="sxs-lookup"><span data-stu-id="46433-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="46433-200">`Deconstruct`Metoda ma parametry, które pasują do nazw wszystkich właściwości publicznych w typie rekordu.</span><span class="sxs-lookup"><span data-stu-id="46433-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="46433-201">`Deconstruct`Metoda może służyć do dekonstruowania rekordu we właściwościach składnika:</span><span class="sxs-lookup"><span data-stu-id="46433-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="46433-202">Wreszcie rejestruje [ `with` wyrażenia](../language-reference/operators/with-expression.md)obsługi.</span><span class="sxs-lookup"><span data-stu-id="46433-202">Finally, records support [`with` expressions](../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="46433-203">_\*_ `with` Expression_ *_ instruuje kompilator, aby utworzył kopię rekordu, ale _with* określone właściwości zmodyfikowano:</span><span class="sxs-lookup"><span data-stu-id="46433-203">A _\*_`with` expression_ *_ instructs the compiler to create a copy of a record, but _with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="46433-204">Poprzedni wiersz tworzy nowy `Person` rekord, w którym `LastName` Właściwość jest kopią `person` , a `FirstName` ma wartość `"Paul"` .</span><span class="sxs-lookup"><span data-stu-id="46433-204">The previous line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is `"Paul"`.</span></span> <span data-ttu-id="46433-205">W wyrażeniu można ustawić dowolną liczbę właściwości `with` .</span><span class="sxs-lookup"><span data-stu-id="46433-205">You can set any number of properties in a `with` expression.</span></span> <span data-ttu-id="46433-206">Możesz również użyć `with` wyrażeń, aby utworzyć dokładną kopię.</span><span class="sxs-lookup"><span data-stu-id="46433-206">You can also use `with` expressions to create an exact copy.</span></span> <span data-ttu-id="46433-207">Należy określić pusty zestaw właściwości do zmodyfikowania:</span><span class="sxs-lookup"><span data-stu-id="46433-207">You specify the empty set for the properties to modify:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="WithCopy":::

<span data-ttu-id="46433-208">Każdy z tych elementów członkowskich, z wyjątkiem metody "Clone", może zostać przez Ciebie zapisany.</span><span class="sxs-lookup"><span data-stu-id="46433-208">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="46433-209">Jeśli typ rekordu ma metodę, która pasuje do sygnatury dowolnej metody, kompilator nie wykonuje syntezy tej metody.</span><span class="sxs-lookup"><span data-stu-id="46433-209">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="46433-210">W przykładzie wcześniejszego `Dog` rekordu znajduje się <xref:System.String.ToString> Przykładowa Metoda ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="46433-210">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

<span data-ttu-id="46433-211">Dowiedz się więcej na temat typów rekordów w tym samouczku [eksploracji rekordów](../tutorials/exploration/records.md) .</span><span class="sxs-lookup"><span data-stu-id="46433-211">Learn more about record types in this [exploration of records](../tutorials/exploration/records.md) tutorial.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="46433-212">Metody ustawiające tylko do inicjowania</span><span class="sxs-lookup"><span data-stu-id="46433-212">Init only setters</span></span>

<span data-ttu-id="46433-213">\***Tylko metody init** _ mają spójną składnię, aby inicjować elementy członkowskie obiektu.</span><span class="sxs-lookup"><span data-stu-id="46433-213">\***Init only setters** _ provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="46433-214">Inicjatory właściwości sprawiają, że wartość jest ustawiana dla właściwości.</span><span class="sxs-lookup"><span data-stu-id="46433-214">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="46433-215">Minusemem jest to, że te właściwości muszą mieć wartość settable.</span><span class="sxs-lookup"><span data-stu-id="46433-215">The downside is that those properties must be settable.</span></span> <span data-ttu-id="46433-216">Począwszy od języka C# 9,0, można tworzyć metody `init` dostępu zamiast `set` metod dostępu do właściwości i indeksatorów.</span><span class="sxs-lookup"><span data-stu-id="46433-216">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="46433-217">Obiekty wywołujące mogą używać składni inicjatora właściwości do ustawiania tych wartości w wyrażeniach tworzenia, ale te właściwości są tylko do odczytu, gdy konstrukcja została ukończona.</span><span class="sxs-lookup"><span data-stu-id="46433-217">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="46433-218">Tylko metody init umożliwiają zmianę stanu okna.</span><span class="sxs-lookup"><span data-stu-id="46433-218">Init only setters provide a window to change state.</span></span> <span data-ttu-id="46433-219">To okno zostanie zamknięte po zakończeniu fazy budowania.</span><span class="sxs-lookup"><span data-stu-id="46433-219">That window closes when the construction phase ends.</span></span> <span data-ttu-id="46433-220">Faza konstruowania skutecznie kończy działanie po wszystkich inicjalizacjach, w tym inicjatorach właściwości i wyrażeniach z.</span><span class="sxs-lookup"><span data-stu-id="46433-220">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="46433-221">Można zadeklarować `init` tylko metody ustawiające w dowolnym typie, który napiszesz.</span><span class="sxs-lookup"><span data-stu-id="46433-221">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="46433-222">Na przykład następująca struktura definiuje strukturę obserwacji pogody:</span><span class="sxs-lookup"><span data-stu-id="46433-222">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="46433-223">Obiekty wywołujące mogą używać składni inicjatora właściwości do ustawiania wartości, pozostawiając zachowanie niezmienności:</span><span class="sxs-lookup"><span data-stu-id="46433-223">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="46433-224">Jednak zmiana obserwacji po inicjacji jest błędem przez przypisanie do właściwości "init-Only" poza inicjalizacją:</span><span class="sxs-lookup"><span data-stu-id="46433-224">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="46433-225">Tylko metody init mogą być przydatne do ustawiania właściwości klasy bazowej z klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="46433-225">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="46433-226">Mogą także ustawiać właściwości pochodne za pomocą pomocników w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="46433-226">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="46433-227">Rekordy pozycyjne deklarują właściwości przy użyciu tylko metod init.</span><span class="sxs-lookup"><span data-stu-id="46433-227">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="46433-228">Te metody ustawiające są używane w wyrażeniach with.</span><span class="sxs-lookup"><span data-stu-id="46433-228">Those setters are used in with-expressions.</span></span> <span data-ttu-id="46433-229">Można zadeklarować tylko metody init dla dowolnego `class` lub `struct` zdefiniowanego elementu.</span><span class="sxs-lookup"><span data-stu-id="46433-229">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="46433-230">Instrukcje najwyższego poziomu</span><span class="sxs-lookup"><span data-stu-id="46433-230">Top-level statements</span></span>

<span data-ttu-id="46433-231">_*_Instrukcje najwyższego poziomu_*_ usuwają niepotrzebne procedury z wielu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="46433-231">_*_Top-level statements_*_ remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="46433-232">Rozważmy kanoniczną "Hello world!"</span><span class="sxs-lookup"><span data-stu-id="46433-232">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="46433-233">Program</span><span class="sxs-lookup"><span data-stu-id="46433-233">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="46433-234">Istnieje tylko jeden wiersz kodu, który robi wszystko.</span><span class="sxs-lookup"><span data-stu-id="46433-234">There’s only one line of code that does anything.</span></span> <span data-ttu-id="46433-235">Przy użyciu instrukcji najwyższego poziomu można zastąpić wszystkie te, które są standardową `using` instrukcją i pojedynczy wiersz, który wykonuje prace:</span><span class="sxs-lookup"><span data-stu-id="46433-235">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="46433-236">Jeśli chciałeś zastosować program jednowierszowy, możesz usunąć `using` dyrektywę i użyć w pełni kwalifikowanej nazwy typu:</span><span class="sxs-lookup"><span data-stu-id="46433-236">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="46433-237">Tylko jeden plik w aplikacji może używać instrukcji najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="46433-237">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="46433-238">Jeśli kompilator odnajdzie instrukcje najwyższego poziomu w wielu plikach źródłowych, jest to błąd.</span><span class="sxs-lookup"><span data-stu-id="46433-238">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="46433-239">Jest również błędem, jeśli łączysz instrukcje najwyższego poziomu z zadeklarowaną metodą punktu wejścia programu, zwykle `Main` metodę.</span><span class="sxs-lookup"><span data-stu-id="46433-239">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="46433-240">W tym sensie można wziąć pod uwagę, że jeden plik zawiera instrukcje, które zwykle są w `Main` metodzie `Program` klasy.</span><span class="sxs-lookup"><span data-stu-id="46433-240">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="46433-241">Jednym z najpopularniejszych zastosowania tej funkcji jest tworzenie materiałów edukacyjnych.</span><span class="sxs-lookup"><span data-stu-id="46433-241">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="46433-242">Początkująci deweloperzy języka C# mogą pisać kanoniczny "Hello world!"</span><span class="sxs-lookup"><span data-stu-id="46433-242">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="46433-243">w jednym lub dwóch wierszach kodu.</span><span class="sxs-lookup"><span data-stu-id="46433-243">in one or two lines of code.</span></span> <span data-ttu-id="46433-244">Żadna z dodatkowych procedury nie jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="46433-244">None of the extra ceremony is needed.</span></span> <span data-ttu-id="46433-245">Niemniej deweloperzy mogą również znaleźć wiele użycia tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="46433-245">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="46433-246">W instrukcjach najwyższego poziomu można korzystać ze środowiska podobnego do skryptu na potrzeby eksperymentowania podobnego do tego, co zapewnia notesy Jupyter.</span><span class="sxs-lookup"><span data-stu-id="46433-246">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="46433-247">Instrukcje najwyższego poziomu są doskonałe dla małych programów konsolowych i narzędzi.</span><span class="sxs-lookup"><span data-stu-id="46433-247">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="46433-248">Azure Functions są idealnym przypadkiem użycia dla instrukcji najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="46433-248">Azure Functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="46433-249">Co najważniejsze, instrukcje najwyższego poziomu nie ograniczają zakresu lub złożoności aplikacji.</span><span class="sxs-lookup"><span data-stu-id="46433-249">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="46433-250">Te instrukcje mogą uzyskać dostęp do dowolnej klasy .NET lub korzystać z niej.</span><span class="sxs-lookup"><span data-stu-id="46433-250">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="46433-251">Nie ograniczają one również użycia argumentów wiersza polecenia ani zwracanych wartości.</span><span class="sxs-lookup"><span data-stu-id="46433-251">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="46433-252">Instrukcje najwyższego poziomu mogą uzyskać dostęp do tablicy ciągów o nazwach argumentów.</span><span class="sxs-lookup"><span data-stu-id="46433-252">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="46433-253">Jeśli instrukcje najwyższego poziomu zwracają wartość całkowitą, ta wartość zostanie zwróconym kodem zwrotnym z metody z syntezą `Main` .</span><span class="sxs-lookup"><span data-stu-id="46433-253">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="46433-254">Instrukcje najwyższego poziomu mogą zawierać wyrażenia asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="46433-254">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="46433-255">W takim przypadku syntezny punkt wejścia zwraca `Task` lub `Task<int>` .</span><span class="sxs-lookup"><span data-stu-id="46433-255">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="46433-256">Ulepszenia dopasowania wzorców</span><span class="sxs-lookup"><span data-stu-id="46433-256">Pattern matching enhancements</span></span>

<span data-ttu-id="46433-257">W języku C# 9 wprowadzono nowe ulepszenia dopasowania do wzorca:</span><span class="sxs-lookup"><span data-stu-id="46433-257">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="46433-258">_*_Wzorce typu_*_ zgodne ze zmienną jest typem</span><span class="sxs-lookup"><span data-stu-id="46433-258">_*_Type patterns_*_ match a variable is a type</span></span>
- <span data-ttu-id="46433-259">_*_Wzorce w nawiasach_*_ wymuszają lub podkreślają pierwszeństwo kombinacji wzorców</span><span class="sxs-lookup"><span data-stu-id="46433-259">_*_Parenthesized patterns_*_ enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="46433-260">_\*_`and` Wzorce conjunctive_\*_ wymagają dopasowania obu wzorców</span><span class="sxs-lookup"><span data-stu-id="46433-260">_*_Conjunctive `and` patterns_*_ require both patterns to match</span></span>
- <span data-ttu-id="46433-261">_\*_`or` Wzorce disjunctive_\*_ wymagają dopasowania do wzorca</span><span class="sxs-lookup"><span data-stu-id="46433-261">_*_Disjunctive `or` patterns_*_ require either pattern to match</span></span>
- <span data-ttu-id="46433-262">_\*_`not` Wzorce negacji_\*_ wymagają, aby wzorzec nie był zgodny</span><span class="sxs-lookup"><span data-stu-id="46433-262">_*_Negated `not` patterns_*_ require that a pattern doesn’t match</span></span>
- <span data-ttu-id="46433-263">_*_Wzorce relacyjne_*_ wymagają, aby dane wejściowe były mniejsze niż, większe niż lub równe lub większe niż lub równe danej stałej.</span><span class="sxs-lookup"><span data-stu-id="46433-263">_*_Relational patterns_*_ require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="46433-264">Wzorce te wzbogacają składnię wzorców.</span><span class="sxs-lookup"><span data-stu-id="46433-264">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="46433-265">Rozważ następujące przykłady:</span><span class="sxs-lookup"><span data-stu-id="46433-265">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="46433-266">Alternatywnie, z opcjonalnymi nawiasami, aby wyczyścić ten element, który `and` ma wyższy priorytet niż `or` :</span><span class="sxs-lookup"><span data-stu-id="46433-266">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="46433-267">Jednym z najpopularniejszych zastosowania jest nowa składnia dla sprawdzania wartości null:</span><span class="sxs-lookup"><span data-stu-id="46433-267">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="46433-268">Któregokolwiek z tych wzorców można używać w dowolnym kontekście, w którym wzorce są dozwolone: `is` wyrażenia wzorców, `switch` wyrażenia, zagnieżdżone wzorce i wzorzec `switch` `case` etykiety instrukcji.</span><span class="sxs-lookup"><span data-stu-id="46433-268">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="46433-269">Wydajność i międzyoperacyjność</span><span class="sxs-lookup"><span data-stu-id="46433-269">Performance and interop</span></span>

<span data-ttu-id="46433-270">Trzy nowe funkcje ulepszają obsługę natywnych bibliotek międzyoperacyjnych i niskiego poziomu, które wymagają wysokiej wydajności: natywnych liczb całkowitych, wskaźników funkcji i pomijania `localsinit` flagi.</span><span class="sxs-lookup"><span data-stu-id="46433-270">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="46433-271">Liczby całkowite o rozmiarze natywnym `nint` i `nuint` są typami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="46433-271">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="46433-272">Są one wyrażone przez typy podstawowe <xref:System.IntPtr?displayProperty=nameWithType> i <xref:System.UIntPtr?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="46433-272">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="46433-273">Kompilator wyświetla dodatkowe konwersje i operacje dla tych typów jako natywny liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="46433-273">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="46433-274">Liczby całkowite o rozmiarze natywnym definiują właściwości dla `MaxValue` lub `MinValue` .</span><span class="sxs-lookup"><span data-stu-id="46433-274">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="46433-275">Te wartości nie mogą być wyrażone jako stałe czasu kompilacji, ponieważ zależą od natywnego rozmiaru liczby całkowitej na maszynie docelowej.</span><span class="sxs-lookup"><span data-stu-id="46433-275">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="46433-276">Te wartości są tylko do odczytu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="46433-276">Those values are readonly at runtime.</span></span> <span data-ttu-id="46433-277">Można użyć wartości stałych dla `nint` zakresu [ `int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="46433-277">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="46433-278">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="46433-278">`int.MaxValue`].</span></span> <span data-ttu-id="46433-279">Można użyć wartości stałych dla `nuint` zakresu [ `uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="46433-279">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="46433-280">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="46433-280">`uint.MaxValue`].</span></span> <span data-ttu-id="46433-281">Kompilator wykonuje stałe łamanie dla wszystkich operatorów jednoargumentowych i binarnych przy użyciu <xref:System.Int32?displayProperty=nameWithType> <xref:System.UInt32?displayProperty=nameWithType> typów i.</span><span class="sxs-lookup"><span data-stu-id="46433-281">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="46433-282">Jeśli wynik nie mieści się w 32 bitów, operacja jest wykonywana w czasie wykonywania i nie jest traktowana jako stała.</span><span class="sxs-lookup"><span data-stu-id="46433-282">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="46433-283">Natywne liczby całkowite mogą zwiększyć wydajność w scenariuszach, w których liczba obliczeń matematycznych jest szeroko stosowana i musi mieć możliwie najszybszą wydajność.</span><span class="sxs-lookup"><span data-stu-id="46433-283">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="46433-284">Wskaźniki funkcji umożliwiają łatwą składnię dostępu do kodów opcode IL `ldftn` i `calli` .</span><span class="sxs-lookup"><span data-stu-id="46433-284">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="46433-285">Można zadeklarować wskaźniki funkcji przy użyciu nowej `delegate_` składni.</span><span class="sxs-lookup"><span data-stu-id="46433-285">You can declare function pointers using new `delegate_` syntax.</span></span> <span data-ttu-id="46433-286">`delegate*`Typ jest typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="46433-286">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="46433-287">Wywoływanie `delegate*` użycia typu `calli` , w przeciwieństwie do delegata, który używa `callvirt` `Invoke()` metody.</span><span class="sxs-lookup"><span data-stu-id="46433-287">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="46433-288">Syntaktycznie wywołania są identyczne.</span><span class="sxs-lookup"><span data-stu-id="46433-288">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="46433-289">Wywołanie wskaźnika funkcji używa `managed` konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="46433-289">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="46433-290">Dodaj `unmanaged` słowo kluczowe po `delegate*` składni, aby zadeklarować, że chcesz `unmanaged` konwencję wywoływania.</span><span class="sxs-lookup"><span data-stu-id="46433-290">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="46433-291">Inne konwencje wywoływania można określić przy użyciu atrybutów w `delegate*` deklaracji.</span><span class="sxs-lookup"><span data-stu-id="46433-291">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="46433-292">Na koniec możesz dodać polecenie, <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> aby poinstruować kompilator, aby nie emitują `localsinit` flagi.</span><span class="sxs-lookup"><span data-stu-id="46433-292">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="46433-293">Ta flaga instruuje CLR, aby nie zainicjowano wszystkich zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="46433-293">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="46433-294">`localsinit`Flaga była domyślnym zachowaniem języka C# od 1,0.</span><span class="sxs-lookup"><span data-stu-id="46433-294">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="46433-295">Jednak dodatkowe zero inicjacji może mieć wymierny wpływ na wydajność w niektórych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="46433-295">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="46433-296">W szczególności w przypadku korzystania z programu `stackalloc` .</span><span class="sxs-lookup"><span data-stu-id="46433-296">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="46433-297">W takich przypadkach można dodać <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> .</span><span class="sxs-lookup"><span data-stu-id="46433-297">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="46433-298">Możesz dodać go do pojedynczej metody lub właściwości, lub do `class` modułu,, `struct` , `interface` lub nawet.</span><span class="sxs-lookup"><span data-stu-id="46433-298">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="46433-299">Ten atrybut nie ma wpływu na `abstract` metody; wpływa na kod wygenerowany dla implementacji.</span><span class="sxs-lookup"><span data-stu-id="46433-299">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="46433-300">Te funkcje mogą zwiększyć wydajność w niektórych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="46433-300">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="46433-301">Powinny być używane tylko po dokładnym przeprowadzeniu testu porównawczego zarówno przed, jak i po przyjęciu.</span><span class="sxs-lookup"><span data-stu-id="46433-301">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="46433-302">Kod obejmujący liczby całkowite o liczbie natywnej musi być testowany na wielu platformach docelowych z różnymi rozmiarami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="46433-302">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="46433-303">Inne funkcje wymagają niebezpiecznego kodu.</span><span class="sxs-lookup"><span data-stu-id="46433-303">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="46433-304">Funkcje dopasowywania i kończenia</span><span class="sxs-lookup"><span data-stu-id="46433-304">Fit and finish features</span></span>

<span data-ttu-id="46433-305">Wiele innych funkcji ułatwia bardziej wydajne pisanie kodu.</span><span class="sxs-lookup"><span data-stu-id="46433-305">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="46433-306">W języku C# 9,0 można pominąć typ w [ `new` wyrażeniu](../language-reference/operators/new-operator.md) , gdy typ tworzonego obiektu jest już znany.</span><span class="sxs-lookup"><span data-stu-id="46433-306">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="46433-307">Najbardziej typowym zastosowaniem jest deklaracja pól:</span><span class="sxs-lookup"><span data-stu-id="46433-307">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="46433-308">Typ docelowy `new` może być również używany, gdy trzeba utworzyć nowy obiekt do przekazania jako argument do metody.</span><span class="sxs-lookup"><span data-stu-id="46433-308">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="46433-309">Rozważmy `ForecastFor()` metodę o następującym podpisie:</span><span class="sxs-lookup"><span data-stu-id="46433-309">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="46433-310">Można wywołać go w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="46433-310">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="46433-311">Innym świetnym użyciem tej funkcji jest połączenie z właściwościami tylko init w celu zainicjowania nowego obiektu:</span><span class="sxs-lookup"><span data-stu-id="46433-311">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="46433-312">Można zwrócić wystąpienie utworzone przez konstruktora domyślnego przy użyciu `return new();` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="46433-312">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="46433-313">Podobna funkcja ulepsza rozpoznawanie typu docelowego [wyrażeń warunkowych](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="46433-313">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="46433-314">W przypadku tej zmiany dwa wyrażenia nie muszą mieć jawnej konwersji z jednego do drugiego, ale mogą jednocześnie mieć niejawne konwersje na typ docelowy.</span><span class="sxs-lookup"><span data-stu-id="46433-314">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="46433-315">Ta zmiana jest niezauważalna.</span><span class="sxs-lookup"><span data-stu-id="46433-315">You likely won’t notice this change.</span></span> <span data-ttu-id="46433-316">Informacje o tym, że niektóre wyrażenia warunkowe, które wcześniej wymagały rzutowania lub nie spowodują skompilowania, już teraz działają.</span><span class="sxs-lookup"><span data-stu-id="46433-316">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="46433-317">Począwszy od języka C# 9,0, można dodać `static` modyfikator do [wyrażeń lambda](../language-reference/operators/lambda-expressions.md) lub [metod anonimowych](../language-reference/operators/delegate-operator.md).</span><span class="sxs-lookup"><span data-stu-id="46433-317">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="46433-318">Statyczne wyrażenia lambda są analogiczne do `static` funkcji lokalnych: statyczna metoda lambda lub anonimowa nie może przechwycić lokalnych zmiennych lub stanu wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="46433-318">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="46433-319">`static`Modyfikator zapobiega przypadkowemu przechwyceniu innych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="46433-319">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="46433-320">Typy zwracane przez współwarianty zapewniają elastyczność dla zwracanych typów metod [zastąpień](../language-reference/keywords/override.md) .</span><span class="sxs-lookup"><span data-stu-id="46433-320">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="46433-321">Metoda przesłaniania może zwracać typ pochodzący od typu zwracanego przesłoniętej metody bazowej.</span><span class="sxs-lookup"><span data-stu-id="46433-321">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="46433-322">Może to być przydatne w przypadku rekordów i dla innych typów, które obsługują wirtualne klony lub metody fabryki.</span><span class="sxs-lookup"><span data-stu-id="46433-322">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="46433-323">Ponadto [ `foreach` Pętla](../language-reference/keywords/foreach-in.md) rozpoznaje i używa metody rozszerzenia `GetEnumerator` , która w przeciwnym razie spełnia warunki `foreach` wzorca.</span><span class="sxs-lookup"><span data-stu-id="46433-323">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="46433-324">Ta zmiana oznacza `foreach` spójność z innymi konstrukcjami opartymi na wzorcu, takimi jak wzorzec asynchroniczny i dekonstrukcja oparta na wzorcu.</span><span class="sxs-lookup"><span data-stu-id="46433-324">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="46433-325">W tym przypadku ta zmiana oznacza, że można dodać `foreach` obsługę dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="46433-325">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="46433-326">Należy ograniczyć jego użycie do momentu, gdy Wyliczenie obiektu ma sens w projekcie.</span><span class="sxs-lookup"><span data-stu-id="46433-326">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="46433-327">Następnie można użyć odrzutów jako parametrów w wyrażeniach lambda.</span><span class="sxs-lookup"><span data-stu-id="46433-327">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="46433-328">Ta wygoda pozwala uniknąć nazywania argumentu, a kompilator może uniknąć korzystania z niego.</span><span class="sxs-lookup"><span data-stu-id="46433-328">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="46433-329">Używasz `_` argumentu for.</span><span class="sxs-lookup"><span data-stu-id="46433-329">You use the `_` for any argument.</span></span> <span data-ttu-id="46433-330">Aby uzyskać więcej informacji, zobacz [Parametry wejściowe sekcji wyrażenie lambda](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) w artykule [wyrażenia lambda](../language-reference/operators/lambda-expressions.md) .</span><span class="sxs-lookup"><span data-stu-id="46433-330">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="46433-331">Na koniec możesz teraz zastosować atrybuty do [funkcji lokalnych](../programming-guide/classes-and-structs/local-functions.md).</span><span class="sxs-lookup"><span data-stu-id="46433-331">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="46433-332">Na przykład można zastosować [Adnotacje atrybutu nullable](../language-reference/attributes/nullable-analysis.md) do funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="46433-332">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="46433-333">Obsługa generatorów kodu</span><span class="sxs-lookup"><span data-stu-id="46433-333">Support for code generators</span></span>

<span data-ttu-id="46433-334">Dwie funkcje końcowe obsługują generatory kodu w języku C#.</span><span class="sxs-lookup"><span data-stu-id="46433-334">Two final features support C# code generators.</span></span> <span data-ttu-id="46433-335">Generatory kodu w języku C# to składnik, który można napisać, podobnie jak Analizator Roslyn lub poprawka kodu.</span><span class="sxs-lookup"><span data-stu-id="46433-335">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="46433-336">Różnica polega na tym, że generatory kodu analizują kod i zapisują nowe pliki kodu źródłowego w ramach procesu kompilacji.</span><span class="sxs-lookup"><span data-stu-id="46433-336">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="46433-337">Typowy generator kodu wyszukuje kod dla atrybutów lub innych konwencji.</span><span class="sxs-lookup"><span data-stu-id="46433-337">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="46433-338">Generator kodu odczytuje atrybuty lub inne elementy kodu przy użyciu interfejsów API analizy Roslyn.</span><span class="sxs-lookup"><span data-stu-id="46433-338">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="46433-339">Z tych informacji dodaje nowy kod do kompilacji.</span><span class="sxs-lookup"><span data-stu-id="46433-339">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="46433-340">Generatory źródła mogą jedynie dodawać kod; nie mogą modyfikować żadnego istniejącego kodu w kompilacji.</span><span class="sxs-lookup"><span data-stu-id="46433-340">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="46433-341">Dwie funkcje, które zostały dodane dla generatorów kodu, to rozszerzenia ***Składnia metody częściowej** _ i _*_inicjatory modułów_\*_.</span><span class="sxs-lookup"><span data-stu-id="46433-341">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*_.</span></span> <span data-ttu-id="46433-342">Najpierw zmiany w metodach częściowych.</span><span class="sxs-lookup"><span data-stu-id="46433-342">First, the changes to partial methods.</span></span> <span data-ttu-id="46433-343">Przed C# 9,0 metody częściowe są, `private` ale nie można określić modyfikatora dostępu, mają `void` Return i nie mogą mieć `out` parametrów.</span><span class="sxs-lookup"><span data-stu-id="46433-343">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="46433-344">Te ograniczenia mające na celu, że jeśli nie zostanie podana implementacja metody, kompilator usuwa wszystkie wywołania metody częściowej.</span><span class="sxs-lookup"><span data-stu-id="46433-344">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="46433-345">Język C# 9,0 usuwa te ograniczenia, ale wymaga, aby częściowa deklaracja metod była implementacją.</span><span class="sxs-lookup"><span data-stu-id="46433-345">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="46433-346">Generatory kodu mogą zapewnić, że implementacja.</span><span class="sxs-lookup"><span data-stu-id="46433-346">Code generators can provide that implementation.</span></span> <span data-ttu-id="46433-347">Aby uniknąć wprowadzenia zmiany, kompilator traktuje każdą metodę częściową bez modyfikatora dostępu, aby przestrzegać starych reguł.</span><span class="sxs-lookup"><span data-stu-id="46433-347">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="46433-348">Jeśli metoda częściowa zawiera `private` modyfikator dostępu, nowe reguły regulują tę metodę częściową.</span><span class="sxs-lookup"><span data-stu-id="46433-348">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="46433-349">Druga Nowa funkcja dla generatorów kodu jest _ *_inicjatorów modułów_* \*.</span><span class="sxs-lookup"><span data-stu-id="46433-349">The second new feature for code generators is _\*_module initializers_\*\*.</span></span> <span data-ttu-id="46433-350">Inicjatory modułów to metody, które mają <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> dołączony atrybut.</span><span class="sxs-lookup"><span data-stu-id="46433-350">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="46433-351">Te metody będą wywoływane przez środowisko uruchomieniowe przed jakimkolwiek innym dostępem do pola lub wywołaniem metody w całym module.</span><span class="sxs-lookup"><span data-stu-id="46433-351">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="46433-352">Metoda inicjatora modułu:</span><span class="sxs-lookup"><span data-stu-id="46433-352">A module initializer method:</span></span>

- <span data-ttu-id="46433-353">Musi być statyczna</span><span class="sxs-lookup"><span data-stu-id="46433-353">Must be static</span></span>
- <span data-ttu-id="46433-354">Musi być bez parametrów</span><span class="sxs-lookup"><span data-stu-id="46433-354">Must be parameterless</span></span>
- <span data-ttu-id="46433-355">Musi zwracać typ void</span><span class="sxs-lookup"><span data-stu-id="46433-355">Must return void</span></span>
- <span data-ttu-id="46433-356">Nie może być metodą generyczną</span><span class="sxs-lookup"><span data-stu-id="46433-356">Must not be a generic method</span></span>
- <span data-ttu-id="46433-357">Nie może być zawarta w klasie generycznej</span><span class="sxs-lookup"><span data-stu-id="46433-357">Must not be contained in a generic class</span></span>
- <span data-ttu-id="46433-358">Musi być dostępny z poziomu zawierającego go modułu</span><span class="sxs-lookup"><span data-stu-id="46433-358">Must be accessible from the containing module</span></span>

<span data-ttu-id="46433-359">Ostatni punkt Bullet efektywnie oznacza, że metoda i jej Klasa zawierająca muszą być wewnętrzne lub publiczne.</span><span class="sxs-lookup"><span data-stu-id="46433-359">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="46433-360">Metoda nie może być funkcją lokalną.</span><span class="sxs-lookup"><span data-stu-id="46433-360">The method can't be a local function.</span></span>
