---
title: Co nowego w języku C# 9,0 — przewodnik w języku C#
description: Zapoznaj się z omówieniem nowych funkcji dostępnych w języku C# 9,0.
ms.date: 09/04/2020
ms.openlocfilehash: c256c03831ac759bc45467f38e85fd3a2884dda4
ms.sourcegitcommit: 532b03d5bbab764d63356193b04cd2281bc01239
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/26/2020
ms.locfileid: "92526594"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="c53cf-103">Co nowego w języku C# 9.0</span><span class="sxs-lookup"><span data-stu-id="c53cf-103">What's new in C# 9.0</span></span>

<span data-ttu-id="c53cf-104">W języku c# 9,0 dodano następujące funkcje i ulepszenia języka C#:</span><span class="sxs-lookup"><span data-stu-id="c53cf-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="c53cf-105">Rekordy</span><span class="sxs-lookup"><span data-stu-id="c53cf-105">Records</span></span>](#record-types)
- [<span data-ttu-id="c53cf-106">Metody ustawiające tylko do inicjowania</span><span class="sxs-lookup"><span data-stu-id="c53cf-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="c53cf-107">Instrukcje najwyższego poziomu</span><span class="sxs-lookup"><span data-stu-id="c53cf-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="c53cf-108">Ulepszenia dopasowania wzorców</span><span class="sxs-lookup"><span data-stu-id="c53cf-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="c53cf-109">Liczby całkowite o wielkości natywnej</span><span class="sxs-lookup"><span data-stu-id="c53cf-109">Native sized integers</span></span>
- <span data-ttu-id="c53cf-110">Wskaźniki funkcji</span><span class="sxs-lookup"><span data-stu-id="c53cf-110">Function pointers</span></span>
- <span data-ttu-id="c53cf-111">Pomiń emitowanie flagi localsinit</span><span class="sxs-lookup"><span data-stu-id="c53cf-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="c53cf-112">Nowe wyrażenia z typem docelowym</span><span class="sxs-lookup"><span data-stu-id="c53cf-112">Target-typed new expressions</span></span>
- <span data-ttu-id="c53cf-113">statyczne funkcje anonimowe</span><span class="sxs-lookup"><span data-stu-id="c53cf-113">static anonymous functions</span></span>
- <span data-ttu-id="c53cf-114">Wyrażenia warunkowe z typem docelowym</span><span class="sxs-lookup"><span data-stu-id="c53cf-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="c53cf-115">Kowariantne typy zwracane</span><span class="sxs-lookup"><span data-stu-id="c53cf-115">Covariant return types</span></span>
- <span data-ttu-id="c53cf-116">`GetEnumerator`Obsługa rozszerzeń dla `foreach` pętli</span><span class="sxs-lookup"><span data-stu-id="c53cf-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="c53cf-117">Parametry odrzucania wyrażenia lambda</span><span class="sxs-lookup"><span data-stu-id="c53cf-117">Lambda discard parameters</span></span>
- <span data-ttu-id="c53cf-118">Atrybuty funkcji lokalnych</span><span class="sxs-lookup"><span data-stu-id="c53cf-118">Attributes on local functions</span></span>
- <span data-ttu-id="c53cf-119">Inicjatory modułów</span><span class="sxs-lookup"><span data-stu-id="c53cf-119">Module initializers</span></span>
- <span data-ttu-id="c53cf-120">Nowe funkcje dla metod częściowych</span><span class="sxs-lookup"><span data-stu-id="c53cf-120">New features for partial methods</span></span>

<span data-ttu-id="c53cf-121">Język C# 9,0 jest obsługiwany w **programie .NET 5**.</span><span class="sxs-lookup"><span data-stu-id="c53cf-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="c53cf-122">Aby uzyskać więcej informacji, zobacz [wersja języka C#](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="c53cf-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

## <a name="record-types"></a><span data-ttu-id="c53cf-123">Typy rekordów</span><span class="sxs-lookup"><span data-stu-id="c53cf-123">Record types</span></span>

<span data-ttu-id="c53cf-124">W języku C# 9,0 wprowadzono \**_typy rekordów_*_, które są typu referencyjnego, który dostarcza metody, które umożliwiają syntezę wartości dla równości.</span><span class="sxs-lookup"><span data-stu-id="c53cf-124">C# 9.0 introduces \**_record types_*_, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="c53cf-125">Rekordy są domyślnie niezmienne.</span><span class="sxs-lookup"><span data-stu-id="c53cf-125">Records are immutable by default.</span></span>

<span data-ttu-id="c53cf-126">Typy rekordów ułatwiają tworzenie niemodyfikowalnych typów referencyjnych w programie .NET.</span><span class="sxs-lookup"><span data-stu-id="c53cf-126">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="c53cf-127">Historycznie typy .NET są w znacznym stopniu klasyfikowane jako typy referencyjne (w tym klasy i typy anonimowe) i typy wartości (w tym struktury i krotki).</span><span class="sxs-lookup"><span data-stu-id="c53cf-127">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="c53cf-128">Chociaż zaleca się niezmienne typy wartości, modyfikowalne typy wartości nie często wprowadzają błędy.</span><span class="sxs-lookup"><span data-stu-id="c53cf-128">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="c53cf-129">Zmienne typu wartości przechowują wartości, więc zmiany są wprowadzane do kopii oryginalnych danych, gdy typy wartości są przekazywane do metod.</span><span class="sxs-lookup"><span data-stu-id="c53cf-129">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="c53cf-130">Istnieje wiele zalet, aby również niezmienne typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="c53cf-130">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="c53cf-131">Te zalety są bardziej wymawiane w współbieżnych programach z udostępnionymi danymi.</span><span class="sxs-lookup"><span data-stu-id="c53cf-131">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="c53cf-132">Niestety, w języku C# wymuszono napisanie całkiem dowolnego dodatkowego kodu w celu utworzenia niemodyfikowalnych typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-132">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="c53cf-133">Rekordy zapewniają deklarację typu dla niezmiennego typu referencyjnego, który używa semantyki wartości dla równości.</span><span class="sxs-lookup"><span data-stu-id="c53cf-133">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="c53cf-134">W metodach syntezy dla kodów równości i wyznaczania wartości skrótu należy wziąć pod uwagę dwa rekordy równe, jeśli ich właściwości są równe.</span><span class="sxs-lookup"><span data-stu-id="c53cf-134">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="c53cf-135">Należy wziąć pod uwagę tę definicję:</span><span class="sxs-lookup"><span data-stu-id="c53cf-135">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="c53cf-136">Definicja rekordu tworzy `Person` Typ, który zawiera dwie właściwości ReadOnly: `FirstName` i `LastName` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-136">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="c53cf-137">`Person`Typ jest typem referencyjnym.</span><span class="sxs-lookup"><span data-stu-id="c53cf-137">The `Person` type is a reference type.</span></span> <span data-ttu-id="c53cf-138">Jeśli szukasz języka IL, jest on klasą.</span><span class="sxs-lookup"><span data-stu-id="c53cf-138">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="c53cf-139">Jest to niezmienne w przypadku, gdy żadna z właściwości nie może być modyfikowana po utworzeniu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-139">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="c53cf-140">W przypadku zdefiniowania typu rekordu, kompilator umożliwia wyszukanie kilku innych metod:</span><span class="sxs-lookup"><span data-stu-id="c53cf-140">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="c53cf-141">Metody porównania równości opartej na wartościach</span><span class="sxs-lookup"><span data-stu-id="c53cf-141">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="c53cf-142">Przesłoń dla <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="c53cf-142">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="c53cf-143">Kopiowanie i klonowanie elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="c53cf-143">Copy and Clone members</span></span>
- <span data-ttu-id="c53cf-144">`PrintMembers` i <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="c53cf-144">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="c53cf-145">Rekordy obsługują dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="c53cf-145">Records support inheritance.</span></span> <span data-ttu-id="c53cf-146">Można zadeklarować nowy rekord pochodzący z `Person` następujących metod:</span><span class="sxs-lookup"><span data-stu-id="c53cf-146">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="c53cf-147">Możesz również zapieczętować rekordy, aby zapobiec dalszemu występowaniu:</span><span class="sxs-lookup"><span data-stu-id="c53cf-147">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="c53cf-148">Kompilator syntezuje różne wersje powyższych metod.</span><span class="sxs-lookup"><span data-stu-id="c53cf-148">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="c53cf-149">Sygnatury metod są zależne od tego, czy typ rekordu jest zapieczętowany i czy bezpośrednia klasa bazowa to obiekt.</span><span class="sxs-lookup"><span data-stu-id="c53cf-149">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="c53cf-150">Rekordy powinny mieć następujące możliwości:</span><span class="sxs-lookup"><span data-stu-id="c53cf-150">Records should have the following capabilities:</span></span>

- <span data-ttu-id="c53cf-151">Równość jest oparta na wartości i zawiera sprawdzenie, czy typy pasują do siebie.</span><span class="sxs-lookup"><span data-stu-id="c53cf-151">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="c53cf-152">Na przykład wartość `Student` nie może być równa `Person` , nawet jeśli dwa rekordy mają tę samą nazwę.</span><span class="sxs-lookup"><span data-stu-id="c53cf-152">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="c53cf-153">Rekordy mają wygenerowaną spójną reprezentację ciągu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-153">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="c53cf-154">Rekordy obsługują konstrukcję kopiowania.</span><span class="sxs-lookup"><span data-stu-id="c53cf-154">Records support copy construction.</span></span> <span data-ttu-id="c53cf-155">Poprawna konstrukcja kopii musi zawierać hierarchie dziedziczenia i właściwości dodawane przez deweloperów.</span><span class="sxs-lookup"><span data-stu-id="c53cf-155">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="c53cf-156">Rekordy można kopiować z modyfikacją.</span><span class="sxs-lookup"><span data-stu-id="c53cf-156">Records can be copied with modification.</span></span> <span data-ttu-id="c53cf-157">Te operacje kopiowania i modyfikowania obsługują mutację nieniszczącą.</span><span class="sxs-lookup"><span data-stu-id="c53cf-157">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="c53cf-158">Oprócz znanych `Equals` przeciążeń, i kompilator umożliwia wypróbowanie `operator ==` `operator !=` nowej `EqualityContract` właściwości.</span><span class="sxs-lookup"><span data-stu-id="c53cf-158">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="c53cf-159">Właściwość zwraca `Type` obiekt, który jest zgodny z typem rekordu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-159">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="c53cf-160">Jeśli typem podstawowym jest `object` , właściwość jest `virtual` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-160">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="c53cf-161">Jeśli typ podstawowy jest innym typem rekordu, właściwość jest `override` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-161">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="c53cf-162">Jeśli typem rekordu jest `sealed` , właściwość jest `sealed` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-162">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="c53cf-163">W syntezie są `GetHashCode` stosowane `GetHashCode` wszystkie właściwości i pola zadeklarowane w typie podstawowym oraz typ rekordu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-163">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="c53cf-164">Te metody, które zostały opisane w tej metodzie, wymuszają równość opartych na wartościach w hierarchii dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="c53cf-164">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="c53cf-165">Oznacza to, że `Student` nigdy nie będzie traktowane jako równe a `Person` o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="c53cf-165">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="c53cf-166">Typy dwóch rekordów muszą być zgodne oraz wszystkie właściwości, które są współużytkowane przez typy rekordów równe.</span><span class="sxs-lookup"><span data-stu-id="c53cf-166">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="c53cf-167">Rekordy mają również konstruktory z syntezą i metodę "Clone" służącą do tworzenia kopii.</span><span class="sxs-lookup"><span data-stu-id="c53cf-167">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="c53cf-168">Konstruktor z syntezą ma jeden argument typu rekordu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-168">The synthesized constructor has one argument of the record type.</span></span> <span data-ttu-id="c53cf-169">Tworzy nowy rekord z tymi samymi wartościami dla wszystkich właściwości rekordu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-169">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="c53cf-170">Ten konstruktor jest prywatny, jeśli rekord jest zapieczętowany, w przeciwnym razie jest chroniony.</span><span class="sxs-lookup"><span data-stu-id="c53cf-170">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="c53cf-171">Synteza "klonowanie" obsługuje konstrukcję kopiowania dla hierarchii rekordów.</span><span class="sxs-lookup"><span data-stu-id="c53cf-171">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="c53cf-172">Termin "klon" jest w cudzysłowie, ponieważ rzeczywista nazwa jest generowana przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="c53cf-172">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="c53cf-173">Nie można utworzyć metody o nazwie `Clone` w typie rekordu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-173">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="c53cf-174">Synteza "klon" zwraca typ rekordu, który jest kopiowany przy użyciu wysyłki wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="c53cf-174">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="c53cf-175">Kompilator dodaje różne Modyfikatory dla metody "Clone" w zależności od modyfikatorów dostępu w `record` :</span><span class="sxs-lookup"><span data-stu-id="c53cf-175">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="c53cf-176">Jeśli typem rekordu jest `abstract` , Metoda "klonowanie" jest również `abstract` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-176">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="c53cf-177">Jeśli typ podstawowy nie jest `object` , metoda jest również `override` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-177">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="c53cf-178">Dla typów rekordów, które nie są, `abstract` gdy typem podstawowym jest `object` :</span><span class="sxs-lookup"><span data-stu-id="c53cf-178">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="c53cf-179">Jeśli rekord ma wartość `sealed` , żadne dodatkowe Modyfikatory nie są dodawane do metody "klonowania" (oznacza to, że nie jest `virtual` ).</span><span class="sxs-lookup"><span data-stu-id="c53cf-179">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="c53cf-180">Jeśli rekord nie jest `sealed` , Metoda "Clone" ma wartość `virtual` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-180">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="c53cf-181">Dla typów rekordów, które nie są, `abstract` gdy typ podstawowy nie jest `object` :</span><span class="sxs-lookup"><span data-stu-id="c53cf-181">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="c53cf-182">Jeśli rekordem jest `sealed` , Metoda "klonowanie" jest również `sealed` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-182">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="c53cf-183">Jeśli rekord nie jest `sealed` , Metoda "Clone" ma wartość `override` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-183">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="c53cf-184">Wynik wszystkich tych reguł jest implementowany spójnie dla każdej hierarchii typów rekordów.</span><span class="sxs-lookup"><span data-stu-id="c53cf-184">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="c53cf-185">Dwa rekordy są równe siebie, jeśli ich właściwości są równe, a ich typy są takie same, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="c53cf-185">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="c53cf-186">Kompilator syntezuje dwie metody, które obsługują wydruk wyjściowy: <xref:System.Object.ToString> przesłonięcie i `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-186">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="c53cf-187">`PrintMembers`Przyjmuje <xref:System.Text.StringBuilder?displayProperty=nameWithType> jako argument.</span><span class="sxs-lookup"><span data-stu-id="c53cf-187">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="c53cf-188">Dodaje rozdzieloną przecinkami listę nazw właściwości i wartości dla wszystkich właściwości w typie rekordu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-188">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="c53cf-189">`PrintMembers` wywołuje podstawową implementację wszystkich rekordów pochodzących z innych rekordów.</span><span class="sxs-lookup"><span data-stu-id="c53cf-189">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="c53cf-190"><xref:System.Object.ToString>Zastąpienie zwraca ciąg utworzony przez `PrintMembers` , ujęty w `{` i `}` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-190">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="c53cf-191">Na przykład <xref:System.Object.ToString> Metoda `Student` zwraca `string` podobne do poniższego kodu:</span><span class="sxs-lookup"><span data-stu-id="c53cf-191">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="c53cf-192">Przykłady pokazane do użycia tradycyjną składnią do deklarowania właściwości.</span><span class="sxs-lookup"><span data-stu-id="c53cf-192">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="c53cf-193">Istnieje bardziej zwięzła forma o nazwie _*_rekordy pozycyjne_*_.</span><span class="sxs-lookup"><span data-stu-id="c53cf-193">There's a more concise form called _*_positional records_*_.</span></span>  <span data-ttu-id="c53cf-194">Oto trzy typy rekordów zdefiniowane wcześniej jako rekordy pozycyjne:</span><span class="sxs-lookup"><span data-stu-id="c53cf-194">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="c53cf-195">Te deklaracje tworzą takie same funkcje jak wcześniejsza wersja (z kilkoma dodatkowymi funkcjami wymienionymi w poniższej sekcji).</span><span class="sxs-lookup"><span data-stu-id="c53cf-195">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="c53cf-196">Te deklaracje kończą się średnikiem zamiast nawiasów, ponieważ te rekordy nie dodają dodatkowych metod.</span><span class="sxs-lookup"><span data-stu-id="c53cf-196">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="c53cf-197">Możesz również dodać treść i dołączyć wszelkie dodatkowe metody:</span><span class="sxs-lookup"><span data-stu-id="c53cf-197">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="c53cf-198">Kompilator tworzy `Deconstruct` metodę dla rekordów pozycyjnych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-198">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="c53cf-199">`Deconstruct`Metoda ma parametry, które pasują do nazw wszystkich właściwości publicznych w typie rekordu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-199">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="c53cf-200">`Deconstruct`Metoda może służyć do dekonstruowania rekordu we właściwościach składnika:</span><span class="sxs-lookup"><span data-stu-id="c53cf-200">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="c53cf-201">Na koniec rejestruje obsługę _*_wyrażeń z wyrażeniami_*_.</span><span class="sxs-lookup"><span data-stu-id="c53cf-201">Finally, records support _*_with-expressions_*_.</span></span> <span data-ttu-id="c53cf-202">_*_Wyrażenie with_*_ powoduje, że kompilator tworzy kopię rekordu, ale _with \* określone właściwości są modyfikowane:</span><span class="sxs-lookup"><span data-stu-id="c53cf-202">A _*_with-expression_*_ instructs the compiler to create a copy of a record, but _with\* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="c53cf-203">Powyższy wiersz tworzy nowy `Person` rekord, w którym `LastName` Właściwość jest kopią `person` , a `FirstName` jest "Paul".</span><span class="sxs-lookup"><span data-stu-id="c53cf-203">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is "Paul".</span></span> <span data-ttu-id="c53cf-204">W wyrażeniu można ustawić dowolną liczbę właściwości.</span><span class="sxs-lookup"><span data-stu-id="c53cf-204">You can set any number of properties in a with-expression.</span></span>  <span data-ttu-id="c53cf-205">Każdy z tych elementów członkowskich, z wyjątkiem metody "Clone", może zostać przez Ciebie zapisany.</span><span class="sxs-lookup"><span data-stu-id="c53cf-205">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="c53cf-206">Jeśli typ rekordu ma metodę, która pasuje do sygnatury dowolnej metody, kompilator nie wykonuje syntezy tej metody.</span><span class="sxs-lookup"><span data-stu-id="c53cf-206">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="c53cf-207">W przykładzie wcześniejszego `Dog` rekordu znajduje się <xref:System.String.ToString> Przykładowa Metoda ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="c53cf-207">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="c53cf-208">Metody ustawiające tylko do inicjowania</span><span class="sxs-lookup"><span data-stu-id="c53cf-208">Init only setters</span></span>

<span data-ttu-id="c53cf-209">\***Tylko metody init**_ mają spójną składnię, aby inicjować elementy członkowskie obiektu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-209">\***Init only setters**_ provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="c53cf-210">Inicjatory właściwości sprawiają, że wartość jest ustawiana dla właściwości.</span><span class="sxs-lookup"><span data-stu-id="c53cf-210">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="c53cf-211">Minusemem jest to, że te właściwości muszą mieć wartość settable.</span><span class="sxs-lookup"><span data-stu-id="c53cf-211">The downside is that those properties must be settable.</span></span> <span data-ttu-id="c53cf-212">Począwszy od języka C# 9,0, można tworzyć metody `init` dostępu zamiast `set` metod dostępu do właściwości i indeksatorów.</span><span class="sxs-lookup"><span data-stu-id="c53cf-212">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="c53cf-213">Obiekty wywołujące mogą używać składni inicjatora właściwości do ustawiania tych wartości w wyrażeniach tworzenia, ale te właściwości są tylko do odczytu, gdy konstrukcja została ukończona.</span><span class="sxs-lookup"><span data-stu-id="c53cf-213">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="c53cf-214">Tylko metody init umożliwiają zmianę stanu okna.</span><span class="sxs-lookup"><span data-stu-id="c53cf-214">Init only setters provide a window to change state.</span></span> <span data-ttu-id="c53cf-215">To okno zostanie zamknięte po zakończeniu fazy budowania.</span><span class="sxs-lookup"><span data-stu-id="c53cf-215">That window closes when the construction phase ends.</span></span> <span data-ttu-id="c53cf-216">Faza konstruowania skutecznie kończy działanie po wszystkich inicjalizacjach, w tym inicjatorach właściwości i wyrażeniach z.</span><span class="sxs-lookup"><span data-stu-id="c53cf-216">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="c53cf-217">Można zadeklarować `init` tylko metody ustawiające w dowolnym typie, który napiszesz.</span><span class="sxs-lookup"><span data-stu-id="c53cf-217">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="c53cf-218">Na przykład następująca struktura definiuje strukturę obserwacji pogody:</span><span class="sxs-lookup"><span data-stu-id="c53cf-218">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="c53cf-219">Obiekty wywołujące mogą używać składni inicjatora właściwości do ustawiania wartości, pozostawiając zachowanie niezmienności:</span><span class="sxs-lookup"><span data-stu-id="c53cf-219">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="c53cf-220">Jednak zmiana obserwacji po inicjacji jest błędem przez przypisanie do właściwości "init-Only" poza inicjalizacją:</span><span class="sxs-lookup"><span data-stu-id="c53cf-220">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="c53cf-221">Tylko metody init mogą być przydatne do ustawiania właściwości klasy bazowej z klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-221">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="c53cf-222">Mogą także ustawiać właściwości pochodne za pomocą pomocników w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="c53cf-222">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="c53cf-223">Rekordy pozycyjne deklarują właściwości przy użyciu tylko metod init.</span><span class="sxs-lookup"><span data-stu-id="c53cf-223">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="c53cf-224">Te metody ustawiające są używane w wyrażeniach with.</span><span class="sxs-lookup"><span data-stu-id="c53cf-224">Those setters are used in with-expressions.</span></span> <span data-ttu-id="c53cf-225">Można zadeklarować tylko metody init dla dowolnego `class` lub `struct` zdefiniowanego elementu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-225">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="c53cf-226">Instrukcje najwyższego poziomu</span><span class="sxs-lookup"><span data-stu-id="c53cf-226">Top-level statements</span></span>

<span data-ttu-id="c53cf-227">_*_Instrukcje najwyższego poziomu_*_ usuwają niepotrzebne procedury z wielu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-227">_*_Top-level statements_*_ remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="c53cf-228">Rozważmy kanoniczną "Hello world!"</span><span class="sxs-lookup"><span data-stu-id="c53cf-228">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="c53cf-229">Program</span><span class="sxs-lookup"><span data-stu-id="c53cf-229">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="c53cf-230">Istnieje tylko jeden wiersz kodu, który robi wszystko.</span><span class="sxs-lookup"><span data-stu-id="c53cf-230">There’s only one line of code that does anything.</span></span> <span data-ttu-id="c53cf-231">Przy użyciu instrukcji najwyższego poziomu można zastąpić wszystkie te, które są standardową `using` instrukcją i pojedynczy wiersz, który wykonuje prace:</span><span class="sxs-lookup"><span data-stu-id="c53cf-231">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="c53cf-232">Jeśli chciałeś zastosować program jednowierszowy, możesz usunąć `using` dyrektywę i użyć w pełni kwalifikowanej nazwy typu:</span><span class="sxs-lookup"><span data-stu-id="c53cf-232">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="c53cf-233">Tylko jeden plik w aplikacji może używać instrukcji najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-233">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="c53cf-234">Jeśli kompilator odnajdzie instrukcje najwyższego poziomu w wielu plikach źródłowych, jest to błąd.</span><span class="sxs-lookup"><span data-stu-id="c53cf-234">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="c53cf-235">Jest również błędem, jeśli łączysz instrukcje najwyższego poziomu z zadeklarowaną metodą punktu wejścia programu, zwykle `Main` metodę.</span><span class="sxs-lookup"><span data-stu-id="c53cf-235">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="c53cf-236">W tym sensie można wziąć pod uwagę, że jeden plik zawiera instrukcje, które zwykle są w `Main` metodzie `Program` klasy.</span><span class="sxs-lookup"><span data-stu-id="c53cf-236">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="c53cf-237">Jednym z najpopularniejszych zastosowania tej funkcji jest tworzenie materiałów edukacyjnych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-237">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="c53cf-238">Początkująci deweloperzy języka C# mogą pisać kanoniczny "Hello world!"</span><span class="sxs-lookup"><span data-stu-id="c53cf-238">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="c53cf-239">w jednym lub dwóch wierszach kodu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-239">in one or two lines of code.</span></span> <span data-ttu-id="c53cf-240">Żadna z dodatkowych procedury nie jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="c53cf-240">None of the extra ceremony is needed.</span></span> <span data-ttu-id="c53cf-241">Niemniej deweloperzy mogą również znaleźć wiele użycia tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-241">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="c53cf-242">W instrukcjach najwyższego poziomu można korzystać ze środowiska podobnego do skryptu na potrzeby eksperymentowania podobnego do tego, co zapewnia notesy Jupyter.</span><span class="sxs-lookup"><span data-stu-id="c53cf-242">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="c53cf-243">Instrukcje najwyższego poziomu są doskonałe dla małych programów konsolowych i narzędzi.</span><span class="sxs-lookup"><span data-stu-id="c53cf-243">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="c53cf-244">Usługa Azure Functions jest idealnym przypadkiem użycia dla instrukcji najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-244">Azure functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="c53cf-245">Co najważniejsze, instrukcje najwyższego poziomu nie ograniczają zakresu lub złożoności aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-245">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="c53cf-246">Te instrukcje mogą uzyskać dostęp do dowolnej klasy .NET lub korzystać z niej.</span><span class="sxs-lookup"><span data-stu-id="c53cf-246">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="c53cf-247">Nie ograniczają one również użycia argumentów wiersza polecenia ani zwracanych wartości.</span><span class="sxs-lookup"><span data-stu-id="c53cf-247">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="c53cf-248">Instrukcje najwyższego poziomu mogą uzyskać dostęp do tablicy ciągów o nazwach argumentów.</span><span class="sxs-lookup"><span data-stu-id="c53cf-248">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="c53cf-249">Jeśli instrukcje najwyższego poziomu zwracają wartość całkowitą, ta wartość zostanie zwróconym kodem zwrotnym z metody z syntezą `Main` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-249">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="c53cf-250">Instrukcje najwyższego poziomu mogą zawierać wyrażenia asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="c53cf-250">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="c53cf-251">W takim przypadku syntezny punkt wejścia zwraca `Task` lub `Task<int>` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-251">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="c53cf-252">Ulepszenia dopasowania wzorców</span><span class="sxs-lookup"><span data-stu-id="c53cf-252">Pattern matching enhancements</span></span>

<span data-ttu-id="c53cf-253">W języku C# 9 wprowadzono nowe ulepszenia dopasowania do wzorca:</span><span class="sxs-lookup"><span data-stu-id="c53cf-253">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="c53cf-254">_*_Wzorce typu_*_ zgodne ze zmienną jest typem</span><span class="sxs-lookup"><span data-stu-id="c53cf-254">_*_Type patterns_*_ match a variable is a type</span></span>
- <span data-ttu-id="c53cf-255">_*_Wzorce w nawiasach_*_ wymuszają lub podkreślają pierwszeństwo kombinacji wzorców</span><span class="sxs-lookup"><span data-stu-id="c53cf-255">_*_Parenthesized patterns_*_ enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="c53cf-256">_\*_ `and` Wzorce conjunctive_\*_ wymagają dopasowania obu wzorców</span><span class="sxs-lookup"><span data-stu-id="c53cf-256">_*_Conjunctive `and` patterns_*_ require both patterns to match</span></span>
- <span data-ttu-id="c53cf-257">_\*_ `or` Wzorce disjunctive_\*_ wymagają dopasowania do wzorca</span><span class="sxs-lookup"><span data-stu-id="c53cf-257">_*_Disjunctive `or` patterns_*_ require either pattern to match</span></span>
- <span data-ttu-id="c53cf-258">_\*_ `not` Wzorce negacji_\*_ wymagają, aby wzorzec nie był zgodny</span><span class="sxs-lookup"><span data-stu-id="c53cf-258">_*_Negated `not` patterns_*_ require that a pattern doesn’t match</span></span>
- <span data-ttu-id="c53cf-259">_*_Wzorce relacyjne_*_ wymagają, aby dane wejściowe były mniejsze niż, większe niż lub równe lub większe niż lub równe danej stałej.</span><span class="sxs-lookup"><span data-stu-id="c53cf-259">_*_Relational patterns_*_ require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="c53cf-260">Wzorce te wzbogacają składnię wzorców.</span><span class="sxs-lookup"><span data-stu-id="c53cf-260">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="c53cf-261">Rozważ następujące przykłady:</span><span class="sxs-lookup"><span data-stu-id="c53cf-261">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="c53cf-262">Alternatywnie, z opcjonalnymi nawiasami, aby wyczyścić ten element, który `and` ma wyższy priorytet niż `or` :</span><span class="sxs-lookup"><span data-stu-id="c53cf-262">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="c53cf-263">Jednym z najpopularniejszych zastosowania jest nowa składnia dla sprawdzania wartości null:</span><span class="sxs-lookup"><span data-stu-id="c53cf-263">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="c53cf-264">Któregokolwiek z tych wzorców można używać w dowolnym kontekście, w którym wzorce są dozwolone: `is` wyrażenia wzorców, `switch` wyrażenia, zagnieżdżone wzorce i wzorzec `switch` `case` etykiety instrukcji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-264">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="c53cf-265">Wydajność i międzyoperacyjność</span><span class="sxs-lookup"><span data-stu-id="c53cf-265">Performance and interop</span></span>

<span data-ttu-id="c53cf-266">Trzy nowe funkcje ulepszają obsługę natywnych bibliotek międzyoperacyjnych i niskiego poziomu, które wymagają wysokiej wydajności: natywnych liczb całkowitych, wskaźników funkcji i pomijania `localsinit` flagi.</span><span class="sxs-lookup"><span data-stu-id="c53cf-266">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="c53cf-267">Liczby całkowite o rozmiarze natywnym `nint` i `nuint` są typami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="c53cf-267">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="c53cf-268">Są one wyrażone przez typy podstawowe <xref:System.IntPtr?displayProperty=nameWithType> i <xref:System.UIntPtr?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c53cf-268">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c53cf-269">Kompilator wyświetla dodatkowe konwersje i operacje dla tych typów jako natywny liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="c53cf-269">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="c53cf-270">Liczby całkowite o rozmiarze natywnym definiują właściwości dla `MaxValue` lub `MinValue` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-270">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="c53cf-271">Te wartości nie mogą być wyrażone jako stałe czasu kompilacji, ponieważ zależą od natywnego rozmiaru liczby całkowitej na maszynie docelowej.</span><span class="sxs-lookup"><span data-stu-id="c53cf-271">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="c53cf-272">Te wartości są tylko do odczytu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="c53cf-272">Those values are readonly at runtime.</span></span> <span data-ttu-id="c53cf-273">Można użyć wartości stałych dla `nint` zakresu [ `int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="c53cf-273">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="c53cf-274">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="c53cf-274">`int.MaxValue`].</span></span> <span data-ttu-id="c53cf-275">Można użyć wartości stałych dla `nuint` zakresu [ `uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="c53cf-275">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="c53cf-276">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="c53cf-276">`uint.MaxValue`].</span></span> <span data-ttu-id="c53cf-277">Kompilator wykonuje stałe łamanie dla wszystkich operatorów jednoargumentowych i binarnych przy użyciu <xref:System.Int32?displayProperty=nameWithType> <xref:System.UInt32?displayProperty=nameWithType> typów i.</span><span class="sxs-lookup"><span data-stu-id="c53cf-277">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="c53cf-278">Jeśli wynik nie mieści się w 32 bitów, operacja jest wykonywana w czasie wykonywania i nie jest traktowana jako stała.</span><span class="sxs-lookup"><span data-stu-id="c53cf-278">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="c53cf-279">Natywne liczby całkowite mogą zwiększyć wydajność w scenariuszach, w których liczba obliczeń matematycznych jest szeroko stosowana i musi mieć możliwie najszybszą wydajność.</span><span class="sxs-lookup"><span data-stu-id="c53cf-279">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="c53cf-280">Wskaźniki funkcji umożliwiają łatwą składnię dostępu do kodów opcode IL `ldftn` i `calli` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-280">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="c53cf-281">Można zadeklarować wskaźniki funkcji przy użyciu nowej `delegate_` składni.</span><span class="sxs-lookup"><span data-stu-id="c53cf-281">You can declare function pointers using new `delegate_` syntax.</span></span> <span data-ttu-id="c53cf-282">`delegate*`Typ jest typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="c53cf-282">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="c53cf-283">Wywoływanie `delegate*` użycia typu `calli` , w przeciwieństwie do delegata, który używa `callvirt` `Invoke()` metody.</span><span class="sxs-lookup"><span data-stu-id="c53cf-283">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="c53cf-284">Syntaktycznie wywołania są identyczne.</span><span class="sxs-lookup"><span data-stu-id="c53cf-284">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="c53cf-285">Wywołanie wskaźnika funkcji używa `managed` konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="c53cf-285">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="c53cf-286">Dodaj `unmanaged` słowo kluczowe po `delegate*` składni, aby zadeklarować, że chcesz `unmanaged` konwencję wywoływania.</span><span class="sxs-lookup"><span data-stu-id="c53cf-286">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="c53cf-287">Inne konwencje wywoływania można określić przy użyciu atrybutów w `delegate*` deklaracji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-287">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="c53cf-288">Na koniec możesz dodać polecenie, <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> aby poinstruować kompilator, aby nie emitują `localsinit` flagi.</span><span class="sxs-lookup"><span data-stu-id="c53cf-288">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="c53cf-289">Ta flaga instruuje CLR, aby nie zainicjowano wszystkich zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-289">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="c53cf-290">`localsinit`Flaga była domyślnym zachowaniem języka C# od 1,0.</span><span class="sxs-lookup"><span data-stu-id="c53cf-290">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="c53cf-291">Jednak dodatkowe zero inicjacji może mieć wymierny wpływ na wydajność w niektórych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="c53cf-291">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="c53cf-292">W szczególności w przypadku korzystania z programu `stackalloc` .</span><span class="sxs-lookup"><span data-stu-id="c53cf-292">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="c53cf-293">W takich przypadkach można dodać <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> .</span><span class="sxs-lookup"><span data-stu-id="c53cf-293">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="c53cf-294">Możesz dodać go do pojedynczej metody lub właściwości, lub do `class` modułu,, `struct` , `interface` lub nawet.</span><span class="sxs-lookup"><span data-stu-id="c53cf-294">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="c53cf-295">Ten atrybut nie ma wpływu na `abstract` metody; wpływa na kod wygenerowany dla implementacji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-295">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="c53cf-296">Te funkcje mogą zwiększyć wydajność w niektórych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="c53cf-296">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="c53cf-297">Powinny być używane tylko po dokładnym przeprowadzeniu testu porównawczego zarówno przed, jak i po przyjęciu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-297">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="c53cf-298">Kod obejmujący liczby całkowite o liczbie natywnej musi być testowany na wielu platformach docelowych z różnymi rozmiarami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="c53cf-298">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="c53cf-299">Inne funkcje wymagają niebezpiecznego kodu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-299">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="c53cf-300">Funkcje dopasowywania i kończenia</span><span class="sxs-lookup"><span data-stu-id="c53cf-300">Fit and finish features</span></span>

<span data-ttu-id="c53cf-301">Wiele innych funkcji ułatwia bardziej wydajne pisanie kodu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-301">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="c53cf-302">W języku C# 9,0 można pominąć typ w [ `new` wyrażeniu](../language-reference/operators/new-operator.md) , gdy typ tworzonego obiektu jest już znany.</span><span class="sxs-lookup"><span data-stu-id="c53cf-302">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="c53cf-303">Najbardziej typowym zastosowaniem jest deklaracja pól:</span><span class="sxs-lookup"><span data-stu-id="c53cf-303">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="c53cf-304">Typ docelowy `new` może być również używany, gdy trzeba utworzyć nowy obiekt do przekazania jako argument do metody.</span><span class="sxs-lookup"><span data-stu-id="c53cf-304">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="c53cf-305">Rozważmy `ForecastFor()` metodę o następującym podpisie:</span><span class="sxs-lookup"><span data-stu-id="c53cf-305">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="c53cf-306">Można wywołać go w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="c53cf-306">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="c53cf-307">Innym świetnym użyciem tej funkcji jest połączenie z właściwościami tylko init w celu zainicjowania nowego obiektu:</span><span class="sxs-lookup"><span data-stu-id="c53cf-307">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="c53cf-308">Można zwrócić wystąpienie utworzone przez konstruktora domyślnego przy użyciu `return new();` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-308">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="c53cf-309">Podobna funkcja ulepsza rozpoznawanie typu docelowego [wyrażeń warunkowych](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="c53cf-309">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="c53cf-310">W przypadku tej zmiany dwa wyrażenia nie muszą mieć jawnej konwersji z jednego do drugiego, ale mogą jednocześnie mieć niejawne konwersje na typ docelowy.</span><span class="sxs-lookup"><span data-stu-id="c53cf-310">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="c53cf-311">Ta zmiana jest niezauważalna.</span><span class="sxs-lookup"><span data-stu-id="c53cf-311">You likely won’t notice this change.</span></span> <span data-ttu-id="c53cf-312">Informacje o tym, że niektóre wyrażenia warunkowe, które wcześniej wymagały rzutowania lub nie spowodują skompilowania, już teraz działają.</span><span class="sxs-lookup"><span data-stu-id="c53cf-312">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="c53cf-313">Począwszy od języka C# 9,0, można dodać `static` modyfikator do [wyrażeń lambda](../language-reference/operators/lambda-expressions.md) lub [metod anonimowych](../language-reference/operators/delegate-operator.md).</span><span class="sxs-lookup"><span data-stu-id="c53cf-313">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="c53cf-314">Statyczne wyrażenia lambda są analogiczne do `static` funkcji lokalnych: statyczna metoda lambda lub anonimowa nie może przechwycić lokalnych zmiennych lub stanu wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c53cf-314">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="c53cf-315">`static`Modyfikator zapobiega przypadkowemu przechwyceniu innych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-315">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="c53cf-316">Typy zwracane przez współwarianty zapewniają elastyczność dla zwracanych typów metod [zastąpień](../language-reference/keywords/override.md) .</span><span class="sxs-lookup"><span data-stu-id="c53cf-316">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="c53cf-317">Metoda przesłaniania może zwracać typ pochodzący od typu zwracanego przesłoniętej metody bazowej.</span><span class="sxs-lookup"><span data-stu-id="c53cf-317">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="c53cf-318">Może to być przydatne w przypadku rekordów i dla innych typów, które obsługują wirtualne klony lub metody fabryki.</span><span class="sxs-lookup"><span data-stu-id="c53cf-318">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="c53cf-319">Ponadto [ `foreach` Pętla](../language-reference/keywords/foreach-in.md) rozpoznaje i używa metody rozszerzenia `GetEnumerator` , która w przeciwnym razie spełnia warunki `foreach` wzorca.</span><span class="sxs-lookup"><span data-stu-id="c53cf-319">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="c53cf-320">Ta zmiana oznacza `foreach` spójność z innymi konstrukcjami opartymi na wzorcu, takimi jak wzorzec asynchroniczny i dekonstrukcja oparta na wzorcu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-320">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="c53cf-321">W tym przypadku ta zmiana oznacza, że można dodać `foreach` obsługę dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-321">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="c53cf-322">Należy ograniczyć jego użycie do momentu, gdy Wyliczenie obiektu ma sens w projekcie.</span><span class="sxs-lookup"><span data-stu-id="c53cf-322">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="c53cf-323">Następnie można użyć odrzutów jako parametrów w wyrażeniach lambda.</span><span class="sxs-lookup"><span data-stu-id="c53cf-323">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="c53cf-324">Ta wygoda pozwala uniknąć nazywania argumentu, a kompilator może uniknąć korzystania z niego.</span><span class="sxs-lookup"><span data-stu-id="c53cf-324">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="c53cf-325">Używasz `_` argumentu for.</span><span class="sxs-lookup"><span data-stu-id="c53cf-325">You use the `_` for any argument.</span></span> <span data-ttu-id="c53cf-326">Aby uzyskać więcej informacji, zobacz [Parametry wejściowe sekcji wyrażenie lambda](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) w artykule [wyrażenia lambda](../language-reference/operators/lambda-expressions.md) .</span><span class="sxs-lookup"><span data-stu-id="c53cf-326">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="c53cf-327">Na koniec możesz teraz zastosować atrybuty do [funkcji lokalnych](../programming-guide/classes-and-structs/local-functions.md).</span><span class="sxs-lookup"><span data-stu-id="c53cf-327">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="c53cf-328">Na przykład można zastosować [Adnotacje atrybutu nullable](../language-reference/attributes/nullable-analysis.md) do funkcji lokalnych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-328">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="c53cf-329">Obsługa generatorów kodu</span><span class="sxs-lookup"><span data-stu-id="c53cf-329">Support for code generators</span></span>

<span data-ttu-id="c53cf-330">Dwie funkcje końcowe obsługują generatory kodu w języku C#.</span><span class="sxs-lookup"><span data-stu-id="c53cf-330">Two final features support C# code generators.</span></span> <span data-ttu-id="c53cf-331">Generatory kodu w języku C# to składnik, który można napisać, podobnie jak Analizator Roslyn lub poprawka kodu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-331">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="c53cf-332">Różnica polega na tym, że generatory kodu analizują kod i zapisują nowe pliki kodu źródłowego w ramach procesu kompilacji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-332">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="c53cf-333">Typowy generator kodu wyszukuje kod dla atrybutów lub innych konwencji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-333">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="c53cf-334">Generator kodu odczytuje atrybuty lub inne elementy kodu przy użyciu interfejsów API analizy Roslyn.</span><span class="sxs-lookup"><span data-stu-id="c53cf-334">A code generator read attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="c53cf-335">Z tych informacji dodaje nowy kod do kompilacji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-335">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="c53cf-336">Generatory źródła mogą jedynie dodawać kod; nie mogą modyfikować żadnego istniejącego kodu w kompilacji.</span><span class="sxs-lookup"><span data-stu-id="c53cf-336">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="c53cf-337">Dwie funkcje, które zostały dodane dla generatorów kodu, to rozszerzenia \***Składnia metody częściowej**_ i _*_inicjatory modułów_*_.</span><span class="sxs-lookup"><span data-stu-id="c53cf-337">The two features added for code generators are extensions to \***partial method syntax**_, and _*_module initializers_*_.</span></span> <span data-ttu-id="c53cf-338">Najpierw zmiany w metodach częściowych.</span><span class="sxs-lookup"><span data-stu-id="c53cf-338">First, the changes to partial methods.</span></span> <span data-ttu-id="c53cf-339">Przed C# 9,0 metody częściowe są, `private` ale nie można określić modyfikatora dostępu, mają `void` Return i nie mogą mieć `out` parametrów.</span><span class="sxs-lookup"><span data-stu-id="c53cf-339">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="c53cf-340">Te ograniczenia mające na celu, że jeśli nie zostanie podana implementacja metody, kompilator usuwa wszystkie wywołania metody częściowej.</span><span class="sxs-lookup"><span data-stu-id="c53cf-340">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="c53cf-341">Język C# 9,0 usuwa te ograniczenia, ale wymaga, aby częściowa deklaracja metod była implementacją.</span><span class="sxs-lookup"><span data-stu-id="c53cf-341">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="c53cf-342">Generatory kodu mogą zapewnić, że implementacja.</span><span class="sxs-lookup"><span data-stu-id="c53cf-342">Code generators can provide that implementation.</span></span> <span data-ttu-id="c53cf-343">Aby uniknąć wprowadzenia zmiany, kompilator traktuje każdą metodę częściową bez modyfikatora dostępu, aby przestrzegać starych reguł.</span><span class="sxs-lookup"><span data-stu-id="c53cf-343">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="c53cf-344">Jeśli metoda częściowa zawiera `private` modyfikator dostępu, nowe reguły regulują tę metodę częściową.</span><span class="sxs-lookup"><span data-stu-id="c53cf-344">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="c53cf-345">Druga Nowa funkcja dla generatorów kodu jest _ *_inicjatorów modułów_* \*.</span><span class="sxs-lookup"><span data-stu-id="c53cf-345">The second new feature for code generators is _\*_module initializers_\*\*.</span></span> <span data-ttu-id="c53cf-346">Inicjatory modułów to metody, które mają <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> dołączony atrybut.</span><span class="sxs-lookup"><span data-stu-id="c53cf-346">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="c53cf-347">Te metody będą wywoływane przez środowisko uruchomieniowe podczas ładowania zestawu.</span><span class="sxs-lookup"><span data-stu-id="c53cf-347">These methods will be called by the runtime when the assembly loads.</span></span> <span data-ttu-id="c53cf-348">Metoda inicjatora modułu:</span><span class="sxs-lookup"><span data-stu-id="c53cf-348">A module initializer method:</span></span>

- <span data-ttu-id="c53cf-349">Musi być statyczna</span><span class="sxs-lookup"><span data-stu-id="c53cf-349">Must be static</span></span>
- <span data-ttu-id="c53cf-350">Musi być bez parametrów</span><span class="sxs-lookup"><span data-stu-id="c53cf-350">Must be parameterless</span></span>
- <span data-ttu-id="c53cf-351">Musi zwracać typ void</span><span class="sxs-lookup"><span data-stu-id="c53cf-351">Must return void</span></span>
- <span data-ttu-id="c53cf-352">Nie może być metodą generyczną</span><span class="sxs-lookup"><span data-stu-id="c53cf-352">Must not be a generic method</span></span>
- <span data-ttu-id="c53cf-353">Nie może być zawarta w klasie generycznej</span><span class="sxs-lookup"><span data-stu-id="c53cf-353">Must not be contained in a generic class</span></span>
- <span data-ttu-id="c53cf-354">Musi być dostępny z poziomu zawierającego go modułu</span><span class="sxs-lookup"><span data-stu-id="c53cf-354">Must be accessible from the containing module</span></span>

<span data-ttu-id="c53cf-355">Ostatni punkt Bullet efektywnie oznacza, że metoda i jej Klasa zawierająca muszą być wewnętrzne lub publiczne.</span><span class="sxs-lookup"><span data-stu-id="c53cf-355">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="c53cf-356">Metoda nie może być funkcją lokalną.</span><span class="sxs-lookup"><span data-stu-id="c53cf-356">The method can't be a local function.</span></span>
