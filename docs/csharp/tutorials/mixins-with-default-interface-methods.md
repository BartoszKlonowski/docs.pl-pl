---
title: Tworzenie typów mixin przy użyciu domyślnych metod interfejsu
description: Za pomocą domyślnych elementów członkowskich interfejsu można rozszerzyć interfejsy z opcjonalnymi implementacjami domyślnymi dla realizatorów.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: ee0536ef51f9bea3e6851be23cc19fa28cc6916b
ms.sourcegitcommit: 07123a475af89b6da5bb6cc51ea40ab1e8a488f0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/24/2020
ms.locfileid: "80134377"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="872c1-103">Samouczek: Mieszanie funkcji podczas tworzenia klas przy użyciu interfejsów z domyślnymi metodami interfejsu</span><span class="sxs-lookup"><span data-stu-id="872c1-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="872c1-104">Począwszy od języka C# 8.0 w .NET Core 3.0, można zdefiniować implementacji podczas deklarowania członka interfejsu.</span><span class="sxs-lookup"><span data-stu-id="872c1-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="872c1-105">Ta funkcja zapewnia nowe możliwości, w których można zdefiniować domyślne implementacje dla funkcji zadeklarowanych w interfejsach.</span><span class="sxs-lookup"><span data-stu-id="872c1-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="872c1-106">Klasy można wybrać, kiedy zastąpić funkcjonalność, kiedy używać funkcji domyślnych, a kiedy nie zadeklarować obsługę dyskretnych funkcji.</span><span class="sxs-lookup"><span data-stu-id="872c1-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="872c1-107">Ten samouczek zawiera informacje na temat wykonywania następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="872c1-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="872c1-108">Tworzenie interfejsów z implementacjami, które opisują funkcje dyskretne.</span><span class="sxs-lookup"><span data-stu-id="872c1-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="872c1-109">Tworzenie klas, które używają implementacji domyślnych.</span><span class="sxs-lookup"><span data-stu-id="872c1-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="872c1-110">Tworzenie klas, które zastępują niektóre lub wszystkie implementacje domyślne.</span><span class="sxs-lookup"><span data-stu-id="872c1-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="872c1-111">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="872c1-111">Prerequisites</span></span>

<span data-ttu-id="872c1-112">Musisz skonfigurować komputer do uruchamiania .NET Core, w tym kompilatora C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="872c1-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="872c1-113">Kompilator języka C# 8.0 jest dostępny począwszy od [programu Visual Studio 2019 w wersji 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)lub [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="872c1-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="872c1-114">Ograniczenia metod rozszerzenia</span><span class="sxs-lookup"><span data-stu-id="872c1-114">Limitations of extension methods</span></span>

<span data-ttu-id="872c1-115">Jednym ze sposobów zaimplementowania zachowania, które pojawia się jako część interfejsu jest zdefiniowanie [metod rozszerzenia,](../programming-guide/classes-and-structs/extension-methods.md) które zapewniają zachowanie domyślne.</span><span class="sxs-lookup"><span data-stu-id="872c1-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="872c1-116">Interfejsy deklarują minimalny zestaw elementów członkowskich, zapewniając jednocześnie większą powierzchnię dla każdej klasy, która implementuje ten interfejs.</span><span class="sxs-lookup"><span data-stu-id="872c1-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="872c1-117">Na przykład metody rozszerzenia <xref:System.Linq.Enumerable> w dostarczać implementacji dla dowolnej sekwencji być źródłem zapytania LINQ.</span><span class="sxs-lookup"><span data-stu-id="872c1-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="872c1-118">Metody rozszerzenia są rozpoznawane w czasie kompilacji, przy użyciu zadeklarowanego typu zmiennej.</span><span class="sxs-lookup"><span data-stu-id="872c1-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="872c1-119">Klasy, które implementują interfejs może zapewnić lepszą implementację dla każdej metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="872c1-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="872c1-120">Deklaracje zmiennych muszą być zgodne z typem implementacjącym, aby umożliwić kompilatorowi wybranie tej implementacji.</span><span class="sxs-lookup"><span data-stu-id="872c1-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="872c1-121">Gdy typ czasu kompilacji pasuje do interfejsu, wywołanie metody rozpoznawania rozpoznawania metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="872c1-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="872c1-122">Innym problemem z metody rozszerzenia jest, że te metody są dostępne wszędzie tam, gdzie klasa zawierająca metody rozszerzenia jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="872c1-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="872c1-123">Klasy nie mogą zadeklarować, czy powinny lub nie powinny dostarczać funkcje zadeklarowane w metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="872c1-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="872c1-124">Począwszy od języka C# 8.0, można zadeklarować domyślne implementacje jako metody interfejsu.</span><span class="sxs-lookup"><span data-stu-id="872c1-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="872c1-125">Następnie każda klasa automatycznie używa domyślnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="872c1-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="872c1-126">Każda klasa, która może zapewnić lepszą implementację można zastąpić definicję metody interfejsu z lepszym algorytmem.</span><span class="sxs-lookup"><span data-stu-id="872c1-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="872c1-127">W pewnym sensie technika ta brzmi podobnie do tego, jak można użyć [metod rozszerzenia](../programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="872c1-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="872c1-128">W tym artykule dowiesz się, jak domyślne implementacje interfejsu włączyć nowe scenariusze.</span><span class="sxs-lookup"><span data-stu-id="872c1-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="872c1-129">Zaprojektuj aplikację</span><span class="sxs-lookup"><span data-stu-id="872c1-129">Design the application</span></span>

<span data-ttu-id="872c1-130">Należy wziąć pod uwagę aplikację automatyki domowej.</span><span class="sxs-lookup"><span data-stu-id="872c1-130">Consider a home automation application.</span></span> <span data-ttu-id="872c1-131">Prawdopodobnie masz wiele różnych rodzajów świateł i wskaźników, które mogą być używane w całym domu.</span><span class="sxs-lookup"><span data-stu-id="872c1-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="872c1-132">Każde światło musi obsługiwać interfejsy API, aby je włączać i wyłączać oraz zgłaszać bieżący stan.</span><span class="sxs-lookup"><span data-stu-id="872c1-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="872c1-133">Niektóre światła i wskaźniki mogą obsługiwać inne funkcje, takie jak:</span><span class="sxs-lookup"><span data-stu-id="872c1-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="872c1-134">Włącz światło, a następnie wyłącz ją po upływie czasu.</span><span class="sxs-lookup"><span data-stu-id="872c1-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="872c1-135">Migać światło przez pewien czas.</span><span class="sxs-lookup"><span data-stu-id="872c1-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="872c1-136">Niektóre z tych rozszerzonych możliwości mogą być emulowane w urządzeniach obsługujących zestaw minimalny.</span><span class="sxs-lookup"><span data-stu-id="872c1-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="872c1-137">Oznacza to, że zapewnia domyślną implementację.</span><span class="sxs-lookup"><span data-stu-id="872c1-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="872c1-138">W przypadku tych urządzeń, które mają wbudowane więcej funkcji, oprogramowanie urządzenia będzie korzystać z natywnych funkcji.</span><span class="sxs-lookup"><span data-stu-id="872c1-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="872c1-139">W przypadku innych świateł mogą zdecydować się na zaimplementowanie interfejsu i użycie implementacji domyślnej.</span><span class="sxs-lookup"><span data-stu-id="872c1-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="872c1-140">Domyślne elementy członkowskie interfejsu jest lepszym rozwiązaniem dla tego scenariusza niż metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="872c1-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="872c1-141">Autorzy klas mogą kontrolować, które interfejsy zdecydują się zaimplementować.</span><span class="sxs-lookup"><span data-stu-id="872c1-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="872c1-142">Te interfejsy, które wybierają, są dostępne jako metody.</span><span class="sxs-lookup"><span data-stu-id="872c1-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="872c1-143">Ponadto ponieważ domyślne metody interfejsu są domyślnie wirtualne, wysyłka metody zawsze wybiera implementację w klasie.</span><span class="sxs-lookup"><span data-stu-id="872c1-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="872c1-144">Utwórzmy kod, aby zademonstrować te różnice.</span><span class="sxs-lookup"><span data-stu-id="872c1-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="872c1-145">Tworzenie interfejsów</span><span class="sxs-lookup"><span data-stu-id="872c1-145">Create interfaces</span></span>

<span data-ttu-id="872c1-146">Zacznij od utworzenia interfejsu, który definiuje zachowanie dla wszystkich świateł:</span><span class="sxs-lookup"><span data-stu-id="872c1-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="872c1-147">Podstawowe napowietrzne oprawy oświetleniowej może zaimplementować ten interfejs, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="872c1-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="872c1-148">W tym samouczku kod nie dysk urządzeń IoT, ale emuluje te działania, pisząc wiadomości do konsoli.</span><span class="sxs-lookup"><span data-stu-id="872c1-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="872c1-149">Możesz eksplorować kod bez automatyzacji domu.</span><span class="sxs-lookup"><span data-stu-id="872c1-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="872c1-150">Następnie zdefiniujmy interfejs dla światła, które może automatycznie wyłączyć po prze skończeniu limitu czasu:</span><span class="sxs-lookup"><span data-stu-id="872c1-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="872c1-151">Można dodać podstawową implementację do światła napowietrznego, ale lepszym `virtual` rozwiązaniem jest zmodyfikowanie tej definicji interfejsu w celu zapewnienia domyślnej implementacji:</span><span class="sxs-lookup"><span data-stu-id="872c1-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="872c1-152">Dodając tę zmianę, `OverheadLight` klasa może zaimplementować funkcję czasomierza, deklarując obsługę interfejsu:</span><span class="sxs-lookup"><span data-stu-id="872c1-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="872c1-153">Inny typ światła może obsługiwać bardziej zaawansowany protokół.</span><span class="sxs-lookup"><span data-stu-id="872c1-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="872c1-154">Może zapewnić własną implementację dla `TurnOnFor`, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="872c1-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="872c1-155">W przeciwieństwie do nadrzędnych metod `TurnOnFor` klasy `HalogenLight` wirtualnej, deklaracja w klasie nie używa słowa kluczowego. `override`</span><span class="sxs-lookup"><span data-stu-id="872c1-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="872c1-156">Mieszanie i dopasowywki</span><span class="sxs-lookup"><span data-stu-id="872c1-156">Mix and match capabilities</span></span>

<span data-ttu-id="872c1-157">Zalety domyślnych metod interfejsu stają się jaśniejsze w miarę wprowadzania bardziej zaawansowanych funkcji.</span><span class="sxs-lookup"><span data-stu-id="872c1-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="872c1-158">Korzystanie z interfejsów umożliwia mieszanie i dopasowywać możliwości.</span><span class="sxs-lookup"><span data-stu-id="872c1-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="872c1-159">Umożliwia również każdemu autorowi klasy wybór między domyślną implementacją a implementacją niestandardową.</span><span class="sxs-lookup"><span data-stu-id="872c1-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="872c1-160">Dodajmy interfejs z domyślną implementacją migającej kontrolki:</span><span class="sxs-lookup"><span data-stu-id="872c1-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="872c1-161">Domyślna implementacja umożliwia miganie dowolnej lampki.</span><span class="sxs-lookup"><span data-stu-id="872c1-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="872c1-162">Kontrolka napowietrzna może dodać zarówno czasomierz, jak i funkcje migania przy użyciu domyślnej implementacji:</span><span class="sxs-lookup"><span data-stu-id="872c1-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="872c1-163">Nowy typ światła, `LEDLight` obsługuje zarówno funkcję timera, jak i funkcję mrugnięcia bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="872c1-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="872c1-164">Ten lekki styl implementuje zarówno `ITimerLight` interfejsy, jak i `IBlinkingLight` interfejsy i zastępuje `Blink` metodę:</span><span class="sxs-lookup"><span data-stu-id="872c1-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="872c1-165">Może `ExtraFancyLight` obsługiwać funkcje migania i czasomierza bezpośrednio:</span><span class="sxs-lookup"><span data-stu-id="872c1-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="872c1-166">Utworzony `HalogenLight` wcześniej nie obsługuje migania.</span><span class="sxs-lookup"><span data-stu-id="872c1-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="872c1-167">Tak, nie należy `IBlinkingLight` dodawać do listy obsługiwanych interfejsów.</span><span class="sxs-lookup"><span data-stu-id="872c1-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="872c1-168">Wykrywanie typów światła za pomocą dopasowywania wzorców</span><span class="sxs-lookup"><span data-stu-id="872c1-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="872c1-169">Następnie napiszmy kod testowy.</span><span class="sxs-lookup"><span data-stu-id="872c1-169">Next, let's write some test code.</span></span> <span data-ttu-id="872c1-170">Można użyć funkcji [dopasowywania wzorca](../pattern-matching.md) języka C#, aby określić możliwości światła, sprawdzając, które interfejsy obsługuje.</span><span class="sxs-lookup"><span data-stu-id="872c1-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="872c1-171">Następująca metoda wykonuje obsługiwane możliwości każdego światła:</span><span class="sxs-lookup"><span data-stu-id="872c1-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="872c1-172">Poniższy kod `Main` w metodzie tworzy każdy typ światła w sekwencji i testuje to światło:</span><span class="sxs-lookup"><span data-stu-id="872c1-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="872c1-173">Jak kompilator określa najlepszą implementację</span><span class="sxs-lookup"><span data-stu-id="872c1-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="872c1-174">W tym scenariuszu pokazano interfejs podstawowy bez żadnych implementacji.</span><span class="sxs-lookup"><span data-stu-id="872c1-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="872c1-175">Dodanie metody do `ILight` interfejsu wprowadza nowe zawiłości.</span><span class="sxs-lookup"><span data-stu-id="872c1-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="872c1-176">Reguły języka regulujące domyślne metody interfejsu minimalizują wpływ na konkretne klasy, które implementują wiele interfejsów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="872c1-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="872c1-177">Poprawmy oryginalny interfejs za pomocą nowej metody, aby pokazać, jak to zmienia jego użycie.</span><span class="sxs-lookup"><span data-stu-id="872c1-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="872c1-178">Każda lampka kontrolna może zgłaszać swój stan zasilania jako wartość wyliczoną:</span><span class="sxs-lookup"><span data-stu-id="872c1-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="872c1-179">Domyślna implementacja nie przyjmuje żadnych uprawnień:</span><span class="sxs-lookup"><span data-stu-id="872c1-179">The default implementation assumes no power:</span></span>

[!code-csharp[Report a default power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="872c1-180">Te zmiany skompilować czysto, mimo `ExtraFancyLight` że `ILight` deklaruje obsługę interfejsu i `ITimerLight` `IBlinkingLight`interfejsów pochodnych i .</span><span class="sxs-lookup"><span data-stu-id="872c1-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="872c1-181">Istnieje tylko jeden "najbliższy" implementacji `ILight` zadeklarowane w interfejsie.</span><span class="sxs-lookup"><span data-stu-id="872c1-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="872c1-182">Każda klasa, która zadeklarowała zastąpienie stanie się jedyną "najbliższą" implementacją.</span><span class="sxs-lookup"><span data-stu-id="872c1-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="872c1-183">Pokazano przykłady w poprzednich klasach, które przekroczyły członków innych interfejsów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="872c1-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="872c1-184">Należy unikać zastępowania tej samej metody w wielu interfejsach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="872c1-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="872c1-185">W ten sposób tworzy niejednoznaczne wywołanie metody, gdy klasa implementuje zarówno interfejsów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="872c1-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="872c1-186">Kompilator nie można wybrać jedną lepszą metodę, więc generuje błąd.</span><span class="sxs-lookup"><span data-stu-id="872c1-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="872c1-187">Na przykład, jeśli `IBlinkingLight` `ITimerLight` zarówno i zaimplementowane zastąpienie `PowerStatus`, `OverheadLight` musiałby podać bardziej szczegółowe zastąpienie.</span><span class="sxs-lookup"><span data-stu-id="872c1-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="872c1-188">W przeciwnym razie kompilator nie można wybrać między implementacjami w dwóch interfejsów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="872c1-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="872c1-189">Zazwyczaj można uniknąć tej sytuacji, utrzymując definicje interfejsu małe i koncentruje się na jednej funkcji.</span><span class="sxs-lookup"><span data-stu-id="872c1-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="872c1-190">W tym scenariuszu każda funkcja światła jest jego własny interfejs; wiele interfejsów są dziedziczone tylko przez klasy.</span><span class="sxs-lookup"><span data-stu-id="872c1-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="872c1-191">W tym przykładzie przedstawiono jeden scenariusz, w którym można zdefiniować dyskretne funkcje, które można mieszać w klasy.</span><span class="sxs-lookup"><span data-stu-id="872c1-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="872c1-192">Deklarujesz dowolny zestaw obsługiwanych funkcji, deklarując, które interfejsy obsługuje klasa.</span><span class="sxs-lookup"><span data-stu-id="872c1-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="872c1-193">Użycie wirtualnych metod interfejsu domyślnego umożliwia klasom użycie lub zdefiniowanie innej implementacji dla dowolnej lub wszystkich metod interfejsu.</span><span class="sxs-lookup"><span data-stu-id="872c1-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="872c1-194">Ta funkcja językowa zapewnia nowe sposoby modelowania systemów rzeczywistych, które budujesz.</span><span class="sxs-lookup"><span data-stu-id="872c1-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="872c1-195">Domyślne metody interfejsu zapewniają bardziej przejrzysty sposób wyrażania powiązanych klas, które mogą łączyć i łączyć różne funkcje przy użyciu wirtualnych implementacji tych możliwości.</span><span class="sxs-lookup"><span data-stu-id="872c1-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
