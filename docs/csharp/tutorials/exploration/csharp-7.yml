### YamlMime:Tutorial
title: Zapoznaj się z C# 7.0 — C# interaktywnego samouczka
metadata:
  title: Zapoznaj się z C# 7.0 — wypróbuj nowe funkcje w C# 7.0 interaktywnie przy użyciu przeglądarki
  description: W tym samouczku użyjesz przeglądarki, aby zapoznać się z C# 7.0 interaktywnie. Dowiesz się o nowych idiomy, za pomocą C# 7.0, które umożliwiają bardziej zwięzły, czytelny kod.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 70f4e93460c69b54702f160d502163827ec73218
  ms.sourcegitcommit: 0aca6c5d166d7961a1e354c248495645b97a1dc5
  ms.translationtype: MT
  ms.contentlocale: pl-PL
  ms.lasthandoff: 03/30/2019
  ms.locfileid: "58675526"
items:
- durationInMinutes: 1
  content: >
    W tym samouczku pozwala Ci eksplorować C# 7.0 funkcji interaktywnie przy użyciu przeglądarki, aby zapisać C# i wyświetlić wyniki kompilacji i uruchomienia kodu. Przewodnik zawiera serię lekcji, które modyfikują wcześniej C# rozwiązania nowszymi, bardziej zwięzły widok C# funkcje w wersji 7.0. W pozostałej części tego artykułu zawiera omówienie każdego z tych funkcji, za pomocą łącza, aby zapoznać się z każdej funkcji.
- title: Limit deklaracji zmiennych w lokalizacji przypisania
  durationInMinutes: 2
  content: "Istniejące składnia, która obsługuje `out` parametry została ulepszona w tej wersji. Kliknij przycisk *wprowadź trybu koncentracji uwagi* znajdujący się u dołu tej strony, a następnie wypróbuj poniższy kod w oknie interaktywnym: \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\nMożesz teraz zadeklarować `out` zmiennych w liście argumentów wywołania metody, zamiast pisania instrukcji deklaracji oddzielne. Zgłoszenia można przenosić do wywołania metody. Dodaj następujący kod do dolnej części okna interaktywnego:\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\nMożesz zmienić `int` deklaracji `var` deklaracji. Dodaj następujący kod do okna interaktywnego:\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\nNowej składni udostępnia dwie ważne korzyści za pośrednictwem istniejących składni:\n\n* Kod jest łatwiejsza do odczytania. \n    - Można zadeklarować zmiennej poza, której używasz, nie w kolejnym wierszu powyżej.\n* Nie ma potrzeby, aby przypisać wartość początkową.\n    - DEKLARUJĄC `out` zmiennej, w przypadku, gdy jest używany w wywołaniu metody, nie można przypadkowo używać go przed przypisaniem go.\n\nZakres zadeklarowanej zmiennej jest zakres otaczający `if` instrukcji. Dzięki temu można później użyć zmiennej. Modyfikowanie ostatnich `if` blokowania, jak pokazano w poniższym fragmencie kodu.\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: Krotek Tworzenie struktur danych lekki
  durationInMinutes: 1
  content: "Kolekcje są strukturami danych uproszczone, zawierające wiele pól do reprezentowania składowych danych. Pola nie są weryfikowane, a nie można definiować własnych metod.\n\n> [!NOTE]\n> Spójne kolekcje były dostępne przed języka C# 7.0, ale zostały mało wydajne i miał Brak obsługi języka. Oznacza to, że elementy krotki mogą być przywoływane tylko jako `Item1`, `Item2` i tak dalej. C#w wersji 7.0 wprowadzono obsługę krotek, co umożliwia semantycznego nazwy pól krotki przy użyciu nowych typów krotki bardziej wydajne.\n\nMożesz utworzyć krotki przez przypisywanie wartości do każdego nazwanego elementu członkowskiego:\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n`namedLetters` Krotka zawiera pola określone jako `Alpha` i `Beta`. Te nazwy istnieje tylko w czasie kompilacji i nie są zachowywane w czasie wykonywania (podczas sprawdzania spójna kolekcja znajdująca się przy użyciu odbicia, na przykład).\n\nW przypisaniu spójnej kolekcji można również określić nazwy pól po prawej stronie przypisania: \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\nMożna określić nazwy pól po lewej i prawej stronie przypisania, ale nazwy po prawej stronie są ignorowane.\n\nKolekcje są najbardziej przydatne jako typów zwracanych dla `private` i `internal` metody. Kolekcje zapewniają prostą składnię dla tych metod zwrócić wiele wartości dyskretnych.\n\nUtworzenie spójnej kolekcji jest wydajniejsze i bardziej produktywne że tworzenie klasy lub struktury. Posiada prostszy, uproszczone Składnia umożliwiająca zdefiniowanie struktury danych, który zawiera więcej niż jedną wartość. Przykładowa metoda poniżej zwraca minimalne i maksymalne wartości znajdujących się w sekwencji liczb całkowitych:\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\nMogą wystąpić sytuacje, gdy zachodzi potrzeba rozpakować elementy członkowskie spójnej kolekcji, które zostały zwrócone z metody.  Możecie od zadeklarowania zmiennych osobne dla każdej wartości w spójnej kolekcji. Jest to nazywane *dekonstrukcja* spójnej kolekcji. Dodaj następujący kod w przeglądarce, aby spróbować zrobić to:\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\nPodczas pracy z krotkami często znajdziesz nie korzystanie z wszystkich elementów członkowskich wynik spójnej kolekcji. Jeśli tak się stanie, za pomocą można odrzucić jeden lub więcej wartości zwracane `_` zamiast zmiennej. Dodaj następujący kod w przeglądarce, aby spróbować zrobić to:\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\nMożesz dowiedzieć się w bardziej szczegółowe informacje o krotek w [artykułu krotek](../../tuples.md).\nDowiedz się więcej o odrzucenia w [artykułu odrzucenia](../../discards.md).\n"
- title: Użyj wzorca typu przy użyciu wyrażenie
  durationInMinutes: 2
  content: >
    `is` Wyrażenia wzorca rozszerza znanej [ `is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) zapytanie poza jego typ obiektu.


    Wypróbuj poniższy kod w oknie przeglądarki:


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    Zamiast tego zmienić deklaracja zmiennej do ciągu:


    ```csharp

    object count = "5";

    ```


    Teraz `is` wyrażenie jest fałszywe, więc `else` gałęzi jest wykonywany. Spróbuj zmienić `count` do `number` w jeszcze gałęzi:


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    Nie będzie powyższych kompilacji ponieważ `number` nie jest przypisana w `else` gałęzi. Jest tylko przypisana w `true` gałęzi `if` instrukcji.


    `is` Wyrażenia typu wzorzec jest przydatny w przypadku, gdy masz małą liczbą typów na potrzeby testowania wstępnego. Często konieczne może być wiele typów testów. Wymagającym dopasowanie wzorca `switch` instrukcji.
- title: Dopasowanie do wzorca w instrukcji switch
  durationInMinutes: 2
  content: >
    *Pasuje do wyrażenia* ma dobrze znanej składni, w oparciu o `switch` instrukcja jest już częścią języka C#. Zacznijmy od zawierającą niewielką próbkę na podstawie `is` składni wyrażenia, które zostały przedstawione na poprzedniej stronie:


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    Poprzedzający kod sprawdza, czy `int` lub `null`. Każdy inny typ osiągnięto przypadek domyślny. Dodaj następujące dwa wiersze, aby zweryfikować zachowanie:


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    `switch` Wyrażenie zostanie przekonwertowana na typ dopuszczający wartość null dla odpowiedniego typu. Dodaj następujące polecenie, aby zweryfikować:


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    Dowolna liczba innych typów wyrażeń wzorca można dodać do instrukcji switch. Dodaj następujące przed `null` przypadków:


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    Upewnij się, tych prac, dodając następujące testy:


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    Wyrażenia dopasowania również obsługiwać stałe. Aby zaoszczędzić czas, to wyprowadzenie się proste przypadki:


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    Należy dodać poprzednim przypadku *przed* `case int:` wyrażenia. Jeśli dodasz po tego przypadku kompilatora ostrzega o tym, że już został obsłużony przez poprzednią etykietę case.


    Możesz dodać `when` klauzuli się wszelkie wzorzec zamierzone, Zapisz, aby mógł testować inne warunki poza typem lub wartością stałą. Wypróbuj je, dodając następujący przypadek powyżej ogólne `string` przypadków:


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    Przetestuj go, podobny do następującego kodu:


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    Składnia nowych wyrażeniach dopasowania do wzorca ułatwia tworzenie algorytmów wysyłania przy użyciu składni bardziej czytelne i zwięzłe na podstawie typu obiektu lub innych właściwości. Wyrażenia dopasowania wzorca Włącz te konstrukcje na typy danych, które są niezwiązanych ze sobą przez dziedziczenie.


    Dowiedz się więcej o dopasowywaniu do wzorca w artykule dedykowane [dopasowywania wzorca w C# ](../../pattern-matching.md).
- title: Optymalizuj magazynowanie pamięci przy użyciu zmienne lokalne ref i zwraca
  durationInMinutes: 2
  content: >
    Ta funkcja umożliwia algorytmy, które używają i zwracać odwołań do zmiennych określonych gdzie indziej. Przykładem jest duże macierzy, a znalezienie jednej lokalizacji, z określoną wspólną charakterystykę. Jedna metoda zwróci dwa indeksy jednej lokalizacji w macierzy:


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    Można przetestować tę metodę, używając następującego kodu:


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    To `Find` metoda zwraca wskaźników do elementów w macierzy. Prowadzi to obiekty wywołujące do pisania kodu, który używa tych indeksów w celu wyłuskania macierzy i modyfikowania pojedynczego elementu. Należy zamiast napisać metodę, która zwraca *odwołania* do elementu macierzy, który chcesz zmienić.


    Przejdźmy teraz przez szereg zmian, które przedstawiono tu funkcji lokalnego odwołania i pokazują, jak utworzyć metodę, która zwraca odwołanie do pamięci wewnętrznej. Po drodze dowiesz się, zasady zwracane ref i funkcji lokalnych ref, które chronić klientów przed przypadkowym niewłaściwie korzysta.


    Rozpoczynanie pracy od modyfikowania `Find` deklaracji metody, tak że zwraca `ref int` zamiast spójnej kolekcji.


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    Zmodyfikuj instrukcję return do zwrócenia elementu na poprawne indeksów:


    ```csharp

    return matrix[i,j];

    ```


    Ostateczny powrót do zgłaszania wyjątków, zamiast tego zmiany:


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    Pamiętaj, że nie będzie to kompilacji. Deklaracja metody wskazuje `ref` zwrotu, ale instrukcja return określa wartość zwracaną. Należy dodać `ref` — słowo kluczowe do każdej instrukcji return. Oznacza to zwracanie przez odwołanie, a następnie pomaga deweloperom czytania dalszej części kodu, należy pamiętać, że metoda zwraca wartość przez odwołanie:


    ```csharp

    return ref matrix[i,j];

    ```


    Teraz, metoda zwraca odwołanie do wartości całkowitej w macierzy, należy zmodyfikować, gdzie jest wywoływana. `var` Deklaracji oznacza, że `valItem` jest teraz `int` zamiast spójnej kolekcji. Zmień kod wywołujący na następujący:


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    Drugi `WriteLine` instrukcja w powyższym przykładzie drukuje się wartość `42`, a nie `24`. Zmienna `valItem` jest `int`, a nie `ref int`. `var` — Słowo kluczowe umożliwia kompilatorowi Określ typ, ale nie spowoduje dodanie niejawnie `ref` modyfikator. Zamiast tego wartość odwołuje się `ref return` jest *skopiowane* do zmiennej po lewej stronie przypisania. Zmienna nie jest `ref` lokalnego.


    Aby zmodyfikować zwracane odwołanie, musisz dodać `ref` modyfikator deklaracji zmiennej lokalnej i przed wywołaniem do `Find` do ustaw dla zmiennej odwołania, gdy wartość zwracana jest odwołaniem. Zmodyfikuj kod testu w przeglądarce, aby dopasować następujące czynności:


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    Teraz, drugi `WriteLine` instrukcja w powyższym przykładzie drukuje się wartość `24`, wskazującą, czy zostały zmodyfikowane magazynu w macierzy. Zmienna lokalna została zadeklarowana przy użyciu `ref` modyfikator i potrwa `ref` powrócić. Należy zainicjować `ref` zmiennej gdy jest on zadeklarowany; nie można podzielić deklaracji i inicjowania.


    W języku C# ma trzy inne reguły, które można chronić przed używaniem `ref` zmiennych lokalnych i zwraca:


    * Nie można przypisać wartość zwracaną standardową metodę, aby `ref` zmiennej lokalnej.

    * Nie można zwrócić `ref` do zmiennej, którego okres istnienia nie wykracza poza wykonywanie metody.

    * `ref` Zmienne lokalne i nie można używać metod asynchronicznych.


    Zmienne lokalne ref i ref zwraca algorytmy Włącz, które są bardziej wydajne, unikając kopiowania wartości lub wykonywanie operacji dereferencji wiele razy.


    Aby uzyskać więcej informacji, zobacz [ref — słowo kluczowe](../../language-reference/keywords/ref.md) artykułu.
- title: Minimalizacja dostępu kodu, korzystając z funkcji lokalnych
  durationInMinutes: 2
  content: "Możesz teraz zadeklarować funkcje lokalne, które są zagnieżdżone w innych funkcjach. Dzięki temu można zminimalizować widoczność tych funkcji. Istnieją trzy przypadki użycia oczywiste funkcje lokalne:\n\n- Funkcje rekursywne.\n- Metody iteratorów.\n- Metody asynchroniczne.\n\nZacznijmy od metody cykliczne. Wypróbuj poniższy kod w przeglądarce, aby obliczyć `6!` (silnię):\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\nFunkcje lokalne są doskonałym sposobem realizowania algorytmy cykliczne. Inne typowe zastosowania są przeznaczone dla metod publicznych iteratora i metod asynchronicznych publicznych. Oba rodzaje metod wygenerować kod, który zgłasza błędy nowsze niż programiści mogą oczekiwać. W przypadku metody iteracyjne wszelkie wyjątki pojawiają się tylko podczas wywoływania kodu, który wylicza zwracanej sekwencji. W przypadku metod asynchronicznych wyjątków tylko obserwuje się kiedy zwracanego `Task` jest oczekiwane.\n\nMetody iteratorów są łatwiejsze do eksplorowania na przeglądarce, więc ich użyć w tej prezentacji. Wypróbuj poniższy kod, który wywołuje metodę iteratora w przeglądarce:\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\nUruchom kod. Należy zauważyć, że wyjątek jest zgłaszany, gdy kod, który zaczyna się iteracja drugi zestaw wyników. Kod, który iteruje po pierwszy zestaw wyników zostało już uruchomione. W tym przykładzie jest zarówno małe i nie zmienia się wszelkich struktur danych dso jest nieszkodliwe i łatwo rozwiązać. Jednak w większego programu, gdzie dwa obiekty iteratora może zostać utworzony za pomocą podrzędnej różnych metod głównego przyczyną może być trudne do znalezienia. Pierwsza metoda iteratora, zmiana stanu danych, można nawet powodować uszkodzenie danych. Wolisz, czy wyjątek został zgłoszony natychmiast, zanim wszystkie zadania są wykonywane. Można zrefaktoryzuj kod, tak aby publiczny metoda sprawdza wszystkie argumenty, a funkcja lokalna, która wykonuje wyliczenia:\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\nPoprzednią sprawia, że Wyczyść, do której odwołanie lokalne metody tylko w kontekście metodzie zewnętrznej. Reguły dotyczące funkcji lokalnych upewnij się, Projektant nie może przypadkowo wywołania funkcji lokalnej z innej lokalizacji w klasie i pominąć walidacji argumentów.\n\nMożna zastosować za pomocą tej samej techniki `async` metod w celu zapewnienia, że wynikające z walidacji argumentów zgłaszania wyjątków przed rozpoczęciem pracy asynchronicznej.\n\n> [!NOTE]\n> Niektóre projekty, które są obsługiwane przez funkcje lokalne mogą być również wykonywane przy użyciu *wyrażeń lambda*. Te zainteresowane można [Dowiedz się więcej o różnicach](../../local-functions-vs-lambdas.md).\n"
- content: Ukończono eksploracji główne nowe funkcje w C# 7. Teraz wypróbuj je w swoich aplikacjach. Można zobaczyć pełną listę w [nowości C# 7](../../whats-new/csharp-7.md) artykułu.
