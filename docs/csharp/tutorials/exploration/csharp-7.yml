### YamlMime:Tutorial
title: <span data-ttu-id="acbb7-101">Zapoznaj się z C# 7.0 — C# interaktywnego samouczka</span><span class="sxs-lookup"><span data-stu-id="acbb7-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: Zapoznaj się z C# 7.0 — wypróbuj nowe funkcje w C# 7.0 interaktywnie przy użyciu przeglądarki
  description: W tym samouczku użyjesz przeglądarki, aby zapoznać się z C# 7.0 interaktywnie. Dowiesz się o nowych idiomy, za pomocą C# 7.0, które umożliwiają bardziej zwięzły, czytelny kod.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: f488d6c05a8be1b2e6ad73d241533ac23b65b9ce
  ms.sourcegitcommit: 15ab532fd5e1f8073a4b678922d93b68b521bfa0
  ms.translationtype: HT
  ms.contentlocale: pl-PL
  ms.lasthandoff: 03/29/2019
  ms.locfileid: "58655538"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="acbb7-105">W tym samouczku pozwala Ci eksplorować C# 7.0 funkcji interaktywnie przy użyciu przeglądarki, aby zapisać C# i wyświetlić wyniki kompilacji i uruchomienia kodu.</span><span class="sxs-lookup"><span data-stu-id="acbb7-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="acbb7-106">Przewodnik zawiera serię lekcji, które modyfikują wcześniej C# rozwiązania nowszymi, bardziej zwięzły widok C# funkcje w wersji 7.0.</span><span class="sxs-lookup"><span data-stu-id="acbb7-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="acbb7-107">W pozostałej części tego artykułu zawiera omówienie każdego z tych funkcji, za pomocą łącza, aby zapoznać się z każdej funkcji.</span><span class="sxs-lookup"><span data-stu-id="acbb7-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="acbb7-108">Limit deklaracji zmiennych w lokalizacji przypisania</span><span class="sxs-lookup"><span data-stu-id="acbb7-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"acbb7-109\">Istniejące składnia, która obsługuje `out` parametry została ulepszona w tej wersji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"acbb7-110\">Kliknij przycisk *wprowadź trybu koncentracji uwagi* znajdujący się u dołu tej strony, a następnie wypróbuj poniższy kod w oknie interaktywnym:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"acbb7-111\">Możesz teraz zadeklarować `out` zmiennych w liście argumentów wywołania metody, zamiast pisania instrukcji deklaracji oddzielne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"acbb7-112\">Zgłoszenia można przenosić do wywołania metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"acbb7-113\">Dodaj następujący kod do dolnej części okna interaktywnego:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"acbb7-114\">Możesz zmienić `int` deklaracji `var` deklaracji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"acbb7-115\">Dodaj następujący kod do okna interaktywnego:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"acbb7-116\">Nowej składni udostępnia dwie ważne korzyści za pośrednictwem istniejących składni:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"acbb7-117\">Kod jest łatwiejsza do odczytania.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"acbb7-118\">Można zadeklarować zmiennej poza, której używasz, nie w kolejnym wierszu powyżej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"acbb7-119\">Nie ma potrzeby, aby przypisać wartość początkową.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"acbb7-120\">DEKLARUJĄC `out` zmiennej, w przypadku, gdy jest używany w wywołaniu metody, nie można przypadkowo używać go przed przypisaniem go.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"acbb7-121\">Zakres zadeklarowanej zmiennej jest zakres otaczający `if` instrukcji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"acbb7-122\">Dzięki temu można później użyć zmiennej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"acbb7-123\">Modyfikowanie ostatnich `if` blokowania, jak pokazano w poniższym fragmencie kodu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="acbb7-124">Krotek Tworzenie struktur danych lekki</span><span class="sxs-lookup"><span data-stu-id="acbb7-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"acbb7-125\">Kolekcje są strukturami danych uproszczone, zawierające wiele pól do reprezentowania składowych danych.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"acbb7-126\">Pola nie są weryfikowane, a nie można definiować własnych metod.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"acbb7-127\">Spójne kolekcje były dostępne przed języka C# 7.0, ale zostały mało wydajne i miał Brak obsługi języka.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"acbb7-128\">Oznacza to, że elementy krotki mogą być przywoływane tylko jako `Item1`, `Item2` i tak dalej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"acbb7-129\">C#w wersji 7.0 wprowadzono obsługę krotek, co umożliwia semantycznego nazwy pól krotki przy użyciu nowych typów krotki bardziej wydajne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"acbb7-130\">Możesz utworzyć krotki przez przypisywanie wartości do każdego nazwanego elementu członkowskiego:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"acbb7-131\">`namedLetters` Krotka zawiera pola określone jako `Alpha` i `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"acbb7-132\">Te nazwy istnieje tylko w czasie kompilacji i nie są zachowywane w czasie wykonywania (podczas sprawdzania spójna kolekcja znajdująca się przy użyciu odbicia, na przykład).</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"acbb7-133\">W przypisaniu spójnej kolekcji można również określić nazwy pól po prawej stronie przypisania:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"acbb7-134\">Można określić nazwy pól po lewej i prawej stronie przypisania, ale nazwy po prawej stronie są ignorowane.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"acbb7-135\">Kolekcje są najbardziej przydatne jako typów zwracanych dla `private` i `internal` metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"acbb7-136\">Kolekcje zapewniają prostą składnię dla tych metod zwrócić wiele wartości dyskretnych.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"acbb7-137\">Utworzenie spójnej kolekcji jest wydajniejsze i bardziej produktywne że tworzenie klasy lub struktury.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"acbb7-138\">Posiada prostszy, uproszczone Składnia umożliwiająca zdefiniowanie struktury danych, który zawiera więcej niż jedną wartość.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"acbb7-139\">Przykładowa metoda poniżej zwraca minimalne i maksymalne wartości znajdujących się w sekwencji liczb całkowitych:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-139\">The example method below returns the minimum and maximum values found in a sequence of integers:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"acbb7-140\">Mogą wystąpić sytuacje, gdy zachodzi potrzeba rozpakować elementy członkowskie spójnej kolekcji, które zostały zwrócone z metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-140\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"acbb7-141\">Możecie od zadeklarowania zmiennych osobne dla każdej wartości w spójnej kolekcji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-141\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"acbb7-142\">Jest to nazywane *dekonstrukcja* spójnej kolekcji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-142\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"acbb7-143\">Dodaj następujący kod w przeglądarce, aby spróbować zrobić to:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-143\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"acbb7-144\">Podczas pracy z krotkami często znajdziesz nie korzystanie z wszystkich elementów członkowskich wynik spójnej kolekcji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-144\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"acbb7-145\">Jeśli tak się stanie, za pomocą można odrzucić jeden lub więcej wartości zwracane `_` zamiast zmiennej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-145\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"acbb7-146\">Dodaj następujący kod w przeglądarce, aby spróbować zrobić to:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-146\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"acbb7-147\">Możesz dowiedzieć się w bardziej szczegółowe informacje o krotek w [artykułu krotek](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-147\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"acbb7-148\">Dowiedz się więcej o odrzucenia w [artykułu odrzucenia](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-148\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="acbb7-149">Użyj wzorca typu przy użyciu wyrażenie</span><span class="sxs-lookup"><span data-stu-id="acbb7-149">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="acbb7-150">`is` Wyrażenia wzorca rozszerza znanej [ `is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) zapytanie poza jego typ obiektu.</span><span class="sxs-lookup"><span data-stu-id="acbb7-150">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="acbb7-151">Wypróbuj poniższy kod w oknie przeglądarki:</span><span class="sxs-lookup"><span data-stu-id="acbb7-151">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="acbb7-152">Zamiast tego zmienić deklaracja zmiennej do ciągu:</span><span class="sxs-lookup"><span data-stu-id="acbb7-152">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="acbb7-153">Teraz `is` wyrażenie jest fałszywe, więc `else` gałęzi jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="acbb7-153">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="acbb7-154">Spróbuj zmienić `count` do `number` w jeszcze gałęzi:</span><span class="sxs-lookup"><span data-stu-id="acbb7-154">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="acbb7-155">Nie będzie powyższych kompilacji ponieważ `number` nie jest przypisana w `else` gałęzi.</span><span class="sxs-lookup"><span data-stu-id="acbb7-155">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="acbb7-156">Jest tylko przypisana w `true` gałęzi `if` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="acbb7-156">It's only assigned in the `true` branch of the `if` statement.</span></span>


    > [!NOTE]

    > <span data-ttu-id="acbb7-157">Brak [problem](https://github.com/dotnet/try/issues/175) gdzie mogą uzyskać nieprawidłowych danych wyjściowych w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="acbb7-157">There is an [issue](https://github.com/dotnet/try/issues/175) where you may get incorrect output in the preceding example.</span></span>


    <span data-ttu-id="acbb7-158">`is` Wyrażenia typu wzorzec jest przydatny w przypadku, gdy masz małą liczbą typów na potrzeby testowania wstępnego.</span><span class="sxs-lookup"><span data-stu-id="acbb7-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="acbb7-159">Często konieczne może być wiele typów testów.</span><span class="sxs-lookup"><span data-stu-id="acbb7-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="acbb7-160">Wymagającym dopasowanie wzorca `switch` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="acbb7-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="acbb7-161">Dopasowanie do wzorca w instrukcji switch</span><span class="sxs-lookup"><span data-stu-id="acbb7-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="acbb7-162">*Pasuje do wyrażenia* ma dobrze znanej składni, w oparciu o `switch` instrukcja jest już częścią języka C#.</span><span class="sxs-lookup"><span data-stu-id="acbb7-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="acbb7-163">Zacznijmy od zawierającą niewielką próbkę na podstawie `is` składni wyrażenia, które zostały przedstawione na poprzedniej stronie:</span><span class="sxs-lookup"><span data-stu-id="acbb7-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="acbb7-164">Poprzedzający kod sprawdza, czy `int` lub `null`.</span><span class="sxs-lookup"><span data-stu-id="acbb7-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="acbb7-165">Każdy inny typ osiągnięto przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="acbb7-165">Every other type reached the default case.</span></span> <span data-ttu-id="acbb7-166">Dodaj następujące dwa wiersze, aby zweryfikować zachowanie:</span><span class="sxs-lookup"><span data-stu-id="acbb7-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="acbb7-167">`switch` Wyrażenie zostanie przekonwertowana na typ dopuszczający wartość null dla odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="acbb7-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="acbb7-168">Dodaj następujące polecenie, aby zweryfikować:</span><span class="sxs-lookup"><span data-stu-id="acbb7-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="acbb7-169">Dowolna liczba innych typów wyrażeń wzorca można dodać do instrukcji switch.</span><span class="sxs-lookup"><span data-stu-id="acbb7-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="acbb7-170">Dodaj następujące przed `null` przypadków:</span><span class="sxs-lookup"><span data-stu-id="acbb7-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="acbb7-171">Upewnij się, tych prac, dodając następujące testy:</span><span class="sxs-lookup"><span data-stu-id="acbb7-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="acbb7-172">Wyrażenia dopasowania również obsługiwać stałe.</span><span class="sxs-lookup"><span data-stu-id="acbb7-172">The match expressions also support constants.</span></span> <span data-ttu-id="acbb7-173">Aby zaoszczędzić czas, to wyprowadzenie się proste przypadki:</span><span class="sxs-lookup"><span data-stu-id="acbb7-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="acbb7-174">Należy dodać poprzednim przypadku *przed* `case int:` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="acbb7-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="acbb7-175">Jeśli dodasz po tego przypadku kompilatora ostrzega o tym, że już został obsłużony przez poprzednią etykietę case.</span><span class="sxs-lookup"><span data-stu-id="acbb7-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="acbb7-176">Możesz dodać `when` klauzuli się wszelkie wzorzec zamierzone, Zapisz, aby mógł testować inne warunki poza typem lub wartością stałą.</span><span class="sxs-lookup"><span data-stu-id="acbb7-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="acbb7-177">Wypróbuj je, dodając następujący przypadek powyżej ogólne `string` przypadków:</span><span class="sxs-lookup"><span data-stu-id="acbb7-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="acbb7-178">Przetestuj go, podobny do następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="acbb7-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="acbb7-179">Składnia nowych wyrażeniach dopasowania do wzorca ułatwia tworzenie algorytmów wysyłania przy użyciu składni bardziej czytelne i zwięzłe na podstawie typu obiektu lub innych właściwości.</span><span class="sxs-lookup"><span data-stu-id="acbb7-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="acbb7-180">Wyrażenia dopasowania wzorca Włącz te konstrukcje na typy danych, które są niezwiązanych ze sobą przez dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="acbb7-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="acbb7-181">Dowiedz się więcej o dopasowywaniu do wzorca w artykule dedykowane [dopasowywania wzorca w C# ](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="acbb7-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="acbb7-182">Optymalizuj magazynowanie pamięci przy użyciu zmienne lokalne ref i zwraca</span><span class="sxs-lookup"><span data-stu-id="acbb7-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"acbb7-183\">Ta funkcja umożliwia algorytmy, które używają i zwracać odwołań do zmiennych określonych gdzie indziej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-183\">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id=\"acbb7-184\">Przykładem jest duże macierzy, a znalezienie jednej lokalizacji, z określoną wspólną charakterystykę.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-184\">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id=\"acbb7-185\">Jedna metoda zwróci dwa indeksy jednej lokalizacji w macierzy:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-185\">One method would return the two indices a single location in the matrix:</span></span>\n\n```csharp\npublic class Program\n{\n    private static (int i, int j) Find(int[,] matrix, Func<int, bool> predicate)\n    {\n        for (int i = 0; i < matrix.GetLength(0); i++)\n            for (int j = 0; j < matrix.GetLength(1); j++)\n                if (predicate(matrix[i, j]))\n                    return (i, j);\n        return (-1, -1); // Not found\n    }\n\n    public static void Main()\n    {\n        int[,] sourceMatrix = new int[10, 10];\n        for (int x = 0; x < 10; x++)\n            for (int y = 0; y < 10; y++)\n                sourceMatrix[x, y] = x * 10 + y;\n\n        var indices = Find(sourceMatrix, (val) => val == 42);\n        Console.WriteLine(indices);\n        sourceMatrix[indices.i, indices.j] = 24;        \n    }\n\n}\n```\n\n\n<span data-ttu-id=\"acbb7-186\">To `Find` metoda zwraca wskaźników do elementów w macierzy.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-186\">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id=\"acbb7-187\">Prowadzi to obiekty wywołujące do pisania kodu, który używa tych indeksów w celu wyłuskania macierzy i modyfikowania pojedynczego elementu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-187\">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id=\"acbb7-188\">Należy zamiast napisać metodę, która zwraca *odwołania* do elementu macierzy, który chcesz zmienić.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-188\">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>\n\n<span data-ttu-id=\"acbb7-189\">Przejdźmy teraz przez szereg zmian, które przedstawiono tu funkcji lokalnego odwołania i pokazują, jak utworzyć metodę, która zwraca odwołanie do pamięci wewnętrznej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-189\">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id=\"acbb7-190\">Po drodze dowiesz się, zasady zwracane ref i funkcji lokalnych ref, które chronić klientów przed przypadkowym niewłaściwie korzysta.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-190\">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>\n\n<span data-ttu-id=\"acbb7-191\">Rozpoczynanie pracy od modyfikowania `Find` deklaracji metody, tak że zwraca `ref int` zamiast spójnej kolekcji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-191\">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>\n\n```csharp\nprivate static ref int Find(int[,] matrix, Func<int, bool> predicate)\n```\n\n<span data-ttu-id=\"acbb7-192\">Zmodyfikuj instrukcję return do zwrócenia elementu na poprawne indeksów:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-192\">Modify the return statement to return the item at the correct indices:</span></span>\n\n```csharp\nreturn matrix[i,j];\n```\n\n<span data-ttu-id=\"acbb7-193\">Ostateczny powrót do zgłaszania wyjątków, zamiast tego zmiany:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-193\">Change the final return to throw an exception instead:</span></span>\n\n```csharp\nthrow new InvalidOperationException(\"Not found\");\n```\n\n<span data-ttu-id=\"acbb7-194\">Pamiętaj, że nie będzie to kompilacji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-194\">Note that this won't compile.</span></span> <span data-ttu-id=\"acbb7-195\">Deklaracja metody wskazuje `ref` zwrotu, ale instrukcja return określa wartość zwracaną.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-195\">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id=\"acbb7-196\">Należy dodać `ref` — słowo kluczowe do każdej instrukcji return.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-196\">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id=\"acbb7-197\">Oznacza to zwracanie przez odwołanie, a następnie pomaga deweloperom czytania dalszej części kodu, należy pamiętać, że metoda zwraca wartość przez odwołanie:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-197\">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>\n\n```csharp\nreturn ref matrix[i,j];\n```\n\n<span data-ttu-id=\"acbb7-198\">Teraz, metoda zwraca odwołanie do wartości całkowitej w macierzy, należy zmodyfikować, gdzie jest wywoływana.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-198\">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id=\"acbb7-199\">`var` Deklaracji oznacza, że `valItem` jest teraz `int` zamiast spójnej kolekcji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-199\">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id=\"acbb7-200\">Zmień kod wywołujący w `Main` metody do następującego:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-200\">Change the calling code in the `Main` method to the following:</span></span>\n\n```csharp\nvar valItem = Find(matrix, (val) => val == 42);\nConsole.WriteLine(valItem);\nvalItem = 24;\nConsole.WriteLine(matrix[4, 2]);\n```\n\n<span data-ttu-id=\"acbb7-201\">Drugi `WriteLine` instrukcja w powyższym przykładzie drukuje się wartość `42`, a nie `24`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-201\">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id=\"acbb7-202\">Zmienna `valItem` jest `int`, a nie `ref int`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-202\">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id=\"acbb7-203\">`var` — Słowo kluczowe umożliwia kompilatorowi Określ typ, ale nie spowoduje dodanie niejawnie `ref` modyfikator.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-203\">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id=\"acbb7-204\">Zamiast tego wartość odwołuje się `ref return` jest *skopiowane* do zmiennej po lewej stronie przypisania.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-204\">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id=\"acbb7-205\">Zmienna nie jest `ref` lokalnego.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-205\">The variable is not a `ref` local.</span></span>\n\n<span data-ttu-id=\"acbb7-206\">Aby zmodyfikować zwracane odwołanie, musisz dodać `ref` modyfikator deklaracji zmiennej lokalnej i przed wywołaniem do `Find` do ustaw dla zmiennej odwołania, gdy wartość zwracana jest odwołaniem.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-206\">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id=\"acbb7-207\">Modyfikowanie `Main` metody w przeglądarce, aby dopasować następujące czynności:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-207\">Modify the `Main` method in your browser to match the following:</span></span>\n\n```csharp\npublic static void Main()\n{\n    int[,] sourceMatrix = new int[10, 10];\n    for (int x = 0; x < 10; x++)\n        for (int y = 0; y < 10; y++)\n            sourceMatrix[x, y] = x * 10 + y;\n\n    ref var item = ref Find(sourceMatrix, (val) => val == 42);\n    Console.WriteLine(item);\n    item = 24;\n    Console.WriteLine(sourceMatrix[4, 2]);\n}\n```\n\n<span data-ttu-id=\"acbb7-208\">Teraz, drugi `WriteLine` instrukcja w powyższym przykładzie drukuje się wartość `24`, wskazującą, czy zostały zmodyfikowane magazynu w macierzy.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-208\">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id=\"acbb7-209\">Zmienna lokalna została zadeklarowana przy użyciu `ref` modyfikator i potrwa `ref` powrócić.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-209\">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id=\"acbb7-210\">Należy zainicjować `ref` zmiennej gdy jest on zadeklarowany; nie można podzielić deklaracji i inicjowania.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-210\">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>\n\n<span data-ttu-id=\"acbb7-211\">W języku C# ma trzy inne reguły, które można chronić przed używaniem `ref` zmiennych lokalnych i zwraca:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-211\">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>\n\n* <span data-ttu-id=\"acbb7-212\">Nie można przypisać wartość zwracaną standardową metodę, aby `ref` zmiennej lokalnej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-212\">You cannot assign a standard method return value to a `ref` local variable.</span></span>\n* <span data-ttu-id=\"acbb7-213\">Nie można zwrócić `ref` do zmiennej, którego okres istnienia nie wykracza poza wykonywanie metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-213\">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>\n* <span data-ttu-id=\"acbb7-214\">`ref` Zmienne lokalne i nie można używać metod asynchronicznych.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-214\">`ref` locals and returns can't be used with async methods.</span></span>\n\n<span data-ttu-id=\"acbb7-215\">Zmienne lokalne ref i ref zwraca algorytmy Włącz, które są bardziej wydajne, unikając kopiowania wartości lub wykonywanie operacji dereferencji wiele razy.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-215\">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>\n\n<span data-ttu-id=\"acbb7-216\">Aby uzyskać więcej informacji, zobacz [ref — słowo kluczowe](../../language-reference/keywords/ref.md) artykułu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-216\">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>\n"
- title: <span data-ttu-id="acbb7-217">Minimalizacja dostępu kodu, korzystając z funkcji lokalnych</span><span class="sxs-lookup"><span data-stu-id="acbb7-217">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"acbb7-218\">Możesz teraz zadeklarować funkcje lokalne, które są zagnieżdżone w innych funkcjach.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-218\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"acbb7-219\">Dzięki temu można zminimalizować widoczność tych funkcji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-219\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"acbb7-220\">Istnieją trzy przypadki użycia oczywiste funkcje lokalne:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-220\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"acbb7-221\">Funkcje rekursywne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-221\">Recursive functions.</span></span>\n- <span data-ttu-id=\"acbb7-222\">Metody iteratorów.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-222\">Iterator methods.</span></span>\n- <span data-ttu-id=\"acbb7-223\">Metody asynchroniczne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-223\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"acbb7-224\">Zacznijmy od metody cykliczne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-224\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"acbb7-225\">Wypróbuj poniższy kod w przeglądarce, aby obliczyć `6!` (silnię):</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-225\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"acbb7-226\">Funkcje lokalne są doskonałym sposobem realizowania algorytmy cykliczne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-226\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"acbb7-227\">Inne typowe zastosowania są przeznaczone dla metod publicznych iteratora i metod asynchronicznych publicznych.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-227\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"acbb7-228\">Oba rodzaje metod wygenerować kod, który zgłasza błędy nowsze niż programiści mogą oczekiwać.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-228\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"acbb7-229\">W przypadku metody iteracyjne wszelkie wyjątki pojawiają się tylko podczas wywoływania kodu, który wylicza zwracanej sekwencji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-229\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"acbb7-230\">W przypadku metod asynchronicznych wyjątków tylko obserwuje się kiedy zwracanego `Task` jest oczekiwane.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-230\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"acbb7-231\">Metody iteratorów są łatwiejsze do eksplorowania na przeglądarce, więc ich użyć w tej prezentacji.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-231\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"acbb7-232\">Wypróbuj poniższy kod, który wywołuje metodę iteratora w przeglądarce:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-232\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"acbb7-233\">Uruchom kod.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-233\">Run the code.</span></span> <span data-ttu-id=\"acbb7-234\">Należy zauważyć, że wyjątek jest zgłaszany, gdy kod, który zaczyna się iteracja drugi zestaw wyników.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-234\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"acbb7-235\">Kod, który iteruje po pierwszy zestaw wyników zostało już uruchomione.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-235\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"acbb7-236\">W tym przykładzie jest zarówno małe i nie zmienia się wszelkich struktur danych dso jest nieszkodliwe i łatwo rozwiązać.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-236\">This sample is both small and doesn't change any data structures, dso it's harmless and easy to fix.</span></span> <span data-ttu-id=\"acbb7-237\">Jednak w większego programu, gdzie dwa obiekty iteratora może zostać utworzony za pomocą podrzędnej różnych metod głównego przyczyną może być trudne do znalezienia.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-237\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"acbb7-238\">Pierwsza metoda iteratora, zmiana stanu danych, można nawet powodować uszkodzenie danych.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-238\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"acbb7-239\">Wolisz, czy wyjątek został zgłoszony natychmiast, zanim wszystkie zadania są wykonywane.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-239\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"acbb7-240\">Można zrefaktoryzuj kod, tak aby publiczny metoda sprawdza wszystkie argumenty, a funkcja lokalna, która wykonuje wyliczenia:</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-240\">You can refactor the code so that the public method validates all arguments, and a local function that performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"acbb7-241\">Poprzednią sprawia, że Wyczyść, do której odwołanie lokalne metody tylko w kontekście metodzie zewnętrznej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-241\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"acbb7-242\">Reguły dotyczące funkcji lokalnych upewnij się, Projektant nie może przypadkowo wywołania funkcji lokalnej z innej lokalizacji w klasie i pominąć walidacji argumentów.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-242\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"acbb7-243\">Można zastosować za pomocą tej samej techniki `async` metod w celu zapewnienia, że wynikające z walidacji argumentów zgłaszania wyjątków przed rozpoczęciem pracy asynchronicznej.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-243\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"acbb7-244\">Niektóre projekty, które są obsługiwane przez funkcje lokalne mogą być również wykonywane przy użyciu *wyrażeń lambda*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-244\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"acbb7-245\">Te zainteresowane można [Dowiedz się więcej o różnicach](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"acbb7-245\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="acbb7-246">Ukończono eksploracji główne nowe funkcje w C# 7.</span><span class="sxs-lookup"><span data-stu-id="acbb7-246">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="acbb7-247">Teraz wypróbuj je w swoich aplikacjach.</span><span class="sxs-lookup"><span data-stu-id="acbb7-247">Now try them yourself in your applications.</span></span> <span data-ttu-id="acbb7-248">Można zobaczyć pełną listę w [nowości C# 7](../../whats-new/csharp-7.md) artykułu.</span><span class="sxs-lookup"><span data-stu-id="acbb7-248">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
