### YamlMime:Tutorial
title: Zapoznaj się z samouczkiem C# 6 — C# interactive C#
metadata:
  title: Poznaj C# 6 - Wypróbuj nowe funkcje w języku C# 6 interaktywnie, korzystając z przeglądarki
  description: W tym samouczku użyjesz przeglądarki, aby interaktywnie eksplorować język C# 6. Będziesz eksplorować nowe idiomy, których można używać z C# 6, które umożliwiają bardziej zwięzły i czytelny kod.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 594ae1530ac9ef41d6f3200b3e218db026552b95
  ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
  ms.translationtype: MT
  ms.contentlocale: pl-PL
  ms.lasthandoff: 03/14/2020
  ms.locfileid: "78240405"
items:
- durationInMinutes: 1
  content: >
    Ten samouczek umożliwia interakcyjne eksplorowanie języka C# 6 przy użyciu przeglądarki do pisania języka C# i wyświetlanie wyników kompilowania i uruchamiania kodu. Zawiera serię lekcji, które modyfikują wcześniejsze praktyki Języka C#, aby używać nowszych, bardziej zwięzłych funkcji języka C# 6. W dalszej części tego artykułu zawiera omówienie każdej z tych funkcji, z linkiem do eksplorowania każdej funkcji.
- title: Właściwości automatyczne tylko do odczytu umożliwiają typy tylko do odczytu
  durationInMinutes: 2
  content: "Dwa ulepszenia składni właściwości automatycznych ułatwiają używanie właściwości automatycznych w większej liczbie miejsc: właściwości automatyczne tylko do odczytu i inicjaty właściwości automatycznych. Rozważmy ten mały program:\n\n[!code-csharp[Starter](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n Wejdź w tryb fokusu, skopiuj poprzedni kod do interaktywnego okna języka C#. Następnie wybierz *pozycję Uruchom,* aby zobaczyć, co robi kod. `AllCaps`ma niepożądane działanie niepożądane modyfikowania wartości właściwości wraz z zwracaniem ciągu wielkich liter. Autor `Person` klasy przeznaczone ciągi dla `FirstName` i `LastName` być tylko do odczytu. Z C# 6, można dokonać tej intencji jasne. Usuń `private set` z obu właściwości, aby utworzyć właściwość auto tylko do odczytu. Wybierz *Uruchom,* aby zobaczyć, że kompilator plamy dwie lokalizacje, gdzie `FirstName` i `LastName` właściwości są zmieniane, gdy nie powinny być. Można zmienić `AllCaps` metodę na następujący kod, aby naprawić błąd kompilatora:\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\nPrzy użyciu tej nowej składni kompilator zapewnia, że właściwości są niezmienne.\n"
- title: Inicjowanie pól zapasowych dla właściwości automatycznych
  durationInMinutes: 1
  content: "Nowa składnia w języku C# 6 umożliwia używanie inicjatorów dla właściwości automatycznych. Staje się to ważniejsze, gdy klasy rozwijają nowe możliwości. Dodaj właściwość drugiego imienia i nowy konstruktor, `Person` który ma trzy ciągi do klasy:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\nPrzypisanie we `MiddleName` właściwości jest inicjatorem. Inicjuje pole zapasowe wygenerowane przez kompilator dla drugiego imienia.\n"
- title: Składowe z wyrażeniem w treści
  durationInMinutes: 2
  content: >
    Elementy członkowskie zabudowane wyrażeniem zapewniają lekką składnię dla metod lekkich. Klasa `Person` ma dwóch świetnych kandydatów. Spójrz na `ToString`deklarację:


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    Zastąp `ToString` tę deklarację następującym kodem:


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    Spróbuj tego samego `AllCaps` z metodą. Jest to niewielka poprawa, ale gdy jest mądrze używany tworzy znacznie bardziej czytelny kod, szczególnie dla obiektów transferu danych (DTO) i innych typów przy minimalnym zachowaniu.
- title: Importowanie pojedynczej klasy
  durationInMinutes: 2
  content: "Jeśli wielokrotnie używasz jednej klasy metod statycznych w całym kodzie, w tym nazwę klasy za każdym razem zasłania znaczenie kodu. Klasa `Person` aktualnie importuje obszar `System` nazw, <xref:System.Console?displayProperty=nameWithType> mimo że jest używany tylko. Zmodyfikuj instrukcję w `using` następujący sposób:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\nInstrukcja `static using` staje się bardziej przydatne w większych programów, które znacznie korzystać z [`string`](xref:System.String) jednej klasy <xref:System.Math?displayProperty=nameWithType> z wielu metod statycznych, takich jak klasy lub klasy.\n"
- title: Lepszy format ciągu
  durationInMinutes: 2
  content: "C# 6 zawiera nową składnię do tworzenia ciągów z ciągu i osadzonych wyrażeń, które są oceniane do produkcji innych wartości ciągu. Można zmienić `ToString` i `AllCaps` metody, aby użyć tej składni:\n\n[!code-csharp[StringInterpolation](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\nZamiast argumentów pozycyjnych `{` `}`między i , można napisać wyrażenia C# bezpośrednio. Możesz zrobić to samo `Main` w metodzie. Zastąp istniejący kod następującymi kwestiami:\n\n[!code-csharp[InterpolationMain](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\nNie są ograniczone do jednej zmiennej w tych wyrażeniach. Zacznijmy od nowego przykładu i zmodyfikujmy go, aby zademonstrować inne wyrażenia, których można użyć z interpolacją ciągów. Wklej następujący kod do interaktywnego okna w metodzie: `Main`\n\n[!code-csharp[Phrases](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \nW tym przypadku należy dodać następującą instrukcję za pomocą do górnej części interaktywnego okna:\n\n```csharp\nusing System.Linq;\n```\n\nMożna usunąć zmienną `average` lokalną i wykonać to obliczenie jako część interpolowanego wyrażenia ciągu. Zamień ostatnie dwa wiersze na następujące elementy:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\nUruchamianie poprzedniego przykładu, można znaleźć, `Average` że dane wyjściowe dla ma więcej miejsc dziesiętnych niż chcesz. Składnia interpolacji ciągów obsługuje wszystkie ciągi formatu dostępne przy użyciu wcześniejszych metod formatowania. Należy określić ciąg formatu wewnątrz nawiasów klamrowych. Dodaj `:` następujące wyrażenie do formatu:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: Szybkie i łatwe kontrole null
  durationInMinutes: 2
  content: "Operator `?.` (null conditional) ułatwia pisanie logiki, która uwzględnia `null` wartości `if` płynnie, bez dodatkowych kontroli. Aby zapoznać się z funkcją, zacznij od skopiowania następującego kodu do interaktywnego okna, aby go wypróbować:\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\nTo rzuca <xref:System.NullReferenceException> po uruchomieniu próbki. Zmień `.` operatora dostępu do elementu członkowskiego na **operator warunkowy null:**\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\nPo tej zmianie nie ma danych wyjściowych. To dlatego, że `s?.Length` wynik `int?` jest, gdy `s.Length` wynik `int`jest . W tym `s?.Length` przykładzie `null`jest . Zwraca, `?.` jeśli jego lewy `null`argument jest . `null` Jeśli typ prawego operandu jest typem wartości, `?.` operator zwraca typ wartości null dla tego typu. Oprócz `?.` tego można `?[]` użyć dla dostępu do tablicy lub indeksatora. Wypróbuj poniższy kod w oknie interaktywnym:\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n Wiele operatorów warunkowych można łączyć w jedno wyrażenie. Lewe `null` operand daje `null` wynik, co ułatwia unikanie zagnieżdżonych klauzul, aby uzyskać dostęp do elementów członkowskich. Na przykład spróbuj wykonać następujący kod w oknie interakcyjnym:\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n W poprzednim przykładzie można uprościć za pomocą **operatora łączenia zerowego,** aby podać wartość domyślną:\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n **Operator warunkowy null** pomaga napisać kod, który sprawia, `null` że logika rdzenia jasne podczas bezproblemowego testowania wartości.\n"
- title: Filtry wyjątków
  durationInMinutes: 2
  content: "Filtry wyjątków umożliwiają przechwycienie wyjątku na podstawie pewnego warunku. Typowym zastosowaniem jest utworzenie metody filtrowania, która rejestruje wyjątki, ale nigdy nie obsługuje tych wyjątków. Filtr wyjątku jest wyrażeniem `true` wartości `catch` logicznej, które `false` jest, gdy klauzula powinna `catch` być wykonywana i gdy wyjątek nie powinny być przechwycone przez klauzulę. Wypróbuj następujący kod w oknie interakcyjnym: rejestruje typ wyjątku i komunikat do konsoli. Zwraca, `false` co wskazuje, że wyjątek nie może być obsługiwany. Wypróbuj program w oknie interaktywnym.\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\nPowinien zostać wyświetlony komunikat `LogException` z metody, a następnie domyślny komunikat o wyjątku. Wystarczy eksperymentować, `return false` zmienić `return true` instrukcję i uruchomić to ponownie. Teraz wyjątek zostanie przechwycony, a program zostanie ukończony.\n\nOprócz rejestrowania scenariuszy filtry wyjątków mogą być najbardziej przydatne, gdy właściwość wyjątku określa, jaką akcję należy podjąć. Na przykład można zajrzeć <xref:System.AggregateException> do środka, aby zobaczyć, jakie są zawarte wyjątki i podjąć odpowiednie działania w zależności od określonego wyjątku.\n"
- title: Używanie nameof
  durationInMinutes: 2
  content: "Operator `nameof` zwraca nazwę dowolnej zmiennej, typu lub elementu członkowskiego typu. Wypróbuj poniższy kod w oknie interaktywnym, aby zobaczyć, jak to działa:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\nDane wyjściowe są zgodne z nazwą zmiennej lub typu. Nawet po podaniu w pełni kwalifikowanej `System.String`nazwy `nameof` typu (na przykład) operator zwraca nazwę bez zastrzeżeń. Ta funkcja jest najbardziej przydatna, gdy trzeba przekonwertować parametr lub nazwę właściwości na ciąg. Przykłady obejmują przechwytywanie nazwy argumentu <xref:System.ArgumentNullException> <xref:System.ArgumentException>do wrzucania lub , lub przechwytywanie nazwy zmienionej właściwości podczas implementowania <xref:System.ComponentModel.INotifyPropertyChanged>. \n"
- title: Nowa składnia inicjowania obiektu
  durationInMinutes: 2
  content: "Składnia inicjatora obiektów obsługuje teraz *indeksatory* inicjujące, a także właściwości i pola. Ten dodatek ułatwia inicjowanie słowników i innych typów. Zacznij od słownika. Uruchom następujący kod w oknie interaktywnym:\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\nTa składnia, która ustawia wartość w indeksatorze, może służyć dla dowolnego typu, który ma dostępny set akcesor na indeksatora.\n\nDruga zmiana ułatwia włączenie składni inicjatora dla typów reprezentujących sekwencje. Inicjatory kolekcji mogą być używane <xref:System.Collections.IEnumerable> na dowolnej klasy, która implementuje i ma publicznie dostępną `Add` metodę. Ta `Add` metoda może być teraz metodą rozszerzenia. \n\nW poniższym przykładzie przedstawiono jeden scenariusz dla tej składni. Tworzy `Path` klasę, która `IEnumerable<Point3D>` implementuje i ma metodę dodawania punktów, które przyjmują trzy argumenty. Klasa `Extensions` tworzy dodatkową `Add` metodę, aby dodać nowy punkt z jego trzech składników. Ten przykład nie jest obecnie uruchamiany interaktywnie z powodu ograniczeń w środowisku.\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: Eksploracja nowych funkcji w języku C# 6 została ukończona. Teraz wypróbuj je samodzielnie w swoich aplikacjach.
