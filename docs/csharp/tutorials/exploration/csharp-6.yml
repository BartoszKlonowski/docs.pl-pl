### YamlMime:Tutorial
title: Eksploruj C# 6 — C# samouczek C# interaktywny
metadata:
  title: Eksploruj C# 6 — Wypróbuj nowe funkcje w C# 6 interaktywnie, używając przeglądarki
  description: W tym samouczku będziesz używać przeglądarki do eksplorowania C# 6 interaktywnie. Poznasz nowe idiomy, których można używać z C# 6, które umożliwiają bardziej zwięzły i możliwy do odczytania kod.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: bd11bda04ccf7d8253907bee8f17fc2b86ed76cd
  ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
  ms.translationtype: MT
  ms.contentlocale: pl-PL
  ms.lasthandoff: 11/12/2019
  ms.locfileid: "73969488"
items:
- durationInMinutes: 1
  content: >
    Ten samouczek umożliwia Eksplorowanie C# 6 interaktywnie przy użyciu przeglądarki do pisania C# i wyświetlania wyników kompilowania i uruchamiania kodu. Zawiera szereg lekcji, które modyfikują wcześniejsze C# praktyki, aby używać nowszych, bardziej zwięzłych C# funkcji. Pozostała część tego artykułu zawiera omówienie każdej z tych funkcji z linkiem do eksplorowania każdej funkcji.
- title: Autowłaściwości tylko do odczytu Włącz typy tylko do odczytu
  durationInMinutes: 2
  content: "Dwa ulepszenia składni właściwości autoproperty ułatwiają korzystanie z funkcji autowłaściwości w większych miejscach: tylko do odczytu właściwości i inicjatory właściwości. Weź pod uwagę ten mały program:\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n Wprowadź tryb koncentracji uwagi, skopiuj poprzedni kod do okna C# interaktywnego. Następnie wybierz pozycję *Uruchom* , aby zobaczyć, jak działa kod. `AllCaps` ma niepożądane skutki uboczne modyfikacji wartości właściwości wraz z zwróceniem ciągu z wielką literą. Autor klasy `Person` zaplanował ciągi dla `FirstName` i `LastName` być tylko do odczytu. W C# przypadku opcji 6 można sprawić, że to wymaganie ma zostać wyczyszczone. Usuń `private set` z obu właściwości, aby utworzyć właściwość autotylko do odczytu. Wybierz pozycję *Uruchom* , aby zobaczyć, że kompilator plamuje dwie lokalizacje, w których właściwości `FirstName` i `LastName` są zmieniane, gdy nie powinny być. Można zmienić metodę `AllCaps` na następujący kod, aby naprawić błąd kompilatora:\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\nPrzy użyciu tej nowej składni kompilator gwarantuje, że właściwości są niezmienne.\n"
- title: Inicjuj pola pomocnicze dla właściwości autoproperties
  durationInMinutes: 1
  content: "Nowa składnia w C# 6 umożliwia korzystanie z inicjatorów dla właściwości autoproperties. Stają się one ważniejsze, ponieważ klasy rozszerzają nowe możliwości. Dodaj właściwość środkowej nazwy i nowy Konstruktor, który przyjmuje trzy ciągi do klasy `Person`:\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\nPrzypisanie we właściwości `MiddleName` jest inicjatorem. Inicjuje pole zapasowe generowane przez kompilator dla nazwy środkowej.\n"
- title: Składowe z wyrażeniem w treści
  durationInMinutes: 2
  content: >
    Elementy składowe z wyrażeniami zapewniają uproszczoną składnię dla uproszczonych metod. Klasa `Person` ma dwa wspaniałe kandydatów. Zapoznaj się z deklaracją `ToString`:


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    Zastąp tę deklarację `ToString` następującym kodem:


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    Spróbuj użyć metody `AllCaps`. Jest to niewielkie ulepszenie, ale w przypadku tworzenia znacznie bardziej czytelnego kodu, szczególnie w przypadku Transfer danych obiektów (DTO) i innych typów z minimalnym zachowaniem.
- title: Importowanie pojedynczej klasy
  durationInMinutes: 2
  content: "Jeśli wielokrotnie używasz metod statycznych jednej klasy w całym kodzie, łącznie z nazwą klasy za każdym razem, gdy zaciemnienie znaczenia kodu. Klasa `Person` aktualnie importuje `System` przestrzeni nazw, mimo że używany jest tylko <xref:System.Console?displayProperty=nameWithType>. Zmodyfikuj instrukcję `using` w następujący sposób:\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\nInstrukcja `static using` jest bardziej przydatna w większych programach, które dzielą użycie pojedynczej klasy z wieloma metodami statycznymi, takimi jak Klasa [`string`](xref:System.String) lub Klasa <xref:System.Math?displayProperty=nameWithType>.\n"
- title: Lepszy format ciągu
  durationInMinutes: 2
  content: "C#6 zawiera nową składnię do redagowania ciągów z ciągu i osadzonych wyrażeń, które są oceniane w celu utworzenia innych wartości ciągu. Możesz zmienić metody `ToString` i `AllCaps`, aby użyć następującej składni:\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\nZamiast argumentów pozycyjnych między `{` i `}`, możesz pisać C# wyrażenia bezpośrednio. Można to zrobić w metodzie `Main`. Zastąp istniejący kod następującym:\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\nW tych wyrażeniach nie jest ograniczona do jednej zmiennej. Zacznijmy od nowego przykładu i zmodyfikujesz go, aby przedstawić inne wyrażenia, których można użyć do interpolacji ciągów. Wklej następujący kod do okna interaktywnego w metodzie `Main`:\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \nUżywa LINQ, dlatego należy dodać następującą instrukcję using na początku okna interaktywnego:\n\n```csharp\nusing System.Linq;\n```\n\nMożesz usunąć zmienną lokalną `average` i wykonać to obliczenie jako część wyrażenia interpolowanego ciągu. Zastąp ostatnie dwa wiersze następującym:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\nW poprzednim przykładzie można stwierdzić, że dane wyjściowe dla `Average` mają więcej miejsc dziesiętnych niż chcesz. Składnia interpolacji ciągu obsługuje wszystkie ciągi formatu dostępne przy użyciu wcześniejszych metod formatowania. Ciąg formatu można określić wewnątrz nawiasów klamrowych. Dodaj `:` następujące wyrażenie do formatowania:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: Szybkie i łatwe sprawdzanie wartości null
  durationInMinutes: 2
  content: "Operator `?.` (null Conditional) ułatwia pisanie logiki, która umożliwia bezproblemowe `null` wartości na koncie bez dodatkowych testów `if`. Aby poznać funkcję, Zacznij od skopiowania następującego kodu do okna interaktywnego w celu jego wypróbowania:\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\nZgłasza <xref:System.NullReferenceException> podczas uruchamiania przykładu. Zmień operatora dostępu `.` składowej na **operatora warunkowego null**:\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\nPo tej zmianie nie ma danych wyjściowych. Wynika to z tego, że wynik `s?.Length` jest `int?`, gdy wynik `s.Length` jest `int`. W tym przykładzie `s?.Length` jest `null`. `?.` zwraca `null`, jeśli pozostały operand jest `null`. Jeśli typ argumentu po prawej stronie jest typem wartości, operator `?.` zwraca typ dopuszczający wartość null dla tego typu. Oprócz `?.` można używać `?[]` na potrzeby dostępu do tablicy lub indeksatora. Wypróbuj następujący kod w oknie interaktywnym:\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n Wielokrotne operatory warunkowe mogą być połączone w jedno wyrażenie. `null` lewy operand generuje wynik `null`, ułatwiając uniknięcie zagnieżdżonych klauzul if w celu uzyskania dostępu do elementów członkowskich. Na przykład Wypróbuj następujący kod w oknie interaktywnym:\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n Poprzedni przykład można uprościć za pomocą **operatora łączenia wartości null** , aby podać wartość domyślną:\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n **Operator warunkowy o wartości null** pomaga napisać kod, który sprawia, że logika podstawowa jest wyczyszczona, a jednocześnie umożliwia bezproblemowe testowanie wartości `null`.\n"
- title: Filtry wyjątków
  durationInMinutes: 2
  content: "Filtry wyjątków umożliwiają przechwytywanie wyjątku na podstawie pewnego warunku. Typowym zastosowaniem jest utworzenie metody filtru, która rejestruje wyjątki, ale nigdy nie obsługuje tych wyjątków. Filtr wyjątku jest wyrażeniem logicznym, które jest `true`, gdy klauzula `catch` powinna być wykonywana, i `false`, gdy wyjątek nie powinien być przechwytywany przez klauzulę `catch`. Wypróbuj następujący kod w oknie interaktywnym: rejestruje typ wyjątku i komunikat w konsoli programu. Zwraca `false`, co oznacza, że nie można obsłużyć wyjątku. Wypróbuj program w oknie interaktywnym.\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\nPowinien zostać wyświetlony komunikat z metody `LogException`, a następnie domyślny komunikat o wyjątku. Tylko w przypadku eksperymentu Zmień instrukcję `return false`, aby `return true` i ponownie uruchomić. Teraz wyjątek jest przechwytywany i program zostanie uruchomiony do ukończenia.\n\nPoza scenariuszami rejestrowania filtry wyjątków mogą być najbardziej przydatne, gdy właściwość wyjątku określa akcję do wykonania. Na przykład można przyjrzeć się wewnątrz <xref:System.AggregateException>, aby zobaczyć, jakie wyjątki są i podjąć odpowiednie działania w zależności od konkretnego wyjątku.\n"
- title: Korzystanie z nameof
  durationInMinutes: 2
  content: "Operator `nameof` zwraca nazwę dowolnej zmiennej, typu lub składowej typu. Wypróbuj następujący kod w oknie interaktywnym, aby zobaczyć, jak to działa:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\nDane wyjściowe są zgodne z nazwą zmiennej lub typu. Nawet w przypadku podanej w pełni kwalifikowanej nazwy typu (takiej jak `System.String`) operator `nameof` zwraca niekwalifikowaną nazwę. Ta funkcja jest najbardziej przydatna, gdy konieczne jest przekonwertowanie nazwy parametru lub właściwości na ciąg. Przykłady obejmują przechwytywanie nazwy argumentu w celu zgłaszania <xref:System.ArgumentNullException> lub <xref:System.ArgumentException>lub przechwytywania nazwy zmienionej właściwości podczas implementowania <xref:System.ComponentModel.INotifyPropertyChanged>. \n"
- title: Składnia inicjalizacji nowej obiektu
  durationInMinutes: 2
  content: "Składnia inicjatora obiektów obsługuje teraz inicjowanie *indeksatorów* oraz właściwości i pól. To dodanie ułatwia inicjowanie słowników i innych typów. Zacznij od słownika. Uruchom następujący kod w oknie interaktywnym:\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\nTa składnia, która ustawia wartość w indeksatorze, może być używana dla dowolnego typu, który ma dostępne metody dostępu set dla indeksatora.\n\nDruga zmiana ułatwia włączenie składni inicjatora dla typów, które reprezentują sekwencje. Inicjatory kolekcji mogą być używane dla każdej klasy, która implementuje <xref:System.Collections.IEnumerable> i ma publicznie dostępną metodę `Add`. Ta metoda `Add` może teraz być metodą rozszerzenia. \n\nPoniższy przykład przedstawia jeden scenariusz dla tej składni. Tworzy klasę `Path` implementującą `IEnumerable<Point3D>` i ma metodę dodawania punktów przyjmujących trzy argumenty. Klasa `Extensions` tworzy dodatkową metodę `Add`, aby dodać nowy punkt z jego trzech składników. Ten przykład nie jest obecnie uruchamiany interaktywnie z powodu ograniczeń w środowisku.\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: Poznasz nowe funkcje w C# 6. Teraz Wypróbuj swoje aplikacje w swoich aplikacjach.
