---
title: Korzystanie z typów rekordów — samouczek języka C#
description: Dowiedz się, jak używać typów rekordów, tworzyć hierarchie rekordów i Kiedy wybierać rekordy dla klas.
ms.date: 11/12/2020
ms.openlocfilehash: 8a2cb6966ab4f93432723fd6f82618efa86b26aa
ms.sourcegitcommit: 34968a61e9bac0f6be23ed6ffb837f52d2390c85
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/17/2020
ms.locfileid: "94688588"
---
# <a name="create-record-types"></a><span data-ttu-id="40245-103">Tworzenie typów rekordów</span><span class="sxs-lookup"><span data-stu-id="40245-103">Create record types</span></span>

<span data-ttu-id="40245-104">W języku C# 9 wprowadzono *rekordy*, nowy typ referencyjny, który można utworzyć zamiast klas lub struktur.</span><span class="sxs-lookup"><span data-stu-id="40245-104">C# 9 introduces *records*, a new reference type that you can create instead of classes or structs.</span></span> <span data-ttu-id="40245-105">Rekordy różnią się od klas w tych typach rekordów, które używają *równości względem wartości*.</span><span class="sxs-lookup"><span data-stu-id="40245-105">Records are distinct from classes in that record types use *value-based equality*.</span></span> <span data-ttu-id="40245-106">Dwie zmienne typu rekordu są równe, jeśli definicje typu rekordu są identyczne, a jeśli dla każdego pola, wartości w obu rekordach są równe.</span><span class="sxs-lookup"><span data-stu-id="40245-106">Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal.</span></span> <span data-ttu-id="40245-107">Dwie zmienne typu klasy są równe, jeśli obiekty określone jako są tego samego typu, a zmienne odwołują się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="40245-107">Two variables of a class type are equal if the objects referred to are the same class type and the variables refer to the same object.</span></span> <span data-ttu-id="40245-108">Równość oparta na wartości oznacza inne możliwości, które prawdopodobnie będą potrzebne w typach rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-108">Value-based equality implies other capabilities you'll probably want in record types.</span></span> <span data-ttu-id="40245-109">Kompilator generuje wiele z tych członków, gdy deklarujesz `record` zamiast `class` .</span><span class="sxs-lookup"><span data-stu-id="40245-109">The compiler generates many of those members when you declare a `record` instead of a `class`.</span></span>

<span data-ttu-id="40245-110">Z tego samouczka dowiesz się, jak wykonywać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="40245-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="40245-111">Zdecyduj, czy należy zadeklarować element `class` lub `record` .</span><span class="sxs-lookup"><span data-stu-id="40245-111">Decide if you should declare a `class` or a `record`.</span></span>
> - <span data-ttu-id="40245-112">Zadeklaruj typy rekordów i typy rekordów pozycyjnych.</span><span class="sxs-lookup"><span data-stu-id="40245-112">Declare record types and positional record types.</span></span>
> - <span data-ttu-id="40245-113">Podstaw metody dla metod generowanych przez kompilator w rekordach.</span><span class="sxs-lookup"><span data-stu-id="40245-113">Substitute your methods for compiler generated methods in records.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="40245-114">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="40245-114">Prerequisites</span></span>

<span data-ttu-id="40245-115">Musisz skonfigurować maszynę do uruchamiania programu .NET 5 lub nowszego, w tym kompilatora C# 9,0 lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="40245-115">You’ll need to set up your machine to run .NET 5 or later, including the C# 9.0 or later compiler.</span></span> <span data-ttu-id="40245-116">Kompilator języka C# 9,0 jest dostępny począwszy od [programu Visual Studio 2019 w wersji 16,8](https://visualstudio.microsoft.com/vs) lub [zestawu .NET 5,0 SDK](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="40245-116">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8](https://visualstudio.microsoft.com/vs) or the [.NET 5.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="characteristics-of-records"></a><span data-ttu-id="40245-117">Charakterystyki rekordów</span><span class="sxs-lookup"><span data-stu-id="40245-117">Characteristics of records</span></span>

<span data-ttu-id="40245-118">*Rekord* można zdefiniować przez zadeklarowanie typu za pomocą `record` słowa kluczowego, zamiast `class` `struct` słowa kluczowego or.</span><span class="sxs-lookup"><span data-stu-id="40245-118">You define a *record* by declaring a type with the `record` keyword, instead of the `class` or `struct` keyword.</span></span> <span data-ttu-id="40245-119">Rekord a to typ referencyjny, który jest zgodny z semantyką równości opartą na wartości.</span><span class="sxs-lookup"><span data-stu-id="40245-119">A record is a reference type and follows value-based equality semantics.</span></span> <span data-ttu-id="40245-120">Aby wymusić semantykę wartości, kompilator generuje kilka metod dla typu rekordu:</span><span class="sxs-lookup"><span data-stu-id="40245-120">To enforce value semantics, the compiler generates several methods for your record type:</span></span>

- <span data-ttu-id="40245-121">Zastąpienie elementu <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="40245-121">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="40245-122">Metoda wirtualna `Equals` , której parametr jest typem rekordu.</span><span class="sxs-lookup"><span data-stu-id="40245-122">A virtual `Equals` method whose parameter is the record type.</span></span>
- <span data-ttu-id="40245-123">Zastąpienie elementu <xref:System.Object.GetHashCode?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="40245-123">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="40245-124">Metody dla `operator ==` i `operator !=` .</span><span class="sxs-lookup"><span data-stu-id="40245-124">Methods for `operator ==` and `operator !=`.</span></span>
- <span data-ttu-id="40245-125">Implementacja typów rekordów <xref:System.IEquatable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="40245-125">Record types implement <xref:System.IEquatable%601?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="40245-126">Ponadto rekordy zapewniają przesłonięcie <xref:System.Object.ToString?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="40245-126">In addition, records provide an override of <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="40245-127">Kompilator służy do syntezowania metod wyświetlania rekordów przy użyciu <xref:System.Object.ToString?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="40245-127">The compiler synthesizes methods for displaying records using <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="40245-128">Poznasz te elementy w trakcie pisania kodu dla tego samouczka.</span><span class="sxs-lookup"><span data-stu-id="40245-128">You'll explore those members as you write the code for this tutorial.</span></span> <span data-ttu-id="40245-129">Rejestruje `with` wyrażenia obsługi, aby umożliwić nieniszczącą mutację rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-129">Records support `with` expressions to enable non-destructive mutation of records.</span></span>

<span data-ttu-id="40245-130">*Rekordy pozycyjne* można także deklarować przy użyciu bardziej zwięzłej składni.</span><span class="sxs-lookup"><span data-stu-id="40245-130">You can also declare *positional records* using a more concise syntax.</span></span> <span data-ttu-id="40245-131">Kompilator pozwala uzyskać więcej metod przy deklarowaniu rekordów pozycyjnych:</span><span class="sxs-lookup"><span data-stu-id="40245-131">The compiler synthesizes more methods for you when you declare positional records:</span></span>

- <span data-ttu-id="40245-132">Podstawowy Konstruktor, którego parametry pasują do parametrów pozycyjnych w deklaracji rekordu.</span><span class="sxs-lookup"><span data-stu-id="40245-132">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
- <span data-ttu-id="40245-133">Publiczne właściwości tylko do inicjacji dla każdego parametru konstruktora podstawowego.</span><span class="sxs-lookup"><span data-stu-id="40245-133">Public init-only properties for each parameter of a primary constructor.</span></span>
- <span data-ttu-id="40245-134">`Deconstruct`Metoda wyodrębniania właściwości z rekordu.</span><span class="sxs-lookup"><span data-stu-id="40245-134">A `Deconstruct` method to extract properties from the record.</span></span>

## <a name="build-temperature-data"></a><span data-ttu-id="40245-135">Kompiluj dane temperatury</span><span class="sxs-lookup"><span data-stu-id="40245-135">Build temperature data</span></span>

<span data-ttu-id="40245-136">Dane i statystyki są między scenariuszami, w których chcesz używać rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-136">Data and statistics are among the scenarios where you'll want to use records.</span></span> <span data-ttu-id="40245-137">W tym samouczku utworzysz aplikację, która obliczy zakres *dni* dla różnych zastosowań.</span><span class="sxs-lookup"><span data-stu-id="40245-137">For this tutorial, you'll build an application that computes *degree days* for different uses.</span></span> <span data-ttu-id="40245-138">*Stopień dni* to miara ciepła (lub braku ciepła) w okresie dni, tygodni lub miesięcy.</span><span class="sxs-lookup"><span data-stu-id="40245-138">*Degree days* are a measure of heat (or lack of heat) over a period of days, weeks, or months.</span></span> <span data-ttu-id="40245-139">Zakres dni śledzenia i przewidywania zużycia energii.</span><span class="sxs-lookup"><span data-stu-id="40245-139">Degree days track and predict energy usage.</span></span> <span data-ttu-id="40245-140">Więcej hotter dni oznacza więcej warunków użytkowania powietrza, a większa liczba dni w chłodni oznacza więcej użycia pieca.</span><span class="sxs-lookup"><span data-stu-id="40245-140">More hotter days means more air conditioning, and more colder days means more furnace usage.</span></span> <span data-ttu-id="40245-141">Zakres dni ułatwia zarządzanie populacją zakładu.</span><span class="sxs-lookup"><span data-stu-id="40245-141">Degree days help manage plant populations.</span></span> <span data-ttu-id="40245-142">Zakres dni jest skorelowany do wzrostu zakładu w miarę zmiany sezonów.</span><span class="sxs-lookup"><span data-stu-id="40245-142">Degree days correlate to plant growth as the seasons change.</span></span> <span data-ttu-id="40245-143">Stopień dni ułatwia śledzenie migracji zwierząt dla gatunków, które podróżują w celu dopasowania klimatu.</span><span class="sxs-lookup"><span data-stu-id="40245-143">Degree days help track animal migrations for species that travel to match climate.</span></span>

<span data-ttu-id="40245-144">Formuła jest zależna od średniej temperatury w danym dniu i temperatury linii bazowej.</span><span class="sxs-lookup"><span data-stu-id="40245-144">The formula is based on the mean temperature on a given day and a baseline temperature.</span></span> <span data-ttu-id="40245-145">Aby obliczyć zakres dni w czasie, w danym okresie będzie potrzebna najwyższa i niska temperatura.</span><span class="sxs-lookup"><span data-stu-id="40245-145">To compute degree days over time, you'll need the high and low temperature each day for a period of time.</span></span> <span data-ttu-id="40245-146">Zacznijmy od utworzenia nowej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="40245-146">Let's start by creating a new application.</span></span> <span data-ttu-id="40245-147">Utwórz nową aplikację konsolową.</span><span class="sxs-lookup"><span data-stu-id="40245-147">Make a new console application.</span></span> <span data-ttu-id="40245-148">Utwórz nowy typ rekordu w nowym pliku o nazwie "DailyTemperature.cs":</span><span class="sxs-lookup"><span data-stu-id="40245-148">Create a new record type in a new file named "DailyTemperature.cs":</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DailyRecord":::

<span data-ttu-id="40245-149">Poprzedni kod definiuje *rekord pozycyjny*.</span><span class="sxs-lookup"><span data-stu-id="40245-149">The preceding code defines a *positional record*.</span></span> <span data-ttu-id="40245-150">Utworzono typ referencyjny, który zawiera dwie właściwości: `HighTemp` , i `LowTemp` .</span><span class="sxs-lookup"><span data-stu-id="40245-150">You've created a reference type that contains two properties: `HighTemp`, and `LowTemp`.</span></span> <span data-ttu-id="40245-151">Właściwości te są *jedynymi właściwościami inicjującymi*, co oznacza, że można je ustawić w konstruktorze lub przy użyciu inicjatora właściwości.</span><span class="sxs-lookup"><span data-stu-id="40245-151">Those properties are *init only properties*, meaning they can be set in the constructor or using a property initializer.</span></span> <span data-ttu-id="40245-152">`DailyTemperature`Typ ma także *podstawowy Konstruktor* , który ma dwa parametry, które pasują do dwóch właściwości.</span><span class="sxs-lookup"><span data-stu-id="40245-152">The `DailyTemperature` type also has a *primary constructor* that has two parameters that match the two properties.</span></span> <span data-ttu-id="40245-153">Użyj konstruktora podstawowego do zainicjowania `DailyTemperature` rekordu:</span><span class="sxs-lookup"><span data-stu-id="40245-153">You use the primary constructor to initialize a `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="DeclareData":::

<span data-ttu-id="40245-154">Możesz dodać własne właściwości lub metody do rekordów, w tym rekordy pozycyjne.</span><span class="sxs-lookup"><span data-stu-id="40245-154">You can add your own properties or methods to records, including positional records.</span></span> <span data-ttu-id="40245-155">Należy obliczyć średnią temperaturę dla każdego dnia.</span><span class="sxs-lookup"><span data-stu-id="40245-155">You'll need to compute the mean temperature for each day.</span></span> <span data-ttu-id="40245-156">Możesz dodać tę właściwość do `DailyTemperature` rekordu:</span><span class="sxs-lookup"><span data-stu-id="40245-156">You can add that property to the `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/DailyTemperature.cs" ID="TemperatureRecord":::

<span data-ttu-id="40245-157">Upewnij się, że możesz użyć tych danych.</span><span class="sxs-lookup"><span data-stu-id="40245-157">Let's make sure you can use this data.</span></span> <span data-ttu-id="40245-158">Dodaj następujący kod do `Main` metody:</span><span class="sxs-lookup"><span data-stu-id="40245-158">Add the following code to your `Main` method:</span></span>

```csharp
foreach (var item in data)
    Console.WriteLine(item);
```

<span data-ttu-id="40245-159">Uruchom aplikację i zobaczysz dane wyjściowe podobne do następującego ekranu (kilka wierszy usuniętych dla obszaru):</span><span class="sxs-lookup"><span data-stu-id="40245-159">Run your application, and you'll see output that looks similar to the following display (several rows removed for space):</span></span>

```dotnetcli
DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }


DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
```

<span data-ttu-id="40245-160">Powyższy kod przedstawia dane wyjściowe z przesłonięcia, które zostały przesłonięte `ToString` przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="40245-160">The preceding code shows the output from the override of `ToString` synthesized by the compiler.</span></span> <span data-ttu-id="40245-161">Jeśli wolisz inny tekst, możesz napisać własną wersję programu `ToString` .</span><span class="sxs-lookup"><span data-stu-id="40245-161">If you prefer different text, you can write your own version of `ToString`.</span></span> <span data-ttu-id="40245-162">Uniemożliwia to kompilatorowi wyszukanie wersji.</span><span class="sxs-lookup"><span data-stu-id="40245-162">That prevents the compiler from synthesizing a version for you.</span></span>

## <a name="compute-degree-days"></a><span data-ttu-id="40245-163">Liczba dni obliczeniowych</span><span class="sxs-lookup"><span data-stu-id="40245-163">Compute degree days</span></span>

<span data-ttu-id="40245-164">Aby obliczyć liczbę dni, należy wziąć pod nich różnicę z temperatury linii bazowej i średniej temperatury danego dnia.</span><span class="sxs-lookup"><span data-stu-id="40245-164">To compute degree days, you take the difference from a baseline temperature and the mean temperature on a given day.</span></span> <span data-ttu-id="40245-165">Aby zmierzyć ciepło w czasie, odrzucasz dni, w których średnia temperatura jest poniżej linii bazowej.</span><span class="sxs-lookup"><span data-stu-id="40245-165">To measure heat over time, you discard any days where the mean temperature is below the baseline.</span></span> <span data-ttu-id="40245-166">Aby zmierzyć zimny czas, odrzucaj dni, w których średnia temperatura jest wyższa od linii bazowej.</span><span class="sxs-lookup"><span data-stu-id="40245-166">To measure cold over time, you discard any days where the mean temperature is above the baseline.</span></span> <span data-ttu-id="40245-167">Na przykład stan USA używa 65F jako podstawy dla obu dni ogrzewania i chłodzenia.</span><span class="sxs-lookup"><span data-stu-id="40245-167">For example, the U.S. uses 65F as the base for both heating  and cooling degree days.</span></span> <span data-ttu-id="40245-168">Jest to temperatura, w której nie jest wymagana ogrzewanie ani chłodzenie.</span><span class="sxs-lookup"><span data-stu-id="40245-168">That's the temperature where no heating or cooling is needed.</span></span> <span data-ttu-id="40245-169">Jeśli dzień ma średnią temperaturę 70F, ten dzień to 5 dni w poziomie chłodzenia i 0 stopni ogrzewania.</span><span class="sxs-lookup"><span data-stu-id="40245-169">If a day has a mean temperature of 70F, that day is 5 cooling degree days and 0 heating degree days.</span></span> <span data-ttu-id="40245-170">Z drugiej strony, jeśli średnia temperatura to 55F, ten dzień wynosi 10 dni w poziomie ogrzewania i 0 stopni chłodzenia.</span><span class="sxs-lookup"><span data-stu-id="40245-170">Conversely, if the mean temperature is 55F, that day is 10 heating degree days and 0 cooling degree days.</span></span>

<span data-ttu-id="40245-171">Te formuły można wyrazić jako małą hierarchię typów rekordów: abstrakcyjny typ dnia i dwa typy konkretnego poziomu ogrzewania dla dni i stopnia chłodzenia.</span><span class="sxs-lookup"><span data-stu-id="40245-171">You can express these formulas as a small hierarchy of record types: an abstract degree day type and two concrete types for heating degree days and cooling degree days.</span></span> <span data-ttu-id="40245-172">Te typy mogą również zawierać rekordy pozycyjne.</span><span class="sxs-lookup"><span data-stu-id="40245-172">These types can also be positional records.</span></span> <span data-ttu-id="40245-173">Przyjmują one temperaturę bazową i sekwencję dziennych rekordów temperatury jako argumenty konstruktora podstawowego:</span><span class="sxs-lookup"><span data-stu-id="40245-173">They take a baseline temperature and a sequence of daily temperature records as arguments to the primary constructor:</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DegreeDaysRecords":::

<span data-ttu-id="40245-174">Rekord abstrakcyjny `DegreeDays` jest współdzieloną klasą bazową dla `HeatingDegreeDays` `CoolingDegreeDays` rekordów i.</span><span class="sxs-lookup"><span data-stu-id="40245-174">The abstract `DegreeDays` record is the shared base class for both the `HeatingDegreeDays` and `CoolingDegreeDays` records.</span></span> <span data-ttu-id="40245-175">Deklaracje konstruktora podstawowego dotyczące rekordów pochodnych pokazują, jak zarządzać inicjalizacją rekordu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="40245-175">The primary constructor declarations on the derived records show how to manage base record initialization.</span></span> <span data-ttu-id="40245-176">Rekord pochodny deklaruje parametry dla wszystkich parametrów w podstawowym konstruktorze bazowym rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-176">Your derived record declares parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="40245-177">Rekord podstawowy deklaruje i inicjuje te właściwości.</span><span class="sxs-lookup"><span data-stu-id="40245-177">The base record declares and initializes those properties.</span></span> <span data-ttu-id="40245-178">Rekord pochodny nie jest ukrywany, ale tylko tworzy i inicjuje właściwości dla parametrów, które nie są zadeklarowane w rekordzie podstawowym.</span><span class="sxs-lookup"><span data-stu-id="40245-178">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span> <span data-ttu-id="40245-179">W tym przykładzie rekordy pochodne nie dodają nowych parametrów konstruktora podstawowego.</span><span class="sxs-lookup"><span data-stu-id="40245-179">In this example, the derived records don't add new primary constructor parameters.</span></span> <span data-ttu-id="40245-180">Przetestuj swój kod, dodając następujący kod do `Main` metody:</span><span class="sxs-lookup"><span data-stu-id="40245-180">Test your code by adding the following code to your `Main` method:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="HeatingAndCooling":::

<span data-ttu-id="40245-181">Zostaną wyświetlone dane wyjściowe podobne do następujących:</span><span class="sxs-lookup"><span data-stu-id="40245-181">You'll get output like the following display:</span></span>

```dotnetcli
HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
```

## <a name="define-compiler-synthesized-methods"></a><span data-ttu-id="40245-182">Definiowanie metod z syntezą kompilatora</span><span class="sxs-lookup"><span data-stu-id="40245-182">Define compiler-synthesized methods</span></span>

<span data-ttu-id="40245-183">Kod oblicza poprawną liczbę dni ogrzewania i chłodzenia w tym okresie.</span><span class="sxs-lookup"><span data-stu-id="40245-183">Your code calculates the correct number of heating and cooling degree days over that period of time.</span></span> <span data-ttu-id="40245-184">Ale w tym przykładzie pokazano, dlaczego warto zastąpić niektóre metody z syntezą dla rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-184">But this example shows why you may want to replace some of the synthesized methods for records.</span></span> <span data-ttu-id="40245-185">Można zadeklarować własną wersję dowolnego z metod, które zostały wykorzystane przez kompilator w typie rekordu, z wyjątkiem metody klonowania.</span><span class="sxs-lookup"><span data-stu-id="40245-185">You can declare your own version of any of the compiler-synthesized methods in a record type except the clone method.</span></span> <span data-ttu-id="40245-186">Metoda klonowania ma nazwę wygenerowaną przez kompilator i nie można podać innej implementacji.</span><span class="sxs-lookup"><span data-stu-id="40245-186">The clone method has a compiler generated name and you cannot provide a different implementation.</span></span> <span data-ttu-id="40245-187">Te metody z syntezą obejmują Konstruktor kopiujący, elementy członkowskie <xref:System.IEquatable%601?displayProperty=nameWithType> interfejsu, testy równości i nierówności oraz <xref:System.Object.GetHashCode> .</span><span class="sxs-lookup"><span data-stu-id="40245-187">These synthesized methods include a copy constructor, the members of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, equality and inequality tests, and <xref:System.Object.GetHashCode>.</span></span> <span data-ttu-id="40245-188">W tym celu będziesz je wyszukiwać `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="40245-188">For this purpose, you'll synthesize `PrintMembers`.</span></span> <span data-ttu-id="40245-189">Można również zadeklarować własne `ToString` , ale `PrintMembers` zapewnia lepszą opcję dla scenariuszy dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="40245-189">You could also declare your own `ToString`, but `PrintMembers` provides a better option for inheritance scenarios.</span></span> <span data-ttu-id="40245-190">Aby zapewnić własną wersję metody z syntezą, sygnatura musi być zgodna z metodą z syntezą.</span><span class="sxs-lookup"><span data-stu-id="40245-190">To provide your own version of a synthesized method, the signature must match the synthesized method.</span></span>

<span data-ttu-id="40245-191">`TempRecords`Element w danych wyjściowych konsoli nie jest przydatny.</span><span class="sxs-lookup"><span data-stu-id="40245-191">The `TempRecords` element in the console output isn't useful.</span></span> <span data-ttu-id="40245-192">Wyświetla typ, ale nic innego.</span><span class="sxs-lookup"><span data-stu-id="40245-192">It displays the type, but nothing else.</span></span> <span data-ttu-id="40245-193">Możesz zmienić to zachowanie, dostarczając własną implementację metody z syntezą `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="40245-193">You can change this behavior by providing your own implementation of the synthesized `PrintMembers` method.</span></span> <span data-ttu-id="40245-194">Podpis zależy od modyfikatorów stosowanych do `record` deklaracji:</span><span class="sxs-lookup"><span data-stu-id="40245-194">The signature depends on modifiers applied to the `record` declaration:</span></span>

- <span data-ttu-id="40245-195">Jeśli typ rekordu to `sealed` , podpis jest `private bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="40245-195">If a record type is `sealed`, the signature is `private bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="40245-196">Jeśli typ rekordu nie jest `sealed` i pochodzi od `object` (oznacza to, że nie deklaruje rekordu bazowego), podpis jest `protected virtual bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="40245-196">If a record type isn't `sealed` and derives from `object` (that is, it doesn't declare a base record), the signature is `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="40245-197">Jeśli typ rekordu nie jest `sealed` i pochodzi od innego rekordu, podpis jest `protected override bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="40245-197">If a record type isn't `sealed` and derives from another record, the signature is `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="40245-198">Te reguły są najłatwiej comprehend przez zrozumienie celu `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="40245-198">These rules are easiest to comprehend through understanding the purpose of `PrintMembers`.</span></span> <span data-ttu-id="40245-199">`PrintMembers` dodaje informacje o każdej właściwości w typie rekordu do ciągu.</span><span class="sxs-lookup"><span data-stu-id="40245-199">`PrintMembers` adds information about each property in a record type to a string.</span></span> <span data-ttu-id="40245-200">Kontrakt wymaga rekordów bazowych, aby dodać ich członków do ekranu i przyjęto, że pochodni członkowie doda ich członków.</span><span class="sxs-lookup"><span data-stu-id="40245-200">The contract requires base records to add their members to the display and assumes derived members will add their members.</span></span> <span data-ttu-id="40245-201">Każdy typ rekordu `ToString` określa przesłonięcie, który wygląda podobnie do następującego przykładu `HeatingDegreeDays` :</span><span class="sxs-lookup"><span data-stu-id="40245-201">Each record type synthesizes a `ToString` override that looks similar to the following example for `HeatingDegreeDays`:</span></span>

```csharp
public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
```

<span data-ttu-id="40245-202">Należy zadeklarować `PrintMembers` metodę w `DegreeDays` rekordzie, który nie drukuje typu kolekcji:</span><span class="sxs-lookup"><span data-stu-id="40245-202">You declare a `PrintMembers` method in the `DegreeDays` record that doesn't print the type of the collection:</span></span>

:::code language="csharp" source="snippets/record-types/DegreeDays.cs" ID="AddPrintMembers":::

<span data-ttu-id="40245-203">Podpis deklaruje `virtual protected` metodę zgodną z wersją kompilatora.</span><span class="sxs-lookup"><span data-stu-id="40245-203">The signature declares a `virtual protected` method to match the compiler's version.</span></span> <span data-ttu-id="40245-204">Nie martw się, Jeśli otrzymujesz odpowiednie metody dostępu; Język wymusza poprawność podpisu.</span><span class="sxs-lookup"><span data-stu-id="40245-204">Don't worry if you get the accessors wrong; the language enforces the correct signature.</span></span> <span data-ttu-id="40245-205">Jeśli zapomnisz o poprawnym modyfikatorze dla dowolnej metody z syntezą, kompilator wygeneruje ostrzeżenia lub błędy, które pomogą Ci uzyskać właściwy podpis.</span><span class="sxs-lookup"><span data-stu-id="40245-205">If you forget the correct modifiers for any synthesized method, the compiler issues warnings or errors that help you get the right signature.</span></span>

## <a name="non-destructive-mutation"></a><span data-ttu-id="40245-206">Mutacja nieniszcząca</span><span class="sxs-lookup"><span data-stu-id="40245-206">Non-destructive mutation</span></span>

<span data-ttu-id="40245-207">Syntezy w rekordach pozycyjnych nie modyfikują stanu rekordu.</span><span class="sxs-lookup"><span data-stu-id="40245-207">The synthesized members in a positional record don't modify the state of the record.</span></span> <span data-ttu-id="40245-208">Celem jest możliwość łatwiejszego tworzenia niezmiennych rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-208">The goal is that you can more easily create immutable records.</span></span> <span data-ttu-id="40245-209">Zapoznaj się ponownie z powyższymi deklaracjami dla `HeatingDegreeDays` i `CoolingDegreeDays` .</span><span class="sxs-lookup"><span data-stu-id="40245-209">Look again at the preceding declarations for `HeatingDegreeDays` and `CoolingDegreeDays`.</span></span> <span data-ttu-id="40245-210">Dodane elementy członkowskie wykonują obliczenia na wartościach rekordu, ale nie są zmieniane.</span><span class="sxs-lookup"><span data-stu-id="40245-210">The members added perform computations on the values for the record, but don't mutate state.</span></span> <span data-ttu-id="40245-211">Rekordy pozycyjne ułatwiają tworzenie niemodyfikowalnych typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="40245-211">Positional records make it easier for you to create immutable reference types.</span></span>

<span data-ttu-id="40245-212">Tworzenie niemodyfikowalnych typów referencyjnych oznacza, że chcesz użyć mutacji nieniszczącej.</span><span class="sxs-lookup"><span data-stu-id="40245-212">Creating immutable reference types means you'll want to use non-destructive mutation.</span></span> <span data-ttu-id="40245-213">Tworzysz nowe wystąpienia rekordów podobne do istniejących wystąpień rekordów przy użyciu [ `with` wyrażeń](../../language-reference/operators/with-expression.md).</span><span class="sxs-lookup"><span data-stu-id="40245-213">You  create new record instances that are similar to existing record instances using [`with` expressions](../../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="40245-214">Te wyrażenia są kopią kopii z dodatkowymi przypisaniami, które modyfikują kopię.</span><span class="sxs-lookup"><span data-stu-id="40245-214">These expressions are a copy construction with additional assignments that modify the copy.</span></span> <span data-ttu-id="40245-215">Wynik jest nowym wystąpieniem rekordu, w którym każda właściwość została skopiowana z istniejącego rekordu i opcjonalnie zmodyfikowana.</span><span class="sxs-lookup"><span data-stu-id="40245-215">The result is a new record instance where each property has been copied from the existing record and optionally modified.</span></span> <span data-ttu-id="40245-216">Oryginalny rekord nie został zmieniony.</span><span class="sxs-lookup"><span data-stu-id="40245-216">The original record is unchanged.</span></span>

<span data-ttu-id="40245-217">Dodajmy do programu kilka funkcji, które demonstrują `with` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="40245-217">Let's add a couple features to your program that demonstrate `with` expressions.</span></span> <span data-ttu-id="40245-218">Najpierw utwórz nowy rekord, aby obliczyć rosnący wzrost dni przy użyciu tych samych danych.</span><span class="sxs-lookup"><span data-stu-id="40245-218">First, let's create a new record to compute growing degree days using the same data.</span></span> <span data-ttu-id="40245-219">*Coraz* większy zakres dni zwykle używa 41F jako linii bazowej i mierzy temperaturę ponad linię bazową.</span><span class="sxs-lookup"><span data-stu-id="40245-219">*Growing degree days* typically uses 41F as the baseline and measures temperatures above the baseline.</span></span> <span data-ttu-id="40245-220">Aby użyć tych samych danych, można utworzyć nowy rekord podobny do `coolingDegreeDays` , ale z inną temperaturą bazową:</span><span class="sxs-lookup"><span data-stu-id="40245-220">To use the same data, you can create a new record that is similar to the `coolingDegreeDays`, but with a different base temperature:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="GrowingDegreeDays":::

<span data-ttu-id="40245-221">Można porównać liczbę stopni obliczanych z wartościami wygenerowanymi przez wyższą temperaturę linii bazowej.</span><span class="sxs-lookup"><span data-stu-id="40245-221">You can compare the number of degrees computed to the numbers generated with a higher baseline temperature.</span></span> <span data-ttu-id="40245-222">Należy pamiętać, że rekordy są *typami odwołań* , a te kopie to płytki kopie.</span><span class="sxs-lookup"><span data-stu-id="40245-222">Remember that records are *reference types* and these copies are shallow copies.</span></span> <span data-ttu-id="40245-223">Tablica danych nie jest kopiowana, ale oba rekordy odwołują się do tych samych danych.</span><span class="sxs-lookup"><span data-stu-id="40245-223">The array for the data isn't copied, but both records refer to the same data.</span></span> <span data-ttu-id="40245-224">Jest to korzyść w jednym innym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="40245-224">That fact is an advantage in one other scenario.</span></span> <span data-ttu-id="40245-225">W przypadku rosnących dni warto śledzić łączną wartość w ciągu ostatnich 5 dni.</span><span class="sxs-lookup"><span data-stu-id="40245-225">For growing degree days, it's useful to keep track of the total for the previous 5 days.</span></span> <span data-ttu-id="40245-226">Można tworzyć nowe rekordy z różnymi danymi źródłowymi przy użyciu `with` wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="40245-226">You can create new records with different source data using `with` expressions.</span></span> <span data-ttu-id="40245-227">Poniższy kod tworzy kolekcję tych kumulacji, a następnie wyświetla wartości:</span><span class="sxs-lookup"><span data-stu-id="40245-227">The following code builds a collection of these accumulations, then displays the values:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="RunningFiveDayTotal":::

<span data-ttu-id="40245-228">Możesz również użyć `with` wyrażeń do tworzenia kopii rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-228">You can also use `with` expressions to create copies of records.</span></span> <span data-ttu-id="40245-229">Nie określaj żadnych właściwości między nawiasami klamrowymi `with` wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="40245-229">Don't specify any properties between the braces for the `with` expression.</span></span> <span data-ttu-id="40245-230">Oznacza to utworzenie kopii i nie zmienia żadnych właściwości:</span><span class="sxs-lookup"><span data-stu-id="40245-230">That means create a copy, and don't change any properties:</span></span>

```csharp
var growingDegreeDaysCopy = growingDegreeDays with { };
```

<span data-ttu-id="40245-231">Uruchom ukończoną aplikację, aby wyświetlić wyniki.</span><span class="sxs-lookup"><span data-stu-id="40245-231">Run the finished application to see the results.</span></span>

## <a name="summary"></a><span data-ttu-id="40245-232">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="40245-232">Summary</span></span>

<span data-ttu-id="40245-233">W tym samouczku pokazano kilka aspektów rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-233">This tutorial showed several aspects of records.</span></span> <span data-ttu-id="40245-234">Rekordy zapewniają zwięzłą składnię dla typów referencyjnych, w których podstawowe użycie zapisuje dane.</span><span class="sxs-lookup"><span data-stu-id="40245-234">Records provide concise syntax for reference types where the fundamental use is storing data.</span></span> <span data-ttu-id="40245-235">W przypadku klas zorientowanych obiektowo, podstawowe użycie polega na definiowaniu obowiązków.</span><span class="sxs-lookup"><span data-stu-id="40245-235">For object-oriented classes, the fundamental use is defining responsibilities.</span></span> <span data-ttu-id="40245-236">Ten samouczek koncentruje się na *rekordach pozycyjnych*, gdzie można użyć zwięzłej składni do deklarowania właściwości tylko do inicjacji dla rekordu.</span><span class="sxs-lookup"><span data-stu-id="40245-236">This tutorial focused on *positional records*, where you can use a concise syntax to declare the init-only properties for a record.</span></span> <span data-ttu-id="40245-237">Kompilator umożliwia wyszukanie kilku elementów członkowskich rekordu do kopiowania i porównywania rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-237">The compiler synthesizes several members of the record for copying and comparing records.</span></span> <span data-ttu-id="40245-238">Możesz dodać innych członków potrzebnych dla typów rekordów.</span><span class="sxs-lookup"><span data-stu-id="40245-238">You can add any other members you need for your record types.</span></span> <span data-ttu-id="40245-239">Można tworzyć niezmienne typy rekordów, wiedząc, że żaden z elementów członkowskich generowanych przez kompilator nie będzie mógł zmodyfikować stanu.</span><span class="sxs-lookup"><span data-stu-id="40245-239">You can create immutable record types knowing that none of the compiler-generated members would mutate state.</span></span> <span data-ttu-id="40245-240">W przypadku rekordów pozycyjnych `with` wyrażenia ułatwiają obsługę mutacji nieniszczącej.</span><span class="sxs-lookup"><span data-stu-id="40245-240">For positional records, `with` expressions make it easy to support non-destructive mutation.</span></span>

<span data-ttu-id="40245-241">Rekordy dodają inny sposób definiowania typów.</span><span class="sxs-lookup"><span data-stu-id="40245-241">Records add another way to define types.</span></span> <span data-ttu-id="40245-242">Za pomocą `class` definicji można tworzyć hierarchie zorientowane obiektowo, które koncentrują się na odpowiedzialności i zachowaniu obiektów.</span><span class="sxs-lookup"><span data-stu-id="40245-242">You use `class` definitions to create object-oriented hierarchies that focus on the responsibilities and behavior of objects.</span></span> <span data-ttu-id="40245-243">Tworzysz `struct` typy struktur danych, które przechowują dane i są wystarczająco małe, aby można je było wydajnie kopiować.</span><span class="sxs-lookup"><span data-stu-id="40245-243">You create `struct` types for data structures that store data and are small enough to copy efficiently.</span></span> <span data-ttu-id="40245-244">Rekordy są tworzone, gdy chcesz, aby dane były zgodne i porównywane, nie chcesz kopiować wartości i chcieć używać zmiennych referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="40245-244">You create records when you want value-based equality and comparison, don't want to copy values, and want to use reference variables.</span></span>

<span data-ttu-id="40245-245">Aby poznać pełny opis rekordów, należy odczytać [proponowaną specyfikację typu rekordu](~/_csharplang/proposals/csharp-9.0/records.md).</span><span class="sxs-lookup"><span data-stu-id="40245-245">You can learn the complete description of records by reading the [proposed record type specification](~/_csharplang/proposals/csharp-9.0/records.md).</span></span>
