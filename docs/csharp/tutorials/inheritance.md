---
title: Dziedziczenie wC#
description: Dowiedz się, jak C# używać dziedziczenia w bibliotekach i aplikacjach.
author: rpetrusha
ms.author: ronpet
ms.date: 07/05/2018
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 41377cb47836624160a5b402e0a85270b68eba4f
ms.sourcegitcommit: 205b9a204742e9c77256d43ac9d94c3f82909808
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/10/2019
ms.locfileid: "70850988"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="c89a2-103">Dziedziczenie w języku C# i .NET</span><span class="sxs-lookup"><span data-stu-id="c89a2-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="c89a2-104">Ten samouczek przedstawia sposób dziedziczenia w C#programie.</span><span class="sxs-lookup"><span data-stu-id="c89a2-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="c89a2-105">Dziedziczenie to funkcja języków programowania zorientowanego obiektowo, która umożliwia zdefiniowanie klasy bazowej, która zapewnia konkretne funkcje (dane i zachowanie) i definiuje klasy pochodne, które dziedziczą lub przesłaniają te funkcje.</span><span class="sxs-lookup"><span data-stu-id="c89a2-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="c89a2-106">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="c89a2-106">Prerequisites</span></span>

<span data-ttu-id="c89a2-107">W tym samouczku założono, że zainstalowano zestaw .NET Core SDK.</span><span class="sxs-lookup"><span data-stu-id="c89a2-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="c89a2-108">Odwiedź stronę [pobierania programu .NET Core](https://dotnet.microsoft.com/download) , aby ją pobrać.</span><span class="sxs-lookup"><span data-stu-id="c89a2-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="c89a2-109">Potrzebny jest również Edytor kodu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-109">You also need a code editor.</span></span> <span data-ttu-id="c89a2-110">W tym samouczku użyto [Visual Studio Code](https://code.visualstudio.com), chociaż można użyć dowolnego dowolnego edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="c89a2-111">Uruchamianie przykładów</span><span class="sxs-lookup"><span data-stu-id="c89a2-111">Running the examples</span></span>

<span data-ttu-id="c89a2-112">Aby utworzyć i uruchomić przykłady w tym samouczku, użyj narzędzia [dotnet](../../core/tools/dotnet.md) z wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="c89a2-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="c89a2-113">Wykonaj następujące czynności na każdym z przykładów:</span><span class="sxs-lookup"><span data-stu-id="c89a2-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="c89a2-114">Utwórz katalog do przechowywania przykładu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="c89a2-115">Wprowadź [nową konsolę programu dotnet](../../core/tools/dotnet-new.md) w wierszu polecenia, aby utworzyć nowy projekt .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c89a2-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="c89a2-116">Skopiuj i wklej kod z przykładu do edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="c89a2-117">Wprowadź [dotnet Restore](../../core/tools/dotnet-restore.md) polecenie w wierszu polecenia, aby załadować lub przywrócić zależności projektu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="c89a2-118">Wprowadź polecenie [Uruchom jako dotnet](../../core/tools/dotnet-run.md) , aby skompilować i uruchomić przykład.</span><span class="sxs-lookup"><span data-stu-id="c89a2-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="c89a2-119">Tle Co to jest dziedziczenie?</span><span class="sxs-lookup"><span data-stu-id="c89a2-119">Background: What is inheritance?</span></span>

<span data-ttu-id="c89a2-120">*Dziedziczenie* jest jednym z podstawowych atrybutów programowania zorientowanego obiektowo.</span><span class="sxs-lookup"><span data-stu-id="c89a2-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="c89a2-121">Umożliwia zdefiniowanie klasy podrzędnej, która ponownie używa (dziedziczy), rozszerza lub modyfikuje zachowanie klasy nadrzędnej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="c89a2-122">Klasa, której członkowie są dziedziczone jest nazywana *klasą bazową*.</span><span class="sxs-lookup"><span data-stu-id="c89a2-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="c89a2-123">Klasa, która dziedziczy elementy członkowskie klasy bazowej, nosi nazwę *klasy pochodnej*.</span><span class="sxs-lookup"><span data-stu-id="c89a2-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="c89a2-124">C#i .NET obsługuje tylko *pojedyncze dziedziczenie* .</span><span class="sxs-lookup"><span data-stu-id="c89a2-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="c89a2-125">Oznacza to, że Klasa może dziedziczyć tylko z pojedynczej klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="c89a2-126">Dziedziczenie jest jednak przechodnie, co pozwala na zdefiniowanie hierarchii dziedziczenia dla zestawu typów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="c89a2-127">Innymi słowy, `D` typ może dziedziczyć po typie `C`, który dziedziczy z typu `B`, który dziedziczy z typu `A`klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="c89a2-128">Ponieważ dziedziczenie jest przechodnie, elementy członkowskie `A` typu są dostępne do `D`typu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="c89a2-129">Nie wszystkie składowe klasy bazowej są dziedziczone przez klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="c89a2-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="c89a2-130">Następujące elementy członkowskie nie są dziedziczone:</span><span class="sxs-lookup"><span data-stu-id="c89a2-130">The following members are not inherited:</span></span>

- <span data-ttu-id="c89a2-131">[Konstruktory statyczne](../programming-guide/classes-and-structs/static-constructors.md), które inicjują statyczne dane klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="c89a2-132">[Konstruktory wystąpień](../programming-guide/classes-and-structs/constructors.md), które są wywoływane w celu utworzenia nowego wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="c89a2-133">Każda klasa musi definiować własne konstruktory.</span><span class="sxs-lookup"><span data-stu-id="c89a2-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="c89a2-134">[Finalizatory](../programming-guide/classes-and-structs/destructors.md), które są wywoływane przez moduł wyrzucania elementów bezużytecznych środowiska uruchomieniowego, aby zniszczyć wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="c89a2-135">Wszystkie inne elementy członkowskie klasy bazowej są dziedziczone przez klasy pochodne, niezależnie od tego, czy są one widoczne, czy nie są zależne od ich dostępności.</span><span class="sxs-lookup"><span data-stu-id="c89a2-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="c89a2-136">Dostępność elementu członkowskiego ma wpływ na widoczność klas pochodnych w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="c89a2-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="c89a2-137">[Prywatne](../language-reference/keywords/private.md) składowe są widoczne tylko w klasach pochodnych, które są zagnieżdżone w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="c89a2-138">W przeciwnym razie nie są one widoczne w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="c89a2-139">W poniższym przykładzie `A.B` jest klasą zagnieżdżoną, która pochodzi od `A`, i `C` pochodzi od `A`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="c89a2-140">Pole prywatne `A.value` jest widoczne w A.B.</span><span class="sxs-lookup"><span data-stu-id="c89a2-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="c89a2-141">Jeśli jednak usuniesz Komentarze z `C.GetValue` metody i spróbujemy skompilować przykład, generuje błąd kompilatora CS0122: "A. Value" jest niedostępny z powodu swojego poziomu ochrony ".</span><span class="sxs-lookup"><span data-stu-id="c89a2-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="c89a2-142">[Chronione](../language-reference/keywords/protected.md) elementy członkowskie są widoczne tylko w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="c89a2-143">[Wewnętrzne](../language-reference/keywords/internal.md) elementy członkowskie są widoczne tylko w klasach pochodnych, które znajdują się w tym samym zestawie, co Klasa bazowa.</span><span class="sxs-lookup"><span data-stu-id="c89a2-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="c89a2-144">Nie są one widoczne w klasach pochodnych znajdujących się w innym zestawie z klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="c89a2-145">[Publiczne](../language-reference/keywords/public.md) składowe są widoczne w klasach pochodnych i są częścią interfejsu publicznego klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="c89a2-146">Publiczne dziedziczone elementy członkowskie mogą być wywoływane tak, jakby są zdefiniowane w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="c89a2-147">W poniższym przykładzie `A` Klasa definiuje metodę o nazwie `Method1`, a Klasa `B` dziedziczy z klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="c89a2-148">Przykład następnie wywołuje `Method1` , jakby była `B`metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c89a2-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="c89a2-149">Klasy pochodne mogą również *przesłaniać* dziedziczone elementy członkowskie, dostarczając alternatywną implementację.</span><span class="sxs-lookup"><span data-stu-id="c89a2-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="c89a2-150">Aby możliwe było przesłonięcie elementu członkowskiego, element członkowski w klasie bazowej musi być oznaczony za pomocą słowa kluczowego [Virtual](../language-reference/keywords/virtual.md) .</span><span class="sxs-lookup"><span data-stu-id="c89a2-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="c89a2-151">Domyślnie elementy członkowskie klasy bazowej nie są oznaczone jako `virtual` i nie można ich zastąpić.</span><span class="sxs-lookup"><span data-stu-id="c89a2-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="c89a2-152">Próba zastąpienia niewirtualnego elementu członkowskiego, jak pokazano w poniższym przykładzie, generuje błąd kompilatora CS0506: "\<member > nie może przesłonić dziedziczonej składowej składowej \<> ponieważ nie jest ona oznaczona jako wirtualna, abstrakcyjna lub przesłonięcie.</span><span class="sxs-lookup"><span data-stu-id="c89a2-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="c89a2-153">W niektórych przypadkach Klasa pochodna *musi* przesłonić implementację klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="c89a2-154">Elementy członkowskie klasy bazowej oznaczone za pomocą słowa kluczowego [abstract](../language-reference/keywords/abstract.md) wymagają, aby klasy pochodne zostały przez nie zastąpione.</span><span class="sxs-lookup"><span data-stu-id="c89a2-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="c89a2-155">Próba skompilowania poniższego przykładu generuje błąd kompilatora CS0534, "&lt;Klasa&gt; nie implementuje dziedziczonej abstrakcyjnej &lt;składowej&gt;składowej" `B` , ponieważ Klasa nie udostępnia Implementacja programu `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="c89a2-156">Dziedziczenie ma zastosowanie tylko do klas i interfejsów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="c89a2-157">Inne kategorie typów (struktury, Delegaty i wyliczenia) nie obsługują dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="c89a2-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="c89a2-158">Ze względu na te reguły Próba skompilowania kodu, takiego jak Poniższy przykład, powoduje powstanie błędu kompilatora CS0527: "Typ" ValueType "na liście interfejsów nie jest interfejsem".</span><span class="sxs-lookup"><span data-stu-id="c89a2-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="c89a2-159">Komunikat o błędzie wskazuje, że chociaż można zdefiniować interfejsy, które implementuje struktura, dziedziczenie nie jest obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="c89a2-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="c89a2-160">Dziedziczenie niejawne</span><span class="sxs-lookup"><span data-stu-id="c89a2-160">Implicit inheritance</span></span>

<span data-ttu-id="c89a2-161">Oprócz typów, które mogą dziedziczyć za pośrednictwem pojedynczego dziedziczenia, wszystkie typy w systemie typu .NET niejawnie <xref:System.Object> dziedziczą z lub typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="c89a2-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="c89a2-162">Typowe funkcje programu <xref:System.Object> są dostępne dla dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="c89a2-163">Aby zobaczyć, co oznacza niejawne dziedziczenie, zdefiniujmy nową `SimpleClass`klasę, która jest po prostu pustą definicją klasy:</span><span class="sxs-lookup"><span data-stu-id="c89a2-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="c89a2-164">Następnie można użyć odbicia, które umożliwia sprawdzenie metadanych typu w celu uzyskania informacji na temat tego typu, aby uzyskać listę elementów członkowskich należących do `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="c89a2-165">Chociaż nie zdefiniowano żadnych elementów członkowskich w `SimpleClass` klasie, dane wyjściowe z przykładu wskazują, że faktycznie ma dziewięć członków.</span><span class="sxs-lookup"><span data-stu-id="c89a2-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="c89a2-166">Jeden z tych elementów członkowskich jest konstruktorem bez parametrów (lub domyślnym), który jest dostarczany automatycznie `SimpleClass` dla typu przez C# kompilator.</span><span class="sxs-lookup"><span data-stu-id="c89a2-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="c89a2-167">Pozostałe osiem są członkami <xref:System.Object>, typu, z którego wszystkie klasy i interfejsy w systemie typu .NET ostatecznie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="c89a2-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="c89a2-168">Niejawne dziedziczenie z <xref:System.Object> klasy sprawia, `SimpleClass` że te metody są dostępne dla klasy:</span><span class="sxs-lookup"><span data-stu-id="c89a2-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="c89a2-169">Metoda publiczna `ToString` , która `SimpleClass` Konwertuje obiekt na jego reprezentację w postaci ciągu, zwraca w pełni kwalifikowaną nazwę typu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="c89a2-170">W tym przypadku `ToString` Metoda zwraca ciąg "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="c89a2-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="c89a2-171">Trzy metody, które testują pod kątem równości dwóch obiektów: publiczna metoda wystąpienia `Equals(Object)` , publiczna metoda statyczna `Equals(Object, Object)` i publiczna metoda statyczna `ReferenceEquals(Object, Object)` .</span><span class="sxs-lookup"><span data-stu-id="c89a2-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="c89a2-172">Domyślnie te metody testują równość odniesienia; oznacza to, że jest równe, dwie zmienne obiektów muszą odwoływać się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="c89a2-173">Metoda publiczna `GetHashCode` , która oblicza wartość umożliwiającą wystąpienie typu, który ma być używany w kolekcjach skrótów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="c89a2-174">Metoda publiczna `GetType` , która <xref:System.Type> zwraca obiekt, który reprezentuje `SimpleClass` typ.</span><span class="sxs-lookup"><span data-stu-id="c89a2-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="c89a2-175">Metoda chroniona <xref:System.Object.Finalize%2A> , która została zaprojektowana w celu zwolnienia zasobów niezarządzanych przed odjęciem pamięci obiektu przez moduł wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="c89a2-176">Metoda chroniona <xref:System.Object.MemberwiseClone%2A> , która tworzy płytki klonowania bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="c89a2-177">Ze względu na niejawne dziedziczenie można wywołać dowolny Dziedziczony `SimpleClass` element członkowski z obiektu, tak jakby był to element członkowski zdefiniowany `SimpleClass` w klasie.</span><span class="sxs-lookup"><span data-stu-id="c89a2-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="c89a2-178">Na przykład poniższy przykład wywołuje `SimpleClass.ToString` metodę, która `SimpleClass` dziedziczy z <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="c89a2-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="c89a2-179">W poniższej tabeli wymieniono kategorie typów, które można utworzyć w programie C# , oraz typy, z których dziedziczą niejawnie.</span><span class="sxs-lookup"><span data-stu-id="c89a2-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="c89a2-180">Każdy typ podstawowy udostępnia inny zestaw elementów członkowskich za pomocą dziedziczenia do niejawnie pochodnych typów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="c89a2-181">Kategoria typu</span><span class="sxs-lookup"><span data-stu-id="c89a2-181">Type category</span></span> | <span data-ttu-id="c89a2-182">Niejawnie dziedziczone z</span><span class="sxs-lookup"><span data-stu-id="c89a2-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="c89a2-183">class</span><span class="sxs-lookup"><span data-stu-id="c89a2-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="c89a2-184">struktura</span><span class="sxs-lookup"><span data-stu-id="c89a2-184">struct</span></span>        | <span data-ttu-id="c89a2-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="c89a2-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="c89a2-186">enum</span><span class="sxs-lookup"><span data-stu-id="c89a2-186">enum</span></span>          | <span data-ttu-id="c89a2-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="c89a2-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="c89a2-188">delegate</span><span class="sxs-lookup"><span data-stu-id="c89a2-188">delegate</span></span>      | <span data-ttu-id="c89a2-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="c89a2-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="c89a2-190">Dziedziczenie i relacja "is"</span><span class="sxs-lookup"><span data-stu-id="c89a2-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="c89a2-191">Zwykle dziedziczenie jest stosowane do wyrażenia "is" relacji między klasą bazową i co najmniej jedną klasą pochodną, gdzie klasy pochodne są wyspecjalizowanymi wersjami klasy bazowej; Klasa pochodna jest typem klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="c89a2-192">Na przykład `Publication` Klasa reprezentuje publikację dowolnego rodzaju, `Book` a klasy i `Magazine` reprezentują określone typy publikacji.</span><span class="sxs-lookup"><span data-stu-id="c89a2-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="c89a2-193">Klasa lub struktura może zaimplementować jeden lub więcej interfejsów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="c89a2-194">Podczas gdy implementacja interfejsu jest często prezentowana jako obejście dla pojedynczego dziedziczenia lub jako sposób używania dziedziczenia z strukturami, należy przedstawić inną relację (relację "może") między interfejsem a jego typem implementującym niż strukturze.</span><span class="sxs-lookup"><span data-stu-id="c89a2-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="c89a2-195">Interfejs definiuje podzestaw funkcji (takich jak możliwość testowania równości, porównywania lub sortowania obiektów lub do obsługi analizy zależnej od kultury i formatowania), które Interfejs udostępnia dla jego typów implementujących.</span><span class="sxs-lookup"><span data-stu-id="c89a2-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="c89a2-196">Należy zauważyć, że "is" także wskazuje relację między typem i określonym wystąpieniem tego typu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="c89a2-197">W poniższym przykładzie `Automobile` jest klasą, która ma trzy unikatowe właściwości tylko do odczytu: `Make`, producent urządzenia przenośnego; , rodzaj samochodów i `Year`rok produkcji. `Model`</span><span class="sxs-lookup"><span data-stu-id="c89a2-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="c89a2-198">Klasa ma także konstruktora, którego argumenty są przypisane do wartości właściwości, i <xref:System.Object.ToString%2A?displayProperty=nameWithType> zastępuje metodę, aby utworzyć `Automobile` ciąg, który jednoznacznie identyfikuje wystąpienie, a nie `Automobile` klasę. `Automobile`</span><span class="sxs-lookup"><span data-stu-id="c89a2-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="c89a2-199">W takim przypadku nie należy polegać na dziedziczeniu do reprezentowania określonych samochodów i modeli.</span><span class="sxs-lookup"><span data-stu-id="c89a2-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="c89a2-200">Nie trzeba na przykład definiować `Packard` typu do reprezentowania samochodów, które są wytwarzane przez firmę Packard Motor samochodowa.</span><span class="sxs-lookup"><span data-stu-id="c89a2-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="c89a2-201">Zamiast tego można je przedstawić, tworząc `Automobile` obiekt z odpowiednimi wartościami przekazaną do jego konstruktora klasy, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="c89a2-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="c89a2-202">Jest to relacja oparta na dziedziczeniu najlepiej zastosowana do klasy bazowej i do klas pochodnych, które dodają do klasy podstawowej dodatkowe elementy członkowskie lub które wymagają dodatkowych funkcji nieobecnych w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="c89a2-203">Projektowanie klasy bazowej i klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="c89a2-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="c89a2-204">Przyjrzyjmy się procesowi projektowania klasy bazowej i jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="c89a2-205">W tej sekcji zdefiniujesz klasę `Publication`bazową, która reprezentuje publikację dowolnego rodzaju, na przykład książkę, czasopismo, gazetę, arkusz, artykuł itd. Zdefiniujesz `Book` również klasę, która pochodzi od `Publication`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="c89a2-206">Można łatwo zwiększyć przykład, aby zdefiniować inne klasy pochodne, `Magazine`takie jak `Newspaper`, `Journal`,, i `Article`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="c89a2-207">Klasa publikacji podstawowej</span><span class="sxs-lookup"><span data-stu-id="c89a2-207">The base Publication class</span></span>

<span data-ttu-id="c89a2-208">Podczas projektowania `Publication` klasy należy podjąć pewne decyzje dotyczące projektowania:</span><span class="sxs-lookup"><span data-stu-id="c89a2-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="c89a2-209">Elementy członkowskie, które mają zostać uwzględnione `Publication` w klasie bazowej, oraz `Publication` informacje o tym, czy składowe udostępniają implementacje metod, czy też `Publication` jest abstrakcyjną klasą bazową, która służy jako szablon klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="c89a2-210">W takim przypadku `Publication` Klasa zapewni implementacje metod.</span><span class="sxs-lookup"><span data-stu-id="c89a2-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="c89a2-211">[Projektowanie abstrakcyjnych klas podstawowych i ich klas pochodnych](#abstract) zawiera przykład, który używa abstrakcyjnej klasy bazowej do definiowania metod, które muszą zostać przesłonięte przez klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="c89a2-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="c89a2-212">Klasy pochodne są bezpłatne, aby zapewnić implementację, która jest odpowiednia dla typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="c89a2-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="c89a2-213">Możliwość ponownego użycia kodu (oznacza to, że wiele klas pochodnych korzysta z deklaracji i implementacji metod klasy bazowej i nie trzeba ich przesłonić) jest zaletą nieabstrakcyjnych klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="c89a2-214">W związku z tym należy dodać członków `Publication` do, jeśli ich kod może być współużytkowany przez niektóre lub większość wyspecjalizowanych `Publication` typów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="c89a2-215">Jeśli nie podasz wydajnych implementacji klas podstawowych, będziesz mieć możliwość zapewnienia większości identycznych implementacji elementów członkowskich w klasach pochodnych, a nie pojedynczej implementacji w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="c89a2-216">Konieczność utrzymania duplikatu kodu w wielu lokalizacjach jest potencjalnym źródłem błędów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="c89a2-217">Aby zmaksymalizować użycie kodu i utworzyć logiczną i intuicyjną hierarchię dziedziczenia, należy się upewnić, że należy uwzględnić w `Publication` klasie tylko dane i funkcje wspólne dla wszystkich lub większości publikacji.</span><span class="sxs-lookup"><span data-stu-id="c89a2-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="c89a2-218">Klasy pochodne następnie implementują elementy członkowskie, które są unikatowe dla określonych rodzajów publikacji, które reprezentują.</span><span class="sxs-lookup"><span data-stu-id="c89a2-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="c89a2-219">Jak daleko, aby zwiększyć hierarchię klas.</span><span class="sxs-lookup"><span data-stu-id="c89a2-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="c89a2-220">Czy chcesz opracować hierarchię trzech lub więcej klas, a nie po prostu klasy bazowej i co najmniej jednej klasy pochodnej?</span><span class="sxs-lookup"><span data-stu-id="c89a2-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="c89a2-221">Na `Publication` przykład może być `Magazine` `Periodical`klasą bazową, która z kolei jest klasą bazową, `Journal` i `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="c89a2-222">Przykładowo będziesz używać małej hierarchii `Publication` klasy i pojedynczej `Book`klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="c89a2-223">Można łatwo zwiększyć przykład, aby utworzyć szereg dodatkowych klas, które pochodzą z `Publication`, takich jak `Magazine` i `Article`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-223">You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="c89a2-224">Określa, czy warto utworzyć wystąpienie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="c89a2-225">Jeśli tak nie jest, należy zastosować [abstrakcyjne](../language-reference/keywords/abstract.md) słowo kluczowe do klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="c89a2-226">W przeciwnym razie `Publication` można utworzyć wystąpienie klasy, wywołując jej Konstruktor klas.</span><span class="sxs-lookup"><span data-stu-id="c89a2-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="c89a2-227">Jeśli zostanie podjęta próba utworzenia wystąpienia klasy oznaczonej za pomocą `abstract` słowa kluczowego przez bezpośrednie wywołanie konstruktora klasy, C# kompilator generuje błąd CS0144, "nie można utworzyć wystąpienia klasy abstrakcyjnej lub interfejsu".</span><span class="sxs-lookup"><span data-stu-id="c89a2-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="c89a2-228">Jeśli zostanie podjęta próba utworzenia wystąpienia klasy przy użyciu odbicia, Metoda odbicia zgłasza <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="c89a2-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="c89a2-229">Domyślnie można utworzyć wystąpienie klasy bazowej, wywołując jej Konstruktor klas.</span><span class="sxs-lookup"><span data-stu-id="c89a2-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="c89a2-230">Nie musisz jawnie definiować konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="c89a2-231">Jeśli nie występuje w kodzie źródłowym klasy podstawowej, C# kompilator automatycznie udostępnia domyślny Konstruktor (bez parametrów).</span><span class="sxs-lookup"><span data-stu-id="c89a2-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="c89a2-232">Przykładowo oznaczmy `Publication` klasę jako [abstrakcyjną](../language-reference/keywords/abstract.md) , aby nie można było utworzyć wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c89a2-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="c89a2-233">Klasa bez żadnych `abstract` metod wskazuje, że ta klasa reprezentuje abstrakcyjną koncepcję, która jest współużytkowana przez kilka klas `Book`konkretnych `Journal`(takich jak,). `abstract`</span><span class="sxs-lookup"><span data-stu-id="c89a2-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="c89a2-234">Bez względu na to, czy klasy pochodne muszą dziedziczyć implementację klasy bazowej określonych elementów członkowskich, czy mają opcję przesłaniania implementacji klasy bazowej, czy też muszą dostarczyć implementację.</span><span class="sxs-lookup"><span data-stu-id="c89a2-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="c89a2-235">Aby wymusić implementację klas pochodnych, należy użyć słowa kluczowego [abstract](../language-reference/keywords/abstract.md) .</span><span class="sxs-lookup"><span data-stu-id="c89a2-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="c89a2-236">Możesz użyć słowa kluczowego [Virtual](../language-reference/keywords/virtual.md) , aby umożliwić klasom pochodnym przesłonięcie metody klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="c89a2-237">Domyślnie metody zdefiniowane w klasie bazowej *nie* są możliwe do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="c89a2-237">By default, methods defined in the base class are *not* overridable.</span></span>

 <span data-ttu-id="c89a2-238">Klasa nie ma żadnych `abstract` metod, ale sama klasa to `abstract`. `Publication`</span><span class="sxs-lookup"><span data-stu-id="c89a2-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="c89a2-239">Czy Klasa pochodna reprezentuje ostateczną klasę w hierarchii dziedziczenia i nie może być używana jako klasa bazowa dla dodatkowych klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="c89a2-240">Domyślnie każda klasa może być klasą bazową.</span><span class="sxs-lookup"><span data-stu-id="c89a2-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="c89a2-241">Można zastosować [zapieczętowane](../language-reference/keywords/sealed.md) słowo kluczowe, aby wskazać, że Klasa nie może być klasą bazową dla jakichkolwiek dodatkowych klas.</span><span class="sxs-lookup"><span data-stu-id="c89a2-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="c89a2-242">Podjęto próbę wygenerowania z klasy wygenerowanej przez kompilator błędu kompilatora CS0509 "nie może \<pochodzić od typu zapieczętowanego typ >".</span><span class="sxs-lookup"><span data-stu-id="c89a2-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="c89a2-243">Na przykład należy oznaczyć klasę pochodną jako `sealed`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="c89a2-244">Poniższy przykład pokazuje kod źródłowy dla `Publication` klasy, a także `PublicationType` Wyliczenie `Publication.PublicationType` , które jest zwracane przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="c89a2-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="c89a2-245">Oprócz elementów członkowskich, z <xref:System.Object>których dziedziczy `Publication` , Klasa definiuje następujące unikatowe elementy członkowskie i przesłonięcia elementu członkowskiego:</span><span class="sxs-lookup"><span data-stu-id="c89a2-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="c89a2-246">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="c89a2-246">A constructor</span></span>

  <span data-ttu-id="c89a2-247">Ponieważ Klasa jest `abstract`, nie można utworzyć wystąpienia bezpośrednio w kodzie, podobnie jak w poniższym przykładzie: `Publication`</span><span class="sxs-lookup"><span data-stu-id="c89a2-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="c89a2-248">Jednak jego Konstruktor wystąpień można wywołać bezpośrednio z konstruktorów klas pochodnych, ponieważ kod `Book` źródłowy klasy pokazuje.</span><span class="sxs-lookup"><span data-stu-id="c89a2-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="c89a2-249">Dwie właściwości powiązane z publikacją</span><span class="sxs-lookup"><span data-stu-id="c89a2-249">Two publication-related properties</span></span>

  <span data-ttu-id="c89a2-250">`Title`jest właściwością tylko <xref:System.String> do odczytu, której wartość jest dostarczana przez `Publication` wywołanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c89a2-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="c89a2-251">`Pages`jest właściwością do odczytu <xref:System.Int32> i zapisu, która wskazuje, ile razem stron publikacji ma.</span><span class="sxs-lookup"><span data-stu-id="c89a2-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="c89a2-252">Wartość jest przechowywana w prywatnym polu o nazwie `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="c89a2-253">Musi być liczbą dodatnią lub <xref:System.ArgumentOutOfRangeException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c89a2-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="c89a2-254">Elementy członkowskie powiązane z wydawcą</span><span class="sxs-lookup"><span data-stu-id="c89a2-254">Publisher-related members</span></span>

  <span data-ttu-id="c89a2-255">Dwie właściwości `Publisher` tylko do odczytu i `Type`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="c89a2-256">Wartości są początkowo dostarczane przez wywołanie `Publication` konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="c89a2-257">Elementy członkowskie powiązane z publikowaniem</span><span class="sxs-lookup"><span data-stu-id="c89a2-257">Publishing-related members</span></span>

  <span data-ttu-id="c89a2-258">Dwie metody, `Publish` i `GetPublicationDate`, ustawiają i zwracają datę publikacji.</span><span class="sxs-lookup"><span data-stu-id="c89a2-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="c89a2-259">Metoda ustawia flagę prywatną `published` na `true` kiedy jest wywoływana i przypisuje datę przekazaną do niej jako argument do pola prywatnego `datePublished`. `Publish`</span><span class="sxs-lookup"><span data-stu-id="c89a2-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="c89a2-260">`false` `published` `true` `datePublished` Metoda zwraca ciąg "NYP", jeśli flaga jest i wartość pola, jeśli jest. `GetPublicationDate`</span><span class="sxs-lookup"><span data-stu-id="c89a2-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="c89a2-261">Elementy członkowskie powiązane z prawami autorskimi</span><span class="sxs-lookup"><span data-stu-id="c89a2-261">Copyright-related members</span></span>

  <span data-ttu-id="c89a2-262">Metoda przyjmuje nazwę posiadacza praw autorskich i rok praw autorskich jako argumenty i przypisuje je `CopyrightName` do właściwości i `CopyrightDate`. `Copyright`</span><span class="sxs-lookup"><span data-stu-id="c89a2-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="c89a2-263">Przesłonięcie `ToString` metody</span><span class="sxs-lookup"><span data-stu-id="c89a2-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="c89a2-264">Jeśli typ nie przesłania <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, zwraca w pełni kwalifikowaną nazwę typu, który jest niewielkim użyciem w rozróżnieniu jednego wystąpienia od drugiego.</span><span class="sxs-lookup"><span data-stu-id="c89a2-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="c89a2-265">Klasa przesłania <xref:System.Object.ToString%2A?displayProperty=nameWithType> wartość`Title` właściwości. `Publication`</span><span class="sxs-lookup"><span data-stu-id="c89a2-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="c89a2-266">Na poniższej ilustracji przedstawiono relacje między klasą bazową `Publication` i jej niejawnie dziedziczoną <xref:System.Object> klasą.</span><span class="sxs-lookup"><span data-stu-id="c89a2-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Klasy obiektów i publikacji](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="c89a2-268">`Book` Klasa</span><span class="sxs-lookup"><span data-stu-id="c89a2-268">The `Book` class</span></span>

<span data-ttu-id="c89a2-269">`Book` Klasa reprezentuje książkę jako wyspecjalizowany typ publikacji.</span><span class="sxs-lookup"><span data-stu-id="c89a2-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="c89a2-270">Poniższy przykład pokazuje kod źródłowy dla `Book` klasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="c89a2-271">Oprócz elementów członkowskich, z `Publication`których dziedziczy `Book` , Klasa definiuje następujące unikatowe elementy członkowskie i przesłonięcia elementu członkowskiego:</span><span class="sxs-lookup"><span data-stu-id="c89a2-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="c89a2-272">Dwa konstruktory</span><span class="sxs-lookup"><span data-stu-id="c89a2-272">Two constructors</span></span>

  <span data-ttu-id="c89a2-273">Dwa `Book` konstruktory korzystają z trzech wspólnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="c89a2-274">Dwa, *tytuły* i *Wydawca*odpowiadają `Publication` parametrom konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c89a2-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="c89a2-275">Trzecia jest *autorem*, który jest przechowywany w publicznej niezmiennej `Author` właściwości.</span><span class="sxs-lookup"><span data-stu-id="c89a2-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="c89a2-276">Jeden Konstruktor zawiera parametr *ISBN* , który jest przechowywany we `ISBN` właściwości autoproperty.</span><span class="sxs-lookup"><span data-stu-id="c89a2-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="c89a2-277">Pierwszy Konstruktor używa słowa kluczowego [this](../language-reference/keywords/this.md) do wywołania innego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c89a2-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="c89a2-278">Tworzenie łańcucha konstruktorów jest typowym wzorcem definiującym konstruktory.</span><span class="sxs-lookup"><span data-stu-id="c89a2-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="c89a2-279">Konstruktory z mniejszą liczbą parametrów zapewniają wartości domyślne podczas wywoływania konstruktora przy użyciu największej liczby parametrów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="c89a2-280">Drugi Konstruktor używa słowa kluczowego [Base](../language-reference/keywords/base.md) do przekazania tytułu i nazwy wydawcy do konstruktora klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="c89a2-281">Jeśli nie utworzysz jawnie wywołania konstruktora klasy bazowej w kodzie źródłowym, C# kompilator automatycznie poda wywołanie do konstruktora klasy podstawowej "Default lub bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="c89a2-282">Właściwość tylko `ISBN` do odczytu, która `Book` zwraca międzynarodowy numer standardowej księgi obiektu, unikatowy numer 10 lub 13 cyfr.</span><span class="sxs-lookup"><span data-stu-id="c89a2-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="c89a2-283">ISBN jest dostarczany jako argument do jednego z `Book` konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="c89a2-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="c89a2-284">ISBN jest przechowywany w prywatnym polu zapasowym, które jest automatycznie generowane przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="c89a2-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="c89a2-285">Właściwość tylko `Author` do odczytu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-285">A read-only `Author` property.</span></span> <span data-ttu-id="c89a2-286">Nazwa autora jest dostarczana jako argument do obu `Book` konstruktorów i jest przechowywana we właściwości.</span><span class="sxs-lookup"><span data-stu-id="c89a2-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="c89a2-287">Dwie właściwości `Price` dotyczące cen tylko do odczytu i `Currency`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="c89a2-288">Ich wartości są podawane jako argumenty w `SetPrice` wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="c89a2-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="c89a2-289">`Currency` Właściwość jest symbolem waluty ISO o trzech cyfrach (na przykład USD dla dolara USA).</span><span class="sxs-lookup"><span data-stu-id="c89a2-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="c89a2-290">Symbole waluty ISO można pobrać z <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="c89a2-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="c89a2-291">Obie te właściwości są zewnętrznie tylko do odczytu, ale obie można ustawić przez kod w `Book` klasie.</span><span class="sxs-lookup"><span data-stu-id="c89a2-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="c89a2-292">Metoda, która ustawia wartości `Price` właściwości i `Currency`. `SetPrice`</span><span class="sxs-lookup"><span data-stu-id="c89a2-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="c89a2-293">Te wartości są zwracane przez te same właściwości.</span><span class="sxs-lookup"><span data-stu-id="c89a2-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="c89a2-294">Przesłania `ToString` do metody (dziedziczone z `Publication`) i <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody i <xref:System.Object.GetHashCode%2A> (dziedziczone z <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="c89a2-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="c89a2-295">O ile nie zostanie on zastąpiony, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Metoda sprawdza równość odwołań.</span><span class="sxs-lookup"><span data-stu-id="c89a2-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="c89a2-296">Oznacza to, że dwie zmienne obiektu są uważane za równe, jeśli odwołują się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="c89a2-297">W klasie, z drugiej strony, dwa `Book` obiekty powinny być równe, jeśli mają ten sam ISBN. `Book`</span><span class="sxs-lookup"><span data-stu-id="c89a2-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="c89a2-298">Podczas przesłonięcia <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody należy również <xref:System.Object.GetHashCode%2A> zastąpić metodę, która zwraca wartość używaną przez środowisko uruchomieniowe do przechowywania elementów w kolekcjach skrótów w celu wydajnego pobierania.</span><span class="sxs-lookup"><span data-stu-id="c89a2-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="c89a2-299">Kod skrótu powinien zwracać wartość zgodną z testem dla równości.</span><span class="sxs-lookup"><span data-stu-id="c89a2-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="c89a2-300"><xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Ponieważ zastąpienie `Book` <xref:System.String.GetHashCode%2A> właściwości ISBN dwóch obiektów jest równe, zwracany jest kod skrótu obliczony przez wywołanie metody ciągu zwracanego przez `ISBN` właściwość. `true`</span><span class="sxs-lookup"><span data-stu-id="c89a2-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="c89a2-301">Na poniższej ilustracji przedstawiono relacje między `Book` klasą a `Publication`klasą bazową.</span><span class="sxs-lookup"><span data-stu-id="c89a2-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Klasy publikacji i książek](media/book-class.jpg)

<span data-ttu-id="c89a2-303">Teraz można utworzyć wystąpienie `Book` obiektu, wywołać zarówno unikatowy, jak i dziedziczonych elementów członkowskich, i przekazać go jako argument do metody, która oczekuje parametru typu `Publication` lub typu `Book`, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="c89a2-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="c89a2-304">Projektowanie abstrakcyjnych klas podstawowych i ich klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="c89a2-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="c89a2-305">W poprzednim przykładzie zdefiniowano klasę bazową, która udostępnia implementację wielu metod, aby umożliwić pochodnym klasom współużytkowanie kodu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="c89a2-306">W wielu przypadkach jednak Klasa bazowa nie powinna dostarczyć implementacji.</span><span class="sxs-lookup"><span data-stu-id="c89a2-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="c89a2-307">Zamiast tego Klasa bazowa jest *klasą abstrakcyjną* , która deklaruje *metody abstrakcyjne*; służy jako szablon definiujący składowe, które muszą zostać zaimplementowane przez każdą klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="c89a2-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="c89a2-308">Zwykle w abstrakcyjnej klasie podstawowej implementacja każdego typu pochodnego jest unikatowa dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="c89a2-309">Klasa jest oznaczona za pomocą abstrakcyjnego słowa kluczowego, ponieważ nie ma sensu `Publication` tworzenia wystąpienia obiektu, chociaż Klasa zapewniała implementacje wspólnych funkcji dla publikacji.</span><span class="sxs-lookup"><span data-stu-id="c89a2-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="c89a2-310">Na przykład każdy zamknięty dwuwymiarowy kształt geometryczny zawiera dwie właściwości: obszar, wewnętrzny zakres kształtu; i obwód oraz odległość wzdłuż krawędzi kształtu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="c89a2-311">Jednak sposób, w jaki te właściwości są obliczane, zależy całkowicie od określonego kształtu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="c89a2-312">Formuła służąca do obliczania obwodu (lub obwodu) koła, na przykład, różni się od tego trójkąta.</span><span class="sxs-lookup"><span data-stu-id="c89a2-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="c89a2-313">Klasa jest klasą z `abstract` metodami. `abstract` `Shape`</span><span class="sxs-lookup"><span data-stu-id="c89a2-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="c89a2-314">Wskazuje, że klasy pochodne mają takie same funkcje, ale te klasy pochodne implementują te funkcje w różny sposób.</span><span class="sxs-lookup"><span data-stu-id="c89a2-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="c89a2-315">W poniższym przykładzie zdefiniowano abstrakcyjną klasę bazową o nazwie `Shape` , która definiuje dwie właściwości: `Area` i `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="c89a2-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="c89a2-316">Oprócz oznaczania klasy [abstrakcyjnym](../language-reference/keywords/abstract.md) słowem kluczowym każdy element członkowski wystąpienia jest również oznaczony za pomocą słowa kluczowego [abstract](../language-reference/keywords/abstract.md) .</span><span class="sxs-lookup"><span data-stu-id="c89a2-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="c89a2-317">W takim przypadku `Shape` <xref:System.Object.ToString%2A?displayProperty=nameWithType> przesłania również metodę zwracającą nazwę typu, a nie jego w pełni kwalifikowaną nazwę.</span><span class="sxs-lookup"><span data-stu-id="c89a2-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="c89a2-318">Definiuje dwa statyczne elementy członkowskie `GetArea` i `GetPerimeter`, które umożliwiają wywołującym łatwe pobieranie obszaru i obwodu wystąpienia dowolnej klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="c89a2-319">Gdy przekazujesz wystąpienie klasy pochodnej do jednej z tych metod, środowisko uruchomieniowe wywołuje metodę przesłaniania klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c89a2-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="c89a2-320">Następnie można utworzyć klasy z `Shape` tego, które reprezentują określone kształty.</span><span class="sxs-lookup"><span data-stu-id="c89a2-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="c89a2-321">W poniższym przykładzie zdefiniowano trzy klasy `Triangle`, `Rectangle`,, `Circle`i.</span><span class="sxs-lookup"><span data-stu-id="c89a2-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="c89a2-322">Każda z nich używa formuły unikatowej dla danego kształtu do obliczenia obszaru i obwodu.</span><span class="sxs-lookup"><span data-stu-id="c89a2-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="c89a2-323">Niektóre klasy pochodne definiują również właściwości, takie jak `Rectangle.Diagonal` i `Circle.Diameter`, które są unikatowe dla kształtu, który reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="c89a2-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="c89a2-324">W poniższym przykładzie zastosowano obiekty pochodne `Shape`od.</span><span class="sxs-lookup"><span data-stu-id="c89a2-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="c89a2-325">Tworzy wystąpienie obiektu Array obiektów pochodzących od `Shape` i wywołuje metody `Shape` statyczne klasy, co spowoduje Zawijanie zwracanych `Shape` wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="c89a2-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="c89a2-326">Środowisko uruchomieniowe pobiera wartości z przesłoniętych właściwości typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c89a2-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="c89a2-327">Przykład rzutuje również każdy `Shape` obiekt w tablicy na jego typ pochodny i, jeśli rzutowanie powiedzie się, pobiera właściwości tej konkretnej `Shape`podklasy.</span><span class="sxs-lookup"><span data-stu-id="c89a2-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="c89a2-328">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="c89a2-328">See also</span></span>

- [<span data-ttu-id="c89a2-329">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="c89a2-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="c89a2-330">DziedziczenieC# (Przewodnik programowania)</span><span class="sxs-lookup"><span data-stu-id="c89a2-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
