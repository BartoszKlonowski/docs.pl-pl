---
title: 'Dziedziczenie w C #'
description: Dowiedz się, jak używać dziedziczenia w bibliotekach i aplikacjach języka C#.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: b72badb7833e018dfcbf5d2583b17f17c800c382
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156756"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="af55f-103">Dziedziczenie w języku C# i .NET</span><span class="sxs-lookup"><span data-stu-id="af55f-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="af55f-104">Ten samouczek wprowadza do dziedziczenia w języku C#.</span><span class="sxs-lookup"><span data-stu-id="af55f-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="af55f-105">Dziedziczenie jest cechą języków programowania zorientowanych obiektowo, która umożliwia zdefiniowanie klasy podstawowej, która zapewnia określone funkcje (dane i zachowanie) oraz definiowanie klas pochodnych, które dziedziczą lub zastępują tę funkcję.</span><span class="sxs-lookup"><span data-stu-id="af55f-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="af55f-106">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="af55f-106">Prerequisites</span></span>

<span data-ttu-id="af55f-107">W tym samouczku przyjęto założenie, że zainstalowano zestaw SDK .NET Core.</span><span class="sxs-lookup"><span data-stu-id="af55f-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="af55f-108">Odwiedź stronę [pobierania .NET Core,](https://dotnet.microsoft.com/download) aby ją pobrać.</span><span class="sxs-lookup"><span data-stu-id="af55f-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="af55f-109">Potrzebny jest również edytor kodu.</span><span class="sxs-lookup"><span data-stu-id="af55f-109">You also need a code editor.</span></span> <span data-ttu-id="af55f-110">Ten samouczek używa [kodu programu Visual Studio](https://code.visualstudio.com), chociaż można użyć dowolnego edytora kodu do wyboru.</span><span class="sxs-lookup"><span data-stu-id="af55f-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="af55f-111">Uruchamianie przykładów</span><span class="sxs-lookup"><span data-stu-id="af55f-111">Running the examples</span></span>

<span data-ttu-id="af55f-112">Aby utworzyć i uruchomić przykłady w tym samouczku, należy użyć narzędzia [dotnet](../../core/tools/dotnet.md) z wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="af55f-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="af55f-113">Wykonaj następujące kroki dla każdego przykładu:</span><span class="sxs-lookup"><span data-stu-id="af55f-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="af55f-114">Utwórz katalog do przechowywania przykładu.</span><span class="sxs-lookup"><span data-stu-id="af55f-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="af55f-115">Wprowadź polecenie [dotnet new console](../../core/tools/dotnet-new.md) w wierszu polecenia, aby utworzyć nowy projekt .NET Core.</span><span class="sxs-lookup"><span data-stu-id="af55f-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="af55f-116">Skopiuj i wklej kod z przykładu do edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="af55f-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="af55f-117">Wprowadź polecenie [przywracania dotnetzwy](../../core/tools/dotnet-restore.md) z wiersza polecenia, aby załadować lub przywrócić zależności projektu.</span><span class="sxs-lookup"><span data-stu-id="af55f-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="af55f-118">Wprowadź polecenie [dotnet run,](../../core/tools/dotnet-run.md) aby skompilować i wykonać przykład.</span><span class="sxs-lookup"><span data-stu-id="af55f-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="af55f-119">Tło: Co to jest dziedziczenie?</span><span class="sxs-lookup"><span data-stu-id="af55f-119">Background: What is inheritance?</span></span>

<span data-ttu-id="af55f-120">*Dziedziczenie* jest jednym z podstawowych atrybutów programowania obiektowego.</span><span class="sxs-lookup"><span data-stu-id="af55f-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="af55f-121">Umożliwia zdefiniowanie klasy podrzędnej, która używa ponownie (dziedziczy), rozszerza lub modyfikuje zachowanie klasy nadrzędnej.</span><span class="sxs-lookup"><span data-stu-id="af55f-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="af55f-122">Klasa, której elementy członkowskie są dziedziczone jest nazywany *klasy podstawowej*.</span><span class="sxs-lookup"><span data-stu-id="af55f-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="af55f-123">Klasa, która dziedziczy członków klasy podstawowej jest nazywany *klasy pochodnej*.</span><span class="sxs-lookup"><span data-stu-id="af55f-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="af55f-124">C# i .NET obsługują tylko *pojedyncze dziedziczenie.*</span><span class="sxs-lookup"><span data-stu-id="af55f-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="af55f-125">Oznacza to, że klasa może dziedziczyć tylko z jednej klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="af55f-126">Dziedziczenie jest jednak przechodnie, co umożliwia zdefiniowanie hierarchii dziedziczenia dla zestawu typów.</span><span class="sxs-lookup"><span data-stu-id="af55f-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="af55f-127">Innymi słowy, `D` typ może `C`dziedziczyć z `B`typu , który dziedziczy z typu , który dziedziczy z typu `A`klasy podstawowej .</span><span class="sxs-lookup"><span data-stu-id="af55f-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="af55f-128">Ponieważ dziedziczenie jest przechodnie, `A` elementy członkowskie `D`typu są dostępne do typu .</span><span class="sxs-lookup"><span data-stu-id="af55f-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="af55f-129">Nie wszystkie elementy członkowskie klasy podstawowej są dziedziczone przez klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="af55f-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="af55f-130">Następujące elementy członkowskie nie są dziedziczone:</span><span class="sxs-lookup"><span data-stu-id="af55f-130">The following members are not inherited:</span></span>

- <span data-ttu-id="af55f-131">[Konstruktory statyczne](../programming-guide/classes-and-structs/static-constructors.md), które inicjują dane statyczne klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="af55f-132">[Konstruktory wystąpienia](../programming-guide/classes-and-structs/constructors.md), które można wywołać, aby utworzyć nowe wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="af55f-133">Każda klasa musi zdefiniować własne konstruktory.</span><span class="sxs-lookup"><span data-stu-id="af55f-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="af55f-134">[Finalizatory](../programming-guide/classes-and-structs/destructors.md), które są wywoływane przez moduł zbierający elementy bezużyteczne w czasie wykonywania, aby zniszczyć wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="af55f-135">Podczas gdy wszystkie inne elementy członkowskie klasy podstawowej są dziedziczone przez klasy pochodne, czy są one widoczne, czy nie zależy od ich dostępności.</span><span class="sxs-lookup"><span data-stu-id="af55f-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="af55f-136">Dostępność elementu członkowskiego wpływa na jego widoczność dla klas pochodnych w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="af55f-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="af55f-137">[Elementy członkowskie prywatne](../language-reference/keywords/private.md) są widoczne tylko w klasach pochodnych, które są zagnieżdżone w ich klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="af55f-138">W przeciwnym razie nie są one widoczne w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="af55f-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="af55f-139">W poniższym `A.B` przykładzie jest zagnieżdżona `C` klasa, `A`która pochodzi od `A`i pochodzi od .</span><span class="sxs-lookup"><span data-stu-id="af55f-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="af55f-140">Pole `A.value` prywatne jest widoczne w polu A.B.</span><span class="sxs-lookup"><span data-stu-id="af55f-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="af55f-141">Jeśli jednak usuniesz `C.GetValue` komentarze z metody i spróbujesz skompilować przykład, utworzy błąd kompilatora CS0122: "A.value" jest niedostępny ze względu na poziom ochrony."</span><span class="sxs-lookup"><span data-stu-id="af55f-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="af55f-142">[Chronione](../language-reference/keywords/protected.md) elementy członkowskie są widoczne tylko w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="af55f-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="af55f-143">[Elementy członkowskie wewnętrzne](../language-reference/keywords/internal.md) są widoczne tylko w klasach pochodnych, które znajdują się w tym samym zestawie co klasa podstawowa.</span><span class="sxs-lookup"><span data-stu-id="af55f-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="af55f-144">Nie są one widoczne w klasach pochodnych znajdujących się w innym zestawie niż klasa podstawowa.</span><span class="sxs-lookup"><span data-stu-id="af55f-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="af55f-145">[Elementy akcyjne](../language-reference/keywords/public.md) są widoczne w klasach pochodnych i są częścią interfejsu publicznego klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="af55f-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="af55f-146">Publiczne dziedziczone elementy członkowskie można wywołać tak, jakby były zdefiniowane w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="af55f-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="af55f-147">W poniższym przykładzie `A` klasa definiuje `Method1`metodę o `B` nazwie , `A`a klasa dziedziczy z klasy .</span><span class="sxs-lookup"><span data-stu-id="af55f-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="af55f-148">Przykład następnie `Method1` wywołuje tak, jakby była `B`to metoda instancji na .</span><span class="sxs-lookup"><span data-stu-id="af55f-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="af55f-149">Klasy pochodne można również *zastąpić* dziedziczone elementy członkowskie, zapewniając implementację alternatywną.</span><span class="sxs-lookup"><span data-stu-id="af55f-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="af55f-150">Aby można było zastąpić element członkowski, element członkowski w klasie podstawowej musi być oznaczony [wirtualnym](../language-reference/keywords/virtual.md) słowem kluczowym.</span><span class="sxs-lookup"><span data-stu-id="af55f-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="af55f-151">Domyślnie elementy członkowskie klasy podstawowej nie są oznaczone jako `virtual` i nie można ich zastąpić.</span><span class="sxs-lookup"><span data-stu-id="af55f-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="af55f-152">Próba zastąpienia elementu członkowskiego niewirtualnego, jak w poniższym przykładzie, generuje błąd kompilatora CS0506: "\<element członkowski> nie może zastąpić dziedziczonego członka elementu członkowskiego \<> ponieważ nie jest oznaczony jako wirtualny, abstrakcyjny lub zastępowany.</span><span class="sxs-lookup"><span data-stu-id="af55f-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="af55f-153">W niektórych przypadkach klasa pochodna *musi* zastąpić implementacji klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="af55f-154">Członkowie klasy podstawowej oznaczone [abstrakcyjne](../language-reference/keywords/abstract.md) słowo kluczowe wymagają, że klasy pochodne zastąpić je.</span><span class="sxs-lookup"><span data-stu-id="af55f-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="af55f-155">Próba skompilowania w poniższym przykładzie generuje błąd kompilatora CS0534, "&lt;klasa&gt; nie implementuje dziedziczonego abstrakcyjnego elementu członkowskiego &lt;&gt;", ponieważ klasa `B` nie zapewnia implementacji dla `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="af55f-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="af55f-156">Dziedziczenie ma zastosowanie tylko do klas i interfejsów.</span><span class="sxs-lookup"><span data-stu-id="af55f-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="af55f-157">Inne kategorie typów (struktury, delegatów i wyliczenia) nie obsługują dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="af55f-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="af55f-158">Ze względu na te reguły, próbując skompilować kod, jak w poniższym przykładzie tworzy błąd kompilatora CS0527: "Typ 'ValueType' na liście interfejsu nie jest interfejsem."</span><span class="sxs-lookup"><span data-stu-id="af55f-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="af55f-159">Komunikat o błędzie wskazuje, że chociaż można zdefiniować interfejsy, które implementuje struktury, dziedziczenie nie jest obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="af55f-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="af55f-160">Dziedziczenie niejawne</span><span class="sxs-lookup"><span data-stu-id="af55f-160">Implicit inheritance</span></span>

<span data-ttu-id="af55f-161">Oprócz wszelkich typów, które mogą dziedziczyć z za pośrednictwem pojedynczego dziedziczenia, wszystkie typy w systemie typu .NET niejawnie dziedziczą lub <xref:System.Object> typu pochodzącego z niego.</span><span class="sxs-lookup"><span data-stu-id="af55f-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="af55f-162">Wspólna funkcjonalność <xref:System.Object> jest dostępna dla każdego typu.</span><span class="sxs-lookup"><span data-stu-id="af55f-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="af55f-163">Aby zobaczyć, co oznacza niejawne dziedziczenie, zdefiniujmy nową klasę, `SimpleClass`która jest po prostu pustą definicją klasy:</span><span class="sxs-lookup"><span data-stu-id="af55f-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="af55f-164">Następnie można użyć odbicia (który pozwala sprawdzić metadane typu, aby uzyskać informacje o tym typie), `SimpleClass` aby uzyskać listę elementów członkowskich, które należą do typu.</span><span class="sxs-lookup"><span data-stu-id="af55f-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="af55f-165">Mimo że nie zdefiniowano żadnych `SimpleClass` elementów członkowskich w klasie, dane wyjściowe z przykładu wskazuje, że faktycznie ma dziewięć elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="af55f-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="af55f-166">Jeden z tych elementów członkowskich jest konstruktorem bezparametrów (lub domyślnym), który jest automatycznie dostarczany dla `SimpleClass` typu przez kompilator C#.</span><span class="sxs-lookup"><span data-stu-id="af55f-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="af55f-167">Pozostałe osiem są <xref:System.Object>członkami , typ, z którego wszystkie klasy i interfejsy w systemie typu .NET ostatecznie niejawnie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="af55f-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="af55f-168">Niejawne <xref:System.Object> dziedziczenie z klasy `SimpleClass` udostępnia te metody klasie:</span><span class="sxs-lookup"><span data-stu-id="af55f-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="af55f-169">Metoda `ToString` publiczna, która konwertuje `SimpleClass` obiekt na jego reprezentację ciągu, zwraca w pełni kwalifikowaną nazwę typu.</span><span class="sxs-lookup"><span data-stu-id="af55f-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="af55f-170">W takim przypadku `ToString` metoda zwraca ciąg "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="af55f-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="af55f-171">Trzy metody, które testują na równość `Equals(Object)` dwóch obiektów: `Equals(Object, Object)` metoda wystąpienia publicznego, publiczna metoda statyczna i publiczna metoda statyczna. `ReferenceEquals(Object, Object)`</span><span class="sxs-lookup"><span data-stu-id="af55f-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="af55f-172">Domyślnie te metody testują równość odniesienia; oznacza to, że aby być równym, dwie zmienne obiektowe muszą odwoływać się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="af55f-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="af55f-173">Metoda `GetHashCode` publiczna, która oblicza wartość, która umożliwia wystąpienie typu, który ma być używany w kolekcjach haszhed.</span><span class="sxs-lookup"><span data-stu-id="af55f-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="af55f-174">Metoda `GetType` publiczna, która <xref:System.Type> zwraca obiekt, `SimpleClass` który reprezentuje typ.</span><span class="sxs-lookup"><span data-stu-id="af55f-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="af55f-175">Metoda <xref:System.Object.Finalize%2A> chroniona, która jest przeznaczona do zwalniania zasobów niezarządzanych, zanim pamięć obiektu zostanie odzyskana przez moduł zbierający elementy bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="af55f-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="af55f-176">Metoda <xref:System.Object.MemberwiseClone%2A> chroniona, która tworzy płytki klon bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="af55f-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="af55f-177">Ze względu na niejawne dziedziczenie, `SimpleClass` można wywołać dowolnego dziedziczonego elementu `SimpleClass` członkowskiego z obiektu, tak jakby był rzeczywiście element członkowski zdefiniowany w klasie.</span><span class="sxs-lookup"><span data-stu-id="af55f-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="af55f-178">Na przykład poniższy przykład `SimpleClass.ToString` wywołuje metodę, `SimpleClass` która <xref:System.Object>dziedziczy z .</span><span class="sxs-lookup"><span data-stu-id="af55f-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="af55f-179">W poniższej tabeli wymieniono kategorie typów, które można utworzyć w języku C# i typy, z których niejawnie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="af55f-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="af55f-180">Każdy typ podstawowy udostępnia inny zestaw elementów członkowskich za pośrednictwem dziedziczenia do typów niejawnie pochodnych.</span><span class="sxs-lookup"><span data-stu-id="af55f-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="af55f-181">Kategoria typu</span><span class="sxs-lookup"><span data-stu-id="af55f-181">Type category</span></span> | <span data-ttu-id="af55f-182">Niejawnie dziedziczy z</span><span class="sxs-lookup"><span data-stu-id="af55f-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="af55f-183">class</span><span class="sxs-lookup"><span data-stu-id="af55f-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="af55f-184">struktura </span><span class="sxs-lookup"><span data-stu-id="af55f-184">struct</span></span>        | <span data-ttu-id="af55f-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="af55f-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="af55f-186">enum</span><span class="sxs-lookup"><span data-stu-id="af55f-186">enum</span></span>          | <span data-ttu-id="af55f-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="af55f-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="af55f-188">delegate</span><span class="sxs-lookup"><span data-stu-id="af55f-188">delegate</span></span>      | <span data-ttu-id="af55f-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="af55f-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="af55f-190">Dziedziczenie i relacja "jest"</span><span class="sxs-lookup"><span data-stu-id="af55f-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="af55f-191">Zwykle dziedziczenie służy do wyrażania relacji "jest" między klasą podstawową a jedną lub większą liczbą klas pochodnych, gdzie klasy pochodne są wyspecjalizowanymi wersjami klasy podstawowej; klasa pochodna jest typem klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="af55f-192">Na przykład `Publication` klasa reprezentuje publikację dowolnego rodzaju, `Book` `Magazine` a i klasy reprezentują określone typy publikacji.</span><span class="sxs-lookup"><span data-stu-id="af55f-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="af55f-193">Klasa lub struktura może zaimplementować jeden lub więcej interfejsów.</span><span class="sxs-lookup"><span data-stu-id="af55f-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="af55f-194">Podczas gdy implementacja interfejsu jest często przedstawiana jako obejście dla pojedynczego dziedziczenia lub jako sposób używania dziedziczenia z strukturami, ma na celu wyrażenie innej relacji (relacji "można zrobić") między interfejsem a jego typem implementującym niż Dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="af55f-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="af55f-195">Interfejs definiuje podzbiór funkcji (takich jak możliwość testowania równości, porównywania lub sortowania obiektów lub obsługi analizowania i formatowania zależnego od kultury), które interfejs udostępnia swoim typom implementacji.</span><span class="sxs-lookup"><span data-stu-id="af55f-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="af55f-196">Należy zauważyć, że "is a" wyraża również relację między typem a określonym wystąpienia tego typu.</span><span class="sxs-lookup"><span data-stu-id="af55f-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="af55f-197">W poniższym `Automobile` przykładzie jest to klasa, która ma `Make`trzy unikalne właściwości tylko do odczytu: , producent samochodu; `Model`, rodzaj samochodu; i `Year`, rok produkcji.</span><span class="sxs-lookup"><span data-stu-id="af55f-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="af55f-198">Klasa `Automobile` ma również konstruktora, którego argumenty są przypisane do <xref:System.Object.ToString%2A?displayProperty=nameWithType> wartości właściwości i zastępuje metodę `Automobile` do tworzenia `Automobile` ciągu, który jednoznacznie identyfikuje wystąpienie, a nie klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="af55f-199">W takim przypadku nie należy polegać na dziedziczeniu do reprezentowania konkretnych marek samochodów i modeli.</span><span class="sxs-lookup"><span data-stu-id="af55f-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="af55f-200">Na przykład nie trzeba definiować typu reprezentującego `Packard` samochody produkowane przez Firmę Motorową Packard.</span><span class="sxs-lookup"><span data-stu-id="af55f-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="af55f-201">Zamiast tego można je reprezentować, tworząc `Automobile` obiekt z odpowiednimi wartościami przekazanymi do jego konstruktora klasy, tak jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="af55f-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="af55f-202">Relacja jest oparta na dziedziczeniu najlepiej jest stosowana do klasy podstawowej i klas pochodnych, które dodają dodatkowe elementy członkowskie do klasy podstawowej lub które wymagają dodatkowych funkcji nieobecnych w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="af55f-203">Projektowanie klasy podstawowej i klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="af55f-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="af55f-204">Przyjrzyjmy się procesowi projektowania klasy podstawowej i jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="af55f-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="af55f-205">W tej sekcji zdefiniujesz klasę `Publication`podstawową, która reprezentuje wszelkiego rodzaju publikacje, takie jak książka, czasopismo, gazeta, czasopismo, artykuł itp. Zdefiniujesz również `Book` klasę, która `Publication`wywodzi się z .</span><span class="sxs-lookup"><span data-stu-id="af55f-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="af55f-206">Można łatwo rozszerzyć przykład, aby zdefiniować inne `Magazine`klasy `Journal` `Newspaper`pochodne, takie jak , , , i `Article`.</span><span class="sxs-lookup"><span data-stu-id="af55f-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="af55f-207">Podstawowa klasa publikacji</span><span class="sxs-lookup"><span data-stu-id="af55f-207">The base Publication class</span></span>

<span data-ttu-id="af55f-208">Projektując swoją `Publication` klasę, musisz podjąć kilka decyzji projektowych:</span><span class="sxs-lookup"><span data-stu-id="af55f-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="af55f-209">Jakie elementy członkowskie do `Publication` uwzględnienia w `Publication` klasie podstawowej i `Publication` czy członkowie zapewniają implementacje metody lub czy jest abstrakcyjną klasą podstawową, która służy jako szablon dla jego klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="af55f-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="af55f-210">W takim przypadku `Publication` klasa zapewni implementacje metody.</span><span class="sxs-lookup"><span data-stu-id="af55f-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="af55f-211">[Projektowanie abstrakcyjnych klas podstawowych i ich klasy pochodne](#abstract) sekcja zawiera przykład, który używa abstrakcyjnej klasy podstawowej do definiowania metod, które klasy pochodne należy zastąpić.</span><span class="sxs-lookup"><span data-stu-id="af55f-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="af55f-212">Klasy pochodne mogą zapewnić dowolną implementację, która jest odpowiednia dla typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="af55f-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="af55f-213">Możliwość ponownego użycia kodu (czyli wiele klas pochodnych współużytkują deklarację i implementację metod klasy podstawowej i nie muszą je zastępować) jest zaletą nieabstrakcyjnych klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="af55f-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="af55f-214">W związku z tym `Publication` należy dodać członków, jeśli ich kod `Publication` może być współużytkowany przez niektóre lub najbardziej wyspecjalizowanych typów.</span><span class="sxs-lookup"><span data-stu-id="af55f-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="af55f-215">Jeśli nie uda ci się zapewnić implementacje klasy podstawowej wydajnie, będziesz musiał podać w dużej mierze identyczne implementacje elementów członkowskich w klasach pochodnych, a pojedynczą implementację w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="af55f-216">Konieczność utrzymywania zduplikowanego kodu w wielu lokalizacjach jest potencjalnym źródłem błędów.</span><span class="sxs-lookup"><span data-stu-id="af55f-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="af55f-217">Zarówno w celu zmaksymalizowania ponownego użycia kodu, jak i do utworzenia logicznej i intuicyjnej hierarchii dziedziczenia, należy mieć pewność, że w `Publication` klasie są uwzględniane tylko dane i funkcje, które są wspólne dla wszystkich lub dla większości publikacji.</span><span class="sxs-lookup"><span data-stu-id="af55f-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="af55f-218">Klasy pochodne następnie implementują elementy członkowskie, które są unikatowe dla określonych rodzajów publikacji, które reprezentują.</span><span class="sxs-lookup"><span data-stu-id="af55f-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="af55f-219">Jak daleko rozszerzyć hierarchię klas.</span><span class="sxs-lookup"><span data-stu-id="af55f-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="af55f-220">Czy chcesz opracować hierarchię trzech lub więcej klas, a nie tylko klasy podstawowej i jednej lub więcej klas pochodnych?</span><span class="sxs-lookup"><span data-stu-id="af55f-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="af55f-221">Na przykład `Publication` może być klasą `Periodical`podstawową , która `Magazine`z `Journal` `Newspaper`kolei jest klasą podstawową , i .</span><span class="sxs-lookup"><span data-stu-id="af55f-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="af55f-222">W przykładzie użyjesz małej hierarchii `Publication` klasy i pojedynczej `Book`klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="af55f-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="af55f-223">Można łatwo rozszerzyć przykład, aby utworzyć szereg dodatkowych `Publication`klas, `Magazine` które `Article`pochodzą z , takich jak i .</span><span class="sxs-lookup"><span data-stu-id="af55f-223">You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="af55f-224">Czy ma sens tworzenie wystąpienia klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="af55f-225">Jeśli nie, należy zastosować [abstrakcyjne](../language-reference/keywords/abstract.md) słowo kluczowe do klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="af55f-226">W przeciwnym `Publication` razie klasy można utworzyć wystąpienia przez wywołanie jego konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="af55f-227">Jeśli zostanie podjęta próba utworzenia wystąpienia klasy oznaczonej `abstract` słowem kluczowym przez bezpośrednie wywołanie jego konstruktora klasy, kompilator C# generuje błąd CS0144, "Nie można utworzyć wystąpienia klasy abstrakcyjnej lub interfejsu."</span><span class="sxs-lookup"><span data-stu-id="af55f-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="af55f-228">Jeśli zostanie podjęta próba wystąpienia klasy przy użyciu odbicia, metoda odbicia <xref:System.MemberAccessException>wyrzuci .</span><span class="sxs-lookup"><span data-stu-id="af55f-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="af55f-229">Domyślnie klasy podstawowej można utworzyć wystąpienia przez wywołanie jego konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="af55f-230">Nie trzeba jawnie zdefiniować konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="af55f-231">Jeśli nie jest obecny w kodzie źródłowym klasy podstawowej, kompilator C# automatycznie udostępnia domyślny (bezparametrowy) konstruktor.</span><span class="sxs-lookup"><span data-stu-id="af55f-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="af55f-232">W przykładzie oznaczysz `Publication` klasę jako [abstrakcyjną,](../language-reference/keywords/abstract.md) aby nie można było jej utworzyć.</span><span class="sxs-lookup"><span data-stu-id="af55f-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="af55f-233">Klasa `abstract` bez `abstract` żadnych metod wskazuje, że ta klasa reprezentuje abstrakcyjną koncepcję, `Book` `Journal`która jest współużytkowana przez kilka konkretnych klas (takich jak , ).</span><span class="sxs-lookup"><span data-stu-id="af55f-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="af55f-234">Czy klasy pochodne muszą dziedziczyć implementacji klasy podstawowej określonych elementów członkowskich, czy mają możliwość zastąpienia implementacji klasy podstawowej lub czy muszą one zapewnić implementację.</span><span class="sxs-lookup"><span data-stu-id="af55f-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="af55f-235">Użyj [abstrakcyjne](../language-reference/keywords/abstract.md) słowo kluczowe wymusić klasy pochodne, aby zapewnić implementację.</span><span class="sxs-lookup"><span data-stu-id="af55f-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="af55f-236">Słowo kluczowe [virtual](../language-reference/keywords/virtual.md) umożliwia klasy pochodne, aby zastąpić metodę klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="af55f-237">Domyślnie metody zdefiniowane w klasie podstawowej *nie* są nadawalne.</span><span class="sxs-lookup"><span data-stu-id="af55f-237">By default, methods defined in the base class are *not* overridable.</span></span>

 <span data-ttu-id="af55f-238">Klasa `Publication` nie ma `abstract` żadnych metod, ale sama `abstract`klasa jest .</span><span class="sxs-lookup"><span data-stu-id="af55f-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="af55f-239">Czy klasa pochodna reprezentuje ostateczną klasę w hierarchii dziedziczenia i sama nie może być używana jako klasa podstawowa dla dodatkowych klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="af55f-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="af55f-240">Domyślnie każda klasa może służyć jako klasa podstawowa.</span><span class="sxs-lookup"><span data-stu-id="af55f-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="af55f-241">Można zastosować [zapieczętowane](../language-reference/keywords/sealed.md) słowo kluczowe, aby wskazać, że klasa nie może służyć jako klasa podstawowa dla żadnych dodatkowych klas.</span><span class="sxs-lookup"><span data-stu-id="af55f-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="af55f-242">Próbując wyprowadzić z zapieczętowanej klasy wygenerowany błąd kompilatora CS0509, "nie może pochodzić z typu zapieczętowanego \<typem>".</span><span class="sxs-lookup"><span data-stu-id="af55f-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="af55f-243">Na przykład oznaczysz klasę pochodną `sealed`jako .</span><span class="sxs-lookup"><span data-stu-id="af55f-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="af55f-244">W poniższym przykładzie przedstawiono `Publication` kod źródłowy `PublicationType` dla klasy, a także `Publication.PublicationType` wyliczenie, które jest zwracane przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="af55f-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="af55f-245">Oprócz elementów członkowskich, które dziedziczy z <xref:System.Object>, `Publication` klasa definiuje następujące unikatowe elementy członkowskie i zastąpienia elementów członkowskich:</span><span class="sxs-lookup"><span data-stu-id="af55f-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="af55f-246">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="af55f-246">A constructor</span></span>

  <span data-ttu-id="af55f-247">Ponieważ `Publication` klasa `abstract`jest , nie można utworzyć wystąpienia bezpośrednio z kodu, jak w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="af55f-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="af55f-248">Jednak jego konstruktor wystąpienia można wywołać bezpośrednio z pochodnych konstruktorów klas, jak pokazuje kod źródłowy `Book` dla klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="af55f-249">Dwie właściwości związane z publikacją</span><span class="sxs-lookup"><span data-stu-id="af55f-249">Two publication-related properties</span></span>

  <span data-ttu-id="af55f-250">`Title`jest właściwością <xref:System.String> tylko do odczytu, której `Publication` wartość jest dostarczana przez wywołanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="af55f-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="af55f-251">`Pages`jest właściwością <xref:System.Int32> odczytu i zapisu, która wskazuje, ile całkowita liczba stron publikacji ma.</span><span class="sxs-lookup"><span data-stu-id="af55f-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="af55f-252">Wartość jest przechowywana w `totalPages`polu prywatnym o nazwie .</span><span class="sxs-lookup"><span data-stu-id="af55f-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="af55f-253">Musi to być liczba <xref:System.ArgumentOutOfRangeException> dodatnia lub wyrzucona.</span><span class="sxs-lookup"><span data-stu-id="af55f-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="af55f-254">Członkowie związani z wydawcą</span><span class="sxs-lookup"><span data-stu-id="af55f-254">Publisher-related members</span></span>

  <span data-ttu-id="af55f-255">Dwie właściwości tylko do `Publisher` `Type`odczytu i .</span><span class="sxs-lookup"><span data-stu-id="af55f-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="af55f-256">Wartości są pierwotnie dostarczane przez wywołanie konstruktora `Publication` klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="af55f-257">Członkowie związani z publikowaniem</span><span class="sxs-lookup"><span data-stu-id="af55f-257">Publishing-related members</span></span>

  <span data-ttu-id="af55f-258">Dwie metody `Publish` i `GetPublicationDate`, ustawić i zwrócić datę publikacji.</span><span class="sxs-lookup"><span data-stu-id="af55f-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="af55f-259">Metoda `Publish` ustawia flagę `published` prywatną, gdy `true` jest wywoływana i przypisuje datę `datePublished` przekazaną do niej jako argument do pola prywatnego.</span><span class="sxs-lookup"><span data-stu-id="af55f-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="af55f-260">Metoda `GetPublicationDate` zwraca ciąg "NYP", `published` jeśli `false`flaga jest , `datePublished` a wartość `true`pola, jeśli jest .</span><span class="sxs-lookup"><span data-stu-id="af55f-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="af55f-261">Członkowie związani z prawami autorskimi</span><span class="sxs-lookup"><span data-stu-id="af55f-261">Copyright-related members</span></span>

  <span data-ttu-id="af55f-262">Metoda `Copyright` przyjmuje nazwę posiadacza praw autorskich i rok praw autorskich `CopyrightName` jako `CopyrightDate` argumenty i przypisuje je do i właściwości.</span><span class="sxs-lookup"><span data-stu-id="af55f-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="af55f-263">Zastąpienie `ToString` metody</span><span class="sxs-lookup"><span data-stu-id="af55f-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="af55f-264">Jeśli typ nie zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, zwraca w pełni kwalifikowaną nazwę typu, która jest mało użyteczna w odróżnianiu jednego wystąpienia od innego.</span><span class="sxs-lookup"><span data-stu-id="af55f-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="af55f-265">Klasa `Publication` zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> zwracać wartość `Title` właściwości.</span><span class="sxs-lookup"><span data-stu-id="af55f-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="af55f-266">Na poniższej ilustracji przedstawiono `Publication` relację między klasą <xref:System.Object> podstawową a jej niejawnie dziedziczoną klasą.</span><span class="sxs-lookup"><span data-stu-id="af55f-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Klasy Obiekt i publikacja](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="af55f-268">Klasa `Book`</span><span class="sxs-lookup"><span data-stu-id="af55f-268">The `Book` class</span></span>

<span data-ttu-id="af55f-269">Klasa `Book` reprezentuje książkę jako wyspecjalizowany typ publikacji.</span><span class="sxs-lookup"><span data-stu-id="af55f-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="af55f-270">W poniższym przykładzie przedstawiono `Book` kod źródłowy dla klasy.</span><span class="sxs-lookup"><span data-stu-id="af55f-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="af55f-271">Oprócz elementów członkowskich, które dziedziczy z `Publication`, `Book` klasa definiuje następujące unikatowe elementy członkowskie i zastąpienia elementów członkowskich:</span><span class="sxs-lookup"><span data-stu-id="af55f-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="af55f-272">Dwa konstruktory</span><span class="sxs-lookup"><span data-stu-id="af55f-272">Two constructors</span></span>

  <span data-ttu-id="af55f-273">Dwa `Book` konstruktory mają trzy wspólne parametry.</span><span class="sxs-lookup"><span data-stu-id="af55f-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="af55f-274">Dwa, *tytuł* i *wydawca*, `Publication` odpowiadają parametrom konstruktora.</span><span class="sxs-lookup"><span data-stu-id="af55f-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="af55f-275">Trzeci to *autor*, który jest przechowywany `Author` w publicznej nieruchomości niezmiennej.</span><span class="sxs-lookup"><span data-stu-id="af55f-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="af55f-276">Jeden konstruktor zawiera parametr *isbn,* który jest przechowywany w `ISBN` auto-właściwości.</span><span class="sxs-lookup"><span data-stu-id="af55f-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="af55f-277">Pierwszy konstruktor używa [tego](../language-reference/keywords/this.md) słowa kluczowego do wywołania innego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="af55f-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="af55f-278">Łańcuchkonstruktora jest typowym wzorcem w definiowaniu konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="af55f-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="af55f-279">Konstruktorzy z mniejszą liczbą parametrów zapewniają wartości domyślne podczas wywoływania konstruktora z największą liczbą parametrów.</span><span class="sxs-lookup"><span data-stu-id="af55f-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="af55f-280">Drugi konstruktor używa [podstawowego](../language-reference/keywords/base.md) słowa kluczowego, aby przekazać tytuł i nazwę wydawcy do konstruktora klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="af55f-281">Jeśli nie wygłoszą jawne wywołanie konstruktora klasy podstawowej w kodzie źródłowym, kompilator C# automatycznie dostarcza wywołanie domyślnego lub parametrnego konstruktora klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="af55f-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="af55f-282">Właściwość tylko `ISBN` do odczytu, `Book` która zwraca obiektinternational standard book number, unikatowy numer 10- lub 13-cyfrowy.</span><span class="sxs-lookup"><span data-stu-id="af55f-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="af55f-283">NUMER ISBN jest dostarczany jako argument `Book` do jednego z konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="af55f-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="af55f-284">Numer ISBN jest przechowywany w prywatnym polu zapasowym, które jest automatycznie generowane przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="af55f-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="af55f-285">Właściwość tylko `Author` do odczytu.</span><span class="sxs-lookup"><span data-stu-id="af55f-285">A read-only `Author` property.</span></span> <span data-ttu-id="af55f-286">Nazwa autora jest dostarczana jako `Book` argument do obu konstruktorów i jest przechowywana we właściwości.</span><span class="sxs-lookup"><span data-stu-id="af55f-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="af55f-287">Dwie właściwości związane z ceną `Price` tylko `Currency`do odczytu i .</span><span class="sxs-lookup"><span data-stu-id="af55f-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="af55f-288">Ich wartości są dostarczane `SetPrice` jako argumenty w wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="af55f-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="af55f-289">Właściwość `Currency` jest trzycyfrowym symbolem waluty ISO (na przykład USD za dolara amerykańskiego).</span><span class="sxs-lookup"><span data-stu-id="af55f-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="af55f-290">Symbole waluty ISO można pobrać <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> z obiektu.</span><span class="sxs-lookup"><span data-stu-id="af55f-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="af55f-291">Obie te właściwości są zewnętrznie tylko do odczytu, ale `Book` oba mogą być ustawione przez kod w klasie.</span><span class="sxs-lookup"><span data-stu-id="af55f-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="af55f-292">Metoda, `SetPrice` która ustawia wartości `Price` i `Currency` właściwości.</span><span class="sxs-lookup"><span data-stu-id="af55f-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="af55f-293">Te wartości są zwracane przez te same właściwości.</span><span class="sxs-lookup"><span data-stu-id="af55f-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="af55f-294">Zastępuje `ToString` metodę (dziedziczoną `Publication` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> z ) <xref:System.Object.GetHashCode%2A> i i metody <xref:System.Object>(dziedziczone z ).</span><span class="sxs-lookup"><span data-stu-id="af55f-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="af55f-295">Chyba że jest zastąpiona, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda testuje dla równości referencyjnej.</span><span class="sxs-lookup"><span data-stu-id="af55f-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="af55f-296">Oznacza to, że dwie zmienne obiektowe są uważane za równe, jeśli odnoszą się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="af55f-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="af55f-297">W `Book` klasie, z drugiej strony, dwa `Book` obiekty powinny być równe, jeśli mają ten sam ISBN.</span><span class="sxs-lookup"><span data-stu-id="af55f-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="af55f-298">Podczas zastępowania <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody, należy również <xref:System.Object.GetHashCode%2A> zastąpić metodę, która zwraca wartość, która jest używana do przechowywania elementów w kolekcjach haszhed dla wydajnego pobierania.</span><span class="sxs-lookup"><span data-stu-id="af55f-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="af55f-299">Kod skrótu powinien zwracać wartość, która jest zgodna z testem równości.</span><span class="sxs-lookup"><span data-stu-id="af55f-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="af55f-300">Ponieważ zostały zastąpione <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> do `true` zwrócenia, jeśli isbn `Book` właściwości dwóch obiektów są równe, należy zwrócić <xref:System.String.GetHashCode%2A> kod skrótu obliczone `ISBN` przez wywołanie metody ciągu zwrócone przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="af55f-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="af55f-301">Na poniższej ilustracji przedstawiono `Book` relację między klasą a `Publication`jej klasą podstawową.</span><span class="sxs-lookup"><span data-stu-id="af55f-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Zajęcia z publikacji i książek](media/book-class.jpg)

<span data-ttu-id="af55f-303">Teraz można utworzyć wystąpienia `Book` obiektu, wywołać zarówno jego unikatowe i dziedziczone elementy członkowskie i przekazać `Publication` go jako `Book`argument do metody, która oczekuje parametr typu lub typu , jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="af55f-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="af55f-304">Projektowanie abstrakcyjnych klas podstawowych i ich klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="af55f-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="af55f-305">W poprzednim przykładzie zdefiniowano klasę podstawową, która dostarczyła implementację dla wielu metod, aby umożliwić klasy pochodne do udostępniania kodu.</span><span class="sxs-lookup"><span data-stu-id="af55f-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="af55f-306">W wielu przypadkach jednak klasa podstawowa nie oczekuje się, aby zapewnić implementację.</span><span class="sxs-lookup"><span data-stu-id="af55f-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="af55f-307">Zamiast tego klasa podstawowa jest *klasą abstrakcyjną,* która deklaruje *metody abstrakcyjne;* służy jako szablon, który definiuje elementy członkowskie, które każda klasa pochodna musi zaimplementować.</span><span class="sxs-lookup"><span data-stu-id="af55f-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="af55f-308">Zazwyczaj w abstrakcyjnej klasie podstawowej implementacja każdego typu pochodnego jest unikatowa dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="af55f-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="af55f-309">Oznaczyłeś klasę abstrakcyjnym słowem kluczowym, ponieważ nie `Publication` ma sensu utworzyć wystąpienia obiektu, mimo że klasa dostarczyła implementacji funkcji wspólnych dla publikacji.</span><span class="sxs-lookup"><span data-stu-id="af55f-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="af55f-310">Na przykład każdy zamknięty dwuwymiarowy kształt geometryczny zawiera dwie właściwości: obszar, wewnętrzny zakres kształtu; obwodu lub odległości wzdłuż krawędzi kształtu.</span><span class="sxs-lookup"><span data-stu-id="af55f-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="af55f-311">Sposób obliczania tych właściwości zależy jednak całkowicie od konkretnego kształtu.</span><span class="sxs-lookup"><span data-stu-id="af55f-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="af55f-312">Formuła obliczania obwodu (lub obwodu) okręgu różni się na przykład od wzoru trójkąta.</span><span class="sxs-lookup"><span data-stu-id="af55f-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="af55f-313">Klasa `Shape` jest `abstract` klasą `abstract` z metodami.</span><span class="sxs-lookup"><span data-stu-id="af55f-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="af55f-314">Oznacza to, że klasy pochodne mają te same funkcje, ale te klasy pochodne implementują tę funkcję inaczej.</span><span class="sxs-lookup"><span data-stu-id="af55f-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="af55f-315">W poniższym przykładzie zdefiniowano `Shape` abstrakcyjną klasę podstawową o nazwie, która definiuje dwie właściwości: `Area` i `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="af55f-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="af55f-316">Oprócz oznaczania klasy za pomocą [abstrakcyjnego](../language-reference/keywords/abstract.md) słowa kluczowego każdy element członkowski wystąpienia jest również oznaczony [abstrakcyjnym](../language-reference/keywords/abstract.md) słowem kluczowym.</span><span class="sxs-lookup"><span data-stu-id="af55f-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="af55f-317">W takim `Shape` przypadku zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> również metodę zwracania nazwy typu, a nie jego w pełni kwalifikowaną nazwę.</span><span class="sxs-lookup"><span data-stu-id="af55f-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="af55f-318">Definiuje dwa statyczne elementy `GetArea` członkowskie `GetPerimeter`i , które umożliwiają wywołującym łatwo pobrać obszar i obwód wystąpienia dowolnej klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="af55f-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="af55f-319">Po przekazaniu wystąpienia klasy pochodnej do jednej z tych metod, czas wykonywania wywołuje zastąpienie metody klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="af55f-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="af55f-320">Następnie można wyprowadzić `Shape` niektóre klasy z tych reprezentujących określone kształty.</span><span class="sxs-lookup"><span data-stu-id="af55f-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="af55f-321">Poniższy przykład definiuje trzy `Triangle`klasy, `Rectangle` `Circle`, , i .</span><span class="sxs-lookup"><span data-stu-id="af55f-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="af55f-322">Każdy używa formuły unikatowej dla danego kształtu do obliczania obszaru i obwodu.</span><span class="sxs-lookup"><span data-stu-id="af55f-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="af55f-323">Niektóre klasy pochodne również zdefiniować właściwości, `Rectangle.Diagonal` `Circle.Diameter`takie jak i , które są unikatowe dla kształtu, który reprezentują.</span><span class="sxs-lookup"><span data-stu-id="af55f-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="af55f-324">W poniższym przykładzie użyto obiektów pochodzących z `Shape`.</span><span class="sxs-lookup"><span data-stu-id="af55f-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="af55f-325">Tworzy tablicę obiektów pochodzących z `Shape` i wywołuje metody statyczne `Shape` klasy, która otacza `Shape` zwraca wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="af55f-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="af55f-326">Czas wykonywania pobiera wartości z przesłoniętych właściwości typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="af55f-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="af55f-327">Przykład również rzutuje `Shape` każdy obiekt w tablicy do jego typu pochodnego i, jeśli rzutowany `Shape`zakończy się pomyślnie, pobiera właściwości tej określonej podklasy .</span><span class="sxs-lookup"><span data-stu-id="af55f-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="af55f-328">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="af55f-328">See also</span></span>

- [<span data-ttu-id="af55f-329">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="af55f-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="af55f-330">Dziedziczenie (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="af55f-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
