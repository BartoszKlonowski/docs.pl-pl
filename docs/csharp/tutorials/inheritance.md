---
title: 'Dziedziczenie w C #'
description: Naucz się używać dziedziczenia w bibliotekach i aplikacjach języka C#.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 78833110db0e4f0382e5c0c6de7c6c8be9a16c8d
ms.sourcegitcommit: a9b8945630426a575ab0a332e568edc807666d1b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/30/2020
ms.locfileid: "80391152"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="47485-103">Dziedziczenie w języku C# i .NET</span><span class="sxs-lookup"><span data-stu-id="47485-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="47485-104">W tym samouczku przedstawiono dziedziczenie w języku C#.</span><span class="sxs-lookup"><span data-stu-id="47485-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="47485-105">Dziedziczenie jest funkcją zorientowanych obiektowo języków programowania, która pozwala zdefiniować klasę podstawową, która zapewnia określone funkcje (dane i zachowanie) i zdefiniować klasy pochodne, które dziedziczą lub zastępują tę funkcjonalność.</span><span class="sxs-lookup"><span data-stu-id="47485-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="47485-106">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="47485-106">Prerequisites</span></span>

<span data-ttu-id="47485-107">W tym samouczku przyjęto założenie, że zainstalowano pakiet SDK .NET Core.</span><span class="sxs-lookup"><span data-stu-id="47485-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="47485-108">Odwiedź stronę [pobierania rdzenia .NET,](https://dotnet.microsoft.com/download) aby ją pobrać.</span><span class="sxs-lookup"><span data-stu-id="47485-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="47485-109">Potrzebny jest również edytor kodu.</span><span class="sxs-lookup"><span data-stu-id="47485-109">You also need a code editor.</span></span> <span data-ttu-id="47485-110">W tym samouczku użyto [programu Visual Studio Code](https://code.visualstudio.com), chociaż można użyć dowolnego edytora kodu do wyboru.</span><span class="sxs-lookup"><span data-stu-id="47485-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="47485-111">Uruchamianie przykładów</span><span class="sxs-lookup"><span data-stu-id="47485-111">Running the examples</span></span>

<span data-ttu-id="47485-112">Aby utworzyć i uruchomić przykłady w tym samouczku, należy użyć narzędzia [dotnet](../../core/tools/dotnet.md) z wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="47485-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="47485-113">Wykonaj następujące kroki dla każdego przykładu:</span><span class="sxs-lookup"><span data-stu-id="47485-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="47485-114">Utwórz katalog do przechowywania przykładu.</span><span class="sxs-lookup"><span data-stu-id="47485-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="47485-115">Wprowadź polecenie [dotnet nowej konsoli](../../core/tools/dotnet-new.md) w wierszu polecenia, aby utworzyć nowy projekt .NET Core.</span><span class="sxs-lookup"><span data-stu-id="47485-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="47485-116">Kopiowanie i wklejenie kodu z przykładu do edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="47485-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="47485-117">Wprowadź polecenie [przywracania dotnet](../../core/tools/dotnet-restore.md) z wiersza polecenia, aby załadować lub przywrócić zależności projektu.</span><span class="sxs-lookup"><span data-stu-id="47485-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

   [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="47485-118">Wprowadź polecenie [dotnet run,](../../core/tools/dotnet-run.md) aby skompilować i wykonać przykład.</span><span class="sxs-lookup"><span data-stu-id="47485-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="47485-119">Tło: Co to jest dziedziczenie?</span><span class="sxs-lookup"><span data-stu-id="47485-119">Background: What is inheritance?</span></span>

<span data-ttu-id="47485-120">*Dziedziczenie* jest jednym z podstawowych atrybutów programowania obiektowego.</span><span class="sxs-lookup"><span data-stu-id="47485-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="47485-121">Umożliwia zdefiniowanie klasy podrzędnej, która ponownie używa (dziedziczy), rozszerza lub modyfikuje zachowanie klasy nadrzędnej.</span><span class="sxs-lookup"><span data-stu-id="47485-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="47485-122">Klasa, której członkowie są dziedziczone, jest nazywana *klasą podstawową*.</span><span class="sxs-lookup"><span data-stu-id="47485-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="47485-123">Klasa, która dziedziczy członków klasy podstawowej, jest *nazywana klasą pochodną*.</span><span class="sxs-lookup"><span data-stu-id="47485-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="47485-124">C# i .NET obsługują tylko *pojedyncze dziedziczenie.*</span><span class="sxs-lookup"><span data-stu-id="47485-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="47485-125">Oznacza to, że klasa może dziedziczyć tylko z jednej klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="47485-126">Jednak dziedziczenie jest przechodnie, co pozwala na zdefiniowanie hierarchii dziedziczenia dla zestawu typów.</span><span class="sxs-lookup"><span data-stu-id="47485-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="47485-127">Innymi słowy, `D` typ może `C`dziedziczyć z `B`typu , który dziedziczy `A`po typie , który dziedziczy z typu klasy podstawowej .</span><span class="sxs-lookup"><span data-stu-id="47485-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="47485-128">Ponieważ dziedziczenie jest przechodnie, `A` elementy członkowskie `D`typu są dostępne do wpisywać .</span><span class="sxs-lookup"><span data-stu-id="47485-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="47485-129">Nie wszystkie elementy członkowskie klasy podstawowej są dziedziczone przez klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="47485-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="47485-130">Następujące elementy członkowskie nie są dziedziczone:</span><span class="sxs-lookup"><span data-stu-id="47485-130">The following members are not inherited:</span></span>

- <span data-ttu-id="47485-131">[Konstruktory statyczne](../programming-guide/classes-and-structs/static-constructors.md), które inicjują dane statyczne klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="47485-132">[Konstruktory instancji](../programming-guide/classes-and-structs/constructors.md), które można wywołać, aby utworzyć nowe wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="47485-133">Każda klasa musi zdefiniować własne konstruktory.</span><span class="sxs-lookup"><span data-stu-id="47485-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="47485-134">[Finalizatory](../programming-guide/classes-and-structs/destructors.md), które są wywoływane przez moduł zbierający elementy bezużyteczne środowiska wykonawczego, aby zniszczyć wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="47485-135">Podczas gdy wszystkie inne elementy członkowskie klasy podstawowej są dziedziczone przez klasy pochodne, czy są one widoczne, czy nie zależy od ich dostępności.</span><span class="sxs-lookup"><span data-stu-id="47485-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="47485-136">Dostępność elementu członkowskiego wpływa na jego widoczność dla klas pochodnych w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="47485-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="47485-137">[Prywatne](../language-reference/keywords/private.md) elementy członkowskie są widoczne tylko w klasach pochodnych, które są zagnieżdżone w ich klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="47485-138">W przeciwnym razie nie są one widoczne w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="47485-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="47485-139">W poniższym `A.B` przykładzie jest klasą zagnieżdżoną, która wywodzi się z `A`i `C` wywodzi się z `A`.</span><span class="sxs-lookup"><span data-stu-id="47485-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="47485-140">Pole `A.value` prywatne jest widoczne w trybie A.B.</span><span class="sxs-lookup"><span data-stu-id="47485-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="47485-141">Jednak jeśli usuniesz `C.GetValue` komentarze z metody i spróbujesz skompilować przykład, generuje błąd kompilatora CS0122: "'A.value' jest niedostępny ze względu na jego poziom ochrony."</span><span class="sxs-lookup"><span data-stu-id="47485-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="47485-142">[Chronione elementy](../language-reference/keywords/protected.md) członkowskie są widoczne tylko w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="47485-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="47485-143">[Elementy wewnętrzne](../language-reference/keywords/internal.md) są widoczne tylko w klasach pochodnych, które znajdują się w tym samym zestawie co klasa podstawowa.</span><span class="sxs-lookup"><span data-stu-id="47485-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="47485-144">Nie są one widoczne w klasach pochodnych znajdujących się w innym zestawie niż klasa podstawowa.</span><span class="sxs-lookup"><span data-stu-id="47485-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="47485-145">[Elementy](../language-reference/keywords/public.md) publiczne są widoczne w klasach pochodnych i są częścią interfejsu publicznego klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="47485-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="47485-146">Publiczne dziedziczone elementy członkowskie mogą być wywoływane tak, jakby były zdefiniowane w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="47485-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="47485-147">W poniższym przykładzie `A` klasa definiuje `Method1`metodę `B` o nazwie `A`, a klasa dziedziczy z klasy .</span><span class="sxs-lookup"><span data-stu-id="47485-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="47485-148">W przykładzie `Method1` następnie wywołuje tak, `B`jakby była to metoda wystąpienia na .</span><span class="sxs-lookup"><span data-stu-id="47485-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="47485-149">Klasy *pochodne* mogą również zastąpić odziedziczone elementy członkowskie, zapewniając alternatywną implementację.</span><span class="sxs-lookup"><span data-stu-id="47485-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="47485-150">Aby można było zastąpić element członkowski, element członkowski w klasie podstawowej musi być oznaczony [wirtualnym](../language-reference/keywords/virtual.md) słowem kluczowym.</span><span class="sxs-lookup"><span data-stu-id="47485-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="47485-151">Domyślnie elementy członkowskie klasy podstawowej nie są oznaczone jako `virtual` i nie mogą zostać zastąpione.</span><span class="sxs-lookup"><span data-stu-id="47485-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="47485-152">Próba zastąpienia elementu członkowskiego niebędącego wirtualnym, zgodnie z poniższym przykładem, generuje błąd\<kompilatora CS0506: \<" element członkowski> nie może zastąpić dziedziczonego elementu członkowskiego>, ponieważ nie jest oznaczony jako wirtualny, abstrakcyjny lub zastąpiony.</span><span class="sxs-lookup"><span data-stu-id="47485-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="47485-153">W niektórych przypadkach klasa pochodna *musi* zastąpić implementacji klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="47485-154">Elementy członkowskie klasy podstawowej oznaczone [abstrakcyjnym](../language-reference/keywords/abstract.md) słowem kluczowym wymagają, aby klasy pochodne je zastępować.</span><span class="sxs-lookup"><span data-stu-id="47485-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="47485-155">Próba skompilowania poniższego przykładu generuje błąd kompilatora&gt; CS0534, &lt;&gt;"&lt;klasa `B` nie implementuje dziedziczonego abstrakcyjnego elementu członkowskiego ", ponieważ klasa nie zapewnia implementacji dla `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="47485-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="47485-156">Dziedziczenie dotyczy tylko klas i interfejsów.</span><span class="sxs-lookup"><span data-stu-id="47485-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="47485-157">Inne kategorie typów (struktury, delegatów i wyliczenia) nie obsługują dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="47485-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="47485-158">Z powodu tych reguł próba skompilowania kodu, podobnie jak w poniższym przykładzie, powoduje błąd kompilatora CS0527: "Typ 'ValueType' na liście interfejsów nie jest interfejsem."</span><span class="sxs-lookup"><span data-stu-id="47485-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="47485-159">Komunikat o błędzie wskazuje, że chociaż można zdefiniować interfejsy, które implementuje struktury, dziedziczenie nie jest obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="47485-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="47485-160">Dziedziczenie niejawne</span><span class="sxs-lookup"><span data-stu-id="47485-160">Implicit inheritance</span></span>

<span data-ttu-id="47485-161">Oprócz typów, które mogą dziedziczyć za pośrednictwem pojedynczego dziedziczenia, <xref:System.Object> wszystkie typy w systemie typu .NET niejawnie dziedziczą lub typu pochodnego z niego.</span><span class="sxs-lookup"><span data-stu-id="47485-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="47485-162">Wspólna funkcjonalność <xref:System.Object> jest dostępna dla każdego typu.</span><span class="sxs-lookup"><span data-stu-id="47485-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="47485-163">Aby zobaczyć, co oznacza dziedziczenie niejawne, zdefiniujmy nową klasę, `SimpleClass`czyli po prostu pustą definicję klasy:</span><span class="sxs-lookup"><span data-stu-id="47485-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="47485-164">Następnie można użyć odbicia (co pozwala sprawdzić metadane typu, aby uzyskać informacje o tym typie), aby uzyskać listę elementów członkowskich, które należą do `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="47485-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="47485-165">Mimo że nie zdefiniowano żadnych `SimpleClass` elementów członkowskich w klasie, dane wyjściowe z przykładu wskazuje, że faktycznie ma dziewięć elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="47485-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="47485-166">Jeden z tych elementów członkowskich jest konstruktorem bez parametrów (lub domyślnym), który jest automatycznie dostarczany dla `SimpleClass` typu przez kompilator języka C#.</span><span class="sxs-lookup"><span data-stu-id="47485-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="47485-167">Pozostałe osiem to <xref:System.Object>członkowie , typ, z którego wszystkie klasy i interfejsy w systemie typu .NET ostatecznie niejawnie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="47485-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="47485-168">Niejawne <xref:System.Object> dziedziczenie z klasy `SimpleClass` udostępnia te metody do klasy:</span><span class="sxs-lookup"><span data-stu-id="47485-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="47485-169">Metoda `ToString` publiczna, która `SimpleClass` konwertuje obiekt na jego reprezentację ciągu, zwraca w pełni kwalifikowaną nazwę typu.</span><span class="sxs-lookup"><span data-stu-id="47485-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="47485-170">W takim przypadku `ToString` metoda zwraca ciąg "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="47485-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="47485-171">Trzy metody, które testują równość `Equals(Object)` dwóch obiektów: metodę `Equals(Object, Object)` wystąpienia publicznego, `ReferenceEquals(Object, Object)` publiczną metodę statyczną i publiczną metodę statyczną.</span><span class="sxs-lookup"><span data-stu-id="47485-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="47485-172">Domyślnie te metody testują równość odniesienia; oznacza to, że aby być równe, dwie zmienne obiektu muszą odwoływać się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="47485-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="47485-173">Metoda `GetHashCode` publiczna, która oblicza wartość, która umożliwia wystąpienie typu, które mają być używane w kolekcjach mieszanych.</span><span class="sxs-lookup"><span data-stu-id="47485-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="47485-174">Metoda `GetType` publiczna, która <xref:System.Type> zwraca obiekt, który reprezentuje `SimpleClass` typ.</span><span class="sxs-lookup"><span data-stu-id="47485-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="47485-175">Metoda chroniona, <xref:System.Object.Finalize%2A> która jest przeznaczona do zwalniania zasobów niezarządzanych, zanim pamięć obiektu zostanie odzyskana przez moduł zbierający elementy bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="47485-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="47485-176">Metoda chroniona, <xref:System.Object.MemberwiseClone%2A> która tworzy płytki klon bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="47485-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="47485-177">Z powodu niejawnego dziedziczenia można `SimpleClass` wywołać dowolny odziedziczony element członkowski `SimpleClass` z obiektu tak, jakby był faktycznie członkiem zdefiniowanym w klasie.</span><span class="sxs-lookup"><span data-stu-id="47485-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="47485-178">Na przykład w poniższym `SimpleClass.ToString` przykładzie `SimpleClass` wywołuje <xref:System.Object>metodę, która dziedziczy po .</span><span class="sxs-lookup"><span data-stu-id="47485-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="47485-179">W poniższej tabeli wymieniono kategorie typów, które można utworzyć w języku C# i typy, z których niejawnie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="47485-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="47485-180">Każdy typ podstawowy sprawia, że inny zestaw elementów członkowskich dostępnych za pośrednictwem dziedziczenia do niejawnie pochodnych typów.</span><span class="sxs-lookup"><span data-stu-id="47485-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="47485-181">Kategoria typu</span><span class="sxs-lookup"><span data-stu-id="47485-181">Type category</span></span> | <span data-ttu-id="47485-182">Niejawnie dziedziczy po</span><span class="sxs-lookup"><span data-stu-id="47485-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="47485-183">class</span><span class="sxs-lookup"><span data-stu-id="47485-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="47485-184">struktura </span><span class="sxs-lookup"><span data-stu-id="47485-184">struct</span></span>        | <span data-ttu-id="47485-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="47485-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="47485-186">enum</span><span class="sxs-lookup"><span data-stu-id="47485-186">enum</span></span>          | <span data-ttu-id="47485-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="47485-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="47485-188">delegate</span><span class="sxs-lookup"><span data-stu-id="47485-188">delegate</span></span>      | <span data-ttu-id="47485-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="47485-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="47485-190">Dziedziczenie i relacja "jest"</span><span class="sxs-lookup"><span data-stu-id="47485-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="47485-191">Zwykle dziedziczenie jest używane do wyrażania relacji "jest" między klasą podstawową a jedną lub kilkoma klasami pochodnymi, gdzie klasy pochodne są wyspecjalizowanymi wersjami klasy podstawowej; klasa pochodna jest typem klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="47485-192">Na przykład `Publication` klasa reprezentuje publikację dowolnego rodzaju, a `Book` i `Magazine` klasy reprezentują określone typy publikacji.</span><span class="sxs-lookup"><span data-stu-id="47485-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="47485-193">Klasa lub struktura można zaimplementować jeden lub więcej interfejsów.</span><span class="sxs-lookup"><span data-stu-id="47485-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="47485-194">Chociaż implementacja interfejsu jest często przedstawiana jako obejście pojedynczego dziedziczenia lub jako sposób używania dziedziczenia za pomocą struktur, ma na celu wyrażenie innej relacji (relacji "może zrobić") między interfejsem a jego typem implementacmentu niż Dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="47485-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="47485-195">Interfejs definiuje podzbiór funkcji (takich jak możliwość testowania równości, do porównywania lub sortowania obiektów lub do obsługi analizowania i formatowania zależne od kultury), które interfejs udostępnia do jego typów implementujących.</span><span class="sxs-lookup"><span data-stu-id="47485-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="47485-196">Należy zauważyć, że "jest" wyraża również relację między typem a określonym wystąpieniem tego typu.</span><span class="sxs-lookup"><span data-stu-id="47485-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="47485-197">W poniższym `Automobile` przykładzie jest klasą, która ma `Make`trzy unikatowe właściwości tylko do odczytu: , producenta samochodu; `Model`, rodzaj samochodu; i `Year`, jego rok produkcji.</span><span class="sxs-lookup"><span data-stu-id="47485-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="47485-198">Klasa `Automobile` ma również konstruktora, którego argumenty są przypisane do <xref:System.Object.ToString%2A?displayProperty=nameWithType> wartości właściwości i zastępuje metodę tworzenia `Automobile` ciągu, `Automobile` który jednoznacznie identyfikuje wystąpienie, a nie klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="47485-199">W takim przypadku nie należy polegać na dziedziczeniu do reprezentowania określonych samochodów sprawia i modeli.</span><span class="sxs-lookup"><span data-stu-id="47485-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="47485-200">Na przykład nie trzeba definiować `Packard` typu reprezentującego samochody produkowane przez Firmę Samochodów Packard.</span><span class="sxs-lookup"><span data-stu-id="47485-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="47485-201">Zamiast tego można je reprezentować, `Automobile` tworząc obiekt z odpowiednimi wartościami przekazanymi do konstruktora klasy, tak jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="47485-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="47485-202">Relacja is-a oparta na dziedziczeniu jest najlepiej stosowana do klasy podstawowej i klas pochodnych, które dodają dodatkowe elementy członkowskie do klasy podstawowej lub które wymagają dodatkowych funkcji, które nie są obecne w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="47485-203">Projektowanie klasy podstawowej i klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="47485-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="47485-204">Przyjrzyjmy się procesowi projektowania klasy podstawowej i jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="47485-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="47485-205">W tej sekcji zdefiniujesz klasę `Publication`podstawową, która reprezentuje wszelkiego rodzaju publikację, taką jak książka, czasopismo, gazeta, czasopismo, artykuł itp. Zdefiniujesz również `Book` klasę, która `Publication`wywodzi się z .</span><span class="sxs-lookup"><span data-stu-id="47485-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="47485-206">Przykład można łatwo rozszerzyć, aby zdefiniować inne `Magazine` `Journal`klasy `Newspaper`pochodne, takie jak , , i `Article`.</span><span class="sxs-lookup"><span data-stu-id="47485-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="47485-207">Podstawowa klasa Publikacja</span><span class="sxs-lookup"><span data-stu-id="47485-207">The base Publication class</span></span>

<span data-ttu-id="47485-208">Projektując swoją `Publication` klasę, musisz podjąć kilka decyzji projektowych:</span><span class="sxs-lookup"><span data-stu-id="47485-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="47485-209">Jakie elementy członkowskie do `Publication` uwzględnienia w `Publication` klasie podstawowej i `Publication` czy członkowie zapewniają implementacje metody lub czy jest abstrakcyjną klasą podstawową, która służy jako szablon dla klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="47485-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="47485-210">W takim przypadku `Publication` klasa zapewni implementacje metody.</span><span class="sxs-lookup"><span data-stu-id="47485-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="47485-211">[Projektowanie abstrakcyjnych klas podstawowych i ich klas pochodnych](#abstract) sekcja zawiera przykład, który używa abstrakcyjnej klasy podstawowej do definiowania metod, które klasy pochodne muszą zastąpić.</span><span class="sxs-lookup"><span data-stu-id="47485-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="47485-212">Klasy pochodne są wolne do zapewnienia dowolnej implementacji, która jest odpowiednia dla typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="47485-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="47485-213">Możliwość ponownego użycia kodu (oznacza to, że wiele klas pochodnych współużytkuje deklarację i implementację metod klasy podstawowej i nie trzeba ich zastępować) jest zaletą nieabstrakcyjnych klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="47485-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="47485-214">W związku z tym `Publication` należy dodać członków, jeśli ich kod `Publication` może być współużytkowany przez niektóre lub najbardziej wyspecjalizowane typy.</span><span class="sxs-lookup"><span data-stu-id="47485-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="47485-215">Jeśli nie uda się zapewnić implementacji klasy podstawowej skutecznie, skończysz z koniecznością zapewnienia implementacji w dużej mierze identyczne element członkowski w klasach pochodnych, a pojedyncza implementacja w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="47485-216">Konieczność obsługi zduplikowanego kodu w wielu lokalizacjach jest potencjalnym źródłem błędów.</span><span class="sxs-lookup"><span data-stu-id="47485-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="47485-217">Zarówno w celu zmaksymalizowania ponownego użycia kodu i utworzenia logicznej i intuicyjnej hierarchii dziedziczenia, należy mieć pewność, że w `Publication` klasie uwzględnisz tylko dane i funkcje, które są wspólne dla wszystkich lub większości publikacji.</span><span class="sxs-lookup"><span data-stu-id="47485-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="47485-218">Klasy pochodne następnie implementują elementy członkowskie, które są unikatowe dla określonych rodzajów publikacji, które reprezentują.</span><span class="sxs-lookup"><span data-stu-id="47485-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="47485-219">Jak daleko rozszerzyć hierarchię klas.</span><span class="sxs-lookup"><span data-stu-id="47485-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="47485-220">Czy chcesz opracować hierarchię trzech lub więcej klas, a nie tylko klasę podstawową i jedną lub więcej klas pochodnych?</span><span class="sxs-lookup"><span data-stu-id="47485-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="47485-221">Na przykład `Publication` może być klasą podstawową , która `Periodical`z kolei jest klasą podstawową `Magazine`, `Journal` i `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="47485-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="47485-222">W przykładzie użyjesz małej hierarchii `Publication` klasy i pojedynczej klasy `Book`pochodnej.</span><span class="sxs-lookup"><span data-stu-id="47485-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="47485-223">Można łatwo rozszerzyć przykład, aby utworzyć szereg dodatkowych `Publication`klas, `Magazine` które `Article`wynikają z , takich jak i .</span><span class="sxs-lookup"><span data-stu-id="47485-223">You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="47485-224">Czy ma sens tworzenie wystąpienia klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="47485-225">Jeśli tak nie jest, należy zastosować [abstrakcyjne](../language-reference/keywords/abstract.md) słowo kluczowe do klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="47485-226">W przeciwnym `Publication` razie można utworzyć wystąpienia klasy, wywołując jego konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="47485-227">Jeśli zostanie podjęta próba wystąpienia klasy `abstract` oznaczonej słowem kluczowym przez bezpośrednie wywołanie konstruktora klasy, kompilator języka C# generuje błąd CS0144, "Nie można utworzyć wystąpienia klasy abstrakcyjnej lub interfejsu".</span><span class="sxs-lookup"><span data-stu-id="47485-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="47485-228">Jeśli zostanie podjęta próba wystąpienia klasy przy użyciu odbicia, metoda <xref:System.MemberAccessException>odbicia rzuca .</span><span class="sxs-lookup"><span data-stu-id="47485-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="47485-229">Domyślnie można utworzyć wystąpienie klasy podstawowej, wywołując jego konstruktora klas.</span><span class="sxs-lookup"><span data-stu-id="47485-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="47485-230">Nie trzeba jawnie definiować konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="47485-231">Jeśli jeden nie jest obecny w kodzie źródłowym klasy podstawowej, kompilator Języka C# automatycznie zapewnia domyślny (bez parametrów) konstruktora.</span><span class="sxs-lookup"><span data-stu-id="47485-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="47485-232">W przykładzie zaznaczysz `Publication` klasę jako [abstrakcyjną,](../language-reference/keywords/abstract.md) aby nie można było utworzyć wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="47485-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="47485-233">Klasa `abstract` bez `abstract` żadnych metod wskazuje, że ta klasa reprezentuje abstrakcyjną koncepcję, która jest współużytkowana przez kilka konkretnych klas (takich jak `Book`, `Journal`).</span><span class="sxs-lookup"><span data-stu-id="47485-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="47485-234">Czy klasy pochodne muszą dziedziczyć implementacji klasy podstawowej określonych elementów członkowskich, czy mają możliwość zastąpienia implementacji klasy podstawowej lub czy muszą zapewnić implementację.</span><span class="sxs-lookup"><span data-stu-id="47485-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="47485-235">Użycie [abstrakcyjnego](../language-reference/keywords/abstract.md) słowa kluczowego, aby wymusić klasy pochodne, aby zapewnić implementację.</span><span class="sxs-lookup"><span data-stu-id="47485-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="47485-236">Wirtualne [virtual](../language-reference/keywords/virtual.md) słowo kluczowe służy do zezwalania klas pochodnych zastąpić metody klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="47485-237">Domyślnie metody zdefiniowane w klasie podstawowej *nie* są nadpisywalne.</span><span class="sxs-lookup"><span data-stu-id="47485-237">By default, methods defined in the base class are *not* overridable.</span></span>

 <span data-ttu-id="47485-238">Klasa `Publication` nie ma `abstract` żadnych metod, ale `abstract`sama klasa jest .</span><span class="sxs-lookup"><span data-stu-id="47485-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="47485-239">Czy klasa pochodna reprezentuje klasę końcową w hierarchii dziedziczenia i nie może sama być używana jako klasa podstawowa dla dodatkowych klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="47485-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="47485-240">Domyślnie każda klasa może służyć jako klasa podstawowa.</span><span class="sxs-lookup"><span data-stu-id="47485-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="47485-241">[Zapieczętowane](../language-reference/keywords/sealed.md) słowo kluczowe można zastosować, aby wskazać, że klasa nie może służyć jako klasa podstawowa dla żadnych dodatkowych klas.</span><span class="sxs-lookup"><span data-stu-id="47485-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="47485-242">Próba wyprowadzenia z zapieczętowanego błędu kompilatora wygenerowanego \<klasy CS0509 ,,nie może pochodzić z zapieczętowanego typu typeName>".</span><span class="sxs-lookup"><span data-stu-id="47485-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="47485-243">W twoim przykładzie oznaczysz klasę `sealed`pochodną jako .</span><span class="sxs-lookup"><span data-stu-id="47485-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="47485-244">Poniższy przykład przedstawia kod `Publication` źródłowy dla klasy, a także wyliczenie, `PublicationType` które jest zwracane przez `Publication.PublicationType` właściwość.</span><span class="sxs-lookup"><span data-stu-id="47485-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="47485-245">Oprócz elementów członkowskich, które <xref:System.Object>dziedziczy `Publication` z , klasa definiuje następujące unikatowe elementy członkowskie i elementy członkowskie zastępuje:</span><span class="sxs-lookup"><span data-stu-id="47485-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="47485-246">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="47485-246">A constructor</span></span>

  <span data-ttu-id="47485-247">Ponieważ `Publication` klasa `abstract`jest , nie można utworzyć wystąpienia bezpośrednio z kodu, jak w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="47485-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="47485-248">Jednak jego konstruktora wystąpienia można wywołać bezpośrednio z konstruktorów `Book` klas pochodnych, jak pokazuje kod źródłowy dla klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="47485-249">Dwie właściwości związane z publikacją</span><span class="sxs-lookup"><span data-stu-id="47485-249">Two publication-related properties</span></span>

  <span data-ttu-id="47485-250">`Title`jest właściwością <xref:System.String> tylko do odczytu, `Publication` której wartość jest dostarczana przez wywołanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="47485-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="47485-251">`Pages`jest właściwością <xref:System.Int32> odczytu i zapisu, która wskazuje, ile wszystkich stron ma publikacja.</span><span class="sxs-lookup"><span data-stu-id="47485-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="47485-252">Wartość jest przechowywana w `totalPages`prywatnym polu o nazwie .</span><span class="sxs-lookup"><span data-stu-id="47485-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="47485-253">Musi to być liczba <xref:System.ArgumentOutOfRangeException> dodatnia lub jest wyrzucana.</span><span class="sxs-lookup"><span data-stu-id="47485-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="47485-254">Członkowie związani z wydawcą</span><span class="sxs-lookup"><span data-stu-id="47485-254">Publisher-related members</span></span>

  <span data-ttu-id="47485-255">Dwie właściwości tylko do `Publisher` `Type`odczytu i .</span><span class="sxs-lookup"><span data-stu-id="47485-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="47485-256">Wartości są pierwotnie dostarczane przez wywołanie do konstruktora `Publication` klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="47485-257">Członkowie związani z publikowaniem</span><span class="sxs-lookup"><span data-stu-id="47485-257">Publishing-related members</span></span>

  <span data-ttu-id="47485-258">Dwie metody `Publish` `GetPublicationDate`i , ustawić i zwrócić datę publikacji.</span><span class="sxs-lookup"><span data-stu-id="47485-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="47485-259">Metoda `Publish` ustawia prywatną `published` `true` flagę, gdy jest wywoływana i przypisuje datę przekazywaną do niej jako argument do pola prywatnego. `datePublished`</span><span class="sxs-lookup"><span data-stu-id="47485-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="47485-260">Metoda `GetPublicationDate` zwraca ciąg "NYP", `published` jeśli `false`flaga jest , `datePublished` a wartość `true`pola, jeśli jest .</span><span class="sxs-lookup"><span data-stu-id="47485-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="47485-261">Członkowie związani z prawami autorskimi</span><span class="sxs-lookup"><span data-stu-id="47485-261">Copyright-related members</span></span>

  <span data-ttu-id="47485-262">Metoda `Copyright` przyjmuje nazwę posiadacza praw autorskich i rok praw autorskich jako `CopyrightName` argumenty `CopyrightDate` i przypisuje je do i właściwości.</span><span class="sxs-lookup"><span data-stu-id="47485-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="47485-263">Zastąpienie `ToString` metody</span><span class="sxs-lookup"><span data-stu-id="47485-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="47485-264">Jeśli typ nie zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, zwraca w pełni kwalifikowaną nazwę typu, który ma niewielkie zastosowanie w odróżnianiu jednego wystąpienia od innego.</span><span class="sxs-lookup"><span data-stu-id="47485-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="47485-265">Klasa `Publication` zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> zwracać wartość `Title` właściwości.</span><span class="sxs-lookup"><span data-stu-id="47485-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="47485-266">Poniższy rysunek ilustruje `Publication` relację między klasą <xref:System.Object> podstawową a jej niejawnie dziedziczoną klasą.</span><span class="sxs-lookup"><span data-stu-id="47485-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Klasa Obiekt i publikacja](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="47485-268">Klasa `Book`</span><span class="sxs-lookup"><span data-stu-id="47485-268">The `Book` class</span></span>

<span data-ttu-id="47485-269">Klasa `Book` reprezentuje książkę jako wyspecjalizowany typ publikacji.</span><span class="sxs-lookup"><span data-stu-id="47485-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="47485-270">Poniższy przykład pokazuje kod `Book` źródłowy dla klasy.</span><span class="sxs-lookup"><span data-stu-id="47485-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="47485-271">Oprócz elementów członkowskich, które `Publication`dziedziczy `Book` z , klasa definiuje następujące unikatowe elementy członkowskie i elementy członkowskie zastępuje:</span><span class="sxs-lookup"><span data-stu-id="47485-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="47485-272">Dwa konstruktory</span><span class="sxs-lookup"><span data-stu-id="47485-272">Two constructors</span></span>

  <span data-ttu-id="47485-273">Dwa `Book` konstruktory mają trzy wspólne parametry.</span><span class="sxs-lookup"><span data-stu-id="47485-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="47485-274">Dwa, *tytuł* i *wydawca*, `Publication` odpowiadają parametrom konstruktora.</span><span class="sxs-lookup"><span data-stu-id="47485-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="47485-275">Trzeci to *autor*, który jest przechowywany `Author` w publicznej właściwości niezmienne.</span><span class="sxs-lookup"><span data-stu-id="47485-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="47485-276">Jeden konstruktor zawiera parametr *isbn,* `ISBN` który jest przechowywany we właściwości auto.</span><span class="sxs-lookup"><span data-stu-id="47485-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="47485-277">Pierwszy konstruktor używa [tego](../language-reference/keywords/this.md) słowa kluczowego, aby wywołać inny konstruktora.</span><span class="sxs-lookup"><span data-stu-id="47485-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="47485-278">Tworzenie łańcucha konstruktora jest typowym wzorcem w definiowaniu konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="47485-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="47485-279">Konstruktory z mniejszą liczbą parametrów zapewniają wartości domyślne podczas wywoływania konstruktora z największą liczbą parametrów.</span><span class="sxs-lookup"><span data-stu-id="47485-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="47485-280">Drugi konstruktor używa podstawowego słowa [kluczowego,](../language-reference/keywords/base.md) aby przekazać nazwę tytułu i wydawcy do konstruktora klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="47485-281">Jeśli nie dokonać jawnego wywołania konstruktora klasy podstawowej w kodzie źródłowym, kompilator Języka C# automatycznie dostarcza wywołanie domyślnego lub bez parametrowego konstruktora klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="47485-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="47485-282">Właściwość tylko `ISBN` do odczytu, `Book` która zwraca międzynarodowy standardowy numer książki obiektu, unikatowy numer 10- lub 13-cyfrowy.</span><span class="sxs-lookup"><span data-stu-id="47485-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="47485-283">Numer ISBN jest dostarczany jako argument `Book` do jednego z konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="47485-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="47485-284">Numer ISBN jest przechowywany w prywatnym polu zapasowym, które jest generowane automatycznie przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="47485-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="47485-285">Właściwość tylko `Author` do odczytu.</span><span class="sxs-lookup"><span data-stu-id="47485-285">A read-only `Author` property.</span></span> <span data-ttu-id="47485-286">Nazwa autora jest dostarczana `Book` jako argument do obu konstruktorów i jest przechowywana we właściwości.</span><span class="sxs-lookup"><span data-stu-id="47485-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="47485-287">Dwie właściwości związane tylko z `Price` ceną do odczytu i `Currency`.</span><span class="sxs-lookup"><span data-stu-id="47485-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="47485-288">Ich wartości są dostarczane `SetPrice` jako argumenty w wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="47485-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="47485-289">Właściwość `Currency` jest trzycyfrowym symbolem waluty ISO (na przykład USD dla dolara amerykańskiego).</span><span class="sxs-lookup"><span data-stu-id="47485-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="47485-290">Symbole waluty ISO można pobrać <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> z właściwości.</span><span class="sxs-lookup"><span data-stu-id="47485-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="47485-291">Obie te właściwości są tylko do odczytu zewnętrznie, ale `Book` oba mogą być ustawione przez kod w klasie.</span><span class="sxs-lookup"><span data-stu-id="47485-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="47485-292">Metoda, `SetPrice` która ustawia wartości `Price` i `Currency` właściwości.</span><span class="sxs-lookup"><span data-stu-id="47485-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="47485-293">Te wartości są zwracane przez te same właściwości.</span><span class="sxs-lookup"><span data-stu-id="47485-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="47485-294">`ToString` Zastępuje metodę (dziedziczoną z `Publication`) <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> oraz <xref:System.Object.GetHashCode%2A> metody i <xref:System.Object>metody (dziedziczone po ).</span><span class="sxs-lookup"><span data-stu-id="47485-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="47485-295">Chyba że jest zastępowane, testy <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody równości odwołania.</span><span class="sxs-lookup"><span data-stu-id="47485-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="47485-296">Oznacza to, że dwie zmienne obiektu są uważane za równe, jeśli odnoszą się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="47485-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="47485-297">W `Book` klasie, z drugiej strony, dwa `Book` obiekty powinny być równe, jeśli mają ten sam numer ISBN.</span><span class="sxs-lookup"><span data-stu-id="47485-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="47485-298">Po zastąpieniu <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody, należy również zastąpić <xref:System.Object.GetHashCode%2A> metodę, która zwraca wartość, która używa środowiska wykonawczego do przechowywania elementów w kolekcji mieszania dla skutecznego pobierania.</span><span class="sxs-lookup"><span data-stu-id="47485-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="47485-299">Kod mieszania powinien zwracać wartość, która jest zgodna z testem równości.</span><span class="sxs-lookup"><span data-stu-id="47485-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="47485-300">Ponieważ <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> zostały zastąpione do `true` zwrócenia, jeśli właściwości ISBN dwóch `Book` obiektów są równe, zwracasz kod <xref:System.String.GetHashCode%2A> skrótu obliczony `ISBN` przez wywołanie metody ciągu zwróconego przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="47485-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="47485-301">Poniższy rysunek ilustruje `Book` relację między klasą i `Publication`, jej klasą podstawową.</span><span class="sxs-lookup"><span data-stu-id="47485-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Klasy publikacji i książek](media/book-class.jpg)

<span data-ttu-id="47485-303">Teraz można utworzyć wystąpienie `Book` obiektu, wywołać zarówno jego unikatowe i dziedziczone elementy członkowskie i przekazać `Publication` go jako `Book`argument do metody, która oczekuje parametru typu lub typu, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="47485-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="47485-304">Projektowanie abstrakcyjnych klas podstawowych i ich klas pochodnych</span><span class="sxs-lookup"><span data-stu-id="47485-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="47485-305">W poprzednim przykładzie zdefiniowano klasę podstawową, która dostarczyła implementację dla wielu metod, aby umożliwić klasom pochodnym udostępnianie kodu.</span><span class="sxs-lookup"><span data-stu-id="47485-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="47485-306">W wielu przypadkach jednak klasa podstawowa nie oczekuje się implementacji.</span><span class="sxs-lookup"><span data-stu-id="47485-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="47485-307">Zamiast tego klasa podstawowa jest *klasą abstrakcyjną,* która deklaruje *metody abstrakcyjne;* służy jako szablon, który definiuje elementy członkowskie, które każda klasa pochodna musi zaimplementować.</span><span class="sxs-lookup"><span data-stu-id="47485-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="47485-308">Zazwyczaj w abstrakcyjnej klasie podstawowej implementacja każdego typu pochodnego jest unikatowa dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="47485-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="47485-309">Oznaczone klasy z abstrakcyjne słowa kluczowego, ponieważ nie `Publication` ma sensu do tworzenia wystąpienia obiektu, chociaż klasa nie zapewniają implementacji funkcji wspólnych dla publikacji.</span><span class="sxs-lookup"><span data-stu-id="47485-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="47485-310">Na przykład każdy zamknięty dwuwymiarowy kształt geometryczny zawiera dwie właściwości: obszar, wewnętrzny zasięg kształtu; i obwodu lub odległości wzdłuż krawędzi kształtu.</span><span class="sxs-lookup"><span data-stu-id="47485-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="47485-311">Sposób obliczania tych właściwości zależy jednak całkowicie od konkretnego kształtu.</span><span class="sxs-lookup"><span data-stu-id="47485-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="47485-312">Wzór do obliczania obwodu (lub obwodu) okręgu, na przykład, różni się od trójkąta.</span><span class="sxs-lookup"><span data-stu-id="47485-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="47485-313">Klasa `Shape` jest `abstract` klasą `abstract` z metodami.</span><span class="sxs-lookup"><span data-stu-id="47485-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="47485-314">Oznacza to, że klasy pochodne współużytkują te same funkcje, ale te klasy pochodne implementują tę funkcjonalność inaczej.</span><span class="sxs-lookup"><span data-stu-id="47485-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="47485-315">Poniższy przykład definiuje abstrakcyjną `Shape` klasę podstawową o `Area` nazwie, która definiuje dwie właściwości: i `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="47485-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="47485-316">Oprócz oznaczania klasy słowem kluczowym [abstrakcyjnym,](../language-reference/keywords/abstract.md) każdy element członkowski wystąpienia jest również oznaczony [abstrakcyjnym](../language-reference/keywords/abstract.md) słowem kluczowym.</span><span class="sxs-lookup"><span data-stu-id="47485-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="47485-317">W takim `Shape` przypadku również zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę zwracania nazwy typu, a nie jego w pełni kwalifikowaną nazwę.</span><span class="sxs-lookup"><span data-stu-id="47485-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="47485-318">I definiuje dwa statyczne `GetArea` elementy `GetPerimeter`członkowskie i , które umożliwiają wywołującym łatwo pobrać obszar i obwód wystąpienia dowolnej klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="47485-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="47485-319">Po przełknięciu wystąpienia klasy pochodnej do jednej z tych metod środowisko uruchomieniowe wywołuje zastąpienie metody klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="47485-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="47485-320">Następnie można wyprowadzić niektóre `Shape` klasy z tych reprezentują określone kształty.</span><span class="sxs-lookup"><span data-stu-id="47485-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="47485-321">Poniższy przykład definiuje trzy `Triangle` `Rectangle`klasy, `Circle`, i .</span><span class="sxs-lookup"><span data-stu-id="47485-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="47485-322">Każdy używa formuły unikatowej dla tego konkretnego kształtu do obliczenia obszaru i obwodu.</span><span class="sxs-lookup"><span data-stu-id="47485-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="47485-323">Niektóre klasy pochodne również zdefiniować właściwości, takie jak `Rectangle.Diagonal` i `Circle.Diameter`, które są unikatowe dla kształtu, który reprezentują.</span><span class="sxs-lookup"><span data-stu-id="47485-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="47485-324">W poniższym przykładzie użyto obiektów pochodzących z `Shape`programu .</span><span class="sxs-lookup"><span data-stu-id="47485-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="47485-325">Wywołuje tablicę obiektów pochodzących z `Shape` i wywołuje metody statyczne `Shape` klasy, która `Shape` zawija zwraca wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="47485-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="47485-326">Środowisko wykonawcze pobiera wartości z nadpisanych właściwości typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="47485-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="47485-327">W przykładzie rzutuje również każdy `Shape` obiekt w tablicy na jego typ pochodny i, jeśli `Shape`rzutowania powiedzie się, pobiera właściwości tej konkretnej podklasy .</span><span class="sxs-lookup"><span data-stu-id="47485-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="47485-328">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="47485-328">See also</span></span>

- [<span data-ttu-id="47485-329">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="47485-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="47485-330">Dziedziczenie (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="47485-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
