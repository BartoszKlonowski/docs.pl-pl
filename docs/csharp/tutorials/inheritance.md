---
title: Dziedziczenie w języku C#
description: Sposoby używania dziedziczenia w aplikacjach i bibliotek C#.
author: rpetrusha
ms.author: ronpet
ms.date: 08/16/2017
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 1476425594e55531fdb56de531ee61808dccd7db
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
ms.locfileid: "33365764"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="24553-103">Dziedziczenie w języku C# i .NET</span><span class="sxs-lookup"><span data-stu-id="24553-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="24553-104">W tym samouczku przedstawiono dziedziczenia w języku C#.</span><span class="sxs-lookup"><span data-stu-id="24553-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="24553-105">Dziedziczenie jest funkcją zorientowane obiektowo języków programowania, która służy do definiowania klasy podstawowej, która zapewnia funkcje (dane i zachowanie) oraz do definiowania klas pochodnych, które dziedziczą lub Zastąp te funkcje.</span><span class="sxs-lookup"><span data-stu-id="24553-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="24553-106">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="24553-106">Prerequisites</span></span>

<span data-ttu-id="24553-107">Ten samouczek zakłada, że po zainstalowaniu platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="24553-107">This tutorial assumes that you've installed .NET Core.</span></span> <span data-ttu-id="24553-108">Aby uzyskać instrukcje instalacji, zobacz [Przewodnik instalacji platformy .NET Core](https://www.microsoft.com/net/core).</span><span class="sxs-lookup"><span data-stu-id="24553-108">For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core).</span></span> <span data-ttu-id="24553-109">Należy również edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="24553-109">You also need a code editor.</span></span> <span data-ttu-id="24553-110">W tym samouczku używana [Visual Studio Code](https://code.visualstudio.com), chociaż można użyć dowolnego wybranego edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="24553-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="24553-111">Uruchamianie przykładów</span><span class="sxs-lookup"><span data-stu-id="24553-111">Running the examples</span></span>

<span data-ttu-id="24553-112">Do tworzenia i uruchamiania przykładów w tym samouczku, użyj [dotnet](../../core/tools/dotnet.md) narzędzie z wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="24553-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="24553-113">Wykonaj następujące kroki na każdym przykład:</span><span class="sxs-lookup"><span data-stu-id="24553-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="24553-114">Utwórz katalog do przechowywania w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="24553-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="24553-115">Wprowadź [dotnet nowej konsoli](../../core/tools/dotnet-new.md) polecenie w wierszu polecenia, aby utworzyć nowy projekt platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="24553-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="24553-116">Skopiuj i Wklej kod w przykładzie do edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="24553-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="24553-117">Wprowadź [przywracania dotnet](../../core/tools/dotnet-restore.md) polecenia z wiersza polecenia do ładowania lub Przywróć zależności projektu.</span><span class="sxs-lookup"><span data-stu-id="24553-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="24553-118">Wprowadź [dotnet Uruchom](../../core/tools/dotnet-run.md) polecenie, aby skompilować i wykonać przykładzie.</span><span class="sxs-lookup"><span data-stu-id="24553-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>


## <a name="background-what-is-inheritance"></a><span data-ttu-id="24553-119">Tło: Co to jest dziedziczenia?</span><span class="sxs-lookup"><span data-stu-id="24553-119">Background: What is inheritance?</span></span>

<span data-ttu-id="24553-120">*Dziedziczenie* jest jednym z podstawowych atrybuty programowanie zorientowane obiektowo.</span><span class="sxs-lookup"><span data-stu-id="24553-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="24553-121">Można zdefiniować klasy podrzędnej, które używa ponownie (dziedziczy) rozszerza lub modyfikuje zachowanie klasy nadrzędnej.</span><span class="sxs-lookup"><span data-stu-id="24553-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="24553-122">Klasa, której członkami są dziedziczone jest nazywana *klasa podstawowa*.</span><span class="sxs-lookup"><span data-stu-id="24553-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="24553-123">Klasa, która dziedziczy elementów członkowskich klasy podstawowej jest nazywany *klasy*.</span><span class="sxs-lookup"><span data-stu-id="24553-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="24553-124">C# i .NET obsługuje *pojedyncze dziedziczenie* tylko.</span><span class="sxs-lookup"><span data-stu-id="24553-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="24553-125">Oznacza to, że klasa może dziedziczyć tylko z jednej klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="24553-126">Jednak dziedziczenia jest przechodnie, co pozwala na określanie hierarchii dziedziczenia dla zestawu typów.</span><span class="sxs-lookup"><span data-stu-id="24553-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="24553-127">Innymi słowy, wpisz `D` może dziedziczyć z typu `C`, który dziedziczy z typu `B`, który dziedziczy z klasy podstawowej typu `A`.</span><span class="sxs-lookup"><span data-stu-id="24553-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="24553-128">Ponieważ dziedziczenia jest przechodnie, elementy członkowskie typu `A` są dostępne dla typów `D`.</span><span class="sxs-lookup"><span data-stu-id="24553-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="24553-129">Nie wszystkie elementy członkowskie klasy podstawowej są dziedziczone przez klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="24553-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="24553-130">Następujące elementy członkowskie nie są dziedziczone:</span><span class="sxs-lookup"><span data-stu-id="24553-130">The following members are not inherited:</span></span>

- <span data-ttu-id="24553-131">[Konstruktory statyczne](../programming-guide/classes-and-structs/static-constructors.md), który zainicjować danych statycznej klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="24553-132">[Konstruktory wystąpień](../programming-guide/classes-and-structs/constructors.md), które należy wywołać, aby utworzyć nowe wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="24553-133">Każda klasa musi definiować własnego konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="24553-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="24553-134">[Finalizatory](../programming-guide/classes-and-structs/destructors.md), które są wywoływane przez moduł Garbage Collector środowiska uruchomieniowego do zniszczenia wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="24553-135">Podczas wszystkich innych członków klasy podstawowej są dziedziczone przez klasy pochodnej, czy są one widoczne czy nie zależy od ich dostępności.</span><span class="sxs-lookup"><span data-stu-id="24553-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="24553-136">Dostępność elementu członkowskiego wpływa na jej widoczność klas pochodnych w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="24553-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="24553-137">[Prywatne](../language-reference/keywords/private.md) elementy są widoczne tylko w klasach pochodnych, które są zagnieżdżone w ich klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="24553-138">W przeciwnym razie nie są widoczne w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="24553-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="24553-139">W poniższym przykładzie `A.B` jest zagnieżdżona klasa, która jest pochodną `A`, i `C` pochodną `A`.</span><span class="sxs-lookup"><span data-stu-id="24553-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="24553-140">Prywatna `A.value` pole jest widoczne w A.B.</span><span class="sxs-lookup"><span data-stu-id="24553-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="24553-141">Jednak jeśli Usuń komentarze z `C.GetValue` metody, a następnie spróbuj skompilować w przykładzie generuje błąd kompilatora CS0122: "" A.value"jest niedostępny z powodu swojego poziomu ochrony."</span><span class="sxs-lookup"><span data-stu-id="24553-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="24553-142">[Chronione](../language-reference/keywords/protected.md) elementy są widoczne tylko w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="24553-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="24553-143">[Wewnętrzny](../language-reference/keywords/internal.md) elementy są widoczne tylko w klasach pochodnych, które znajdują się w tym samym zestawie co klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="24553-144">Nie są widoczne w klasach pochodnych znajduje się w innym zestawie od klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="24553-145">[Publiczny](../language-reference/keywords/public.md) elementy członkowskie są widoczne w klasach pochodnych i są częścią interfejs publiczny klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="24553-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="24553-146">Tak jak gdyby zostały one zdefiniowane w klasie pochodnej można wywołać publicznej dziedziczone elementy członkowskie.</span><span class="sxs-lookup"><span data-stu-id="24553-146">Public inherited members can be called just as if they were defined in the derived class.</span></span> <span data-ttu-id="24553-147">W poniższym przykładzie klasa `A` definiuje metodę o nazwie `Method1`, a klasa `B` dziedziczy z klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="24553-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="24553-148">Przykład wywołuje `Method1` tak jakby był on metodę wystąpienia `B`.</span><span class="sxs-lookup"><span data-stu-id="24553-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="24553-149">Klasy pochodne mogą również *zastąpienia* dziedziczone elementy członkowskie, dostarczając implementację alternatywny.</span><span class="sxs-lookup"><span data-stu-id="24553-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="24553-150">Aby można było zastąpić członka, muszą być oznaczone element członkowski w klasie podstawowej [wirtualnego](../language-reference/keywords/virtual.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="24553-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="24553-151">Domyślnie elementów członkowskich klasy podstawowej nie są oznaczone jako `virtual` i nie może zostać zastąpiona.</span><span class="sxs-lookup"><span data-stu-id="24553-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="24553-152">Próba zastąpienia Niewirtualny element członkowski, tak jak w poniższym przykładzie, generuje błąd kompilatora CS0506: "<member> nie można przesłonić dziedziczonego elementu członkowskiego <member> , ponieważ nie jest oznaczona wirtualny, abstrakcyjny lub zastąpienie.</span><span class="sxs-lookup"><span data-stu-id="24553-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="24553-153">W niektórych przypadkach, w klasie pochodnej *musi* zastąpienia implementacji klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="24553-154">Oznaczonej jako elementów członkowskich klasy podstawowej [abstrakcyjny](../language-reference/keywords/abstract.md) — słowo kluczowe wymagają klas pochodnych zastąpić je.</span><span class="sxs-lookup"><span data-stu-id="24553-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="24553-155">Próba skompilowania w poniższym przykładzie generuje błąd kompilatora CS0534, "<class> nie implementuje odziedziczonego abstrakcyjnego elementu członkowskiego <member>", ponieważ klasa `B` zapewnia implementacji `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="24553-155">Attempting to compile the following example generates compiler error CS0534, "<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="24553-156">Dziedziczenie ma zastosowanie tylko do klasy i interfejsy.</span><span class="sxs-lookup"><span data-stu-id="24553-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="24553-157">Innych kategorii typu (struktur, delegatów i typy wyliczeniowe) nie obsługuje dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="24553-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="24553-158">Z tego powodu próby kompilowania kodu podobnie do następującej powoduje błąd kompilatora CS0527: "Typu"ValueType"na liście interfejsów nie jest interfejsem."</span><span class="sxs-lookup"><span data-stu-id="24553-158">Because of this, attempting to compile code like the following produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="24553-159">Komunikat o błędzie oznacza, że chociaż można zdefiniować interfejsów, które implementuje struktury, dziedziczenia nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="24553-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="24553-160">Niejawne dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="24553-160">Implicit inheritance</span></span>

<span data-ttu-id="24553-161">Oprócz żadnych typów, które mogą dziedziczyć przez pojedyncze dziedziczenie, wszystkie typy w systemie typów .NET niejawnie dziedziczyć po <xref:System.Object> lub typ pochodzący od niego.</span><span class="sxs-lookup"><span data-stu-id="24553-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="24553-162">Dzięki temu, że typowe funkcje są dostępne do dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="24553-162">This ensures that common functionality is available to any type.</span></span>

<span data-ttu-id="24553-163">Aby zobaczyć, jakie niejawne dziedziczenia oznacza, że zdefiniujmy nową klasę `SimpleClass`, to po prostu definicja pustej klasy:</span><span class="sxs-lookup"><span data-stu-id="24553-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="24553-164">Następnie wykorzystamy odbicia (co pozwala nam sprawdzić metadanych typów, aby uzyskać informacje o tym typie) w celu uzyskania listy elementów członkowskich, które należą do `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="24553-164">We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="24553-165">Mimo że firma Microsoft nie zdefiniowano żadnych elementów członkowskich w naszym `SimpleClass` klasy, dane wyjściowe z przykładu wskazuje, że faktycznie ma dziewięciu członków.</span><span class="sxs-lookup"><span data-stu-id="24553-165">Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="24553-166">Jednym z nich jest konstruktora (domyślny lub bezparametryczny), który jest automatycznie udostępniane dla `SimpleClass` typu za pomocą kompilatora C#.</span><span class="sxs-lookup"><span data-stu-id="24553-166">One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="24553-167">Pozostałe osiem są elementami członkowskimi <xref:System.Object>, dziedziczą typu, w którym wszystkie klasy i interfejsy, w ramach platformy .NET system typów ostatecznie niejawnie.</span><span class="sxs-lookup"><span data-stu-id="24553-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="24553-168">Niejawne dziedziczenia z <xref:System.Object> klasy udostępnia następujące metody `SimpleClass` klasy:</span><span class="sxs-lookup"><span data-stu-id="24553-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="24553-169">Publicznego `ToString` metodę, która konwertuje `SimpleClass` obiektu do reprezentacji ciągu zwraca w pełni kwalifikowana nazwa typu.</span><span class="sxs-lookup"><span data-stu-id="24553-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="24553-170">W takim przypadku `ToString` metoda zwraca ciąg "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="24553-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="24553-171">Trzy metody, które testu równości dwóch obiektów: wystąpienia publicznego `Equals(Object)` metoda, publiczne statyczne `Equals(Object, Object)` — metoda i publiczne statyczne `ReferenceEquals(Object, Object)` metody.</span><span class="sxs-lookup"><span data-stu-id="24553-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="24553-172">Domyślnie te metody testowanie równości odwołań; oznacza to aby być taka sama, dwie zmienne obiektu musi odwoływać się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="24553-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="24553-173">Publicznego `GetHashCode` metodę, która oblicza wartość, która umożliwia wystąpienie typu do użycia w formie skrótu kolekcjach.</span><span class="sxs-lookup"><span data-stu-id="24553-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="24553-174">Publicznego `GetType` metody, która zwraca <xref:System.Type> obiekt, który reprezentuje `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="24553-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="24553-175">Chronionej <xref:System.Object.Finalize%2A> metodę, która jest przeznaczona do zwolnić zasoby niezarządzane, zanim pamięci obiektu jest odzyskana przez moduł garbage collector.</span><span class="sxs-lookup"><span data-stu-id="24553-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="24553-176">Chronionej <xref:System.Object.MemberwiseClone%2A> metodę, która tworzy pobieżnego klonu bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="24553-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="24553-177">Z powodu niejawne dziedziczenia, mogą nazywa się żadnych dziedziczonego elementu członkowskiego z `SimpleClass` obiekt tak, jakby był faktycznie elementu członkowskiego zdefiniowany w `SimpleClass` klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-177">Because of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="24553-178">Na przykład poniższy przykład wywołuje `SimpleClass.ToString` — metoda, która `SimpleClass` dziedziczy <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="24553-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="24553-179">W poniższej tabeli wymieniono kategorie typów, które możesz utworzyć w języku C# i typów, z których niejawnie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="24553-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="24553-180">Każdy typ podstawowy udostępnia zestaw elementów członkowskich poprzez dziedziczenie typów pochodnych niejawnie.</span><span class="sxs-lookup"><span data-stu-id="24553-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="24553-181">Typ kategorii</span><span class="sxs-lookup"><span data-stu-id="24553-181">Type category</span></span> | <span data-ttu-id="24553-182">Niejawnie dziedziczy</span><span class="sxs-lookup"><span data-stu-id="24553-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="24553-183">class</span><span class="sxs-lookup"><span data-stu-id="24553-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="24553-184">struktura </span><span class="sxs-lookup"><span data-stu-id="24553-184">struct</span></span>        | <span data-ttu-id="24553-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="24553-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="24553-186">enum</span><span class="sxs-lookup"><span data-stu-id="24553-186">enum</span></span>          | <span data-ttu-id="24553-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="24553-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="24553-188">delegate</span><span class="sxs-lookup"><span data-stu-id="24553-188">delegate</span></span>      | <span data-ttu-id="24553-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="24553-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="24553-190">Dziedziczenie i "to" relacji</span><span class="sxs-lookup"><span data-stu-id="24553-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="24553-191">Zwykle dziedziczenia jest używany do wyrażenia "jest" relację między klasą bazową i co najmniej jednej klasy pochodnej, gdzie klas pochodnych są specjalne wersje klasy podstawowej; Klasa pochodna jest typem klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="24553-192">Na przykład `Publication` klasa reprezentuje publikacji dowolnego rodzaju i `Book` i `Magazine` klasy reprezentują określonych rodzajów publikacji.</span><span class="sxs-lookup"><span data-stu-id="24553-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="24553-193">Co więcej interfejsów można zaimplementować w klasie lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="24553-193">A class or struct can implement one more interfaces.</span></span> <span data-ttu-id="24553-194">Podczas implementacji interfejsu często jest przedstawiony jako obejścia pojedyncze dziedziczenie lub sposób korzystania ze struktury dziedziczenia, jest on przeznaczony do innej relacji (relację "można wykonać") między interfejs i jej typ implementujący niż express dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="24553-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="24553-195">Interfejs definiuje podzbiór funkcji (na przykład możliwości testu równości do porównywania lub sortowania obiektów, lub do obsługi zależne od kultury analizowania i formatowanie), która udostępnia interfejs do jego implementującej typów.</span><span class="sxs-lookup"><span data-stu-id="24553-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="24553-196">Należy pamiętać, że "jest" wyraża również relacji między typem i konkretnego wystąpienia tego typu.</span><span class="sxs-lookup"><span data-stu-id="24553-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="24553-197">W poniższym przykładzie `Automobile` jest klasa, która ma trzy unikatowe właściwości tylko do odczytu: `Make`, producenta samochodów; `Model`, rodzaj samochodów; i `Year`, rok produkcji.</span><span class="sxs-lookup"><span data-stu-id="24553-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="24553-198">Nasze `Automobile` klasa ma również konstruktora, którego argumenty są przypisane do wartości właściwości i zastępuje on <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby utworzyć ciąg, który unikatowo identyfikuje `Automobile` wystąpienia zamiast `Automobile` klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-198">Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="24553-199">W takim przypadku firma Microsoft nie miały dziedziczenia do reprezentowania sprawia, że określonego samochód i modeli.</span><span class="sxs-lookup"><span data-stu-id="24553-199">In this case, we should not rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="24553-200">Na przykład nie musimy zdefiniować `Packard` typu do reprezentowania wyprodukowanych przez firmę samochodu motocykla Packard samochodów.</span><span class="sxs-lookup"><span data-stu-id="24553-200">For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="24553-201">Zamiast tego, firma Microsoft może reprezentować je przez utworzenie `Automobile` obiektu z odpowiednimi wartościami przekazanych do jego konstruktora klasy, tak jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="24553-201">Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="24553-202">Relację a jest oparte na dziedziczenia najlepiej jest stosowany do klasy podstawowej i pochodnej klasy dodatkowych członków dodaje do klasy podstawowej lub wymagających dodatkowe funkcje, które nie znajduje się w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="24553-203">Projektowanie klasy podstawowej i klasy pochodne</span><span class="sxs-lookup"><span data-stu-id="24553-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="24553-204">Oto proces projektowania klasy podstawowej i jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="24553-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="24553-205">W tej sekcji zdefiniujemy klasę podstawową `Publication`, reprezentuje publikacji dowolnego rodzaju, takie jak książkę, magazynu, gazecie, arkusz, artykułu itp. Zdefiniujemy również `Book` klasą pochodzącą z `Publication`.</span><span class="sxs-lookup"><span data-stu-id="24553-205">In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="24553-206">Firma Microsoft może łatwo rozszerzyć przykład zdefiniuj inne klas pochodnych, takich jak `Magazine`, `Journal`, `Newspaper`, i `Article`.</span><span class="sxs-lookup"><span data-stu-id="24553-206">We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="24553-207">Klasa podstawowa publikacji</span><span class="sxs-lookup"><span data-stu-id="24553-207">The base Publication class</span></span>

<span data-ttu-id="24553-208">W projektowaniu naszych `Publication` klasy, należy podjąć kilka decyzje dotyczące projektu:</span><span class="sxs-lookup"><span data-stu-id="24553-208">In designing our `Publication` class, we need to make several design decisions:</span></span>

- <span data-ttu-id="24553-209">Jakie elementy członkowskie do uwzględnienia w naszej bazie `Publication` klasy oraz tego, czy `Publication` członków Podaj implementacji metody, lub czy `Publication` jest abstrakcyjna klasa podstawowa, która służy jako szablon dla jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="24553-209">What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="24553-210">W takim przypadku `Publication` klasy zapewni implementacje metod.</span><span class="sxs-lookup"><span data-stu-id="24553-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="24553-211">[Opracowywania abstrakcyjnych klas podstawowych i ich pochodne](#abstract) sekcji przedstawiono przykładową, która używa abstrakcyjnego klasy podstawowej w celu zdefiniowania metody, które klasy pochodne muszą przesłaniać.</span><span class="sxs-lookup"><span data-stu-id="24553-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="24553-212">Klasy pochodne mogą się do żadnych implementacji, które jest odpowiednie dla typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="24553-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="24553-213">Możliwość ponownego użycia kodu (oznacza to, wielu klas pochodnych udział deklaracji i implementacji podstawowej metody klasy i nie powinny być one zastąpione) jest zaletą nieabstrakcyjnej klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="24553-214">W związku z tym należy dodawać członków do `Publication` w przypadku ich kod może być współużytkowane przez niektóre lub najbardziej specjalizowany `Publication` typów.</span><span class="sxs-lookup"><span data-stu-id="24553-214">Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="24553-215">Jeśli firma Microsoft nie powiedzie się w tym celu wydajnie, firma Microsoft będzie przechodzili konieczności podawania implementacje przeważającej mierze identyczny elementów członkowskich w klasach pochodnych raczej pojedynczą implementacją w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-215">If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="24553-216">To konieczności obsługiwania zduplikowany kod w wielu lokalizacjach jest źródłem potencjalnych błędów.</span><span class="sxs-lookup"><span data-stu-id="24553-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="24553-217">Zarówno do zmaksymalizowania kodu ponownemu i utwórz hierarchię dziedziczenia logicznych i intuicyjne, chcemy należy upewnić się, że przeprowadzamy w `Publication` klasy tylko dane i funkcje, które są wspólne dla wszystkich lub do większości publikacji.</span><span class="sxs-lookup"><span data-stu-id="24553-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="24553-218">Klasy pochodne następnie implementacji elementów członkowskich, które są unikatowe dla określonego rodzaju publikacji, które reprezentują.</span><span class="sxs-lookup"><span data-stu-id="24553-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="24553-219">Jak do tej pory rozszerzyć naszych hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="24553-219">How far to extend our class hierarchy.</span></span> <span data-ttu-id="24553-220">Czy chcemy tworzenie hierarchii co najmniej trzech klas, a nie po prostu klasy podstawowej i co najmniej jednej klasy pochodnej?</span><span class="sxs-lookup"><span data-stu-id="24553-220">Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="24553-221">Na przykład `Publication` może być klasą podstawową `Periodical`, który z kolei jest klasą podstawową `Magazine`, `Journal` i `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="24553-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="24553-222">W naszym przykładzie użyjemy proste hierarchię `Publication` klasy i jednej klasy pochodne `Book`.</span><span class="sxs-lookup"><span data-stu-id="24553-222">For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`.</span></span> <span data-ttu-id="24553-223">Firma Microsoft może łatwo rozszerzyć przykład, aby utworzyć wiele dodatkowych klas, które pochodzą z `Publication`, takich jak `Magazine` i `Article`.</span><span class="sxs-lookup"><span data-stu-id="24553-223">We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="24553-224">Czy warto utworzyć wystąpienia klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="24553-225">Jeśli nie, firma Microsoft stosuje [abstrakcyjny](../language-reference/keywords/abstract.md) — słowo kluczowe do klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-225">If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="24553-226">Jeśli do utworzenia wystąpienia klasy oznaczonej jako podejmowana jest próba `abstract` — słowo kluczowe przez bezpośrednie wywołanie dla jego konstruktora klasy kompilatora C# generuje błąd CS0144 "Nie można utworzyć wystąpienia klasy abstrakcyjnej lub interfejsu".</span><span class="sxs-lookup"><span data-stu-id="24553-226">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="24553-227">Jeśli do utworzenia wystąpienia tej klasy przy użyciu odbicia, zgłasza metody odbicia podejmowana jest próba <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="24553-227">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span> <span data-ttu-id="24553-228">W przeciwnym razie naszych `Publication` można tworzyć wystąpienia klasy przez wywołanie jego konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-228">Otherwise, our `Publication` class can be instantiated by calling its class constructor.</span></span>

  <span data-ttu-id="24553-229">Domyślnie klasy podstawowej można wdrożyć przez wywołanie jego konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="24553-230">Należy pamiętać, że firma Microsoft nie trzeba jawnie definiować konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-230">Note that we do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="24553-231">Jeśli jedno nie jest obecny w kodzie źródłowym klasy podstawowej, kompilator języka C# automatycznie zapewnia domyślnego (bezparametrowego) konstruktora.</span><span class="sxs-lookup"><span data-stu-id="24553-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="24553-232">W naszym przykładzie firma Microsoft będzie oznaczyć `Publication` klasy [abstrakcyjny](../language-reference/keywords/abstract.md) tak, aby nie można utworzyć wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="24553-232">For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>

- <span data-ttu-id="24553-233">Czy klasy pochodne muszą dziedziczyć wykonania określonych elementów członkowskich klasy podstawowej, lub czy mają możliwość zastąpienia implementacji klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-233">Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.</span></span> <span data-ttu-id="24553-234">Mamy użyj [wirtualnego](../language-reference/keywords/virtual.md) — słowo kluczowe, aby umożliwić klasy pochodne zastąpić metody klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-234">We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="24553-235">Domyślnie jest zdefiniowana w klasie podstawowej metody *nie* możliwym do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="24553-235">By default, methods defined in the base class are *not* overridable.</span></span>

- <span data-ttu-id="24553-236">Określa, czy klasa pochodna reprezentuje klasę końcowe w hierarchii dziedziczenia i nie może sam służyć jako klasę podstawową dla dodatkowych klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="24553-236">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="24553-237">Domyślnie każda klasa może służyć jako klasę podstawową.</span><span class="sxs-lookup"><span data-stu-id="24553-237">By default, any class can serve as a base class.</span></span> <span data-ttu-id="24553-238">Możemy zastosować [zapieczętowanego](../language-reference/keywords/sealed.md) — słowo kluczowe, aby wskazać, że klasa nie może służyć jako klasę podstawową dla wszystkich dodatkowych klas.</span><span class="sxs-lookup"><span data-stu-id="24553-238">We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="24553-239">Podjęto próbę pochodzi od klasy zapieczętowanej wygenerowany błąd kompilatora CS0509, "nie może pochodzić od typu zapieczętowanego <typeName>".</span><span class="sxs-lookup"><span data-stu-id="24553-239">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type <typeName>".</span></span>

  <span data-ttu-id="24553-240">W naszym przykładzie mamy oznaczyć naszej klasy pochodnej jako `sealed`.</span><span class="sxs-lookup"><span data-stu-id="24553-240">For our example, we'll mark our derived class as `sealed`.</span></span>

<span data-ttu-id="24553-241">W poniższym przykładzie pokazano kod źródłowy `Publication` klasy, a także `PublicationType` wyliczenia, która jest zwracana w wyniku `Publication.PublicationType` właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-241">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="24553-242">Oprócz elementów członkowskich, które dziedziczy on z <xref:System.Object>, `Publication` klasa definiuje następujące unikatowych elementów członkowskich i element członkowski zastępuje element:</span><span class="sxs-lookup"><span data-stu-id="24553-242">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="24553-243">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="24553-243">A constructor</span></span>

  <span data-ttu-id="24553-244">Ponieważ `Publication` jest klasa `abstract`, nie można utworzyć wystąpienia bezpośrednio z kodu podobnie do następującej:</span><span class="sxs-lookup"><span data-stu-id="24553-244">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="24553-245">Jednak można wywołać jej konstruktora wystąpienia bezpośrednio z konstruktorów w klasie pochodnej, jako kod źródłowy `Book` pokazuje klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-245">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="24553-246">Dwie właściwości związanych z publikacji</span><span class="sxs-lookup"><span data-stu-id="24553-246">Two publication-related properties</span></span>

  <span data-ttu-id="24553-247">`Title` jest tylko do odczytu <xref:System.String> właściwości, której wartość jest dostarczana przez wywołanie `Publication` konstruktora.</span><span class="sxs-lookup"><span data-stu-id="24553-247">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="24553-248">`Pages` jest odczytu i zapisu <xref:System.Int32> ma właściwość, która wskazuje, ile łączna liczba stron publikacji.</span><span class="sxs-lookup"><span data-stu-id="24553-248">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="24553-249">Wartość jest przechowywana w polu prywatnej o nazwie `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="24553-249">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="24553-250">Musi być liczbą dodatnią lub <xref:System.ArgumentOutOfRangeException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="24553-250">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="24553-251">Wydawca związane z członków</span><span class="sxs-lookup"><span data-stu-id="24553-251">Publisher-related members</span></span>

  <span data-ttu-id="24553-252">Dwie właściwości tylko do odczytu, `Publisher` i `Type`.</span><span class="sxs-lookup"><span data-stu-id="24553-252">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="24553-253">Wartości pierwotnie są dostarczane przez wywołanie `Publication` konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-253">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="24553-254">Dotyczące publikowania elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="24553-254">Publishing-related members</span></span>

  <span data-ttu-id="24553-255">Dwie metody `Publish` i `GetPublicationDate`, ustawianie i zwracanie dat publikacji.</span><span class="sxs-lookup"><span data-stu-id="24553-255">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="24553-256">`Publish` Metoda ustawia prywatnej `published` flaga `true` gdy jest wywoływana i przypisuje daty do niej przekazany jako argument prywatna `datePublished` pola.</span><span class="sxs-lookup"><span data-stu-id="24553-256">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="24553-257">`GetPublicationDate` Metoda zwraca ciąg "NYP", jeśli `published` flaga jest `false`i wartość `datePublished` pola, jeśli jest `true`.</span><span class="sxs-lookup"><span data-stu-id="24553-257">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="24553-258">Pokrewnych elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="24553-258">Copyright-related members</span></span>

  <span data-ttu-id="24553-259">`Copyright` Metoda przyjmuje jako argumenty nazwę autorskich oraz roku praw autorskich i przypisuje je do `CopyrightName` i `CopyrightDate` właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-259">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="24553-260">Zastępowanie `ToString` — metoda</span><span class="sxs-lookup"><span data-stu-id="24553-260">An override of the `ToString` method</span></span>

  <span data-ttu-id="24553-261">Jeśli typ nie przesłania <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca w pełni kwalifikowana nazwa typu, który jest rzadko używane w rozróżnianie jedno wystąpienie z innej.</span><span class="sxs-lookup"><span data-stu-id="24553-261">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="24553-262">`Publication` Klasy zastąpienia <xref:System.Object.ToString%2A?displayProperty=nameWithType> do zwracania wartości `Title` właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-262">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="24553-263">Na poniższym rysunku przedstawiono relacje między naszych base `Publication` klasy i jego niejawnie dziedziczenia <xref:System.Object> klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-263">The following figure illustrates the relationship between our base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Klasy obiektów i publikacji](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="24553-265">`Book` — Klasa</span><span class="sxs-lookup"><span data-stu-id="24553-265">The `Book` class</span></span>

<span data-ttu-id="24553-266">`Book` Klasa reprezentuje książkę jako specjalistyczną odmianą publikacji.</span><span class="sxs-lookup"><span data-stu-id="24553-266">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="24553-267">W poniższym przykładzie pokazano kod źródłowy `Book` klasy.</span><span class="sxs-lookup"><span data-stu-id="24553-267">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="24553-268">Oprócz elementów członkowskich, które dziedziczy on z `Publication`, `Book` klasa definiuje następujące unikatowych elementów członkowskich i element członkowski zastępuje element:</span><span class="sxs-lookup"><span data-stu-id="24553-268">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="24553-269">Dwa konstruktory</span><span class="sxs-lookup"><span data-stu-id="24553-269">Two constructors</span></span>

  <span data-ttu-id="24553-270">Dwa `Book` konstruktorów udostępnianie trzy typowych parametrów.</span><span class="sxs-lookup"><span data-stu-id="24553-270">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="24553-271">Dwa, *tytuł* i *wydawcy*, odpowiadają parametrom `Publication` konstruktora.</span><span class="sxs-lookup"><span data-stu-id="24553-271">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="24553-272">Trzeci jest *autora*, który jest przechowywany prywatną `authorName` pola.</span><span class="sxs-lookup"><span data-stu-id="24553-272">The third is *author*, which is stored to a private `authorName` field.</span></span> <span data-ttu-id="24553-273">Zawiera jeden konstruktor *isbn* parametr, który jest przechowywany w `ISBN` auto właściwością.</span><span class="sxs-lookup"><span data-stu-id="24553-273">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="24553-274">Używa pierwszego konstruktora [to](../language-reference/keywords/this.md) — słowo kluczowe do wywoływania innego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="24553-274">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="24553-275">Jest to wspólnego wzorca podczas definiowania konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="24553-275">This is a common pattern in defining constructors.</span></span> <span data-ttu-id="24553-276">Konstruktorów z parametrami mniej podać wartości domyślne podczas wywoływania konstruktora z największą liczbą parametrów.</span><span class="sxs-lookup"><span data-stu-id="24553-276">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="24553-277">Drugi Konstruktor korzysta [podstawowej](../language-reference/keywords/base.md) — słowo kluczowe do przekazania do konstruktora klasy podstawowej nazwy stanowiska i wydawcy.</span><span class="sxs-lookup"><span data-stu-id="24553-277">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="24553-278">Jeśli nie wprowadzisz jawnym wywołaniem konstruktora klasy podstawowej w kodzie źródłowym, kompilator języka C# automatycznie dostarcza wywołanie domyślnego lub konstruktora klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-278">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="24553-279">Tylko do odczytu `ISBN` właściwość, która zwraca `Book` obiektu Międzynarodowy Znormalizowany Numer książki, unikatowe 10 - lub 13-cyfrowy numer.</span><span class="sxs-lookup"><span data-stu-id="24553-279">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="24553-280">ISBN jest podana jako argument do jednego z `Book` konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="24553-280">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="24553-281">ISBN są przechowywane w polem zapasowym prywatny, który został wygenerowany automatycznie przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="24553-281">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="24553-282">Tylko do odczytu `Author` właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-282">A read-only `Author` property.</span></span> <span data-ttu-id="24553-283">Imię i nazwisko autora jest podana jako argument do obu `Book` konstruktory i jest przechowywany w prywatnej `authorName` pola.</span><span class="sxs-lookup"><span data-stu-id="24553-283">The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field.</span></span>

- <span data-ttu-id="24553-284">Dwie właściwości tylko do odczytu dotyczące cen, `Price` i `Currency`.</span><span class="sxs-lookup"><span data-stu-id="24553-284">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="24553-285">Ich wartości są przekazywane jako argumenty `SetPrice` wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="24553-285">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="24553-286">Cena jest przechowywany w prywatnej pola, `bookPrice`.</span><span class="sxs-lookup"><span data-stu-id="24553-286">The price is stored in a private field, `bookPrice`.</span></span> <span data-ttu-id="24553-287">`Currency` Jest symbol waluty ISO cyfry (na przykład USD dla dolara amerykańskiego) i jest przechowywany w prywatnej `ISOCurrencySymbol` pola.</span><span class="sxs-lookup"><span data-stu-id="24553-287">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field.</span></span> <span data-ttu-id="24553-288">ISO waluty symboli może zostać pobrany z <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-288">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span>

- <span data-ttu-id="24553-289">A `SetPrice` metodę, która ustawia wartości `bookPrice` i `ISOCurrencySymbol` pól.</span><span class="sxs-lookup"><span data-stu-id="24553-289">A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields.</span></span> <span data-ttu-id="24553-290">Są to wartości zwracanych przez `Price` i `Currency` właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-290">These are the values returned by the `Price` and `Currency` properties.</span></span>

- <span data-ttu-id="24553-291">Zastąpień w celu `ToString` — metoda (dziedziczone z `Publication`) i <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> i <xref:System.Object.GetHashCode%2A> metod (dziedziczone z <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="24553-291">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="24553-292">Jeśli nie zostanie on przesłonięty <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> testy metoda równości odwołań.</span><span class="sxs-lookup"><span data-stu-id="24553-292">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="24553-293">Oznacza to, że dwie zmienne obiektu są traktowane jako równe odnoszące się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="24553-293">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="24553-294">W przypadku liczby `Book` klasy, z drugiej strony, dwa `Book` obiekty powinny być takie same, jeśli mają tego samego ISBN.</span><span class="sxs-lookup"><span data-stu-id="24553-294">In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="24553-295">Jeśli zastąpienie <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody, należy również zmienić <xref:System.Object.GetHashCode%2A> metody, która zwraca wartość, która środowiska uruchomieniowego używa do przechowywania elementów w kolekcjach skrótem wydajne pobierania.</span><span class="sxs-lookup"><span data-stu-id="24553-295">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="24553-296">Wartość skrótu powinien zwrócić wartość, która jest zgodna z testowanie równości.</span><span class="sxs-lookup"><span data-stu-id="24553-296">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="24553-297">Ponieważ firma Microsoft została zastąpiona <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> do zwrócenia `true` Jeśli właściwości ISBN dwóch `Book` obiekty są takie same, zostanie zwrócona wartość skrótu obliczana przez wywołanie metody <xref:System.String.GetHashCode%2A> ciąg zwracany przez metodę `ISBN` właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-297">Since we've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="24553-298">Na poniższym rysunku przedstawiono relacje między `Book` klasy i `Publication`, jej klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-298">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Klasy publikacji i książki](media/book-class.jpg)

<span data-ttu-id="24553-300">Mamy teraz utworzyć wystąpienia `Book` obiektów, wywołanie jej unikatowy i dziedziczonych członków i przekaż go jako argument do metody, która oczekuje parametru typu `Publication` lub typu `Book`, jak pokazano na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="24553-300">We can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="24553-301">Opracowywania abstrakcyjnych klas podstawowych i ich pochodne</span><span class="sxs-lookup"><span data-stu-id="24553-301">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="24553-302">W poprzednim przykładzie zdefiniowanego przewidzianego implementację metody umożliwiają klasy pochodne udostępnić kod klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="24553-302">In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="24553-303">W wielu przypadkach jednak klasy podstawowej nie powinien zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="24553-303">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="24553-304">Klasa podstawowa jest *klasy abstrakcyjnej*; służy jako szablon, który definiuje elementy każdej klasie pochodnej musi implementować.</span><span class="sxs-lookup"><span data-stu-id="24553-304">Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="24553-305">Zwykle w przypadku abstrakcyjna klasa podstawowa implementacja każdego typu pochodnego jest unikatowa dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="24553-305">Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</span></span>

<span data-ttu-id="24553-306">Na przykład zamknięty kształt dwuwymiarowy geometrycznych zawiera dwie właściwości: obszar, wewnętrzny zakres kształtu; i obwodowej lub odległości wzdłuż krawędzi kształtu.</span><span class="sxs-lookup"><span data-stu-id="24553-306">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="24553-307">Sposób, w którym mają być obliczane te właściwości, jednak zależy całkowicie określonego kształtu.</span><span class="sxs-lookup"><span data-stu-id="24553-307">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="24553-308">Obliczanie obwodowej (lub obwodu) koło, na przykład bardzo różni się od elementu trójkąt.</span><span class="sxs-lookup"><span data-stu-id="24553-308">The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</span></span>

<span data-ttu-id="24553-309">W poniższym przykładzie zdefiniowano abstrakcyjna klasa podstawowa o nazwie `Shape` definiuje dwie właściwości: `Area` i `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="24553-309">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="24553-310">Należy zauważyć, że oprócz oznaczyć klasę atrybutem [abstrakcyjny](../language-reference/keywords/abstract.md) — słowo kluczowe, każdy element członkowski wystąpienia również jest oznaczony atrybutem [abstrakcyjny](../language-reference/keywords/abstract.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="24553-310">Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="24553-311">W takim przypadku `Shape` zastępuje również <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby zwrócić nazwę typu, a nie w pełni kwalifikowanej nazwy.</span><span class="sxs-lookup"><span data-stu-id="24553-311">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="24553-312">I definiuje dwa elementy członkowskie static, `GetArea` i `GetPerimeter`, który zezwalać elementom wywołującym można łatwo pobrać i obwód wystąpienie klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="24553-312">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="24553-313">Gdy wystąpienie klasy pochodnej jest przekazywana do żadnej z tych metod, środowisko urchomieniowe wywołuje metodę zastępującą klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="24553-313">When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="24553-314">Firma Microsoft może następnie wyprowadzać niektóre klasy z `Shape` reprezentujące określonych kształtów.</span><span class="sxs-lookup"><span data-stu-id="24553-314">We can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="24553-315">W poniższym przykładzie zdefiniowano trzech klas `Triangle`, `Rectangle`, i `Circle`.</span><span class="sxs-lookup"><span data-stu-id="24553-315">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="24553-316">Formuła unikatowe dla tego konkretnego kształtu każdego używa do wyliczenia powierzchni i obwodu.</span><span class="sxs-lookup"><span data-stu-id="24553-316">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="24553-317">Niektóre z klasy pochodnej także zdefiniować właściwości, takie jak `Rectangle.Diagonal` i `Circle.Diameter`, które są unikatowe dla kształtu, który reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="24553-317">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="24553-318">W poniższym przykładzie użyto obiektów pochodzących od `Shape`.</span><span class="sxs-lookup"><span data-stu-id="24553-318">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="24553-319">Metoda tworzy tablicę obiektów pochodzących od `Shape` i wywołania metod statycznych `Shape` klasy, która opakowuje zwrotu `Shape` wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="24553-319">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="24553-320">Należy pamiętać, że środowisko wykonawcze pobiera wartości z zastąpione właściwości z typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="24553-320">Note that the runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="24553-321">Przykład również rzutowań w każdym `Shape` obiektu w tablicy, tak aby jego pochodny typ i, jeśli rzutowanie zakończy się powodzeniem, pobiera właściwości tego konkretnego podklasą klasy `Shape`.</span><span class="sxs-lookup"><span data-stu-id="24553-321">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="24553-322">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="24553-322">See also</span></span>

<span data-ttu-id="24553-323">[Klasy i obiekty](../tour-of-csharp/classes-and-objects.md) </span><span class="sxs-lookup"><span data-stu-id="24553-323">[Classes and objects](../tour-of-csharp/classes-and-objects.md) </span></span>  
[<span data-ttu-id="24553-324">Dziedziczenie (C# przewodnik programowania w języku)</span><span class="sxs-lookup"><span data-stu-id="24553-324">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
