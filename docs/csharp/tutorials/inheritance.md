---
title: Dziedziczenie w języku C#
description: Dowiedz się użyć dziedziczenia w C#, bibliotek i aplikacji.
author: rpetrusha
ms.author: ronpet
ms.date: 07/05/2018
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 644e0bb281525fad12e263b31263bb9caba149f0
ms.sourcegitcommit: 7156c0b9e4ce4ce5ecf48ce3d925403b638b680c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/26/2019
ms.locfileid: "58463816"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="a7c56-103">Dziedziczenie w języku C# i .NET</span><span class="sxs-lookup"><span data-stu-id="a7c56-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="a7c56-104">W tym samouczku przedstawiono dziedziczenia w C#.</span><span class="sxs-lookup"><span data-stu-id="a7c56-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="a7c56-105">Dziedziczenie jest funkcją zorientowane obiektowo języków programowania, która pozwala zdefiniować klasę bazową, który zapewnia funkcje (danych i zachowanie) i definiowanie klas pochodnych, które dziedziczą lub zastąpić tę funkcję.</span><span class="sxs-lookup"><span data-stu-id="a7c56-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="a7c56-106">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="a7c56-106">Prerequisites</span></span>

<span data-ttu-id="a7c56-107">Ten samouczek zakłada, że po zainstalowaniu platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a7c56-107">This tutorial assumes that you've installed .NET Core.</span></span> <span data-ttu-id="a7c56-108">Aby uzyskać instrukcje dotyczące instalacji, zobacz [Przewodnik instalacji platformy .NET Core](https://www.microsoft.com/net/core).</span><span class="sxs-lookup"><span data-stu-id="a7c56-108">For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core).</span></span> <span data-ttu-id="a7c56-109">Należy również edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-109">You also need a code editor.</span></span> <span data-ttu-id="a7c56-110">W tym samouczku [programu Visual Studio Code](https://code.visualstudio.com), chociaż można używać dowolnego edytora kodu, wybranych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a7c56-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="a7c56-111">Uruchamianie przykładów</span><span class="sxs-lookup"><span data-stu-id="a7c56-111">Running the examples</span></span>

<span data-ttu-id="a7c56-112">Aby utworzyć i uruchomić przykłady w tym samouczku, należy użyć [dotnet](../../core/tools/dotnet.md) narzędzie z wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="a7c56-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="a7c56-113">Wykonaj następujące kroki dla każdego przykładu:</span><span class="sxs-lookup"><span data-stu-id="a7c56-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="a7c56-114">Utwórz katalog do przechowywania w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a7c56-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="a7c56-115">Wprowadź [dotnet nową konsolę](../../core/tools/dotnet-new.md) polecenie w wierszu polecenia, aby utworzyć nowy projekt .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a7c56-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="a7c56-116">Skopiuj i Wklej kod z przykładu do edytora kodu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="a7c56-117">Wprowadź [dotnet restore](../../core/tools/dotnet-restore.md) polecenia z wiersza polecenia do załadowania lub przywracanie zależności projektu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="a7c56-118">Wprowadź [dotnet, uruchom](../../core/tools/dotnet-run.md) polecenie, aby skompilować i wykonać przykładu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="a7c56-119">Tło: Co to jest dziedziczenie?</span><span class="sxs-lookup"><span data-stu-id="a7c56-119">Background: What is inheritance?</span></span>

<span data-ttu-id="a7c56-120">*Dziedziczenie* jest jednym z podstawowych atrybutów programowanie zorientowane obiektowo.</span><span class="sxs-lookup"><span data-stu-id="a7c56-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="a7c56-121">Pozwala na zdefiniowanie klasę podrzędną, która używa (dziedziczy) rozszerza i modyfikuje zachowanie klasy nadrzędnej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="a7c56-122">Nosi nazwę klasy, której członkowie są dziedziczeni *klasy bazowej*.</span><span class="sxs-lookup"><span data-stu-id="a7c56-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="a7c56-123">Nosi nazwę klasy, która dziedziczy członków klasy podstawowej *klasy pochodnej*.</span><span class="sxs-lookup"><span data-stu-id="a7c56-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="a7c56-124">Obsługa języka C# i .NET *pojedyncze dziedziczenie* tylko.</span><span class="sxs-lookup"><span data-stu-id="a7c56-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="a7c56-125">Oznacza to, że klasa może dziedziczyć tylko pojedynczą klasę.</span><span class="sxs-lookup"><span data-stu-id="a7c56-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="a7c56-126">Jednak dziedziczenia jest przechodnia, co pozwala na zdefiniowanie Hierarchia dziedziczenia dla zestawu typów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="a7c56-127">Innymi słowy, wpisz `D` może dziedziczyć z typu `C`, który dziedziczy z typu `B`, który dziedziczy z klasy podstawowej typu `A`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="a7c56-128">Ponieważ dziedziczenia jest przechodnia, elementy członkowskie typu `A` są dostępne dla typów `D`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="a7c56-129">Nie wszystkie elementy członkowskie klasy bazowej są dziedziczone przez klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="a7c56-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="a7c56-130">Następujące elementy członkowskie nie są dziedziczone:</span><span class="sxs-lookup"><span data-stu-id="a7c56-130">The following members are not inherited:</span></span>

- <span data-ttu-id="a7c56-131">[Konstruktory statyczne](../programming-guide/classes-and-structs/static-constructors.md), który inicjowanie danych statycznych w klasie.</span><span class="sxs-lookup"><span data-stu-id="a7c56-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="a7c56-132">[Konstruktory wystąpień](../programming-guide/classes-and-structs/constructors.md), które należy wywołać, aby utworzyć nowe wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="a7c56-133">Każda klasa musi definiować własne konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="a7c56-134">[Finalizatory](../programming-guide/classes-and-structs/destructors.md), które są wywoływane przez moduł wyrzucania elementów bezużytecznych w środowisku uruchomieniowym do likwidacji wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="a7c56-135">Podczas wszystkich innych członków klasy podstawowej są dziedziczone przez klasy pochodne, czy są one widoczne czy nie zależy od ich dostępność.</span><span class="sxs-lookup"><span data-stu-id="a7c56-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="a7c56-136">Ułatwienia dostępu członków wpływa na jego widoczność klas pochodnych w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a7c56-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="a7c56-137">[Prywatne](../language-reference/keywords/private.md) elementy są widoczne tylko w klasach pochodnych, które są osadzone w swojej klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="a7c56-138">W przeciwnym razie nie są widoczne w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="a7c56-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="a7c56-139">W poniższym przykładzie `A.B` to klasa zagnieżdżona, która pochodzi od klasy `A`, i `C` pochodzi od klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="a7c56-140">Prywatna `A.value` pole jest widoczne w A.B.</span><span class="sxs-lookup"><span data-stu-id="a7c56-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="a7c56-141">Jednak jeśli usuniesz komentarze z `C.GetValue` metody i podjęcie próby skompilować przykład generuje błąd kompilatora CS0122: "" A.value"jest niedostępny z powodu swojego poziomu ochrony".</span><span class="sxs-lookup"><span data-stu-id="a7c56-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="a7c56-142">[Chronione](../language-reference/keywords/protected.md) elementy są widoczne tylko w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="a7c56-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="a7c56-143">[Wewnętrzny](../language-reference/keywords/internal.md) elementy są widoczne tylko w klasach pochodnych, które znajdują się w tym samym zestawie jako klasa bazowa.</span><span class="sxs-lookup"><span data-stu-id="a7c56-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="a7c56-144">Nie są widoczne w klasach pochodnych znajduje się w innym zestawie z klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="a7c56-145">[Publiczne](../language-reference/keywords/public.md) elementów członkowskich są widoczne w klasach pochodnych i są dostępne w ramach interfejsu publicznego klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="a7c56-146">Publiczne dziedziczone elementy Członkowskie mogą być wywoływane tak, jakby zostały zdefiniowane w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="a7c56-147">W poniższym przykładzie klasa `A` definiuje metodę o nazwie `Method1`, a klasa `B` dziedziczy z klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="a7c56-148">Przykład następnie wywołuje `Method1` tak, jakby był metodą instancji na `B`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="a7c56-149">Klasy pochodne mogą również *zastąpienia* odziedziczone składowe, zapewniając alternatywnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="a7c56-150">Aby można było przesłonić składowej, składowej w klasie podstawowej musi być oznaczony przez [wirtualnego](../language-reference/keywords/virtual.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="a7c56-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="a7c56-151">Domyślnie składowych klasy bazowej nie są oznaczane jako `virtual` i nie może zostać zastąpiona.</span><span class="sxs-lookup"><span data-stu-id="a7c56-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="a7c56-152">Próba zastąpienia niewirtualną elementu członkowskiego, jak poniższy przykład generuje błąd kompilatora CS0506: "\<składowej > nie można przesłonić odziedziczonej składowej \<składowej >, ponieważ nie jest oznaczony wirtualnego, abstract" ani "override.</span><span class="sxs-lookup"><span data-stu-id="a7c56-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="a7c56-153">W niektórych przypadkach klasę pochodną *musi* zastępować implementację klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="a7c56-154">Składowych klasy oznaczona za pomocą podstawowej [abstrakcyjne](../language-reference/keywords/abstract.md) — słowo kluczowe wymaga, że klasy pochodne je zastąpić.</span><span class="sxs-lookup"><span data-stu-id="a7c56-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="a7c56-155">Podjęto próbę skompilować poniższy przykład generuje błąd kompilatora CS0534, "&lt;klasy&gt; nie implementuje odziedziczonej abstrakcyjnej składowej &lt;elementu członkowskiego&gt;", ponieważ klasa `B` nie zawiera Implementacja `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="a7c56-156">Dziedziczenie ma zastosowanie tylko do klasy i interfejsy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="a7c56-157">Inne kategorie (struktur, delegaty i wyliczeń) nie obsługują dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="a7c56-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="a7c56-158">Ze względu na te reguły próby kompilacji kodu, takie jak poniższy przykład generuje błąd kompilatora CS0527: "Typ"ValueType"na liście interfejsów nie jest interfejsem."</span><span class="sxs-lookup"><span data-stu-id="a7c56-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="a7c56-159">Komunikat o błędzie wskazuje, że, mimo że można zdefiniować interfejsy, które implementuje struktury, dziedziczenie nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="a7c56-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="a7c56-160">Niejawne dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="a7c56-160">Implicit inheritance</span></span>

<span data-ttu-id="a7c56-161">Oprócz żadnych typów, które mogą dziedziczyć z przez pojedyncze dziedziczenie, wszystkie typy w systemie typów .NET niejawnie dziedziczą z <xref:System.Object> lub typ pochodzący od niego.</span><span class="sxs-lookup"><span data-stu-id="a7c56-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="a7c56-162">Typowe funkcje <xref:System.Object> jest dostępny dla dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="a7c56-163">Aby zobaczyć, jakie niejawne dziedziczenia oznacza, że czynnością jest zdefiniowanie nowej klasy `SimpleClass`, to po prostu pustą definicję klasy:</span><span class="sxs-lookup"><span data-stu-id="a7c56-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="a7c56-164">Następnie można użyć odbicia, (która pozwala sprawdzić metadanych typu, aby uzyskać informacje dotyczące tego typu) w celu uzyskania listy elementów członkowskich, które należą do `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="a7c56-165">Mimo że jeszcze nie zdefiniowano żadnych elementów członkowskich w swojej `SimpleClass` klasy, dane wyjściowe z przykładu wskazuje, że faktycznie ma dziewięciu członków.</span><span class="sxs-lookup"><span data-stu-id="a7c56-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="a7c56-166">Jedną z tych składowych jest konstruktorem bez parametrów (lub domyślny), automatycznie dostarczany dla `SimpleClass` typu przez kompilator języka C#.</span><span class="sxs-lookup"><span data-stu-id="a7c56-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="a7c56-167">Pozostałe ośmiu są elementami członkowskimi <xref:System.Object>, typ, z której wszystkie klasy i interfejsy na platformie .NET system typów ostatecznie niejawnie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="a7c56-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="a7c56-168">Niejawne dziedziczenie z <xref:System.Object> klasy sprawia, że te metody są dostępne dla `SimpleClass` klasy:</span><span class="sxs-lookup"><span data-stu-id="a7c56-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="a7c56-169">Publicznie `ToString` metody, która konwertuje `SimpleClass` obiektu na jego reprezentację ciągu zwraca w pełni kwalifikowana nazwa typu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="a7c56-170">W tym przypadku `ToString` metoda zwraca ciąg "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="a7c56-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="a7c56-171">Trzy metody testowania pod kątem równości dwóch obiektów: publiczne wystąpienia `Equals(Object)` metody, publiczne statyczne `Equals(Object, Object)` metoda i publiczne statyczne `ReferenceEquals(Object, Object)` metody.</span><span class="sxs-lookup"><span data-stu-id="a7c56-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="a7c56-172">Domyślnie te metody testu równości odwołań; oznacza to aby być taka sama, dwie zmienne obiektu musi odwoływać się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="a7c56-173">Publicznie `GetHashCode` metody, która oblicza wartość, która umożliwia wystąpienia typu, który ma być używany w kolekcjach w formie skrótu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="a7c56-174">Publicznie `GetType` metody, która zwraca <xref:System.Type> obiekt, który reprezentuje `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="a7c56-175">Chronionego <xref:System.Object.Finalize%2A> metody, który został zaprojektowany, aby zwolnić niezarządzane zasoby, zanim pamięci obiektu jest odzyskiwane przez moduł odśmiecania pamięci.</span><span class="sxs-lookup"><span data-stu-id="a7c56-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="a7c56-176">Chronionego <xref:System.Object.MemberwiseClone%2A> metody, która tworzy pobieżne klonowanie bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="a7c56-177">Ze względu na niejawne dziedziczenie, można wywołać wszelkie odziedziczonej składowej przed `SimpleClass` obiekt po prostu, tak jakby znajdowała się faktycznie elementu członkowskiego zdefiniowany w `SimpleClass` klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="a7c56-178">Na przykład poniższy przykład wywołuje `SimpleClass.ToString` metody, która `SimpleClass` dziedziczy <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a7c56-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="a7c56-179">W poniższej tabeli wymieniono kategorie typów, utworzone w języku C# oraz typy, z których niejawnie dziedziczą.</span><span class="sxs-lookup"><span data-stu-id="a7c56-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="a7c56-180">Każdego typu podstawowego sprawia, że inny zbiór elementów członkowskich jest dostępna za pośrednictwem dziedziczenia dla typów pochodnych niejawnie.</span><span class="sxs-lookup"><span data-stu-id="a7c56-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="a7c56-181">Kategoria typów</span><span class="sxs-lookup"><span data-stu-id="a7c56-181">Type category</span></span> | <span data-ttu-id="a7c56-182">Dziedziczy niejawnie z</span><span class="sxs-lookup"><span data-stu-id="a7c56-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="a7c56-183">class</span><span class="sxs-lookup"><span data-stu-id="a7c56-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="a7c56-184">struktura </span><span class="sxs-lookup"><span data-stu-id="a7c56-184">struct</span></span>        | <span data-ttu-id="a7c56-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="a7c56-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="a7c56-186">enum</span><span class="sxs-lookup"><span data-stu-id="a7c56-186">enum</span></span>          | <span data-ttu-id="a7c56-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="a7c56-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="a7c56-188">delegate</span><span class="sxs-lookup"><span data-stu-id="a7c56-188">delegate</span></span>      | <span data-ttu-id="a7c56-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="a7c56-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="a7c56-190">Dziedziczenie i "to" relacji</span><span class="sxs-lookup"><span data-stu-id="a7c56-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="a7c56-191">Zazwyczaj dziedziczenia jest używany do wyrażenia "to" relację między klasą bazową i jeden lub więcej klas pochodnych, w których specjalistyczne wersje klasy bazowej; klasy pochodne Klasa pochodna jest typem klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="a7c56-192">Na przykład `Publication` klasa reprezentuje publikacji dowolnego rodzaju i `Book` i `Magazine` klasy reprezentują określonych rodzajów publikacji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="a7c56-193">Klasy lub struktury, można zaimplementować jeden lub więcej interfejsów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="a7c56-194">Podczas implementacji interfejsu często są prezentowane, jako obejście pojedyncze dziedziczenie lub sposób użycia dziedziczenia w strukturach, jest ona przeznaczona do innej relacji (relację "może zrobić") między interfejsem, a jego typ implementujący niż express dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="a7c56-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="a7c56-195">Interfejs definiuje podzbiór funkcji (np. możliwość testowania pod kątem równości do porównywania lub Sortuj obiektów, lub obsługuje wrażliwość na ustawienia kulturowe formatowanie i analizowanie), która udostępnia interfejs do jego typy implementujące.</span><span class="sxs-lookup"><span data-stu-id="a7c56-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="a7c56-196">Należy pamiętać, że "jest" również określa relację między typem i określonego wystąpienia tego typu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="a7c56-197">W poniższym przykładzie `Automobile` to klasa, która ma trzy unikatowe właściwości tylko do odczytu: `Make`, producent samochodów; `Model`, rodzaj samochodów; i `Year`, rok produkcji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="a7c56-198">Twoje `Automobile` klasa również ma konstruktora, w której argumenty są przypisywane do wartości właściwości i zastępuje ona <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody do tworzenia ciąg, który unikatowo identyfikuje `Automobile` wystąpienia zamiast `Automobile` klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="a7c56-199">W tym przypadku nie należy traktować dziedziczenia do reprezentowania określonych samochodu marek i modeli.</span><span class="sxs-lookup"><span data-stu-id="a7c56-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="a7c56-200">Na przykład, nie trzeba zdefiniować `Packard` typu do reprezentowania wytwarzane przez firma samochodowa Motor Packard samochodów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="a7c56-201">Zamiast tego należy je reprezentować, tworząc `Automobile` obiektu odpowiednimi wartościami, które są przekazywane do jej konstruktora klasy, tak jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a7c56-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="a7c56-202">Relacji oparte na dziedziczenie w to a najlepiej jest stosowany do klasy podstawowej i pochodnej klasy, Dodaj dodatkowe elementy członkowskie do klasy bazowej lub które wymagają dodatkowych funkcji, które nie znajduje się w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="a7c56-203">Projektowanie klasy podstawowej i klasy pochodne</span><span class="sxs-lookup"><span data-stu-id="a7c56-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="a7c56-204">Przyjrzyjmy się proces projektowania klasy podstawowej i jej klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="a7c56-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="a7c56-205">W tej sekcji należy zdefiniować klasę bazową `Publication`, która reprezentuje publikacji jakiegokolwiek rodzaju, takich jak książki, magazynu, gazet, dziennikiem, artykułu itp. Należy także zdefiniować `Book` klasę pochodzącą od `Publication`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="a7c56-206">Można łatwo rozszerzyć przykładu tak, aby zdefiniować innych klas pochodnych, takich jak `Magazine`, `Journal`, `Newspaper`, i `Article`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="a7c56-207">Klasa bazowa publikacji</span><span class="sxs-lookup"><span data-stu-id="a7c56-207">The base Publication class</span></span>

<span data-ttu-id="a7c56-208">W projektowaniu swoje `Publication` klasy, musisz wprowadzić kilka decyzje dotyczące projektu:</span><span class="sxs-lookup"><span data-stu-id="a7c56-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="a7c56-209">Jakie elementy członkowskie do uwzględnienia w podstawowym `Publication` klasy oraz tego, czy `Publication` członkowie dostarczać implementacje metod czy `Publication` jest abstrakcyjną klasę bazową, która służy jako szablon do jej klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="a7c56-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="a7c56-210">W tym przypadku `Publication` klasa będzie dostarczać implementacje metod.</span><span class="sxs-lookup"><span data-stu-id="a7c56-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="a7c56-211">[Projektowania abstrakcyjnych klas bazowych i ich klasy pochodne](#abstract) sekcja zawiera przykład pokazujący abstrakcyjną klasę bazową do definiowania metod, które klasy pochodne muszą przesłaniać.</span><span class="sxs-lookup"><span data-stu-id="a7c56-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="a7c56-212">Klasy pochodne mogą wszelkie implementacji, które jest odpowiednie dla typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="a7c56-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="a7c56-213">Możliwość ponownego użycia kodu (oznacza to, że wiele klas pochodnych udział deklarację i implementację base metody klasy i nie trzeba je zastąpić) jest zaletą nieabstrakcyjnej klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="a7c56-214">W związku z tym, należy dodać członków do `Publication` jeśli ich kod jest może być współużytkowane przez niektóre lub najbardziej wyspecjalizowane `Publication` typów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="a7c56-215">Jeśli nie wydajnie dostarczać implementacje klasy bazowej, będzie znajdą koniczności podawania implementacji elementu członkowskiego w przeważającej mierze identyczny w klasach pochodnych zamiast pojedynczego wykonania w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="a7c56-216">Potrzebę utrzymywania zduplikowany kodem w wielu lokalizacjach jest potencjalnym źródłem błędów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="a7c56-217">Zarówno w celu zmaksymalizowania kodu ponownego użycia oraz do tworzenia hierarchii dziedziczenia logiczne i intuicyjne, chcesz upewnij się, że uwzględniasz w `Publication` klasy tylko dane i funkcje, które są wspólne dla wszystkich lub większości publikacji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="a7c56-218">Klasy pochodne następnie zaimplementuj elementy członkowskie, które są unikatowe dla szczególnych typów publikacji, które reprezentują one.</span><span class="sxs-lookup"><span data-stu-id="a7c56-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="a7c56-219">Jak daleko w celu rozszerzenia swojej hierarchii klas.</span><span class="sxs-lookup"><span data-stu-id="a7c56-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="a7c56-220">Czy chcesz tworzyć hierarchii co najmniej trzech klas, a nie po prostu klasę bazową i jeden lub więcej klas pochodnych?</span><span class="sxs-lookup"><span data-stu-id="a7c56-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="a7c56-221">Na przykład `Publication` może być klasą bazową dla `Periodical`, który z kolei jest klasą bazową dla `Magazine`, `Journal` i `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="a7c56-222">Dla przykładu, użyjesz hierarchii małych `Publication` klasy i jednej klasy pochodnej `Book`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="a7c56-223">Można łatwo rozszerzyć przykładu tak, aby utworzyć kilka dodatkowych klas, które wynikają z `Publication`, takich jak `Magazine` i `Article`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-223">You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="a7c56-224">Czy warto utworzyć wystąpienia klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="a7c56-225">Jeśli nie, należy zastosować [abstrakcyjne](../language-reference/keywords/abstract.md) — słowo kluczowe do klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="a7c56-226">W przeciwnym razie swoje `Publication` klasy mogą być utworzone przez wywołanie metody jej konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="a7c56-227">Jeśli do utworzenia wystąpienia klasy oznaczone zostanie podjęta próba `abstract` — słowo kluczowe przez bezpośrednie wywołanie do jej konstruktora klasy, kompilator języka C# generuje błąd CS0144, "Nie można utworzyć wystąpienia abstrakcyjnej klasy lub interfejsu."</span><span class="sxs-lookup"><span data-stu-id="a7c56-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="a7c56-228">Jeśli zostanie podjęta próba, aby utworzyć wystąpienie klasy przy użyciu odbicia, metoda zgłasza wyjątek odbicia <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="a7c56-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="a7c56-229">Domyślnie klasę bazową mogą być utworzone przez wywołanie metody jej konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="a7c56-230">Nie masz definiuje jawnie konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="a7c56-231">Jeżeli nie są dostępne w kodzie źródłowym klasy bazowej, kompilator języka C# automatycznie zapewnia domyślnego (bezparametrowego) konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a7c56-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="a7c56-232">Dla przykładu, będzie można oznaczyć `Publication` klasy [abstrakcyjne](../language-reference/keywords/abstract.md) tak, aby nie można utworzyć wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a7c56-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="a7c56-233">`abstract` Klasy bez `abstract` metody oznacza, że ta klasa reprezentuje pojęcie abstrakcyjne, jest współużytkowana przez kilka konkretnych klas (takich jak `Book`, `Journal`).</span><span class="sxs-lookup"><span data-stu-id="a7c56-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="a7c56-234">Czy pochodne musi dziedziczyć z implementacji klasy podstawowej, określonych elementów członkowskich, czy mają możliwość zastąpienia implementacji klasy podstawowej lub czy musi dostarczyć implementację.</span><span class="sxs-lookup"><span data-stu-id="a7c56-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="a7c56-235">Możesz użyć [abstrakcyjne](../language-reference/keywords/abstract.md) słowo kluczowe, aby wymusić na klasach pochodnych, aby zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="a7c56-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="a7c56-236">Możesz użyć [wirtualnego](../language-reference/keywords/virtual.md) — słowo kluczowe, aby zezwolić na zastąpienie metody klasy podstawowej w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="a7c56-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="a7c56-237">Domyślnie są metody zdefiniowane w klasie bazowej *nie* możliwym do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="a7c56-237">By default, methods defined in the base class are *not* overridable.</span></span>

 <span data-ttu-id="a7c56-238">`Publication` Klasa nie ma żadnych `abstract` metody, ale sama klasa `abstract`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="a7c56-239">Czy klasę pochodną reprezentuje ostatnią klasę w hierarchii dziedziczenia, a nie sam można użyć jako klasę bazową dla dodatkowych klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="a7c56-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="a7c56-240">Domyślnie każda klasa może służyć jako klasę bazową.</span><span class="sxs-lookup"><span data-stu-id="a7c56-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="a7c56-241">Można zastosować [zapieczętowanego](../language-reference/keywords/sealed.md) — słowo kluczowe, aby wskazać, że klasa nie może służyć jako klasę bazową dla wszelkich dodatkowych zajęć.</span><span class="sxs-lookup"><span data-stu-id="a7c56-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="a7c56-242">Podjęto próbę pochodzi od klasy zapieczętowanej generowany błąd kompilatora CS0509, "nie może pochodzić od typu zapieczętowanego \<typeName >".</span><span class="sxs-lookup"><span data-stu-id="a7c56-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="a7c56-243">Dla przykładu, możesz oznaczyć klasy pochodnej jako `sealed`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="a7c56-244">Poniższy kod przedstawia kod źródłowy `Publication` klasy, a także `PublicationType` wyliczenie, który jest zwracany przez `Publication.PublicationType` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="a7c56-245">Oprócz elementów członkowskich, które dziedziczy <xref:System.Object>, `Publication` klasa definiuje następujące unikatowych elementów członkowskich i element członkowski zastępuje element:</span><span class="sxs-lookup"><span data-stu-id="a7c56-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="a7c56-246">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="a7c56-246">A constructor</span></span>

  <span data-ttu-id="a7c56-247">Ponieważ `Publication` klasa jest `abstract`, nie można utworzyć wystąpienia bezpośrednio z kodu, jak w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="a7c56-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="a7c56-248">Jednak jego konstruktora wystąpienia mogą być wywoływane bezpośrednio z konstruktorami klasy pochodnej, jako kod źródłowy `Book` klasy pokazuje.</span><span class="sxs-lookup"><span data-stu-id="a7c56-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="a7c56-249">Dwie właściwości związane z publikacji</span><span class="sxs-lookup"><span data-stu-id="a7c56-249">Two publication-related properties</span></span>

  <span data-ttu-id="a7c56-250">`Title` jest tylko do odczytu <xref:System.String> właściwość, której wartość jest dostarczana przez wywołanie `Publication` konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a7c56-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="a7c56-251">`Pages` jest do odczytu i zapisu <xref:System.Int32> ma właściwość, która wskazuje, ile łącznie strony publikacji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="a7c56-252">Wartość jest przechowywana w polu prywatnej o nazwie `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="a7c56-253">Musi być liczbą dodatnią lub <xref:System.ArgumentOutOfRangeException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="a7c56-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="a7c56-254">Składowe związane z wydawcy</span><span class="sxs-lookup"><span data-stu-id="a7c56-254">Publisher-related members</span></span>

  <span data-ttu-id="a7c56-255">Dwie właściwości tylko do odczytu, `Publisher` i `Type`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="a7c56-256">Wartości pierwotnie są dostarczane przez wywołanie metody `Publication` konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="a7c56-257">Powiązane publikowania elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="a7c56-257">Publishing-related members</span></span>

  <span data-ttu-id="a7c56-258">Dwie metody `Publish` i `GetPublicationDate`, ustawianie i zwracanie dat publikacji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="a7c56-259">`Publish` Metoda ustawia prywatnej `published` flaga `true` gdy jest wywoływana i przypisuje Data przekazany jako argument do prywatnego `datePublished` pola.</span><span class="sxs-lookup"><span data-stu-id="a7c56-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="a7c56-260">`GetPublicationDate` Metoda zwraca ciąg "NYP", jeśli `published` flaga jest `false`i wartość `datePublished` pola, gdy jest `true`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="a7c56-261">Pokrewnych elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="a7c56-261">Copyright-related members</span></span>

  <span data-ttu-id="a7c56-262">`Copyright` Metoda przyjmuje jako argumenty nazwę właściciela praw autorskich i rok praw autorskich i przypisuje je do `CopyrightName` i `CopyrightDate` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="a7c56-263">Zastępowanie `ToString` — metoda</span><span class="sxs-lookup"><span data-stu-id="a7c56-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="a7c56-264">Jeśli typ nie zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody zwraca w pełni kwalifikowaną nazwę typu, który jest rzadko używane w rozróżnianie jednego wystąpienia z innego.</span><span class="sxs-lookup"><span data-stu-id="a7c56-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="a7c56-265">`Publication` Klasy zastąpienia <xref:System.Object.ToString%2A?displayProperty=nameWithType> do zwracania wartości `Title` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="a7c56-266">Na poniższym rysunku przedstawiono relację między podstawowym `Publication` klasy i jego niejawnie dziedziczenia <xref:System.Object> klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Klasy obiektu i publikacji](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="a7c56-268">`Book` Klasy</span><span class="sxs-lookup"><span data-stu-id="a7c56-268">The `Book` class</span></span>

<span data-ttu-id="a7c56-269">`Book` Klasa reprezentuje książki jako wyspecjalizowane typ publikacji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="a7c56-270">Poniższy przykład pokazuje kod źródłowy `Book` klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="a7c56-271">Oprócz elementów członkowskich, które dziedziczy `Publication`, `Book` klasa definiuje następujące unikatowych elementów członkowskich i element członkowski zastępuje element:</span><span class="sxs-lookup"><span data-stu-id="a7c56-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="a7c56-272">Dwa konstruktory</span><span class="sxs-lookup"><span data-stu-id="a7c56-272">Two constructors</span></span>

  <span data-ttu-id="a7c56-273">Dwa `Book` konstruktory udostępnianie trzech typowych parametrów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="a7c56-274">Dwa *tytuł* i *wydawcy*, odpowiadać parametrom `Publication` konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a7c56-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="a7c56-275">Trzecia będzie *Autor*, który jest przechowywany na wartość publiczne, które są niezmienne `Author` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="a7c56-276">Zawiera jeden konstruktor *isbn* parametr, który jest przechowywany w `ISBN` właściwości automatycznej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="a7c56-277">Pierwszy Konstruktor używa [to](../language-reference/keywords/this.md) — słowo kluczowe do wywoływania innego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a7c56-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="a7c56-278">Tworzenie łańcuchów Konstruktor jest typowym definiować konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="a7c56-279">Konstruktorów z parametrami mniej udostępni wartości domyślne podczas wywoływania konstruktora z największą liczbą parametrów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="a7c56-280">Drugi Konstruktor używa [podstawowy](../language-reference/keywords/base.md) — słowo kluczowe do przekazania nazwy stanowiska i wydawcy do konstruktora klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="a7c56-281">Jeśli nie dokonasz jawnym wywołaniem konstruktora klasy bazowej, w kodzie źródłowym, kompilator języka C# automatycznie dostarczy wywołanie klasy bazowej domyślnego lub konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="a7c56-282">Tylko do odczytu `ISBN` właściwość, która zwraca `Book` International Standard książki numer obiektu, unikatowe 10 - lub 13-cyfrowy numer.</span><span class="sxs-lookup"><span data-stu-id="a7c56-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="a7c56-283">ISBN jest dostarczany jako argument do jednego z `Book` konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="a7c56-284">ISBN są przechowywane w polem zapasowym prywatnego, który został wygenerowany automatycznie przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="a7c56-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="a7c56-285">Tylko do odczytu `Author` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-285">A read-only `Author` property.</span></span> <span data-ttu-id="a7c56-286">Imię i nazwisko autora jest dostarczany jako argument do obu `Book` konstruktorów i jest przechowywany we właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="a7c56-287">Dwie właściwości tylko do odczytu dotyczące cen, `Price` i `Currency`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="a7c56-288">Ich wartości są przekazywane jako argumenty `SetPrice` wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="a7c56-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="a7c56-289">`Currency` Właściwość jest symbol waluty ISO trzycyfrowy (na przykład USD za dolar amerykański).</span><span class="sxs-lookup"><span data-stu-id="a7c56-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="a7c56-290">Symbole waluty ISO można pobrać z <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="a7c56-291">Obie te właściwości są zewnętrznie tylko do odczytu, ale można ustawić zarówno przez kod w `Book` klasy.</span><span class="sxs-lookup"><span data-stu-id="a7c56-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="a7c56-292">A `SetPrice` metody, która ustawia wartości `Price` i `Currency` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="a7c56-293">Te wartości są zwracane przez te same właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="a7c56-294">Zastąpienia `ToString` — metoda (odziedziczone `Publication`) i <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> i <xref:System.Object.GetHashCode%2A> metody (odziedziczone <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="a7c56-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="a7c56-295">O ile nie zostanie on przesłonięty <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody testów dla równości odwołań.</span><span class="sxs-lookup"><span data-stu-id="a7c56-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="a7c56-296">Oznacza to, że dwie zmienne do obiektu są traktowane jako równe, jeżeli odnoszą się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="a7c56-297">W `Book` klasy, z drugiej strony dwa `Book` obiekty powinny być równe, jeśli mają one ten sam ISBN.</span><span class="sxs-lookup"><span data-stu-id="a7c56-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="a7c56-298">Gdy zastąpisz <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody, konieczne jest również przesłonięcie <xref:System.Object.GetHashCode%2A> metody, która zwraca wartość, która na podstawie środowisko uruchomieniowe do przechowywania elementów w kolekcji skrótu dla efektywne pobieranie.</span><span class="sxs-lookup"><span data-stu-id="a7c56-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="a7c56-299">Wartość skrótu powinien zwrócić wartość, która jest zgodna z testem pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="a7c56-300">Ponieważ została zastąpiona <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> do zwrócenia `true` Jeśli właściwości ISBN dwóch `Book` obiekty są równe, zwraca wartość skrótu obliczane przez wywołanie metody <xref:System.String.GetHashCode%2A> ciąg zwracany przez metodę `ISBN` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="a7c56-301">Na poniższym rysunku przedstawiono relację między `Book` klasy i `Publication`, jej klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Klasy publikacji i książki](media/book-class.jpg)

<span data-ttu-id="a7c56-303">Teraz można utworzyć wystąpienie `Book` obiektu, wywołaj jego unikatowy i dziedziczonych członków i przekazać go jako argument do metody, która oczekuje, że parametr typu `Publication` lub typu `Book`, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a7c56-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="a7c56-304">Projektowanie abstrakcyjnych klas bazowych i ich klasy pochodne</span><span class="sxs-lookup"><span data-stu-id="a7c56-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="a7c56-305">W poprzednim przykładzie zdefiniowano klasę bazową, przewidzianego implementację na wiele sposobów, aby umożliwić udostępnianie kodu w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="a7c56-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="a7c56-306">W wielu przypadkach jednak klasa bazowa nie powinien zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="a7c56-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="a7c56-307">Klasa bazowa jest *abstrakcyjna klasa* oświadcza, że *metody abstrakcyjne*; służy jako szablon, który definiuje składowe każdej klasy pochodnej musi implementować.</span><span class="sxs-lookup"><span data-stu-id="a7c56-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="a7c56-308">Zazwyczaj w abstrakcyjna klasa bazowa implementacji każdego typu pochodnego jest unikatowa dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="a7c56-309">Oznaczyć klasę za pomocą abstract — słowo kluczowe, ponieważ ona żadnego znaczenia, aby utworzyć wystąpienie `Publication` obiektu, chociaż klasa dostarczył implementacji funkcji, które są wspólne dla publikacji.</span><span class="sxs-lookup"><span data-stu-id="a7c56-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="a7c56-310">Na przykład każdego zamknięty kształt geometryczny dwuwymiarową zawiera dwie właściwości: obszar, wewnętrzny zakres kształtu; i obwodowej lub odległości wzdłuż krawędzi kształtu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="a7c56-311">Sposób, w którym te właściwości są obliczane, jednak zależy od całkowicie określonego kształtu.</span><span class="sxs-lookup"><span data-stu-id="a7c56-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="a7c56-312">Obliczanie obwodowej (lub obwodu) koło, na przykład różni się od, trójkąt.</span><span class="sxs-lookup"><span data-stu-id="a7c56-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="a7c56-313">`Shape` Klasa jest `abstract` klasy `abstract` metody.</span><span class="sxs-lookup"><span data-stu-id="a7c56-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="a7c56-314">Wskazująca klasy pochodne udostępnić taką samą funkcjonalność, ale te klasy pochodne zaimplementować tę funkcję inaczej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="a7c56-315">W poniższym przykładzie zdefiniowano abstrakcyjna klasa bazowa o nazwie `Shape` definiuje dwie właściwości: `Area` i `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="a7c56-316">Oprócz oznakowania klasy za pomocą [abstrakcyjne](../language-reference/keywords/abstract.md) — słowo kluczowe, każdy członek wystąpienia również jest oznaczona za pomocą [abstrakcyjne](../language-reference/keywords/abstract.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="a7c56-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="a7c56-317">W tym przypadku `Shape` zastępuje również <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby zwrócić nazwę typu, a nie jego w pełni kwalifikowana nazwa.</span><span class="sxs-lookup"><span data-stu-id="a7c56-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="a7c56-318">Które definiują dwa statyczne elementy członkowskie `GetArea` i `GetPerimeter`, umożliwiające obiektom wywołującym można łatwo pobrać pole i obwód wystąpienie klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="a7c56-319">Jeśli wystąpienie klasy pochodnej do jednej z tych metod, środowisko wykonawcze wywołuje metodę zastępującą klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="a7c56-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="a7c56-320">Następnie można uzyskać niektóre klasy z `Shape` reprezentujące określonych kształtów.</span><span class="sxs-lookup"><span data-stu-id="a7c56-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="a7c56-321">Poniższy przykład definiuje trzy klasy `Triangle`, `Rectangle`, i `Circle`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="a7c56-322">Każda używa formuły, które są unikatowe dla tego konkretnego kształtu do obliczenia pole i obwód.</span><span class="sxs-lookup"><span data-stu-id="a7c56-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="a7c56-323">Niektóre z klas pochodnych również zdefiniować właściwości, takie jak `Rectangle.Diagonal` i `Circle.Diameter`, które są unikatowe dla kształtu, które reprezentują one.</span><span class="sxs-lookup"><span data-stu-id="a7c56-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="a7c56-324">W poniższym przykładzie użyto obiektów pochodzących od `Shape`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="a7c56-325">Metoda tworzy tablicę obiektów pochodzących od `Shape` i wywołuje metody statyczne `Shape` klasy, która otacza zwrócenia `Shape` wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="a7c56-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="a7c56-326">Środowisko uruchomieniowe pobiera wartości z właściwości zgodnym z przesłoniętą typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="a7c56-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="a7c56-327">Przykład również każdej rzutuje `Shape` obiektów w tablicy, do jego typ pochodny i, jeśli rzutowanie zakończy się powodzeniem, pobiera właściwości tego konkretnego podklasą `Shape`.</span><span class="sxs-lookup"><span data-stu-id="a7c56-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="a7c56-328">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a7c56-328">See also</span></span>

- [<span data-ttu-id="a7c56-329">Klasy i obiekty</span><span class="sxs-lookup"><span data-stu-id="a7c56-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="a7c56-330">Dziedziczenie (C# Programming Guide)</span><span class="sxs-lookup"><span data-stu-id="a7c56-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
