---
title: Generowanie i korzystanie ze strumieni asynchronicznego
description: Ten zaawansowany samouczek ilustruje scenariusze, w których generowanie i używanie strumieni asynchronicznych zapewnia bardziej naturalny sposób pracy z sekwencjami danych, które mogą być generowane asynchronicznie.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: de090eb9cc1e8b511956313ab5169ee4d07a492f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156743"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="fe0fc-103">Samouczek: Generowanie i używanie strumieni asynchronicznyprzy użyciu plików C# 8.0 i .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="fe0fc-103">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="fe0fc-104">C# 8.0 wprowadza **strumienia asynchronicznego**, które modelują źródło przesyłania strumieniowego danych, gdy elementy w strumieniu danych mogą być pobierane lub generowane asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-104">C# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously.</span></span> <span data-ttu-id="fe0fc-105">Strumienie asynchroniczne opierają się na nowych interfejsach wprowadzonych w programie .NET Standard 2.1 i zaimplementowanych w programie .NET Core 3.0 w celu zapewnienia naturalnego modelu programowania dla asynchronicznych źródeł danych strumieniowych.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-105">Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="fe0fc-106">Ten samouczek zawiera informacje na temat wykonywania następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="fe0fc-107">Utwórz źródło danych, które generuje sekwencję elementów danych asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-107">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="fe0fc-108">Użyj tego źródła danych asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-108">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="fe0fc-109">Rozpoznaj, kiedy nowy interfejs i źródło danych są preferowane do wcześniejszych synchronicznych sekwencji danych.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-109">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="fe0fc-110">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="fe0fc-110">Prerequisites</span></span>

<span data-ttu-id="fe0fc-111">Musisz skonfigurować komputer do uruchamiania .NET Core, w tym kompilator C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-111">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="fe0fc-112">Kompilator C# 8 jest dostępny począwszy od [programu Visual Studio 2019 w wersji 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) lub [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="fe0fc-112">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="fe0fc-113">Musisz utworzyć [token dostępu GitHub,](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) aby uzyskać dostęp do punktu końcowego GitHub GraphQL.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-113">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="fe0fc-114">Wybierz następujące uprawnienia tokenu dostępu usługi GitHub:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-114">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="fe0fc-115">repo:stan</span><span class="sxs-lookup"><span data-stu-id="fe0fc-115">repo:status</span></span>
- <span data-ttu-id="fe0fc-116">public_repo</span><span class="sxs-lookup"><span data-stu-id="fe0fc-116">public_repo</span></span>

<span data-ttu-id="fe0fc-117">Zapisz token dostępu w bezpiecznym miejscu, dzięki czemu można go użyć, aby uzyskać dostęp do punktu końcowego interfejsu API usługi GitHub.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-117">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="fe0fc-118">Zabezpiecz swój osobisty token dostępu.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-118">Keep your personal access token secure.</span></span> <span data-ttu-id="fe0fc-119">Każde oprogramowanie z osobistym tokenem dostępu może sprawić, że wywołania interfejsu API usługi GitHub przy użyciu praw dostępu.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-119">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="fe0fc-120">W tym samouczku przyjęto założenie, że znasz c# i .NET, w tym visual studio lub .NET Core CLI.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-120">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="fe0fc-121">Uruchamianie aplikacji startowej</span><span class="sxs-lookup"><span data-stu-id="fe0fc-121">Run the starter application</span></span>

<span data-ttu-id="fe0fc-122">Możesz uzyskać kod dla aplikacji startowej używanej w tym samouczku z naszego repozytorium [dotnet/samples](https://github.com/dotnet/samples) w folderze [csharp/tutorials/AsyncStreams.](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start)</span><span class="sxs-lookup"><span data-stu-id="fe0fc-122">You can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder.</span></span>

<span data-ttu-id="fe0fc-123">Aplikacja startowa to aplikacja konsolowa, która używa interfejsu [GitHub GraphQL](https://developer.github.com/v4/) do pobierania ostatnich problemów zapisanych w repozytorium [dotnet/docs.](https://github.com/dotnet/docs)</span><span class="sxs-lookup"><span data-stu-id="fe0fc-123">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="fe0fc-124">Zacznij od spokozić `Main` następujący kod dla metody aplikacji początkowej:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-124">Start by looking at the following code for the starter app `Main` method:</span></span>

[!code-csharp[StarterAppMain](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#StarterAppMain)]

<span data-ttu-id="fe0fc-125">Można ustawić zmienną środowiskową `GitHubKey` na token dostępu osobistego lub zastąpić ostatni `GenEnvVariable` argument w wywołaniu tokenem dostępu osobistego.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-125">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="fe0fc-126">Nie umieszczaj kodu dostępu w kodzie źródłowym, jeśli będziesz zapisywać źródło z innymi osobami lub umieszczać go w udostępnionym repozytorium źródłowym.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-126">Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.</span></span>

<span data-ttu-id="fe0fc-127">Po utworzeniu klienta GitHub, `Main` kod w tworzy obiekt raportowania postępu i token anulowania.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-127">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="fe0fc-128">Po utworzeniu tych `Main` obiektów `runPagedQueryAsync` wywołania w celu pobrania ostatnich 250 utworzonych problemów.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-128">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="fe0fc-129">Po zakończeniu tego zadania zostaną wyświetlone wyniki.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-129">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="fe0fc-130">Po uruchomieniu aplikacji startowej, można dokonać pewnych ważnych uwag na temat sposobu działania tej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-130">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="fe0fc-131">Zobaczysz postęp zgłoszony dla każdej strony zwróconej z Usługi GitHub.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-131">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="fe0fc-132">Można zaobserwować zauważalną pauzę, zanim gitHub zwróci każdą nową stronę problemów.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-132">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="fe0fc-133">Na koniec problemy są wyświetlane dopiero po pobraniu wszystkich 10 stron z usługi GitHub.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-133">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="fe0fc-134">Zbadaj wdrażanie</span><span class="sxs-lookup"><span data-stu-id="fe0fc-134">Examine the implementation</span></span>

<span data-ttu-id="fe0fc-135">Implementacja ujawnia, dlaczego zaobserwowałeś zachowanie omówione w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-135">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="fe0fc-136">Sprawdź kod `runPagedQueryAsync`pod kątem:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-136">Examine the code for `runPagedQueryAsync`:</span></span>

[!code-csharp[RunPagedQueryStarter](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#RunPagedQuery)]

<span data-ttu-id="fe0fc-137">Skoncentrujmy się na algorytmstronicowania i struktury asynchronicznej poprzedniego kodu.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-137">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="fe0fc-138">(Szczegółowe informacje na temat interfejsu API Programu GitHub GraphQL można znaleźć w [dokumentacji programu GitHub GraphQL).](https://developer.github.com/v4/guides/) Metoda `runPagedQueryAsync` wylicza problemy od najnowszych do najstarszych.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-138">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="fe0fc-139">Żąda 25 problemów na stronie `pageInfo` i analizuje strukturę odpowiedzi, aby kontynuować na poprzedniej stronie.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-139">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="fe0fc-140">Wynika to ze standardowej obsługi stronicowania graphql dla odpowiedzi wielostronicowych.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-140">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="fe0fc-141">Odpowiedź zawiera `pageInfo` obiekt, który `hasPreviousPages` zawiera `startCursor` wartość i wartość używaną do żądania poprzedniej strony.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-141">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="fe0fc-142">Problemy są w `nodes` tablicy.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-142">The issues are in the `nodes` array.</span></span> <span data-ttu-id="fe0fc-143">Metoda `runPagedQueryAsync` dołącza te węzły do tablicy, która zawiera wszystkie wyniki ze wszystkich stron.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-143">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="fe0fc-144">Po pobraniu i przywróceniu `runPagedQueryAsync` strony wyników raportuje postęp i sprawdza anulowanie.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-144">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="fe0fc-145">Jeśli zażądano anulowania, `runPagedQueryAsync` zgłasza <xref:System.OperationCanceledException>plik .</span><span class="sxs-lookup"><span data-stu-id="fe0fc-145">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="fe0fc-146">Istnieje kilka elementów w tym kodzie, które można poprawić.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-146">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="fe0fc-147">Co najważniejsze, `runPagedQueryAsync` należy przydzielić magazyn dla wszystkich zwróconych problemów.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-147">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="fe0fc-148">W tym przykładzie zatrzymuje się na 250 problemów, ponieważ pobieranie wszystkich otwartych problemów wymagałoby znacznie więcej pamięci do przechowywania wszystkich pobranych problemów.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-148">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="fe0fc-149">Ponadto protokoły dotyczące obsługi postępu i obsługi anulowania sprawiają, że algorytm jest trudniejszy do zrozumienia podczas pierwszego czytania.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-149">In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="fe0fc-150">Należy wyszukać klasę postępu, aby znaleźć, gdzie jest raportowany postęp.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-150">You must look for the progress class to find where progress is reported.</span></span> <span data-ttu-id="fe0fc-151">Należy również prześledzić komunikacji <xref:System.Threading.CancellationTokenSource> za pośrednictwem i skojarzonych z <xref:System.Threading.CancellationToken> nią, aby zrozumieć, gdzie wymagane jest anulowanie i gdzie jest to przyznane.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-151">You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="fe0fc-152">Strumienie Async zapewniają lepszy sposób</span><span class="sxs-lookup"><span data-stu-id="fe0fc-152">Async streams provide a better way</span></span>

<span data-ttu-id="fe0fc-153">Strumienie asynchroniczne i obsługa skojarzonego języka rozwiązają wszystkie te problemy.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-153">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="fe0fc-154">Kod, który generuje sekwencję `yield return` można teraz użyć do zwrócenia `async` elementów w metodzie, która została zadeklarowana za pomocą modyfikatora.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-154">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="fe0fc-155">Można użyć strumienia asynchronicznego przy użyciu `await foreach` pętli, `foreach` tak jak zużywają dowolną sekwencję przy użyciu pętli.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-155">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="fe0fc-156">Te nowe funkcje języka zależą od trzech nowych interfejsów dodanych do .NET Standard 2.1 i zaimplementowanych w .NET Core 3.0:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-156">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        T Current { get; }

        ValueTask<bool> MoveNextAsync();
    }
}

namespace System
{
    public interface IAsyncDisposable
    {
        ValueTask DisposeAsync();
    }
}
```

<span data-ttu-id="fe0fc-157">Te trzy interfejsy powinny być znane większości deweloperów języka C#.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-157">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="fe0fc-158">Zachowują się w sposób podobny do ich synchronicznych odpowiedników:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-158">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="fe0fc-159">Jeden typ, który może <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>być nieznany jest .</span><span class="sxs-lookup"><span data-stu-id="fe0fc-159">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fe0fc-160">Struktura `ValueTask` zapewnia podobny interfejs API <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> do klasy.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-160">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="fe0fc-161">`ValueTask`jest używany w tych interfejsach ze względu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-161">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="fe0fc-162">Konwertowanie na strumienie asynchroniczne</span><span class="sxs-lookup"><span data-stu-id="fe0fc-162">Convert to async streams</span></span>

<span data-ttu-id="fe0fc-163">Następnie przekonwertuj `runPagedQueryAsync` metodę, aby wygenerować strumień asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-163">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="fe0fc-164">Najpierw zmień `runPagedQueryAsync` `IAsyncEnumerable<JToken>`podpis, aby zwrócić , i usunąć token anulowania i obiektów postępu z listy parametrów, jak pokazano w następującym kodzie:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-164">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

[!code-csharp[FinishedSignature](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#UpdateSignature)]

<span data-ttu-id="fe0fc-165">Kod początkowy przetwarza każdą stronę podczas pobierania strony, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-165">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

[!code-csharp[StarterPaging](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#ProcessPage)]

<span data-ttu-id="fe0fc-166">Zastąp te trzy wiersze następującym kodem:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-166">Replace those three lines with the following code:</span></span>

[!code-csharp[FinishedPaging](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#YieldReturnPage)]

<span data-ttu-id="fe0fc-167">Można również usunąć deklarację `finalResults` wcześniej w tej `return` metodzie i instrukcji, która następuje po pętli, który został zmodyfikowany.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-167">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="fe0fc-168">Zmiany zostały zakończone w celu wygenerowania strumienia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-168">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="fe0fc-169">Metoda gotowapowinna przypominać poniższy kod:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-169">The finished method should resemble the code below:</span></span>

[!code-csharp[FinishedGenerate](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#GenerateAsyncStream)]

<span data-ttu-id="fe0fc-170">Następnie należy zmienić kod, który używa kolekcji do używania strumienia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-170">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="fe0fc-171">Znajdź następujący kod `Main` w tym, który przetwarza kolekcję problemów:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-171">Find the following code in `Main` that processes the collection of issues:</span></span>

[!code-csharp[EnumerateOldStyle](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#EnumerateOldStyle)]

<span data-ttu-id="fe0fc-172">Zastąp ten `await foreach` kod następującą pętlą:</span><span class="sxs-lookup"><span data-stu-id="fe0fc-172">Replace that code with the following `await foreach` loop:</span></span>

[!code-csharp[FinishedEnumerateAsyncStream](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#EnumerateAsyncStream)]

<span data-ttu-id="fe0fc-173">Domyślnie elementy strumienia są przetwarzane w kontekście przechwyconego.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-173">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="fe0fc-174">Jeśli chcesz wyłączyć przechwytywanie kontekstu, należy użyć metody <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-174">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="fe0fc-175">Aby uzyskać więcej informacji na temat kontekstów synchronizacji i przechwytywania bieżącego kontekstu, zobacz artykuł na [temat korzystania z wzorca asynchronicznego opartego](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)na zadaniu .</span><span class="sxs-lookup"><span data-stu-id="fe0fc-175">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="fe0fc-176">Kod gotowego samouczka można uzyskać z repozytorium [dotnet/samples](https://github.com/dotnet/samples) w folderze [csharp/tutorials/AsyncStreams.](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished)</span><span class="sxs-lookup"><span data-stu-id="fe0fc-176">You can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="fe0fc-177">Uruchamianie gotowej aplikacji</span><span class="sxs-lookup"><span data-stu-id="fe0fc-177">Run the finished application</span></span>

<span data-ttu-id="fe0fc-178">Uruchom ponownie aplikację.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-178">Run the application again.</span></span> <span data-ttu-id="fe0fc-179">Kontrast jego zachowanie z zachowaniem aplikacji starter.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-179">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="fe0fc-180">Pierwsza strona wyników jest wyliczana, gdy tylko będzie dostępna.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-180">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="fe0fc-181">Istnieje obserwowana pauza, ponieważ każda nowa strona jest żądana i pobierana, a następnie wyniki następnej strony są szybko wyliczane.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-181">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="fe0fc-182">`try`  /  Blok `catch` nie jest potrzebny do obsługi anulowania: obiekt wywołujący może przestać wyliczania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-182">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="fe0fc-183">Postęp jest wyraźnie zgłaszane, ponieważ strumień asynchronii generuje wyniki, jak każda strona jest pobierana.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-183">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="fe0fc-184">Stan dla każdego zwróconego problemu jest `await foreach` bezproblemowo uwzględniany w pętli.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-184">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="fe0fc-185">Do śledzenia postępów nie jest potrzebny obiekt wywołania oddzwonić.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-185">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="fe0fc-186">Można zobaczyć ulepszenia w użyciu pamięci, sprawdzając kod.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-186">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="fe0fc-187">Nie trzeba już przydzielić kolekcji do przechowywania wszystkich wyników, zanim zostaną one wyliczone.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-187">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="fe0fc-188">Obiekt wywołujący można określić, jak korzystać z wyników i jeśli kolekcja magazynu jest potrzebna.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-188">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="fe0fc-189">Uruchom zarówno starter i gotowe aplikacje i można obserwować różnice między implementacjami dla siebie.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-189">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="fe0fc-190">Możesz usunąć token dostępu GitHub utworzony po uruchomieniu tego samouczka po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-190">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="fe0fc-191">Jeśli osoba atakująca uzyskała dostęp do tego tokenu, może uzyskać dostęp do interfejsów API usługi GitHub przy użyciu poświadczeń.</span><span class="sxs-lookup"><span data-stu-id="fe0fc-191">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
