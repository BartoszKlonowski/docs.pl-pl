---
title: Generowanie i używanie strumieni asynchronicznych
description: W tym samouczku zaawansowane przedstawiono scenariusze, w którym generowania i używania strumieni asynchronicznych zapewnia bardziej naturalny sposób pracy z sekwencje danych, które mogą być generowane w sposób asynchroniczny.
ms.date: 02/10/2019
ms.custom: mvc
ms.openlocfilehash: c8be9cf4b83e3dd72232279e7c15dcba639c2058
ms.sourcegitcommit: bef803e2025642df39f2f1e046767d89031e0304
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/15/2019
ms.locfileid: "56306016"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="9b04f-103">Samouczek: Generowanie i używanie strumieni asynchronicznych za pomocą C# 8.0 i .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="9b04f-103">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="9b04f-104">C#wprowadza 8.0 **strumieni asynchronicznych**, który modelu przesyłania strumieniowego źródła danych, gdy elementy w strumieniu danych, które mogą być pobierane lub generowane asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="9b04f-104">C# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously.</span></span> <span data-ttu-id="9b04f-105">Asynchroniczne strumienie polegają na nowe interfejsy wprowadzone w programie .NET Standard 2.1 i wdrażane w środowisku .NET Core 3.0 zapewnienie naturalnych modelu programowania asynchronicznego przesyłania strumieniowego źródła danych.</span><span class="sxs-lookup"><span data-stu-id="9b04f-105">Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="9b04f-106">W tym samouczku dowiesz się, jak:</span><span class="sxs-lookup"><span data-stu-id="9b04f-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
> * <span data-ttu-id="9b04f-107">Utwórz źródło danych, która generuje sekwencję elementów danych asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="9b04f-107">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> * <span data-ttu-id="9b04f-108">Asynchronicznie korzystać z tego źródła danych.</span><span class="sxs-lookup"><span data-stu-id="9b04f-108">Consume that data source asynchronously.</span></span>
> * <span data-ttu-id="9b04f-109">Rozpoznaje, gdy nowy interfejs i źródła danych są preferowane wcześniej synchronicznej danych sekwencji.</span><span class="sxs-lookup"><span data-stu-id="9b04f-109">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="9b04f-110">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="9b04f-110">Prerequisites</span></span>

<span data-ttu-id="9b04f-111">Należy skonfigurować komputer do uruchamiania platformę .NET Core, w tym C# kompilatora 8.0 beta.</span><span class="sxs-lookup"><span data-stu-id="9b04f-111">You’ll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler.</span></span> <span data-ttu-id="9b04f-112">C# 8 kompilatora w wersji beta jest dostępna, począwszy od [2019 usługi Visual Studio w wersji zapoznawczej 1](https://visualstudio.microsoft.com/vs/preview/), lub [1 — zestaw SDK platformy .NET Core 3.0 w wersji zapoznawczej](https://dotnet.microsoft.com/download/dotnet-core/3.0).</span><span class="sxs-lookup"><span data-stu-id="9b04f-112">The C# 8 beta compiler is available starting with [Visual Studio 2019 preview 1](https://visualstudio.microsoft.com/vs/preview/), or [.NET Core 3.0 preview 1 SDK](https://dotnet.microsoft.com/download/dotnet-core/3.0).</span></span> <span data-ttu-id="9b04f-113">Asynchroniczne strumienie najpierw są dostępne w wersji zapoznawczej platformy .NET Core 3.0 to 1.</span><span class="sxs-lookup"><span data-stu-id="9b04f-113">Async streams are first available in .NET Core 3.0 preview 1.</span></span>

<span data-ttu-id="9b04f-114">Musisz utworzyć [token dostępu GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) tak, aby mogli punktu końcowego usługi GitHub GraphQL.</span><span class="sxs-lookup"><span data-stu-id="9b04f-114">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="9b04f-115">Wybierz następujące uprawnienia dla Twojego tokenu dostępu usługi GitHub:</span><span class="sxs-lookup"><span data-stu-id="9b04f-115">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="9b04f-116">repozytorium: stan</span><span class="sxs-lookup"><span data-stu-id="9b04f-116">repo:status</span></span>
- <span data-ttu-id="9b04f-117">public_repo</span><span class="sxs-lookup"><span data-stu-id="9b04f-117">public_repo</span></span>

<span data-ttu-id="9b04f-118">Token dostępu należy zapisać w bezpiecznym miejscu, aby można było używać do uzyskania dostępu do punktu końcowego interfejsu API usługi GitHub.</span><span class="sxs-lookup"><span data-stu-id="9b04f-118">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="9b04f-119">Bezpieczeństwo Twój osobisty token dostępu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-119">Keep your personal access token secure.</span></span> <span data-ttu-id="9b04f-120">Wszelkie oprogramowanie za pomocą Twój osobisty token dostępu zapytała wywołań interfejsu API usługi GitHub przy użyciu Twoich praw dostępu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-120">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="9b04f-121">W tym samouczku założono, kiedy znasz już C# i .NET, w tym Visual Studio lub interfejsu wiersza polecenia platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="9b04f-121">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="9b04f-122">Uruchom aplikację modułu uruchamiającego</span><span class="sxs-lookup"><span data-stu-id="9b04f-122">Run the starter application</span></span>

<span data-ttu-id="9b04f-123">Możesz też uzyskać kod aplikacji starter używanych w tym samouczku z naszych [dotnet/samples](https://github.com/dotnet/samples) repozytorium w [AsyncStreams-csharp/samouczki](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folderu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-123">You can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder.</span></span>

<span data-ttu-id="9b04f-124">Aplikacja startowa jest aplikacja konsolowa która używa [GitHub GraphQL](https://developer.github.com/v4/) interfejsu, aby pobrać najnowsze problemy, które napisana [dotnet/docs](https://github.com/dotnet/docs) repozytorium.</span><span class="sxs-lookup"><span data-stu-id="9b04f-124">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="9b04f-125">Zacznij od przejrzenia następujący kod dla aplikację startową `Main` metody:</span><span class="sxs-lookup"><span data-stu-id="9b04f-125">Start by looking at the following code for the starter app `Main` method:</span></span>

[!code-csharp[StarterAppMain](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#StarterAppMain)]

<span data-ttu-id="9b04f-126">Możesz albo zestaw `GitHubKey` zmiennej środowiskowej, aby Twój osobisty token dostępu, lub można zastąpić ostatni argument w wywołaniu `GenEnvVariable` z Twój osobisty token dostępu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-126">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="9b04f-127">Nie umieszczaj kod dostępu w kodzie źródłowym, będzie można zapisać źródła, czy umieszczenie go w repozytorium źródłowy udostępniony.</span><span class="sxs-lookup"><span data-stu-id="9b04f-127">Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.</span></span>

<span data-ttu-id="9b04f-128">Po utworzeniu klienta usługi GitHub, kod w `Main` tworzy postępu raportowania obiektu i token anulowania.</span><span class="sxs-lookup"><span data-stu-id="9b04f-128">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="9b04f-129">Po utworzeniu tych obiektów `Main` wywołania `runPagedQueryAsync` można pobrać ostatnich 250 utworzone problemów.</span><span class="sxs-lookup"><span data-stu-id="9b04f-129">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="9b04f-130">Po zakończeniu tego zadania są wyświetlane wyniki.</span><span class="sxs-lookup"><span data-stu-id="9b04f-130">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="9b04f-131">Po uruchomieniu aplikacji starter ułatwia pewne istotne obserwacje dotyczące działania tej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9b04f-131">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="9b04f-132">Zostanie wyświetlony postęp dla każdej strony zwracane z usługi GitHub.</span><span class="sxs-lookup"><span data-stu-id="9b04f-132">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="9b04f-133">GitHub zwraca każdej nowej strony problemy, które można obserwować zauważalne wstrzymania.</span><span class="sxs-lookup"><span data-stu-id="9b04f-133">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="9b04f-134">Na koniec problemy są wyświetlane tylko wtedy, gdy wszystkie strony 10 zostały pobrane z witryny GitHub.</span><span class="sxs-lookup"><span data-stu-id="9b04f-134">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="9b04f-135">Zapoznania się z implementacją</span><span class="sxs-lookup"><span data-stu-id="9b04f-135">Examine the implementation</span></span>

<span data-ttu-id="9b04f-136">Wdrożenia, co spowoduje wyświetlenie Dlaczego zaobserwowane zachowanie opisanych w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="9b04f-136">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="9b04f-137">Poszukaj w kodzie `runPagedQueryAsync`:</span><span class="sxs-lookup"><span data-stu-id="9b04f-137">Examine the code for `runPagedQueryAsync`:</span></span>

[!code-csharp[RunPagedQueryStarter](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#RunPagedQuery)]

<span data-ttu-id="9b04f-138">Umożliwia skoncentrowanie się na strukturę algorytmu i async stronicowania dla poprzedniego kodu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-138">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="9b04f-139">(Można zapoznać się [dokumentację GitHub GraphQL](https://developer.github.com/v4/guides/) szczegółowe informacje na temat interfejsu API GraphQL usługi GitHub.) `runPagedQueryAsync` Metoda wylicza problemów od najnowszych do najstarszych.</span><span class="sxs-lookup"><span data-stu-id="9b04f-139">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="9b04f-140">Żąda 25 problemy na każdej stronie i sprawdza, czy `pageInfo` struktury odpowiedzi, aby kontynuować z poprzedniej strony.</span><span class="sxs-lookup"><span data-stu-id="9b04f-140">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="9b04f-141">Następujący firmy GraphQL stronicowania pomoc techniczną standard na wiele stron odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="9b04f-141">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="9b04f-142">Odpowiedź zawiera `pageInfo` obiektu, który zawiera `hasPreviousPages` wartość i `startCursor` wartości używane do żądania na poprzedniej stronie.</span><span class="sxs-lookup"><span data-stu-id="9b04f-142">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="9b04f-143">Problemy są w `nodes` tablicy.</span><span class="sxs-lookup"><span data-stu-id="9b04f-143">The issues are in the `nodes` array.</span></span> <span data-ttu-id="9b04f-144">`runPagedQueryAsync` Metoda dołącza te węzły do tablicy, która zawiera wszystkie wyniki ze wszystkich stron.</span><span class="sxs-lookup"><span data-stu-id="9b04f-144">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="9b04f-145">Po ich pobierania i przywracanie strony wyników, `runPagedQueryAsync` zgłasza postępy pracy i sprawdza, czy anulowania.</span><span class="sxs-lookup"><span data-stu-id="9b04f-145">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="9b04f-146">Jeśli zażądano anulowania, `runPagedQueryAsync` zgłasza <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="9b04f-146">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="9b04f-147">Istnieje kilka elementów w tym kodzie, który można zwiększyć.</span><span class="sxs-lookup"><span data-stu-id="9b04f-147">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="9b04f-148">Co najważniejsze `runPagedQueryAsync` należy przydzielić magazyn dla wszystkich problemów, które są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9b04f-148">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="9b04f-149">W tym przykładzie zatrzymuje się na 250 problemy, ponieważ podczas pobierania wszystkich otwartych problemów wymaga znacznie większej ilości pamięci do przechowywania wszystkich pobrane problemów.</span><span class="sxs-lookup"><span data-stu-id="9b04f-149">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="9b04f-150">Ponadto protokoły dla obsługi postępu i anulowania obsługi utrudnić algorytm zrozumieć na pierwszego czytania.</span><span class="sxs-lookup"><span data-stu-id="9b04f-150">In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="9b04f-151">Musisz sprawdzić dla klasy postęp dowiedzieć się, gdzie jest zgłaszany postępu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-151">You must look for the progress class to find where progress is reported.</span></span> <span data-ttu-id="9b04f-152">Musisz też śledzenia komunikacji za pośrednictwem <xref:System.Threading.CancellationTokenSource> i jego skojarzone <xref:System.Threading.CancellationToken> zrozumienie, której zażądano anulowania i gdzie otrzymuje.</span><span class="sxs-lookup"><span data-stu-id="9b04f-152">You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="9b04f-153">Asynchroniczne strumienie umożliwiają lepsze</span><span class="sxs-lookup"><span data-stu-id="9b04f-153">Async streams provide a better way</span></span>

<span data-ttu-id="9b04f-154">Asynchroniczne strumienie i obsługę języka skojarzone adresów wszystkie te problemy.</span><span class="sxs-lookup"><span data-stu-id="9b04f-154">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="9b04f-155">Kod, który generuje sekwencji mogą teraz używać `yield return` do zwrócenia elementów w metodzie, która została zadeklarowana przy użyciu `async` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="9b04f-155">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="9b04f-156">Będzie można korzystać strumienia asynchronicznego przy użyciu `await foreach` pętli tak samo, jak możesz używać dowolnej sekwencji za pomocą `foreach` pętli.</span><span class="sxs-lookup"><span data-stu-id="9b04f-156">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="9b04f-157">Te nowe funkcje języka są zależne od trzy nowe interfejsy dodane do platformy .NET Standard 2.1 i zaimplementowane w .NET Core 3.0 to:</span><span class="sxs-lookup"><span data-stu-id="9b04f-157">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        T Current { get; }

        ValueTask<bool> MoveNextAsync();
    }
}

namespace System
{
    public interface IAsyncDisposable
    {
        ValueTask DisposeAsync();
    }
}
```

<span data-ttu-id="9b04f-158">Te trzy interfejsy należy znać większość C# deweloperów.</span><span class="sxs-lookup"><span data-stu-id="9b04f-158">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="9b04f-159">Zachowują się w sposób podobny do ich odpowiedników synchronicznego:</span><span class="sxs-lookup"><span data-stu-id="9b04f-159">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="9b04f-160">Jest jeden typ, który może być zaznajomiony <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9b04f-160">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9b04f-161">`ValueTask` Struktura zapewnia podobny interfejs API, aby <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="9b04f-161">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="9b04f-162">`ValueTask` jest używana w tych interfejsów ze względu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="9b04f-162">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="9b04f-163">Konwertuj do strumieni asynchronicznych</span><span class="sxs-lookup"><span data-stu-id="9b04f-163">Convert to async streams</span></span>

<span data-ttu-id="9b04f-164">Następnie przekonwertować `runPagedQueryAsync` metodę w celu wygenerowania strumień async.</span><span class="sxs-lookup"><span data-stu-id="9b04f-164">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="9b04f-165">Najpierw Zmień podpis `runPagedQueryAsync` do zwrócenia `IAsyncEnumerable<JToken>`i Usuń obiekty anulowania tokenu i postępu na liście parametrów, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="9b04f-165">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

[!code-csharp[FinishedSignature](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#UpdateSignature)]

<span data-ttu-id="9b04f-166">Kod startowy przetwarza każdej strony jako stronę jest pobierana, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="9b04f-166">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

[!code-csharp[StarterPaging](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#ProcessPage)]

<span data-ttu-id="9b04f-167">Zastąp te trzy wiersze z następującym kodem:</span><span class="sxs-lookup"><span data-stu-id="9b04f-167">Replace those three lines with the following code:</span></span>

[!code-csharp[FinishedPaging](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#YieldReturnPage)]

<span data-ttu-id="9b04f-168">Można również usunąć deklaracji `finalResults` wcześniej w tej metodzie i `return` instrukcję, która następuje po pętli został zmodyfikowany.</span><span class="sxs-lookup"><span data-stu-id="9b04f-168">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="9b04f-169">Zmiany do generowania strumień asynchroniczne zostały ukończone.</span><span class="sxs-lookup"><span data-stu-id="9b04f-169">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="9b04f-170">Zakończono metodę powinien wyglądać podobnie poniższy kod:</span><span class="sxs-lookup"><span data-stu-id="9b04f-170">The finished method should resemble the code below:</span></span>

[!code-csharp[FinishedGenerate](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#GenerateAsyncStream)]

<span data-ttu-id="9b04f-171">Następnie możesz zmienić kod, który korzysta z kolekcji z strumienia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="9b04f-171">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="9b04f-172">Znajdź następujący kod w `Main` która przetwarza zbiór problemy:</span><span class="sxs-lookup"><span data-stu-id="9b04f-172">Find the following code in `Main` that processes the collection of issues:</span></span>

[!code-csharp[EnumerateOldStyle](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#EnumerateOldStyle)]

<span data-ttu-id="9b04f-173">Zastąp kod następującym kodem `await foreach` Pętla:</span><span class="sxs-lookup"><span data-stu-id="9b04f-173">Replace that code with the following `await foreach` loop:</span></span>

[!code-csharp[FinishedEnumerateAsyncStream](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#EnumerateAsyncStream)]

<span data-ttu-id="9b04f-174">Możesz też uzyskać kod Zakończono samouczek z [dotnet/samples](https://github.com/dotnet/samples) repozytorium w [AsyncStreams-csharp/samouczki](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folderu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-174">You can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="9b04f-175">Uruchamianie gotowych aplikacji</span><span class="sxs-lookup"><span data-stu-id="9b04f-175">Run the finished application</span></span>

<span data-ttu-id="9b04f-176">Uruchom ponownie aplikację.</span><span class="sxs-lookup"><span data-stu-id="9b04f-176">Run the application again.</span></span> <span data-ttu-id="9b04f-177">Porównaj zachowanie z zachowaniem aplikacji starter.</span><span class="sxs-lookup"><span data-stu-id="9b04f-177">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="9b04f-178">Pierwszej strony wyników są wyliczane, jak jest ona dostępna.</span><span class="sxs-lookup"><span data-stu-id="9b04f-178">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="9b04f-179">Jest zauważalne Wstrzymaj każdej nowej strony są żądane i pobrać, a następnie szybko wyliczane są następnej strony wyników.</span><span class="sxs-lookup"><span data-stu-id="9b04f-179">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="9b04f-180">`try`  /  `catch` Blok nie jest wymagane do obsługi anulowania: obiekt wywołujący może zatrzymać wyliczania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="9b04f-180">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="9b04f-181">Postęp wyraźnie jest zgłaszany, ponieważ strumienia asynchronicznego generuje wyniki, ponieważ każda strona zostanie pobrana.</span><span class="sxs-lookup"><span data-stu-id="9b04f-181">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span>

<span data-ttu-id="9b04f-182">Możesz zobaczyć ulepszenia wykorzystania pamięci, sprawdzając kod.</span><span class="sxs-lookup"><span data-stu-id="9b04f-182">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="9b04f-183">Nie potrzebujesz już przydzielić kolekcji do przechowywania wszystkich wyników, zanim są teraz wyliczane.</span><span class="sxs-lookup"><span data-stu-id="9b04f-183">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="9b04f-184">Obiekt wywołujący może ustalić, jak używać wyników i kolekcję magazynu jest potrzebna, jeśli.</span><span class="sxs-lookup"><span data-stu-id="9b04f-184">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="9b04f-185">Uruchom starter i gotowe aplikacje i można obserwować różnic między implementacjami dla siebie.</span><span class="sxs-lookup"><span data-stu-id="9b04f-185">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="9b04f-186">Można usunąć tokenu dostępu usługi GitHub, zostały utworzone podczas korzystania z tego samouczka po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="9b04f-186">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="9b04f-187">Jeśli osoba atakująca uzyska dostęp do tego tokenu, można uzyskać dostępu interfejsów API usługi GitHub przy użyciu poświadczeń.</span><span class="sxs-lookup"><span data-stu-id="9b04f-187">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
