---
title: Generowanie i używanie strumieni asynchronicznych
description: W tym zaawansowanym samouczku pokazano, jak generować strumienie asynchroniczne i korzystać z nich. Strumienie asynchroniczne zapewniają bardziej naturalny sposób pracy z sekwencjami danych, które mogą być generowane asynchronicznie.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: 03254e5208a048469f4753d632de7b0d451cde40
ms.sourcegitcommit: 5988e9a29cedb8757320817deda3c08c6f44a6aa
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/28/2020
ms.locfileid: "82200109"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="89f78-104">Samouczek: generowanie strumieni asynchronicznych i korzystanie z nich przy użyciu języków C# 8,0 i .NET Core 3,0</span><span class="sxs-lookup"><span data-stu-id="89f78-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="89f78-105">W języku C# 8,0 wprowadzono **strumienie asynchroniczne**, które modelują Źródło strumieni danych.</span><span class="sxs-lookup"><span data-stu-id="89f78-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="89f78-106">Strumienie danych często pobierają lub generują elementy asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="89f78-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="89f78-107">Strumienie asynchroniczne korzystają z nowych interfejsów wprowadzonych w .NET Standard 2,1.</span><span class="sxs-lookup"><span data-stu-id="89f78-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="89f78-108">Te interfejsy są obsługiwane w programie .NET Core 3,0 i nowszych.</span><span class="sxs-lookup"><span data-stu-id="89f78-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="89f78-109">Zapewniają naturalny model programowania dla asynchronicznych źródeł danych strumieniowych.</span><span class="sxs-lookup"><span data-stu-id="89f78-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="89f78-110">Z tego samouczka dowiesz się, jak wykonywać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="89f78-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="89f78-111">Utwórz źródło danych, które generuje sekwencję elementów danych asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="89f78-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="89f78-112">Korzystaj z tego źródła danych asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="89f78-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="89f78-113">Obsługa anulowania i przechwyconych kontekstów dla strumieni asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="89f78-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="89f78-114">Rozpoznawaj, kiedy nowy interfejs i źródło danych są preferowane ze starszymi synchronicznymi sekwencjami danych.</span><span class="sxs-lookup"><span data-stu-id="89f78-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="89f78-115">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="89f78-115">Prerequisites</span></span>

<span data-ttu-id="89f78-116">Musisz skonfigurować maszynę do uruchamiania programu .NET Core, w tym kompilatora C# 8,0.</span><span class="sxs-lookup"><span data-stu-id="89f78-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="89f78-117">Kompilator języka C# 8 jest dostępny w programie [Visual Studio 2019 w wersji 16,3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) lub [.NET Core 3,0 SDK](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="89f78-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="89f78-118">Musisz utworzyć [token dostępu GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) , aby uzyskać dostęp do punktu końcowego usługi GitHub GraphQL.</span><span class="sxs-lookup"><span data-stu-id="89f78-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="89f78-119">Wybierz następujące uprawnienia dla tokenu dostępu usługi GitHub:</span><span class="sxs-lookup"><span data-stu-id="89f78-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="89f78-120">repozytorium: stan</span><span class="sxs-lookup"><span data-stu-id="89f78-120">repo:status</span></span>
- <span data-ttu-id="89f78-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="89f78-121">public_repo</span></span>

<span data-ttu-id="89f78-122">Zapisz token dostępu w bezpiecznym miejscu, aby można było go użyć w celu uzyskania dostępu do punktu końcowego interfejsu API usługi GitHub.</span><span class="sxs-lookup"><span data-stu-id="89f78-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="89f78-123">Zabezpieczanie osobistego tokenu dostępu.</span><span class="sxs-lookup"><span data-stu-id="89f78-123">Keep your personal access token secure.</span></span> <span data-ttu-id="89f78-124">Każde oprogramowanie z osobistym tokenem dostępu może wykonywać wywołania interfejsu API usługi GitHub przy użyciu praw dostępu.</span><span class="sxs-lookup"><span data-stu-id="89f78-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="89f78-125">W tym samouczku założono, że znasz języki C# i .NET, w tym Visual Studio lub interfejs wiersza polecenia platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="89f78-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="89f78-126">Uruchom aplikację Starter</span><span class="sxs-lookup"><span data-stu-id="89f78-126">Run the starter application</span></span>

<span data-ttu-id="89f78-127">Możesz uzyskać kod dla aplikacji startowej używanej w tym samouczku z repozytorium [dotnet/docs](https://github.com/dotnet/docs) w folderze [CSharp/samouczki/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) .</span><span class="sxs-lookup"><span data-stu-id="89f78-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="89f78-128">Aplikacja startowa to Aplikacja konsolowa korzystająca z interfejsu [GraphQL GitHub](https://developer.github.com/v4/) do pobierania ostatnich problemów pisanych w repozytorium [dotnet/docs](https://github.com/dotnet/docs) .</span><span class="sxs-lookup"><span data-stu-id="89f78-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="89f78-129">Zacznij od przejrzenia następującego kodu dla metody Starter App `Main` :</span><span class="sxs-lookup"><span data-stu-id="89f78-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="89f78-130">Można ustawić zmienną `GitHubKey` środowiskową na osobisty token dostępu lub zastąpić ostatni argument w wywołaniu do `GenEnvVariable` osobistego tokenu dostępu.</span><span class="sxs-lookup"><span data-stu-id="89f78-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="89f78-131">Nie umieszczaj kodu dostępu w kodzie źródłowym, jeśli będziesz udostępniać inne osoby.</span><span class="sxs-lookup"><span data-stu-id="89f78-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="89f78-132">Nigdy nie przekazuj kodów dostępu do udostępnionego repozytorium źródłowego.</span><span class="sxs-lookup"><span data-stu-id="89f78-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="89f78-133">Po utworzeniu klienta usługi GitHub kod w programie `Main` tworzy obiekt raportowania postępu i token anulowania.</span><span class="sxs-lookup"><span data-stu-id="89f78-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="89f78-134">Po utworzeniu tych obiektów program `Main` wywołuje `runPagedQueryAsync` w celu pobrania najnowszych utworzonych problemów 250.</span><span class="sxs-lookup"><span data-stu-id="89f78-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="89f78-135">Po zakończeniu tego zadania zostaną wyświetlone wyniki.</span><span class="sxs-lookup"><span data-stu-id="89f78-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="89f78-136">Po uruchomieniu aplikacji Starter możesz wprowadzić pewne ważne uwagi dotyczące sposobu działania tej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="89f78-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="89f78-137">Zobaczysz Postęp raportowany dla każdej strony zwróconej z usługi GitHub.</span><span class="sxs-lookup"><span data-stu-id="89f78-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="89f78-138">Można obserwować zauważalne wstrzymanie przed zwróceniem przez usługę GitHub każdej nowej strony problemu.</span><span class="sxs-lookup"><span data-stu-id="89f78-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="89f78-139">Na koniec problemy są wyświetlane dopiero po pobraniu 10 stron z witryny GitHub.</span><span class="sxs-lookup"><span data-stu-id="89f78-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="89f78-140">Sprawdzanie implementacji</span><span class="sxs-lookup"><span data-stu-id="89f78-140">Examine the implementation</span></span>

<span data-ttu-id="89f78-141">Implementacja pokazuje, dlaczego zaobserwowano zachowanie omówione w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="89f78-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="89f78-142">Przejrzyj kod dla `runPagedQueryAsync`:</span><span class="sxs-lookup"><span data-stu-id="89f78-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="89f78-143">Skoncentrujemy się na algorytmie stronicowania i strukturze asynchronicznej poprzedniego kodu.</span><span class="sxs-lookup"><span data-stu-id="89f78-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="89f78-144">(Szczegółowe informacje o interfejsie API usługi GitHub GraphQL można znaleźć w [dokumentacji usługi GitHub GraphQL](https://developer.github.com/v4/guides/) ). `runPagedQueryAsync` Metoda wylicza problemy od najnowszych do najstarszych.</span><span class="sxs-lookup"><span data-stu-id="89f78-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="89f78-145">Żąda 25 problemów na stronę i analizuje `pageInfo` strukturę odpowiedzi, aby kontynuować z poprzednią stroną.</span><span class="sxs-lookup"><span data-stu-id="89f78-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="89f78-146">Jest to zgodne ze standardową obsługą stronicowania GraphQL dla odpowiedzi na wiele stron.</span><span class="sxs-lookup"><span data-stu-id="89f78-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="89f78-147">Odpowiedź zawiera `pageInfo` obiekt, który zawiera `hasPreviousPages` wartość i `startCursor` wartość użytą do żądania poprzedniej strony.</span><span class="sxs-lookup"><span data-stu-id="89f78-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="89f78-148">Problemy znajdują się w `nodes` tablicy.</span><span class="sxs-lookup"><span data-stu-id="89f78-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="89f78-149">`runPagedQueryAsync` Metoda dołącza te węzły do tablicy, która zawiera wszystkie wyniki ze wszystkich stron.</span><span class="sxs-lookup"><span data-stu-id="89f78-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="89f78-150">Po pobraniu i przywróceniu strony wyników raporty `runPagedQueryAsync` postępują i sprawdzają, czy zostały anulowane.</span><span class="sxs-lookup"><span data-stu-id="89f78-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="89f78-151">Jeśli żądanie zostało anulowane, `runPagedQueryAsync` program wygeneruje <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="89f78-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="89f78-152">W tym kodzie istnieje kilka elementów, które można ulepszyć.</span><span class="sxs-lookup"><span data-stu-id="89f78-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="89f78-153">Co najważniejsze, `runPagedQueryAsync` należy przydzielić magazyn dla wszystkich zwracanych problemów.</span><span class="sxs-lookup"><span data-stu-id="89f78-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="89f78-154">Ten przykład zakończył się z powodu 250 problemów, ponieważ pobieranie wszystkich otwartych problemów wymagało dużo więcej pamięci do przechowywania wszystkich pobranych problemów.</span><span class="sxs-lookup"><span data-stu-id="89f78-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="89f78-155">Protokoły obsługujące raporty z postępów i anulowanie sprawiają, że algorytm jest trudniejszy do zrozumienia podczas pierwszego odczytywania.</span><span class="sxs-lookup"><span data-stu-id="89f78-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="89f78-156">Są wykorzystywane więcej typów i interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="89f78-156">More types and APIs are involved.</span></span> <span data-ttu-id="89f78-157">Należy śledzić komunikację za pośrednictwem programu <xref:System.Threading.CancellationTokenSource> i powiązane <xref:System.Threading.CancellationToken> z nim, aby zrozumieć, gdzie zażądano anulowania, i miejsce, w którym jest ono udzielone.</span><span class="sxs-lookup"><span data-stu-id="89f78-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="89f78-158">Strumienie asynchroniczne zapewniają lepszy sposób</span><span class="sxs-lookup"><span data-stu-id="89f78-158">Async streams provide a better way</span></span>

<span data-ttu-id="89f78-159">Strumienie asynchroniczne i powiązane z nimi wsparcie dotyczące języka dotyczą wszystkich problemów.</span><span class="sxs-lookup"><span data-stu-id="89f78-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="89f78-160">Kod generujący sekwencję może teraz używać `yield return` do zwracania elementów w metodzie, która została zadeklarowana z `async` modyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="89f78-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="89f78-161">Można wykorzystać strumień asynchroniczny za pomocą `await foreach` pętli tak samo jak w przypadku użycia dowolnej sekwencji przy `foreach` użyciu pętli.</span><span class="sxs-lookup"><span data-stu-id="89f78-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="89f78-162">Te nowe funkcje języka zależą od trzech nowych interfejsów dodanych do .NET Standard 2,1 i wdrożonych w środowisku .NET Core 3,0:</span><span class="sxs-lookup"><span data-stu-id="89f78-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="89f78-163">Te trzy interfejsy powinny być znane dla większości deweloperów języka C#.</span><span class="sxs-lookup"><span data-stu-id="89f78-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="89f78-164">Działają w sposób podobny do ich synchronicznych odpowiedników:</span><span class="sxs-lookup"><span data-stu-id="89f78-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="89f78-165">Jednym z typów, które mogą być nieznane <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="89f78-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="89f78-166">`ValueTask` Struktura zapewnia podobny interfejs API do <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="89f78-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="89f78-167">`ValueTask`jest używany w tych interfejsach ze względu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="89f78-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="89f78-168">Konwertuj na strumienie asynchroniczne</span><span class="sxs-lookup"><span data-stu-id="89f78-168">Convert to async streams</span></span>

<span data-ttu-id="89f78-169">Następnie Skonwertuj `runPagedQueryAsync` metodę w celu wygenerowania strumienia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="89f78-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="89f78-170">Najpierw Zmień sygnaturę `runPagedQueryAsync` `IAsyncEnumerable<JToken>`, aby zwracała, i Usuń tokeny anulowania i obiekty postępu z listy parametrów, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="89f78-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="89f78-171">Kod początkowy przetwarza każdą stronę w miarę pobierania strony, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="89f78-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="89f78-172">Zastąp te trzy wiersze następującym kodem:</span><span class="sxs-lookup"><span data-stu-id="89f78-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="89f78-173">Możesz również usunąć deklarację `finalResults` wcześniej w tej metodzie i `return` instrukcji, która następuje po zmodyfikowanej pętli.</span><span class="sxs-lookup"><span data-stu-id="89f78-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="89f78-174">Zakończono wprowadzanie zmian w celu wygenerowania strumienia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="89f78-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="89f78-175">Metoda Final powinna wyglądać podobnie do następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="89f78-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="89f78-176">Następnie należy zmienić kod, który używa kolekcji, aby wykorzystać strumień asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="89f78-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="89f78-177">Znajdź następujący kod w programie `Main` , który przetwarza zbieranie problemów:</span><span class="sxs-lookup"><span data-stu-id="89f78-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="89f78-178">Zastąp ten kod następującą `await foreach` pętlą:</span><span class="sxs-lookup"><span data-stu-id="89f78-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="89f78-179">Nowy interfejs <xref:System.Collections.Generic.IAsyncEnumerator%601> pochodzi od <xref:System.IAsyncDisposable>.</span><span class="sxs-lookup"><span data-stu-id="89f78-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="89f78-180">Oznacza to, że poprzednia pętla będzie asynchronicznie zlikwidować strumień po zakończeniu pętli.</span><span class="sxs-lookup"><span data-stu-id="89f78-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="89f78-181">Można wyobrazić pętlę, tak jak w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="89f78-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="89f78-182">Domyślnie elementy strumienia są przetwarzane w przechwyconym kontekście.</span><span class="sxs-lookup"><span data-stu-id="89f78-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="89f78-183">Jeśli chcesz wyłączyć przechwytywanie kontekstu, użyj metody <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="89f78-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="89f78-184">Aby uzyskać więcej informacji na temat kontekstów synchronizacji i przechwytywania bieżącego kontekstu, zobacz artykuł dotyczący [konsumowania wzorca asynchronicznego opartego na zadaniach](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="89f78-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="89f78-185">Strumienie asynchroniczne obsługują anulowanie przy użyciu tego samego protokołu `async` , co inne metody.</span><span class="sxs-lookup"><span data-stu-id="89f78-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="89f78-186">Należy zmodyfikować sygnaturę dla asynchronicznej metody iteratora w następujący sposób, aby obsługiwać anulowanie:</span><span class="sxs-lookup"><span data-stu-id="89f78-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="89f78-187">Ten <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> atrybut powoduje, <xref:System.Collections.Generic.IAsyncEnumerator%601> że kompilator generuje kod dla, który przekazuje token jako `GetAsyncEnumerator` widoczny dla treści iteratora asynchronicznego jako ten argument.</span><span class="sxs-lookup"><span data-stu-id="89f78-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="89f78-188">Wewnątrz `runQueryAsync`można skontrolować stan tokenu i w razie żądania anulować dalsze prace.</span><span class="sxs-lookup"><span data-stu-id="89f78-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="89f78-189">Aby przekazać token anulowania do strumienia <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>asynchronicznego, należy użyć innej metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="89f78-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="89f78-190">Należy zmodyfikować pętlę wyliczające problemy w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="89f78-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="89f78-191">Kod gotowego samouczka można uzyskać z repozytorium [dotnet/docs](https://github.com/dotnet/docs) w folderze [CSharp/samouczki/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) .</span><span class="sxs-lookup"><span data-stu-id="89f78-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="89f78-192">Uruchamianie gotowej aplikacji</span><span class="sxs-lookup"><span data-stu-id="89f78-192">Run the finished application</span></span>

<span data-ttu-id="89f78-193">Uruchom ponownie aplikację.</span><span class="sxs-lookup"><span data-stu-id="89f78-193">Run the application again.</span></span> <span data-ttu-id="89f78-194">Poróżnij swoje zachowanie z zachowaniem aplikacji startowej.</span><span class="sxs-lookup"><span data-stu-id="89f78-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="89f78-195">Pierwsza Strona wyników jest wyliczana zaraz po jej udostępnieniu.</span><span class="sxs-lookup"><span data-stu-id="89f78-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="89f78-196">Po zażądaniu i pobraniu każdej nowej strony istnieje zauważalne wstrzymanie, a następnie wyniki następnej strony są szybko wyliczane.</span><span class="sxs-lookup"><span data-stu-id="89f78-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="89f78-197">`try` jest wymagany do obsługi anulowania: obiekt wywołujący może zatrzymać wyliczanie  /  `catch` kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89f78-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="89f78-198">Postęp jest jasno raportowany, ponieważ strumień asynchroniczny generuje wyniki po pobraniu każdej strony.</span><span class="sxs-lookup"><span data-stu-id="89f78-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="89f78-199">Stan każdego zwróconego problemu jest bezproblemowo zawarty w `await foreach` pętli.</span><span class="sxs-lookup"><span data-stu-id="89f78-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="89f78-200">Obiekt wywołania zwrotnego nie jest potrzebny do śledzenia postępu.</span><span class="sxs-lookup"><span data-stu-id="89f78-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="89f78-201">Aby zobaczyć ulepszenia wykorzystania pamięci, zbadając kod.</span><span class="sxs-lookup"><span data-stu-id="89f78-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="89f78-202">Nie trzeba już przydzielać kolekcji do przechowywania wszystkich wyników przed ich wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="89f78-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="89f78-203">Obiekt wywołujący może określić, jak zużywać wyniki i czy wymagana jest kolekcja magazynu.</span><span class="sxs-lookup"><span data-stu-id="89f78-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="89f78-204">Uruchom zarówno aplikacje Starter, jak i gotowe, a także zaobserwuj różnice między implementacjami.</span><span class="sxs-lookup"><span data-stu-id="89f78-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="89f78-205">Po zakończeniu tego samouczka możesz usunąć token dostępu usługi GitHub, który został utworzony podczas jego uruchamiania.</span><span class="sxs-lookup"><span data-stu-id="89f78-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="89f78-206">Jeśli osoba atakująca uzyska dostęp do tego tokenu, może uzyskać dostęp do interfejsów API usługi GitHub przy użyciu swoich poświadczeń.</span><span class="sxs-lookup"><span data-stu-id="89f78-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
