---
title: Wzorzec bramy interfejsu API w porównaniu z bezpośrednią komunikacją klient-mikrousługi
description: Zrozumienie różnic i zastosowań wzorca bramy interfejsu API i bezpośredniej komunikacji klient-mikrousługi.
ms.date: 01/07/2019
ms.openlocfilehash: 47e9a383c1fcb6c9fec38cb376b60a4ab839077d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401726"
---
# <a name="the-api-gateway-pattern-versus-the-direct-client-to-microservice-communication"></a><span data-ttu-id="e5428-103">Wzorzec bramy interfejsu API w porównaniu z bezpośrednią komunikacją klient-mikrousługi</span><span class="sxs-lookup"><span data-stu-id="e5428-103">The API gateway pattern versus the Direct client-to-microservice communication</span></span>

<span data-ttu-id="e5428-104">W architekturze mikrousług każda mikrousługa udostępnia zestaw (zazwyczaj) szczegółowych punktów końcowych.</span><span class="sxs-lookup"><span data-stu-id="e5428-104">In a microservices architecture, each microservice exposes a set of (typically) fine-grained endpoints.</span></span> <span data-ttu-id="e5428-105">Ten fakt może mieć wpływ na komunikację klient-mikrousługi, jak wyjaśniono w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e5428-105">This fact can impact the client-to-microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="e5428-106">Bezpośrednia komunikacja klient-mikrousługi</span><span class="sxs-lookup"><span data-stu-id="e5428-106">Direct client-to-microservice communication</span></span>

<span data-ttu-id="e5428-107">Możliwe podejście jest użycie architektury komunikacji bezpośredniego klient-mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e5428-107">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="e5428-108">W tym podejściu aplikacja klienckimoże wysyłać żądania bezpośrednio do niektórych mikrousług, jak pokazano na rysunku 4-12.</span><span class="sxs-lookup"><span data-stu-id="e5428-108">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![Diagram przedstawiający architekturę komunikacji klient-mikrousługi.](./media/direct-client-to-microservice-communication.png)

<span data-ttu-id="e5428-110">**Rysunek 4-12**.</span><span class="sxs-lookup"><span data-stu-id="e5428-110">**Figure 4-12**.</span></span> <span data-ttu-id="e5428-111">Korzystanie z architektury komunikacji bezpośredniej klient-mikrousługi</span><span class="sxs-lookup"><span data-stu-id="e5428-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="e5428-112">W tym podejściu każda mikrousługa ma publiczny punkt końcowy, czasami z innym portem TCP dla każdej mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e5428-112">In this approach, each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="e5428-113">Przykładem adresu URL określonej usługi może być następujący adres URL na platformie Azure:</span><span class="sxs-lookup"><span data-stu-id="e5428-113">An example of a URL for a particular service could be the following URL in Azure:</span></span>

`http://eshoponcontainers.westus.cloudapp.azure.com:88/`

<span data-ttu-id="e5428-114">W środowisku produkcyjnym opartym na klastrze ten adres URL będzie mapował na moduł równoważenia obciążenia używany w klastrze, który z kolei dystrybuuje żądania między mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="e5428-114">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="e5428-115">W środowiskach produkcyjnych może mieć kontroler dostarczania aplikacji (ADC) jak [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) między mikrousług i Internetu.</span><span class="sxs-lookup"><span data-stu-id="e5428-115">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="e5428-116">Działa to jako przezroczysta warstwa, która nie tylko wykonuje równoważenie obciążenia, ale zabezpiecza usługi, oferując zakończenie SSL.</span><span class="sxs-lookup"><span data-stu-id="e5428-116">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="e5428-117">Zwiększa to obciążenie hostów przez odciążenie zakończenia ssl intensywnie korzystających z procesora CPU i innych obowiązków routingu do bramy aplikacji platformy Azure.</span><span class="sxs-lookup"><span data-stu-id="e5428-117">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="e5428-118">W każdym przypadku moduł równoważenia obciążenia i ADC są przezroczyste z logicznego punktu widzenia architektury aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e5428-118">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="e5428-119">Bezpośrednia architektura komunikacji klient-mikrousługi może być wystarczająco dobre dla małej aplikacji opartej na mikrousługach, zwłaszcza jeśli aplikacja kliencka jest aplikacją sieci web po stronie serwera, taką jak ASP.NET aplikacji MVC.</span><span class="sxs-lookup"><span data-stu-id="e5428-119">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="e5428-120">Jednak podczas tworzenia dużych i złożonych aplikacji opartych na mikrousługach (na przykład podczas obsługi dziesiątek typów mikrousług), a zwłaszcza, gdy aplikacje klienckie są zdalnymi aplikacjami mobilnymi lub aplikacjami sieci web SPA, podejście to napotyka kilka problemów.</span><span class="sxs-lookup"><span data-stu-id="e5428-120">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="e5428-121">Podczas tworzenia dużej aplikacji opartej na mikrousługach należy wziąć pod uwagę następujące pytania:</span><span class="sxs-lookup"><span data-stu-id="e5428-121">Consider the following questions when developing a large application based on microservices:</span></span>

- <span data-ttu-id="e5428-122">*Jak aplikacje klienckie zminimalizować liczbę żądań do zaplecza i zmniejszyć chatty komunikacji do wielu mikrousług?*</span><span class="sxs-lookup"><span data-stu-id="e5428-122">*How can client apps minimize the number of requests to the back end and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="e5428-123">Interakcja z wieloma mikrousługami w celu utworzenia jednego ekranu interfejsu i usług zwiększa liczbę rund w Internecie.</span><span class="sxs-lookup"><span data-stu-id="e5428-123">Interacting with multiple microservices to build a single UI screen increases the number of round trips across the Internet.</span></span> <span data-ttu-id="e5428-124">Zwiększa to opóźnienie i złożoność po stronie interfejsu interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e5428-124">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="e5428-125">W idealnym przypadku odpowiedzi powinny być skutecznie agregowane po stronie serwera.</span><span class="sxs-lookup"><span data-stu-id="e5428-125">Ideally, responses should be efficiently aggregated in the server side.</span></span> <span data-ttu-id="e5428-126">Zmniejsza to opóźnienia, ponieważ wiele fragmentów danych wraca równolegle, a niektóre interfejsu jego danych mogą wyświetlać dane, gdy tylko będą gotowe.</span><span class="sxs-lookup"><span data-stu-id="e5428-126">This reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it's ready.</span></span>

- <span data-ttu-id="e5428-127">*Jak można obsługiwać problemy przekrojowe, takie jak autoryzacja, przekształcenia danych i dynamiczne wysyłanie żądań?*</span><span class="sxs-lookup"><span data-stu-id="e5428-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="e5428-128">Implementowanie zabezpieczeń i przekrojowych problemów, takich jak zabezpieczenia i autoryzacji dla każdej mikrousługi może wymagać znacznych nakładów rozwoju.</span><span class="sxs-lookup"><span data-stu-id="e5428-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="e5428-129">Możliwym podejściem jest mieć te usługi w hoście platformy Docker lub klastrze wewnętrznym, aby ograniczyć bezpośredni dostęp do nich z zewnątrz i zaimplementować te przekrojowe problemy w scentralizowanym miejscu, takim jak brama interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="e5428-129">A possible approach is to have those services within the Docker host or internal cluster to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

- <span data-ttu-id="e5428-130">*Jak aplikacje klienckie mogą komunikować się z usługami korzystającymi z protokołów nieprzyjaznych dla Internetu?*</span><span class="sxs-lookup"><span data-stu-id="e5428-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="e5428-131">Protokoły używane po stronie serwera (takie jak AMQP lub protokoły binarne) zwykle nie są obsługiwane w aplikacjach klienckich.</span><span class="sxs-lookup"><span data-stu-id="e5428-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="e5428-132">W związku z tym żądania muszą być wykonywane za pośrednictwem protokołów, takich jak HTTP/HTTPS i przetłumaczone na inne protokoły później.</span><span class="sxs-lookup"><span data-stu-id="e5428-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="e5428-133">W tej sytuacji może pomóc podejście *"man-in-the-middle".*</span><span class="sxs-lookup"><span data-stu-id="e5428-133">A *man-in-the-middle* approach can help in this situation.</span></span>

- <span data-ttu-id="e5428-134">*Jak można kształtować fasadę specjalnie dla aplikacji mobilnych?*</span><span class="sxs-lookup"><span data-stu-id="e5428-134">*How can you shape a facade especially made for mobile apps?*</span></span>

<span data-ttu-id="e5428-135">Interfejs API wielu mikrousług może nie być dobrze zaprojektowany dla potrzeb różnych aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="e5428-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="e5428-136">Na przykład potrzeby aplikacji mobilnej mogą być inne niż potrzeby aplikacji sieci web.</span><span class="sxs-lookup"><span data-stu-id="e5428-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="e5428-137">W przypadku aplikacji mobilnych może być konieczne jeszcze bardziej zoptymalizowane optymalizacja, aby odpowiedzi na dane mogły być bardziej wydajne.</span><span class="sxs-lookup"><span data-stu-id="e5428-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="e5428-138">Można to zrobić przez agregowanie danych z wielu mikrousług i zwracanie pojedynczego zestawu danych, a czasami eliminując wszystkie dane w odpowiedzi, która nie jest potrzebna przez aplikację mobilną.</span><span class="sxs-lookup"><span data-stu-id="e5428-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that isn't needed by the mobile app.</span></span> <span data-ttu-id="e5428-139">I, oczywiście, można skompresować te dane.</span><span class="sxs-lookup"><span data-stu-id="e5428-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="e5428-140">Ponownie fasady lub interfejsu API pomiędzy aplikacją mobilną i mikrousług może być wygodne w tym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="e5428-140">Again, a facade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="why-consider-api-gateways-instead-of-direct-client-to-microservice-communication"></a><span data-ttu-id="e5428-141">Dlaczego warto rozważyć bramy interfejsu API zamiast bezpośredniej komunikacji klient-mikrousługi</span><span class="sxs-lookup"><span data-stu-id="e5428-141">Why consider API Gateways instead of direct client-to-microservice communication</span></span>

<span data-ttu-id="e5428-142">W architekturze mikrousług aplikacje klienckie zwykle muszą korzystać z funkcji z więcej niż jednej mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e5428-142">In a microservices architecture, the client apps usually need to consume functionality from more than one microservice.</span></span> <span data-ttu-id="e5428-143">Jeśli to zużycie jest wykonywane bezpośrednio, klient musi obsługiwać wiele wywołań do punktów końcowych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e5428-143">If that consumption is performed directly, the client needs to handle multiple calls to microservice endpoints.</span></span> <span data-ttu-id="e5428-144">Co się stanie, gdy aplikacja ewoluuje i nowe mikrousługi są wprowadzane lub istniejące mikrousługi są aktualizowane?</span><span class="sxs-lookup"><span data-stu-id="e5428-144">What happens when the application evolves and new microservices are introduced or existing microservices are updated?</span></span> <span data-ttu-id="e5428-145">Jeśli aplikacja ma wiele mikrousług, obsługa tak wielu punktów końcowych z aplikacji klienckich może być koszmarem.</span><span class="sxs-lookup"><span data-stu-id="e5428-145">If your application has many microservices, handling so many endpoints from the client apps can be a nightmare.</span></span> <span data-ttu-id="e5428-146">Ponieważ aplikacja klienckie będzie sprzęgła z tych wewnętrznych punktów końcowych, ewoluuje mikrousług w przyszłości może spowodować duży wpływ na aplikacje klienckie.</span><span class="sxs-lookup"><span data-stu-id="e5428-146">Since the client app would be coupled to those internal endpoints, evolving the microservices in the future can cause high impact for the client apps.</span></span>

<span data-ttu-id="e5428-147">W związku z tym o poziomie pośrednim lub warstwy pośredniego (Gateway) może być bardzo wygodne dla aplikacji opartych na mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="e5428-147">Therefore, having an intermediate level or tier of indirection (Gateway) can be very convenient for microservice-based applications.</span></span> <span data-ttu-id="e5428-148">Jeśli nie masz bram interfejsu API, aplikacje klienckie muszą wysyłać żądania bezpośrednio do mikrousług, co powoduje problemy, takie jak następujące problemy:</span><span class="sxs-lookup"><span data-stu-id="e5428-148">If you don't have API Gateways, the client apps must send requests directly to the microservices and that raises problems, such as the following issues:</span></span>

- <span data-ttu-id="e5428-149">**Sprzężenie:** bez wzorca bramy interfejsu API aplikacje klienckie są sprzęgane z mikrousług wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="e5428-149">**Coupling**: Without the API Gateway pattern, the client apps are coupled to the internal microservices.</span></span> <span data-ttu-id="e5428-150">Aplikacje klienckie muszą wiedzieć, jak wiele obszarów aplikacji są rozłożone w mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="e5428-150">The client apps need to know how the multiple areas of the application are decomposed in microservices.</span></span> <span data-ttu-id="e5428-151">Podczas ewoluowania i refaktoryzacji mikrousług wewnętrznych, te akcje mają wpływ na konserwację bardzo źle, ponieważ powodują one przełomowe zmiany w aplikacjach klienckich ze względu na bezpośrednie odwołanie do mikrousług wewnętrznych z aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="e5428-151">When evolving and refactoring the internal microservices, those actions impact maintenance pretty badly because they cause breaking changes to the client apps due to the direct reference to the internal microservices from the client apps.</span></span> <span data-ttu-id="e5428-152">Aplikacje klienckie muszą być często aktualizowane, co utrudnia rozwój rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="e5428-152">Client apps need to be updated frequently, making the solution harder to evolve.</span></span>

- <span data-ttu-id="e5428-153">**Zbyt wiele rund:** Pojedyncza strona/ekran w aplikacji klienckiej może wymagać kilku wywołań wielu usług.</span><span class="sxs-lookup"><span data-stu-id="e5428-153">**Too many round trips**: A single page/screen in the client app might require several calls to multiple services.</span></span> <span data-ttu-id="e5428-154">Może to spowodować wiele rund sieciowych między klientem a serwerem, dodając znaczne opóźnienia.</span><span class="sxs-lookup"><span data-stu-id="e5428-154">That can result in multiple network round trips between the client and the server, adding significant latency.</span></span> <span data-ttu-id="e5428-155">Agregacja obsługiwana na poziomie pośrednim może poprawić wydajność i środowisko użytkownika dla aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="e5428-155">Aggregation handled in an intermediate level could improve the performance and user experience for the client app.</span></span>

- <span data-ttu-id="e5428-156">**Problemy z zabezpieczeniami:** bez bramy wszystkie mikrousługi muszą być udostępniane "światzewnętrzny", dzięki czemu powierzchnia ataku jest większa niż w przypadku ukrycia wewnętrznych mikrousług, które nie są bezpośrednio używane przez aplikacje klienckie.</span><span class="sxs-lookup"><span data-stu-id="e5428-156">**Security issues**: Without a gateway, all the microservices must be exposed to the "external world", making the attack surface larger than if you hide internal microservices that aren't directly used by the client apps.</span></span> <span data-ttu-id="e5428-157">Im mniejsza jest powierzchnia ataku, tym bardziej bezpieczna może być aplikacja.</span><span class="sxs-lookup"><span data-stu-id="e5428-157">The smaller the attack surface is, the more secure your application can be.</span></span>

- <span data-ttu-id="e5428-158">**Problemy przekrojowe:** Każda publicznie opublikowana mikrousługa musi obsługiwać takie problemy, jak autoryzacja, ssl itp. W wielu sytuacjach te problemy mogą być obsługiwane w jednej warstwie, dzięki czemu mikrousługi wewnętrzne są uproszczone.</span><span class="sxs-lookup"><span data-stu-id="e5428-158">**Cross-cutting concerns**: Each publicly published microservice must handle concerns such as authorization, SSL, etc. In many situations, those concerns could be handled in a single tier so the internal microservices are simplified.</span></span>

## <a name="what-is-the-api-gateway-pattern"></a><span data-ttu-id="e5428-159">Co to jest wzorzec bramy interfejsu API?</span><span class="sxs-lookup"><span data-stu-id="e5428-159">What is the API Gateway pattern?</span></span>

<span data-ttu-id="e5428-160">Podczas projektowania i tworzenia dużych lub złożonych aplikacji opartych na mikrousługach z wieloma aplikacjami klienckimi dobrym podejściem do rozważenia może być [brama interfejsu API.](https://microservices.io/patterns/apigateway.html)</span><span class="sxs-lookup"><span data-stu-id="e5428-160">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="e5428-161">Jest to usługa, która zapewnia pojedynczy punkt wejścia dla niektórych grup mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e5428-161">This is a service that provides a single-entry point for certain groups of microservices.</span></span> <span data-ttu-id="e5428-162">Jest podobny do [wzoru fasady](https://en.wikipedia.org/wiki/Facade_pattern) z projektu obiektowego, ale w tym przypadku jest częścią systemu rozproszonego.</span><span class="sxs-lookup"><span data-stu-id="e5428-162">It's similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object-oriented design, but in this case, it's part of a distributed system.</span></span> <span data-ttu-id="e5428-163">Wzorzec bramy interfejsu API jest również czasami znany jako "backend for frontend"[(BFF),](https://samnewman.io/patterns/architectural/bff/)ponieważ tworzysz go podczas myślenia o potrzebach aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="e5428-163">The API Gateway pattern is also sometimes known as the "backend for frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="e5428-164">W związku z tym brama interfejsu API znajduje się między aplikacjami klienckimi i mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e5428-164">Therefore, the API gateway sits between the client apps and the microservices.</span></span> <span data-ttu-id="e5428-165">Działa jako zwrotny serwer proxy, routing żądań od klientów do usług.</span><span class="sxs-lookup"><span data-stu-id="e5428-165">It acts as a reverse proxy, routing requests from clients to services.</span></span> <span data-ttu-id="e5428-166">Może również zapewnić dodatkowe funkcje przekrojowe, takie jak uwierzytelnianie, zakończenie protokołu SSL i pamięć podręczna.</span><span class="sxs-lookup"><span data-stu-id="e5428-166">It can also provide additional cross-cutting features such as authentication, SSL termination, and cache.</span></span>

<span data-ttu-id="e5428-167">Rysunek 4-13 pokazuje, jak niestandardowa brama interfejsu API może zmieścić się w uproszczonej architekturze opartej na mikrousługach za pomocą zaledwie kilku mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e5428-167">Figure 4-13 shows how a custom API Gateway can fit into a simplified microservice-based architecture with just a few microservices.</span></span>

![Diagram przedstawiający bramę interfejsu API zaimplementowane jako usługę niestandardową.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/custom-service-api-gateway.png)

<span data-ttu-id="e5428-169">**Rysunek 4-13**.</span><span class="sxs-lookup"><span data-stu-id="e5428-169">**Figure 4-13**.</span></span> <span data-ttu-id="e5428-170">Korzystanie z bramy interfejsu API zaimplementowane jako usługa niestandardowa</span><span class="sxs-lookup"><span data-stu-id="e5428-170">Using an API Gateway implemented as a custom service</span></span>

<span data-ttu-id="e5428-171">Aplikacje łączą się z jednym punktem końcowym, bramą interfejsu API, która jest skonfigurowana do przesyłania dalej żądań do poszczególnych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e5428-171">Apps connect to a single endpoint, the API Gateway, that's configured to forward requests to individual microservices.</span></span> <span data-ttu-id="e5428-172">W tym przykładzie brama interfejsu API zostanie zaimplementowana jako niestandardowa ASP.NET usługi Core WebHost działającej jako kontener.</span><span class="sxs-lookup"><span data-stu-id="e5428-172">In this example, the API Gateway would be implemented as a custom ASP.NET Core WebHost service running as a container.</span></span>

<span data-ttu-id="e5428-173">Ważne jest, aby podkreślić, że na tym diagramie będzie używać jednej niestandardowej usługi Bramy interfejsu API skierowanej do wielu i różnych aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="e5428-173">It's important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="e5428-174">Fakt ten może być ważnym ryzykiem, ponieważ usługa bramy interfejsu API będzie się rozwijać i ewoluować w oparciu o wiele różnych wymagań z aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="e5428-174">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="e5428-175">Ostatecznie, będzie nadęty ze względu na te różne potrzeby i skutecznie może być bardzo podobny do monolitycznego aplikacji lub usługi monolityczne.</span><span class="sxs-lookup"><span data-stu-id="e5428-175">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="e5428-176">Dlatego jest bardzo zalecane, aby podzielić bramy interfejsu API w wielu usług lub wielu mniejszych bram interfejsu API, jeden na klienta aplikacji typu czynnika formularza, na przykład.</span><span class="sxs-lookup"><span data-stu-id="e5428-176">That's why it's very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per client app form-factor type, for instance.</span></span>

<span data-ttu-id="e5428-177">Należy zachować ostrożność podczas implementowania wzorca bramy interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="e5428-177">You need to be careful when implementing the API Gateway pattern.</span></span> <span data-ttu-id="e5428-178">Zazwyczaj nie jest dobrym pomysłem, aby mieć jedną bramę interfejsu API agregujące wszystkie mikrousługi wewnętrzne aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e5428-178">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="e5428-179">Jeśli tak, działa jako monolityczny agregator lub koordynator i narusza autonomię mikrousług przez sprzężenie wszystkich mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e5428-179">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span>

<span data-ttu-id="e5428-180">W związku z tym bramy interfejsu API powinny być segregowane na podstawie granic biznesowych i aplikacji klienckich i nie działać jako pojedynczy agregator dla wszystkich mikrousług wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="e5428-180">Therefore, the API Gateways should be segregated based on business boundaries and the client apps and not act as a single aggregator for all the internal microservices.</span></span>

<span data-ttu-id="e5428-181">Podczas dzielenia warstwy bramy interfejsu API na wiele bram interfejsu API, jeśli aplikacja ma wiele aplikacji klienckich, które mogą być podstawowym punktem zwrotnym podczas identyfikowania wielu typów bram interfejsu API, dzięki czemu można mieć inną fasadę dla potrzeb każdej aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="e5428-181">When splitting the API Gateway tier into multiple API Gateways, if your application has multiple client apps, that can be a primary pivot when identifying the multiple API Gateways types, so that you can have a different facade for the needs of each client app.</span></span> <span data-ttu-id="e5428-182">W tym przypadku jest wzorzec o nazwie "Backend for Frontend"[(BFF),](https://samnewman.io/patterns/architectural/bff/)gdzie każda brama interfejsu API może zapewnić inny interfejs API dostosowany do każdego typu aplikacji klienta, prawdopodobnie nawet na podstawie formularza klienta, implementując określony kod karty, który pod wywołuje wiele mikrousług wewnętrznych, jak pokazano na poniższym obrazie:</span><span class="sxs-lookup"><span data-stu-id="e5428-182">This case is a pattern named "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) where each API Gateway can provide a different API tailored for each client app type, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices, as shown in the following image:</span></span>

![Diagram przedstawiający wiele niestandardowych bram interfejsu API.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/multiple-custom-api-gateways.png)

<span data-ttu-id="e5428-184">**Rysunek 4-13,1**.</span><span class="sxs-lookup"><span data-stu-id="e5428-184">**Figure 4-13.1**.</span></span> <span data-ttu-id="e5428-185">Korzystanie z wielu niestandardowych bram interfejsu API</span><span class="sxs-lookup"><span data-stu-id="e5428-185">Using multiple custom API Gateways</span></span>

<span data-ttu-id="e5428-186">Rysunek 4-13.1 przedstawia bramy interfejsu API, które są segregowane według typu klienta; jeden dla klientów mobilnych i jeden dla klientów internetowych.</span><span class="sxs-lookup"><span data-stu-id="e5428-186">Figure 4-13.1 shows API Gateways that are segregated by client type; one for mobile clients and one for web clients.</span></span> <span data-ttu-id="e5428-187">Tradycyjna aplikacja sieci web łączy się z mikrousługą MVC, która używa bramy interfejsu API sieci Web.</span><span class="sxs-lookup"><span data-stu-id="e5428-187">A traditional web app connects to an MVC microservice that uses the web API Gateway.</span></span> <span data-ttu-id="e5428-188">W przykładzie przedstawiono uproszczoną architekturę z wieloma szczegółowymi bramami interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="e5428-188">The example depicts a simplified architecture with multiple fine-grained API Gateways.</span></span> <span data-ttu-id="e5428-189">W takim przypadku granice zidentyfikowane dla każdej bramy interfejsu API są oparte wyłącznie na wzorzec "Backend for Frontend"[(BFF),](https://samnewman.io/patterns/architectural/bff/)dlatego oparte tylko na interfejsie API potrzebnym na aplikację klienta.</span><span class="sxs-lookup"><span data-stu-id="e5428-189">In this case, the boundaries identified for each API Gateway are based purely on the "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) pattern, hence based just on the API needed per client app.</span></span> <span data-ttu-id="e5428-190">Ale w większych aplikacjach należy również pójść dalej i utworzyć dodatkowe bramy interfejsu API na podstawie granic biznesowych jako drugiego przestawiania projektu.</span><span class="sxs-lookup"><span data-stu-id="e5428-190">But in larger applications you should also go further and create additional API Gateways based on business boundaries as a second design pivot.</span></span>

## <a name="main-features-in-the-api-gateway-pattern"></a><span data-ttu-id="e5428-191">Główne cechy wzorca bramy interfejsu API</span><span class="sxs-lookup"><span data-stu-id="e5428-191">Main features in the API Gateway pattern</span></span>

<span data-ttu-id="e5428-192">Brama interfejsu API może oferować wiele funkcji.</span><span class="sxs-lookup"><span data-stu-id="e5428-192">An API Gateway can offer multiple features.</span></span> <span data-ttu-id="e5428-193">W zależności od produktu może oferować bogatsze lub prostsze funkcje, jednak najważniejsze i podstawowe funkcje dla każdej bramy interfejsu API są następujące wzorce projektowe:</span><span class="sxs-lookup"><span data-stu-id="e5428-193">Depending on the product it might offer richer or simpler features, however, the most important and foundational features for any API Gateway are the following design patterns:</span></span>

<span data-ttu-id="e5428-194">**Odwróć routing serwera proxy lub bramy.**</span><span class="sxs-lookup"><span data-stu-id="e5428-194">**Reverse proxy or gateway routing.**</span></span> <span data-ttu-id="e5428-195">Brama interfejsu API oferuje zwrotny serwer proxy do przekierowania lub trasy żądań (warstwy 7 routingu, zwykle żądania HTTP) do punktów końcowych mikrousług wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="e5428-195">The API Gateway offers a reverse proxy to redirect or route requests (layer 7 routing, usually HTTP requests) to the endpoints of the internal microservices.</span></span> <span data-ttu-id="e5428-196">Brama udostępnia pojedynczy punkt końcowy lub adres URL dla aplikacji klienckich, a następnie wewnętrznie mapuje żądania do grupy mikrousług wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="e5428-196">The gateway provides a single endpoint or URL for the client apps and then internally maps the requests to a group of internal microservices.</span></span> <span data-ttu-id="e5428-197">Ta funkcja routingu pomaga oddzielić aplikacje klienckie od mikrousług, ale jest również dość wygodne podczas modernizacji monolitycznego interfejsu API, siedząc bramy interfejsu API pomiędzy monolitycznym interfejsem API i aplikacjami klienckimi, a następnie można dodać nowe interfejsy API jako nowe mikrousługi nadal przy użyciu starszego monolitycznego interfejsu API, dopóki nie jest podzielony na wiele mikrousług w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="e5428-197">This routing feature helps to decouple the client apps from the microservices but it's also pretty convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it's split into many microservices in the future.</span></span> <span data-ttu-id="e5428-198">Ze względu na bramę interfejsu API aplikacje klienckie nie zauważą, czy używane interfejsy API są implementowane jako wewnętrzne mikrousługi lub monolityczny interfejs API, a co ważniejsze, podczas ewoluowania i refaktoryzacji monolitycznego interfejsu API w mikrousługach, dzięki routingowi bramy interfejsu API , aplikacje klienckie nie będą miały wpływu na żadną zmianę identyfikatora URI.</span><span class="sxs-lookup"><span data-stu-id="e5428-198">Because of the API Gateway, the client apps won't notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won't be impacted with any URI change.</span></span>

<span data-ttu-id="e5428-199">Aby uzyskać więcej informacji, zobacz [Wzorzec routingu bramy](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing).</span><span class="sxs-lookup"><span data-stu-id="e5428-199">For more information, see [Gateway routing pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing).</span></span>

<span data-ttu-id="e5428-200">**Żąda agregacji.**</span><span class="sxs-lookup"><span data-stu-id="e5428-200">**Requests aggregation.**</span></span> <span data-ttu-id="e5428-201">W ramach wzorca bramy można agregować wiele żądań klientów (zwykle żądań HTTP) przeznaczonych dla wielu mikrousług wewnętrznych w jednym żądaniu klienta.</span><span class="sxs-lookup"><span data-stu-id="e5428-201">As part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request.</span></span> <span data-ttu-id="e5428-202">Ten wzorzec jest szczególnie wygodne, gdy strona klienta/ekran potrzebuje informacji z kilku mikrousług.</span><span class="sxs-lookup"><span data-stu-id="e5428-202">This pattern is especially convenient when a client page/screen needs information from several microservices.</span></span> <span data-ttu-id="e5428-203">Dzięki takiemu podejściu aplikacja klienczowa wysyła pojedyncze żądanie do bramy interfejsu API, która wysyła kilka żądań do mikrousług wewnętrznych, a następnie agreguje wyniki i wysyła wszystko z powrotem do aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="e5428-203">With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app.</span></span> <span data-ttu-id="e5428-204">Główną zaletą i celem tego wzorca projektowania jest zmniejszenie chattiness między aplikacjami klienckimi i interfejsu API zaplecza, co jest szczególnie ważne dla aplikacji zdalnych z centrum danych, w którym żyją mikrousługi, takie jak aplikacje mobilne lub żądania pochodzące z aplikacji SPA, które z JavaScript w przeglądarkach zdalnych klienta.</span><span class="sxs-lookup"><span data-stu-id="e5428-204">The main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps out of the datacenter where the microservices live, like mobile apps or requests coming from SPA apps that come from Javascript in client remote browsers.</span></span> <span data-ttu-id="e5428-205">W przypadku zwykłych aplikacji sieci Web wykonujących żądania w środowisku serwera (takich jak ASP.NET core MVC web app) ten wzorzec nie jest tak ważny, ponieważ opóźnienie jest znacznie mniejsze niż w przypadku zdalnych aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="e5428-205">For regular web apps performing the requests in the server environment (like an ASP.NET Core MVC web app), this pattern is not so important as the latency is very much smaller than for remote client apps.</span></span>

<span data-ttu-id="e5428-206">W zależności od używanego produktu bramy interfejsu API może być w stanie wykonać tę agregację.</span><span class="sxs-lookup"><span data-stu-id="e5428-206">Depending on the API Gateway product you use, it might be able to perform this aggregation.</span></span> <span data-ttu-id="e5428-207">Jednak w wielu przypadkach jest bardziej elastyczne do tworzenia mikrousług agregacji w zakresie bramy interfejsu API, więc zdefiniować agregacji w kodzie (czyli kod C#):</span><span class="sxs-lookup"><span data-stu-id="e5428-207">However, in many cases it's more flexible to create aggregation microservices under the scope of the API Gateway, so you define the aggregation in code (that is, C# code):</span></span>

<span data-ttu-id="e5428-208">Aby uzyskać więcej informacji, zobacz [Wzorzec agregacji bramy](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation).</span><span class="sxs-lookup"><span data-stu-id="e5428-208">For more information, see [Gateway aggregation pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation).</span></span>

<span data-ttu-id="e5428-209">**Problemy przekrojowe lub odciążanie bramy.**</span><span class="sxs-lookup"><span data-stu-id="e5428-209">**Cross-cutting concerns or gateway offloading.**</span></span> <span data-ttu-id="e5428-210">W zależności od funkcji oferowanych przez każdy produkt bramy interfejsu API można odciążyć funkcje z poszczególnych mikrousług do bramy, co upraszcza implementację każdej mikrousługi, konsolidując problemy przekrojowe w jednej warstwie.</span><span class="sxs-lookup"><span data-stu-id="e5428-210">Depending on the features offered by each API Gateway product, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice by consolidating cross-cutting concerns into one tier.</span></span> <span data-ttu-id="e5428-211">Jest to szczególnie wygodne w przypadku specjalistycznych funkcji, które mogą być złożone do prawidłowego wdrożenia w każdej mikrousługi wewnętrznej, takich jak następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="e5428-211">This is especially convenient for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:</span></span>

- <span data-ttu-id="e5428-212">Uwierzytelnianie i autoryzacja</span><span class="sxs-lookup"><span data-stu-id="e5428-212">Authentication and authorization</span></span>
- <span data-ttu-id="e5428-213">Integracja z odnajdowaniem usług</span><span class="sxs-lookup"><span data-stu-id="e5428-213">Service discovery integration</span></span>
- <span data-ttu-id="e5428-214">Buforowanie odpowiedzi</span><span class="sxs-lookup"><span data-stu-id="e5428-214">Response caching</span></span>
- <span data-ttu-id="e5428-215">Zasady ponawiania, wyłącznika i QoS</span><span class="sxs-lookup"><span data-stu-id="e5428-215">Retry policies, circuit breaker, and QoS</span></span>
- <span data-ttu-id="e5428-216">Ograniczanie szybkości i ograniczanie przepustowości</span><span class="sxs-lookup"><span data-stu-id="e5428-216">Rate limiting and throttling</span></span>
- <span data-ttu-id="e5428-217">Równoważenie obciążenia</span><span class="sxs-lookup"><span data-stu-id="e5428-217">Load balancing</span></span>
- <span data-ttu-id="e5428-218">Rejestrowanie, śledzenie, korelacja</span><span class="sxs-lookup"><span data-stu-id="e5428-218">Logging, tracing, correlation</span></span>
- <span data-ttu-id="e5428-219">Nagłówki, ciągi zapytań i transformacja oświadczeń</span><span class="sxs-lookup"><span data-stu-id="e5428-219">Headers, query strings, and claims transformation</span></span>
- <span data-ttu-id="e5428-220">Biała lista adresów IP</span><span class="sxs-lookup"><span data-stu-id="e5428-220">IP whitelisting</span></span>

<span data-ttu-id="e5428-221">Aby uzyskać więcej informacji, zobacz [Wzorzec odciążania bramy](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading).</span><span class="sxs-lookup"><span data-stu-id="e5428-221">For more information, see [Gateway offloading pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading).</span></span>

## <a name="using-products-with-api-gateway-features"></a><span data-ttu-id="e5428-222">Korzystanie z produktów z funkcjami bramy interfejsu API</span><span class="sxs-lookup"><span data-stu-id="e5428-222">Using products with API Gateway features</span></span>

<span data-ttu-id="e5428-223">W zależności od każdej implementacji może istnieć wiele innych problemów przekrojowych oferowanych przez produkty bramy interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="e5428-223">There can be many more cross-cutting concerns offered by the API Gateways products depending on each implementation.</span></span> <span data-ttu-id="e5428-224">Poznamy tutaj:</span><span class="sxs-lookup"><span data-stu-id="e5428-224">We'll explore here:</span></span>

- [<span data-ttu-id="e5428-225">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="e5428-225">Azure API Management</span></span>](https://azure.microsoft.com/services/api-management/)
- [<span data-ttu-id="e5428-226">Ocelot</span><span class="sxs-lookup"><span data-stu-id="e5428-226">Ocelot</span></span>](https://github.com/ThreeMammals/Ocelot)

### <a name="azure-api-management"></a><span data-ttu-id="e5428-227">Usługa Azure API Management</span><span class="sxs-lookup"><span data-stu-id="e5428-227">Azure API Management</span></span>

<span data-ttu-id="e5428-228">[Usługa Azure API Management](https://azure.microsoft.com/services/api-management/) (jak pokazano na rysunku 4-14) nie tylko rozwiązuje potrzeby bramy interfejsu API, ale zapewnia funkcje, takie jak zbieranie szczegółowych informacji z interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="e5428-228">[Azure API Management](https://azure.microsoft.com/services/api-management/) (as shown in Figure 4-14) not only solves your API Gateway needs but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="e5428-229">Jeśli używasz rozwiązania do zarządzania interfejsem API, brama interfejsu API jest tylko składnikiem w tym pełnym rozwiązaniu do zarządzania interfejsem API.</span><span class="sxs-lookup"><span data-stu-id="e5428-229">If you're using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![Diagram przedstawiający sposób korzystania z usługi Azure API Management jako bramy interfejsu API.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/api-gateway-azure-api-management.png)

<span data-ttu-id="e5428-231">**Rysunek 4-14**.</span><span class="sxs-lookup"><span data-stu-id="e5428-231">**Figure 4-14**.</span></span> <span data-ttu-id="e5428-232">Korzystanie z usługi Azure API Management dla bramy interfejsu API</span><span class="sxs-lookup"><span data-stu-id="e5428-232">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="e5428-233">Usługa Azure API Management rozwiązuje zarówno bramy interfejsu API, jak i potrzeby zarządzania, takie jak rejestrowanie, zabezpieczenia, pomiary itp. W takim przypadku podczas korzystania z produktu, takiego jak usługa Azure API Management, fakt, że możesz mieć jedną bramę interfejsu API, nie jest tak ryzykowny, ponieważ tego rodzaju bramy interfejsu API są "cieńsze", co oznacza, że nie implementujesz niestandardowego kodu C#, który może ewoluować w kierunku składnika monolitycznego.</span><span class="sxs-lookup"><span data-stu-id="e5428-233">Azure API Management solves both your API Gateway and Management needs like logging, security, metering, etc. In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span>

<span data-ttu-id="e5428-234">Produkty bramy interfejsu API zwykle działają jak zwrotny serwer proxy dla komunikacji ciągłego składania wniosków, gdzie można również filtrować interfejsy API z mikrousług wewnętrznych oraz stosować autoryzację do opublikowanych interfejsów API w tej pojedynczej warstwie.</span><span class="sxs-lookup"><span data-stu-id="e5428-234">The API Gateway products usually act like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="e5428-235">Szczegółowe informacje dostępne w systemie zarządzania interfejsami API pomagają zrozumieć, w jaki sposób są używane interfejsy API i jak działają.</span><span class="sxs-lookup"><span data-stu-id="e5428-235">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="e5428-236">Robią to, umożliwiając wyświetlanie raportów analitycznych w czasie zbliżeń w czasie rzeczywistym i identyfikowanie trendów, które mogą mieć wpływ na Twoją firmę.</span><span class="sxs-lookup"><span data-stu-id="e5428-236">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="e5428-237">Ponadto możesz mieć dzienniki dotyczące aktywności w zakresie żądań i odpowiedzi w celu dalszej analizy online i offline.</span><span class="sxs-lookup"><span data-stu-id="e5428-237">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="e5428-238">Za pomocą usługi Azure API Management można zabezpieczyć interfejsy API przy użyciu klucza, tokenu i filtrowania adresów IP.</span><span class="sxs-lookup"><span data-stu-id="e5428-238">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="e5428-239">Te funkcje umożliwiają wymuszanie elastycznych i szczegółowych przydziałów i limitów szybkości, modyfikowanie kształtu i zachowania interfejsów API przy użyciu zasad oraz zwiększanie wydajności za pomocą buforowania odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="e5428-239">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="e5428-240">W tym przewodniku i przykładowej aplikacji referencyjnej (eShopOnContainers), architektura jest ograniczona do prostszej i niestandardowej architektury konteneryzowanej, aby skupić się na zwykłych kontenerach bez używania produktów PaaS, takich jak usługa Azure API Management.</span><span class="sxs-lookup"><span data-stu-id="e5428-240">In this guide and the reference sample application (eShopOnContainers), the architecture is limited to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="e5428-241">Jednak w przypadku aplikacji opartych na dużych mikrousługach, które są wdrażane na platformie Microsoft Azure, zachęcamy do oceny usługi Azure API Management jako podstawy bram interfejsu API w środowisku produkcyjnym.</span><span class="sxs-lookup"><span data-stu-id="e5428-241">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to evaluate Azure API Management as the base for your API Gateways in production.</span></span>

### <a name="ocelot"></a><span data-ttu-id="e5428-242">Ocelot</span><span class="sxs-lookup"><span data-stu-id="e5428-242">Ocelot</span></span>

<span data-ttu-id="e5428-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) to lekka brama interfejsu API, zalecana w przypadku prostszych metod.</span><span class="sxs-lookup"><span data-stu-id="e5428-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) is a lightweight API Gateway, recommended for simpler approaches.</span></span> <span data-ttu-id="e5428-244">Ocelot jest open source .NET Core oparte bramy interfejsu API specjalnie dla architektury mikrousług, które wymagają ujednoliconych punktów wejścia do ich systemu.</span><span class="sxs-lookup"><span data-stu-id="e5428-244">Ocelot is an Open Source .NET Core based API Gateway especially made for microservices architecture that need unified points of entry into their system.</span></span> <span data-ttu-id="e5428-245">Jest lekki, szybki, skalowalny i zapewnia routing i uwierzytelnianie wśród wielu innych funkcji.</span><span class="sxs-lookup"><span data-stu-id="e5428-245">It's lightweight, fast, scalable and provides routing and authentication among many other features.</span></span>

<span data-ttu-id="e5428-246">Głównym powodem, aby wybrać Ocelot dla [aplikacji referencyjnej eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) jest, ponieważ Ocelot jest .NET Core lekka brama interfejsu API, które można wdrożyć w tym samym środowisku wdrażania aplikacji, gdzie wdrażasz mikrousług/kontenerów, takich jak Host platformy Docker, Kubernetes, itp. A ponieważ jest on oparty na .NET Core, jest to wieloplatformowa możliwość wdrażania w systemie Linux lub Windows.</span><span class="sxs-lookup"><span data-stu-id="e5428-246">The main reason to choose Ocelot for the [eShopOnContainers reference application](https://github.com/dotnet-architecture/eShopOnContainers) is because Ocelot is a .NET Core lightweight API Gateway that you can deploy into the same application deployment environment where you're deploying your microservices/containers, such as a Docker Host, Kubernetes, etc. And since it's based on .NET Core, it's cross-platform allowing you to deploy on Linux or Windows.</span></span>

<span data-ttu-id="e5428-247">Poprzednie diagramy przedstawiające niestandardowe bramy interfejsu API działające w kontenerach są dokładnie tym, jak można również uruchomić Ocelot w aplikacji opartej na kontenerach i mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="e5428-247">The previous diagrams showing custom API Gateways running in containers are precisely how you can also run Ocelot in a container and microservice-based application.</span></span>

<span data-ttu-id="e5428-248">Ponadto na rynku dostępnych jest wiele innych produktów oferujących funkcje bram API, takie jak Apigee, Kong, MuleSoft, WSO2 i inne produkty, takie jak Linkerd i Istio dla funkcji kontrolera danych przychodzących siatki serwisowej.</span><span class="sxs-lookup"><span data-stu-id="e5428-248">In addition, there are many other products in the market offering API Gateways features, such as Apigee, Kong, MuleSoft, WSO2, and other products like Linkerd and Istio for service mesh ingress controller features.</span></span>

<span data-ttu-id="e5428-249">Po początkowej architektury i wzorców wyjaśnienie sekcje, następne sekcje wyjaśnić, jak zaimplementować bramy interfejsu API z [Ocelot](https://github.com/ThreeMammals/Ocelot).</span><span class="sxs-lookup"><span data-stu-id="e5428-249">After the initial architecture and patterns explanation sections, the next sections explain how to implement API Gateways with [Ocelot](https://github.com/ThreeMammals/Ocelot).</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="e5428-250">Wady wzorca bramy interfejsu API</span><span class="sxs-lookup"><span data-stu-id="e5428-250">Drawbacks of the API Gateway pattern</span></span>

- <span data-ttu-id="e5428-251">Najważniejszą wadą jest to, że podczas implementowania bramy interfejsu API, są sprzężenia tej warstwy z mikrousług wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="e5428-251">The most important drawback is that when you implement an API Gateway, you're coupling that tier with the internal microservices.</span></span> <span data-ttu-id="e5428-252">Sprzężenie takie jak to może spowodować poważne trudności dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e5428-252">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="e5428-253">Clemens Vaster, architekt z zespołu usługi Azure Service Bus, odnosi się do tej potencjalnej trudności jako "nowy ESB" w sesji "[Wiadomości i mikrousługi](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" na GOTO 2016.</span><span class="sxs-lookup"><span data-stu-id="e5428-253">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as "the new ESB" in the "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

- <span data-ttu-id="e5428-254">Przy użyciu bramy interfejsu API mikrousług tworzy dodatkowe możliwe pojedynczy punkt awarii.</span><span class="sxs-lookup"><span data-stu-id="e5428-254">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

- <span data-ttu-id="e5428-255">Brama interfejsu API może wprowadzić zwiększony czas odpowiedzi ze względu na dodatkowe wywołanie sieciowe.</span><span class="sxs-lookup"><span data-stu-id="e5428-255">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="e5428-256">Jednak to dodatkowe wywołanie zwykle ma mniejszy wpływ niż posiadanie interfejsu klienta, który jest zbyt gadatliwy bezpośrednio wywołując mikrousług wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="e5428-256">However, this extra call usually has less impact than having a client interface that's too chatty directly calling the internal microservices.</span></span>

- <span data-ttu-id="e5428-257">Jeśli nie skalowane w sposób prawidłowy, brama interfejsu API może stać się wąskim gardłem.</span><span class="sxs-lookup"><span data-stu-id="e5428-257">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

- <span data-ttu-id="e5428-258">Brama interfejsu API wymaga dodatkowych kosztów rozwoju i przyszłej konserwacji, jeśli zawiera niestandardową logikę i agregację danych.</span><span class="sxs-lookup"><span data-stu-id="e5428-258">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="e5428-259">Deweloperzy muszą zaktualizować bramy interfejsu API w celu udostępnienia punktów końcowych każdej mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="e5428-259">Developers must update the API Gateway in order to expose each microservice's endpoints.</span></span> <span data-ttu-id="e5428-260">Ponadto zmiany implementacji w mikrousługach wewnętrznych może spowodować zmiany kodu na poziomie bramy interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="e5428-260">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="e5428-261">Jednak jeśli brama interfejsu API tylko stosuje zabezpieczenia, rejestrowanie i przechowywanie wersji (tak jak w przypadku korzystania z usługi Azure API Management), ten dodatkowy koszt rozwoju może nie zostać zastosowany.</span><span class="sxs-lookup"><span data-stu-id="e5428-261">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

- <span data-ttu-id="e5428-262">Jeśli brama interfejsu API jest rozwijany przez jeden zespół, może być wąskie gardło rozwoju.</span><span class="sxs-lookup"><span data-stu-id="e5428-262">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="e5428-263">Jest to kolejny powód, dla którego lepszym podejściem jest kilka ukaranych bram interfejsu API, które odpowiadają na różne potrzeby klientów.</span><span class="sxs-lookup"><span data-stu-id="e5428-263">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="e5428-264">Brama interfejsu API można również segregować wewnętrznie do wielu obszarów lub warstw, które są własnością różnych zespołów pracujących nad mikrousługami wewnętrznymi.</span><span class="sxs-lookup"><span data-stu-id="e5428-264">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="e5428-265">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="e5428-265">Additional resources</span></span>

- <span data-ttu-id="e5428-266">**Chris Richardson. Wzorzec: Brama interfejsu API / zaplecze frontonu** </span><span class="sxs-lookup"><span data-stu-id="e5428-266">**Chris Richardson. Pattern: API Gateway / Backend for Front-End** </span></span>\
  <https://microservices.io/patterns/apigateway.html>

- <span data-ttu-id="e5428-267">**Wzorzec bramy interfejsu API** </span><span class="sxs-lookup"><span data-stu-id="e5428-267">**API Gateway pattern** </span></span>\
  <https://docs.microsoft.com/azure/architecture/microservices/gateway>

- <span data-ttu-id="e5428-268">**Agregacja i wzorzec kompozycji** </span><span class="sxs-lookup"><span data-stu-id="e5428-268">**Aggregation and composition pattern** </span></span>\
  <https://microservices.io/patterns/data/api-composition.html>

- <span data-ttu-id="e5428-269">**Zarządzanie interfejsem API platformy Azure** </span><span class="sxs-lookup"><span data-stu-id="e5428-269">**Azure API Management** </span></span>\
  <https://azure.microsoft.com/services/api-management/>

- <span data-ttu-id="e5428-270">**Udi Dahan. Skład zorientowany na usługi** </span><span class="sxs-lookup"><span data-stu-id="e5428-270">**Udi Dahan. Service Oriented Composition** </span></span>\
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

- <span data-ttu-id="e5428-271">**Clemens Vasters. Wiadomości i mikrousługi na GOTO 2016 (wideo)** </span><span class="sxs-lookup"><span data-stu-id="e5428-271">**Clemens Vasters. Messaging and Microservices at GOTO 2016 (video)** </span></span>\
  <https://www.youtube.com/watch?v=rXi5CLjIQ9k>

- <span data-ttu-id="e5428-272">**Brama interfejsu API w skrócie** (ASP.net core API Gateway Tutorial Series) </span><span class="sxs-lookup"><span data-stu-id="e5428-272">**API Gateway in a Nutshell** (ASP.net Core API Gateway Tutorial Series) </span></span>\
  <https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html>

>[!div class="step-by-step"]
><span data-ttu-id="e5428-273">[Poprzedni](identify-microservice-domain-model-boundaries.md)
>[następny](communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="e5428-273">[Previous](identify-microservice-domain-model-boundaries.md)
[Next](communication-in-microservice-architecture.md)</span></span>
