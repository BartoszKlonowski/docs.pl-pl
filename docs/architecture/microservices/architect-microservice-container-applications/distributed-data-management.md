---
title: Problemy i rozwiązania dotyczące rozproszonego zarządzania danymi
description: Zapoznaj się z wyzwaniami i rozwiązaniami dotyczącymi rozproszonego zarządzania danymi na świecie mikrousług.
ms.date: 09/20/2018
ms.openlocfilehash: 1439dd5a04c3991a2b3b2ef12763843f9f339a29
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/24/2020
ms.locfileid: "91152654"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="56444-103">Problemy i rozwiązania dotyczące rozproszonego zarządzania danymi</span><span class="sxs-lookup"><span data-stu-id="56444-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="56444-104">Wyzwanie \# 1: sposób definiowania granic każdej mikrousługi</span><span class="sxs-lookup"><span data-stu-id="56444-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="56444-105">Definiowanie granic mikrousług jest prawdopodobnie pierwszym wyzwaniem.</span><span class="sxs-lookup"><span data-stu-id="56444-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="56444-106">Każda mikrousługa musi być częścią aplikacji, a każda mikrousługa powinna być autonomiczna ze wszystkimi korzyściami i wyzwaniami, które przekazuje.</span><span class="sxs-lookup"><span data-stu-id="56444-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="56444-107">Ale jak zidentyfikować te granice?</span><span class="sxs-lookup"><span data-stu-id="56444-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="56444-108">Najpierw należy skoncentrować się na modelach domeny logicznej aplikacji i powiązanych danych.</span><span class="sxs-lookup"><span data-stu-id="56444-108">First, you need to focus on the application's logical domain models and related data.</span></span> <span data-ttu-id="56444-109">Spróbuj zidentyfikować oddzielone Wyspy danych i różne konteksty w tej samej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="56444-109">Try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="56444-110">Każdy kontekst może mieć inny język biznesowy (różne warunki biznesowe).</span><span class="sxs-lookup"><span data-stu-id="56444-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="56444-111">Konteksty należy definiować i zarządzać niezależnie.</span><span class="sxs-lookup"><span data-stu-id="56444-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="56444-112">Warunki i jednostki, które są używane w tych różnych kontekstach mogą wyglądać podobnie, ale można je wykryć w określonym kontekście, pojęcie biznesowe z jedną z nich jest używane do innego celu w innym kontekście i może nawet mieć inną nazwę.</span><span class="sxs-lookup"><span data-stu-id="56444-112">The terms and entities that are used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="56444-113">Na przykład użytkownik może być określony jako użytkownik w kontekście tożsamości lub członkostwa, jako klient w kontekście programu CRM, jako kupujący w kontekście porządkowania i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="56444-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="56444-114">Sposób identyfikacji granic między wieloma kontekstami aplikacji z inną domeną dla każdego kontekstu to dokładne określenie granic dla każdej mikrousługi biznesowej i powiązanego modelu domeny i danych.</span><span class="sxs-lookup"><span data-stu-id="56444-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="56444-115">Zawsze należy podjąć próbę zminimalizowania sprzęgu między tymi mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="56444-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="56444-116">Ten przewodnik zawiera bardziej szczegółowe informacje o tej identyfikacji i projekcie modelu domeny w sekcji [Identyfikowanie granic modelu domeny dla każdej mikrousługi](identify-microservice-domain-model-boundaries.md) później.</span><span class="sxs-lookup"><span data-stu-id="56444-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="56444-117">Wyzwanie \# 2: jak tworzyć zapytania, które pobierają dane z kilku mikrousług</span><span class="sxs-lookup"><span data-stu-id="56444-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="56444-118">Drugim wyzwaniem jest zaimplementowanie zapytań, które pobierają dane z kilku mikrousług, jednocześnie unikając komunikacji między mikrousługami ze zdalnych aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="56444-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="56444-119">Przykładem może być pojedynczy ekran z poziomu aplikacji mobilnej, który musi zawierać informacje o użytkowniku, którego właścicielem jest koszyk, katalog i mikrousługi tożsamości użytkowników.</span><span class="sxs-lookup"><span data-stu-id="56444-119">An example could be a single screen from a mobile app that needs to show user information that's owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="56444-120">Innym przykładem jest złożony raport obejmujący wiele tabel znajdujących się w wielu mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="56444-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="56444-121">Odpowiednie rozwiązanie zależy od złożoności zapytań.</span><span class="sxs-lookup"><span data-stu-id="56444-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="56444-122">Jednak w dowolnym przypadku trzeba będzie mieć możliwość agregowania informacji, jeśli chcesz zwiększyć efektywność komunikacji w systemie.</span><span class="sxs-lookup"><span data-stu-id="56444-122">But in any case, you'll need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="56444-123">Poniżej przedstawiono najpopularniejsze rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="56444-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="56444-124">**Brama interfejsu API.**</span><span class="sxs-lookup"><span data-stu-id="56444-124">**API Gateway.**</span></span> <span data-ttu-id="56444-125">W przypadku prostej agregacji danych z wielu mikrousług należących do różnych baz danych Zalecanym podejściem jest mikrousługa agregacji, nazywana bramą interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="56444-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="56444-126">Należy jednak zachować ostrożność podczas implementowania tego wzorca, ponieważ może to być punkt podlewka w systemie i może naruszać zasadę autonomii mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="56444-127">Aby wyeliminować tę możliwość, można mieć wiele bram interfejsów API z ograniczeniami, które koncentrują się na pionowych "wycinkach" lub w obszarze roboczym systemu.</span><span class="sxs-lookup"><span data-stu-id="56444-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical "slice" or business area of the system.</span></span> <span data-ttu-id="56444-128">Wzorzec bramy interfejsu API został wyjaśniony bardziej szczegółowo w [sekcji bramy interfejsu API](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) .</span><span class="sxs-lookup"><span data-stu-id="56444-128">The API Gateway pattern is explained in more detail in the [API Gateway section](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) later.</span></span>

<span data-ttu-id="56444-129">**CQRS z tabelami zapytań/odczytów.**</span><span class="sxs-lookup"><span data-stu-id="56444-129">**CQRS with query/reads tables.**</span></span> <span data-ttu-id="56444-130">Innym rozwiązaniem do agregowania danych z wielu mikrousług jest [wzorzec widoku materiału](/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="56444-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="56444-131">W tej metodzie generowane są z góry (przygotowanie nieznormalizowanych danych przed rzeczywistymi zapytania), tabela tylko do odczytu z danymi należącymi do wielu mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that's owned by multiple microservices.</span></span> <span data-ttu-id="56444-132">Tabela ma format odpowiedni dla potrzeb aplikacji klienta.</span><span class="sxs-lookup"><span data-stu-id="56444-132">The table has a format suited to the client app's needs.</span></span>

<span data-ttu-id="56444-133">Rozważ coś takiego jak ekran aplikacji mobilnej.</span><span class="sxs-lookup"><span data-stu-id="56444-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="56444-134">Jeśli masz pojedynczą bazę danych, możesz ściągnąć dane dla tego ekranu za pomocą zapytania SQL, które wykonuje złożone sprzężenie obejmujące wiele tabel.</span><span class="sxs-lookup"><span data-stu-id="56444-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="56444-135">Jeśli jednak masz wiele baz danych, a każda baza danych jest własnością innej mikrousługi, nie można wykonać zapytania o te bazy danych i utworzyć sprzężenia SQL.</span><span class="sxs-lookup"><span data-stu-id="56444-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="56444-136">Zapytanie złożone jest wyzwaniem.</span><span class="sxs-lookup"><span data-stu-id="56444-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="56444-137">Wymagania można rozwiązać przy użyciu podejścia CQRSego — można utworzyć nieznormalizowaną tabelę w innej bazie danych, która jest używana tylko w przypadku zapytań.</span><span class="sxs-lookup"><span data-stu-id="56444-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that's used just for queries.</span></span> <span data-ttu-id="56444-138">Tabela może być zaprojektowana specjalnie dla danych, które są potrzebne dla zapytania złożonego, z relacją jeden do jednego między polami wymaganymi przez ekran aplikacji a kolumnami w tabeli zapytania.</span><span class="sxs-lookup"><span data-stu-id="56444-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application's screen and the columns in the query table.</span></span> <span data-ttu-id="56444-139">Może również być używany do celów raportowania.</span><span class="sxs-lookup"><span data-stu-id="56444-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="56444-140">Takie podejście nie tylko rozwiązuje pierwotny problem (jak wysyłać zapytania i sprzęgać je na mikrousługi), ale również znacznie zwiększa wydajność w porównaniu z złożonym sprzężeniem, ponieważ masz już dane wymagane przez aplikację w tabeli zapytań.</span><span class="sxs-lookup"><span data-stu-id="56444-140">This approach not only solves the original problem (how to query and join across microservices), but it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="56444-141">Oczywiście korzystanie z Command and Query Responsibility Segregation (CQRS) z tabelami zapytań/odczytów oznacza dodatkowe prace programistyczne i konieczność zapewnienia spójności ostatecznej.</span><span class="sxs-lookup"><span data-stu-id="56444-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you'll need to embrace eventual consistency.</span></span> <span data-ttu-id="56444-142">Niemniej jednak wymagania dotyczące wydajności i wysokiej skalowalności w [scenariuszach współpracy](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (lub scenariuszach konkurencyjnych, w zależności od punktu widzenia) to miejsce, w którym należy zastosować CQRS z wieloma bazami danych.</span><span class="sxs-lookup"><span data-stu-id="56444-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) are where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="56444-143">**"Zimne dane" w centralnych bazach danych.**</span><span class="sxs-lookup"><span data-stu-id="56444-143">**"Cold data" in central databases.**</span></span> <span data-ttu-id="56444-144">W przypadku złożonych raportów i zapytań, które mogą nie wymagać danych w czasie rzeczywistym, typowym podejściem jest wyeksportowanie "gorące dane" (dane transakcyjne z mikrousług) jako "zimne dane" do dużych baz danych, które są używane tylko na potrzeby raportowania.</span><span class="sxs-lookup"><span data-stu-id="56444-144">For complex reports and queries that might not require real-time data, a common approach is to export your "hot data" (transactional data from the microservices) as "cold data" into large databases that are used only for reporting.</span></span> <span data-ttu-id="56444-145">System centralnej bazy danych może być opartym na danych Big systemowym, takim jak Hadoop, magazynem danych, takim jak serwer, na podstawie Azure SQL Data Warehouse, a nawet z pojedynczą bazą danych SQL, która jest używana tylko do raportów (Jeśli rozmiar nie będzie problemem).</span><span class="sxs-lookup"><span data-stu-id="56444-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database that's used just for reports (if size won't be an issue).</span></span>

<span data-ttu-id="56444-146">Należy pamiętać, że ta Scentralizowana baza danych byłaby używana tylko w przypadku zapytań i raportów, które nie wymagają danych w czasie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="56444-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="56444-147">Oryginalne aktualizacje i transakcje, jako źródło prawdy, muszą znajdować się w danych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="56444-148">Aby synchronizować dane, można użyć komunikacji opartej na zdarzeniach (podanej w następnych sekcjach) lub przy użyciu innych narzędzi do importowania/eksportowania infrastruktury bazy danych.</span><span class="sxs-lookup"><span data-stu-id="56444-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="56444-149">W przypadku korzystania z komunikacji opartej na zdarzeniach proces integracji będzie podobny do sposobu propagowania danych zgodnie z wcześniejszym opisem dla tabel zapytań CQRS.</span><span class="sxs-lookup"><span data-stu-id="56444-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="56444-150">Jeśli jednak projekt aplikacji obejmuje stałe agregowanie informacji z wielu mikrousług dla złożonych zapytań, może to być objawem nieprawidłowego projektu — mikrousługa powinna być tak izolowana jak to możliwe z innych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design -a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="56444-151">(Spowoduje to wykluczenie raportów/analiz, które zawsze powinny korzystać z scentralizowanych centralnych baz danych). Występowanie tego problemu często może być przyczyną scalania mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="56444-152">Należy zrównoważyć autonomię ewolucji i wdrożenia każdej mikrousługi przy użyciu silnych zależności, spójności i agregacji danych.</span><span class="sxs-lookup"><span data-stu-id="56444-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="56444-153">Wyzwanie \# 3: sposób osiągnięcia spójności w wielu mikrousługach</span><span class="sxs-lookup"><span data-stu-id="56444-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="56444-154">Jak wspomniano wcześniej, dane należące do każdej mikrousługi są prywatne dla tej mikrousługi i można uzyskać do nich dostęp tylko przy użyciu interfejsu API mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="56444-155">Z tego względu zaprezentowano wyzwanie polegające na implementacji kompleksowych procesów firmy przy zachowaniu spójności w wielu mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="56444-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="56444-156">Aby przeanalizować ten problem, przyjrzyjmy się przykładowi z [aplikacji eShopOnContainers Reference](https://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="56444-156">To analyze this problem, let's look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="56444-157">Mikrousługa katalogu przechowuje informacje o wszystkich produktach, w tym o cenie produktu.</span><span class="sxs-lookup"><span data-stu-id="56444-157">The Catalog microservice maintains information about all the products, including the product price.</span></span> <span data-ttu-id="56444-158">Mikrousługa koszyka zarządza danymi czasowymi dotyczącymi elementów produktu, które użytkownicy są dodawani do koszyków zakupów, co obejmuje cenę elementów w momencie dodania ich do koszyka.</span><span class="sxs-lookup"><span data-stu-id="56444-158">The Basket microservice manages temporal data about product items that users are adding to their shopping baskets, which includes the price of the items at the time they were added to the basket.</span></span> <span data-ttu-id="56444-159">Gdy cena produktu jest aktualizowana w katalogu, Cena ta powinna być również aktualizowana w przypadku aktywnych koszyków, w których znajduje się ten sam produkt, a system powinien prawdopodobnie ostrzegać użytkownika o tym, że cena określonego elementu zmieniła się od dodania do koszyka.</span><span class="sxs-lookup"><span data-stu-id="56444-159">When a product's price is updated in the catalog, that price should also be updated in the active baskets that hold that same product, plus the system should probably warn the user saying that a particular item's price has changed since they added it to their basket.</span></span>

<span data-ttu-id="56444-160">W hipotetycznej wersji monolitycznej tej aplikacji po zmianie ceny w tabeli Products podsystem wykazu może po prostu użyć transakcji KWASowej do zaktualizowania bieżącej ceny w tabeli koszyka.</span><span class="sxs-lookup"><span data-stu-id="56444-160">In a hypothetical monolithic version of this application, when the price changes in the products table, the catalog subsystem could simply use an ACID transaction to update the current price in the Basket table.</span></span>

<span data-ttu-id="56444-161">Jednak w aplikacji opartej na mikrousługach tabele produktów i koszyka są własnością odpowiednich mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-161">However, in a microservices-based application, the Product and Basket tables are owned by their respective microservices.</span></span> <span data-ttu-id="56444-162">Żadna mikrousługa nie powinna obejmować tabel/magazynów należących do innej mikrousług w swoich własnych transakcjach, a nie nawet zapytań bezpośrednich, jak pokazano na rysunku 4-9.</span><span class="sxs-lookup"><span data-stu-id="56444-162">No microservice should ever include tables/storage owned by another microservice in its own transactions, not even in direct queries, as shown in Figure 4-9.</span></span>

![Diagram przedstawiający, że dane bazy danych mikrousług nie mogą być udostępniane.](./media/distributed-data-management/indepentent-microservice-databases.png)

<span data-ttu-id="56444-164">**Rysunek 4-9**.</span><span class="sxs-lookup"><span data-stu-id="56444-164">**Figure 4-9**.</span></span> <span data-ttu-id="56444-165">Mikrousługa nie może bezpośrednio uzyskać dostępu do tabeli w innej mikrousłudze</span><span class="sxs-lookup"><span data-stu-id="56444-165">A microservice can't directly access a table in another microservice</span></span>

<span data-ttu-id="56444-166">Mikrousługa katalogu nie powinna aktualizować tabeli koszyka bezpośrednio, ponieważ jest ona własnością usługi koszyka.</span><span class="sxs-lookup"><span data-stu-id="56444-166">The Catalog microservice shouldn't update the Basket table directly, because the Basket table is owned by the Basket microservice.</span></span> <span data-ttu-id="56444-167">Aby przeprowadzić aktualizację mikrousługi koszyka, usługa Catalog powinna korzystać z spójności ostatecznej na podstawie komunikacji asynchronicznej, takiej jak zdarzenia integracji (komunikacja oparta na komunikatach i zdarzeniach).</span><span class="sxs-lookup"><span data-stu-id="56444-167">To make an update to the Basket microservice, the Catalog microservice should use eventual consistency probably based on asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="56444-168">Jest to sposób, w jaki aplikacja referencyjna [eShopOnContainers](https://aka.ms/eshoponcontainers) wykonuje ten typ spójności na mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="56444-168">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of consistency across microservices.</span></span>

<span data-ttu-id="56444-169">Jak określono w [theorem Cap](https://en.wikipedia.org/wiki/CAP_theorem), należy wybrać między dostępnością a silną SPÓJNOŚCIą kwaśną.</span><span class="sxs-lookup"><span data-stu-id="56444-169">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="56444-170">Większość scenariuszy opartych na mikrousługach wymaga dostępności i wysokiej skalowalności w przeciwieństwie do silnej spójności.</span><span class="sxs-lookup"><span data-stu-id="56444-170">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="56444-171">Aplikacje o znaczeniu krytycznym muszą pozostać w działaniu, a deweloperzy mogą obejść silną spójność przy użyciu technik do pracy z słabą lub bezprawną spójnością.</span><span class="sxs-lookup"><span data-stu-id="56444-171">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="56444-172">Jest to podejście podejmowane przez większość architektur opartych na mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="56444-172">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="56444-173">Ponadto w przypadku transakcji zatwierdzania w stylu KWASowym lub dwufazowym nie są one bezpośrednio związane z zasadami mikrousług. Większość baz danych NoSQL (takich jak Azure Cosmos DB, MongoDB itp.) nie obsługuje transakcji zatwierdzania dwuetapowego, typowych w scenariuszach dystrybuowanych baz danych.</span><span class="sxs-lookup"><span data-stu-id="56444-173">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions, typical in distributed databases scenarios.</span></span> <span data-ttu-id="56444-174">Jednak zachowanie spójności danych w ramach usług i baz danych jest niezbędne.</span><span class="sxs-lookup"><span data-stu-id="56444-174">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="56444-175">To wyzwanie jest również powiązane z pytaniem, jak propagować zmiany w wielu mikrousługach, gdy pewne dane muszą być nadmiarowe — na przykład, gdy trzeba mieć nazwę lub opis produktu w mikrousłudze katalogu i mikrousługi koszyka.</span><span class="sxs-lookup"><span data-stu-id="56444-175">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product's name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="56444-176">Dobrym rozwiązaniem dla tego problemu jest użycie ostatecznej spójności między mikrousługami przegubowymi przy użyciu komunikacji opartej na zdarzeniach i systemu publikowania i subskrybowania.</span><span class="sxs-lookup"><span data-stu-id="56444-176">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="56444-177">Te tematy zostały omówione w sekcji [asynchroniczna komunikacja oparta na zdarzeniach](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) w dalszej części tego przewodnika.</span><span class="sxs-lookup"><span data-stu-id="56444-177">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="56444-178">Wyzwanie \# 4: projektowanie komunikacji między granicami mikrousług</span><span class="sxs-lookup"><span data-stu-id="56444-178">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="56444-179">Komunikacja między granicami mikrousług jest rzeczywistym wyzwaniem.</span><span class="sxs-lookup"><span data-stu-id="56444-179">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="56444-180">W tym kontekście komunikacja nie odnosi się do używanego protokołu (HTTP i REST, AMQP, Messaging itd.).</span><span class="sxs-lookup"><span data-stu-id="56444-180">In this context, communication doesn't refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="56444-181">Zamiast tego określa styl komunikacji, który powinien być używany, a zwłaszcza na to, jak to mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="56444-181">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="56444-182">W zależności od poziomu sprzęgu, gdy wystąpi awaria, wpływ tego błędu na system różni się znacznie.</span><span class="sxs-lookup"><span data-stu-id="56444-182">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="56444-183">W systemie rozproszonym, takim jak aplikacja oparta na mikrousługach, dzięki czemu wiele artefaktów porusza się wokół i z rozproszonymi usługami na wielu serwerach lub hostach, składniki zakończą się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="56444-183">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="56444-184">Wystąpiły częściowe awarie i jeszcze większe przestoje, dlatego należy zaprojektować mikrousługi i komunikować się między nimi, biorąc pod uwagę typowe zagrożenia w tym typie rozproszonego systemu.</span><span class="sxs-lookup"><span data-stu-id="56444-184">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them considering the common risks in this type of distributed system.</span></span>

<span data-ttu-id="56444-185">Popularnym podejściem jest implementowanie mikrousług opartych na protokole HTTP (REST), ze względu na ich prostotę.</span><span class="sxs-lookup"><span data-stu-id="56444-185">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="56444-186">Podejście oparte na protokole HTTP jest doskonale akceptowalne; Ten problem jest związany z używaniem go.</span><span class="sxs-lookup"><span data-stu-id="56444-186">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="56444-187">W przypadku korzystania z żądań i odpowiedzi HTTP tylko w celu współdziałania z mikrousługami z aplikacji klienckich lub bram interfejsu API jest to dokładne.</span><span class="sxs-lookup"><span data-stu-id="56444-187">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that's fine.</span></span> <span data-ttu-id="56444-188">Ale jeśli utworzysz długie łańcuchy synchronicznych wywołań HTTP na mikrousługach, komunikuje się w zależności od tego, czy mikrousługi były obiektami w aplikacji monolitycznej, aplikacja zostanie ostatecznie uruchomiona.</span><span class="sxs-lookup"><span data-stu-id="56444-188">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="56444-189">Załóżmy na przykład, że aplikacja kliencka wysyła wywołanie interfejsu API protokołu HTTP do pojedynczej mikrousługi, takiej jak mikrousługa porządkowania.</span><span class="sxs-lookup"><span data-stu-id="56444-189">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="56444-190">Jeśli mikrousługa porządkowania w programie umożliwia wywoływanie dodatkowych mikrousług przy użyciu protokołu HTTP w ramach tego samego cyklu żądania/odpowiedzi, tworzysz łańcuch wywołań HTTP.</span><span class="sxs-lookup"><span data-stu-id="56444-190">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you're creating a chain of HTTP calls.</span></span> <span data-ttu-id="56444-191">Może to być rozsądnie uzasadnione.</span><span class="sxs-lookup"><span data-stu-id="56444-191">It might sound reasonable initially.</span></span> <span data-ttu-id="56444-192">Istnieją jednak ważne kwestie, które należy wziąć pod uwagę podczas przechodzenia do tej ścieżki:</span><span class="sxs-lookup"><span data-stu-id="56444-192">However, there are important points to consider when going down this path:</span></span>

- <span data-ttu-id="56444-193">Blokowanie i niska wydajność.</span><span class="sxs-lookup"><span data-stu-id="56444-193">Blocking and low performance.</span></span> <span data-ttu-id="56444-194">Ze względu na synchroniczny charakter protokołu HTTP oryginalne żądanie nie otrzymuje odpowiedzi, dopóki nie zostaną zakończone wszystkie wewnętrzne wywołania HTTP.</span><span class="sxs-lookup"><span data-stu-id="56444-194">Due to the synchronous nature of HTTP, the original request doesn't get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="56444-195">Załóżmy, że liczba tych wywołań rośnie znacznie i w tym samym czasie jedno z pośrednich wywołań HTTP do mikrousługi jest blokowane.</span><span class="sxs-lookup"><span data-stu-id="56444-195">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="56444-196">Jest to wpływ na wydajność, a ogólna skalowalność będzie miała wykładniczy wpływ na wzrost liczby żądań HTTP.</span><span class="sxs-lookup"><span data-stu-id="56444-196">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

- <span data-ttu-id="56444-197">Mikrousługi sprzęgające przy użyciu protokołu HTTP.</span><span class="sxs-lookup"><span data-stu-id="56444-197">Coupling microservices with HTTP.</span></span> <span data-ttu-id="56444-198">Mikrousługi biznesowe nie powinny być połączone z innymi mikrousługami biznesowymi.</span><span class="sxs-lookup"><span data-stu-id="56444-198">Business microservices shouldn't be coupled with other business microservices.</span></span> <span data-ttu-id="56444-199">W idealnym przypadku nie należy wiedzieć o istnieniu innych mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-199">Ideally, they shouldn't "know" about the existence of other microservices.</span></span> <span data-ttu-id="56444-200">Jeśli aplikacja korzysta z mikrousług sprzęgania, jak w przykładzie, osiągnięcie autonomii na mikrousług będzie niemal niemożliwe.</span><span class="sxs-lookup"><span data-stu-id="56444-200">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

- <span data-ttu-id="56444-201">Niepowodzenie w żadnej z mikrousług.</span><span class="sxs-lookup"><span data-stu-id="56444-201">Failure in any one microservice.</span></span> <span data-ttu-id="56444-202">W przypadku zaimplementowania łańcucha mikrousług połączonych przez wywołania HTTP, gdy dowolne mikrousługi nie powiedzie się (i ostatecznie nie będą działać), cały łańcuch mikrousług zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="56444-202">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="56444-203">Systemy oparte na mikrousługach powinny być przeznaczone do dalszej pracy, a także w przypadku awarii częściowych.</span><span class="sxs-lookup"><span data-stu-id="56444-203">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="56444-204">Nawet w przypadku implementowania logiki klienta, która używa ponowień w ramach funkcji wykładniczych wycofywania lub wyłączników, bardziej skomplikowane łańcuchy wywołań HTTP to bardziej skomplikowany sposób implementacji strategii niepowodzeń na podstawie protokołu HTTP.</span><span class="sxs-lookup"><span data-stu-id="56444-204">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is to implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="56444-205">W rzeczywistości, jeśli wewnętrzne mikrousługi komunikują się przez tworzenie łańcuchów żądań HTTP zgodnie z opisem, można zatwierdzić, że masz wbudowaną aplikację, ale jedną opartą na protokole HTTP między procesami.</span><span class="sxs-lookup"><span data-stu-id="56444-205">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intra-process communication mechanisms.</span></span>

<span data-ttu-id="56444-206">W związku z tym w celu wymuszenia autonomii mikrousług i uzyskania lepszej odporności należy zminimalizować wykorzystanie łańcuchów komunikacji żądania/odpowiedzi między mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="56444-206">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="56444-207">Zaleca się używać tylko asynchronicznej interakcji w przypadku komunikacji między mikrousługami przy użyciu asynchronicznej komunikacji komunikatów i zdarzeń albo za pomocą (asynchroniczne) sondowania HTTP niezależnie od oryginalnego żądania HTTP/cyklu odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="56444-207">It's recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="56444-208">Korzystanie z komunikacji asynchronicznej jest wyjaśnione z dodatkowymi szczegółami w dalszej części tego przewodnika w sekcjach [asynchronicznej integracji mikrousług wymusza międzyusługową](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) i [asynchroniczną komunikację opartą na komunikatach](asynchronous-message-based-communication.md).</span><span class="sxs-lookup"><span data-stu-id="56444-208">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice's autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="56444-209">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="56444-209">Additional resources</span></span>

- <span data-ttu-id="56444-210">**Theorem CAP** </span><span class="sxs-lookup"><span data-stu-id="56444-210">**CAP theorem** </span></span>\
  <https://en.wikipedia.org/wiki/CAP_theorem>

- <span data-ttu-id="56444-211">**Spójność ostateczna** </span><span class="sxs-lookup"><span data-stu-id="56444-211">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="56444-212">**Podstawy spójności danych** </span><span class="sxs-lookup"><span data-stu-id="56444-212">**Data Consistency Primer** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)>

- <span data-ttu-id="56444-213">**Fowlera Martin. CQRS (Command and Query Responsibility Segregation)** </span><span class="sxs-lookup"><span data-stu-id="56444-213">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)** </span></span>\
  <https://martinfowler.com/bliki/CQRS.html>

- <span data-ttu-id="56444-214">**Widok z materiałami** </span><span class="sxs-lookup"><span data-stu-id="56444-214">**Materialized View** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/materialized-view>

- <span data-ttu-id="56444-215">**Charles wiersz. Kwas a BASE: przesunięcie pH przetwarzania transakcji bazy danych** </span><span class="sxs-lookup"><span data-stu-id="56444-215">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing** </span></span>\
  <https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/>

- <span data-ttu-id="56444-216">**Kompensowanie transakcji** </span><span class="sxs-lookup"><span data-stu-id="56444-216">**Compensating Transaction** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction>

- <span data-ttu-id="56444-217">**UDI Dahan. Składowe zorientowane na usługę** </span><span class="sxs-lookup"><span data-stu-id="56444-217">**Udi Dahan. Service Oriented Composition** </span></span>\
  <https://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

>[!div class="step-by-step"]
><span data-ttu-id="56444-218">[Poprzedni](logical-versus-physical-architecture.md) 
> [Dalej](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="56444-218">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
