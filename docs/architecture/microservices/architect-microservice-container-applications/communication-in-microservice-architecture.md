---
title: Komunikacja w ramach architektury mikrousługi
description: Poznaj różne sposoby komunikacji między mikrousługami, zrozumienie implikacji synchronicznych i asynchronicznych sposobów.
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401656"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="a71ea-103">Komunikacja w ramach architektury mikrousługi</span><span class="sxs-lookup"><span data-stu-id="a71ea-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="a71ea-104">W aplikacji monolityczne uruchomionej w jednym procesie składniki wywołać siebie za pomocą metody na poziomie języka lub wywołania funkcji.</span><span class="sxs-lookup"><span data-stu-id="a71ea-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="a71ea-105">Mogą one być silnie sprzężona, jeśli tworzysz `new ClassName()`obiekty z kodem (na przykład), lub mogą być wywoływane w sposób niepowiązanych, jeśli używasz iniekcji zależności, odwołując się abstrakcje, a nie wystąpienia konkretnych obiektów.</span><span class="sxs-lookup"><span data-stu-id="a71ea-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="a71ea-106">Tak czy inaczej, obiekty są uruchomione w ramach tego samego procesu.</span><span class="sxs-lookup"><span data-stu-id="a71ea-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="a71ea-107">Największym wyzwaniem podczas zmiany z aplikacji monolityczne do aplikacji opartej na mikrousługach polega na zmianie mechanizmu komunikacji.</span><span class="sxs-lookup"><span data-stu-id="a71ea-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="a71ea-108">Bezpośrednia konwersja z wywołań metody w procesie do wywołań RPC do usług spowoduje chatty i nie efektywnej komunikacji, która nie będzie działać dobrze w środowiskach rozproszonych.</span><span class="sxs-lookup"><span data-stu-id="a71ea-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="a71ea-109">Wyzwania związane z projektowaniem rozproszonego systemu są na tyle dobrze znane, że istnieje nawet kanon znany jako [Błędy rozproszonego przetwarzania,](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) który wymienia założenia, które deweloperzy często przyjmują podczas przechodzenia z monolitycznych do rozproszonych projektów.</span><span class="sxs-lookup"><span data-stu-id="a71ea-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="a71ea-110">Nie ma jednego rozwiązania, ale kilka.</span><span class="sxs-lookup"><span data-stu-id="a71ea-110">There isn't one solution, but several.</span></span> <span data-ttu-id="a71ea-111">Jedno rozwiązanie polega na izolowaniu mikrousług biznesowych, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="a71ea-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="a71ea-112">Następnie należy użyć komunikacji asynchronicznej między mikrousług wewnętrznych i zastąpić komunikację drobnoziarnistą, która jest typowa w komunikacji wewnątrz procesu między obiektami z grubsze ziarnistej komunikacji.</span><span class="sxs-lookup"><span data-stu-id="a71ea-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="a71ea-113">Można to zrobić przez grupowanie wywołań i zwracanie danych, które agreguje wyniki wielu wywołań wewnętrznych, do klienta.</span><span class="sxs-lookup"><span data-stu-id="a71ea-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="a71ea-114">Aplikacja oparta na mikrousługach jest systemem rozproszonym działana na wielu procesach lub usługach, zwykle nawet na wielu serwerach lub hostach.</span><span class="sxs-lookup"><span data-stu-id="a71ea-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="a71ea-115">Każde wystąpienie usługi jest zazwyczaj procesem.</span><span class="sxs-lookup"><span data-stu-id="a71ea-115">Each service instance is typically a process.</span></span> <span data-ttu-id="a71ea-116">W związku z tym usługi muszą współdziałać przy użyciu protokołu komunikacji między procesami, takich jak HTTP, AMQP lub protokołu binarnego, takich jak TCP, w zależności od charakteru każdej usługi.</span><span class="sxs-lookup"><span data-stu-id="a71ea-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="a71ea-117">Społeczność mikrousług promuje filozofię "[inteligentnych punktów końcowych i niepomyte potoki](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" To hasło zachęca projekt, który jest tak oddzielone, jak to możliwe między mikrousług i jak bardziej zgodne, jak to możliwe w ramach jednej mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="a71ea-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="a71ea-118">Jak wyjaśniono wcześniej, każda mikrousługa jest właścicielem własnych danych i własnej logiki domeny.</span><span class="sxs-lookup"><span data-stu-id="a71ea-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="a71ea-119">Jednak mikrousługi tworzące aplikację end-to-end są zwykle po prostu choreografia przy użyciu\* komunikacji REST, a nie złożonych protokołów, takich jak WS- i elastyczne zdarzenia oparte na komunikacji zamiast scentralizowanych procesów biznesowych-orchestrators.</span><span class="sxs-lookup"><span data-stu-id="a71ea-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="a71ea-120">Dwa często używane protokoły są żądanie HTTP/odpowiedź z interfejsami API zasobów (podczas wykonywania zapytań przede wszystkim) i lekkich komunikatów asynchronicznych podczas przekazywania aktualizacji w wielu mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="a71ea-121">Są one wyjaśnione bardziej szczegółowo w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="a71ea-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="a71ea-122">Typy komunikacji</span><span class="sxs-lookup"><span data-stu-id="a71ea-122">Communication types</span></span>

<span data-ttu-id="a71ea-123">Klient i usługi mogą komunikować się za pośrednictwem wielu różnych typów komunikacji, z których każdy jest przeznaczony dla innego scenariusza i celów.</span><span class="sxs-lookup"><span data-stu-id="a71ea-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="a71ea-124">Początkowo tego typu komunikaty można sklasyfikować na dwóch osiach.</span><span class="sxs-lookup"><span data-stu-id="a71ea-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="a71ea-125">Pierwsza oś określa, czy protokół jest synchroniczny lub asynchroniczny:</span><span class="sxs-lookup"><span data-stu-id="a71ea-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="a71ea-126">protokół synchroniczny.</span><span class="sxs-lookup"><span data-stu-id="a71ea-126">Synchronous protocol.</span></span> <span data-ttu-id="a71ea-127">HTTP jest protokołem synchronicznym.</span><span class="sxs-lookup"><span data-stu-id="a71ea-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="a71ea-128">Klient wysyła żądanie i czeka na odpowiedź z usługi.</span><span class="sxs-lookup"><span data-stu-id="a71ea-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="a71ea-129">To jest niezależne od wykonania kodu klienta, które mogą być synchroniczne (wątek jest zablokowany) lub asynchroniczne (wątek nie jest zablokowany, a odpowiedź zostanie ostatecznie dotrzeć do wywołania wywołania.</span><span class="sxs-lookup"><span data-stu-id="a71ea-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="a71ea-130">Ważną kwestią jest to, że protokół (HTTP/HTTPS) jest synchroniczny, a kod klienta może kontynuować swoje zadanie tylko po odebraniu odpowiedzi serwera HTTP.</span><span class="sxs-lookup"><span data-stu-id="a71ea-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="a71ea-131">Protokół asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="a71ea-131">Asynchronous protocol.</span></span> <span data-ttu-id="a71ea-132">Inne protokoły, takie jak AMQP (protokół obsługiwany przez wiele systemów operacyjnych i środowisk w chmurze) używają komunikatów asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="a71ea-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="a71ea-133">Kod klienta lub nadawca wiadomości zwykle nie czeka na odpowiedź.</span><span class="sxs-lookup"><span data-stu-id="a71ea-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="a71ea-134">Po prostu wysyła wiadomość, jak podczas wysyłania wiadomości do kolejki RabbitMQ lub innego brokera wiadomości.</span><span class="sxs-lookup"><span data-stu-id="a71ea-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="a71ea-135">Druga oś określa, czy komunikacja ma jeden odbiornik lub wiele odbiorników:</span><span class="sxs-lookup"><span data-stu-id="a71ea-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="a71ea-136">Pojedynczy odbiornik.</span><span class="sxs-lookup"><span data-stu-id="a71ea-136">Single receiver.</span></span> <span data-ttu-id="a71ea-137">Każde żądanie musi być przetworzone przez dokładnie jeden odbiornik lub usługę.</span><span class="sxs-lookup"><span data-stu-id="a71ea-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="a71ea-138">Przykładem tej komunikacji jest [wzorzec polecenia](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="a71ea-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="a71ea-139">Wiele odbiorników.</span><span class="sxs-lookup"><span data-stu-id="a71ea-139">Multiple receivers.</span></span> <span data-ttu-id="a71ea-140">Każde żądanie może być przetwarzane przez zero do wielu odbiorników.</span><span class="sxs-lookup"><span data-stu-id="a71ea-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="a71ea-141">Ten typ komunikacji musi być asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="a71ea-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="a71ea-142">Przykładem jest mechanizm [publikowania/subskrybowania](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) używany w wzorcach, takich jak [architektura sterna zdarzeniami.](https://microservices.io/patterns/data/event-driven-architecture.html)</span><span class="sxs-lookup"><span data-stu-id="a71ea-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="a71ea-143">Jest to oparte na interfejsie magistrali zdarzeń lub brokera komunikatów podczas propagowania aktualizacji danych między wieloma mikrousługami za pośrednictwem zdarzeń; jest zwykle implementowane za pośrednictwem magistrali usług lub podobnego artefaktu, takiego jak [usługa Azure Service Bus](https://azure.microsoft.com/services/service-bus/) przy użyciu [tematów i subskrypcji.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)</span><span class="sxs-lookup"><span data-stu-id="a71ea-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="a71ea-144">Aplikacja oparta na mikrousługach często używa kombinacji tych stylów komunikacji.</span><span class="sxs-lookup"><span data-stu-id="a71ea-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="a71ea-145">Najczęstszym typem jest komunikacja z jednym odbiorcą z protokołem synchronicznym, takim jak HTTP/HTTPS podczas wywoływania zwykłej usługi HTTP interfejsu API sieci Web.</span><span class="sxs-lookup"><span data-stu-id="a71ea-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="a71ea-146">Mikrousługi zazwyczaj używają protokołów obsługi wiadomości do komunikacji asynchronicznej między mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="a71ea-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="a71ea-147">Te osie są dobre wiedzieć, więc masz jasność co do możliwych mechanizmów komunikacji, ale nie są one ważne problemy podczas tworzenia mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="a71ea-148">Ani asynchroniczny charakter wykonywania wątku klienta, ani asynchroniczny charakter wybranego protokołu nie są ważnymi punktami podczas integracji mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="a71ea-149">Co *jest* ważne jest możliwość integracji mikrousług asynchronicznie przy zachowaniu niezależności mikrousług, jak wyjaśniono w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="a71ea-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="a71ea-150">Integracja mikrousług asynchronicznych wymusza autonomię mikrousługi</span><span class="sxs-lookup"><span data-stu-id="a71ea-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="a71ea-151">Jak wspomniano, ważnym punktem podczas tworzenia aplikacji opartej na mikrousługach jest sposób integracji mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="a71ea-152">W idealnym przypadku należy spróbować zminimalizować komunikację między mikrousług wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="a71ea-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="a71ea-153">Im mniej komunikacji między mikrousługami, tym lepiej.</span><span class="sxs-lookup"><span data-stu-id="a71ea-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="a71ea-154">Ale w wielu przypadkach trzeba będzie jakoś zintegrować mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="a71ea-155">Gdy trzeba to zrobić, krytyczną regułą w tym miejscu jest, że komunikacja między mikrousług ami powinny być asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="a71ea-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="a71ea-156">Nie oznacza to, że trzeba użyć określonego protokołu (na przykład asynchronicznego przesyłania wiadomości w porównaniu z synchronicznym protokołem HTTP).</span><span class="sxs-lookup"><span data-stu-id="a71ea-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="a71ea-157">Oznacza to po prostu, że komunikacja między mikrousługami powinna odbywać się tylko przez propagowanie danych asynchronicznie, ale staraj się nie polegać na innych mikrousług wewnętrznych jako część operacji żądania/odpowiedzi HTTP usługi początkowej.</span><span class="sxs-lookup"><span data-stu-id="a71ea-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="a71ea-158">Jeśli to możliwe, nigdy nie zależą od komunikacji synchronicznej (żądanie/odpowiedź) między wieloma mikrousługami, nawet dla zapytań.</span><span class="sxs-lookup"><span data-stu-id="a71ea-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="a71ea-159">Celem każdej mikrousługi ma być autonomiczne i dostępne dla konsumenta klienta, nawet jeśli inne usługi, które są częścią aplikacji end-to-end są w dół lub w złej kondycji.</span><span class="sxs-lookup"><span data-stu-id="a71ea-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="a71ea-160">Jeśli uważasz, że trzeba nawiązać wywołanie z jednej mikrousługi do innych mikrousług (takich jak wykonywanie żądania HTTP dla zapytania danych), aby móc zapewnić odpowiedź na aplikację kliencką, masz architekturę, która nie będzie odporna, gdy niektóre mikrousługi nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="a71ea-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="a71ea-161">Ponadto o zależności HTTP między mikrousługami, jak podczas tworzenia długich żądań/odpowiedzi cykli z łańcuchami żądań HTTP, jak pokazano w pierwszej części rysunku 4-15, nie tylko sprawia, że mikrousługi nie autonomiczne, ale także ich wydajność ma wpływ, jak tylko jedna z usług w tym łańcuchu nie działa dobrze.</span><span class="sxs-lookup"><span data-stu-id="a71ea-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="a71ea-162">Im więcej można dodać synchroniczne zależności między mikrousługami, takich jak żądania zapytań, tym gorszy ogólny czas odpowiedzi pobiera dla aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="a71ea-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![Diagram przedstawiający trzy typy komunikacji między mikrousługami.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="a71ea-164">**Rysunek 4-15**.</span><span class="sxs-lookup"><span data-stu-id="a71ea-164">**Figure 4-15**.</span></span> <span data-ttu-id="a71ea-165">Anti-wzorce i wzorce w komunikacji między mikrousługami</span><span class="sxs-lookup"><span data-stu-id="a71ea-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="a71ea-166">Jak pokazano na powyższym diagramie, w komunikacji synchronicznej "łańcuch" żądań jest tworzony między mikrousług podczas obsługi żądania klienta.</span><span class="sxs-lookup"><span data-stu-id="a71ea-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="a71ea-167">Jest to anty-wzór.</span><span class="sxs-lookup"><span data-stu-id="a71ea-167">This is an anti-pattern.</span></span> <span data-ttu-id="a71ea-168">W mikrousługach komunikacji asynchronicznej użyj komunikatów asynchronicznych lub sondowania http do komunikowania się z innymi mikrousługami, ale żądanie klienta jest obsługiwane od razu.</span><span class="sxs-lookup"><span data-stu-id="a71ea-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="a71ea-169">Jeśli mikrousługi musi podnieść dodatkową akcję w innej mikrousługi, jeśli to możliwe, nie należy wykonywać tej akcji synchronicznie i jako część oryginalnego żądania mikrousługi i operacji odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="a71ea-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="a71ea-170">Zamiast tego zrób to asynchronicznie (przy użyciu asynchronicznych komunikatów lub zdarzeń integracji, kolejek itp.).</span><span class="sxs-lookup"><span data-stu-id="a71ea-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="a71ea-171">Jednak w miarę możliwości nie należy wywoływać akcji synchronicznie jako część oryginalnego synchronicznego żądania i operacji odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="a71ea-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="a71ea-172">I na koniec (i to jest, gdy większość problemów pojawiają się podczas tworzenia mikrousług), jeśli początkowemikrousługi wymaga danych, które są pierwotnie własnością innych mikrousług, nie polegać na dokonywanie synchroniczne żądania dla tych danych.</span><span class="sxs-lookup"><span data-stu-id="a71ea-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="a71ea-173">Zamiast tego replikuj lub propagować te dane (tylko potrzebne atrybuty) do bazy danych usługi początkowej przy użyciu spójności ostatecznej (zazwyczaj przy użyciu zdarzeń integracji, jak wyjaśniono w nadchodzących sekcjach).</span><span class="sxs-lookup"><span data-stu-id="a71ea-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="a71ea-174">Jak wspomniano wcześniej w identyfikacji granic modelu domeny dla każdej sekcji [mikrousługi,](identify-microservice-domain-model-boundaries.md) powielanie niektórych danych w kilku mikrousług nie jest niepoprawny projekt — wręcz przeciwnie, podczas wykonywania, że można przetłumaczyć dane na określony język lub warunki tej dodatkowej domeny lub ograniczony kontekst.</span><span class="sxs-lookup"><span data-stu-id="a71ea-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="a71ea-175">Na przykład w [aplikacji eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) masz mikrousługę o nazwie, `identity-api` która jest odpowiedzialna za większość `User`danych użytkownika z jednostką o nazwie .</span><span class="sxs-lookup"><span data-stu-id="a71ea-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="a71ea-176">Jednak gdy trzeba przechowywać dane o `Ordering` użytkowniku w mikrousługi, należy `Buyer`przechowywać go jako inną jednostkę o nazwie .</span><span class="sxs-lookup"><span data-stu-id="a71ea-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="a71ea-177">Jednostka `Buyer` udostępnia tę samą `User` tożsamość oryginalnej jednostce, ale może mieć `Ordering` tylko kilka atrybutów wymaganych przez domenę, a nie cały profil użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a71ea-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="a71ea-178">Można użyć dowolnego protokołu do komunikowania się i propagacji danych asynchronicznie przez mikrousług w celu uzyskania spójności ostatecznej.</span><span class="sxs-lookup"><span data-stu-id="a71ea-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="a71ea-179">Jak wspomniano, można użyć zdarzeń integracji przy użyciu magistrali zdarzeń lub brokera komunikatów lub można nawet użyć protokołu HTTP, sondując inne usługi zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="a71ea-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="a71ea-180">To nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="a71ea-180">It doesn't matter.</span></span> <span data-ttu-id="a71ea-181">Ważną zasadą jest, aby nie tworzyć synchroniczne zależności między mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="a71ea-182">W poniższych sekcjach wyjaśniono wiele stylów komunikacji, które można rozważyć przy użyciu w aplikacji opartej na mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="a71ea-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="a71ea-183">Style komunikacji</span><span class="sxs-lookup"><span data-stu-id="a71ea-183">Communication styles</span></span>

<span data-ttu-id="a71ea-184">Istnieje wiele protokołów i opcji, których można używać do komunikacji, w zależności od typu komunikacji, którego chcesz użyć.</span><span class="sxs-lookup"><span data-stu-id="a71ea-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="a71ea-185">Jeśli używasz synchronicznego mechanizmu komunikacji opartego na żądaniu/odpowiedzi, protokoły, takie jak podejścia HTTP i REST, są najczęściej, szczególnie jeśli publikujesz swoje usługi poza hostem platformy Docker lub klastrem mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="a71ea-186">Jeśli komunikujesz się między usługami wewnętrznie (w obrębie hosta platformy Docker lub klastra mikrousług), można również użyć mechanizmów komunikacji w formacie binarnym (takich jak WCF przy użyciu protokołu TCP i formatu binarnego).</span><span class="sxs-lookup"><span data-stu-id="a71ea-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="a71ea-187">Alternatywnie można użyć asynchronicznych, opartych na komunikatach mechanizmów komunikacji, takich jak AMQP.</span><span class="sxs-lookup"><span data-stu-id="a71ea-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="a71ea-188">Istnieje również wiele formatów wiadomości, takich jak JSON lub XML, a nawet formatów binarnych, które mogą być bardziej wydajne.</span><span class="sxs-lookup"><span data-stu-id="a71ea-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="a71ea-189">Jeśli wybrany format binarny nie jest standardem, prawdopodobnie nie jest dobrym pomysłem publiczne publikowanie usług w tym formacie.</span><span class="sxs-lookup"><span data-stu-id="a71ea-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="a71ea-190">Można użyć niestandardowego formatu do wewnętrznej komunikacji między mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="a71ea-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="a71ea-191">Można to zrobić podczas komunikowania się między mikrousług w obrębie hosta platformy Docker lub klastra mikrousług (na przykład koordynatorów platformy Docker) lub dla zastrzeżonych aplikacji klienckich, które komunikują się z mikrousług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="a71ea-192">Komunikacja żądania/odpowiedzi z HTTP i REST</span><span class="sxs-lookup"><span data-stu-id="a71ea-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="a71ea-193">Gdy klient używa komunikacji żądania/odpowiedzi, wysyła żądanie do usługi, a następnie usługa przetwarza żądanie i odsyła odpowiedź.</span><span class="sxs-lookup"><span data-stu-id="a71ea-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="a71ea-194">Komunikacja żądania/odpowiedzi jest szczególnie dobrze nadaje się do wykonywania zapytań danych dla interfejsu użytkownika w czasie rzeczywistym (interfejs użytkownika na żywo) z aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="a71ea-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="a71ea-195">W związku z tym w architekturze mikrousług prawdopodobnie użyjesz tego mechanizmu komunikacji dla większości zapytań, jak pokazano na rysunku 4-16.</span><span class="sxs-lookup"><span data-stu-id="a71ea-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Diagram przedstawiający komunikaty żądania/odpowiedzi dla zapytań i aktualizacji na żywo.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="a71ea-197">**Rysunek 4-16**.</span><span class="sxs-lookup"><span data-stu-id="a71ea-197">**Figure 4-16**.</span></span> <span data-ttu-id="a71ea-198">Korzystanie z komunikacji żądania/odpowiedzi HTTP (synchroniczne lub asynchroniczne)</span><span class="sxs-lookup"><span data-stu-id="a71ea-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="a71ea-199">Gdy klient używa komunikacji żądania/odpowiedzi, zakłada, że odpowiedź zostanie nadejdzie w krótkim czasie, zazwyczaj mniej niż sekundę lub co najwyżej kilka sekund.</span><span class="sxs-lookup"><span data-stu-id="a71ea-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="a71ea-200">W przypadku opóźnionych odpowiedzi należy zaimplementować komunikację asynchroniczną na podstawie [wzorców obsługi wiadomości](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) i [technologii obsługi wiadomości](https://en.wikipedia.org/wiki/Message-oriented_middleware), co jest innym podejściem, które wyjaśniamy w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="a71ea-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="a71ea-201">Popularnym stylem architektonicznym komunikacji żądania/odpowiedzi jest [REST.](https://en.wikipedia.org/wiki/Representational_state_transfer)</span><span class="sxs-lookup"><span data-stu-id="a71ea-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="a71ea-202">Takie podejście jest oparte na i ściśle powiązane z protokołem [HTTP,](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) obejmując zlecenia HTTP, takie jak GET, POST i PUT.</span><span class="sxs-lookup"><span data-stu-id="a71ea-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="a71ea-203">REST jest najczęściej używanym podejściem komunikacji architektonicznej podczas tworzenia usług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="a71ea-204">Usługi REST można zaimplementować podczas opracowywania ASP.NET podstawowych usług interfejsu API sieci Web.</span><span class="sxs-lookup"><span data-stu-id="a71ea-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="a71ea-205">Istnieje dodatkowa wartość podczas korzystania z usług HTTP REST jako języka definicji interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a71ea-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="a71ea-206">Na przykład jeśli używasz [metadanych Swagger](https://swagger.io/) do opisania interfejsu API usługi, można użyć narzędzi, które generują wycinki klienta, które mogą bezpośrednio odnajdowania i korzystania z usług.</span><span class="sxs-lookup"><span data-stu-id="a71ea-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="a71ea-207">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="a71ea-207">Additional resources</span></span>

- <span data-ttu-id="a71ea-208">**Martin Fowler. Richardson Maturity Model** Opis modelu REST.</span><span class="sxs-lookup"><span data-stu-id="a71ea-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="a71ea-209">**Puszyć** Oficjalna strona.</span><span class="sxs-lookup"><span data-stu-id="a71ea-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="a71ea-210">Komunikacja push i w czasie rzeczywistym oparta na http</span><span class="sxs-lookup"><span data-stu-id="a71ea-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="a71ea-211">Inną możliwością (zwykle do innych celów niż REST) jest komunikacja w czasie rzeczywistym i jeden do wielu z ramami wyższego poziomu, takimi jak [ASP.NET SignalR](https://www.asp.net/signalr) i protokołami, takimi jak [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="a71ea-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="a71ea-212">Jak pokazuje rysunek 4-17, komunikacja HTTP w czasie rzeczywistym oznacza, że kod serwera może wypychać zawartość do połączonych klientów w miarę udostępniania danych, zamiast czekać na klienta, aby zażądać nowych danych.</span><span class="sxs-lookup"><span data-stu-id="a71ea-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![Diagram przedstawiający komunikatory wypychania i rzeczywistym oparte na SignalR.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="a71ea-214">**Rysunek 4-17**.</span><span class="sxs-lookup"><span data-stu-id="a71ea-214">**Figure 4-17**.</span></span> <span data-ttu-id="a71ea-215">Asynchroniczny komunikat w czasie rzeczywistym</span><span class="sxs-lookup"><span data-stu-id="a71ea-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="a71ea-216">SignalR to dobry sposób na uzyskanie komunikacji w czasie rzeczywistym w celu wypychania treści do klientów z serwera zaplecza.</span><span class="sxs-lookup"><span data-stu-id="a71ea-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="a71ea-217">Ponieważ komunikacja jest w czasie rzeczywistym, aplikacje klienckie pokazują zmiany niemal natychmiast.</span><span class="sxs-lookup"><span data-stu-id="a71ea-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="a71ea-218">Jest to zwykle obsługiwane przez protokół, taki jak WebSockets, przy użyciu wielu połączeń WebSockets (jeden na klienta).</span><span class="sxs-lookup"><span data-stu-id="a71ea-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="a71ea-219">Typowym przykładem jest, gdy usługa komunikuje zmiany wyniku gry sportowej do wielu aplikacji sieci Web klienta jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="a71ea-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a71ea-220">[Poprzedni](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[następny](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="a71ea-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
