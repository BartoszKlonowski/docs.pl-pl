---
title: Projektowanie mikrousługi zorientowanej na wzorzec DDD
description: Architektura mikrousług .NET dla konteneryzowanych aplikacji .NET | Zapoznaj się z projektem mikrousługi porządkowej zorientowanej na DDD i jej warstw aplikacji.
ms.date: 10/08/2018
ms.openlocfilehash: c5ac55978ca979a3ae055d9b0cd2d3c6b3187b4e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401698"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="1a830-103">Projektowanie mikrousługi zorientowanej na DDD</span><span class="sxs-lookup"><span data-stu-id="1a830-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="1a830-104">Projekt oparty na domenie (DDD) zaleca modelowanie w oparciu o rzeczywistość firmy jako istotne dla przypadków użycia.</span><span class="sxs-lookup"><span data-stu-id="1a830-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="1a830-105">W kontekście tworzenia aplikacji DDD mówi o problemach jako domenach.</span><span class="sxs-lookup"><span data-stu-id="1a830-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="1a830-106">Opisuje niezależne obszary problemowe jako ograniczone konteksty (każdy ograniczony kontekst koreluje z mikrousługą) i podkreśla wspólny język, aby porozmawiać o tych problemach.</span><span class="sxs-lookup"><span data-stu-id="1a830-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="1a830-107">Sugeruje również wiele koncepcji technicznych i wzorców, takich jak jednostki domeny z bogatymi modelami (bez [modelu anemicznego domeny),](https://martinfowler.com/bliki/AnemicDomainModel.html)obiekty wartości, agregacje i zagregowane reguły root (lub jednostki głównej) do obsługi implementacji wewnętrznej.</span><span class="sxs-lookup"><span data-stu-id="1a830-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="1a830-108">W tej sekcji przedstawiono projektowanie i implementację tych wzorców wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="1a830-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="1a830-109">Czasami te zasady techniczne ddd i wzorce są postrzegane jako przeszkody, które mają stromą krzywą uczenia się do wdrażania podejść DDD.</span><span class="sxs-lookup"><span data-stu-id="1a830-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="1a830-110">Ale ważną częścią nie są same wzorce, ale organizowanie kodu, aby był on dostosowany do problemów biznesowych i używania tych samych terminów biznesowych (wszechobecny język).</span><span class="sxs-lookup"><span data-stu-id="1a830-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="1a830-111">Ponadto metody DDD powinny być stosowane tylko wtedy, gdy implementujesz złożone mikrousługi ze znaczącymi regułami biznesowymi.</span><span class="sxs-lookup"><span data-stu-id="1a830-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="1a830-112">Prostsze obowiązki, takie jak usługa CRUD, można zarządzać za pomocą prostszych podejść.</span><span class="sxs-lookup"><span data-stu-id="1a830-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="1a830-113">Gdzie narysować granice jest kluczowym zadaniem podczas projektowania i definiowania mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="1a830-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="1a830-114">Wzorce DDD pomagają zrozumieć złożoność w domenie.</span><span class="sxs-lookup"><span data-stu-id="1a830-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="1a830-115">Dla modelu domeny dla każdego ograniczonego kontekstu można zidentyfikować i zdefiniować jednostki, obiekty wartości i agreguje, które modelują domenę.</span><span class="sxs-lookup"><span data-stu-id="1a830-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="1a830-116">Tworzenie i uściślanie modelu domeny, który jest zawarty w granicach, która definiuje kontekst.</span><span class="sxs-lookup"><span data-stu-id="1a830-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="1a830-117">I to jest bardzo jawne w postaci mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="1a830-117">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="1a830-118">Składniki w tych granicach kończy się mikrousług, chociaż w niektórych przypadkach bc lub mikrousług biznesowych może składać się z kilku usług fizycznych.</span><span class="sxs-lookup"><span data-stu-id="1a830-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="1a830-119">DDD jest o granice i tak są mikrousług.</span><span class="sxs-lookup"><span data-stu-id="1a830-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="1a830-120">Zachować granice kontekstu mikrousług stosunkowo małe</span><span class="sxs-lookup"><span data-stu-id="1a830-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="1a830-121">Określanie, gdzie umieścić granice między ograniczone konteksty równoważy dwa konkurujące ze sobą cele.</span><span class="sxs-lookup"><span data-stu-id="1a830-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="1a830-122">Po pierwsze chcesz początkowo utworzyć najmniejszą możliwą mikrousługę, chociaż nie powinno to być głównym sterownikiem; należy utworzyć granicę wokół rzeczy, które wymagają spójności.</span><span class="sxs-lookup"><span data-stu-id="1a830-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="1a830-123">Po drugie, chcesz uniknąć chatty komunikacji między mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="1a830-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="1a830-124">Cele te mogą ze sobą zaprzeczyć.</span><span class="sxs-lookup"><span data-stu-id="1a830-124">These goals can contradict one another.</span></span> <span data-ttu-id="1a830-125">Należy zrównoważyć je, rozkładając system na tyle małych mikrousług, jak to możliwe, dopóki nie zobaczysz granice komunikacji szybko rośnie z każdej dodatkowej próby oddzielenia nowego ograniczonego kontekstu.</span><span class="sxs-lookup"><span data-stu-id="1a830-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="1a830-126">Spójność ma kluczowe znaczenie w jednym ograniczonym kontekście.</span><span class="sxs-lookup"><span data-stu-id="1a830-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="1a830-127">Jest on podobny do [zapachu kodu nieodpowiedniej intymności](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) podczas wykonywania zajęć.</span><span class="sxs-lookup"><span data-stu-id="1a830-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="1a830-128">Jeśli dwie mikrousługi muszą współpracować dużo ze sobą, prawdopodobnie powinny być tym samym mikrousług.</span><span class="sxs-lookup"><span data-stu-id="1a830-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="1a830-129">Innym sposobem spojrzenia na to jest autonomia.</span><span class="sxs-lookup"><span data-stu-id="1a830-129">Another way to look at this is autonomy.</span></span> <span data-ttu-id="1a830-130">Jeśli mikrousługi musi polegać na innej usługi bezpośrednio do obsługi żądania, nie jest naprawdę autonomiczne.</span><span class="sxs-lookup"><span data-stu-id="1a830-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="1a830-131">Warstwy w mikrousługach DDD</span><span class="sxs-lookup"><span data-stu-id="1a830-131">Layers in DDD microservices</span></span>

<span data-ttu-id="1a830-132">Większość aplikacji korporacyjnych o znacznej złożoności biznesowej i technicznej jest definiowana przez wiele warstw.</span><span class="sxs-lookup"><span data-stu-id="1a830-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="1a830-133">Warstwy są artefaktem logicznym i nie są związane z wdrożeniem usługi.</span><span class="sxs-lookup"><span data-stu-id="1a830-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="1a830-134">Istnieją one, aby pomóc deweloperom zarządzać złożonością w kodzie.</span><span class="sxs-lookup"><span data-stu-id="1a830-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="1a830-135">Różne warstwy (takie jak warstwa modelu domeny w porównaniu z warstwą prezentacji itp.) mogą mieć różne typy, co nakazuje tłumaczenia między tymi typami.</span><span class="sxs-lookup"><span data-stu-id="1a830-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="1a830-136">Na przykład jednostka może być załadowany z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="1a830-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="1a830-137">Następnie część tych informacji lub agregacja informacji, w tym dodatkowe dane z innych jednostek, mogą być wysyłane do interfejsu klienta za pośrednictwem interfejsu API sieci Web REST.</span><span class="sxs-lookup"><span data-stu-id="1a830-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="1a830-138">Chodzi o to, że jednostka domeny jest zawarta w warstwie modelu domeny i nie powinna być propagowana do innych obszarów, do których nie należy, takich jak warstwa prezentacji.</span><span class="sxs-lookup"><span data-stu-id="1a830-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="1a830-139">Ponadto należy mieć zawsze prawidłowe jednostki (zobacz [Projektowanie sprawdzania poprawności w sekcji warstwy modelu domeny)](domain-model-layer-validations.md) kontrolowane przez agregujące katalogi główne (jednostki główne).</span><span class="sxs-lookup"><span data-stu-id="1a830-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="1a830-140">W związku z tym jednostki nie powinny być powiązane z widokami klienta, ponieważ na poziomie interfejsu i ze znanie interfejsu, niektóre dane mogą nadal nie zostać zweryfikowane.</span><span class="sxs-lookup"><span data-stu-id="1a830-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="1a830-141">Jest to, co ViewModel jest dla.</span><span class="sxs-lookup"><span data-stu-id="1a830-141">This is what the ViewModel is for.</span></span> <span data-ttu-id="1a830-142">ViewModel jest modeldanych wyłącznie dla potrzeb warstwy prezentacji.</span><span class="sxs-lookup"><span data-stu-id="1a830-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="1a830-143">Jednostki domeny nie należą bezpośrednio do ViewModel.</span><span class="sxs-lookup"><span data-stu-id="1a830-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="1a830-144">Zamiast tego należy przetłumaczyć między ViewModels i jednostek domeny i na odwrót.</span><span class="sxs-lookup"><span data-stu-id="1a830-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="1a830-145">Podczas rozwiązywania złożoności, ważne jest, aby model domeny kontrolowane przez zagregowane katalogi główne, które upewnij się, że wszystkie niezmienne i reguły związane z tej grupy jednostek (agregacji) są wykonywane za pośrednictwem jednego punktu wejścia lub bramy, zagregowanego katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="1a830-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="1a830-146">Rysunek 7-5 pokazuje, jak warstwowy projekt jest implementowany w aplikacji eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="1a830-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![Diagram przedstawiający warstwy w mikrousługach projektowania opartych na domenie.](./media/ddd-oriented-microservice/domain-driven-design-microservice.png)

<span data-ttu-id="1a830-148">**Rysunek 7-5**.</span><span class="sxs-lookup"><span data-stu-id="1a830-148">**Figure 7-5**.</span></span> <span data-ttu-id="1a830-149">Warstwy DDD w mikrousługach porządkowych w eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="1a830-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="1a830-150">Trzy warstwy w mikrousługach DDD, takie jak zamawianie.</span><span class="sxs-lookup"><span data-stu-id="1a830-150">The three layers in a DDD microservice like Ordering.</span></span> <span data-ttu-id="1a830-151">Każda warstwa jest projektem VS: Warstwa aplikacji to Ordering.API, Warstwa domeny to Ordering.Domain, a warstwa Infrastruktura to Zamawianie.Infrastruktura.</span><span class="sxs-lookup"><span data-stu-id="1a830-151">Each layer is a VS project: Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</span></span> <span data-ttu-id="1a830-152">System ma być zaprojektowany tak, aby każda warstwa komunikowała się tylko z niektórymi innymi warstwami.</span><span class="sxs-lookup"><span data-stu-id="1a830-152">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="1a830-153">To może być łatwiejsze do wymuszenia, jeśli warstwy są implementowane jako biblioteki różnych klas, ponieważ można wyraźnie określić, jakie zależności są ustawione między bibliotekami.</span><span class="sxs-lookup"><span data-stu-id="1a830-153">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="1a830-154">Na przykład warstwa modelu domeny nie powinna być uzależniona od żadnej innej warstwy (klasy modelu domeny powinny być zwykłymi starymi obiektami CLR lub [klasami POCO).](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)</span><span class="sxs-lookup"><span data-stu-id="1a830-154">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="1a830-155">Jak pokazano na rysunku 7-6, biblioteka warstwy **Ordering.Domain** ma zależności tylko na bibliotekach .NET Core lub pakietach NuGet, ale nie w żadnej innej bibliotece niestandardowej, takiej jak biblioteka danych lub biblioteka trwałości.</span><span class="sxs-lookup"><span data-stu-id="1a830-155">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![Zrzut ekranu przedstawiający zależności Ordering.Domain.](./media/ddd-oriented-microservice/ordering-domain-dependencies.png)

<span data-ttu-id="1a830-157">**Rysunek 7-6**.</span><span class="sxs-lookup"><span data-stu-id="1a830-157">**Figure 7-6**.</span></span> <span data-ttu-id="1a830-158">Warstwy zaimplementowane jako biblioteki umożliwiają lepszą kontrolę zależności między warstwami</span><span class="sxs-lookup"><span data-stu-id="1a830-158">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="1a830-159">Warstwa modelu domeny</span><span class="sxs-lookup"><span data-stu-id="1a830-159">The domain model layer</span></span>

<span data-ttu-id="1a830-160">Doskonała książka Erica Evansa [Domain Driven Design](https://domainlanguage.com/ddd/) mówi o warstwie modelu domeny i warstwie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="1a830-160">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="1a830-161">**Warstwa modelu domeny**: Odpowiedzialny za reprezentowanie pojęć firmy, informacji o sytuacji biznesowej i reguł biznesowych.</span><span class="sxs-lookup"><span data-stu-id="1a830-161">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="1a830-162">państwo, które odzwierciedla sytuację biznesową, jest tutaj kontrolowane i wykorzystywane, mimo że szczegóły techniczne przechowywania są przekazywane do infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="1a830-162">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="1a830-163">Ta warstwa jest sercem oprogramowania biznesowego.</span><span class="sxs-lookup"><span data-stu-id="1a830-163">This layer is the heart of business software.</span></span>

<span data-ttu-id="1a830-164">Warstwa modelu domeny jest, gdzie firma jest wyrażona.</span><span class="sxs-lookup"><span data-stu-id="1a830-164">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="1a830-165">Podczas implementowania warstwy modelu domeny mikrousług w .NET, ta warstwa jest kodowana jako biblioteka klas z jednostkami domeny, które przechwytują dane plus zachowanie (metody z logiką).</span><span class="sxs-lookup"><span data-stu-id="1a830-165">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="1a830-166">Po [trwałości ignorancji](https://deviq.com/persistence-ignorance/) i zasady [ignorancji infrastruktury,](https://ayende.com/blog/3137/infrastructure-ignorance) ta warstwa musi całkowicie ignorować szczegóły trwałości danych.</span><span class="sxs-lookup"><span data-stu-id="1a830-166">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="1a830-167">Te zadania trwałości powinny być wykonywane przez warstwę infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="1a830-167">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="1a830-168">W związku z tym ta warstwa nie powinny przyjmować bezpośrednie zależności od infrastruktury, co oznacza, że ważną regułą jest, że klasy jednostek modelu domeny powinny być [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span><span class="sxs-lookup"><span data-stu-id="1a830-168">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="1a830-169">Jednostki domeny nie powinny mieć żadnych bezpośrednich zależności (takich jak wynikające z klasy podstawowej) na wszelkie struktury infrastruktury dostępu do danych, takich jak entity framework lub NHibernate.</span><span class="sxs-lookup"><span data-stu-id="1a830-169">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="1a830-170">W idealnym przypadku jednostki domeny nie powinny pochodzić od lub zaimplementować żadnego typu zdefiniowanego w ramach infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="1a830-170">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="1a830-171">Większość nowoczesnych platform ORM, takich jak Entity Framework Core, zezwala na takie podejście, dzięki czemu klasy modelu domeny nie są powiązane z infrastrukturą.</span><span class="sxs-lookup"><span data-stu-id="1a830-171">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="1a830-172">Jednak posiadanie jednostek POCO nie zawsze jest możliwe podczas korzystania z niektórych baz danych i struktur NoSQL, takich jak podmioty i niezawodne kolekcje w sieci szkieletowej usług Azure.</span><span class="sxs-lookup"><span data-stu-id="1a830-172">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="1a830-173">Nawet wtedy, gdy jest ważne, aby przestrzegać zasady nieznajomości trwałości dla modelu domeny, nie należy ignorować obawy trwałości.</span><span class="sxs-lookup"><span data-stu-id="1a830-173">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="1a830-174">Nadal bardzo ważne jest, aby zrozumieć model danych fizycznych i jak mapuje do modelu obiektu jednostki.</span><span class="sxs-lookup"><span data-stu-id="1a830-174">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="1a830-175">W przeciwnym razie można tworzyć niemożliwe projekty.</span><span class="sxs-lookup"><span data-stu-id="1a830-175">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="1a830-176">Ponadto nie oznacza to, że można wziąć model przeznaczony dla relacyjnej bazy danych i bezpośrednio przenieść go do bazy danych NoSQL lub zorientowanej na dokumenty.</span><span class="sxs-lookup"><span data-stu-id="1a830-176">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="1a830-177">W niektórych modelach encji model może się zmieścić, ale zwykle nie.</span><span class="sxs-lookup"><span data-stu-id="1a830-177">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="1a830-178">Nadal istnieją ograniczenia, których musi przestrzegać model jednostki, zarówno w oparciu o technologię pamięci masowej, jak i technologię ORM.</span><span class="sxs-lookup"><span data-stu-id="1a830-178">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="1a830-179">Warstwa aplikacji</span><span class="sxs-lookup"><span data-stu-id="1a830-179">The application layer</span></span>

<span data-ttu-id="1a830-180">Przechodząc do warstwy aplikacji, możemy ponownie przytoczyć książki Eric Evans [Domain Driven Design:](https://domainlanguage.com/ddd/)</span><span class="sxs-lookup"><span data-stu-id="1a830-180">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="1a830-181">**Warstwa aplikacji:** Definiuje zadania, które oprogramowanie ma wykonywać, i kieruje obiekty domeny ekspresyjnej do wypracowania problemów.</span><span class="sxs-lookup"><span data-stu-id="1a830-181">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="1a830-182">Zadania, za które odpowiada ta warstwa, mają znaczenie dla firmy lub są niezbędne do interakcji z warstwami aplikacji innych systemów.</span><span class="sxs-lookup"><span data-stu-id="1a830-182">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="1a830-183">Warstwa ta jest cienka.</span><span class="sxs-lookup"><span data-stu-id="1a830-183">This layer is kept thin.</span></span> <span data-ttu-id="1a830-184">Nie zawiera reguł biznesowych lub wiedzy, ale tylko koordynuje zadania i deleguje pracę do współpracy obiektów domeny w następnej warstwie w dół.</span><span class="sxs-lookup"><span data-stu-id="1a830-184">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="1a830-185">Nie ma stanu odzwierciedlającego sytuację biznesową, ale może mieć stan, który odzwierciedla postęp zadania dla użytkownika lub programu.</span><span class="sxs-lookup"><span data-stu-id="1a830-185">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="1a830-186">Warstwa aplikacji mikrousługi w platformie .NET jest często kodowana jako ASP.NET projektu interfejsu API podstawowej sieci Web.</span><span class="sxs-lookup"><span data-stu-id="1a830-186">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="1a830-187">Projekt implementuje interakcji mikrousługi, zdalny dostęp do sieci i zewnętrznych interfejsów API sieci Web używanych z interfejsu użytkownika lub aplikacji klienckich.</span><span class="sxs-lookup"><span data-stu-id="1a830-187">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="1a830-188">Zawiera zapytania, jeśli przy użyciu podejścia CQRS, polecenia akceptowane przez mikrousługi, a nawet komunikacji opartej na zdarzeniach między mikrousług (zdarzenia integracji).</span><span class="sxs-lookup"><span data-stu-id="1a830-188">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="1a830-189">ASP.NET core Web API reprezentujący warstwę aplikacji nie może zawierać reguł biznesowych ani wiedzy o domenie (zwłaszcza reguł domeny dla transakcji lub aktualizacji); powinny one być własnością biblioteki klas modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="1a830-189">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="1a830-190">Warstwa aplikacji musi koordynować tylko zadania i nie może zawierać ani definiować żadnego stanu domeny (modelu domeny).</span><span class="sxs-lookup"><span data-stu-id="1a830-190">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="1a830-191">Deleguje wykonywanie reguł biznesowych do samych klas modelu domeny (zagregowane katalogi główne i jednostki domeny), które ostatecznie zaktualizują dane w ramach tych jednostek domeny.</span><span class="sxs-lookup"><span data-stu-id="1a830-191">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="1a830-192">Zasadniczo logika aplikacji jest, gdzie można zaimplementować wszystkie przypadki użycia, które zależą od danego frontonu.</span><span class="sxs-lookup"><span data-stu-id="1a830-192">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="1a830-193">Na przykład implementacja związana z usługą interfejsu API sieci Web.</span><span class="sxs-lookup"><span data-stu-id="1a830-193">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="1a830-194">Celem jest, że logika domeny w warstwie modelu domeny, jej niezmienne, model danych i powiązanych reguł biznesowych musi być całkowicie niezależna od warstwy prezentacji i aplikacji.</span><span class="sxs-lookup"><span data-stu-id="1a830-194">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="1a830-195">Przede wszystkim warstwy modelu domeny nie może bezpośrednio zależeć od żadnych framework infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="1a830-195">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="1a830-196">Warstwa infrastruktury</span><span class="sxs-lookup"><span data-stu-id="1a830-196">The infrastructure layer</span></span>

<span data-ttu-id="1a830-197">Warstwa infrastruktury jest jak dane, które są początkowo przechowywane w jednostkach domeny (w pamięci) jest zachowywany w bazach danych lub innego magazynu trwałego.</span><span class="sxs-lookup"><span data-stu-id="1a830-197">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="1a830-198">Przykładem jest użycie kodu core struktury jednostki do implementowania klas wzorca repozytorium, które używają DBContext do utrwalenia danych w relacyjnej bazie danych.</span><span class="sxs-lookup"><span data-stu-id="1a830-198">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="1a830-199">Zgodnie z wcześniej wspomnianymi zasadami [persistence ignorancji](https://deviq.com/persistence-ignorance/) i [infrastruktury niewiedzy,](https://ayende.com/blog/3137/infrastructure-ignorance) warstwa infrastruktury nie może "zanieczyszczać" warstwy modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="1a830-199">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="1a830-200">Należy zachować klasy jednostki modelu domeny agnostyk z infrastruktury, która służy do utrwalania danych (EF lub innych ramach), nie biorąc twarde zależności na ramach.</span><span class="sxs-lookup"><span data-stu-id="1a830-200">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="1a830-201">Biblioteka klas warstwy modelu domeny powinna mieć tylko kod domeny, tylko klasy jednostek [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) implementujące serce oprogramowania i całkowicie oddzielone od technologii infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="1a830-201">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="1a830-202">W związku z tym warstwy lub biblioteki klas i projekty powinny ostatecznie zależeć od warstwy modelu domeny (biblioteki), a nie odwrotnie, jak pokazano na rysunku 7-7.</span><span class="sxs-lookup"><span data-stu-id="1a830-202">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![Diagram przedstawiający zależności istniejące między warstwami usługi DDD.](./media/ddd-oriented-microservice/ddd-service-layer-dependencies.png)

<span data-ttu-id="1a830-204">**Rysunek 7-7**.</span><span class="sxs-lookup"><span data-stu-id="1a830-204">**Figure 7-7**.</span></span> <span data-ttu-id="1a830-205">Zależności między warstwami w DDD</span><span class="sxs-lookup"><span data-stu-id="1a830-205">Dependencies between layers in DDD</span></span>

<span data-ttu-id="1a830-206">Zależności w usłudze DDD, warstwa aplikacji zależy od domeny i infrastruktury, a infrastruktura zależy od domeny, ale domena nie zależy od żadnej warstwy.</span><span class="sxs-lookup"><span data-stu-id="1a830-206">Dependencies in a DDD Service, the Application layer depends on Domain and Infrastructure, and Infrastructure depends on Domain, but Domain doesn't depend on any layer.</span></span> <span data-ttu-id="1a830-207">Ten projekt warstwy powinny być niezależne dla każdej mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="1a830-207">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="1a830-208">Jak wspomniano wcześniej, można zaimplementować najbardziej złożonych mikrousług po wzorców DDD, podczas implementowania prostsze mikrousług opartych na danych (proste CRUD w jednej warstwie) w prostszy sposób.</span><span class="sxs-lookup"><span data-stu-id="1a830-208">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="1a830-209">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="1a830-209">Additional resources</span></span>

- <span data-ttu-id="1a830-210">**DevIQ. Zasada niewiedzy o trwałości** </span><span class="sxs-lookup"><span data-stu-id="1a830-210">**DevIQ. Persistence Ignorance principle** </span></span>\
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="1a830-211">**Oren Eini. Nieznajomość infrastruktury** </span><span class="sxs-lookup"><span data-stu-id="1a830-211">**Oren Eini. Infrastructure Ignorance** </span></span>\
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="1a830-212">**Angel Lopez. Architektura warstwowa w projekcie opartym na domenie** </span><span class="sxs-lookup"><span data-stu-id="1a830-212">**Angel Lopez. Layered Architecture In Domain-Driven Design** </span></span>\
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="1a830-213">[Poprzedni](cqrs-microservice-reads.md)
>[następny](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="1a830-213">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>
