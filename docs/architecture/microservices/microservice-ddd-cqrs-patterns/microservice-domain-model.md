---
title: Projektowanie modelu domeny mikrousługi
description: Architektura mikrousług platformy .NET dla aplikacji platformy .NET w kontenerze | Zapoznaj się z najważniejszymi pojęciami dotyczącymi projektowania zorientowanej na siebie modelu domeny.
ms.date: 01/30/2020
ms.openlocfilehash: fe78e719570d5758b71531beab883e5c24a88dca
ms.sourcegitcommit: 5280b2aef60a1ed99002dba44e4b9e7f6c830604
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/03/2020
ms.locfileid: "84306916"
---
# <a name="design-a-microservice-domain-model"></a><span data-ttu-id="d0e93-103">Projektowanie modelu domeny mikrousługi</span><span class="sxs-lookup"><span data-stu-id="d0e93-103">Design a microservice domain model</span></span>

<span data-ttu-id="d0e93-104">*Zdefiniuj jeden bogaty model domeny dla każdego mikrousługi biznesowej lub ograniczonego kontekstu.*</span><span class="sxs-lookup"><span data-stu-id="d0e93-104">*Define one rich domain model for each business microservice or Bounded Context.*</span></span>

<span data-ttu-id="d0e93-105">Celem jest utworzenie jednego spójnego modelu domeny dla każdego mikrousług biznesowej lub ograniczonego kontekstu (BC).</span><span class="sxs-lookup"><span data-stu-id="d0e93-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="d0e93-106">Należy jednak pamiętać, że mikrousługa BC lub biznesowa może czasami składać się z kilku usług fizycznych, które współużytkują jeden model domeny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="d0e93-107">Model domeny musi przechwycić reguły, zachowanie, język biznesowy i ograniczenia dotyczące pojedynczego powiązanego kontekstu lub mikrousługi biznesowej, które reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="d0e93-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="d0e93-108">Wzorzec jednostki domeny</span><span class="sxs-lookup"><span data-stu-id="d0e93-108">The Domain Entity pattern</span></span>

<span data-ttu-id="d0e93-109">Jednostki reprezentują obiekty domeny i są głównie definiowane przez ich tożsamość, ciągłość i trwałość w czasie, a nie tylko te, które zawierają te atrybuty.</span><span class="sxs-lookup"><span data-stu-id="d0e93-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="d0e93-110">Jak Eric Evans mówi, "obiekt, głównie zdefiniowany przez jego tożsamość, nosi nazwę jednostki".</span><span class="sxs-lookup"><span data-stu-id="d0e93-110">As Eric Evans says, "an object primarily defined by its identity is called an Entity."</span></span> <span data-ttu-id="d0e93-111">Jednostki są bardzo ważne w modelu domeny, ponieważ są one podstawą dla modelu.</span><span class="sxs-lookup"><span data-stu-id="d0e93-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="d0e93-112">W związku z tym należy uważnie identyfikować i projektować.</span><span class="sxs-lookup"><span data-stu-id="d0e93-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="d0e93-113">*Tożsamość jednostki może przekroczyć wiele mikrousług lub ograniczonych kontekstów.*</span><span class="sxs-lookup"><span data-stu-id="d0e93-113">*An entity's identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="d0e93-114">Ta sama tożsamość (to jest taka sama `Id` wartość, chociaż prawdopodobnie nie jest to taka sama jednostka domeny), którą można modelować w wielu ograniczonych kontekstach lub mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="d0e93-114">The same identity (that is, the same `Id` value, although perhaps not the same domain entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="d0e93-115">Nie oznacza to jednak, że ta sama jednostka z tymi samymi atrybutami i logiką zostałaby wdrożona w wielu powiązanych kontekstach.</span><span class="sxs-lookup"><span data-stu-id="d0e93-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="d0e93-116">Zamiast tego obiekty w każdym ograniczonym kontekście ograniczają ich atrybuty i zachowania do tych, które są wymagane w domenie powiązanego kontekstu.</span><span class="sxs-lookup"><span data-stu-id="d0e93-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context's domain.</span></span>

<span data-ttu-id="d0e93-117">Na przykład jednostka kupca może mieć większość atrybutów osób, które są zdefiniowane w jednostce użytkownika w ramach profilu lub mikrousługi tożsamości, w tym tożsamość.</span><span class="sxs-lookup"><span data-stu-id="d0e93-117">For instance, the buyer entity might have most of a person's attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="d0e93-118">Jednak jednostka kupca w mikrousłudze porządkowania może mieć mniej atrybutów, ponieważ tylko niektóre dane dotyczące kupujących są powiązane z procesem zamówienia.</span><span class="sxs-lookup"><span data-stu-id="d0e93-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="d0e93-119">Kontekst każdego mikrousługi lub ograniczonego kontekstu ma wpływ na model domeny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="d0e93-120">*Jednostki domeny muszą implementować zachowanie oprócz implementowania atrybutów danych.*</span><span class="sxs-lookup"><span data-stu-id="d0e93-120">*Domain entities must implement behavior in addition to implementing data attributes.*</span></span>

<span data-ttu-id="d0e93-121">Jednostka domeny w DDD musi implementować logikę domeny lub zachowanie związane z danymi jednostki (obiektem dostępnym w pamięci).</span><span class="sxs-lookup"><span data-stu-id="d0e93-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="d0e93-122">Na przykład w ramach klasy jednostki zamówienia należy mieć logikę biznesową i operacje zaimplementowane jako metody dla zadań, takich jak dodawanie elementu zamówienia, sprawdzanie poprawności danych i obliczanie całkowite.</span><span class="sxs-lookup"><span data-stu-id="d0e93-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="d0e93-123">Metody jednostki zapoznają się z niektórymi różnymi i niektórymi regułami jednostki, zamiast korzystać z tych reguł w warstwie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-123">The entity's methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="d0e93-124">Rysunek 7-8 pokazuje jednostkę domeny, która implementuje nie tylko atrybuty danych, ale operacje lub metody z powiązaną logiką domeny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-124">Figure 7-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![Diagram przedstawiający wzorzec jednostki domeny.](./media/microservice-domain-model/domain-entity-pattern.png)

<span data-ttu-id="d0e93-126">**Rysunek 7-8**.</span><span class="sxs-lookup"><span data-stu-id="d0e93-126">**Figure 7-8**.</span></span> <span data-ttu-id="d0e93-127">Przykład projektu jednostki domeny implementującego dane oraz zachowanie</span><span class="sxs-lookup"><span data-stu-id="d0e93-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="d0e93-128">Jednostka modelu domeny implementuje zachowania za pomocą metod, czyli nie jest to model "Anemic".</span><span class="sxs-lookup"><span data-stu-id="d0e93-128">A domain model entity implements behaviors through methods, that is, it's not an "anemic" model.</span></span> <span data-ttu-id="d0e93-129">Oczywiście czasami może istnieć jednostka, która nie implementuje żadnej logiki jako części klasy Entity.</span><span class="sxs-lookup"><span data-stu-id="d0e93-129">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="d0e93-130">Może się to zdarzyć w jednostkach podrzędnych w ramach agregacji, jeśli jednostka podrzędna nie ma żadnej specjalnej logiki, ponieważ większość logiki jest zdefiniowana w zagregowanym elemencie głównym.</span><span class="sxs-lookup"><span data-stu-id="d0e93-130">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="d0e93-131">W przypadku złożonej mikrousługi, która ma logikę zaimplementowaną w klasach usług zamiast w jednostkach domeny, można uwzględnić model domeny Anemic, wyjaśniony w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-131">If you have a complex microservice that has logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="d0e93-132">Bogaty model domeny a model domeny Anemic</span><span class="sxs-lookup"><span data-stu-id="d0e93-132">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="d0e93-133">W swoim [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html)post Fowlera opisuje model domeny Anemic w ten sposób:</span><span class="sxs-lookup"><span data-stu-id="d0e93-133">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="d0e93-134">Podstawowym objawem modelu domeny Anemic jest to, że pierwszy rumianolawendowy wygląda jak w rzeczywistości.</span><span class="sxs-lookup"><span data-stu-id="d0e93-134">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="d0e93-135">Istnieją obiekty, wiele nazwanych po rzeczownikach w przestrzeni domeny, a te obiekty są połączone z rozbudowanymi relacjami i strukturą, które mają prawdziwe modele domeny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-135">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="d0e93-136">Catch pojawia się, gdy zobaczysz zachowanie i zobaczysz, że na tych obiektach istnieje trudne jakiekolwiek zachowanie, dzięki czemu są one nieco większe niż zbiory metod pobierających i ustawiających.</span><span class="sxs-lookup"><span data-stu-id="d0e93-136">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="d0e93-137">Oczywiście w przypadku używania modelu domeny Anemic te modele danych będą używane z zestawu obiektów usługi (tradycyjnie nazywana *warstwą biznesową*), które przechwytują całą domenę lub logikę biznesową.</span><span class="sxs-lookup"><span data-stu-id="d0e93-137">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="d0e93-138">Warstwa biznesowa znajduje się na szczycie modelu danych i używa modelu danych tak samo jak dane.</span><span class="sxs-lookup"><span data-stu-id="d0e93-138">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="d0e93-139">Model domeny Anemic jest tylko projektem w stylu proceduralnym.</span><span class="sxs-lookup"><span data-stu-id="d0e93-139">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="d0e93-140">Obiekty jednostek Anemic nie są obiektami rzeczywistymi, ponieważ nie są one zachowaniem (Metoda).</span><span class="sxs-lookup"><span data-stu-id="d0e93-140">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="d0e93-141">Przechowują one tylko właściwości danych, dlatego nie jest to projektowanie zorientowane obiektowo.</span><span class="sxs-lookup"><span data-stu-id="d0e93-141">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="d0e93-142">Przez umieszczenie wszystkich zachowań w obiektach usługi (warstwa biznesowa), zasadniczo jest to [spaghetti kodu](https://en.wikipedia.org/wiki/Spaghetti_code) lub [skryptów transakcji](https://martinfowler.com/eaaCatalog/transactionScript.html), w związku z czym utracisz korzyści, jakie zapewnia model domeny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-142">By putting all the behavior out into service objects (the business layer), you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="d0e93-143">Bez względu na to, że usługa mikrousług lub ograniczone konteksty są bardzo proste (usługi CRUD), model domeny Anemic w formie obiektów Entity ze wszystkimi właściwościami danych może być wystarczająco dobry i nie będzie warto wdrażać bardziej złożonych wzorców DDD.</span><span class="sxs-lookup"><span data-stu-id="d0e93-143">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="d0e93-144">W takim przypadku jest to po prostu model trwałości, ponieważ celowo utworzono jednostkę z tylko danymi do celów CRUD.</span><span class="sxs-lookup"><span data-stu-id="d0e93-144">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="d0e93-145">Dlatego architektury mikrousług doskonale nadaje się do podejścia wieloarchitekturowego, w zależności od każdego powiązanego kontekstu.</span><span class="sxs-lookup"><span data-stu-id="d0e93-145">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="d0e93-146">Na przykład w eShopOnContainers, porządkowanie mikrousługi implementuje wzorce DDD, ale nie jest to prosta usługa CRUD.</span><span class="sxs-lookup"><span data-stu-id="d0e93-146">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="d0e93-147">Niektórzy użytkownicy mówią, że model domeny Anemic jest antywzorców.</span><span class="sxs-lookup"><span data-stu-id="d0e93-147">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="d0e93-148">Jest to naprawdę zależne od implementacji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-148">It really depends on what you are implementing.</span></span> <span data-ttu-id="d0e93-149">Jeśli mikrousługa, którą tworzysz, jest wystarczająco prosta (na przykład usługa CRUD), zgodnie z modelem domeny Anemic nie jest to Antywzorzec.</span><span class="sxs-lookup"><span data-stu-id="d0e93-149">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="d0e93-150">Jeśli jednak chcesz zaradzić sobie z złożonością domeny mikrousługi, która ma wiele niezmienionych reguł firmy, model domeny Anemic może być Antywzorzec dla tego mikrousługi lub ograniczonego kontekstu.</span><span class="sxs-lookup"><span data-stu-id="d0e93-150">However, if you need to tackle the complexity of a microservice's domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="d0e93-151">W takim przypadku projektowanie go jako bogaty model z obiektami zawierającymi dane oraz zachowaniem, a także wdrożenie dodatkowych wzorców DDD (agregatów, obiektów wartości itp.) może mieć ogromny zakres korzyści w przypadku długotrwałego sukcesu takich mikrousług.</span><span class="sxs-lookup"><span data-stu-id="d0e93-151">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d0e93-152">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="d0e93-152">Additional resources</span></span>

- <span data-ttu-id="d0e93-153">**DevIQ. Jednostka domeny** </span><span class="sxs-lookup"><span data-stu-id="d0e93-153">**DevIQ. Domain Entity** </span></span>\
  <https://deviq.com/entity/>

- <span data-ttu-id="d0e93-154">**Fowlera Martin. Model domeny** </span><span class="sxs-lookup"><span data-stu-id="d0e93-154">**Martin Fowler. The Domain Model** </span></span>\
  <https://martinfowler.com/eaaCatalog/domainModel.html>

- <span data-ttu-id="d0e93-155">**Fowlera Martin. Model domeny Anemic** </span><span class="sxs-lookup"><span data-stu-id="d0e93-155">**Martin Fowler. The Anemic Domain Model** </span></span>\
  <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="d0e93-156">Wzorzec obiektu wartości</span><span class="sxs-lookup"><span data-stu-id="d0e93-156">The Value Object pattern</span></span>

<span data-ttu-id="d0e93-157">Ponieważ zanotowano Eric Evans, "wiele obiektów nie ma tożsamości koncepcyjnej.</span><span class="sxs-lookup"><span data-stu-id="d0e93-157">As Eric Evans has noted, "Many objects do not have conceptual identity.</span></span> <span data-ttu-id="d0e93-158">Te obiekty opisują pewne charakterystyki elementu ".</span><span class="sxs-lookup"><span data-stu-id="d0e93-158">These objects describe certain characteristics of a thing."</span></span>

<span data-ttu-id="d0e93-159">Jednostka wymaga tożsamości, ale istnieje wiele obiektów w systemie, które nie są takie jak wzorzec obiektu wartości.</span><span class="sxs-lookup"><span data-stu-id="d0e93-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="d0e93-160">Obiekt wartości jest obiektem bez tożsamości koncepcyjnej opisującym aspekt domeny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="d0e93-161">Są to obiekty, które są przeznaczone do reprezentowania elementów projektu, które dotyczą tylko chwilowo.</span><span class="sxs-lookup"><span data-stu-id="d0e93-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="d0e93-162">Pamiętaj o tym, *czego* zajmują. *who*</span><span class="sxs-lookup"><span data-stu-id="d0e93-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="d0e93-163">Przykłady zawierają liczby i ciągi, ale mogą być również pojęcia wyższego poziomu, takie jak grupy atrybutów.</span><span class="sxs-lookup"><span data-stu-id="d0e93-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="d0e93-164">Coś, co jest jednostką w mikrousłudze, może nie być jednostką w innej mikrousług, ponieważ w drugim przypadku ograniczony kontekst może mieć inne znaczenie.</span><span class="sxs-lookup"><span data-stu-id="d0e93-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="d0e93-165">Na przykład adres w aplikacji handlu elektronicznego może nie mieć tożsamości, ponieważ może reprezentować tylko grupę atrybutów profilu klienta dla osoby lub firmy.</span><span class="sxs-lookup"><span data-stu-id="d0e93-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer's profile for a person or company.</span></span> <span data-ttu-id="d0e93-166">W takim przypadku adres powinien być sklasyfikowany jako obiekt wartości.</span><span class="sxs-lookup"><span data-stu-id="d0e93-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="d0e93-167">Jednak w aplikacji dla elektrycznego narzędzia do zarządzania energię adres klienta może być istotny dla domeny biznesowej.</span><span class="sxs-lookup"><span data-stu-id="d0e93-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="d0e93-168">W związku z tym adres musi mieć tożsamość, aby system rozliczeń mógł być bezpośrednio połączony z adresem.</span><span class="sxs-lookup"><span data-stu-id="d0e93-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="d0e93-169">W takim przypadku adres powinien być sklasyfikowany jako jednostka domeny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="d0e93-170">Osoba o nazwisku i nazwisku jest zazwyczaj jednostką, ponieważ osoba ma tożsamość, nawet jeśli nazwa i nazwisko pokrywają się z innym zestawem wartości, takich jak te nazwy również odnoszą się do innej osoby.</span><span class="sxs-lookup"><span data-stu-id="d0e93-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refer to a different person.</span></span>

<span data-ttu-id="d0e93-171">Obiekty wartości są trudne do zarządzania w relacyjnych bazach danych i ORMs takich jak Entity Framework (EF), natomiast w bazach danych zorientowanych na dokumenty są one łatwiejsze do zaimplementowania i użycia.</span><span class="sxs-lookup"><span data-stu-id="d0e93-171">Value objects are hard to manage in relational databases and ORMs like Entity Framework (EF), whereas in document-oriented databases they are easier to implement and use.</span></span>

<span data-ttu-id="d0e93-172">EF Core 2,0 i nowsze wersje zawierają funkcję [jednostek należących](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) do elementów, które ułatwiają obsługę obiektów wartości, co opisano w dalszej części artykułu.</span><span class="sxs-lookup"><span data-stu-id="d0e93-172">EF Core 2.0 and later versions include the [Owned Entities](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) feature that makes it easier to handle value objects, as we'll see in detail later on.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d0e93-173">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="d0e93-173">Additional resources</span></span>

- <span data-ttu-id="d0e93-174">**Fowlera Martin. Wzorzec obiektu wartości** </span><span class="sxs-lookup"><span data-stu-id="d0e93-174">**Martin Fowler. Value Object pattern** </span></span>\
  <https://martinfowler.com/bliki/ValueObject.html>

- <span data-ttu-id="d0e93-175">**Obiekt wartości** </span><span class="sxs-lookup"><span data-stu-id="d0e93-175">**Value Object** </span></span>\
  <https://deviq.com/value-object/>

- <span data-ttu-id="d0e93-176">**Obiekty wartości w programowaniu sterowanym testami** </span><span class="sxs-lookup"><span data-stu-id="d0e93-176">**Value Objects in Test-Driven Development** </span></span>\
  [https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)

- <span data-ttu-id="d0e93-177">**Eric Evans. Projektowanie oparte na domenie: zapełnianie złożoności w oprogramowaniu.**</span><span class="sxs-lookup"><span data-stu-id="d0e93-177">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="d0e93-178">(Książka; zawiera omówienie obiektów wartości) </span><span class="sxs-lookup"><span data-stu-id="d0e93-178">(Book; includes a discussion of value objects) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="d0e93-179">Wzorzec agregacji</span><span class="sxs-lookup"><span data-stu-id="d0e93-179">The Aggregate pattern</span></span>

<span data-ttu-id="d0e93-180">Model domeny zawiera klastry różnych jednostek danych i procesów, które mogą kontrolować znaczący obszar funkcjonalności, taki jak realizacja lub spis kolejności.</span><span class="sxs-lookup"><span data-stu-id="d0e93-180">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfillment or inventory.</span></span> <span data-ttu-id="d0e93-181">Bardziej szczegółowym przydziałem jest agregacja, która opisuje klaster lub grupę jednostek i zachowań, które mogą być traktowane jako spójna jednostka.</span><span class="sxs-lookup"><span data-stu-id="d0e93-181">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="d0e93-182">Zwykle definiuje się wartość zagregowaną na podstawie wymaganych transakcji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-182">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="d0e93-183">Klasycznym przykładem jest kolejność, która zawiera również listę elementów zamówienia.</span><span class="sxs-lookup"><span data-stu-id="d0e93-183">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="d0e93-184">Element Order zazwyczaj będzie jednostką.</span><span class="sxs-lookup"><span data-stu-id="d0e93-184">An order item will usually be an entity.</span></span> <span data-ttu-id="d0e93-185">Ale będzie ona jednostką podrzędną w ramach agregacji Order, która również będzie zawierać jednostkę Order jako jednostkę główną, zazwyczaj nazywaną zagregowanym elementem głównym.</span><span class="sxs-lookup"><span data-stu-id="d0e93-185">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="d0e93-186">Identyfikowanie zagregowane może być trudne.</span><span class="sxs-lookup"><span data-stu-id="d0e93-186">Identifying aggregates can be hard.</span></span> <span data-ttu-id="d0e93-187">Agregacja to grupa obiektów, która musi być spójna ze sobą, ale nie można tylko wybrać grupy obiektów i oznaczyć je agregacją.</span><span class="sxs-lookup"><span data-stu-id="d0e93-187">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="d0e93-188">Należy zacząć od koncepcji domeny i myśleć o jednostkach, które są używane w najpopularniejszych transakcjach związanych z tą koncepcją.</span><span class="sxs-lookup"><span data-stu-id="d0e93-188">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="d0e93-189">Te jednostki, które muszą mieć spójną transakcję, tworzą agregację.</span><span class="sxs-lookup"><span data-stu-id="d0e93-189">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="d0e93-190">Zastanawiamy się, że operacje transakcji są prawdopodobnie najlepszym sposobem na identyfikację agregacji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-190">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="d0e93-191">Wzorzec zagregowanych lub głównych jednostek głównych</span><span class="sxs-lookup"><span data-stu-id="d0e93-191">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="d0e93-192">Agregacja składa się z co najmniej jednej jednostki: zagregowanego elementu głównego, nazywanego również jednostką główną lub jednostką podstawową.</span><span class="sxs-lookup"><span data-stu-id="d0e93-192">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="d0e93-193">Ponadto może mieć wiele jednostek podrzędnych i obiektów wartości, ze wszystkimi jednostkami i obiektami, które współpracują w celu zaimplementowania wymaganego zachowania i transakcji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-193">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="d0e93-194">Celem zagregowanego elementu głównego jest zapewnienie spójności agregacji; powinien być jedynym punktem wejścia dla aktualizacji zagregowanych za pomocą metod lub operacji w klasie głównej agregacji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-194">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="d0e93-195">Zmiany jednostek w ramach agregacji należy wprowadzać tylko za pośrednictwem zagregowanego elementu głównego.</span><span class="sxs-lookup"><span data-stu-id="d0e93-195">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="d0e93-196">Jest to zagregowany opiekun spójności, biorąc pod uwagę wszystkie niewarianty i reguły spójności, które mogą być potrzebne w ramach agregacji.</span><span class="sxs-lookup"><span data-stu-id="d0e93-196">It is the aggregate's consistency guardian, considering all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="d0e93-197">Jeśli zmienisz jednostkę podrzędną lub obiekt wartości niezależnie, zagregowany element główny nie może zagwarantować, że agregacja jest w prawidłowym stanie.</span><span class="sxs-lookup"><span data-stu-id="d0e93-197">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="d0e93-198">Byłoby tak jak tabela z luźną gałęzią.</span><span class="sxs-lookup"><span data-stu-id="d0e93-198">It would be like a table with a loose leg.</span></span> <span data-ttu-id="d0e93-199">Zachowanie spójności jest głównym celem zagregowanego elementu głównego.</span><span class="sxs-lookup"><span data-stu-id="d0e93-199">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="d0e93-200">Na rysunku 7-9 można zobaczyć przykładowe zagregowane wartości, takie jak agregacja kupującego, która zawiera pojedynczą jednostkę (zagregowany główny kupujący).</span><span class="sxs-lookup"><span data-stu-id="d0e93-200">In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="d0e93-201">Zagregowana kolejność zawiera wiele jednostek i obiekt wartości.</span><span class="sxs-lookup"><span data-stu-id="d0e93-201">The order aggregate contains multiple entities and a value object.</span></span>

![Diagram porównujący zagregowaną sumę i agregację zamówienia.](./media/microservice-domain-model/buyer-order-aggregate-pattern.png)

<span data-ttu-id="d0e93-203">**Rysunek 7-9**.</span><span class="sxs-lookup"><span data-stu-id="d0e93-203">**Figure 7-9**.</span></span> <span data-ttu-id="d0e93-204">Przykład zagregowanych elementów z wieloma jednostkami lub pojedynczymi</span><span class="sxs-lookup"><span data-stu-id="d0e93-204">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="d0e93-205">Model domeny DDD składa się z agregacji, agregacja może mieć tylko jedną jednostkę lub wiele obiektów i może zawierać również obiekty wartości.</span><span class="sxs-lookup"><span data-stu-id="d0e93-205">A DDD domain model is composed from aggregates, an aggregate can have just one entity or more, and can include value objects as well.</span></span> <span data-ttu-id="d0e93-206">Należy pamiętać, że agregowanie kupującego może mieć dodatkowe jednostki podrzędne, w zależności od domeny, tak jak w przypadku mikrousługi porządkowania w aplikacji eShopOnContainers Reference.</span><span class="sxs-lookup"><span data-stu-id="d0e93-206">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="d0e93-207">Rysunek 7-9 po prostu ilustruje przypadek, w którym kupujący ma pojedynczą jednostkę, jako przykład agregacji, która zawiera tylko zagregowany element główny.</span><span class="sxs-lookup"><span data-stu-id="d0e93-207">Figure 7-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="d0e93-208">Aby zachować rozdzielenie agregacji i zachować jasne granice między nimi, dobrym sposobem w modelu domeny DDD jest uniemożliwienie bezpośredniej nawigacji między agregacjami i tylko posiadanie pola klucza obcego (FK), zgodnie z implementacją w [modelu domeny mikrousługi](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) w eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="d0e93-208">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="d0e93-209">Jednostka Order ma tylko pole klucza obcego dla kupującego, ale nie EF Core właściwość nawigacji, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="d0e93-209">The Order entity only has a foreign key field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; // FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="d0e93-210">Identyfikowanie i praca z agregacjami wymaga badań i środowiska.</span><span class="sxs-lookup"><span data-stu-id="d0e93-210">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="d0e93-211">Aby uzyskać więcej informacji, zobacz poniższą listę zasobów dodatkowych.</span><span class="sxs-lookup"><span data-stu-id="d0e93-211">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d0e93-212">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="d0e93-212">Additional resources</span></span>

- <span data-ttu-id="d0e93-213">**Vaughn Vernon. Efektywny model agregacji — część I: Modelowanie pojedynczej agregacji** (od <https://dddcommunity.org/> ) </span><span class="sxs-lookup"><span data-stu-id="d0e93-213">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate** (from <https://dddcommunity.org/>) </span></span>\
  <https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf>

- <span data-ttu-id="d0e93-214">**Vaughn Vernon. Efektywny projekt zagregowany — część II: wykonywanie zagregowanych współdziałań** (z <https://dddcommunity.org/> ) </span><span class="sxs-lookup"><span data-stu-id="d0e93-214">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together** (from <https://dddcommunity.org/>) </span></span>\
  <https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf>

- <span data-ttu-id="d0e93-215">**Vaughn Vernon. Efektywny projekt zagregowany — część III: uzyskiwanie wglądu w dane poprzez odnajdywanie** (od <https://dddcommunity.org/> ) </span><span class="sxs-lookup"><span data-stu-id="d0e93-215">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery** (from <https://dddcommunity.org/>) </span></span>\
  <https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf>

- <span data-ttu-id="d0e93-216">**Sergey Grybniak. Wzorce projektowe DDD** </span><span class="sxs-lookup"><span data-stu-id="d0e93-216">**Sergey Grybniak. DDD Tactical Design Patterns** </span></span>\
  <https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part>

- <span data-ttu-id="d0e93-217">**Krzysztof Richardson. Opracowywanie mikrousług transakcyjnych przy użyciu agregacji** </span><span class="sxs-lookup"><span data-stu-id="d0e93-217">**Chris Richardson. Developing Transactional Microservices Using Aggregates** </span></span>\
  <https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson>

- <span data-ttu-id="d0e93-218">**DevIQ. Wzorzec agregacji** </span><span class="sxs-lookup"><span data-stu-id="d0e93-218">**DevIQ. The Aggregate pattern** </span></span>\
  <https://deviq.com/aggregate-pattern/>

>[!div class="step-by-step"]
><span data-ttu-id="d0e93-219">[Poprzedni](ddd-oriented-microservice.md) 
> [Dalej](net-core-microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="d0e93-219">[Previous](ddd-oriented-microservice.md)
[Next](net-core-microservice-domain-model.md)</span></span>
