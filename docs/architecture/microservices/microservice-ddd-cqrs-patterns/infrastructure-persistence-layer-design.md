---
title: Projektowanie warstwy trwałości infrastruktury
description: Architektura mikrousług platformy .NET dla aplikacji platformy .NET w kontenerze | Zapoznaj się z wzorcem repozytorium w projekcie warstwy trwałości infrastruktury.
ms.date: 10/08/2018
ms.openlocfilehash: 76f545403a1b595ce7a541a96d212b9406d89c10
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/30/2019
ms.locfileid: "70295909"
---
# <a name="design-the-infrastructure-persistence-layer"></a><span data-ttu-id="2bf8d-103">Zaprojektowanie warstwy trwałości infrastruktury</span><span class="sxs-lookup"><span data-stu-id="2bf8d-103">Design the infrastructure persistence layer</span></span>

<span data-ttu-id="2bf8d-104">Składniki trwałości danych zapewniają dostęp do danych znajdujących się w granicach mikrousługi (czyli bazy danych mikrousług).</span><span class="sxs-lookup"><span data-stu-id="2bf8d-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="2bf8d-105">Zawierają one rzeczywistą implementację składników, takich jak repozytoria i klasy [jednostek pracy](https://martinfowler.com/eaaCatalog/unitOfWork.html) , takie jak niestandardowe obiekty Entity Framework ( <xref:Microsoft.EntityFrameworkCore.DbContext> EF).</span><span class="sxs-lookup"><span data-stu-id="2bf8d-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span> <span data-ttu-id="2bf8d-106">EF DbContext implementuje oba elementy, repozytorium i jednostki pracy.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-106">EF DbContext implements both, the Repository and the Unit of Work patterns.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="2bf8d-107">Wzorzec repozytorium</span><span class="sxs-lookup"><span data-stu-id="2bf8d-107">The Repository pattern</span></span>

<span data-ttu-id="2bf8d-108">Repozytoria to klasy lub składniki, które hermetyzują logikę wymaganą do uzyskiwania dostępu do źródeł danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="2bf8d-109">Umożliwiają one scentralizowanie funkcji dostępu do danych, co zapewnia lepszą łatwość utrzymania i rozdzielenie infrastruktury lub technologii używanej do uzyskiwania dostępu do baz danych z warstwy modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="2bf8d-110">Jeśli używasz mapowania obiektowo-relacyjnego (ORM), takiego jak Entity Framework, kod, który musi być zaimplementowany, jest uproszczony, dzięki czemu LINQ i silne pisanie.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-110">If you use an Object-Relational Mapper (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="2bf8d-111">Pozwala to skupić się na logice trwałości danych, a nie na instalacji wodociągowej.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="2bf8d-112">Wzorzec repozytorium jest dobrze udokumentowanym sposobem pracy ze źródłem danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="2bf8d-113">W [wzorcach księgi architektury aplikacji przedsiębiorstwa](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowlera opisuje repozytorium w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="2bf8d-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="2bf8d-114">Repozytorium wykonuje zadania pośredniego między warstwami modelu domeny i mapowaniem danych, działając w podobny sposób jak w przypadku zestawu obiektów domeny w pamięci.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="2bf8d-115">Obiekty klienta deklaratywnie kompilują zapytania i wysyłają je do repozytoriów na potrzeby odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="2bf8d-116">Koncepcyjnie repozytorium jest hermetyzowane z zestawem obiektów przechowywanych w bazie danych i operacjach, które mogą być wykonywane na nich, zapewniając sposób zbliżony do warstwy trwałości.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="2bf8d-117">Repozytoria, również obsługa celu oddzielenia, jasno i w jednym kierunku, zależności między domeną służbową i alokacją danych lub mapowaniem.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="2bf8d-118">Zdefiniuj jedno repozytorium na zagregowane</span><span class="sxs-lookup"><span data-stu-id="2bf8d-118">Define one repository per aggregate</span></span>

<span data-ttu-id="2bf8d-119">Dla każdego elementu zagregowanego agregacji lub agregacji należy utworzyć jedną klasę repozytorium.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="2bf8d-120">W mikrousłudze na podstawie wzorców projektowania opartego na domenach (DDD) jedynym kanałem, którego należy użyć do zaktualizowania bazy danych, powinny być repozytoria.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-120">In a microservice based on Domain-Driven Design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="2bf8d-121">Wynika to z faktu, że mają one relację jeden do jednego z zagregowanym elementem głównym, który kontroluje niezagregowaną i transakcyjną spójność agregacji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="2bf8d-122">Nie można wysyłać zapytań do bazy danych za pomocą innych kanałów (jak w przypadku podejścia CQRS), ponieważ zapytania nie zmieniają stanu bazy danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-122">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="2bf8d-123">Jednak obszar transakcyjny (czyli aktualizacje) musi być zawsze kontrolowany przez repozytoria i zagregowane elementy główne.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-123">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="2bf8d-124">W zasadzie repozytorium umożliwia wypełnienie danych w pamięci pochodzącej z bazy danych w postaci jednostek domeny.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="2bf8d-125">Gdy jednostki znajdują się w pamięci, można je zmienić, a następnie utrwalić z powrotem do bazy danych za pomocą transakcji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="2bf8d-126">Jak wspomniano wcześniej, jeśli używasz wzorca architektury CQS/CQRS, początkowe zapytania są wykonywane przez zapytania boczne z modelu domeny, wykonywane przez proste instrukcje SQL przy użyciu Dapper.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-126">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="2bf8d-127">Takie podejście jest znacznie bardziej elastyczne niż repozytoria, ponieważ można wykonywać zapytania i dołączać do dowolnych tabel, które nie są ograniczone przez reguły z agregacji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="2bf8d-128">Te dane przechodzą do warstwy prezentacji lub aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-128">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="2bf8d-129">Jeśli użytkownik wprowadza zmiany, dane, które mają zostać zaktualizowane, pochodzą z aplikacji klienckiej lub z warstwy prezentacji do warstwy aplikacji (takiej jak usługa interfejsu API sieci Web).</span><span class="sxs-lookup"><span data-stu-id="2bf8d-129">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="2bf8d-130">Po otrzymaniu polecenia w programie obsługi poleceń, należy użyć repozytoriów, aby pobrać dane, które mają zostać zaktualizowane z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-130">When you receive a command in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="2bf8d-131">Aktualizujesz ją w pamięci za pomocą danych przesłanych z poleceniami, a następnie dodasz lub zaktualizujesz dane (jednostki domeny) w bazie danych za pomocą transakcji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-131">You update it in memory with the data passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="2bf8d-132">Ważne jest, aby ponownie wyróżnić tylko jedno repozytorium dla każdego zagregowanego elementu głównego, jak pokazano na rysunku 7-17.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-132">It's important to emphasize again that you should only define one repository for each aggregate root, as shown in Figure 7-17.</span></span> <span data-ttu-id="2bf8d-133">Aby osiągnąć cel zagregowanego elementu głównego, aby zachować spójność transakcyjną między wszystkimi obiektami w ramach agregacji, nigdy nie należy tworzyć repozytorium dla każdej tabeli w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![Relacje między warstwami domeny i infrastruktury: Agregacja kupująca zależy od IBuyerRepository i kolejności agregacji, zależnie od interfejsów IOrderRepository, te interfejsy są implementowane w warstwie infrastruktury przez odpowiednie repozytoria, które zależą od UnitOfWork, również zaimplementowane w tym miejscu. uzyskuje dostęp do tabel w warstwie danych.](./media/image18.png)

<span data-ttu-id="2bf8d-135">**Rysunek 7-17**.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-135">**Figure 7-17**.</span></span> <span data-ttu-id="2bf8d-136">Relacja między repozytoriami, agregacjami i tabelami baz danych</span><span class="sxs-lookup"><span data-stu-id="2bf8d-136">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforce-one-aggregate-root-per-repository"></a><span data-ttu-id="2bf8d-137">Wymuszaj jeden zagregowany element główny na repozytorium</span><span class="sxs-lookup"><span data-stu-id="2bf8d-137">Enforce one aggregate root per repository</span></span>

<span data-ttu-id="2bf8d-138">Może być cenny do zaimplementowania projektu repozytorium w taki sposób, że wymusza regułę, że tylko agregowane elementy główne powinny mieć repozytoria.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-138">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="2bf8d-139">Można utworzyć typ repozytorium generycznego lub podstawowego, który ogranicza typ jednostek, z którymi współpracuje, aby upewnić się, że mają `IAggregateRoot` interfejs znacznika.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-139">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="2bf8d-140">W ten sposób każda klasa repozytorium zaimplementowana w warstwie infrastruktury implementuje swój własny kontrakt lub interfejs, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="2bf8d-140">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="2bf8d-141">Każdy interfejs określonego repozytorium implementuje ogólny interfejs IRepository:</span><span class="sxs-lookup"><span data-stu-id="2bf8d-141">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="2bf8d-142">Jednak lepszym sposobem zapewnienia, że kod wymusza Konwencję, że każde repozytorium jest powiązane z pojedynczą agregacją, ma na celu implementację ogólnego typu repozytorium.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-142">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="2bf8d-143">Dzięki temu jest to jawne, że używasz repozytorium, aby określić wartość zagregowaną.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-143">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="2bf8d-144">Można to łatwo zrobić, implementując ogólny `IRepository` interfejs podstawowy, jak w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="2bf8d-144">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="2bf8d-145">Wzorzec repozytorium ułatwia testowanie logiki aplikacji</span><span class="sxs-lookup"><span data-stu-id="2bf8d-145">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="2bf8d-146">Wzorzec repozytorium umożliwia łatwe testowanie aplikacji za pomocą testów jednostkowych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-146">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="2bf8d-147">Należy pamiętać, że testy jednostkowe tylko testują kod, a nie infrastruktury, więc abstrakcje repozytorium ułatwiają osiągnięcie tego celu.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-147">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="2bf8d-148">Zgodnie z wcześniejszą sekcją zaleca się zdefiniowanie i umieszczenie interfejsów repozytorium w warstwie modelu domeny, tak aby warstwa aplikacji, taka jak mikrousługa internetowego interfejsu API, nie zależała bezpośrednio od warstwy infrastruktury, w której zostały zaimplementowane. rzeczywiste klasy repozytorium.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-148">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="2bf8d-149">Wykonując te czynności i korzystając z iniekcji zależności na kontrolerach internetowego interfejsu API, można zaimplementować repozytoria, które zwracają fałszywe dane zamiast danych z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-149">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="2bf8d-150">To rozdzielone podejście umożliwia tworzenie i uruchamianie testów jednostkowych, które koncentrują się na logice aplikacji, bez konieczności łączności z bazą danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-150">This decoupled approach allows you to create and run unit tests that focus the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="2bf8d-151">Połączenia z bazami danych mogą zakończyć się niepowodzeniem i, co ważniejsze, uruchamianie setek testów względem bazy danych jest nieprawidłowe z dwóch powodów.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-151">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="2bf8d-152">Po pierwsze może zająć dużo czasu z powodu dużej liczby testów.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-152">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="2bf8d-153">Następnie rekordy bazy danych mogą ulec zmianie i mieć wpływ na wyniki testów, dzięki czemu mogą być niespójne.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-153">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="2bf8d-154">Testowanie bazy danych nie jest testem jednostkowym, ale testem integracji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-154">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="2bf8d-155">Należy szybko uruchamiać wiele testów jednostkowych, ale mniej testów integracji z bazami danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-155">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="2bf8d-156">W odniesieniu do separacji problemów testów jednostkowych, logika działa na jednostkach domeny w pamięci.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-156">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="2bf8d-157">Przyjęto założenie, że Klasa repozytorium dostarczyła te.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-157">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="2bf8d-158">Gdy logika modyfikuje jednostki domeny, zakłada, że Klasa repozytorium będzie je poprawnie przechowywać.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-158">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="2bf8d-159">Ważnym punktem jest utworzenie testów jednostkowych względem modelu domeny i jego logiki domeny.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-159">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="2bf8d-160">Zagregowane elementy główne są głównymi granicami spójności w DDD.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-160">Aggregate roots are the main consistency boundaries in DDD.</span></span>

<span data-ttu-id="2bf8d-161">Repozytoria zaimplementowane w eShopOnContainers polegają EF Core na implementacji DbContext dla wzorców repozytorium i jednostki pracy przy użyciu modułu śledzącego zmiany, dzięki czemu nie duplikują tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-161">The repositories implemented in eShopOnContainers rely on EF Core’s DbContext implementation of the Repository and Unit of Work patterns using its change tracker, so they don’t duplicate this functionality.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="2bf8d-162">Różnica między wzorcem repozytorium a wzorcem starszej klasy dostępu do danych (Klasa DAL)</span><span class="sxs-lookup"><span data-stu-id="2bf8d-162">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="2bf8d-163">Obiekt dostępu do danych bezpośrednio wykonuje operacje dostępu do danych i trwałości w odniesieniu do magazynu.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-163">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="2bf8d-164">Repozytorium oznacza dane z operacjami, które mają być wykonywane w pamięci jednostki obiektu pracy (jak w EF w przypadku używania <xref:Microsoft.EntityFrameworkCore.DbContext> klasy), ale te aktualizacje nie są bezpośrednio wykonywane w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-164">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately to the database.</span></span>

<span data-ttu-id="2bf8d-165">Jednostka pracy jest określana jako pojedyncza transakcja, która obejmuje wiele operacji wstawiania, aktualizowania lub usuwania.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-165">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="2bf8d-166">W prostym przypadku oznacza to, że dla konkretnej akcji użytkownika, takiej jak rejestracja w witrynie sieci Web, wszystkie operacje wstawiania, aktualizowania i usuwania są obsługiwane w jednej transakcji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-166">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete operations are handled in a single transaction.</span></span> <span data-ttu-id="2bf8d-167">Jest to bardziej wydajne niż obsługa wielu transakcji bazy danych w chattier sposób.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-167">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="2bf8d-168">Te wiele operacji trwałości są wykonywane później w ramach jednej akcji, gdy kod z warstwy aplikacji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-168">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="2bf8d-169">Decyzja o stosowaniu zmian w pamięci do rzeczywistego magazynu bazy danych jest zwykle oparta na [wzorcu jednostki pracy](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="2bf8d-169">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="2bf8d-170">W EF, wzorzec jednostki pracy jest implementowany jako <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-170">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="2bf8d-171">W wielu przypadkach ten wzorzec lub sposób stosowania operacji do magazynu może zwiększyć wydajność aplikacji i ograniczyć możliwość niespójności.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-171">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="2bf8d-172">Powoduje także zmniejszenie blokowania transakcji w tabelach bazy danych, ponieważ wszystkie zamierzone operacje są zatwierdzane jako część jednej transakcji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-172">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="2bf8d-173">Jest to bardziej wydajne w porównaniu do wykonywania wielu operacji izolowanych względem bazy danych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-173">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="2bf8d-174">W związku z tym wybrany ORM może zoptymalizować wykonywanie względem bazy danych przez zgrupowanie kilku akcji aktualizacji w ramach tej samej transakcji, w przeciwieństwie do wielu małych i oddzielnych wykonań transakcji.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-174">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="2bf8d-175">Repozytoria nie powinny być obowiązkowe</span><span class="sxs-lookup"><span data-stu-id="2bf8d-175">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="2bf8d-176">Niestandardowe repozytoria są przydatne z przyczyn pożądanych wcześniej, a to podejście do mikrousługi porządkowania w eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-176">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="2bf8d-177">Nie jest to jednak zasadniczy wzór do zaimplementowania w projekcie DDD, a nawet w ogólnym opracowaniu platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-177">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="2bf8d-178">Na przykład Jimmy Bogard, podczas przekazywania bezpośredniej opinii dla tego przewodnika, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="2bf8d-178">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="2bf8d-179">Prawdopodobnie to największa opinia.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-179">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="2bf8d-180">Nie jestem wentylatorem dla repozytoriów, głównie ponieważ ukrywają one ważne informacje o podstawowym mechanizmie trwałości.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-180">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="2bf8d-181">To dlatego, że jest to tylko MediatR dla poleceń.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-181">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="2bf8d-182">Mogę użyć pełnej mocy warstwy trwałości i wypchnąć wszystkie takie zachowanie domeny do moich zagregowanych elementów głównych.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-182">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="2bf8d-183">Zazwyczaj nie chcę zasymulować moich repozytoriów — nadal muszę mieć test integracji z rzeczywistym użyciem.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-183">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="2bf8d-184">Dzięki temu CQRS się, że nie mamy jeszcze potrzeby dla repozytoriów.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-184">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="2bf8d-185">Repozytoria mogą być przydatne, ale nie są krytyczne dla Twojego projektu DDD, w sposób, w jaki wzorzec agregacji i bogaty model domeny są.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-185">Repositories might be useful, but they are not critical for your DDD design, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="2bf8d-186">W związku z tym użyj wzorca repozytorium lub nie, tak jak jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-186">Therefore, use the Repository pattern or not, as you see fit.</span></span> <span data-ttu-id="2bf8d-187">Mimo to będziesz używać wzorca repozytorium za każdym razem, gdy używasz EF Core, chociaż w tym przypadku repozytorium obejmuje całą mikrousługę lub ograniczony kontekst.</span><span class="sxs-lookup"><span data-stu-id="2bf8d-187">Anyway, you’ll be using the repository pattern whenever you use EF Core although, in this case, the repository covers the whole microservice or bounded context.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="2bf8d-188">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="2bf8d-188">Additional resources</span></span>

### <a name="repository-pattern"></a><span data-ttu-id="2bf8d-189">Wzorzec repozytorium</span><span class="sxs-lookup"><span data-stu-id="2bf8d-189">Repository pattern</span></span>

- <span data-ttu-id="2bf8d-190">**Wzorzec repozytorium** </span><span class="sxs-lookup"><span data-stu-id="2bf8d-190">**The Repository pattern** </span></span>\
  <https://deviq.com/repository-pattern/>

- <span data-ttu-id="2bf8d-191">**Edward Hieatt i Rob Me. Wzorzec repozytorium.**</span><span class="sxs-lookup"><span data-stu-id="2bf8d-191">**Edward Hieatt and Rob Mee. Repository pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/repository.html>

- <span data-ttu-id="2bf8d-192">**Wzorzec repozytorium** </span><span class="sxs-lookup"><span data-stu-id="2bf8d-192">**The Repository pattern** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)>

- <span data-ttu-id="2bf8d-193">**Eric Evans. Projektowanie oparte na domenie: Zapełnianie się złożonością oprogramowania.**</span><span class="sxs-lookup"><span data-stu-id="2bf8d-193">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="2bf8d-194">(Książka; zawiera omówienie wzorca repozytorium) </span><span class="sxs-lookup"><span data-stu-id="2bf8d-194">(Book; includes a discussion of the Repository pattern) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="2bf8d-195">Wzorzec jednostki pracy</span><span class="sxs-lookup"><span data-stu-id="2bf8d-195">Unit of Work pattern</span></span>

- <span data-ttu-id="2bf8d-196">**Fowlera Martin. Wzorzec jednostki pracy.**</span><span class="sxs-lookup"><span data-stu-id="2bf8d-196">**Martin Fowler. Unit of Work pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/unitOfWork.html>

- <span data-ttu-id="2bf8d-197">**Implementacja wzorców repozytorium i jednostki pracy w aplikacji ASP.NET MVC** </span><span class="sxs-lookup"><span data-stu-id="2bf8d-197">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application** </span></span>\
  <https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application>

>[!div class="step-by-step"]
><span data-ttu-id="2bf8d-198">[Poprzedni](domain-events-design-implementation.md)Następny
>[](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="2bf8d-198">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
