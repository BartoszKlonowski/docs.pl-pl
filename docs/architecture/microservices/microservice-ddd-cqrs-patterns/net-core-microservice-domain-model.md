---
title: Implementowanie modelu domeny mikrousługi za pomocą platformy .NET Core
description: Architektura mikrousług platformy .NET dla aplikacji platformy .NET w kontenerze | Zapoznaj się ze szczegółami implementacji modelu domeny zorientowanego na DDD.
ms.date: 10/08/2018
ms.openlocfilehash: 0b42ecc2440faf5870b2d99e31d03cda00b21ce0
ms.sourcegitcommit: 5280b2aef60a1ed99002dba44e4b9e7f6c830604
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/03/2020
ms.locfileid: "84306915"
---
# <a name="implement-a-microservice-domain-model-with-net-core"></a><span data-ttu-id="e4717-103">Implementowanie modelu domeny mikrousługi przy użyciu platformy .NET Core</span><span class="sxs-lookup"><span data-stu-id="e4717-103">Implement a microservice domain model with .NET Core</span></span>

<span data-ttu-id="e4717-104">W poprzedniej sekcji zostały wyjaśnione podstawowe zasady projektowania i wzorce projektowania modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="e4717-104">In the previous section, the fundamental design principles and patterns for designing a domain model were explained.</span></span> <span data-ttu-id="e4717-105">Teraz można poznać możliwe sposoby implementacji modelu domeny za pomocą platformy .NET Core (zwykłego \# kodu C) i EF Core.</span><span class="sxs-lookup"><span data-stu-id="e4717-105">Now it is time to explore possible ways to implement the domain model by using .NET Core (plain C\# code) and EF Core.</span></span> <span data-ttu-id="e4717-106">Model domeny będzie złożony po prostu z Twojego kodu.</span><span class="sxs-lookup"><span data-stu-id="e4717-106">Your domain model will be composed simply of your code.</span></span> <span data-ttu-id="e4717-107">Będzie on miał tylko wymagania dotyczące modelu EF Core, ale nie rzeczywiste zależności w EF.</span><span class="sxs-lookup"><span data-stu-id="e4717-107">It will have just the EF Core model requirements, but not real dependencies on EF.</span></span> <span data-ttu-id="e4717-108">Nie należy mieć sztywnych zależności ani odwołań do EF Core ani żadnych innych ORM w modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="e4717-108">You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</span></span>

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a><span data-ttu-id="e4717-109">Struktura modelu domeny w niestandardowej bibliotece .NET Standard</span><span class="sxs-lookup"><span data-stu-id="e4717-109">Domain model structure in a custom .NET Standard Library</span></span>

<span data-ttu-id="e4717-110">Organizacja folderu używana dla aplikacji referencyjnej eShopOnContainers pokazuje model DDD dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e4717-110">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application.</span></span> <span data-ttu-id="e4717-111">Może się okazać, że inna organizacja folderu bardziej jasno komunikuje się z opcjami projektu dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e4717-111">You might find that a different folder organization more clearly communicates the design choices made for your application.</span></span> <span data-ttu-id="e4717-112">Jak widać na rysunku 7-10, w modelu domeny porządkowania są dwie wartości zagregowane, zagregowana kolejność i agregacja kupująca.</span><span class="sxs-lookup"><span data-stu-id="e4717-112">As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate.</span></span> <span data-ttu-id="e4717-113">Każda agregacja jest grupą obiektów domeny i obiekty wartości, chociaż może istnieć agregacja złożona z pojedynczej jednostki domeny (jednostki zagregowanej lub głównej).</span><span class="sxs-lookup"><span data-stu-id="e4717-113">Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Zrzut ekranu przedstawiający projekt porządkowanie. domena w Eksplorator rozwiązań.":::
<span data-ttu-id="e4717-115">Widok Eksplorator rozwiązań dla projektu porządkowania. domeny, przedstawiający folder AggregatesModel zawierający foldery BuyerAggregate i OrderAggregate, każdy z nich zawierający klasy jednostek, pliki obiektów wartości i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="e4717-115">The Solution Explorer view for the Ordering.Domain project, showing the AggregatesModel folder containing the BuyerAggregate and OrderAggregate folders, each one containing its entity classes, value object files and so on.</span></span>
:::image-end:::

<span data-ttu-id="e4717-116">**Rysunek 7-10**.</span><span class="sxs-lookup"><span data-stu-id="e4717-116">**Figure 7-10**.</span></span> <span data-ttu-id="e4717-117">Struktura modelu domeny dla mikrousługi porządkowania w eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="e4717-117">Domain model structure for the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="e4717-118">Ponadto warstwa modelu domeny obejmuje kontrakty repozytorium (interfejsy), które są wymaganiami infrastruktury modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="e4717-118">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model.</span></span> <span data-ttu-id="e4717-119">Innymi słowy, te interfejsy wyrażają, jakie repozytoria i metody muszą być implementowane przez warstwę infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="e4717-119">In other words, these interfaces express what repositories and the methods the infrastructure layer must implement.</span></span> <span data-ttu-id="e4717-120">Ważne jest, aby implementacja repozytoriów została umieszczona poza warstwą modelu domeny w bibliotece warstw infrastruktury, więc warstwa modelu domeny nie jest "zanieczyszczona" przez interfejsy API lub klasy z technologii infrastruktury, takich jak Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="e4717-120">It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not "contaminated" by API or classes from infrastructure technologies, like Entity Framework.</span></span>

<span data-ttu-id="e4717-121">Można również wyświetlić folder [SeedWork](https://martinfowler.com/bliki/Seedwork.html) zawierający niestandardowe klasy bazowe, których można użyć jako podstawy dla jednostek domeny i obiektów wartości, dzięki czemu nie masz nadmiarowego kodu w klasie obiektów każdej domeny.</span><span class="sxs-lookup"><span data-stu-id="e4717-121">You can also see a [SeedWork](https://martinfowler.com/bliki/Seedwork.html) folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain's object class.</span></span>

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a><span data-ttu-id="e4717-122">Agregowanie struktury w niestandardowej bibliotece .NET Standard</span><span class="sxs-lookup"><span data-stu-id="e4717-122">Structure aggregates in a custom .NET Standard library</span></span>

<span data-ttu-id="e4717-123">Agregacja odnosi się do klastra obiektów domeny zgrupowanych w celu dopasowania spójności transakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="e4717-123">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency.</span></span> <span data-ttu-id="e4717-124">Te obiekty mogą być wystąpieniami jednostek (z których jednym jest agregacją główną lub główną jednostką) oraz wszelkimi dodatkowymi obiektami wartości.</span><span class="sxs-lookup"><span data-stu-id="e4717-124">Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</span></span>

<span data-ttu-id="e4717-125">Spójność transakcyjna oznacza, że agregowanie ma zagwarantować spójność i aktualność na końcu działania biznesowego.</span><span class="sxs-lookup"><span data-stu-id="e4717-125">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action.</span></span> <span data-ttu-id="e4717-126">Na przykład agregacja kolejności z modelu domeny mikrousługi eShopOnContainers porządkowania składa się, jak pokazano na rysunku 7-11.</span><span class="sxs-lookup"><span data-stu-id="e4717-126">For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Zrzut ekranu przedstawiający folder OrderAggregate i jego klasy.":::
<span data-ttu-id="e4717-128">Szczegółowy widok folderu OrderAggregate: Address.cs jest obiektem wartości, IOrderRepository jest interfejsem repozytorium, Order.cs jest elementem głównym agregacji, OrderItem.cs jest jednostką podrzędną, a OrderStatus.cs jest klasą wyliczania.</span><span class="sxs-lookup"><span data-stu-id="e4717-128">A detailed view of the OrderAggregate folder: Address.cs is a value object, IOrderRepository is a repo interface, Order.cs is an aggregate root, OrderItem.cs is a child entity, and OrderStatus.cs is an enumeration class.</span></span>
:::image-end:::

<span data-ttu-id="e4717-129">**Rysunek 7-11**.</span><span class="sxs-lookup"><span data-stu-id="e4717-129">**Figure 7-11**.</span></span> <span data-ttu-id="e4717-130">Agregacja kolejności w rozwiązaniu Visual Studio</span><span class="sxs-lookup"><span data-stu-id="e4717-130">The order aggregate in Visual Studio solution</span></span>

<span data-ttu-id="e4717-131">W przypadku otwarcia dowolnego pliku w folderze zagregowanym można zobaczyć, jak jest on oznaczony jako niestandardową klasę bazową lub interfejs, taki jak obiekt jednostki lub wartości, zgodnie z zaimplementowaną w folderze [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) .</span><span class="sxs-lookup"><span data-stu-id="e4717-131">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) folder.</span></span>

## <a name="implement-domain-entities-as-poco-classes"></a><span data-ttu-id="e4717-132">Implementowanie jednostek domeny jako klas POCO</span><span class="sxs-lookup"><span data-stu-id="e4717-132">Implement domain entities as POCO classes</span></span>

<span data-ttu-id="e4717-133">Aby zaimplementować model domeny w programie .NET, należy utworzyć klasy POCO, które implementują jednostki domeny.</span><span class="sxs-lookup"><span data-stu-id="e4717-133">You implement a domain model in .NET by creating POCO classes that implement your domain entities.</span></span> <span data-ttu-id="e4717-134">W poniższym przykładzie Klasa Order jest definiowana jako jednostka, a także jako zagregowany element główny.</span><span class="sxs-lookup"><span data-stu-id="e4717-134">In the following example, the Order class is defined as an entity and also as an aggregate root.</span></span> <span data-ttu-id="e4717-135">Ponieważ Klasa Order dziedziczy z klasy podstawowej jednostki, może ponownie użyć wspólnego kodu związanego z jednostkami.</span><span class="sxs-lookup"><span data-stu-id="e4717-135">Because the Order class derives from the Entity base class, it can reuse common code related to entities.</span></span> <span data-ttu-id="e4717-136">Należy pamiętać, że te klasy bazowe i interfejsy są zdefiniowane przez użytkownika w projekcie modelu domeny, więc jest to kod, a nie kod infrastruktury z ORM, np. EF.</span><span class="sxs-lookup"><span data-stu-id="e4717-136">Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</span></span>

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 2.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

<span data-ttu-id="e4717-137">Należy pamiętać, że jest to jednostka domeny zaimplementowana jako Klasa POCO.</span><span class="sxs-lookup"><span data-stu-id="e4717-137">It is important to note that this is a domain entity implemented as a POCO class.</span></span> <span data-ttu-id="e4717-138">Nie ma żadnej bezpośredniej zależności od Entity Framework Core ani żadnych innych struktur infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="e4717-138">It does not have any direct dependency on Entity Framework Core or any other infrastructure framework.</span></span> <span data-ttu-id="e4717-139">Ta implementacja ma charakter w DDD, po prostu kod C# implementujący model domeny.</span><span class="sxs-lookup"><span data-stu-id="e4717-139">This implementation is as it should be in DDD, just C# code implementing a domain model.</span></span>

<span data-ttu-id="e4717-140">Ponadto Klasa ma interfejs o nazwie IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="e4717-140">In addition, the class is decorated with an interface named IAggregateRoot.</span></span> <span data-ttu-id="e4717-141">Ten interfejs jest pustym interfejsem, czasami nazywany *interfejsem znacznika*, który jest używany tylko do wskazania, że ta klasa jednostki jest również zagregowanym elementem głównym.</span><span class="sxs-lookup"><span data-stu-id="e4717-141">That interface is an empty interface, sometimes called a *marker interface*, that is used just to indicate that this entity class is also an aggregate root.</span></span>

<span data-ttu-id="e4717-142">Interfejs znacznika jest czasami traktowany jako Antywzorzec; Jednak jest to również czysty sposób oznaczania klasy, szczególnie w przypadku, gdy ten interfejs może się pojawić.</span><span class="sxs-lookup"><span data-stu-id="e4717-142">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving.</span></span> <span data-ttu-id="e4717-143">Atrybut może być innym wyborem dla znacznika, ale jest szybszym sposobem wyświetlania klasy bazowej (jednostki) obok interfejsu IAggregate zamiast umieszczania znacznika atrybutu agregacji powyżej klasy.</span><span class="sxs-lookup"><span data-stu-id="e4717-143">An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class.</span></span> <span data-ttu-id="e4717-144">W każdym przypadku jest to sprawa z preferencjami.</span><span class="sxs-lookup"><span data-stu-id="e4717-144">It is a matter of preferences, in any case.</span></span>

<span data-ttu-id="e4717-145">Posiadanie zagregowanego elementu głównego oznacza, że większość kodu związanego z spójnością i regułami biznesowymi jednostek agregacji powinna być implementowana jako metody w klasie głównej agregacji Order (na przykład AddOrderItem podczas dodawania obiektu OrderItem do agregacji).</span><span class="sxs-lookup"><span data-stu-id="e4717-145">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate's entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate).</span></span> <span data-ttu-id="e4717-146">Nie należy tworzyć ani aktualizować obiektów OrderItems niezależnie lub bezpośrednio; Klasa AggregateRoot musi utrzymywać kontrolę i spójność każdej operacji aktualizacji z jej jednostkami podrzędnymi.</span><span class="sxs-lookup"><span data-stu-id="e4717-146">You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</span></span>

## <a name="encapsulate-data-in-the-domain-entities"></a><span data-ttu-id="e4717-147">Hermetyzuj dane w jednostkach domeny</span><span class="sxs-lookup"><span data-stu-id="e4717-147">Encapsulate data in the Domain Entities</span></span>

<span data-ttu-id="e4717-148">Typowy problem związany z modelami jednostek polega na udostępnieniu właściwości nawigacji kolekcji jako typów list dostępnych publicznie.</span><span class="sxs-lookup"><span data-stu-id="e4717-148">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types.</span></span> <span data-ttu-id="e4717-149">Pozwala to deweloperom współpracownikom na manipulowanie zawartością tych typów kolekcji, co może spowodować obejście ważnych reguł firmy związanych z kolekcją, prawdopodobnie pozostawiając obiekt w nieprawidłowym stanie.</span><span class="sxs-lookup"><span data-stu-id="e4717-149">This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state.</span></span> <span data-ttu-id="e4717-150">Rozwiązaniem tego problemu jest udostępnienie dostępu tylko do odczytu do powiązanych kolekcji i jawne dostarczenie metod, które definiują sposoby manipulowania nimi przez klientów.</span><span class="sxs-lookup"><span data-stu-id="e4717-150">The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</span></span>

<span data-ttu-id="e4717-151">W poprzednim kodzie należy zauważyć, że wiele atrybutów jest tylko do odczytu lub jako prywatne i można je aktualizować tylko przy użyciu metod klasy, więc każda aktualizacja traktuje nieodmiany i logikę domeny biznesowej określone w metodach klasy.</span><span class="sxs-lookup"><span data-stu-id="e4717-151">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</span></span>

<span data-ttu-id="e4717-152">Na przykład, poniższe wzorce DDD, \*\* *nie* należy wykonywać następujących czynności\*\* z żadnej metody obsługi poleceń lub klasy aplikacji (w rzeczywistości powinna to być niemożliwe):</span><span class="sxs-lookup"><span data-stu-id="e4717-152">For example, following DDD patterns, **you should *not* do the following** from any command handler method or application layer class (actually, it should be impossible for you to do so):</span></span>

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

<span data-ttu-id="e4717-153">W tym przypadku metoda Add jest czysto operacją dodawania danych, z bezpośrednim dostępem do kolekcji OrderItems.</span><span class="sxs-lookup"><span data-stu-id="e4717-153">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection.</span></span> <span data-ttu-id="e4717-154">W związku z tym większość logiki domeny, reguł lub walidacji związanych z tą operacją z jednostkami podrzędnymi zostanie rozłożona między warstwą aplikacji (programy obsługi poleceń i kontrolery API sieci Web).</span><span class="sxs-lookup"><span data-stu-id="e4717-154">Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</span></span>

<span data-ttu-id="e4717-155">Jeśli przejdziesz do zagregowanego elementu głównego, zagregowany element główny nie może zagwarantować jego nieważności, jego poprawności lub jego spójności.</span><span class="sxs-lookup"><span data-stu-id="e4717-155">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency.</span></span> <span data-ttu-id="e4717-156">Ostatecznie będziesz mieć kod spaghetti lub transakcyjny kod skryptu.</span><span class="sxs-lookup"><span data-stu-id="e4717-156">Eventually you will have spaghetti code or transactional script code.</span></span>

<span data-ttu-id="e4717-157">Aby obserwować wzorce DDD, jednostki nie mogą mieć publicznych metod ustawiających we właściwościach Entity.</span><span class="sxs-lookup"><span data-stu-id="e4717-157">To follow DDD patterns, entities must not have public setters in any entity property.</span></span> <span data-ttu-id="e4717-158">Zmiany w jednostce powinny być oparte na jawnych metodach z jawnym, powszechnie używanym językiem o zmianach wykonywanych w jednostce.</span><span class="sxs-lookup"><span data-stu-id="e4717-158">Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</span></span>

<span data-ttu-id="e4717-159">Ponadto kolekcje w jednostce (takie jak Order Items) powinny być właściwościami tylko do odczytu (Metoda AsReadOnly omówiona później).</span><span class="sxs-lookup"><span data-stu-id="e4717-159">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later).</span></span> <span data-ttu-id="e4717-160">Należy ją zaktualizować tylko z poziomu metod klasy głównej agregacji lub metod jednostki podrzędnej.</span><span class="sxs-lookup"><span data-stu-id="e4717-160">You should be able to update it only from within the aggregate root class methods or the child entity methods.</span></span>

<span data-ttu-id="e4717-161">Jak widać w kodzie dla głównego elementu agregacji zamówienia, wszystkie metody ustawiające powinny być prywatne lub tylko do odczytu na zewnątrz, tak aby każda operacja na danych jednostki lub jej jednostkach podrzędnych była wykonywana za pomocą metod klasy Entity.</span><span class="sxs-lookup"><span data-stu-id="e4717-161">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity's data or its child entities has to be performed through methods in the entity class.</span></span> <span data-ttu-id="e4717-162">Zapewnia to spójność kontrolowanych i zorientowanych obiektowo, a nie implementowanie kodu skryptu transakcyjnego.</span><span class="sxs-lookup"><span data-stu-id="e4717-162">This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</span></span>

<span data-ttu-id="e4717-163">Poniższy fragment kodu przedstawia właściwy sposób kodowania zadania dodawania obiektu OrderItem do agregacji zamówienia.</span><span class="sxs-lookup"><span data-stu-id="e4717-163">The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate.</span></span>

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object's business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

<span data-ttu-id="e4717-164">W tym fragmencie kodu większość walidacji lub logiki związanych z tworzeniem obiektu OrderItem będzie podlegać kontroli nad elementem głównym agregacji zamówienia — w metodzie AddOrderItem — szczególnie walidacji i logika związanych z innymi elementami w agregacji.</span><span class="sxs-lookup"><span data-stu-id="e4717-164">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate.</span></span> <span data-ttu-id="e4717-165">Na przykład można uzyskać ten sam element produktu, co w wyniku wielu wywołań AddOrderItem.</span><span class="sxs-lookup"><span data-stu-id="e4717-165">For instance, you might get the same product item as the result of multiple calls to AddOrderItem.</span></span> <span data-ttu-id="e4717-166">W tej metodzie można przeanalizować elementy produktu i skonsolidować te same elementy produktu w pojedynczy obiekt OrderItem o kilku jednostkach.</span><span class="sxs-lookup"><span data-stu-id="e4717-166">In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units.</span></span> <span data-ttu-id="e4717-167">Ponadto jeśli istnieją różne kwoty rabatu, ale identyfikator produktu jest taki sam, prawdopodobnie obowiązuje wyższy rabat.</span><span class="sxs-lookup"><span data-stu-id="e4717-167">Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount.</span></span> <span data-ttu-id="e4717-168">Ta zasada ma zastosowanie do każdej innej logiki domeny dla obiektu OrderItem.</span><span class="sxs-lookup"><span data-stu-id="e4717-168">This principle applies to any other domain logic for the OrderItem object.</span></span>

<span data-ttu-id="e4717-169">Ponadto nowa operacja OrderItem (params) również będzie kontrolowana i wykonywana przez metodę AddOrderItem z poziomu głównego agregacji Order.</span><span class="sxs-lookup"><span data-stu-id="e4717-169">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root.</span></span> <span data-ttu-id="e4717-170">W związku z tym większość logiki lub walidacji związanych z tą operacją (szczególnie każdy ma wpływ na spójność między innymi jednostkami podrzędnymi) będzie w jednym miejscu w ramach zagregowanego elementu głównego.</span><span class="sxs-lookup"><span data-stu-id="e4717-170">Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root.</span></span> <span data-ttu-id="e4717-171">Jest to ostateczny cel zagregowanego wzorca głównego.</span><span class="sxs-lookup"><span data-stu-id="e4717-171">That is the ultimate purpose of the aggregate root pattern.</span></span>

<span data-ttu-id="e4717-172">W przypadku korzystania z Entity Framework Core 1,1 lub nowszej jednostka DDD może być lepiej wyrażona, ponieważ umożliwia ona [Mapowanie do pól](https://docs.microsoft.com/ef/core/modeling/backing-field) oprócz właściwości.</span><span class="sxs-lookup"><span data-stu-id="e4717-172">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows [mapping to fields](https://docs.microsoft.com/ef/core/modeling/backing-field) in addition to properties.</span></span> <span data-ttu-id="e4717-173">Jest to przydatne w przypadku ochrony kolekcji jednostek podrzędnych lub obiektów wartości.</span><span class="sxs-lookup"><span data-stu-id="e4717-173">This is useful when protecting collections of child entities or value objects.</span></span> <span data-ttu-id="e4717-174">Dzięki temu ulepszeniu można używać prostych prywatnych pól zamiast właściwości i można zaimplementować dowolną aktualizację do kolekcji pól w metodach publicznych i zapewnić dostęp tylko do odczytu za pomocą metody AsReadOnly.</span><span class="sxs-lookup"><span data-stu-id="e4717-174">With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></span>

<span data-ttu-id="e4717-175">W DDD należy zaktualizować jednostkę tylko za pomocą metod w jednostce (lub w konstruktorze) w celu kontrolowania wszelkich niezmiennej i spójności danych, dlatego właściwości są definiowane tylko przy użyciu metody dostępu get.</span><span class="sxs-lookup"><span data-stu-id="e4717-175">In DDD, you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor.</span></span> <span data-ttu-id="e4717-176">Właściwości są obsługiwane przez pola prywatne.</span><span class="sxs-lookup"><span data-stu-id="e4717-176">The properties are backed by private fields.</span></span> <span data-ttu-id="e4717-177">Dostęp do prywatnych elementów członkowskich można uzyskać tylko z poziomu klasy.</span><span class="sxs-lookup"><span data-stu-id="e4717-177">Private members can only be accessed from within the class.</span></span> <span data-ttu-id="e4717-178">Istnieje jednak jeden wyjątek: EF Core muszą także ustawiać te pola (aby można było zwrócić obiekt z prawidłowymi wartościami).</span><span class="sxs-lookup"><span data-stu-id="e4717-178">However, there one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</span></span>

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a><span data-ttu-id="e4717-179">Właściwości mapy z dostępem tylko do pól w tabeli bazy danych</span><span class="sxs-lookup"><span data-stu-id="e4717-179">Map properties with only get accessors to the fields in the database table</span></span>

<span data-ttu-id="e4717-180">Mapowanie właściwości do kolumn tabeli bazy danych nie jest odpowiedzialnością w domenie, ale częścią infrastruktury i warstwy trwałości.</span><span class="sxs-lookup"><span data-stu-id="e4717-180">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer.</span></span> <span data-ttu-id="e4717-181">Tutaj wspominamy o nowych możliwościach EF Core 1,1 lub nowszych związanych z tym, jak można modelować jednostki.</span><span class="sxs-lookup"><span data-stu-id="e4717-181">We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities.</span></span> <span data-ttu-id="e4717-182">Dodatkowe szczegóły dotyczące tego tematu zostały omówione w sekcji infrastruktura i trwałość.</span><span class="sxs-lookup"><span data-stu-id="e4717-182">Additional details on this topic are explained in the infrastructure and persistence section.</span></span>

<span data-ttu-id="e4717-183">W przypadku korzystania z EF Core 1,0 lub nowszego w kontekście DbContext należy zmapować właściwości, które są zdefiniowane tylko przez metody pobierające do rzeczywistych pól w tabeli bazy danych.</span><span class="sxs-lookup"><span data-stu-id="e4717-183">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table.</span></span> <span data-ttu-id="e4717-184">Jest to realizowane za pomocą metody HasField klasy PropertyBuilder.</span><span class="sxs-lookup"><span data-stu-id="e4717-184">This is done with the HasField method of the PropertyBuilder class.</span></span>

### <a name="map-fields-without-properties"></a><span data-ttu-id="e4717-185">Mapuj pola bez właściwości</span><span class="sxs-lookup"><span data-stu-id="e4717-185">Map fields without properties</span></span>

<span data-ttu-id="e4717-186">Przy użyciu funkcji w EF Core 1,1 lub nowszej, aby zamapować kolumny na pola, można również nie używać właściwości.</span><span class="sxs-lookup"><span data-stu-id="e4717-186">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties.</span></span> <span data-ttu-id="e4717-187">Zamiast tego można po prostu zmapować kolumny z tabeli do pól.</span><span class="sxs-lookup"><span data-stu-id="e4717-187">Instead, you can just map columns from a table to fields.</span></span> <span data-ttu-id="e4717-188">Typowym przypadkiem użycia jest to pole prywatne dla stanu wewnętrznego, do którego nie trzeba uzyskiwać dostępu poza jednostką.</span><span class="sxs-lookup"><span data-stu-id="e4717-188">A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</span></span>

<span data-ttu-id="e4717-189">Na przykład w poprzednim przykładzie kodu OrderAggregate istnieje kilka pól prywatnych, takich jak `_paymentMethodId` pole, które nie ma powiązanej właściwości dla metody ustawiającej lub pobierającej.</span><span class="sxs-lookup"><span data-stu-id="e4717-189">For example, in the preceding OrderAggregate code example, there are several private fields, like the  `_paymentMethodId` field, that have no related property for either a setter or getter.</span></span> <span data-ttu-id="e4717-190">To pole może być również obliczane w ramach logiki biznesowej i stosowane z metod zamówienia, ale muszą być również utrwalane w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="e4717-190">That field could also be calculated within the order's business logic and used from the order's methods, but it needs to be persisted in the database as well.</span></span> <span data-ttu-id="e4717-191">Tak więc w EF Core (od wersji 1.1) istnieje możliwość mapowania pola bez powiązanej właściwości do kolumny w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="e4717-191">So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database.</span></span> <span data-ttu-id="e4717-192">Jest to również wyjaśnione w sekcji [warstwa infrastruktury](ddd-oriented-microservice.md#the-infrastructure-layer) tego przewodnika.</span><span class="sxs-lookup"><span data-stu-id="e4717-192">This is also explained in the [Infrastructure layer](ddd-oriented-microservice.md#the-infrastructure-layer) section of this guide.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="e4717-193">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="e4717-193">Additional resources</span></span>

- <span data-ttu-id="e4717-194">**Vaughn Vernon. Modelowanie agregacji z DDD i Entity Framework.**</span><span class="sxs-lookup"><span data-stu-id="e4717-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.**</span></span> <span data-ttu-id="e4717-195">Należy zauważyć, że *nie* jest to Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="e4717-195">Note that this is *not* Entity Framework Core.</span></span> \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- <span data-ttu-id="e4717-196">**Julie Lerman. Punkty danych — kodowanie dla projektowania opartego na domenie: porady dotyczące Deweloperzyów danych** </span><span class="sxs-lookup"><span data-stu-id="e4717-196">**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span></span>\
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- <span data-ttu-id="e4717-197">**UDI Dahan. Jak utworzyć w pełni hermetyzowane modele domen** </span><span class="sxs-lookup"><span data-stu-id="e4717-197">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> <span data-ttu-id="e4717-198">[Poprzedni](microservice-domain-model.md) 
>  [Dalej](seedwork-domain-model-base-classes-interfaces.md)</span><span class="sxs-lookup"><span data-stu-id="e4717-198">[Previous](microservice-domain-model.md)
[Next](seedwork-domain-model-base-classes-interfaces.md)</span></span>
