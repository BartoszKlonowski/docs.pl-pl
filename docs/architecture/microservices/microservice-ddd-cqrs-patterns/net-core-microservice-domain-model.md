---
title: Implementowanie modelu domeny mikrousługi za pomocą platformy .NET Core
description: Architektura mikrousług .NET dla konteneryzowanych aplikacji .NET | Zapoznaj się ze szczegółami implementacji modelu domeny zorientowanej na DDD.
ms.date: 10/08/2018
ms.openlocfilehash: bff9cbda08e519038056268151a1721427f0ac01
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "73972044"
---
# <a name="implement-a-microservice-domain-model-with-net-core"></a><span data-ttu-id="d1f1c-103">Implementowanie modelu domeny mikrousług za pomocą programu .NET Core</span><span class="sxs-lookup"><span data-stu-id="d1f1c-103">Implement a microservice domain model with .NET Core</span></span>

<span data-ttu-id="d1f1c-104">W poprzedniej sekcji wyjaśniono podstawowe zasady projektowania i wzorce projektowania modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-104">In the previous section, the fundamental design principles and patterns for designing a domain model were explained.</span></span> <span data-ttu-id="d1f1c-105">Teraz nadszedł czas, aby zbadać możliwe sposoby zaimplementowania\# modelu domeny przy użyciu .NET Core (zwykły kod C) i EF Core.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-105">Now it is time to explore possible ways to implement the domain model by using .NET Core (plain C\# code) and EF Core.</span></span> <span data-ttu-id="d1f1c-106">Należy pamiętać, że model domeny będzie składać się po prostu z kodu.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-106">Note that your domain model will be composed simply of your code.</span></span> <span data-ttu-id="d1f1c-107">Będzie miał tylko wymagania modelu EF Core, ale nie rzeczywiste zależności od EF.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-107">It will have just the EF Core model requirements, but not real dependencies on EF.</span></span> <span data-ttu-id="d1f1c-108">Nie powinny mieć twarde zależności lub odwołania do EF Core lub innych ORM w modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-108">You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</span></span>

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a><span data-ttu-id="d1f1c-109">Struktura modelu domeny w niestandardowej standardowej bibliotece .NET</span><span class="sxs-lookup"><span data-stu-id="d1f1c-109">Domain model structure in a custom .NET Standard Library</span></span>

<span data-ttu-id="d1f1c-110">Organizacja folderów używana dla aplikacji referencyjnej eShopOnContainers demonstruje model DDD dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-110">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application.</span></span> <span data-ttu-id="d1f1c-111">Może się okazać, że inna organizacja folderów wyraźniej komunikuje wybory projektowe dokonane dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-111">You might find that a different folder organization more clearly communicates the design choices made for your application.</span></span> <span data-ttu-id="d1f1c-112">Jak widać na rysunku 7-10, w modelu domeny zamawiania istnieją dwa agregaty, agregacja zamówień i agregacja kupującego.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-112">As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate.</span></span> <span data-ttu-id="d1f1c-113">Każda agregacja jest grupą jednostek domeny i obiektów wartości, chociaż może mieć agregację składającą się z pojedynczej jednostki domeny (jednostki głównej lub głównej).</span><span class="sxs-lookup"><span data-stu-id="d1f1c-113">Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Zrzut ekranu przedstawiający projekt Ordering.Domain w Eksploratorze rozwiązań.":::
<span data-ttu-id="d1f1c-115">Widok Eksploratorrozwiązania dla projektu Ordering.Domain, zawierający folder AggregatesModel zawierający foldery BuyerAggregate i OrderAggregate, z których każdy zawiera klasy jednostek, pliki obiektów wartości itd.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-115">The Solution Explorer view for the Ordering.Domain project, showing the AggregatesModel folder containing the BuyerAggregate and OrderAggregate folders, each one containing it's entity classes, value object files and so on.</span></span>
:::image-end:::

<span data-ttu-id="d1f1c-116">**Rysunek 7-10**.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-116">**Figure 7-10**.</span></span> <span data-ttu-id="d1f1c-117">Struktura modelu domeny dla mikrousługi porządkowania w eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="d1f1c-117">Domain model structure for the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="d1f1c-118">Ponadto warstwa modelu domeny zawiera kontrakty repozytorium (interfejsy), które są wymagania infrastrukturalne modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-118">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model.</span></span> <span data-ttu-id="d1f1c-119">Innymi słowy te interfejsy wyrazić, jakie repozytoria i metody warstwy infrastruktury musi implementować.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-119">In other words, these interfaces express what repositories and the methods the infrastructure layer must implement.</span></span> <span data-ttu-id="d1f1c-120">Bardzo ważne jest, aby implementacja repozytoriów została umieszczona poza warstwą modelu domeny w bibliotece warstwy infrastruktury, dzięki czemu warstwa modelu domeny nie jest "zanieczyszczona" interfejsem API lub klasami z technologii infrastruktury, takich jak Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-120">It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not “contaminated” by API or classes from infrastructure technologies, like Entity Framework.</span></span>

<span data-ttu-id="d1f1c-121">Można również wyświetlić [seedwork](https://martinfowler.com/bliki/Seedwork.html) folder, który zawiera niestandardowe klasy podstawowe, które można użyć jako podstawa dla jednostek domeny i obiektów wartości, więc nie masz nadmiarowego kodu w klasie obiektów każdej domeny.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-121">You can also see a [SeedWork](https://martinfowler.com/bliki/Seedwork.html) folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain’s object class.</span></span>

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a><span data-ttu-id="d1f1c-122">Agregacja struktury w niestandardowej bibliotece standardu .NET</span><span class="sxs-lookup"><span data-stu-id="d1f1c-122">Structure aggregates in a custom .NET Standard library</span></span>

<span data-ttu-id="d1f1c-123">Agregat odnosi się do klastra obiektów domeny zgrupowanych w celu dopasowania spójności transakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-123">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency.</span></span> <span data-ttu-id="d1f1c-124">Obiekty te mogą być wystąpienia jednostek (z których jeden jest agregacji jednostki głównej lub głównej) plus wszelkie dodatkowe obiekty wartości.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-124">Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</span></span>

<span data-ttu-id="d1f1c-125">Spójność transakcyjna oznacza, że wartość zagregowana jest spójna i aktualna na koniec akcji biznesowej.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-125">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action.</span></span> <span data-ttu-id="d1f1c-126">Na przykład agregacji zamówienia z eShopOnContainers zamawiania modelu domeny mikrousługi składa się, jak pokazano na rysunku 7-11.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-126">For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Zrzut ekranu przedstawiający folder OrderAggregate i jego klasy.":::
<span data-ttu-id="d1f1c-128">Szczegółowy widok orderuzagregacji folderu: Address.cs jest obiektem wartości, IOrderRepository jest interfejsem repozytorium, Order.cs jest zagregowanym katalogiem głównym, OrderItem.cs jest jednostką podrzędną, a OrderStatus.cs jest klasą wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-128">A detailed view of the OrderAggregate folder: Address.cs is a value object, IOrderRepository is a repo interface, Order.cs is an aggregate root, OrderItem.cs is a child entity, and OrderStatus.cs is an enumeration class.</span></span>
:::image-end:::

<span data-ttu-id="d1f1c-129">**Rysunek 7-11**.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-129">**Figure 7-11**.</span></span> <span data-ttu-id="d1f1c-130">Agregacja zamówień w rozwiązaniu programu Visual Studio</span><span class="sxs-lookup"><span data-stu-id="d1f1c-130">The order aggregate in Visual Studio solution</span></span>

<span data-ttu-id="d1f1c-131">Jeśli otworzysz dowolny z plików w folderze agregacji, można zobaczyć, jak jest oznaczony jako niestandardowej klasy podstawowej lub interfejsu, takich jak jednostki lub obiektu wartości, jak zaimplementowane w folderze [SeedWork.](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork)</span><span class="sxs-lookup"><span data-stu-id="d1f1c-131">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) folder.</span></span>

## <a name="implement-domain-entities-as-poco-classes"></a><span data-ttu-id="d1f1c-132">Implementowanie jednostek domeny jako klas POCO</span><span class="sxs-lookup"><span data-stu-id="d1f1c-132">Implement domain entities as POCO classes</span></span>

<span data-ttu-id="d1f1c-133">Model domeny można zaimplementować w .NET, tworząc klasy POCO, które implementują jednostki domeny.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-133">You implement a domain model in .NET by creating POCO classes that implement your domain entities.</span></span> <span data-ttu-id="d1f1c-134">W poniższym przykładzie Order klasy jest zdefiniowany jako jednostki, a także jako zagregowanego katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-134">In the following example, the Order class is defined as an entity and also as an aggregate root.</span></span> <span data-ttu-id="d1f1c-135">Ponieważ Order Klasa pochodzi od jednostki klasy podstawowej, można ponownie użyć wspólnego kodu związane z jednostek.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-135">Because the Order class derives from the Entity base class, it can reuse common code related to entities.</span></span> <span data-ttu-id="d1f1c-136">Należy pamiętać, że te klasy podstawowe i interfejsy są definiowane przez użytkownika w projekcie modelu domeny, więc jest to kod, a nie kod infrastruktury z ORM jak EF.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-136">Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</span></span>

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 2.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

<span data-ttu-id="d1f1c-137">Należy pamiętać, że jest to jednostka domeny zaimplementowana jako klasa POCO.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-137">It is important to note that this is a domain entity implemented as a POCO class.</span></span> <span data-ttu-id="d1f1c-138">Nie ma żadnej bezpośredniej zależności od core framework jednostki lub innych ramach infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-138">It does not have any direct dependency on Entity Framework Core or any other infrastructure framework.</span></span> <span data-ttu-id="d1f1c-139">Ta implementacja jest tak, jak powinna\# być w DDD, tylko kod C implementacji modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-139">This implementation is as it should be in DDD, just C\# code implementing a domain model.</span></span>

<span data-ttu-id="d1f1c-140">Ponadto klasa jest ozdobiona interfejsem o nazwie IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-140">In addition, the class is decorated with an interface named IAggregateRoot.</span></span> <span data-ttu-id="d1f1c-141">Ten interfejs jest pusty interfejs, czasami nazywany *interfejs znacznika*, który jest używany tylko do wskazania, że ta klasa jednostki jest również zagregowanego katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-141">That interface is an empty interface, sometimes called a *marker interface*, that is used just to indicate that this entity class is also an aggregate root.</span></span>

<span data-ttu-id="d1f1c-142">Interfejs znacznika jest czasami uważany za anty-wzór; jednak jest to również czysty sposób, aby oznaczyć klasę, zwłaszcza gdy ten interfejs może ewoluować.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-142">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving.</span></span> <span data-ttu-id="d1f1c-143">Atrybut może być innym wyborem dla znacznika, ale szybciej jest zobaczyć klasy podstawowej (jednostki) obok interfejsu IAggregate zamiast umieszczania zagregowanego znacznika atrybutu nad klasą.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-143">An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class.</span></span> <span data-ttu-id="d1f1c-144">W każdym razie jest to kwestia preferencji.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-144">It is a matter of preferences, in any case.</span></span>

<span data-ttu-id="d1f1c-145">Posiadanie katalogu głównego agregacji oznacza, że większość kodu związanego z regułami spójności i działalności jednostek agregacji powinna być zaimplementowana jako metody w klasie głównej agregacji zamówienia (na przykład AddOrderItem podczas dodawania OrderItem obiektu do agregacji) .</span><span class="sxs-lookup"><span data-stu-id="d1f1c-145">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate’s entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate).</span></span> <span data-ttu-id="d1f1c-146">Nie należy tworzyć ani aktualizować OrderItems obiektów niezależnie lub bezpośrednio; AggregateRoot klasa musi zachować kontrolę i spójność każdej operacji aktualizacji względem jego jednostek podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-146">You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</span></span>

## <a name="encapsulate-data-in-the-domain-entities"></a><span data-ttu-id="d1f1c-147">Hermetyzować dane w jednostkach domeny</span><span class="sxs-lookup"><span data-stu-id="d1f1c-147">Encapsulate data in the Domain Entities</span></span>

<span data-ttu-id="d1f1c-148">Typowym problemem w modelach jednostek jest, że uwidaczniają właściwości nawigacji kolekcji jako publicznie dostępne typy list.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-148">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types.</span></span> <span data-ttu-id="d1f1c-149">Dzięki temu każdy deweloper współpracownika do manipulowania zawartością tych typów kolekcji, które mogą ominąć ważne reguły biznesowe związane z kolekcji, ewentualnie pozostawiając obiekt w nieprawidłowym stanie.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-149">This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state.</span></span> <span data-ttu-id="d1f1c-150">Rozwiązaniem tego problemu jest udostępnienie dostępu tylko do odczytu do powiązanych kolekcji i jawnie podać metody, które definiują sposoby, w których klienci mogą manipulować nimi.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-150">The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</span></span>

<span data-ttu-id="d1f1c-151">W poprzednim kodzie należy pamiętać, że wiele atrybutów są tylko do odczytu lub prywatnych i są dostępne tylko przez metody klasy, więc każda aktualizacja uważa, że domeny biznesowej invariants i logiki określonych w ramach metod klasy.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-151">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</span></span>

<span data-ttu-id="d1f1c-152">Na przykład po wzorce DDD, \*\* *nie* należy wykonywać następujące z\*\* dowolnej metody obsługi poleceń lub klasy warstwy aplikacji (w rzeczywistości powinno być niemożliwe, aby to zrobić):</span><span class="sxs-lookup"><span data-stu-id="d1f1c-152">For example, following DDD patterns, **you should *not* do the following** from any command handler method or application layer class (actually, it should be impossible for you to do so):</span></span>

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

<span data-ttu-id="d1f1c-153">W takim przypadku Add metoda jest czysto operacji, aby dodać dane, z bezpośrednim dostępem do OrderItems kolekcji.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-153">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection.</span></span> <span data-ttu-id="d1f1c-154">W związku z tym większość logiki domeny, reguł lub weryfikacji związanych z tą operacją z jednostkami podrzędnych będzie rozłożona na warstwę aplikacji (programy obsługi poleceń i kontrolery interfejsu API sieci Web).</span><span class="sxs-lookup"><span data-stu-id="d1f1c-154">Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</span></span>

<span data-ttu-id="d1f1c-155">Jeśli obejść katalogu głównego agregacji, agregacji katalogu głównego nie może zagwarantować jego invariants, jego ważności lub jego spójności.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-155">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency.</span></span> <span data-ttu-id="d1f1c-156">Po pewnym czasie będziesz miał kod spaghetti lub kod skryptu transakcyjnego.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-156">Eventually you will have spaghetti code or transactional script code.</span></span>

<span data-ttu-id="d1f1c-157">Aby wykonać wzorce DDD, jednostki nie mogą mieć ustawiaczy publicznych w żadnej właściwości jednostki.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-157">To follow DDD patterns, entities must not have public setters in any entity property.</span></span> <span data-ttu-id="d1f1c-158">Zmiany w jednostce powinny być napędzane przez jawne metody z jawnym wszechobecnym językiem o zmianie, którą wykonują w jednostce.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-158">Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</span></span>

<span data-ttu-id="d1f1c-159">Ponadto kolekcje w jednostce (jak elementy zamówienia) powinny być właściwościtylko do odczytu (AsReadOnly metoda wyjaśnione później).</span><span class="sxs-lookup"><span data-stu-id="d1f1c-159">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later).</span></span> <span data-ttu-id="d1f1c-160">Powinno być możliwe zaktualizowanie go tylko z poziomu zagregowanych metod klasy głównej lub metod encji podrzędnej.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-160">You should be able to update it only from within the aggregate root class methods or the child entity methods.</span></span>

<span data-ttu-id="d1f1c-161">Jak widać w kodzie zagregowanego katalogu głównego zagregowanego zamówienia, wszystkie metody ustawiania powinny być prywatne lub przynajmniej tylko do odczytu zewnętrznie, tak aby każda operacja względem danych jednostki lub jej jednostek podrzędnych musi być wykonywana za pomocą metod w klasie jednostki.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-161">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity’s data or its child entities has to be performed through methods in the entity class.</span></span> <span data-ttu-id="d1f1c-162">Pozwala to zachować spójność w sposób kontrolowany i obiektowy zamiast implementowania kodu skryptu transakcyjnego.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-162">This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</span></span>

<span data-ttu-id="d1f1c-163">Poniższy fragment kodu pokazuje właściwy sposób kodowania zadania dodawania OrderItem obiektu do Zaagregacji Zamówienia.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-163">The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate.</span></span>

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object’s business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

<span data-ttu-id="d1f1c-164">W tym fragmencie kodu większość sprawdzania poprawności lub logiki związanych z tworzeniem OrderItem obiektu będzie pod kontrolą katalogu głównego agregacji zamówienia — w AddOrderItem metody — szczególnie sprawdzania poprawności i logiki związane z innymi elementami w agregacji.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-164">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate.</span></span> <span data-ttu-id="d1f1c-165">Na przykład może pojawić się ten sam element produktu w wyniku wielu wywołań AddOrderItem.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-165">For instance, you might get the same product item as the result of multiple calls to AddOrderItem.</span></span> <span data-ttu-id="d1f1c-166">W tej metodzie można zbadać towary produktu i skonsolidować te same elementy produktu w jednym OrderItem obiektu z kilku jednostek.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-166">In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units.</span></span> <span data-ttu-id="d1f1c-167">Ponadto, jeśli istnieją różne kwoty rabatu, ale identyfikator produktu jest taki sam, prawdopodobnie zastosujesz wyższy rabat.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-167">Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount.</span></span> <span data-ttu-id="d1f1c-168">Zasada ta ma zastosowanie do każdej innej logiki domeny dla OrderItem obiektu.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-168">This principle applies to any other domain logic for the OrderItem object.</span></span>

<span data-ttu-id="d1f1c-169">Ponadto nowa operacja OrderItem(params) będzie również kontrolowana i wykonywana przez metodę AddOrderItem z katalogu głównego agregacji zamówienia.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-169">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root.</span></span> <span data-ttu-id="d1f1c-170">W związku z tym większość logiki lub sprawdzania poprawności związanych z tą operacją (zwłaszcza wszystko, co wpływa na spójność między innymi jednostkami podrzędnych) będzie w jednym miejscu w katalogu głównym agregacji.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-170">Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root.</span></span> <span data-ttu-id="d1f1c-171">To jest ostateczny cel wzorca głównego agregacji.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-171">That is the ultimate purpose of the aggregate root pattern.</span></span>

<span data-ttu-id="d1f1c-172">Korzystając z jednostki Framework Core 1.1 lub nowsze, jednostka DDD może być lepiej wyrażone, ponieważ umożliwia [mapowanie do pól](https://docs.microsoft.com/ef/core/modeling/backing-field) oprócz właściwości.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-172">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows [mapping to fields](https://docs.microsoft.com/ef/core/modeling/backing-field) in addition to properties.</span></span> <span data-ttu-id="d1f1c-173">Jest to przydatne podczas ochrony kolekcji jednostek podrzędnych lub obiektów wartości.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-173">This is useful when protecting collections of child entities or value objects.</span></span> <span data-ttu-id="d1f1c-174">Za pomocą tego rozszerzenia można użyć prostych pól prywatnych zamiast właściwości i można zaimplementować dowolną aktualizację do kolekcji pól w metodach publicznych i zapewnić dostęp tylko do odczytu za pośrednictwem AsReadOnly metody.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-174">With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></span>

<span data-ttu-id="d1f1c-175">W DDD chcesz zaktualizować jednostkę tylko za pomocą metod w jednostce (lub konstruktora) w celu kontrolowania wszelkich niezmiennych i spójności danych, więc właściwości są definiowane tylko za pomocą get akcesora.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-175">In DDD you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor.</span></span> <span data-ttu-id="d1f1c-176">Właściwości są wspierane przez pola prywatne.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-176">The properties are backed by private fields.</span></span> <span data-ttu-id="d1f1c-177">Członkowie prywatni są dostępowi tylko z poziomu klasy.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-177">Private members can only be accessed from within the class.</span></span> <span data-ttu-id="d1f1c-178">Jednak istnieje jeden wyjątek: EF Core musi ustawić te pola, jak również (dzięki czemu można zwrócić obiekt z odpowiednimi wartościami).</span><span class="sxs-lookup"><span data-stu-id="d1f1c-178">However, there one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</span></span>

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a><span data-ttu-id="d1f1c-179">Właściwości mapy z tylko uzyskać akcesory do pól w tabeli bazy danych</span><span class="sxs-lookup"><span data-stu-id="d1f1c-179">Map properties with only get accessors to the fields in the database table</span></span>

<span data-ttu-id="d1f1c-180">Mapowanie właściwości do kolumn tabeli bazy danych nie jest odpowiedzialnością domeny, ale częścią warstwy infrastruktury i trwałości.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-180">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer.</span></span> <span data-ttu-id="d1f1c-181">Wspominamy o tym tutaj tylko dlatego, że są świadomi nowych możliwości w EF Core 1.1 lub nowszych związane z jak można modelować jednostki.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-181">We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities.</span></span> <span data-ttu-id="d1f1c-182">Dodatkowe szczegóły na ten temat są wyjaśnione w sekcji infrastruktury i trwałości.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-182">Additional details on this topic are explained in the infrastructure and persistence section.</span></span>

<span data-ttu-id="d1f1c-183">Korzystając z EF Core 1.0 lub nowszego, w ramach DbContext należy mapować właściwości, które są zdefiniowane tylko z metodami rozejrzające do rzeczywistych pól w tabeli bazy danych.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-183">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table.</span></span> <span data-ttu-id="d1f1c-184">Odbywa się to za pomocą HasField metody PropertyBuilder klasy.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-184">This is done with the HasField method of the PropertyBuilder class.</span></span>

### <a name="map-fields-without-properties"></a><span data-ttu-id="d1f1c-185">Mapowanie pól bez właściwości</span><span class="sxs-lookup"><span data-stu-id="d1f1c-185">Map fields without properties</span></span>

<span data-ttu-id="d1f1c-186">Dzięki funkcji w EF Core 1.1 lub nowszej do mapowania kolumn do pól, jest również możliwe, aby nie używać właściwości.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-186">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties.</span></span> <span data-ttu-id="d1f1c-187">Zamiast tego możesz po prostu mapować kolumny z tabeli na pola.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-187">Instead, you can just map columns from a table to fields.</span></span> <span data-ttu-id="d1f1c-188">Typowy przypadek użycia dla tego jest pola prywatne dla stanu wewnętrznego, który nie musi być dostępny spoza jednostki.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-188">A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</span></span>

<span data-ttu-id="d1f1c-189">Na przykład w poprzednim przykładzie kodu OrderAggregate istnieje kilka pól `_paymentMethodId` prywatnych, takich jak pole, które nie mają właściwości pokrewnej dla podmiotu ustawiającego lub rozdzielającego.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-189">For example, in the preceding OrderAggregate code example, there are several private fields, like the  `_paymentMethodId` field, that have no related property for either a setter or getter.</span></span> <span data-ttu-id="d1f1c-190">To pole może być również obliczane w ramach logiki biznesowej zamówienia i używane z metod zamówienia, ale musi być również utrwalić w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-190">That field could also be calculated within the order’s business logic and used from the order’s methods, but it needs to be persisted in the database as well.</span></span> <span data-ttu-id="d1f1c-191">Tak więc w EF Core (od 1.1) istnieje sposób mapowania pola bez powiązanej właściwości do kolumny w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-191">So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database.</span></span> <span data-ttu-id="d1f1c-192">Jest to również wyjaśnione w sekcji [Warstwa infrastruktury](ddd-oriented-microservice.md#the-infrastructure-layer) w tym przewodniku.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-192">This is also explained in the [Infrastructure layer](ddd-oriented-microservice.md#the-infrastructure-layer) section of this guide.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="d1f1c-193">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="d1f1c-193">Additional resources</span></span>

- <span data-ttu-id="d1f1c-194">**Vaughn Vernon. Modelowanie agregacji za pomocą DDD i framework jednostek.**</span><span class="sxs-lookup"><span data-stu-id="d1f1c-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.**</span></span> <span data-ttu-id="d1f1c-195">Należy zauważyć, że *nie* jest to rdzeń framework jednostki.</span><span class="sxs-lookup"><span data-stu-id="d1f1c-195">Note that this is *not* Entity Framework Core.</span></span> \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- <span data-ttu-id="d1f1c-196">**Julie Lerman. Punkty danych — kodowanie dla projektowania opartego na domenie: porady dotyczące deweloperów zorientowanych na dane** </span><span class="sxs-lookup"><span data-stu-id="d1f1c-196">**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span></span>\
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- <span data-ttu-id="d1f1c-197">**Udi Dahan. Jak tworzyć w pełni hermetyzowane modele domen** </span><span class="sxs-lookup"><span data-stu-id="d1f1c-197">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> <span data-ttu-id="d1f1c-198">[Poprzedni](microservice-domain-model.md)
> [następny](seedwork-domain-model-base-classes-interfaces.md)</span><span class="sxs-lookup"><span data-stu-id="d1f1c-198">[Previous](microservice-domain-model.md)
[Next](seedwork-domain-model-base-classes-interfaces.md)</span></span>
