---
title: Zdarzenia domeny. Projektowanie i implementacja
description: Architektura mikrousług platformy .NET dla aplikacji platformy .NET w kontenerze | Uzyskaj szczegółowy widok zdarzeń domeny, kluczową koncepcję do ustanowienia komunikacji między agregacjami.
ms.date: 10/08/2018
ms.openlocfilehash: f0dbd6b0e70d825122d319611a327438df065588
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/07/2019
ms.locfileid: "73739888"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="8fa2a-104">Zdarzenia w domenie: projektowanie i implementacja</span><span class="sxs-lookup"><span data-stu-id="8fa2a-104">Domain events: design and implementation</span></span>

<span data-ttu-id="8fa2a-105">Za pomocą zdarzeń domeny można jawnie zaimplementować efekty uboczne zmian w domenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="8fa2a-106">Innymi słowy i przy użyciu terminologii DDD należy używać zdarzeń domeny w celu jawnego implementowania efektów ubocznych w wielu agregacjach.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="8fa2a-107">Opcjonalnie, aby zapewnić lepszą skalowalność i mniej wpływ na blokady baz danych, należy użyć spójności ostatecznej między agregacjami w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="8fa2a-108">Co to jest zdarzenie domeny?</span><span class="sxs-lookup"><span data-stu-id="8fa2a-108">What is a domain event?</span></span>

<span data-ttu-id="8fa2a-109">Zdarzenie to coś, co się stało w przeszłości.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="8fa2a-110">Zdarzenie domeny to, coś, co nastąpiło w domenie, aby inne części tej samej domeny (w procesie) były świadome.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="8fa2a-111">Przekazane części zazwyczaj reagują na zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="8fa2a-112">Ważną zaletą zdarzeń domeny jest to, że efekty uboczne mogą być wyrażone jawnie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="8fa2a-113">Na przykład jeśli korzystasz tylko z Entity Framework, a musisz być odpowiedzią na niektóre zdarzenie, prawdopodobnie kod, którego potrzebujesz blisko, co spowoduje Wyzwalanie zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="8fa2a-114">W związku z tym reguła jest połączona, niejawnie do kodu i trzeba będzie przyjrzeć się do kodu, miejmy nadzieję, aby zrealizować regułę.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="8fa2a-115">Z drugiej strony, korzystanie z zdarzeń domeny czyni koncepcję jawną, ponieważ występuje `DomainEvent` i co najmniej jeden `DomainEventHandler`.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="8fa2a-116">Na przykład w aplikacji eShopOnContainers, gdy zamówienie zostanie utworzone, użytkownik zostaje kupujący, więc `OrderStartedDomainEvent` jest zgłaszane i obsługiwane w `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, więc koncepcja bazowa jest oczywista.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="8fa2a-117">W skrócie zdarzenia domeny pomagają w jawnym wykorzystaniu zasad domeny, w oparciu o język powszechny udostępniony przez ekspertów domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="8fa2a-118">Zdarzenia domeny umożliwiają również lepsze rozdzielenie problemów między klasami w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="8fa2a-119">Ważne jest, aby upewnić się, że podobnie jak transakcja bazy danych, wszystkie operacje związane ze zdarzeniem domeny zakończą się pomyślnie lub żadna z nich nie działa.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="8fa2a-120">Zdarzenia domeny są podobne do zdarzeń w stylu obsługi komunikatów, z jedną istotną różnicą.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="8fa2a-121">W przypadku rzeczywistej obsługi komunikatów, usługi kolejkowania komunikatów, brokerów komunikatów lub usługi Service Bus przy użyciu AMQP komunikat jest zawsze wysyłany asynchronicznie i przekazywany przez procesy i maszyny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-121">With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="8fa2a-122">Jest to przydatne w przypadku integrowania wielu ograniczonych kontekstów, mikrousług lub nawet różnych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="8fa2a-123">Jednak ze zdarzeniami domeny, chcesz zgłosić zdarzenie z aktualnie działającej operacji domeny, ale chcesz, aby wszystkie efekty uboczne miały miejsce w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="8fa2a-124">Zdarzenia domeny i ich skutki uboczne (akcje wyzwalane w późniejszym czasie, które są zarządzane przez programy obsługi zdarzeń) powinny wystąpić niemal natychmiast, zwykle w procesie i w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="8fa2a-125">W rezultacie zdarzenia domeny mogą być synchroniczne lub asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="8fa2a-126">Zdarzenia integracji powinny jednak zawsze być asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="8fa2a-127">Zdarzenia dotyczące domeny a zdarzenia integracji</span><span class="sxs-lookup"><span data-stu-id="8fa2a-127">Domain events versus integration events</span></span>

<span data-ttu-id="8fa2a-128">Semantycznie zdarzenia dotyczące domeny i integracji są takie same: powiadomienia dotyczące coś, co się stało.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="8fa2a-129">Jednak ich implementacja musi się różnić.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-129">However, their implementation must be different.</span></span> <span data-ttu-id="8fa2a-130">Zdarzenia domeny są po prostu przekazywane do dyspozytora zdarzeń domeny, który można zaimplementować jako mediator w pamięci na podstawie kontenera IoC lub innej metody.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="8fa2a-131">Z drugiej strony, celem zdarzeń integracji jest propagowanie zatwierdzonych transakcji i aktualizacji do dodatkowych podsystemów, bez względu na to, czy są to inne mikrousługi, ograniczone konteksty, czy nawet aplikacje zewnętrzne.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="8fa2a-132">W związku z tym powinny wystąpić tylko wtedy, gdy jednostka została pomyślna utrwalana, w przeciwnym razie jest tak, jakby cała operacja nigdy nie zakończyła się.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="8fa2a-133">Jak wspomniano wcześniej, zdarzenia integracji muszą opierać się na asynchronicznej komunikacji między wieloma mikrousługami (innymi kontekstami ograniczonymi) lub nawet z zewnętrznymi systemami/aplikacjami.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="8fa2a-134">Z tego względu Interfejs magistrali zdarzeń musi mieć pewną infrastrukturę, która umożliwia międzyprocesową i rozproszoną komunikację między potencjalnie zdalnymi usługami.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="8fa2a-135">Może ona być oparta na komercyjnej magistrali usług, kolejkach, udostępnionej bazie danych używanej jako Skrzynka pocztowa lub w dowolnym innym rozproszonym i idealnym systemie dostarczania komunikatów opartych na wypychaniu.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="8fa2a-136">Zdarzenia domeny jako preferowany sposób wyzwalania efektów ubocznych przez wiele agregacji w tej samej domenie</span><span class="sxs-lookup"><span data-stu-id="8fa2a-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="8fa2a-137">Jeśli wykonanie polecenia związanego z jednym wystąpieniem zagregowanym wymaga uruchomienia dodatkowych reguł domeny w jednej lub większej liczbie dodatkowych agregacji, należy zaprojektować i zaimplementować te efekty uboczne, aby były wyzwalane przez zdarzenia domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="8fa2a-138">Jak pokazano na rysunku 7-14 i jako jeden z najważniejszych przypadków użycia, zdarzenie domeny powinno być używane do propagowania zmian stanu w wielu agregacjach w ramach tego samego modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![Diagram przedstawiający zdarzenia domeny kontrolujące dane do zagregowanego nabywcy.](./media/domain-events-design-implementation/domain-model-ordering-microservice.png)

<span data-ttu-id="8fa2a-140">**Rysunek 7-14**.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-140">**Figure 7-14**.</span></span> <span data-ttu-id="8fa2a-141">Zdarzenia domeny w celu wymuszenia spójności między wieloma agregacjami w tej samej domenie</span><span class="sxs-lookup"><span data-stu-id="8fa2a-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="8fa2a-142">Rysunek 7-14 pokazuje, jak spójność między agregacjami jest osiągana przez zdarzenia domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-142">Figure 7-14 shows how consistency between aggregates is achieved by domain events.</span></span> <span data-ttu-id="8fa2a-143">Gdy użytkownik inicjuje zamówienie, agregacja zamówienia wysyła zdarzenie `OrderStarted` domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-143">When the user initiates an order, the Order Aggregate sends an `OrderStarted` domain event.</span></span> <span data-ttu-id="8fa2a-144">Zdarzenie domeny OrderStarted jest obsługiwane przez agregację kupującego w celu utworzenia obiektu kupca w mikrousłudze porządkowania na podstawie oryginalnych informacji o użytkowniku z mikrousługi tożsamości (z informacjami podanymi w poleceniu "Utwórz zamówienie").</span><span class="sxs-lookup"><span data-stu-id="8fa2a-144">The OrderStarted domain event is handled by the Buyer Aggregate to create a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span>

<span data-ttu-id="8fa2a-145">Alternatywnie można mieć zagregowany katalog główny subskrybowany dla zdarzeń wywoływanych przez elementy członkowskie jego agregacji (jednostki podrzędne).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-145">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="8fa2a-146">Na przykład każda jednostka podrzędna OrderItem może zgłosić zdarzenie, gdy cena elementu jest wyższa niż określona kwota lub gdy ilość elementu produktu jest zbyt wysoka.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-146">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="8fa2a-147">Zagregowany element główny może następnie odbierać te zdarzenia i wykonywać globalne obliczenia lub agregację.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-147">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="8fa2a-148">Ważne jest, aby zrozumieć, że ta komunikacja oparta na zdarzeniach nie została zaimplementowana bezpośrednio w ramach agregacji; należy zaimplementować obsługę zdarzeń domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-148">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="8fa2a-149">Obsługa zdarzeń domeny jest problemem aplikacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-149">Handling the domain events is an application concern.</span></span> <span data-ttu-id="8fa2a-150">Warstwa modelu domeny powinna skupiać się tylko na logice domeny, co jest zrozumiałe dla eksperta domeny, a nie infrastruktury aplikacji, takiej jak programy obsługi i akcje trwałości ubocznej przy użyciu repozytoriów.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-150">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="8fa2a-151">W związku z tym poziom warstwy aplikacji to miejsce, w którym należy wykonać procedury obsługi zdarzeń domeny wyzwalające akcje po podniesieniu zdarzenia domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-151">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="8fa2a-152">Zdarzenia domeny mogą również służyć do wyzwalania dowolnej liczby akcji aplikacji i co ważniejsze, muszą być otwarte, aby zwiększyć tę liczbę w przyszłości w niezależny sposób.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-152">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="8fa2a-153">Na przykład po rozpoczęciu zamówienia można opublikować zdarzenie domeny, aby propagować te informacje do innych agregacji, a nawet wywołać akcje aplikacji, takie jak powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-153">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="8fa2a-154">Punkt klucza to otwarta liczba akcji do wykonania w przypadku wystąpienia zdarzenia domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-154">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="8fa2a-155">Ostatecznie akcje i reguły w domenie i aplikacji zostaną rozrastane.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-155">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="8fa2a-156">Złożoność lub liczba akcji związanych z efektem ubocznym, gdy wystąpi coś, ale jeśli kod został połączony z "klejem" (czyli tworzeniem określonych obiektów z `new`), a następnie za każdym razem, gdy trzeba dodać nową akcję, należy również zmienić pracę i kod przetestowany.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-156">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="8fa2a-157">Ta zmiana może spowodować nowe błędy, a podejście to również odnosi się do [zasady otwarte/zamknięte](https://en.wikipedia.org/wiki/Open/closed_principle) z [pełnych](https://en.wikipedia.org/wiki/SOLID).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-157">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="8fa2a-158">Nie tylko, Oryginalna klasa, która była w trakcie organizowania operacji, rośnie i rośnie, która jest zgodna z [pojedynczą zasadą odpowiedzialności (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-158">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="8fa2a-159">Z drugiej strony, jeśli używasz zdarzeń domeny, możesz utworzyć szczegółową i rozłączoną implementację, segregowając obowiązki przy użyciu tej metody:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-159">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="8fa2a-160">Wyślij polecenie (na przykład Zamów).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-160">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="8fa2a-161">Odbierz polecenie w programie obsługi poleceń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-161">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="8fa2a-162">Wykonaj pojedynczą transakcję agregacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-162">Execute a single aggregate’s transaction.</span></span>
   - <span data-ttu-id="8fa2a-163">Obowiązkowe Podnieś zdarzenia domeny dla efektów ubocznych (na przykład OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-163">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="8fa2a-164">Obsługa zdarzeń domeny (w ramach bieżącego procesu), które będą wykonywały otwartą liczbę efektów ubocznych w wielu agregacjach lub akcjach aplikacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-164">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="8fa2a-165">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-165">For example:</span></span>
   - <span data-ttu-id="8fa2a-166">Zweryfikuj lub Utwórz kupującego i metodę płatności.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-166">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="8fa2a-167">Tworzenie i wysyłanie powiązanego zdarzenia integracji do usługi Event Bus w celu propagowania Stanów dla mikrousług lub wyzwalania akcji zewnętrznych, takich jak wysyłanie wiadomości e-mail do kupującego.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-167">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="8fa2a-168">Obsługuj inne efekty uboczne.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-168">Handle other side effects.</span></span>

<span data-ttu-id="8fa2a-169">Jak pokazano na rysunku 7-15, rozpoczynając od tego samego zdarzenia domeny, można obsługiwać wiele akcji związanych z innymi agregacjami w domenie lub dodatkowych akcjach aplikacji, które należy wykonać na mikrousługach łączących się ze zdarzeniami integracji i magistralą zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-169">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Diagram przedstawiający zdarzenie domeny przekazujące dane do kilku programów obsługi zdarzeń.](./media/domain-events-design-implementation/aggregate-domain-event-handlers.png)

<span data-ttu-id="8fa2a-171">**Rysunek 7-15**.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-171">**Figure 7-15**.</span></span> <span data-ttu-id="8fa2a-172">Obsługa wielu akcji na domenę</span><span class="sxs-lookup"><span data-stu-id="8fa2a-172">Handling multiple actions per domain</span></span>

<span data-ttu-id="8fa2a-173">Może istnieć kilka programów obsługi dla tego samego zdarzenia domeny w warstwie aplikacji, jednak jedna procedura obsługi może rozwiązać spójność między agregacjami, a inna procedura obsługi może opublikować wydarzenie integracji, dzięki czemu inne mikrousługi mogą wykonać coś z nim.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-173">There can be several handlers for the same domain event in the Application Layer, one handler can solve consistency between aggregates and another handler can publish an integration event, so other microservices can do something with it.</span></span> <span data-ttu-id="8fa2a-174">Programy obsługi zdarzeń zwykle znajdują się w warstwie aplikacji, ponieważ będziesz używać obiektów infrastruktury, takich jak repozytoria lub interfejs API aplikacji dla zachowania mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-174">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="8fa2a-175">W tym sensie programy obsługi zdarzeń są podobne do programów obsługi poleceń, więc obie są częścią warstwy aplikacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-175">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="8fa2a-176">Istotną różnicą jest to, że polecenie powinno być przetwarzane tylko raz.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-176">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="8fa2a-177">Zdarzenie domeny może być przetwarzane zero lub *n* razy, ponieważ może zostać odebrane przez wielu odbiorników lub obsługę zdarzeń z innym przeznaczeniem dla każdej procedury obsługi.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-177">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="8fa2a-178">Posiadanie otwartej liczby programów obsługi na domenę umożliwia dodanie możliwie największej liczby reguł domeny bez wpływu na bieżący kod.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-178">Having an open number of handlers per domain event allows you to add as many domain rules as needed, without affecting  current code.</span></span> <span data-ttu-id="8fa2a-179">Na przykład wdrożenie następującej reguły biznesowej może być równie proste, jak dodanie kilku programów obsługi zdarzeń (lub nawet jednego z nich):</span><span class="sxs-lookup"><span data-stu-id="8fa2a-179">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="8fa2a-180">Gdy łączna kwota zakupiona przez klienta w sklepie w ramach dowolnej liczby zamówień przekracza $6 000, należy zastosować 10% rabatu na każde nowe zamówienie i powiadomić klienta za pośrednictwem wiadomości e-mail o tym rabatie dla przyszłych zamówień.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-180">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="8fa2a-181">Implementowanie zdarzeń domeny</span><span class="sxs-lookup"><span data-stu-id="8fa2a-181">Implement domain events</span></span>

<span data-ttu-id="8fa2a-182">W C#programie zdarzenie domeny jest po prostu strukturą lub klasą przechowywania danych, taką jak DTO, ze wszystkimi informacjami związanymi z tym, co się stało w domenie, jak pokazano w następującym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-182">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="8fa2a-183">Jest to zasadniczo Klasa, która zawiera wszystkie dane związane ze zdarzeniem OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-183">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="8fa2a-184">W odniesieniu do powszechnie używanego języka domeny, ponieważ zdarzenie to coś, co miało miejsce w przeszłości, nazwa klasy zdarzenia powinna być reprezentowana jako czasownik przeszły, taki jak OrderStartedDomainEvent lub OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-184">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="8fa2a-185">Jest to sposób implementacji zdarzenia domeny w mikrousłudze porządkowania w eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-185">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="8fa2a-186">Jak wspomniano wcześniej, ważną cechą zdarzeń jest fakt, że zdarzenie to coś, co miało miejsce w przeszłości, nie powinno się zmieniać.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-186">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="8fa2a-187">W związku z tym musi być klasą niemodyfikowalną.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-187">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="8fa2a-188">W poprzednim kodzie można zobaczyć, że właściwości są tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-188">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="8fa2a-189">Nie ma sposobu na zaktualizowanie obiektu, można ustawić tylko wartości podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-189">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="8fa2a-190">Należy tu zaznaczyć, że jeśli zdarzenia domeny mają być obsługiwane asynchronicznie, przy użyciu kolejki, która wymaga serializacji i deserializacji obiektów zdarzeń, właściwości muszą mieć wartość "Prywatny zestaw" zamiast tylko do odczytu, więc Deserializator będzie Możliwość przypisywania wartości podczas usuwania z kolejki.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-190">It’s important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be “private set” instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="8fa2a-191">Nie jest to problem występujący w mikrousłudze porządkowania, ponieważ zdarzenie w domenie pub/sub jest zaimplementowane synchronicznie za pomocą MediatR.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-191">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="8fa2a-192">Zgłoś zdarzenia domeny</span><span class="sxs-lookup"><span data-stu-id="8fa2a-192">Raise domain events</span></span>

<span data-ttu-id="8fa2a-193">Następnym pytaniem jest to, jak podnieść zdarzenie domeny, aby docierał do jego powiązanych programów obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-193">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="8fa2a-194">Można użyć wielu metod.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-194">You can use multiple approaches.</span></span>

<span data-ttu-id="8fa2a-195">UDI Dahan pierwotnie proponowane (na przykład w kilku powiązanych wpisach, takich jak [zdarzenia domeny — Zrób 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) przy użyciu klasy statycznej do zarządzania i wywoływania zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-195">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="8fa2a-196">Może to obejmować klasę statyczną o nazwie DomainEvents, która mogłaby podnieść zdarzenia domeny natychmiast po wywołaniu, używając składni takiej jak `DomainEvents.Raise(Event myEvent)`.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-196">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="8fa2a-197">Jimmy Bogard zapisał wpis w blogu ([wzmacnianie domeny: zdarzenia domeny](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)), która zaleca podobne podejście.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-197">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="8fa2a-198">Jednak gdy klasa zdarzenia domeny jest statyczna, to również natychmiast wysyła do programów obsługi.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-198">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="8fa2a-199">Dzięki temu testy i debugowanie są trudniejsze, ponieważ programy obsługi zdarzeń z logiką efektów ubocznych są wykonywane natychmiast po wywołaniu zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-199">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="8fa2a-200">Podczas testowania i debugowania należy skoncentrować się na tym, co dzieje się w przypadku bieżących klas agregujących; nie chcesz nagle przekierowywać do innych programów obsługi zdarzeń w przypadku efektów ubocznych związanych z innymi agregacjami lub logiką aplikacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-200">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="8fa2a-201">Jest to dlatego, że inne podejścia zostały rozwinięte, jak wyjaśniono w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-201">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="8fa2a-202">Odroczone podejście do wywoływania i wysyłania zdarzeń</span><span class="sxs-lookup"><span data-stu-id="8fa2a-202">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="8fa2a-203">Zamiast wysyłać do programu obsługi zdarzeń domeny natychmiast, lepszym rozwiązaniem jest dodanie zdarzeń domeny do kolekcji, a następnie wysłanie tych zdarzeń domeny *bezpośrednio przed* *lub po* *zatwierdzeniu* transakcji (jak w przypadku Metody SaveChanges w EF).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-203">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="8fa2a-204">(Takie podejście zostało opisane przez Jimmy Bogard w tym wpisie [lepszego wzorca zdarzeń domeny](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-204">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="8fa2a-205">Wybór w przypadku wysyłania zdarzeń domeny bezpośrednio przed lub po zatwierdzeniu transakcji jest istotny, ponieważ określa, czy będzie uwzględniać efekty uboczne w ramach tej samej transakcji lub w różnych transakcjach.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-205">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="8fa2a-206">W tym drugim przypadku należy zaradzić sobie ze spójnością ostateczną w wielu agregacjach.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-206">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="8fa2a-207">Ten temat został omówiony w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-207">This topic is discussed in the next section.</span></span>

<span data-ttu-id="8fa2a-208">Podejście odroczone to eShopOnContainers, z których korzystają.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-208">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="8fa2a-209">Najpierw Dodaj zdarzenia wykonywane w jednostkach do kolekcji lub listy zdarzeń na jednostkę.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-209">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="8fa2a-210">Ta lista powinna być częścią obiektu jednostki, a nawet lepiej, częścią klasy jednostki podstawowej, jak pokazano w poniższym przykładzie klasy podstawowej jednostki:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-210">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //...
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents;

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="8fa2a-211">Gdy chcesz zgłosić zdarzenie, wystarczy dodać je do kolekcji zdarzeń z kodu w dowolnej metodzie agregacji jednostki głównej.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-211">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="8fa2a-212">Poniższy kod, część [agregacji Order-root w eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), zawiera przykład:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-212">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="8fa2a-213">Należy zauważyć, że jedyną kwestią, że metoda AddDomainEvent jest dodawana do listy zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-213">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="8fa2a-214">Żadne zdarzenie nie jest jeszcze wysyłane i nie wywołano jeszcze obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-214">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="8fa2a-215">Na pewno chcesz wysłać zdarzenia później, po zatwierdzeniu transakcji do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-215">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="8fa2a-216">Jeśli używasz Entity Framework Core, oznacza to w metodzie metody SaveChanges w kontekście EF DB, jak w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-216">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="8fa2a-217">Za pomocą tego kodu wysyłasz zdarzenia jednostki do odpowiednich programów obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-217">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="8fa2a-218">Ogólny wynik polega na tym, że zostało oddzielone podnoszenie poziomu zdarzenia domeny (proste dodanie do listy w pamięci) od wysłania go do programu obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-218">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="8fa2a-219">Ponadto, w zależności od używanego rodzaju dyspozytora, można wysyłać zdarzenia synchronicznie lub asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-219">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="8fa2a-220">Należy pamiętać, że granice transakcyjne są znacznie dostępne w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-220">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="8fa2a-221">Jeśli jednostka pracy i transakcji może obejmować więcej niż jedną wartość zagregowaną (jak w przypadku używania EF Core i relacyjnej bazy danych), może to być dobre.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-221">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="8fa2a-222">Ale jeśli transakcja nie może obejmować agregacji, na przykład gdy korzystasz z bazy danych NoSQL, takiej jak Azure CosmosDB, musisz zaimplementować dodatkowe kroki, aby osiągnąć spójność.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-222">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="8fa2a-223">Jest to kolejny powód, dla którego trwałość ignorujących nie jest uniwersalna; jest to zależne od używanego systemu magazynu.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-223">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="8fa2a-224">Pojedyncza transakcja w agregacjach i ostateczna spójność w agregacjach</span><span class="sxs-lookup"><span data-stu-id="8fa2a-224">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="8fa2a-225">Pytanie, czy wykonać pojedynczą transakcję w ramach agregacji, w przeciwieństwie do spójności ostatecznej dla tych agregacji jest kontrowersyjny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-225">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="8fa2a-226">Wiele autorów, takich jak Eric Evans i Vaughn Vernon, ambasadoruje zasadę, że jedna transakcja = jedna wartość zagregowana i w związku z tym podnieśy się do ostatecznej spójności w agregacjach.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-226">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="8fa2a-227">Na przykład w swoim *projekcie opartym na domenie*, Eric Evans to:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-227">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="8fa2a-228">Wszystkie reguły, które rozciągają się na agregacje, nie będą zawsze aktualne.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-228">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="8fa2a-229">W przypadku przetwarzania zdarzeń, przetwarzania wsadowego lub innych mechanizmów aktualizacji inne zależności można rozpoznać w określonym czasie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-229">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="8fa2a-230">(strona 128)</span><span class="sxs-lookup"><span data-stu-id="8fa2a-230">(page 128)</span></span>

<span data-ttu-id="8fa2a-231">Vaughn Vernon jest następująca w [skutecznym, zagregowanym projekcie. Część II: wykonywanie zagregowanych zadań jednocześnie](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="8fa2a-231">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="8fa2a-232">W takim przypadku, jeśli wykonywanie polecenia w jednym wystąpieniu agregującym wymaga, aby dodatkowe reguły biznesowe były wykonywane na co najmniej jednej wartości zagregowanej, korzystać z \[spójności ostatecznej...\] istnieje praktyczny sposób zapewnienia spójności ostatecznej w modelu DDD.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-232">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="8fa2a-233">Metoda agregująca publikuje zdarzenie domeny, które jest w czasie dostarczane do co najmniej jednego subskrybenta asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-233">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="8fa2a-234">To uzasadnienie opiera się na uwzględnieniu szczegółowych transakcji zamiast transakcji obejmujących wiele zagregowanych lub jednostek.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-234">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="8fa2a-235">Dobrym pomysłem jest to, że w drugim przypadku liczba blokad baz danych będzie znacząca w aplikacjach o dużej skali o wysokiej skalowalności.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-235">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="8fa2a-236">W przypadku, gdy wysoce skalowalne aplikacje nie muszą mieć natychmiastowej spójności transakcyjnej między wieloma agregacjami, pomaga zaakceptować koncepcję spójności ostatecznej.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-236">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="8fa2a-237">Zmiany niepodzielne często nie są wymagane przez firmę, a w każdym przypadku odpowiedzialność ekspertów domeny może powiedzieć, czy określone operacje wymagają niepodzielnych transakcji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-237">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="8fa2a-238">Jeśli operacja zawsze wymaga niepodzielnej transakcji między wieloma agregacjami, może wystąpić pytanie, czy wartość zagregowana powinna być większa czy nie została prawidłowo zaprojektowana.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-238">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="8fa2a-239">Jednak inni deweloperzy i architekty, takie jak Jimmy Bogard, są w trakcie łączenia jednej transakcji z wieloma agregacjami, ale tylko wtedy, gdy te dodatkowe agregaty są powiązane z efektami ubocznymi tego samego oryginalnego polecenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-239">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="8fa2a-240">Przykładowo w przypadku [lepszego wzorca zdarzeń domeny](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)Bogard brzmi:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-240">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="8fa2a-241">Zazwyczaj chcę, aby skutki uboczne zdarzenia domeny miały miejsce w ramach tej samej transakcji logicznej, ale niekoniecznie w tym samym zakresie podnoszenie poziomu zdarzenia domeny \[...\] tuż przed zatwierdzeniem naszej transakcji, wyślemy nasze zdarzenia do swoich odpowiednie programy obsługi.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-241">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="8fa2a-242">Jeśli wysyłasz zdarzenia domeny bezpośrednio *przed* zatwierdzeniem oryginalnej transakcji, jest to spowodowane tym, że efekty uboczne tych zdarzeń mają być uwzględnione w tej samej transakcji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-242">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="8fa2a-243">Na przykład jeśli metoda EF DbContext metody SaveChanges nie powiedzie się, transakcja wycofa wszystkie zmiany, w tym wynik wszelkich operacji ubocznych wdrożonych przez powiązane procedury obsługi zdarzeń domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-243">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="8fa2a-244">Wynika to z faktu, że zakres istnienia kontekstu DbContext jest domyślnie zdefiniowany jako "objęty zakresem".</span><span class="sxs-lookup"><span data-stu-id="8fa2a-244">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="8fa2a-245">W związku z tym obiekt DbContext jest współużytkowany przez wiele obiektów repozytorium, które są tworzone w ramach tego samego zakresu lub grafu obiektów.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-245">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="8fa2a-246">Ta sama zbieżność z zakresem HttpRequest podczas opracowywania aplikacji sieci Web API lub MVC.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-246">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="8fa2a-247">W rzeczywistości obie metody (jedna niepodzielna transakcja i spójność ostateczna) mogą być odpowiednie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-247">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="8fa2a-248">Jest to naprawdę zależne od wymagań Twojej domeny lub firmy oraz informacji o tym, co informują eksperci z domeną.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-248">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="8fa2a-249">Zależy to również od tego, jak skalowalność potrzebuje usługi (bardziej szczegółowe transakcje mają mniejszy wpływ na blokady bazy danych).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-249">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="8fa2a-250">Jest to zależne od tego, jak dużo inwestycji leży w kodzie, ponieważ w celu wykrywania możliwych niespójności w ramach zagregowanych danych wymagana jest bardziej skomplikowana spójność i konieczna jest implementacja działań wyrównawczych.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-250">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="8fa2a-251">Należy wziąć pod uwagę, że jeśli zatwierdzisz zmiany w pierwotnej wartości zagregowanej, a następnie, gdy zdarzenia są wysyłane, jeśli wystąpi problem, a programy obsługi zdarzeń nie mogą zatwierdzić ich efektów ubocznych, będziesz mieć niespójności między agregacjami.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-251">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="8fa2a-252">Sposobem zezwalania na akcje kompensacyjne będzie przechowywanie zdarzeń domeny w dodatkowych tabelach bazy danych, dzięki czemu mogą one być częścią oryginalnej transakcji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-252">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="8fa2a-253">Później może istnieć proces wsadowy, który wykrywa niespójności i uruchamia akcje kompensacyjne, porównując listę zdarzeń z bieżącym stanem agregacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-253">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="8fa2a-254">Działania kompensacyjne są częścią złożonego tematu, który będzie wymagał głębokiej analizy ze strony użytkownika, która obejmuje omawianie jej z ekspertami użytkowników i domen dla firm.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-254">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="8fa2a-255">W każdym przypadku można wybrać potrzebną metodę.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-255">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="8fa2a-256">Ale początkowe podejście odroczone — podnoszenie zdarzeń przed zatwierdzeniem, dlatego należy użyć jednej transakcji — najprostszym podejściem jest użycie EF Core i relacyjnej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-256">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="8fa2a-257">Jest to łatwiejsze do zaimplementowania i prawidłowego w wielu przypadkach firmy.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-257">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="8fa2a-258">Jest to również podejście używane w mikrousłudze porządkowania w eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-258">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="8fa2a-259">Ale jak faktycznie wysyłać te zdarzenia do odpowiednich programów obsługi zdarzeń?</span><span class="sxs-lookup"><span data-stu-id="8fa2a-259">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="8fa2a-260">Co to jest obiekt `_mediator` widoczny w poprzednim przykładzie?</span><span class="sxs-lookup"><span data-stu-id="8fa2a-260">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="8fa2a-261">Należy to zrobić przy użyciu technik i artefaktów używanych do mapowania między zdarzeniami a ich programami obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-261">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="8fa2a-262">Dyspozytor zdarzeń domeny: mapowanie ze zdarzeń do programów obsługi zdarzeń</span><span class="sxs-lookup"><span data-stu-id="8fa2a-262">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="8fa2a-263">Gdy będzie możliwe wysłanie lub opublikowanie zdarzeń, potrzebujesz pewnego rodzaju artefaktu, który będzie publikować zdarzenie, dzięki czemu każda powiązana procedura obsługi może go uzyskać i przetwarzać efekty uboczne na podstawie tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-263">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="8fa2a-264">Jednym z rozwiązań jest rzeczywisty system obsługi komunikatów, a nawet magistrala zdarzeń, prawdopodobnie oparta na magistrali usług, w przeciwieństwie do zdarzeń w pamięci.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-264">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="8fa2a-265">Jednak w przypadku pierwszego przypadku prawdziwe wiadomości zbyt obszerne do przetwarzania zdarzeń domeny, ponieważ wystarczy przetwarzać te zdarzenia w ramach tego samego procesu (czyli w obrębie tej samej domeny i warstwy aplikacji).</span><span class="sxs-lookup"><span data-stu-id="8fa2a-265">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="8fa2a-266">Innym sposobem mapowania zdarzeń do obsługi wielu zdarzeń jest użycie rejestracji typów w kontenerze IoC, dzięki czemu można dynamicznie wywnioskować, gdzie mają zostać wysłane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-266">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="8fa2a-267">Innymi słowy, należy wiedzieć, jakie programy obsługi zdarzeń muszą uzyskać konkretne zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-267">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="8fa2a-268">Rysunek 7-16 pokazuje uproszczone podejście do tego podejścia.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-268">Figure 7-16 shows a simplified approach for this approach.</span></span>

![Diagram przedstawiający wysyłanie zdarzeń przez dyspozytora zdarzeń domeny do odpowiednich programów obsługi.](./media/domain-events-design-implementation/domain-event-dispatcher.png)

<span data-ttu-id="8fa2a-270">**Rysunek 7-16**.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-270">**Figure 7-16**.</span></span> <span data-ttu-id="8fa2a-271">Dyspozytor zdarzeń domeny przy użyciu IoC</span><span class="sxs-lookup"><span data-stu-id="8fa2a-271">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="8fa2a-272">Możesz skompilować wszystkie instalacje i artefakty, aby zaimplementować to rozwiązanie samodzielnie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-272">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="8fa2a-273">Można jednak również użyć dostępnych bibliotek, takich jak [MediatR](https://github.com/jbogard/MediatR) , które używają kontenera IOC w obszarze okładek.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-273">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="8fa2a-274">W związku z tym można bezpośrednio używać wstępnie zdefiniowanych interfejsów i metod publikowania/wysyłania obiektów mediator.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-274">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="8fa2a-275">W kodzie należy najpierw zarejestrować typy obsługi zdarzeń w kontenerze IoC, jak pokazano w poniższym przykładzie w [EShopOnContainers porządkowanie mikrousługi](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="8fa2a-275">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="8fa2a-276">Kod najpierw identyfikuje zestaw, który zawiera procedury obsługi zdarzeń domeny przez lokalizowanie zestawu, który zawiera dowolne procedury obsługi (przy użyciu elementu typeof (ValidateOrAddBuyerAggregateWhenXxxx), ale można wybrać dowolną inną procedurę obsługi zdarzeń w celu zlokalizowania zestawu.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-276">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="8fa2a-277">Ponieważ wszystkie programy obsługi zdarzeń implementują interfejs IAsyncNotificationHandler, kod następnie wyszukuje te typy i rejestruje wszystkie programy obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-277">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="8fa2a-278">Jak subskrybować zdarzenia domeny</span><span class="sxs-lookup"><span data-stu-id="8fa2a-278">How to subscribe to domain events</span></span>

<span data-ttu-id="8fa2a-279">W przypadku korzystania z MediatR, każdy program obsługi zdarzeń musi używać typu zdarzenia dostarczonego w parametrze ogólnym interfejsu INotificationHandler, jak widać w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="8fa2a-279">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="8fa2a-280">Na podstawie relacji między zdarzeniem i obsługą zdarzeń, które mogą być uważane za subskrypcję, artefakt MediatR może odnaleźć wszystkie procedury obsługi zdarzeń dla każdego zdarzenia i wyzwolić każdy z tych programów obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-280">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="8fa2a-281">Jak obsługiwać zdarzenia domeny</span><span class="sxs-lookup"><span data-stu-id="8fa2a-281">How to handle domain events</span></span>

<span data-ttu-id="8fa2a-282">Na koniec program obsługi zdarzeń zazwyczaj implementuje kod warstwy aplikacji, który korzysta z repozytoriów infrastruktury w celu uzyskania wymaganych dodatkowych agregacji i wykonywania logiki domeny z efektem ubocznym.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-282">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="8fa2a-283">Następujący [kod procedury obsługi zdarzeń domeny w eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs)zawiera przykład implementacji.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-283">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer)
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="8fa2a-284">Poprzedni kod procedury obsługi zdarzeń domeny jest uznawany za kod warstwy aplikacji, ponieważ używa repozytoriów infrastruktury, jak wyjaśniono w następnej sekcji warstwy trwałości infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-284">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="8fa2a-285">Procedury obsługi zdarzeń mogą również używać innych składników infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-285">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="8fa2a-286">Zdarzenia domeny mogą generować zdarzenia integracji do opublikowania poza granicami mikrousług</span><span class="sxs-lookup"><span data-stu-id="8fa2a-286">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="8fa2a-287">Na koniec należy zauważyć, że czasami chcesz propagować zdarzenia w wielu mikrousługach.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-287">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="8fa2a-288">Propagacja jest zdarzeniem integracji i może zostać opublikowana za pośrednictwem magistrali zdarzeń z dowolnego programu obsługi zdarzeń domeny.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-288">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="8fa2a-289">Wnioski dotyczące zdarzeń domeny</span><span class="sxs-lookup"><span data-stu-id="8fa2a-289">Conclusions on domain events</span></span>

<span data-ttu-id="8fa2a-290">Jak wspomniano, użyj zdarzeń domeny w celu jawnego implementowania efektów ubocznych zmian w domenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-290">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="8fa2a-291">Aby użyć terminologii, użyj zdarzeń domeny w celu jawnego implementowania efektów ubocznych w jednej lub wielu agregacjach.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-291">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="8fa2a-292">Ponadto, aby zapewnić lepszą skalowalność i mniej wpływ na blokady bazy danych, należy użyć spójności ostatecznej między agregacjami w tej samej domenie.</span><span class="sxs-lookup"><span data-stu-id="8fa2a-292">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="8fa2a-293">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="8fa2a-293">Additional resources</span></span>

- <span data-ttu-id="8fa2a-294">**Greg Young. Co to jest zdarzenie domeny?**</span><span class="sxs-lookup"><span data-stu-id="8fa2a-294">**Greg Young. What is a Domain Event?**</span></span> \
  <https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25>

- <span data-ttu-id="8fa2a-295">**Jan Stenberg. Zdarzenia domeny i spójność ostateczna** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-295">**Jan Stenberg. Domain Events and Eventual Consistency** </span></span>\
  <https://www.infoq.com/news/2015/09/domain-events-consistency>

- <span data-ttu-id="8fa2a-296">**Jimmy Bogard. Lepszy wzorzec zdarzeń domeny** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-296">**Jimmy Bogard. A better domain events pattern** </span></span>\
  <https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/>

- <span data-ttu-id="8fa2a-297">**Vaughn Vernon. Efektywna agregowana część II: wykonywanie zagregowanych współdziałania** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-297">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** </span></span>\
  [https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="8fa2a-298">**Jimmy Bogard. Wzmacnianie domeny: zdarzenia domeny** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-298">**Jimmy Bogard. Strengthening your domain: Domain Events** </span></span>\
  <https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>

- <span data-ttu-id="8fa2a-299">**Której należy Tony Truong. Przykład wzorca zdarzeń domeny** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-299">**Tony Truong. Domain Events Pattern Example** </span></span>\
  <https://www.tonytruong.net/domain-events-pattern-example/>

- <span data-ttu-id="8fa2a-300">**UDI Dahan. Jak utworzyć w pełni hermetyzowane modele domen** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-300">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

- <span data-ttu-id="8fa2a-301">**UDI Dahan. Zdarzenia domeny — zajmiemy 2** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-301">**Udi Dahan. Domain Events – Take 2** </span></span>\
  <http://udidahan.com/2008/08/25/domain-events-take-2/>

- <span data-ttu-id="8fa2a-302">**UDI Dahan. Zdarzenia domeny — Salvation** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-302">**Udi Dahan. Domain Events – Salvation** </span></span>\
  <http://udidahan.com/2009/06/14/domain-events-salvation/>

- <span data-ttu-id="8fa2a-303">**Jan Kronquist. Nie Publikuj zdarzeń domeny, zwróć je!**</span><span class="sxs-lookup"><span data-stu-id="8fa2a-303">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  <https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/>

- <span data-ttu-id="8fa2a-304">**Cesar de La Torre. Zdarzenia domeny a zdarzenia integracji w architekturze DDD i mikrousług** </span><span class="sxs-lookup"><span data-stu-id="8fa2a-304">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** </span></span>\
  <https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/>

>[!div class="step-by-step"]
><span data-ttu-id="8fa2a-305">[Poprzedni](client-side-validation.md)
>[dalej](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="8fa2a-305">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>
