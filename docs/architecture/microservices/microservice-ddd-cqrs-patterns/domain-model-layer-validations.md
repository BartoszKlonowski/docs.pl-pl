---
title: Projektowanie reguł weryfikacji w warstwie modelu domeny
description: Architektura mikrousług .NET dla konteneryzowanych aplikacji .NET | Zapoznaj się z kluczowymi pojęciami sprawdzania poprawności modelu domeny.
ms.date: 10/08/2018
ms.openlocfilehash: 98ccc5df84c9f6f402ecbee83b077c806d6a76fc
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "75899666"
---
# <a name="design-validations-in-the-domain-model-layer"></a><span data-ttu-id="7396f-103">Sprawdzanie poprawności projektu w warstwie modelu domeny</span><span class="sxs-lookup"><span data-stu-id="7396f-103">Design validations in the domain model layer</span></span>

<span data-ttu-id="7396f-104">W DDD reguły sprawdzania poprawności można traktować jako niezmienne.</span><span class="sxs-lookup"><span data-stu-id="7396f-104">In DDD, validation rules can be thought as invariants.</span></span> <span data-ttu-id="7396f-105">Główną odpowiedzialnością za agregat jest wymuszanie niezmiennych zmian stanu dla wszystkich jednostek w ramach tego agregatu.</span><span class="sxs-lookup"><span data-stu-id="7396f-105">The main responsibility of an aggregate is to enforce invariants across state changes for all the entities within that aggregate.</span></span>

<span data-ttu-id="7396f-106">Jednostki domeny powinny być zawsze prawidłowe jednostki.</span><span class="sxs-lookup"><span data-stu-id="7396f-106">Domain entities should always be valid entities.</span></span> <span data-ttu-id="7396f-107">Istnieje pewna liczba invariants dla obiektu, który zawsze powinien być true.</span><span class="sxs-lookup"><span data-stu-id="7396f-107">There are a certain number of invariants for an object that should always be true.</span></span> <span data-ttu-id="7396f-108">Na przykład obiekt zapasu zamówienia zawsze musi mieć ilość, która musi być dodatnią liczbą całkowitą, plus nazwa artykułu i cena.</span><span class="sxs-lookup"><span data-stu-id="7396f-108">For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price.</span></span> <span data-ttu-id="7396f-109">W związku z tym wymuszanie invariants jest obowiązkiem jednostek domeny (zwłaszcza zagregowanego katalogu głównego) i obiekt jednostki nie powinien istnieć bez ważności.</span><span class="sxs-lookup"><span data-stu-id="7396f-109">Therefore, invariants enforcement is the responsibility of the domain entities (especially of the aggregate root) and an entity object should not be able to exist without being valid.</span></span> <span data-ttu-id="7396f-110">Niezmienne reguły są po prostu wyrażone jako kontrakty, a wyjątki lub powiadomienia są wywoływane, gdy są naruszane.</span><span class="sxs-lookup"><span data-stu-id="7396f-110">Invariant rules are simply expressed as contracts, and exceptions or notifications are raised when they are violated.</span></span>

<span data-ttu-id="7396f-111">Rozumowanie za to jest, że wiele błędów występują, ponieważ obiekty są w stanie, w jaki nigdy nie powinny być w.</span><span class="sxs-lookup"><span data-stu-id="7396f-111">The reasoning behind this is that many bugs occur because objects are in a state they should never have been in.</span></span> <span data-ttu-id="7396f-112">Oto dobre wyjaśnienie greg young w [dyskusji online:](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/)</span><span class="sxs-lookup"><span data-stu-id="7396f-112">The following is a good explanation from Greg Young in an [online discussion](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/):</span></span>

<span data-ttu-id="7396f-113">Zaproponujmy teraz sendusercreationemailservice, który ma UserProfile ... jak możemy zracjonalizować w tej usłudze, że nazwa nie jest null?</span><span class="sxs-lookup"><span data-stu-id="7396f-113">Let's propose we now have a SendUserCreationEmailService that takes a UserProfile ... how can we rationalize in that service that Name is not null?</span></span> <span data-ttu-id="7396f-114">Czy sprawdzamy to jeszcze raz?</span><span class="sxs-lookup"><span data-stu-id="7396f-114">Do we check it again?</span></span> <span data-ttu-id="7396f-115">Lub bardziej prawdopodobne ... po prostu nie zawracaj sobie głowy, aby sprawdzić i "nadzieję na najlepsze" - masz nadzieję, że ktoś zadał sobie trud, aby potwierdzić go przed wysłaniem go do Ciebie.</span><span class="sxs-lookup"><span data-stu-id="7396f-115">Or more likely ... you just don't bother to check and "hope for the best"—you hope that someone bothered to validate it before sending it to you.</span></span> <span data-ttu-id="7396f-116">Oczywiście, za pomocą TDD jednym z pierwszych testów powinniśmy pisać jest to, że jeśli wysłać klienta o nazwie null, że powinien zgłosić błąd.</span><span class="sxs-lookup"><span data-stu-id="7396f-116">Of course, using TDD one of the first tests we should be writing is that if I send a customer with a null name that it should raise an error.</span></span> <span data-ttu-id="7396f-117">Ale kiedy zaczniemy pisać tego rodzaju testy w kółko, zdajemy sobie sprawę ... "poczekaj, jeśli nigdy nie pozwoliliśmy nazwę stać się null nie mielibyśmy wszystkie te testy"</span><span class="sxs-lookup"><span data-stu-id="7396f-117">But once we start writing these kinds of tests over and over again we realize ... "wait if we never allowed name to become null we wouldn't have all of these tests"</span></span>

## <a name="implement-validations-in-the-domain-model-layer"></a><span data-ttu-id="7396f-118">Implementowanie sprawdzania poprawności w warstwie modelu domeny</span><span class="sxs-lookup"><span data-stu-id="7396f-118">Implement validations in the domain model layer</span></span>

<span data-ttu-id="7396f-119">Sprawdzanie poprawności są zwykle implementowane w konstruktorów jednostek domeny lub w metodach, które można zaktualizować jednostki.</span><span class="sxs-lookup"><span data-stu-id="7396f-119">Validations are usually implemented in domain entity constructors or in methods that can update the entity.</span></span> <span data-ttu-id="7396f-120">Istnieje wiele sposobów implementowania sprawdzania poprawności, takich jak weryfikowanie danych i zgłaszanie wyjątków w przypadku niepowodzenia sprawdzania poprawności.</span><span class="sxs-lookup"><span data-stu-id="7396f-120">There are multiple ways to implement validations, such as verifying data and raising exceptions if the validation fails.</span></span> <span data-ttu-id="7396f-121">Istnieją również bardziej zaawansowane wzorce, takie jak przy użyciu wzorca specyfikacji dla sprawdzania poprawności i wzorzec powiadomień, aby zwrócić kolekcję błędów zamiast zwracać wyjątek dla każdego sprawdzania poprawności, jak to się dzieje.</span><span class="sxs-lookup"><span data-stu-id="7396f-121">There are also more advanced patterns such as using the Specification pattern for validations, and the Notification pattern to return a collection of errors instead of returning an exception for each validation as it occurs.</span></span>

### <a name="validate-conditions-and-throw-exceptions"></a><span data-ttu-id="7396f-122">Sprawdzanie poprawności warunków i zgłaszanie wyjątków</span><span class="sxs-lookup"><span data-stu-id="7396f-122">Validate conditions and throw exceptions</span></span>

<span data-ttu-id="7396f-123">W poniższym przykładzie kodu przedstawiono najprostsze podejście do sprawdzania poprawności w jednostce domeny, zgłaszając wyjątek.</span><span class="sxs-lookup"><span data-stu-id="7396f-123">The following code example shows the simplest approach to validation in a domain entity by raising an exception.</span></span> <span data-ttu-id="7396f-124">W tabeli odwołań na końcu tej sekcji można zobaczyć łącza do bardziej zaawansowanych implementacji na podstawie wzorców, które omówiliśmy wcześniej.</span><span class="sxs-lookup"><span data-stu-id="7396f-124">In the references table at the end of this section you can see links to more advanced implementations based on the patterns we have discussed previously.</span></span>

```csharp
public void SetAddress(Address address)
{
    _shippingAddress = address?? throw new ArgumentNullException(nameof(address));
}
```

<span data-ttu-id="7396f-125">Lepszym przykładem może być wykazanie potrzeby zapewnienia, że stan wewnętrzny nie zmienił się lub że wystąpiły wszystkie mutacje dla metody.</span><span class="sxs-lookup"><span data-stu-id="7396f-125">A better example would demonstrate the need to ensure that either the internal state did not change, or that all the mutations for a method occurred.</span></span> <span data-ttu-id="7396f-126">Na przykład następująca implementacja pozostawi obiekt w nieprawidłowym stanie:</span><span class="sxs-lookup"><span data-stu-id="7396f-126">For example, the following implementation would leave the object in an invalid state:</span></span>

```csharp
public void SetAddress(string line1, string line2,
    string city, string state, int zip)
{
    _shippingAddress.line1 = line1 ?? throw new ...
    _shippingAddress.line2 = line2;
    _shippingAddress.city = city ?? throw new ...
    _shippingAddress.state = (IsValid(state) ? state : throw new …);
}
```

<span data-ttu-id="7396f-127">Jeśli wartość stanu jest nieprawidłowa, pierwszy wiersz adresu i miasto zostały już zmienione.</span><span class="sxs-lookup"><span data-stu-id="7396f-127">If the value of the state is invalid, the first address line and the city have already been changed.</span></span> <span data-ttu-id="7396f-128">To może sprawić, że adres jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="7396f-128">That might make the address invalid.</span></span>

<span data-ttu-id="7396f-129">Podobne podejście może służyć w konstruktorze jednostki, podnosząc wyjątek, aby upewnić się, że jednostka jest prawidłowa po utworzeniu.</span><span class="sxs-lookup"><span data-stu-id="7396f-129">A similar approach can be used in the entity’s constructor, raising an exception to make sure that the entity is valid once it is created.</span></span>

### <a name="use-validation-attributes-in-the-model-based-on-data-annotations"></a><span data-ttu-id="7396f-130">Używanie atrybutów sprawdzania poprawności w modelu na podstawie adnotacji danych</span><span class="sxs-lookup"><span data-stu-id="7396f-130">Use validation attributes in the model based on data annotations</span></span>

<span data-ttu-id="7396f-131">Adnotacje danych, takie jak required lub MaxLength atrybuty, może służyć do konfigurowania właściwości pola bazy danych EF Core, jak wyjaśniono szczegółowo w sekcji [mapowania tabeli,](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping) ale [nie działają już dla sprawdzania poprawności jednostki w EF Core](https://github.com/dotnet/efcore/issues/3680) (nie ma <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> metody), jak to miało miejsce od EF 4.x w .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7396f-131">Data annotations, like the Required or MaxLength attributes, can be used to configure EF Core database field properties, as explained in detail in the [Table mapping](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping) section, but [they no longer work for entity validation in EF Core](https://github.com/dotnet/efcore/issues/3680) (neither does the <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> method), as they have done since EF 4.x in .NET Framework.</span></span>

<span data-ttu-id="7396f-132">Adnotacje danych <xref:System.ComponentModel.DataAnnotations.IValidatableObject> i interfejs nadal mogą być używane do sprawdzania poprawności modelu podczas wiązania modelu, przed wywołaniem akcji kontrolera, jak zwykle, ale ten model ma być ViewModel lub DTO i to jest MVC lub API dotyczą nie dotyczy problemu modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="7396f-132">Data annotations and the <xref:System.ComponentModel.DataAnnotations.IValidatableObject> interface can still be used for model validation during model binding, prior to the controller’s actions invocation as usual, but that model is meant to be a ViewModel or DTO and that’s an MVC or API concern not a domain model concern.</span></span>

<span data-ttu-id="7396f-133">Po dokonaniu różnica koncepcyjne jasne, nadal można użyć `IValidatableObject` adnotacji danych i w klasie jednostki do sprawdzania poprawności, jeśli akcje odbierają parametr obiektu klasy jednostki, który nie jest zalecane.</span><span class="sxs-lookup"><span data-stu-id="7396f-133">Having made the conceptual difference clear, you can still use data annotations and `IValidatableObject` in the entity class for validation, if your actions receive an entity class object parameter, which is not recommended.</span></span> <span data-ttu-id="7396f-134">W takim przypadku sprawdzania poprawności nastąpi na powiązanie modelu, tuż przed wywołaniem akcji i można sprawdzić modelstate kontrolera.IsValid właściwości, aby sprawdzić wynik, ale potem znowu, dzieje się w kontrolerze, nie przed utrwalenia obiektu jednostki w DbContext, jak to miało miejsce od EF 4.x.</span><span class="sxs-lookup"><span data-stu-id="7396f-134">In that case, validation will occur upon model binding, just before invoking the action and you can check the controller’s ModelState.IsValid property to check the result, but then again, it happens in the controller, not before persisting the entity object in the DbContext, as it had done since EF 4.x.</span></span>

<span data-ttu-id="7396f-135">Nadal można zaimplementować niestandardowe sprawdzanie poprawności w klasie `IValidatableObject.Validate` jednostki przy użyciu adnotacji danych i metody, zastępując Metodę SaveChanges DbContext.</span><span class="sxs-lookup"><span data-stu-id="7396f-135">You can still implement custom validation in the entity class using data annotations and the `IValidatableObject.Validate` method, by overriding the DbContext’s SaveChanges method.</span></span>

<span data-ttu-id="7396f-136">Możesz zobaczyć przykładową implementację `IValidatableObject` sprawdzania poprawności jednostek w [tym komentarzu w uspolu GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span><span class="sxs-lookup"><span data-stu-id="7396f-136">You can see a sample implementation for validating `IValidatableObject` entities in [this comment on GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span></span> <span data-ttu-id="7396f-137">Ten przykład nie wykonuje sprawdzania poprawności opartych na atrybutach, ale powinny być łatwe do zaimplementowania przy użyciu odbicia w tym samym zastąpić.</span><span class="sxs-lookup"><span data-stu-id="7396f-137">That sample doesn't do attribute-based validations, but they should be easy to implement using reflection in the same override.</span></span>

<span data-ttu-id="7396f-138">Jednak z punktu widzenia DDD model domeny jest najlepiej utrzymywany jako lean przy użyciu wyjątków w metodach zachowania jednostki lub przez wdrożenie wzorców specyfikacji i powiadomień w celu wymuszenia reguł sprawdzania poprawności.</span><span class="sxs-lookup"><span data-stu-id="7396f-138">However, from a DDD point of view, the domain model is best kept lean with the use of exceptions in your entity’s behavior methods, or by implementing the Specification and Notification patterns to enforce validation rules.</span></span>

<span data-ttu-id="7396f-139">Warto użyć adnotacji danych w warstwie aplikacji w klasach ViewModel (zamiast jednostek domeny), które będą akceptować dane wejściowe, aby umożliwić sprawdzanie poprawności modelu w warstwie interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="7396f-139">It can make sense to use data annotations at the application layer in ViewModel classes (instead of domain entities) that will accept input, to allow for model validation within the UI layer.</span></span> <span data-ttu-id="7396f-140">Jednak nie należy tego robić z wyłączeniem sprawdzania poprawności w modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="7396f-140">However, this should not be done at the exclusion of validation within the domain model.</span></span>

### <a name="validate-entities-by-implementing-the-specification-pattern-and-the-notification-pattern"></a><span data-ttu-id="7396f-141">Sprawdzanie poprawności jednostek przez wdrożenie wzorca specyfikacji i wzorca powiadomień</span><span class="sxs-lookup"><span data-stu-id="7396f-141">Validate entities by implementing the Specification pattern and the Notification pattern</span></span>

<span data-ttu-id="7396f-142">Na koniec bardziej rozbudowane podejście do implementowania sprawdzania poprawności w modelu domeny jest poprzez implementowanie wzorca specyfikacji w połączeniu ze wzorcem powiadomień, jak wyjaśniono w niektórych dodatkowych zasobów wymienionych później.</span><span class="sxs-lookup"><span data-stu-id="7396f-142">Finally, a more elaborate approach to implementing validations in the domain model is by implementing the Specification pattern in conjunction with the Notification pattern, as explained in some of the additional resources listed later.</span></span>

<span data-ttu-id="7396f-143">Warto wspomnieć, że można również użyć tylko jednego z tych wzorców — na przykład ręcznego sprawdzania poprawności za pomocą instrukcji sterujących, ale przy użyciu wzorca powiadomień do stosu i zwrócenia listy błędów sprawdzania poprawności.</span><span class="sxs-lookup"><span data-stu-id="7396f-143">It is worth mentioning that you can also use just one of those patterns—for example, validating manually with control statements, but using the Notification pattern to stack and return a list of validation errors.</span></span>

### <a name="use-deferred-validation-in-the-domain"></a><span data-ttu-id="7396f-144">Używanie odroczonego sprawdzania poprawności w domenie</span><span class="sxs-lookup"><span data-stu-id="7396f-144">Use deferred validation in the domain</span></span>

<span data-ttu-id="7396f-145">Istnieją różne podejścia do radzenia sobie z odroczonego sprawdzania poprawności w domenie.</span><span class="sxs-lookup"><span data-stu-id="7396f-145">There are various approaches to deal with deferred validations in the domain.</span></span> <span data-ttu-id="7396f-146">W swojej książce [Implementing Domain-Driven Design,](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)Vaughn Vernon omawia te w sekcji na walidacji.</span><span class="sxs-lookup"><span data-stu-id="7396f-146">In his book [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon discusses these in the section on validation.</span></span>

### <a name="two-step-validation"></a><span data-ttu-id="7396f-147">Walidacja dwuetapowa</span><span class="sxs-lookup"><span data-stu-id="7396f-147">Two-step validation</span></span>

<span data-ttu-id="7396f-148">Należy również wziąć pod uwagę weryfikacji dwuetapowej.</span><span class="sxs-lookup"><span data-stu-id="7396f-148">Also consider two-step validation.</span></span> <span data-ttu-id="7396f-149">Użyj sprawdzania poprawności na poziomie pola w pole obiekty transferu danych (DTO) i sprawdzania poprawności na poziomie domeny wewnątrz jednostek.</span><span class="sxs-lookup"><span data-stu-id="7396f-149">Use field-level validation on your command Data Transfer Objects (DTOs) and domain-level validation inside your entities.</span></span> <span data-ttu-id="7396f-150">Można to zrobić, zwracając obiekt wynik zamiast wyjątków, aby ułatwić radzenie sobie z błędami sprawdzania poprawności.</span><span class="sxs-lookup"><span data-stu-id="7396f-150">You can do this by returning a result object instead of exceptions in order to make it easier to deal with the validation errors.</span></span>

<span data-ttu-id="7396f-151">Na przykład za pomocą sprawdzania poprawności pola z adnotacjami danych nie można powielać definicji sprawdzania poprawności.</span><span class="sxs-lookup"><span data-stu-id="7396f-151">Using field validation with data annotations, for example, you do not duplicate the validation definition.</span></span> <span data-ttu-id="7396f-152">Wykonanie, choć może być zarówno po stronie serwera, jak i po stronie klienta w przypadku DCO (polecenia i ViewModels, na przykład).</span><span class="sxs-lookup"><span data-stu-id="7396f-152">The execution, though, can be both server-side and client-side in the case of DTOs (commands and ViewModels, for instance).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="7396f-153">Zasoby dodatkowe</span><span class="sxs-lookup"><span data-stu-id="7396f-153">Additional resources</span></span>

- <span data-ttu-id="7396f-154">**Rachel Appel. Wprowadzenie do sprawdzania poprawności modelu w ASP.NET Core MVC** </span><span class="sxs-lookup"><span data-stu-id="7396f-154">**Rachel Appel. Introduction to model validation in ASP.NET Core MVC** </span></span>\
  <https://docs.microsoft.com/aspnet/core/mvc/models/validation>

- <span data-ttu-id="7396f-155">**Rick Anderson. Dodawanie sprawdzania poprawności** </span><span class="sxs-lookup"><span data-stu-id="7396f-155">**Rick Anderson. Adding validation** </span></span>\
  <https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation>

- <span data-ttu-id="7396f-156">**Martin Fowler. Zastępowanie zgłaszających wyjątków powiadomieniem w modułach sprawdzania poprawności** </span><span class="sxs-lookup"><span data-stu-id="7396f-156">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** </span></span>\
  <https://martinfowler.com/articles/replaceThrowWithNotification.html>

- <span data-ttu-id="7396f-157">**Specyfikacja i wzorce powiadomień** </span><span class="sxs-lookup"><span data-stu-id="7396f-157">**Specification and Notification Patterns** </span></span>\
  <https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns>

- <span data-ttu-id="7396f-158">**Lew Gorodinski. Sprawdzanie poprawności w projekcie opartym na domenie (DDD)** </span><span class="sxs-lookup"><span data-stu-id="7396f-158">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)** </span></span>\
  <http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/>

- <span data-ttu-id="7396f-159">**Colin Jack. Sprawdzanie poprawności modelu domeny** </span><span class="sxs-lookup"><span data-stu-id="7396f-159">**Colin Jack. Domain Model Validation** </span></span>\
  <https://colinjack.blogspot.com/2008/03/domain-model-validation.html>

- <span data-ttu-id="7396f-160">**Jimmy Bogard. Walidacja w świecie DDD** </span><span class="sxs-lookup"><span data-stu-id="7396f-160">**Jimmy Bogard. Validation in a DDD world** </span></span>\
  <https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/>

> [!div class="step-by-step"]
> <span data-ttu-id="7396f-161">[Poprzedni](enumeration-classes-over-enum-types.md)
> [następny](client-side-validation.md)</span><span class="sxs-lookup"><span data-stu-id="7396f-161">[Previous](enumeration-classes-over-enum-types.md)
[Next](client-side-validation.md)</span></span>
