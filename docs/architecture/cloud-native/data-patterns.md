---
title: Wzorce danych natywnych w chmurze
description: Tworzenie architektury natywnych aplikacji .NET w chmurze dla platformy Azure | Wzorce danych natywnych w chmurze
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/30/2019
ms.locfileid: "73087699"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="a614f-103">Wzorce danych natywnych w chmurze</span><span class="sxs-lookup"><span data-stu-id="a614f-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="a614f-104">Zdecentralizowane dane mogą prowadzić do zwiększenia wydajności, skalowalności i oszczędności kosztów, a także wiele wyzwań.</span><span class="sxs-lookup"><span data-stu-id="a614f-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="a614f-105">Wykonywanie zapytań dotyczących danych w mikrousługach jest złożone.</span><span class="sxs-lookup"><span data-stu-id="a614f-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="a614f-106">Transakcja, która obejmuje mikrousługi, musi być zarządzana programowo, ponieważ transakcje rozproszone nie są obsługiwane w aplikacjach natywnych w chmurze.</span><span class="sxs-lookup"><span data-stu-id="a614f-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="a614f-107">Przenosisz ze świata *natychmiastowej spójności* do *spójności ostatecznej*.</span><span class="sxs-lookup"><span data-stu-id="a614f-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="a614f-108">Omawiamy te wyzwania teraz.</span><span class="sxs-lookup"><span data-stu-id="a614f-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="a614f-109">Zapytania międzyusługowe</span><span class="sxs-lookup"><span data-stu-id="a614f-109">Cross-service queries</span></span>

<span data-ttu-id="a614f-110">Jak aplikacja wykonuje zapytania dotyczące danych, które są rozłożone na wiele niezależnych mikrousług?</span><span class="sxs-lookup"><span data-stu-id="a614f-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="a614f-111">Na rysunku 5-4 przedstawiono ten scenariusz.</span><span class="sxs-lookup"><span data-stu-id="a614f-111">Figure 5-4 shows this scenario.</span></span>

![Wykonywanie zapytań na mikrousługach](./media/cross-service-query.png)

<span data-ttu-id="a614f-113">**Rysunek 5-4**.</span><span class="sxs-lookup"><span data-stu-id="a614f-113">**Figure 5-4**.</span></span> <span data-ttu-id="a614f-114">Wykonywanie zapytań na mikrousługach</span><span class="sxs-lookup"><span data-stu-id="a614f-114">Querying across microservices</span></span>

<span data-ttu-id="a614f-115">Zwróć uwagę na to, jak na powyższym rysunku zobaczymy mikrousługę koszyka zakupów, która dodaje element do koszyka zakupów użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a614f-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="a614f-116">Chociaż magazyn danych koszyka zakupów zawiera tabelę koszyka i lineItem, nie zawiera danych o produkcie ani cenach, ponieważ te elementy znajdują się w mikrousługach produktu i cen.</span><span class="sxs-lookup"><span data-stu-id="a614f-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="a614f-117">Aby dodać element, usługa koszyka zakupów potrzebuje danych produktu i cennika.</span><span class="sxs-lookup"><span data-stu-id="a614f-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="a614f-118">Jakie są opcje uzyskiwania informacji o produkcie i cenach?</span><span class="sxs-lookup"><span data-stu-id="a614f-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="a614f-119">Rysunek 5-5 przedstawia mikrousługi koszyka zakupów bezpośrednie wywołanie protokołu HTTP zarówno do wykazu produktów, jak i mikrousług cenowych.</span><span class="sxs-lookup"><span data-stu-id="a614f-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Bezpośrednia komunikacja http](./media/direct-http-communication.png)

<span data-ttu-id="a614f-121">**Rysunek 5-5**.</span><span class="sxs-lookup"><span data-stu-id="a614f-121">**Figure 5-5**.</span></span> <span data-ttu-id="a614f-122">Bezpośrednia komunikacja HTTP</span><span class="sxs-lookup"><span data-stu-id="a614f-122">Direct HTTP communication</span></span>

<span data-ttu-id="a614f-123">Chociaż jest to możliwe do wdrożenia, w rozdziale 4 opisano sposób bezpośredniego wywoływania protokołu HTTP w mikrousługach, a nie jako dobre rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="a614f-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="a614f-124">Możemy zaimplementować mikrousługę agregatora przedstawioną na rysunku 5-6.</span><span class="sxs-lookup"><span data-stu-id="a614f-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Mikrousługa agregatora](./media/aggregator-microservice.png)

<span data-ttu-id="a614f-126">**Rysunek 5-6.**</span><span class="sxs-lookup"><span data-stu-id="a614f-126">**Figure 5-6.**</span></span> <span data-ttu-id="a614f-127">Mikrousługa agregatora</span><span class="sxs-lookup"><span data-stu-id="a614f-127">Aggregator microservice</span></span>

<span data-ttu-id="a614f-128">Chociaż to podejście hermetyzuje przepływ pracy operacji biznesowej w pojedynczej mikrousłudze, zwiększa złożoność i nadal prowadzi bezpośrednie wywołania HTTP.</span><span class="sxs-lookup"><span data-stu-id="a614f-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="a614f-129">Typowym podejściem do wykonywania zapytań wykonywanych przez wiele usług jest użycie [wzorca widoku materiałowego](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), pokazanego na rysunku 5-7.</span><span class="sxs-lookup"><span data-stu-id="a614f-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Wzorzec widoku materiałowego](./media/materialized-view-pattern.png)

<span data-ttu-id="a614f-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="a614f-131">**Figure5-7**.</span></span> <span data-ttu-id="a614f-132">Wzorzec widoku materiałowego</span><span class="sxs-lookup"><span data-stu-id="a614f-132">Materialized View Pattern</span></span>

<span data-ttu-id="a614f-133">Za pomocą tego wzorca bezpośrednio umieszczasz tabelę lokalną (nazywaną *modelem odczytu*) w usłudze koszyka zakupów, która zawiera nieznormalizowaną kopię danych, która jest wymagana od mikrousług produktu i cen.</span><span class="sxs-lookup"><span data-stu-id="a614f-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="a614f-134">Umieszczenie tych danych w ramach usługi koszyka zakupów eliminuje konieczność wywoływania kosztownych wywołań międzyusługowych.</span><span class="sxs-lookup"><span data-stu-id="a614f-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="a614f-135">W przypadku danych lokalnych dla usługi można poprawić czas odpowiedzi i niezawodność.</span><span class="sxs-lookup"><span data-stu-id="a614f-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="a614f-136">Catch z tym podejściem ma teraz duplikaty danych w systemie.</span><span class="sxs-lookup"><span data-stu-id="a614f-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="a614f-137">W systemach natywnych w chmurze duplikaty danych nie są uznawane za [Antywzorzec](https://en.wikipedia.org/wiki/Anti-pattern) i są zwykle zaimplementowane w systemach natywnych w chmurze.</span><span class="sxs-lookup"><span data-stu-id="a614f-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="a614f-138">Jednak jeden i tylko jeden system może być właścicielem dowolnego zestawu danych i należy zaimplementować mechanizm synchronizacji dla systemu rejestrowania, aby zaktualizować wszystkie skojarzone modele odczytu, gdy następuje zmiana danych źródłowych.</span><span class="sxs-lookup"><span data-stu-id="a614f-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="a614f-139">Obsługa transakcyjna</span><span class="sxs-lookup"><span data-stu-id="a614f-139">Transactional support</span></span>

<span data-ttu-id="a614f-140">Podczas gdy zapytania między mikrousługami są trudne, wdrożenie transakcji w mikrousługach może być skomplikowane.</span><span class="sxs-lookup"><span data-stu-id="a614f-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="a614f-141">Nieodłączne wyzwanie związane z utrzymywaniem spójności danych między źródłami danych znajdującymi się w różnych mikrousługach nie jest możliwe.</span><span class="sxs-lookup"><span data-stu-id="a614f-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="a614f-142">Rysunek 5-8 pokazuje problem.</span><span class="sxs-lookup"><span data-stu-id="a614f-142">Figure 5-8 shows the problem.</span></span>

![Transakcja w wzorcu Saga](./media/saga-transaction-operation.png)

<span data-ttu-id="a614f-144">**Rysunek 5-8**.</span><span class="sxs-lookup"><span data-stu-id="a614f-144">**Figure 5-8**.</span></span> <span data-ttu-id="a614f-145">Implementowanie transakcji w mikrousługach</span><span class="sxs-lookup"><span data-stu-id="a614f-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="a614f-146">Zwróć uwagę na to, jak w poprzednim rysunku pięciu niezależnych mikrousług wszyscy uczestniczą w rozproszonej transakcji *tworzenia zamówienia* .</span><span class="sxs-lookup"><span data-stu-id="a614f-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="a614f-147">Jednakże transakcja dla każdego z pięciu poszczególnych mikrousług musi się powieść lub wszystkie muszą przerwać operację.</span><span class="sxs-lookup"><span data-stu-id="a614f-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll-back the operation.</span></span> <span data-ttu-id="a614f-148">Wbudowana obsługa transakcyjna jest dostępna w ramach każdej mikrousług, ale nie jest obsługiwana transakcja rozproszona w ramach wszystkich pięciu usług.</span><span class="sxs-lookup"><span data-stu-id="a614f-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="a614f-149">Ponieważ obsługa transakcyjna jest istotna dla tej operacji, aby zachować spójność danych w poszczególnych mikrousługach, należy programowo skonstruować transakcję rozproszoną.</span><span class="sxs-lookup"><span data-stu-id="a614f-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="a614f-150">Popularnym wzorcem do programistycznego dodawania obsługi transakcyjnej jest [wzorzec Saga](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="a614f-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="a614f-151">Jest to implementowane przez grupowanie transakcji lokalnych razem i sekwencyjne wywoływanie każdego z nich.</span><span class="sxs-lookup"><span data-stu-id="a614f-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="a614f-152">Jeśli transakcja lokalna nie powiedzie się, Saga przerywa operację i wywołuje zestaw [kompensowania transakcji](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) , aby cofnąć zmiany wprowadzone przez poprzednie transakcje lokalne.</span><span class="sxs-lookup"><span data-stu-id="a614f-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="a614f-153">Rysunek 5-9 pokazuje nieudaną transakcję ze wzorcem Saga.</span><span class="sxs-lookup"><span data-stu-id="a614f-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Wycofywanie w wzorcu Saga](./media/saga-rollback-operation.png)

<span data-ttu-id="a614f-155">**Rysunek 5-9**.</span><span class="sxs-lookup"><span data-stu-id="a614f-155">**Figure 5-9**.</span></span> <span data-ttu-id="a614f-156">Wycofywanie transakcji</span><span class="sxs-lookup"><span data-stu-id="a614f-156">Rolling back a transaction</span></span>

<span data-ttu-id="a614f-157">Zwróć uwagę na to, jak na poprzednim rysunku operacja *GenerateContent* nie powiodła się w mikrousłudze muzycznej.</span><span class="sxs-lookup"><span data-stu-id="a614f-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="a614f-158">Saga wywołuje kompensowanie transakcji (czerwony) do usunięcia zawartości, anuluje płatność i anuluje zamówienie, zwracając dane dla każdej mikrousługi z powrotem do spójnego stanu.</span><span class="sxs-lookup"><span data-stu-id="a614f-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="a614f-159">Wzorce Saga są zwykle choreographed jako serie powiązanych zdarzeń lub zorganizowane jako zestaw powiązanych poleceń.</span><span class="sxs-lookup"><span data-stu-id="a614f-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="a614f-160">Wzorzec CQRS</span><span class="sxs-lookup"><span data-stu-id="a614f-160">CQRS pattern</span></span>

<span data-ttu-id="a614f-161">CQRS, lub [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), to wzorzec architektoniczny, który oddziela operacje odczytujące dane z tych, które zapisują dane.</span><span class="sxs-lookup"><span data-stu-id="a614f-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="a614f-162">Ten wzorzec może pomóc w maksymalizacji wydajności, skalowalności i bezpieczeństwa.</span><span class="sxs-lookup"><span data-stu-id="a614f-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="a614f-163">W normalnych scenariuszach dostępu do danych implementowany jest jeden model (obiekt jednostki i repozytorium), który wykonuje *operacje odczytu i* zapisu danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="a614f-164">Jednak bardziej zaawansowany scenariusz dostępu do danych może korzystać z oddzielnych modeli i tabel danych do odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="a614f-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="a614f-165">Aby zwiększyć wydajność, operacja odczytu, znana jako *zapytanie*, może wykonywać zapytania względem wysoce nieznormalizowanej reprezentacji danych, aby uniknąć kosztownych sprzężeń między tabelami.</span><span class="sxs-lookup"><span data-stu-id="a614f-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="a614f-166">Podczas gdy operacja *zapisu* , znana jako *polecenie*, może być aktualizowana względem w pełni znormalizowanej reprezentacji danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="a614f-167">Następnie należy zaimplementować mechanizm, aby zachować obie reprezentacje w synchronizacji. Zazwyczaj zawsze, gdy tabela zapisu zostanie zmodyfikowana, wywołuje zdarzenie, które replikuje modyfikację danych do tabeli Odczytaj.</span><span class="sxs-lookup"><span data-stu-id="a614f-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="a614f-168">Na rysunku 5-10 przedstawiono implementację wzorca CQRS.</span><span class="sxs-lookup"><span data-stu-id="a614f-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![Implementacja CQRS](./media/cqrs-implementation.png)

<span data-ttu-id="a614f-170">**Rysunek 5-10**.</span><span class="sxs-lookup"><span data-stu-id="a614f-170">**Figure 5-10**.</span></span> <span data-ttu-id="a614f-171">Implementacja CQRS</span><span class="sxs-lookup"><span data-stu-id="a614f-171">CQRS implementation</span></span>

<span data-ttu-id="a614f-172">Zwróć uwagę na to, jak w poprzednim rysunku są implementowane poszczególne modele poleceń i zapytań.</span><span class="sxs-lookup"><span data-stu-id="a614f-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="a614f-173">Ponadto każda operacja zapisu danych jest zapisywana w magazynie zapisu, a następnie propagowana do magazynu odczytu.</span><span class="sxs-lookup"><span data-stu-id="a614f-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="a614f-174">Należy zwrócić szczególną uwagę na to, jak proces propagacji działa zgodnie z zasadą [spójności ostatecznej](https://www.cloudcomputingpatterns.org/eventual_consistency/), podczas gdy model odczytu ostatecznie synchronizuje się z modelem zapisu, ale może wystąpić pewne opóźnienia w procesie.</span><span class="sxs-lookup"><span data-stu-id="a614f-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="a614f-175">Wdrożenie separacji pozwala na skalowanie odczytów i zapisów oddzielnie.</span><span class="sxs-lookup"><span data-stu-id="a614f-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="a614f-176">Ponadto można nałożyć ściślejsze zabezpieczenia na operacje zapisu niż w przypadku operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="a614f-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="a614f-177">Zwykle wzorce CQRS są stosowane do ograniczonych sekcji systemu w zależności od konkretnych potrzeb.</span><span class="sxs-lookup"><span data-stu-id="a614f-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="a614f-178">Relacyjne vs NoSQL</span><span class="sxs-lookup"><span data-stu-id="a614f-178">Relational vs NoSQL</span></span>

<span data-ttu-id="a614f-179">Nie można zastanowić się nad wpływem technologii [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) , szczególnie w przypadku rozproszonych systemów natywnych w chmurze.</span><span class="sxs-lookup"><span data-stu-id="a614f-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="a614f-180">Rozprzestrzenianie się nowych technologii danych w tym miejscu ma zakłócone rozwiązania, które są dostępne tylko w odniesieniu do relacyjnych baz danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="a614f-181">Z jednej strony relacyjne bazy danych były powszechnie rozpowszechnioną technologią dla dekad.</span><span class="sxs-lookup"><span data-stu-id="a614f-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="a614f-182">Są one dojrzałe, sprawdzone i szeroko implementowane.</span><span class="sxs-lookup"><span data-stu-id="a614f-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="a614f-183">Konkurencyjne produkty bazy danych, doświadczenie i narzędzia abounds.</span><span class="sxs-lookup"><span data-stu-id="a614f-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="a614f-184">Relacyjne bazy danych zapewniają magazyn powiązanych tabel danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="a614f-185">Te tabele mają stały schemat, za pomocą programu SQL (Structured Query Language) można zarządzać danymi i mieć zapewniony [kwas](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (znany także jako niepodzielność, spójność, izolacja i trwałość).</span><span class="sxs-lookup"><span data-stu-id="a614f-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="a614f-186">Bazy danych bez programu SQL po drugiej stronie zapoznaj się z tematem magazyny o wysokiej wydajności, nierelacyjne.</span><span class="sxs-lookup"><span data-stu-id="a614f-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="a614f-187">Są one w programie Excel w ich łatwość użycia, skalowalności, odporności i dostępności.</span><span class="sxs-lookup"><span data-stu-id="a614f-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="a614f-188">Zamiast sprzęgać tabele znormalizowanych danych, NoSQL przechowuje własne opisy (bez schematu) dane zazwyczaj w dokumentach JSON.</span><span class="sxs-lookup"><span data-stu-id="a614f-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="a614f-189">Nie oferują one gwarancji [kwaśnych](https://www.geeksforgeeks.org/acid-properties-in-dbms/) .</span><span class="sxs-lookup"><span data-stu-id="a614f-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="a614f-190">Sposób zrozumienia różnic między tymi typami baz danych można znaleźć w [theorem Cap](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), zestaw zasad, które mogą być stosowane do systemów rozproszonych, które są przechowywane w stanie.</span><span class="sxs-lookup"><span data-stu-id="a614f-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="a614f-191">Rysunek 5-11 pokazuje trzy właściwości CAP theorem.</span><span class="sxs-lookup"><span data-stu-id="a614f-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![Theorem CAP](./media/cap-theorem.png)

<span data-ttu-id="a614f-193">**Rysunek 5-11**.</span><span class="sxs-lookup"><span data-stu-id="a614f-193">**Figure 5-11**.</span></span> <span data-ttu-id="a614f-194">Theorem zakończenia</span><span class="sxs-lookup"><span data-stu-id="a614f-194">The CAP theorem</span></span>

<span data-ttu-id="a614f-195">Theorem stwierdza, że każdy rozproszony system danych będzie oferować kompromis między spójnością, dostępnością i tolerancją partycji oraz że każda baza danych może zagwarantować tylko dwie z trzech właściwości:</span><span class="sxs-lookup"><span data-stu-id="a614f-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="a614f-196">*Spójność*: każdy węzeł w klastrze będzie odpowiadał na najnowsze dane, nawet jeśli wymaga zablokowania żądania do momentu, aż wszystkie repliki zostaną prawidłowo zaktualizowane.</span><span class="sxs-lookup"><span data-stu-id="a614f-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="a614f-197">*Dostępność*: każdy węzeł zwróci odpowiedź w rozsądnym czasie, nawet jeśli ta odpowiedź nie jest najnowszą ilością danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="a614f-198">*Tolerancja partycji*: gwarantuje, że system będzie kontynuował działanie, jeśli węzeł ulegnie awarii lub utraci połączenie z innym.</span><span class="sxs-lookup"><span data-stu-id="a614f-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="a614f-199">Relacyjne bazy danych wykazują spójność i dostępność, ale nie tolerancję partycji.</span><span class="sxs-lookup"><span data-stu-id="a614f-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="a614f-200">Partycjonowanie relacyjnej bazy danych, takiej jak fragmentowania, jest trudne i może mieć wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="a614f-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="a614f-201">Z drugiej strony bazy danych NoSQL zwykle wykazują tolerancję partycji, znaną jako skalowalność i wysoką dostępność.</span><span class="sxs-lookup"><span data-stu-id="a614f-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="a614f-202">Ponieważ theorem CAP określa, można mieć tylko dwie z trzech zasad i utracić Właściwość spójności.</span><span class="sxs-lookup"><span data-stu-id="a614f-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="a614f-203">Bazy danych NoSQL są dystrybuowane i często skalowane na serwerach asortymentu.</span><span class="sxs-lookup"><span data-stu-id="a614f-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="a614f-204">Takie działanie może zapewnić doskonałą dostępność, zarówno w regionie, jak i w regionach geograficznych, przy niższych kosztach.</span><span class="sxs-lookup"><span data-stu-id="a614f-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="a614f-205">Dane mogą być partycjonowane i replikowane na tych maszynach, na węzłach, w celu zapewnienia nadmiarowości i odporności na uszkodzenia.</span><span class="sxs-lookup"><span data-stu-id="a614f-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="a614f-206">Minusem jest spójna.</span><span class="sxs-lookup"><span data-stu-id="a614f-206">The downside is consistency.</span></span> <span data-ttu-id="a614f-207">Zmiana danych w jednym węźle NoSQL może zająć trochę czasu do innych węzłów.</span><span class="sxs-lookup"><span data-stu-id="a614f-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="a614f-208">Zazwyczaj węzeł bazy danych NoSQL będzie dostarczać natychmiastową odpowiedź do zapytania, nawet jeśli dane, które są obecnie wysyłane, są przestarzałe i nie zostały jeszcze zaktualizowane.</span><span class="sxs-lookup"><span data-stu-id="a614f-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="a614f-209">Jest to znana [spójność ostateczna](https://www.cloudcomputingpatterns.org/eventual_consistency/), charakterystyczną dla rozproszonych systemów danych, w której nie są obsługiwane transakcje kwasowe.</span><span class="sxs-lookup"><span data-stu-id="a614f-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="a614f-210">Jest to krótkie opóźnienie między aktualizacją elementu danych i czasu potrzebnego do propagowania tej aktualizacji do poszczególnych węzłów repliki.</span><span class="sxs-lookup"><span data-stu-id="a614f-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="a614f-211">W przypadku zaktualizowania elementu produktu w bazie danych NoSQL w Stany Zjednoczone, ale w tym samym czasie zapytanie o ten sam element danych z węzła repliki w Europie, można pobrać wcześniejsze informacje o produkcie — do momentu zaktualizowania węzła Europejskiego przy zmianie produktu.</span><span class="sxs-lookup"><span data-stu-id="a614f-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="a614f-212">W związku z tym, że jest to spowodowane [silną spójnością](https://en.wikipedia.org/wiki/Strong_consistency), oczekiwanie na zaktualizowanie wszystkich węzłów repliki przed zwróceniem wyników zapytania, można obsługiwać ogromny rozmiar i ilość ruchu sieciowego, ale z możliwością przedsprzedaży starszych danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="a614f-213">Bazy danych NoSQL można klasyfikować według następujących czterech modeli:</span><span class="sxs-lookup"><span data-stu-id="a614f-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="a614f-214">*Magazyn dokumentów* (MongoDB, CouchDB, Couchbase): dane (i odpowiadające im metadane) są przechowywane w nierelacyjny sposób w nieznormalizowanych dokumentach opartych na notacji JSON w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="a614f-215">*Magazyn kluczy/wartości* (Redis, Riak, Memcached): dane są przechowywane w prostych parach klucz-wartość z operacjami systemu wykonywanymi przy użyciu unikatowego klucza dostępu, który jest mapowany na wartość danych użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a614f-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="a614f-216">*Magazyn szerokiej kolumny* (HBase, Cassandra): powiązane dane są przechowywane w formacie kolumnowy jako zestaw par klucz-wartość w jednej kolumnie z danymi, które są zwykle pobierane jako pojedyncze jednostki bez konieczności sprzęgania wielu tabel.</span><span class="sxs-lookup"><span data-stu-id="a614f-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="a614f-217">*Sklepy grafów* (Neo4j, Titan): dane są przechowywane jako graficzna reprezentacja w węźle wraz z krawędziami określającymi relację między węzłami.</span><span class="sxs-lookup"><span data-stu-id="a614f-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="a614f-218">Bazy danych NoSQL można zoptymalizować pod kątem obsługi danych na dużą skalę, zwłaszcza wtedy, gdy dane są stosunkowo proste.</span><span class="sxs-lookup"><span data-stu-id="a614f-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="a614f-219">Bazę danych NoSQL należy wziąć pod uwagę w przypadku:</span><span class="sxs-lookup"><span data-stu-id="a614f-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="a614f-220">Obciążenie wymaga dużej skali i dużej współbieżności.</span><span class="sxs-lookup"><span data-stu-id="a614f-220">Your workload requires large-scale and high-concurrency.</span></span>
- <span data-ttu-id="a614f-221">Masz dużą liczbę użytkowników.</span><span class="sxs-lookup"><span data-stu-id="a614f-221">You have large numbers of users.</span></span>
- <span data-ttu-id="a614f-222">Dane można wyrazić po prostu bez relacji.</span><span class="sxs-lookup"><span data-stu-id="a614f-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="a614f-223">Konieczne jest geograficznie dystrybuowanie danych.</span><span class="sxs-lookup"><span data-stu-id="a614f-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="a614f-224">Nie potrzebujesz gwarancji KWAŚNych.</span><span class="sxs-lookup"><span data-stu-id="a614f-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="a614f-225">Zostanie wdrożony na sprzęcie z asortymentami.</span><span class="sxs-lookup"><span data-stu-id="a614f-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="a614f-226">Następnie należy wziąć pod uwagę relacyjną bazę danych, gdy:</span><span class="sxs-lookup"><span data-stu-id="a614f-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="a614f-227">Twoje obciążenia wymagają średniego na dużą skalę.</span><span class="sxs-lookup"><span data-stu-id="a614f-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="a614f-228">Współbieżność nie jest istotna.</span><span class="sxs-lookup"><span data-stu-id="a614f-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="a614f-229">Są konieczne gwarancje KWAŚNe.</span><span class="sxs-lookup"><span data-stu-id="a614f-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="a614f-230">Dane są najlepiej wyrażone w sposób relacyjny.</span><span class="sxs-lookup"><span data-stu-id="a614f-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="a614f-231">Aplikacja zostanie wdrożona na dużym sprzęcie.</span><span class="sxs-lookup"><span data-stu-id="a614f-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="a614f-232">Następnie zapoznaj się z magazynem danych w chmurze platformy Azure.</span><span class="sxs-lookup"><span data-stu-id="a614f-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a614f-233">[Poprzedni](distributed-data.md)
>[Następny](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="a614f-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
