---
title: Baza danych na mikrousługę
description: Kontrast przechowywania danych w aplikacjach monolitycznych i natywnych dla chmury.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141448"
---
# <a name="database-per-microservice"></a><span data-ttu-id="b34c1-103">Baza danych na mikrousługę</span><span class="sxs-lookup"><span data-stu-id="b34c1-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="b34c1-104">Jak widzieliśmy w całej tej książce, podejście natywne dla chmury zmienia sposób projektowania, wdrażania i zarządzania aplikacjami.</span><span class="sxs-lookup"><span data-stu-id="b34c1-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="b34c1-105">Zmienia również sposób zarządzania i przechowywania danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="b34c1-106">Rysunek 5-1 kontrastuje różnice.</span><span class="sxs-lookup"><span data-stu-id="b34c1-106">Figure 5-1 contrasts the differences.</span></span>

![Przechowywanie danych w aplikacjach natywnych dla chmury](./media/distributed-data.png)

<span data-ttu-id="b34c1-108">**Rysunek 5-1**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-108">**Figure 5-1**.</span></span> <span data-ttu-id="b34c1-109">Zarządzanie danymi w aplikacjach natywnych dla chmury</span><span class="sxs-lookup"><span data-stu-id="b34c1-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="b34c1-110">Doświadczeni deweloperzy z łatwością rozpoznają architekturę po lewej stronie rysunku 5-1.</span><span class="sxs-lookup"><span data-stu-id="b34c1-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="b34c1-111">W tej *aplikacji monolityczne*, składniki usługi biznesowej kolokacji razem w warstwie usług udostępnionych, udostępnianie danych z jednej relcyjnej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="b34c1-112">Na wiele sposobów pojedyncza baza danych ułatwia zarządzanie danymi.</span><span class="sxs-lookup"><span data-stu-id="b34c1-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="b34c1-113">Wykonywanie zapytań dotyczących danych w wielu tabelach jest proste.</span><span class="sxs-lookup"><span data-stu-id="b34c1-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="b34c1-114">Zmiany w aktualizacji danych razem lub wszystkie one wycofać.</span><span class="sxs-lookup"><span data-stu-id="b34c1-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="b34c1-115">[Transakcje ACID](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) gwarantują silną i natychmiastową spójność.</span><span class="sxs-lookup"><span data-stu-id="b34c1-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="b34c1-116">Projektowanie dla chmury rodzimych, mamy inne podejście.</span><span class="sxs-lookup"><span data-stu-id="b34c1-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="b34c1-117">Po prawej stronie rysunku 5-1 należy zwrócić uwagę na sposób, w jaki funkcje biznesowe są segregowane w małe, niezależne mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="b34c1-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="b34c1-118">Każda mikrousługa hermetyzuje określone możliwości biznesowe i własne dane.</span><span class="sxs-lookup"><span data-stu-id="b34c1-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="b34c1-119">Monolityczne bazy danych rozkłada się w modelu rozproszonych danych z wielu mniejszych baz danych, każdy dostosowanie do mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="b34c1-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="b34c1-120">Gdy dym czyści, wyłaniamy się z projektem, który udostępnia *bazy danych na mikrousługi*.</span><span class="sxs-lookup"><span data-stu-id="b34c1-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="b34c1-121">Dlaczego?</span><span class="sxs-lookup"><span data-stu-id="b34c1-121">Why?</span></span>

<span data-ttu-id="b34c1-122">Ta baza danych na mikrousługi zapewnia wiele korzyści, szczególnie w przypadku systemów, które muszą szybko ewoluować i obsługiwać dużą skalę.</span><span class="sxs-lookup"><span data-stu-id="b34c1-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="b34c1-123">Z tym modelem...</span><span class="sxs-lookup"><span data-stu-id="b34c1-123">With this model...</span></span>

- <span data-ttu-id="b34c1-124">Dane domeny są hermetyzowane w ramach usługi</span><span class="sxs-lookup"><span data-stu-id="b34c1-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="b34c1-125">Schemat danych może ewoluować bez bezpośredniego wpływu na inne usługi</span><span class="sxs-lookup"><span data-stu-id="b34c1-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="b34c1-126">Każdy magazyn danych może niezależnie skalować</span><span class="sxs-lookup"><span data-stu-id="b34c1-126">Each data store can independently scale</span></span>
- <span data-ttu-id="b34c1-127">Awaria magazynu danych w jednej usłudze nie wpłynie bezpośrednio na inne usługi</span><span class="sxs-lookup"><span data-stu-id="b34c1-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="b34c1-128">Segregowanie danych umożliwia również każdej mikrousługi do zaimplementowania typu magazynu danych, który jest najlepiej zoptymalizowany pod kątem jego obciążenia, potrzeb magazynu i odczytu/zapisu wzorców.</span><span class="sxs-lookup"><span data-stu-id="b34c1-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="b34c1-129">Dostępne opcje obejmują relacyjne, dokumentowe, kluczowe, a nawet oparte na wykresie magazyny danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="b34c1-130">Rysunek 5-2 przedstawia zasadę trwałości polyglot w systemie natywnym dla chmury.</span><span class="sxs-lookup"><span data-stu-id="b34c1-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Trwałość danych polyglot](./media/polyglot-data-persistence.png)

<span data-ttu-id="b34c1-132">**Rysunek 5-2**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-132">**Figure 5-2**.</span></span> <span data-ttu-id="b34c1-133">Trwałość danych polyglot</span><span class="sxs-lookup"><span data-stu-id="b34c1-133">Polyglot data persistence</span></span>

<span data-ttu-id="b34c1-134">Uwaga na poprzednim rysunku, jak każda mikrousługa obsługuje inny typ magazynu danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="b34c1-135">Mikrousługi katalogu produktów zużywa relacyjnej bazy danych, aby pomieścić bogatą strukturę relacyjnej danych źródłowych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="b34c1-136">Mikrousługi koszyka zakupów zużywa rozproszonej pamięci podręcznej, która obsługuje jego prosty magazyn danych o wartości klucza.</span><span class="sxs-lookup"><span data-stu-id="b34c1-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="b34c1-137">Mikrousługi zamawiania używa zarówno bazy danych dokumentów NoSql dla operacji zapisu wraz z magazynu kluczy/wartości wysoce nieznormalizowane, aby pomieścić duże ilości operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="b34c1-138">Podczas gdy relacyjne bazy danych pozostają istotne dla mikrousług ze złożonymi danymi, bazy danych NoSQL zyskały znaczną popularność.</span><span class="sxs-lookup"><span data-stu-id="b34c1-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="b34c1-139">Zapewniają one ogromną skalę i wysoką dostępność.</span><span class="sxs-lookup"><span data-stu-id="b34c1-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="b34c1-140">Ich charakter bez schematu umożliwia deweloperom odejście od architektury typowane klasy danych i ORM, które sprawiają, że zmiany kosztowne i czasochłonne.</span><span class="sxs-lookup"><span data-stu-id="b34c1-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="b34c1-141">Omówimy bazy danych NoSQL w dalszej części tego rozdziału.</span><span class="sxs-lookup"><span data-stu-id="b34c1-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="b34c1-142">Hermetyzując dane w oddzielnych mikrousług może zwiększyć elastyczność, wydajność i skalowalność, również przedstawia wiele wyzwań.</span><span class="sxs-lookup"><span data-stu-id="b34c1-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="b34c1-143">W następnej części omawiamy te wyzwania wraz ze wzorcami i praktykami, które pomogą je przezwyciężyć.</span><span class="sxs-lookup"><span data-stu-id="b34c1-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="b34c1-144">Zapytania między usługami</span><span class="sxs-lookup"><span data-stu-id="b34c1-144">Cross-service queries</span></span>

<span data-ttu-id="b34c1-145">Mikrousługi są niezależne i koncentrują się na określonych możliwościach funkcjonalnych, takich jak spis, wysyłka lub zamawianie, często wymagają integracji z innymi mikrousługami.</span><span class="sxs-lookup"><span data-stu-id="b34c1-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="b34c1-146">Często integracja obejmuje jedną mikrousługę *wykonywania zapytań* innej dla danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="b34c1-147">Rysunek 5-3 przedstawia scenariusz.</span><span class="sxs-lookup"><span data-stu-id="b34c1-147">Figure 5-3 shows the scenario.</span></span>

![Wykonywanie zapytań w mikrousługach](./media/cross-service-query.png)

<span data-ttu-id="b34c1-149">**Rysunek 5-3**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-149">**Figure 5-3**.</span></span> <span data-ttu-id="b34c1-150">Wykonywanie zapytań w mikrousługach</span><span class="sxs-lookup"><span data-stu-id="b34c1-150">Querying across microservices</span></span>

<span data-ttu-id="b34c1-151">Na powyższym rysunku widzimy mikrousługi koszyka zakupów, który dodaje element do koszyka zakupów użytkownika.</span><span class="sxs-lookup"><span data-stu-id="b34c1-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="b34c1-152">Magazyn danych dla tej mikrousługi zawiera dane koszyka i elementu zamówienia, ale nie przechowuje danych o produktach ani cenach.</span><span class="sxs-lookup"><span data-stu-id="b34c1-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="b34c1-153">Zamiast tego te elementy danych są własnością mikrousług katalogu i cen.</span><span class="sxs-lookup"><span data-stu-id="b34c1-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="b34c1-154">Stanowi to problem.</span><span class="sxs-lookup"><span data-stu-id="b34c1-154">This presents a problem.</span></span> <span data-ttu-id="b34c1-155">W jaki sposób mikrousługa koszyka zakupów może dodać produkt do koszyka zakupów użytkownika, gdy nie ma produktu ani danych cenowych w swojej bazie danych?</span><span class="sxs-lookup"><span data-stu-id="b34c1-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="b34c1-156">Jedną z opcji omówionych w rozdziale 4 jest [bezpośrednie wywołanie HTTP](service-to-service-communication.md#queries) z koszyka do mikrousług katalogu i cen.</span><span class="sxs-lookup"><span data-stu-id="b34c1-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="b34c1-157">Jednak w rozdziale 4 powiedzieliśmy synchroniczne HTTP wywołuje *kilka* mikrousług razem, zmniejszając ich autonomię i zmniejszając ich korzyści architektoniczne.</span><span class="sxs-lookup"><span data-stu-id="b34c1-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="b34c1-158">Możemy również zaimplementować wzorzec żądania i odpowiedzi z oddzielnymi kolejkami przychodzącymi i wychodzącymi dla każdej usługi.</span><span class="sxs-lookup"><span data-stu-id="b34c1-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="b34c1-159">Jednak ten wzorzec jest skomplikowane i wymaga hydraulika skorelować żądania i odpowiedzi wiadomości.</span><span class="sxs-lookup"><span data-stu-id="b34c1-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="b34c1-160">Podczas gdy nie rozłączyć wywołania mikrousługi zaplecza, usługa wywołująca musi nadal synchronicznie czekać na zakończenie wywołania.</span><span class="sxs-lookup"><span data-stu-id="b34c1-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="b34c1-161">Przeciążenie sieci, błędy przejściowe lub przeciążenie mikrousługi i może spowodować długotrwałe, a nawet nie powiodło się operacje.</span><span class="sxs-lookup"><span data-stu-id="b34c1-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="b34c1-162">Zamiast tego powszechnie akceptowanym wzorcem do usuwania zależności między usługami jest [zmaterializowany wzorzec widoku,](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)pokazany na rysunku 5-4.</span><span class="sxs-lookup"><span data-stu-id="b34c1-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Zmaterializowany wzór widoku](./media/materialized-view-pattern.png)

<span data-ttu-id="b34c1-164">**Rysunek 5-4**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-164">**Figure 5-4**.</span></span> <span data-ttu-id="b34c1-165">Zmaterializowany wzór widoku</span><span class="sxs-lookup"><span data-stu-id="b34c1-165">Materialized View Pattern</span></span>

<span data-ttu-id="b34c1-166">Za pomocą tego wzorca umieszczasię tabelę danych lokalnych (znaną jako *model odczytu)* w usłudze koszyka zakupów.</span><span class="sxs-lookup"><span data-stu-id="b34c1-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="b34c1-167">Ta tabela zawiera nieznormalizowaną kopię danych potrzebnych z mikrousług produktu i cen.</span><span class="sxs-lookup"><span data-stu-id="b34c1-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="b34c1-168">Kopiowanie danych bezpośrednio do mikrousługi koszyka zakupów eliminuje konieczność kosztownych wywołań między usługami.</span><span class="sxs-lookup"><span data-stu-id="b34c1-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="b34c1-169">Dzięki danym lokalnym do usługi, można poprawić czas reakcji usługi i niezawodność.</span><span class="sxs-lookup"><span data-stu-id="b34c1-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="b34c1-170">Ponadto posiadanie własnej kopii danych sprawia, że usługa koszyka jest bardziej odporna.</span><span class="sxs-lookup"><span data-stu-id="b34c1-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="b34c1-171">Jeśli usługa katalogu powinna stać się niedostępna, nie wpłynie bezpośrednio na usługę koszyka.</span><span class="sxs-lookup"><span data-stu-id="b34c1-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="b34c1-172">Koszyk może kontynuować działanie z danymi z własnego sklepu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="b34c1-173">Haczyk z tego podejścia jest to, że masz teraz zduplikowane dane w systemie.</span><span class="sxs-lookup"><span data-stu-id="b34c1-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="b34c1-174">Jednak *strategicznie* duplikowanie danych w systemach natywnych dla chmury jest utrwaloną praktyką i nie jest uważane za anty-wzorzec lub złe praktyki.</span><span class="sxs-lookup"><span data-stu-id="b34c1-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="b34c1-175">Należy pamiętać, że *jedna i tylko jedna usługa* może posiadać zestaw danych i mieć nad nim uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="b34c1-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="b34c1-176">Po zaktualizowaniu systemu rekordów należy zsynchronizować modele odczytu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="b34c1-177">Synchronizacja jest zazwyczaj implementowana za pośrednictwem wiadomości asynchronicznych z [wzorcem publikowania/subskrybowania,](service-to-service-communication.md#events)jak pokazano na rysunku 5.4.</span><span class="sxs-lookup"><span data-stu-id="b34c1-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="b34c1-178">Transakcje rozproszone</span><span class="sxs-lookup"><span data-stu-id="b34c1-178">Distributed transactions</span></span>

<span data-ttu-id="b34c1-179">Podczas wykonywania zapytań danych w mikrousługach jest trudne, implementowanie transakcji w kilku mikrousług jest jeszcze bardziej złożone.</span><span class="sxs-lookup"><span data-stu-id="b34c1-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="b34c1-180">Nieodłączne wyzwanie zachowania spójności danych w niezależnych źródłach danych w różnych mikrousług nie można zaniżać.</span><span class="sxs-lookup"><span data-stu-id="b34c1-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="b34c1-181">Brak transakcji rozproszonych w aplikacjach natywnych dla chmury oznacza, że należy programowo zarządzać transakcjami rozproszonymi.</span><span class="sxs-lookup"><span data-stu-id="b34c1-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="b34c1-182">Przechodzisz ze świata *natychmiastowej spójności* do *ostatecznej spójności.*</span><span class="sxs-lookup"><span data-stu-id="b34c1-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="b34c1-183">Rysunek 5-5 pokazuje problem.</span><span class="sxs-lookup"><span data-stu-id="b34c1-183">Figure 5-5 shows the problem.</span></span>

![Transakcja w strukturze sagi](./media/saga-transaction-operation.png)

<span data-ttu-id="b34c1-185">**Rysunek 5-5**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-185">**Figure 5-5**.</span></span> <span data-ttu-id="b34c1-186">Implementowanie transakcji w mikrousługach</span><span class="sxs-lookup"><span data-stu-id="b34c1-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="b34c1-187">Na powyższym rysunku pięć niezależnych mikrousług uczestniczyć w transakcji rozproszonej, która tworzy zamówienie.</span><span class="sxs-lookup"><span data-stu-id="b34c1-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="b34c1-188">Każda mikrousługa utrzymuje własny magazyn danych i implementuje transakcję lokalną dla swojego magazynu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="b34c1-189">Aby utworzyć zamówienie, transakcja lokalna dla *każdej* mikrousługi poszczególnych musi się powieść lub *wszystkie* muszą przerwać i wycofać operację.</span><span class="sxs-lookup"><span data-stu-id="b34c1-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="b34c1-190">Podczas gdy wbudowana obsługa transakcyjna jest dostępna wewnątrz każdej mikrousługi, nie ma żadnej obsługi transakcji rozproszonej, która będzie się rozciągać we wszystkich pięciu usługach, aby zachować spójność danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="b34c1-191">Zamiast tego należy skonstruować tę transakcję rozproszoną *programowo*.</span><span class="sxs-lookup"><span data-stu-id="b34c1-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="b34c1-192">Popularnym wzorcem dodawania rozproszonej obsługi transakcyjnej jest wzór Saga.</span><span class="sxs-lookup"><span data-stu-id="b34c1-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="b34c1-193">Jest implementowana przez grupowanie transakcji lokalnych razem programowo i sekwencyjnie wywołując każdy z nich.</span><span class="sxs-lookup"><span data-stu-id="b34c1-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="b34c1-194">Jeśli którakolwiek z transakcji lokalnych nie powiedzie się, Saga przerywa operację i wywołuje zestaw [transakcji kompensacyjnych](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span><span class="sxs-lookup"><span data-stu-id="b34c1-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="b34c1-195">Transakcje kompensacyjne cofają zmiany wprowadzone przez poprzednie transakcje lokalne i przywracają spójność danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="b34c1-196">Rysunek 5-6 przedstawia nieudaną transakcję ze wzorem Saga.</span><span class="sxs-lookup"><span data-stu-id="b34c1-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Wycofaj się w sagę wzór](./media/saga-rollback-operation.png)

<span data-ttu-id="b34c1-198">**Rysunek 5-6**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-198">**Figure 5-6**.</span></span> <span data-ttu-id="b34c1-199">Wycofywanie transakcji</span><span class="sxs-lookup"><span data-stu-id="b34c1-199">Rolling back a transaction</span></span>

<span data-ttu-id="b34c1-200">Na poprzedniej rysunku *operacja Aktualizuj spis* uchylić się w mikrousługi zapasów.</span><span class="sxs-lookup"><span data-stu-id="b34c1-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="b34c1-201">Saga wywołuje zestaw transakcji kompensacyjnych (na czerwono), aby dostosować liczbę zapasów, anulować płatności i zamówienia i zwrócić dane dla każdej mikrousługi z powrotem do stanu spójnego.</span><span class="sxs-lookup"><span data-stu-id="b34c1-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="b34c1-202">Wzorce sagi są zazwyczaj choreografia jako seria powiązanych wydarzeń lub zaaranżowane jako zestaw powiązanych poleceń.</span><span class="sxs-lookup"><span data-stu-id="b34c1-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="b34c1-203">W rozdziale 4 omówiliśmy wzorzec agregatora usług, który byłby podstawą zaaranżowanej implementacji sagi.</span><span class="sxs-lookup"><span data-stu-id="b34c1-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="b34c1-204">Omówiliśmy również eventing wraz z usługi Azure Service Bus i azure event grid tematów, które będą podstawą dla implementacji sagi choreografia.</span><span class="sxs-lookup"><span data-stu-id="b34c1-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="b34c1-205">Dane o dużej objętości</span><span class="sxs-lookup"><span data-stu-id="b34c1-205">High volume data</span></span>

<span data-ttu-id="b34c1-206">Duże aplikacje natywne dla chmury często obsługują wymagania dotyczące danych o dużej objętości.</span><span class="sxs-lookup"><span data-stu-id="b34c1-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="b34c1-207">W tych scenariuszach tradycyjne techniki przechowywania danych może spowodować wąskie gardła.</span><span class="sxs-lookup"><span data-stu-id="b34c1-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="b34c1-208">W przypadku złożonych systemów wdrażanych na dużą skalę zarówno segregacja odpowiedzialności za polecenia, jak i kwerendy (CQRS) i pozyskiwanie zdarzeń może zwiększyć wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b34c1-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="b34c1-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="b34c1-209">CQRS</span></span>

<span data-ttu-id="b34c1-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), to wzorzec architektoniczny, który może pomóc zmaksymalizować wydajność, skalowalność i zabezpieczenia.</span><span class="sxs-lookup"><span data-stu-id="b34c1-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="b34c1-211">Wzorzec oddziela operacje, które odczytują dane z tych operacji, które zapisują dane.</span><span class="sxs-lookup"><span data-stu-id="b34c1-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="b34c1-212">W przypadku normalnych scenariuszy ten sam model jednostki i obiekt repozytorium danych są używane zarówno dla operacji odczytu, *jak* i zapisu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="b34c1-213">Jednak scenariusz danych o dużej objętości może korzystać z oddzielnych modeli i tabel danych dla odczytów i zapisów.</span><span class="sxs-lookup"><span data-stu-id="b34c1-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="b34c1-214">Aby zwiększyć wydajność, operacja odczytu może kwerendy przeciwko wysoce nieznormalizowane reprezentacji danych, aby uniknąć kosztownych powtarzających się sprzężeń tabeli i blokad tabeli.</span><span class="sxs-lookup"><span data-stu-id="b34c1-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="b34c1-215">Operacja *zapisu,* znana jako *polecenie,* będzie aktualizowana względem w pełni znormalizowanej reprezentacji danych, która gwarantowałaby spójność.</span><span class="sxs-lookup"><span data-stu-id="b34c1-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="b34c1-216">Następnie należy zaimplementować mechanizm, aby zachować obie reprezentacje w synchronizacji. Zazwyczaj za każdym razem, gdy tabela zapisu jest modyfikowany, publikuje zdarzenie, które replikuje modyfikacji do tabeli odczytu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="b34c1-217">Rysunek 5-7 przedstawia implementację wzorca CQRS.</span><span class="sxs-lookup"><span data-stu-id="b34c1-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![Segregacja odpowiedzialności za polecenia i kwerendy](./media/cqrs-implementation.png)

<span data-ttu-id="b34c1-219">**Rysunek 5-7**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-219">**Figure 5-7**.</span></span> <span data-ttu-id="b34c1-220">Wdrożenie CQRS</span><span class="sxs-lookup"><span data-stu-id="b34c1-220">CQRS implementation</span></span>

<span data-ttu-id="b34c1-221">Na poprzedniej rysunku zaimplementowano oddzielne modele poleceń i zapytań.</span><span class="sxs-lookup"><span data-stu-id="b34c1-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="b34c1-222">Każda operacja zapisu danych jest zapisywana w magazynie zapisu, a następnie propagowana do magazynu odczytu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="b34c1-223">Należy zwrócić szczególną uwagę na to, jak proces propagacji danych działa na zasadzie [spójności ostatecznej](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span><span class="sxs-lookup"><span data-stu-id="b34c1-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="b34c1-224">Model odczytu ostatecznie synchronizuje się z modelem zapisu, ale może występować pewne opóźnienia w procesie.</span><span class="sxs-lookup"><span data-stu-id="b34c1-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="b34c1-225">Omówimy spójność ostateczną w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="b34c1-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="b34c1-226">Ta separacja umożliwia odczyty i zapisy do skalowania niezależnie.</span><span class="sxs-lookup"><span data-stu-id="b34c1-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="b34c1-227">Operacje odczytu używają schematu zoptymalizowanego pod kątem kwerend, podczas gdy zapisy używają schematu zoptymalizowanego pod kątem aktualizacji.</span><span class="sxs-lookup"><span data-stu-id="b34c1-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="b34c1-228">Kwerendy odczytu są sprzeczne z danymi nieznormalizowanych, podczas gdy złożona logika biznesowa może być stosowana do modelu zapisu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="b34c1-229">Jak również można nałożyć ściślejsze zabezpieczenia na operacje zapisu niż te narażające odczyty.</span><span class="sxs-lookup"><span data-stu-id="b34c1-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="b34c1-230">Implementowanie CQRS może zwiększyć wydajność aplikacji dla usług natywnych dla chmury.</span><span class="sxs-lookup"><span data-stu-id="b34c1-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="b34c1-231">Jednak powoduje to bardziej złożony projekt.</span><span class="sxs-lookup"><span data-stu-id="b34c1-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="b34c1-232">Zastosuj tę zasadę ostrożnie i strategicznie do tych sekcji aplikacji natywnej dla chmury, które będą z niej korzystać.</span><span class="sxs-lookup"><span data-stu-id="b34c1-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="b34c1-233">Aby uzyskać więcej informacji na temat CQRS, zobacz książkę Microsoft [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span><span class="sxs-lookup"><span data-stu-id="b34c1-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="b34c1-234">Pozyskiwanie zdarzeń</span><span class="sxs-lookup"><span data-stu-id="b34c1-234">Event sourcing</span></span>

<span data-ttu-id="b34c1-235">Inne podejście do optymalizacji scenariuszy danych o dużej objętości obejmuje [pozyskiwanie zdarzeń.](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)</span><span class="sxs-lookup"><span data-stu-id="b34c1-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="b34c1-236">System zazwyczaj przechowuje bieżący stan jednostki danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="b34c1-237">Jeśli użytkownik zmieni swój numer telefonu, na przykład rekord klienta zostanie zaktualizowany o nowy numer.</span><span class="sxs-lookup"><span data-stu-id="b34c1-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="b34c1-238">Zawsze znamy bieżący stan jednostki danych, ale każda aktualizacja zastępuje poprzedni stan.</span><span class="sxs-lookup"><span data-stu-id="b34c1-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="b34c1-239">W większości przypadków ten model działa dobrze.</span><span class="sxs-lookup"><span data-stu-id="b34c1-239">In most cases, this model works fine.</span></span> <span data-ttu-id="b34c1-240">Jednak w systemach o dużej objętości obciążenie wynikające z operacji blokowania transakcyjnego i częstych aktualizacji może mieć wpływ na wydajność bazy danych, czas reakcji i skalowalność ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="b34c1-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="b34c1-241">Pozyskiwanie zdarzeń ma inne podejście do przechwytywania danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="b34c1-242">Każda operacja, która wpływa na dane jest utrwaliony do magazynu zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="b34c1-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="b34c1-243">Zamiast aktualizować stan rekordu danych, dołączamy każdą zmianę do sekwencyjnej listy przeszłych zdarzeń - podobnie jak w księdze księgowej.</span><span class="sxs-lookup"><span data-stu-id="b34c1-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="b34c1-244">Magazyn zdarzeń staje się systemem rekordów danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="b34c1-245">Jest on używany do propagowania różnych zmaterializowanych widoków w kontekście ograniczone mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="b34c1-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="b34c1-246">Rysunek 5.8 przedstawia wzór.</span><span class="sxs-lookup"><span data-stu-id="b34c1-246">Figure 5.8 shows the pattern.</span></span>

![Określanie źródła zdarzeń](./media/event-sourcing.png)

<span data-ttu-id="b34c1-248">**Rysunek 5-8**.</span><span class="sxs-lookup"><span data-stu-id="b34c1-248">**Figure 5-8**.</span></span> <span data-ttu-id="b34c1-249">Określanie źródła zdarzeń</span><span class="sxs-lookup"><span data-stu-id="b34c1-249">Event Sourcing</span></span>

<span data-ttu-id="b34c1-250">Na poprzednim rysunku należy zwrócić uwagę na to, jak każdy wpis (na niebiesko) koszyka użytkownika jest dołączany do bazowego magazynu zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="b34c1-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="b34c1-251">W sąsiednim widoku zmaterializowanym system wyświetla bieżący stan, odtwarzając wszystkie zdarzenia skojarzone z każdym koszykiem.</span><span class="sxs-lookup"><span data-stu-id="b34c1-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="b34c1-252">Ten widok lub model odczytu jest następnie udostępniane z powrotem do interfejsu interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="b34c1-253">Zdarzenia mogą być również zintegrowane z zewnętrznymi systemami i aplikacjami lub badane w celu określenia bieżącego stanu jednostki.</span><span class="sxs-lookup"><span data-stu-id="b34c1-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="b34c1-254">Dzięki takiemu podejściu zachowujesz historię.</span><span class="sxs-lookup"><span data-stu-id="b34c1-254">With this approach, you maintain history.</span></span> <span data-ttu-id="b34c1-255">Wiesz nie tylko bieżący stan jednostki, ale także sposób osiągnięcia tego stanu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="b34c1-256">Mechanicznie rzecz biorąc, pozyskiwanie zdarzeń upraszcza model zapisu.</span><span class="sxs-lookup"><span data-stu-id="b34c1-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="b34c1-257">Nie ma żadnych aktualizacji ani usuwania.</span><span class="sxs-lookup"><span data-stu-id="b34c1-257">There are no updates or deletes.</span></span> <span data-ttu-id="b34c1-258">Dołączanie każdego wpisu danych jako zdarzenia niezmiennego minimalizuje konflikty rywalizacji, blokowania i współbieżności skojarzone z relacyjnymi bazami danych.</span><span class="sxs-lookup"><span data-stu-id="b34c1-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="b34c1-259">Tworzenie modeli odczytu ze zmaterializowanym wzorcem widoku umożliwia oddzielenie widoku od modelu zapisu i wybranie najlepszego magazynu danych w celu optymalizacji potrzeb interfejsu użytkownika aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b34c1-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="b34c1-260">Dla tego wzorca należy wziąć pod uwagę magazyn danych, który bezpośrednio obsługuje pozyskiwanie zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="b34c1-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="b34c1-261">Dobrymi kandydatami są usługi Azure Cosmos DB, MongoDB, Cassandra, CouchDB i RavenDB.</span><span class="sxs-lookup"><span data-stu-id="b34c1-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="b34c1-262">Podobnie jak w przypadku wszystkich wzorców i technologii, wdrażaj strategicznie i w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="b34c1-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="b34c1-263">Pozyskiwanie zdarzeń może zapewnić zwiększoną wydajność i skalowalność, ale kosztem złożoności i krzywej uczenia się.</span><span class="sxs-lookup"><span data-stu-id="b34c1-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="b34c1-264">[Poprzedni](service-mesh-communication-infrastructure.md)
>[następny](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="b34c1-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
