---
title: Kroki przepływu pracy DevOps w zewnętrznej pętli dla aplikacji platformy Docker
description: Zapoznaj się z instrukcjami "zewnętrznej pętli" przepływu pracy DevOps
ms.date: 02/15/2019
ms.openlocfilehash: 44bd73bf88a743e5350e422d3ea000ca075f7383
ms.sourcegitcommit: 465547886a1224a5435c3ac349c805e39ce77706
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/21/2020
ms.locfileid: "82021299"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="bb96e-103">Kroki przepływu pracy DevOps w zewnętrznej pętli dla aplikacji platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="bb96e-104">Rysunek 5-1 przedstawia end-to-end obraz kroków składających devops przepływu pracy pętli zewnętrznej.</span><span class="sxs-lookup"><span data-stu-id="bb96e-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="bb96e-105">Pokazuje "zewnętrzną pętlę" DevOps.</span><span class="sxs-lookup"><span data-stu-id="bb96e-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="bb96e-106">Gdy kod jest wypychany do repozytorium, potok ciągłej integracji jest uruchamiany, a następnie rozpoczyna potok dysku CD, w którym zostanie wdrożona aplikacja.</span><span class="sxs-lookup"><span data-stu-id="bb96e-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="bb96e-107">Metryki zebrane z wdrożonych aplikacji są przekazywane z powrotem do obciążenia programistycznego, gdzie występuje "wewnętrzna pętla", więc zespoły programistyczne mają rzeczywiste dane, aby odpowiedzieć na potrzeby użytkowników i firm.</span><span class="sxs-lookup"><span data-stu-id="bb96e-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![Diagram przedstawiający 6 kroków przepływu pracy pętli zewnętrznej DevOps.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="bb96e-109">**Rysunek 5-1**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-109">**Figure 5-1**.</span></span> <span data-ttu-id="bb96e-110">Przepływ pracy pętli zewnętrznej DevOps dla aplikacji platformy Docker za pomocą narzędzi firmy Microsoft</span><span class="sxs-lookup"><span data-stu-id="bb96e-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="bb96e-111">Teraz przyjrzyjmy się każdej z tych kroków bardziej szczegółowo.</span><span class="sxs-lookup"><span data-stu-id="bb96e-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="bb96e-112">Krok 1: Przepływ pracy tworzenia pętli wewnętrznej</span><span class="sxs-lookup"><span data-stu-id="bb96e-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="bb96e-113">Ten krok jest szczegółowo wyjaśnione w rozdziale 4, ale, podsumowując, tutaj jest, gdzie rozpoczyna się zewnętrzna pętla, w momencie, w którym deweloper wypycha kod do systemu zarządzania kontrolą źródła (jak Git) inicjowania akcji potoku ciągłej.</span><span class="sxs-lookup"><span data-stu-id="bb96e-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="bb96e-114">Krok 2: Integracja i zarządzanie kontrolą kodu źródłowego za pomocą usług DevOps Azure i git</span><span class="sxs-lookup"><span data-stu-id="bb96e-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="bb96e-115">W tym kroku musisz mieć system kontroli wersji, aby zebrać skonsolidowaną wersję całego kodu pochodzącego od różnych deweloperów w zespole.</span><span class="sxs-lookup"><span data-stu-id="bb96e-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="bb96e-116">Mimo że kontrola kodu źródłowego (SCC) i zarządzanie kodem źródłowym może wydawać się drugorzędne dla większości deweloperów, podczas tworzenia aplikacji platformy Docker w cyklu życia DevOps, ważne jest, aby podkreślić, że nie należy przesyłać obrazów platformy Docker z aplikacją bezpośrednio do globalnego rejestru platformy Docker (takich jak Azure Container Registry lub Docker Hub) z komputera dewelopera.</span><span class="sxs-lookup"><span data-stu-id="bb96e-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="bb96e-117">Wręcz przeciwnie obrazy platformy Docker, które mają zostać wydane i wdrożone w środowiskach produkcyjnych, muszą być tworzone wyłącznie na kodzie źródłowym, który jest zintegrowany z globalną kompilacją lub potokiem ciągłej integracji na podstawie repozytorium kodu źródłowego (takiego jak Git).</span><span class="sxs-lookup"><span data-stu-id="bb96e-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="bb96e-118">Obrazy lokalne, generowane przez deweloperów, powinny być używane przez nich podczas testowania w ramach własnych maszyn.</span><span class="sxs-lookup"><span data-stu-id="bb96e-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="bb96e-119">Dlatego bardzo ważne jest, aby potok DevOps był aktywowany z kodu SCC.</span><span class="sxs-lookup"><span data-stu-id="bb96e-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="bb96e-120">Usługi Azure DevOps i serwer Team Foundation obsługują kontrolę wersji git i team foundation.</span><span class="sxs-lookup"><span data-stu-id="bb96e-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="bb96e-121">Można wybrać między nimi i używać go do kompleksowego środowiska firmy Microsoft.</span><span class="sxs-lookup"><span data-stu-id="bb96e-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="bb96e-122">Można jednak również zarządzać kodem w zewnętrznych repozytoriach (takich jak GitHub, lokalne repozytoria Git lub Subversion) i nadal można się z nim połączyć i uzyskać kod jako punkt wyjścia dla potoku ciągłej ewidencji DevOps.</span><span class="sxs-lookup"><span data-stu-id="bb96e-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="bb96e-123">Krok 3: Tworzenie, ci, integracja i testowanie za pomocą usług Azure DevOps i platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="bb96e-124">Ci stał się standardem dla nowoczesnych testów oprogramowania i dostarczania.</span><span class="sxs-lookup"><span data-stu-id="bb96e-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="bb96e-125">Rozwiązanie platformy Docker utrzymuje wyraźny rozdzielenie problemów między zespołami deweloperów i operacji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="bb96e-126">Niezmienność obrazów platformy Docker zapewnia powtarzalne wdrożenie między tym, co jest opracowane, przetestowane za pośrednictwem ciągłej integracji i uruchamiane w produkcji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="bb96e-127">Aparat platformy Docker wdrożony w komputerach przenośnych deweloperów i infrastruktury testowej sprawia, że kontenery są przenośne w różnych środowiskach.</span><span class="sxs-lookup"><span data-stu-id="bb96e-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="bb96e-128">W tym momencie po systemie kontroli wersji z poprawnym kodem przesłane, trzeba *usługi kompilacji,* aby odebrać kod i uruchomić globalnej kompilacji i testów.</span><span class="sxs-lookup"><span data-stu-id="bb96e-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="bb96e-129">Wewnętrzny przepływ pracy dla tego kroku (CI, kompilacja, test) dotyczy budowy potoku ciągłej integracji składającego się z repozytorium kodu (Git itp.), serwera kompilacji (usługi Azure DevOps), aparatu platformy Docker engine i rejestru platformy Docker.</span><span class="sxs-lookup"><span data-stu-id="bb96e-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="bb96e-130">Usługi Azure DevOps można używać jako podstawy do tworzenia aplikacji i ustawiania potoku ciągłej integracji oraz publikowania wbudowanych "artefaktów" w "repozytorium artefaktów", co wyjaśniono w następnym kroku.</span><span class="sxs-lookup"><span data-stu-id="bb96e-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="bb96e-131">Podczas korzystania z platformy Docker do wdrożenia, "ostateczne artefakty", które mają zostać wdrożone są obrazy platformy Docker z aplikacji lub usług osadzonych w nich.</span><span class="sxs-lookup"><span data-stu-id="bb96e-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="bb96e-132">Te obrazy są wypychane lub publikowane w rejestrze platformy *Docker* (prywatne repozytorium, takie jak te, które można mieć w usłudze Azure Container Registry lub publiczne, takie jak docker hub registry, który jest powszechnie używany dla oficjalnych obrazów podstawowych).</span><span class="sxs-lookup"><span data-stu-id="bb96e-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="bb96e-133">Oto podstawowa koncepcja: Potok ciągłej integracji zostanie rozpoczęty przez zatwierdzenie do repozytorium SCC, takiego jak Git.</span><span class="sxs-lookup"><span data-stu-id="bb96e-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="bb96e-134">Zatwierdzenie spowoduje, że usługi Azure DevOps Services do uruchomienia zadania kompilacji w kontenerze platformy Docker i po pomyślnym zakończeniu tego zadania wypchnąć obraz platformy Docker do rejestru platformy Docker, jak pokazano na rysunku 5-2.</span><span class="sxs-lookup"><span data-stu-id="bb96e-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="bb96e-135">Pierwsza część pętli zewnętrznej obejmuje kroki 1 do 3, od kodu, uruchom, debugowania i sprawdzania poprawności, a następnie repozytorium kodu do kroku kompilacji i testowania ci.</span><span class="sxs-lookup"><span data-stu-id="bb96e-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![Diagram przedstawiający trzy kroki związane z przepływem pracy ciągłej integracji.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="bb96e-137">**Rysunek 5-2**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-137">**Figure 5-2**.</span></span> <span data-ttu-id="bb96e-138">Kroki związane z ci</span><span class="sxs-lookup"><span data-stu-id="bb96e-138">The steps involved in CI</span></span>

<span data-ttu-id="bb96e-139">Oto podstawowe kroki przepływu pracy w zakresie ciągłej integracji za pomocą usług Docker i Azure DevOps:</span><span class="sxs-lookup"><span data-stu-id="bb96e-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="bb96e-140">Deweloper wypycha zatwierdzenie do repozytorium SCC (Usługi Git/Azure DevOps, GitHub itp.).</span><span class="sxs-lookup"><span data-stu-id="bb96e-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="bb96e-141">Jeśli używasz usługi Azure DevOps services lub Git, ci jest wbudowany, co oznacza, że jest tak proste, jak zaznaczenie pola wyboru w usługach Azure DevOps.</span><span class="sxs-lookup"><span data-stu-id="bb96e-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="bb96e-142">Jeśli używasz zewnętrznego SCC (takiego jak GitHub), a `webhook` powiadomi usługi Azure DevOps o aktualizacji lub wypchniesz do git/GitHub.</span><span class="sxs-lookup"><span data-stu-id="bb96e-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="bb96e-143">Usługi Azure DevOps pobiera repozytorium SCC, w tym Dockerfile opisujące obraz, a także kod aplikacji i testów.</span><span class="sxs-lookup"><span data-stu-id="bb96e-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="bb96e-144">Usługi Azure DevOps tworzy obraz platformy Docker i etykiety go z numerem kompilacji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="bb96e-145">Usługi Azure DevOps services wystąpienia kontenera platformy Docker w ramach aprowizacji hosta platformy Docker i uruchamia odpowiednie testy.</span><span class="sxs-lookup"><span data-stu-id="bb96e-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="bb96e-146">Jeśli testy się powiodą, obraz zostanie najpierw przeliczony do znaczącej nazwy, aby wiedzieć, że jest to "błogosławiona kompilacja" (np. "/1.0.0" lub inna etykieta), a następnie wypchnięty do rejestru platformy Docker (Docker Hub, Azure Container Registry, DTR itp.)</span><span class="sxs-lookup"><span data-stu-id="bb96e-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="bb96e-147">Implementowanie potoku ciągłej integracji za pomocą usług DevOps azure i rozszerzenia platformy Docker dla usług Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="bb96e-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="bb96e-148">Visual Studio Azure DevOps Services zawiera szablony kompilacji & wersji, które można użyć w potoku ciągłej integracji/ciągłego wdrażania, za pomocą którego można tworzyć obrazy platformy Docker, wypychać obrazy platformy Docker do uwierzytelnionego rejestru platformy Docker, uruchamiać obrazy platformy Docker lub uruchamiać inne operacje oferowane przez wiersz polecenia platformy Docker.</span><span class="sxs-lookup"><span data-stu-id="bb96e-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="bb96e-149">Dodaje również zadanie docker compose, którego można użyć do tworzenia, wypychania i uruchamiania aplikacji platformy Docker z wieloma kontenerami lub uruchamiania innych operacji oferowanych przez interfejsu wiersza polecenia docker compose, jak pokazano na rysunku 5-3.</span><span class="sxs-lookup"><span data-stu-id="bb96e-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Zrzut ekranu przedstawiający potok docker CI w usłudze Azure DevOps.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="bb96e-151">**Rysunek 5-3**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-151">**Figure 5-3**.</span></span> <span data-ttu-id="bb96e-152">Potok docker CI w usługach Azure DevOps, w tym tworzenie szablonów & wersji i skojarzonych zadań.</span><span class="sxs-lookup"><span data-stu-id="bb96e-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="bb96e-153">Za pomocą tych szablonów i zadań można tworzyć artefakty ciągłej integracji/ciągłego wdrażania do kompilacji/testowania i wdrażania w usłudze Azure Service Fabric, usłudze Azure Kubernetes i podobnych ofertach.</span><span class="sxs-lookup"><span data-stu-id="bb96e-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="bb96e-154">Dzięki tym zadaniom programu Visual Studio Team Services kompilacja hosta/maszyny wirtualnej linux-docker aprowizowana na platformie Azure i preferowany rejestr platformy Docker (Azure Container Registry, Docker Hub, private Docker DTR lub inny rejestr platformy Docker) można zebrać potoku docker CI w bardzo spójny sposób.</span><span class="sxs-lookup"><span data-stu-id="bb96e-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="bb96e-155">***Wymagania:***</span><span class="sxs-lookup"><span data-stu-id="bb96e-155">***Requirements:***</span></span>

- <span data-ttu-id="bb96e-156">Usługi Azure DevOps lub dla instalacji lokalnych, Team Foundation Server 2015 Update 3 lub nowsze.</span><span class="sxs-lookup"><span data-stu-id="bb96e-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="bb96e-157">Agent usługi Azure DevOps services, który ma pliki binarne platformy Docker.</span><span class="sxs-lookup"><span data-stu-id="bb96e-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="bb96e-158">Łatwym sposobem utworzenia jednego z tych agentów jest użycie platformy Docker do uruchamiania kontenera na podstawie obrazu platformy Docker agenta usługi Azure DevOps.</span><span class="sxs-lookup"><span data-stu-id="bb96e-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [! INFORMACJE]<span data-ttu-id="bb96e-159"> Aby dowiedzieć się więcej na temat składania potoku docker ci usług Deweloperów platformy Azure i wyświetlić wskazówki, odwiedź następujące witryny:</span><span class="sxs-lookup"><span data-stu-id="bb96e-159"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="bb96e-160">Uruchamianie agenta usługi zespołu programu Visual Studio (teraz usługi Azure DevOps) jako kontenera platformy Docker: </span><span class="sxs-lookup"><span data-stu-id="bb96e-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="bb96e-161">Tworzenie obrazów platformy Docker .NET Core Linux za pomocą usług Azure DevOps: </span><span class="sxs-lookup"><span data-stu-id="bb96e-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="bb96e-162">Tworzenie komputera kompilacji usługi Visual Studio z systemem Linux z obsługą platformy Docker: </span><span class="sxs-lookup"><span data-stu-id="bb96e-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="bb96e-163">Integracja, testowanie i sprawdzanie poprawności aplikacji platformy Docker z wieloma kontenerami</span><span class="sxs-lookup"><span data-stu-id="bb96e-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="bb96e-164">Zazwyczaj większość aplikacji platformy Docker składa się z wielu kontenerów, a nie z jednego kontenera.</span><span class="sxs-lookup"><span data-stu-id="bb96e-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="bb96e-165">Dobrym przykładem jest aplikacja zorientowana na mikrousługi, dla której można mieć jeden kontener na mikrousługi.</span><span class="sxs-lookup"><span data-stu-id="bb96e-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="bb96e-166">Ale nawet bez ścisłego po mikrousług wzorców podejścia, jest prawdopodobne, że aplikacja platformy Docker będzie składać się z wielu kontenerów lub usług.</span><span class="sxs-lookup"><span data-stu-id="bb96e-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="bb96e-167">W związku z tym po tworzeniu kontenerów aplikacji w potoku ciągłej integracji należy również wdrożyć, zintegrować i przetestować aplikację jako całość ze wszystkimi jej kontenerami w ramach platformy Docker integracji lub nawet do klastra testowego, do którego kontenery są dystrybuowane.</span><span class="sxs-lookup"><span data-stu-id="bb96e-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="bb96e-168">Jeśli używasz jednego hosta, można użyć poleceń platformy Docker, takich jak docker-compose do tworzenia i wdrażania powiązanych kontenerów do testowania i sprawdzania poprawności środowiska platformy Docker w jednej maszynie wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="bb96e-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="bb96e-169">Ale jeśli pracujesz z klastra orkiestratora, takich jak DC/OS, Kubernetes lub Docker Swarm, należy wdrożyć kontenery za pomocą innego mechanizmu lub orchestrator, w zależności od wybranego klastra/harmonogramu.</span><span class="sxs-lookup"><span data-stu-id="bb96e-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="bb96e-170">Poniżej przedstawiono kilka typów testów, które można uruchomić w kontenerach platformy Docker:</span><span class="sxs-lookup"><span data-stu-id="bb96e-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="bb96e-171">Testy jednostkowe kontenerów platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="bb96e-172">Grupy testowe powiązanych ze sobą aplikacji lub mikrousług</span><span class="sxs-lookup"><span data-stu-id="bb96e-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="bb96e-173">Test w produkcji i "kanarek" zwalnia</span><span class="sxs-lookup"><span data-stu-id="bb96e-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="bb96e-174">Ważne jest to, że podczas uruchamiania integracji i testów funkcjonalnych, należy uruchomić te testy spoza kontenerów.</span><span class="sxs-lookup"><span data-stu-id="bb96e-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="bb96e-175">Testy nie są zawarte lub uruchamiane w kontenerach, które wdrażasz, ponieważ kontenery są oparte na statycznych obrazach, które powinny być dokładnie takie, jak te, które będą wdrażane w procesach produkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="bb96e-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="bb96e-176">Praktyczną opcją podczas testowania bardziej zaawansowanych scenariuszy, takich jak włączenie kilku klastrów (klastra testowego, klastra przemieszczania i klastra produkcyjnego) jest opublikowanie obrazów w rejestrze, dzięki czemu można je przetestować w różnych klastrach.</span><span class="sxs-lookup"><span data-stu-id="bb96e-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="bb96e-177">Wypychanie niestandardowego obrazu platformy Docker aplikacji do globalnego rejestru platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="bb96e-178">Po przetestowaniu i sprawdzeniu obrazów platformy Docker należy oznaczyć je i opublikować w rejestrze platformy Docker.</span><span class="sxs-lookup"><span data-stu-id="bb96e-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="bb96e-179">Rejestr platformy Docker jest krytycznym elementem w cyklu życia aplikacji platformy Docker, ponieważ jest to centralne miejsce przechowywania testu niestandardowego (znanego również jako "błogosławione obrazy"), który ma zostać wdrożony w środowiskach kontroli jakości i środowiskach produkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="bb96e-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="bb96e-180">Podobnie jak kod aplikacji przechowywany w repozytorium SCC (Git, itp.) jest "źródłem prawdy", rejestr platformy Docker jest "źródłem prawdy" dla aplikacji binarnej lub bitów, które mają być wdrożone w qa lub środowiskach produkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="bb96e-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="bb96e-181">Zazwyczaj można mieć prywatne repozytoria obrazów niestandardowych albo w prywatnym repozytorium w usłudze Azure Container Registry lub w rejestrze lokalnym, takim jak Zaufany rejestr platformy Docker, lub w rejestrze chmury publicznej z ograniczonym dostępem (takim jak Docker Hub), chociaż w tym ostatnim przypadku, jeśli kod nie jest open source, należy ufać bezpieczeństwu dostawcy.</span><span class="sxs-lookup"><span data-stu-id="bb96e-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="bb96e-182">Tak czy inaczej, metoda, której używasz `docker push` jest podobna i opiera się na poleceniu, jak pokazano na rysunku 5-4.</span><span class="sxs-lookup"><span data-stu-id="bb96e-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Diagram przedstawiający wypychanie obrazów niestandardowych do rejestru kontenerów.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="bb96e-184">**Rysunek 5-4**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-184">**Figure 5-4**.</span></span> <span data-ttu-id="bb96e-185">Publikowanie obrazów niestandardowych w rejestrze platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="bb96e-186">W kroku 3 do tworzenia integracji i testowania (CI) można opublikować wynikowe obrazy platformy docker do rejestru prywatnego lub publicznego.</span><span class="sxs-lookup"><span data-stu-id="bb96e-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="bb96e-187">Istnieje wiele ofert rejestrów platformy Docker od dostawców chmury, takich jak Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="bb96e-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="bb96e-188">Za pomocą zadań platformy Docker można wypchnąć `docker-compose.yml` zestaw obrazów usług zdefiniowanych przez plik, z wieloma tagami, do uwierzytelnionego rejestru platformy Docker (takiego jak usługa Azure Container Registry), jak pokazano na rysunku 5-5.</span><span class="sxs-lookup"><span data-stu-id="bb96e-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Zrzut ekranu przedstawiający krok do publikowania obrazów w rejestrze.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="bb96e-190">**Rysunek 5-5**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-190">**Figure 5-5**.</span></span> <span data-ttu-id="bb96e-191">Używanie usług DevOps platformy Azure do publikowania obrazów niestandardowych w rejestrze platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [! INFORMACJE]<span data-ttu-id="bb96e-192"> Aby uzyskać więcej informacji <https://aka.ms/azurecontainerregistry>na temat rejestru kontenerów platformy Azure, zobacz .</span><span class="sxs-lookup"><span data-stu-id="bb96e-192"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="bb96e-193">Krok 4: CD, Wdrażanie</span><span class="sxs-lookup"><span data-stu-id="bb96e-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="bb96e-194">Niezmienność obrazów platformy Docker zapewnia powtarzalne wdrożenie z tym, co jest opracowywane, testowane za pośrednictwem ciągłej integracji i uruchamiane w produkcji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="bb96e-195">Po opublikowaniu obrazów platformy Docker aplikacji w rejestrze platformy Docker (prywatnych lub publicznych) można wdrożyć je w kilku środowiskach, które mogą mieć (produkcja, kontrola jakości, przemieszczania itp.) z potoku dysku CD przy użyciu zadań potoku usług Azure DevOps lub usługi Azure DevOps Release Management.</span><span class="sxs-lookup"><span data-stu-id="bb96e-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="bb96e-196">Jednak w tym momencie zależy od tego, jaki rodzaj aplikacji platformy Docker wdrażasz.</span><span class="sxs-lookup"><span data-stu-id="bb96e-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="bb96e-197">Wdrażanie prostej aplikacji (z punktu widzenia kompozycji i wdrażania) jak monolityczne aplikacji składającej się z kilku kontenerów lub usług i wdrożony na kilku serwerach lub maszyn wirtualnych różni się od wdrażania bardziej złożonych aplikacji, takich jak aplikacja zorientowana na mikrousługi z możliwością hiperskali.</span><span class="sxs-lookup"><span data-stu-id="bb96e-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="bb96e-198">Te dwa scenariusze są wyjaśnione w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="bb96e-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="bb96e-199">Wdrażanie złożonych aplikacji platformy Docker w wielu środowiskach platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="bb96e-200">Przyjrzyjmy się najpierw mniej złożonemu scenariuszowi: wdrażanie na prostych hostach platformy Docker (maszyny wirtualne lub serwery) w jednym środowisku lub wielu środowiskach (qa, przemieszczania i produkcji).</span><span class="sxs-lookup"><span data-stu-id="bb96e-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="bb96e-201">W tym scenariuszu wewnętrznie potoku dysku CD można użyć docker-compose (z zadań wdrażania usługi Azure DevOps Services) do wdrażania aplikacji platformy Docker z powiązanym zestawem kontenerów lub usług, jak pokazano na rysunku 5-6.</span><span class="sxs-lookup"><span data-stu-id="bb96e-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Diagram przedstawiający krok wdrażania dysku CD w trzech środowiskach.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="bb96e-203">**Rysunek 5-6**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-203">**Figure 5-6**.</span></span> <span data-ttu-id="bb96e-204">Wdrażanie kontenerów aplikacji w prostym rejestrze środowisk hosta platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="bb96e-205">Rysunek 5-7 podkreśla, jak można połączyć kompilacji CI do środowiska QA/test za pośrednictwem usługi Azure DevOps Services, klikając docker compose w oknie dialogowym Dodawanie zadania.</span><span class="sxs-lookup"><span data-stu-id="bb96e-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="bb96e-206">Jednak podczas wdrażania w środowiskach przejściowych lub produkcyjnych zwykle należy używać funkcji zarządzania wersjami obsługujących wiele środowisk (takich jak kontrola jakości, przemieszczania i produkcji).</span><span class="sxs-lookup"><span data-stu-id="bb96e-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="bb96e-207">Jeśli wdrażasz do pojedynczych hostów platformy Docker, używa zadania "Docker Compose" usług Azure `docker-compose up` DevOps (które wywołuje polecenie pod maską).</span><span class="sxs-lookup"><span data-stu-id="bb96e-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="bb96e-208">Jeśli wdrażasz w usłudze Azure Kubernetes Service (AKS), używa zadania wdrażania platformy Docker, jak wyjaśniono w sekcji, która jest następująca.</span><span class="sxs-lookup"><span data-stu-id="bb96e-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Zrzut ekranu przedstawiający okno dialogowe Dodawanie zadań zadania dok.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="bb96e-210">**Rysunek 5-7**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-210">**Figure 5-7**.</span></span> <span data-ttu-id="bb96e-211">Dodawanie zadania dokowania compose w potoku usług Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="bb96e-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="bb96e-212">Podczas tworzenia wersji w usłudze Azure DevOps Services, trwa zestaw artefaktów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="bb96e-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="bb96e-213">Te artefakty są przeznaczone do niezmienne przez cały okres istnienia wydania, we wszystkich środowiskach.</span><span class="sxs-lookup"><span data-stu-id="bb96e-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="bb96e-214">Po wprowadzeniu kontenerów artefakty wejściowe identyfikują obrazy w rejestrze do wdrożenia.</span><span class="sxs-lookup"><span data-stu-id="bb96e-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="bb96e-215">W zależności od sposobu identyfikacji tych obrazów nie są one gwarantowane, aby pozostać takie same przez `myimage:latest` cały `docker-compose` czas trwania wydania, najbardziej oczywistym przypadkiem jest odwołanie z pliku.</span><span class="sxs-lookup"><span data-stu-id="bb96e-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="bb96e-216">Szablony usług DevOps platformy Azure umożliwiają generowanie artefaktów kompilacji, które zawierają określone skróty obrazów rejestru, które są gwarantowane, aby jednoznacznie zidentyfikować ten sam plik binarny obrazu.</span><span class="sxs-lookup"><span data-stu-id="bb96e-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="bb96e-217">Są to, co naprawdę chcesz użyć jako dane wejściowe do wydania.</span><span class="sxs-lookup"><span data-stu-id="bb96e-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="bb96e-218">Zarządzanie wersjami do środowisk platformy Docker przy użyciu zarządzania wersjami usług Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="bb96e-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="bb96e-219">Za pomocą szablonów usług Azure DevOps można utworzyć nowy obraz, opublikować go w rejestrze platformy Docker, `docker-compose` uruchomić go na platformie Linux lub Windows hosts i używać poleceń, takich jak wdrożenie wielu kontenerów jako całej aplikacji, wszystko za pośrednictwem funkcji zarządzania wersjami usługi Azure DevOps przeznaczone dla wielu środowisk, jak pokazano na rysunku 5-8.</span><span class="sxs-lookup"><span data-stu-id="bb96e-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Zrzut ekranu przedstawiający konfigurację wersji kompozycji docker.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="bb96e-221">**Rysunek 5-8**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-221">**Figure 5-8**.</span></span> <span data-ttu-id="bb96e-222">Konfigurowanie zadań dokowania usługi Azure DevOps compose z zarządzania wydaniami usług Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="bb96e-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="bb96e-223">Należy jednak pamiętać, że scenariusz pokazany na rysunku 5-6 i zaimplementowany na rysunku 5-8 jest prosty (wdrażany na pojedynczych hostach platformy Docker i maszynach wirtualnych i będzie jeden kontener lub wystąpienie na obraz) i prawdopodobnie powinien być używany tylko do scenariuszy programistycznych lub testowych.</span><span class="sxs-lookup"><span data-stu-id="bb96e-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="bb96e-224">W większości scenariuszy produkcyjnych przedsiębiorstwa chcesz mieć wysoką dostępność (HA) i łatwe w zarządzaniu skalowalność przez równoważenie obciążenia w wielu węzłach, serwerach i maszynach wirtualnych oraz "inteligentne tryb failovers", więc jeśli serwer lub węzeł ulegnie awarii, jego usługi i kontenery zostaną przeniesione do innego serwera hosta lub maszyny wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="bb96e-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="bb96e-225">W takim przypadku potrzebne są bardziej zaawansowane technologie, takie jak klastry kontenerów, koordynatorzy i harmonogramy.</span><span class="sxs-lookup"><span data-stu-id="bb96e-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="bb96e-226">W związku z tym sposób wdrożenia do tych klastrów jest obsługa zaawansowanych scenariuszy wyjaśnione w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="bb96e-227">Wdrażanie aplikacji platformy Docker w klastrach platformy Docker</span><span class="sxs-lookup"><span data-stu-id="bb96e-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="bb96e-228">Charakter aplikacji rozproszonych wymaga zasobów obliczeniowych, które są również dystrybuowane.</span><span class="sxs-lookup"><span data-stu-id="bb96e-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="bb96e-229">Aby mieć możliwości skali produkcyjnej, należy mieć możliwości klastrowania, które zapewniają wysoką skalowalność i wysoką dostępność na podstawie zasobów puli.</span><span class="sxs-lookup"><span data-stu-id="bb96e-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="bb96e-230">Kontenery można wdrożyć ręcznie do tych klastrów z narzędzia interfejsu wiersza polecenia lub interfejsu użytkownika sieci web, ale należy zarezerwować tego rodzaju pracy ręcznej do wykrywania testowania wdrażania lub celów zarządzania, takich jak skalowanie lub monitorowanie.</span><span class="sxs-lookup"><span data-stu-id="bb96e-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="bb96e-231">Z punktu widzenia dysku CD, a usługi Azure DevOps w szczególności można uruchomić specjalnie wykonane zadania wdrażania ze środowisk zarządzania wersjami usługi Azure DevOps, które będą wdrażać konteneryzowane aplikacje do klastrów rozproszonych w usłudze kontenera, jak pokazano na rysunku 5-9.</span><span class="sxs-lookup"><span data-stu-id="bb96e-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Diagram przedstawiający krok wdrażania dysku CD dla koordynatorów.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="bb96e-233">**Rysunek 5-9**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-233">**Figure 5-9**.</span></span> <span data-ttu-id="bb96e-234">Wdrażanie aplikacji rozproszonych w usłudze kontenerowej</span><span class="sxs-lookup"><span data-stu-id="bb96e-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="bb96e-235">Początkowo podczas wdrażania do niektórych klastrów lub koordynatorów, tradycyjnie należy użyć określonych skryptów wdrażania i mechanizmów na każdego koordynatora (czyli Kubernetes i sieci `docker-compose` szkieletowej usług `docker-compose.yml` mają różne mechanizmy wdrażania) zamiast prostszego i łatwego w użyciu narzędzia opartego na pliku definicji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="bb96e-236">Jednak dzięki zadaniu wdrażania platformy Azure DevOps Services, pokazane na rysunku 5-10, teraz można również wdrożyć do obsługiwanych koordynatorów, po prostu przy użyciu znanego `docker-compose.yml` pliku, ponieważ narzędzie wykonuje to "tłumaczenie" dla Ciebie (z `docker-compose.yml` pliku do formatu wymaganego przez koordynatora).</span><span class="sxs-lookup"><span data-stu-id="bb96e-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Zrzut ekranu przedstawiający zadanie Wdrażanie w uduśne.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="bb96e-238">**Rysunek 5-10**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-238">**Figure 5-10**.</span></span> <span data-ttu-id="bb96e-239">Dodawanie zadania Wdrażanie do usługi Kubernetes do środowiska</span><span class="sxs-lookup"><span data-stu-id="bb96e-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="bb96e-240">Rysunek 5-11 pokazuje, jak można edytować wdrożenie do kubernetes zadanie z sekcji dostępnych do konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="bb96e-241">Jest to zadanie, które będzie pobierać gotowe do użycia niestandardowe obrazy platformy Docker do wdrożenia jako kontenery w klastrze.</span><span class="sxs-lookup"><span data-stu-id="bb96e-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Zrzut ekranu przedstawiający konfigurację zadania Wdrażanie w uduchowienia.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="bb96e-243">**Rysunek 5-11**.</span><span class="sxs-lookup"><span data-stu-id="bb96e-243">**Figure 5-11**.</span></span> <span data-ttu-id="bb96e-244">Wdrażanie definicji zadania wdrażania w deployą definicji systemu ACS DC/OS</span><span class="sxs-lookup"><span data-stu-id="bb96e-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [! INFORMACJE]<span data-ttu-id="bb96e-245"> Aby dowiedzieć się więcej o potoku dysku CD w usłudze Azure DevOps Services i platformie Docker, odwiedź stronę<https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="bb96e-245"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="bb96e-246">Krok 5: Uruchamianie i zarządzanie</span><span class="sxs-lookup"><span data-stu-id="bb96e-246">Step 5: Run and manage</span></span>

<span data-ttu-id="bb96e-247">Ponieważ uruchamianie aplikacji i zarządzanie aplikacjami na poziomie produkcji przedsiębiorstwa jest głównym tematem samym w sobie, a także ze względu na rodzaj operacji i osób pracujących na tym poziomie (operacje IT), a także duży zakres tego obszaru, cały następny rozdział poświęcony jest wyjaśnieniu tego.</span><span class="sxs-lookup"><span data-stu-id="bb96e-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="bb96e-248">Krok 6: Monitorowanie i diagnozowanie</span><span class="sxs-lookup"><span data-stu-id="bb96e-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="bb96e-249">Ten temat jest również omówiony w następnym rozdziale jako część zadań, które IT wykonuje w systemach produkcyjnych; jednak ważne jest, aby podkreślić, że szczegółowe informacje uzyskane w tym kroku musi przesyłać z powrotem do zespołu deweloperów, tak aby aplikacja jest stale ulepszana.</span><span class="sxs-lookup"><span data-stu-id="bb96e-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="bb96e-250">Z tego punktu widzenia jest również częścią DevOps, chociaż zadania i operacje są często wykonywane przez IT.</span><span class="sxs-lookup"><span data-stu-id="bb96e-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="bb96e-251">Tylko wtedy, gdy monitorowanie i diagnostyka są w 100% w obrębie obszaru DevOps są procesy monitorowania i analizy wykonywane przez zespół programistów przed testowaniem lub środowiskach beta.</span><span class="sxs-lookup"><span data-stu-id="bb96e-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="bb96e-252">Odbywa się to poprzez przeprowadzenie testów obciążenia lub monitorowanie środowisk beta lub qa, gdzie beta testerzy próbują nowych wersji.</span><span class="sxs-lookup"><span data-stu-id="bb96e-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="bb96e-253">[Poprzedni](index.md)
>[następny](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="bb96e-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
