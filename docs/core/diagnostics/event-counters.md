---
title: EventCounters na platformie .NET Core
description: W tym artykule dowiesz się, co EventCounters, jak je wdrożyć i jak je wykorzystać.
ms.date: 08/07/2020
ms.openlocfilehash: 08180b5580d2e7fe782fbd531a26872715825cdf
ms.sourcegitcommit: 4b79862c5b41fbd86cf38f926f6a49516059f6f2
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/18/2020
ms.locfileid: "97678196"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="58180-103">EventCounters na platformie .NET Core</span><span class="sxs-lookup"><span data-stu-id="58180-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="58180-104">**Ten artykuł ma zastosowanie do: ✔️** .net Core 3,0 SDK i nowszych wersjach</span><span class="sxs-lookup"><span data-stu-id="58180-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="58180-105">EventCounters to interfejsy API platformy .NET Core używane dla lekkiej, międzyplatformowej i niemal w czasie rzeczywistym zbierania metryk wydajności.</span><span class="sxs-lookup"><span data-stu-id="58180-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="58180-106">EventCounters zostały dodane jako alternatywa dla wielu platform dla "liczników wydajności" .NET Framework w systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="58180-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="58180-107">W tym artykule dowiesz się, co EventCounters, jak je wdrożyć i jak je wykorzystać.</span><span class="sxs-lookup"><span data-stu-id="58180-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="58180-108">Środowisko uruchomieniowe platformy .NET Core i kilka bibliotek .NET publikują podstawowe informacje diagnostyczne przy użyciu EventCounters, począwszy od platformy .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="58180-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="58180-109">Oprócz EventCounters, które są dostarczane przez środowisko uruchomieniowe platformy .NET, można zaimplementować swój własny EventCounters.</span><span class="sxs-lookup"><span data-stu-id="58180-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="58180-110">EventCounters może służyć do śledzenia różnych metryk.</span><span class="sxs-lookup"><span data-stu-id="58180-110">EventCounters can be used to track various metrics.</span></span> <span data-ttu-id="58180-111">Dowiedz się więcej na temat [dobrze znanych EventCounters na platformie .NET](available-counters.md)</span><span class="sxs-lookup"><span data-stu-id="58180-111">Learn more about them in the [well-known EventCounters in .NET](available-counters.md)</span></span>

<span data-ttu-id="58180-112">EventCounters na żywo jako część <xref:System.Diagnostics.Tracing.EventSource> i są automatycznie wypychane do narzędzi odbiornika.</span><span class="sxs-lookup"><span data-stu-id="58180-112">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="58180-113">Podobnie jak w przypadku wszystkich innych zdarzeń w <xref:System.Diagnostics.Tracing.EventSource> , mogą one być używane zarówno w procesie, jak i na zewnątrz w procesie za pośrednictwem <xref:System.Diagnostics.Tracing.EventListener> i [EventPipe](./eventpipe.md).</span><span class="sxs-lookup"><span data-stu-id="58180-113">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and [EventPipe](./eventpipe.md).</span></span> <span data-ttu-id="58180-114">Ten artykuł koncentruje się na funkcjach EventCounters i celowo wyklucza narzędzia PerfView i funkcję ETW (śledzenie zdarzeń dla systemu Windows), chociaż oba mogą być używane z EventCounters.</span><span class="sxs-lookup"><span data-stu-id="58180-114">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Obraz przedstawiający diagram w procesie EventCounters i out-of-proc](media/event-counters.svg)

## <a name="eventcounter-api-overview"></a><span data-ttu-id="58180-116">Przegląd interfejsu API EventCounter</span><span class="sxs-lookup"><span data-stu-id="58180-116">EventCounter API overview</span></span>

<span data-ttu-id="58180-117">Istnieją dwie podstawowe kategorie liczników.</span><span class="sxs-lookup"><span data-stu-id="58180-117">There are two primary categories of counters.</span></span> <span data-ttu-id="58180-118">Niektóre liczniki są przeznaczone do wartości "rate", takich jak łączna liczba wyjątków, Łączna liczba operacje odzyskiwania pamięci i łączna liczba żądań.</span><span class="sxs-lookup"><span data-stu-id="58180-118">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="58180-119">Inne liczniki to wartości "snapshot", takie jak użycie sterty, użycie procesora CPU i rozmiar zestawu roboczego.</span><span class="sxs-lookup"><span data-stu-id="58180-119">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="58180-120">W ramach każdej z tych kategorii liczników istnieją dwa typy liczników, które różnią się w zależności od ich wartości.</span><span class="sxs-lookup"><span data-stu-id="58180-120">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="58180-121">Liczniki sondowania pobierają ich wartości za pośrednictwem wywołania zwrotnego, a liczniki bez sondowania mają swoje wartości bezpośrednio ustawione w wystąpieniu licznika.</span><span class="sxs-lookup"><span data-stu-id="58180-121">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="58180-122">Liczniki są reprezentowane przez następujące implementacje:</span><span class="sxs-lookup"><span data-stu-id="58180-122">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="58180-123">Odbiornik zdarzeń określa, jak długo są interwały pomiaru.</span><span class="sxs-lookup"><span data-stu-id="58180-123">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="58180-124">Na końcu każdego interwału wartość jest przekazywana do odbiornika dla każdego licznika.</span><span class="sxs-lookup"><span data-stu-id="58180-124">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="58180-125">Implementacje licznika określają, jakie interfejsy API i obliczenia są używane do tworzenia wartości każdego interwału.</span><span class="sxs-lookup"><span data-stu-id="58180-125">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="58180-126"><xref:System.Diagnostics.Tracing.EventCounter>Rejestruje zbiór wartości.</span><span class="sxs-lookup"><span data-stu-id="58180-126">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="58180-127"><xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType>Metoda dodaje nową wartość do zestawu.</span><span class="sxs-lookup"><span data-stu-id="58180-127">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="58180-128">Dla każdego interwału obliczane jest podsumowanie statystyczne dla zestawu, takie jak min, Max i średnia.</span><span class="sxs-lookup"><span data-stu-id="58180-128">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="58180-129">W narzędziu [dotnet-Counters](dotnet-counters.md) zawsze będzie wyświetlana wartość średnia.</span><span class="sxs-lookup"><span data-stu-id="58180-129">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="58180-130"><xref:System.Diagnostics.Tracing.EventCounter>Jest to przydatne do opisywania dyskretnego zestawu operacji.</span><span class="sxs-lookup"><span data-stu-id="58180-130">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="58180-131">Typowym użyciem może być monitorowanie średniego rozmiaru w bajtach ostatnich operacji we/wy lub średniej wartości pieniężnej zestawu transakcji finansowych.</span><span class="sxs-lookup"><span data-stu-id="58180-131">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="58180-132"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Rejestruje sumę całkowitą dla każdego przedziału czasu.</span><span class="sxs-lookup"><span data-stu-id="58180-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="58180-133"><xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType>Metoda dodaje do sumy.</span><span class="sxs-lookup"><span data-stu-id="58180-133">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="58180-134">Na przykład, jeśli `Increment()` jest wywoływana trzy razy w jednym interwale z wartościami `1` , `2` , i `5` , wówczas suma uruchomiona wartości `8` będzie raportowana jako wartość licznika dla tego interwału.</span><span class="sxs-lookup"><span data-stu-id="58180-134">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="58180-135">W narzędziu [dotnet-Counters](dotnet-counters.md) zostanie wyświetlona stawka jako nagrana suma/czas.</span><span class="sxs-lookup"><span data-stu-id="58180-135">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="58180-136"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Jest to przydatne do mierzenia, jak często występuje akcja, na przykład liczby żądań przetwarzanych na sekundę.</span><span class="sxs-lookup"><span data-stu-id="58180-136">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="58180-137"><xref:System.Diagnostics.Tracing.PollingCounter>Używa wywołania zwrotnego do określenia wartości, która jest raportowana.</span><span class="sxs-lookup"><span data-stu-id="58180-137">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="58180-138">Za każdym razem, gdy jest wywoływana funkcja wywołania zwrotnego użytkownika, a zwracana wartość jest używana jako wartość licznika.</span><span class="sxs-lookup"><span data-stu-id="58180-138">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="58180-139"><xref:System.Diagnostics.Tracing.PollingCounter>Program może służyć do wykonywania zapytań dotyczących metryki z zewnętrznego źródła, na przykład przy pobieraniu bieżących bajtów wolnego miejsca na dysku.</span><span class="sxs-lookup"><span data-stu-id="58180-139">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="58180-140">Może on również służyć do raportowania niestandardowych statystyk, które mogą być obliczane na żądanie przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="58180-140">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="58180-141">Przykłady obejmują raportowanie używany 95. percentylu ostatnich opóźnień żądań lub bieżącego współczynnika trafień lub chybień pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="58180-141">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="58180-142"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter>Używa wywołania zwrotnego, aby określić raportowaną wartość przyrostu.</span><span class="sxs-lookup"><span data-stu-id="58180-142">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="58180-143">Za każdym razem interwał wywołania zwrotnego jest wywoływany, a następnie różnica między bieżącym wywołaniem a ostatnim wywołaniem jest raportowaną wartością.</span><span class="sxs-lookup"><span data-stu-id="58180-143">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="58180-144">W narzędziu [dotnet-Counters](dotnet-counters.md) zawsze będzie wyświetlana różnica w postaci stawki, zgłoszonej wartości/godziny.</span><span class="sxs-lookup"><span data-stu-id="58180-144">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="58180-145">Ten licznik jest przydatny, gdy nie jest możliwe wywołanie interfejsu API dla każdego wystąpienia, ale możliwe jest zbadanie łącznej liczby wystąpień.</span><span class="sxs-lookup"><span data-stu-id="58180-145">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="58180-146">Można na przykład zgłosić liczbę bajtów zapisanych do pliku na sekundę, nawet bez powiadomienia za każdym razem, gdy zostanie zapisany bajt.</span><span class="sxs-lookup"><span data-stu-id="58180-146">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="58180-147">Implementowanie elementu EventSource</span><span class="sxs-lookup"><span data-stu-id="58180-147">Implement an EventSource</span></span>

<span data-ttu-id="58180-148">Poniższy kod implementuje przykład <xref:System.Diagnostics.Tracing.EventSource> uwidoczniony jako nazwany `"Sample.EventCounter.Minimal"` dostawca.</span><span class="sxs-lookup"><span data-stu-id="58180-148">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="58180-149">To źródło zawiera <xref:System.Diagnostics.Tracing.EventCounter> czas przetwarzania żądania.</span><span class="sxs-lookup"><span data-stu-id="58180-149">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="58180-150">Taki licznik ma nazwę (czyli jego unikatowy identyfikator w źródle) i nazwę wyświetlaną używaną przez narzędzia odbiornika, takie jak [dotnet-Counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="58180-150">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="58180-151">Służy `dotnet-counters ps` do wyświetlania listy procesów platformy .NET, które mogą być monitorowane:</span><span class="sxs-lookup"><span data-stu-id="58180-151">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="58180-152">Przekaż <xref:System.Diagnostics.Tracing.EventSource> nazwę do `--counters` opcji rozpoczęcia monitorowania licznika:</span><span class="sxs-lookup"><span data-stu-id="58180-152">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `--counters` option to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 --counters Sample.EventCounter.Minimal
```

<span data-ttu-id="58180-153">Poniższy przykład przedstawia dane wyjściowe monitora:</span><span class="sxs-lookup"><span data-stu-id="58180-153">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="58180-154">Naciśnij pozycję <kbd>q</kbd> , aby zatrzymać polecenie monitorowania.</span><span class="sxs-lookup"><span data-stu-id="58180-154">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="58180-155">Liczniki warunkowe</span><span class="sxs-lookup"><span data-stu-id="58180-155">Conditional counters</span></span>

<span data-ttu-id="58180-156">Podczas wdrażania klasy <xref:System.Diagnostics.Tracing.EventSource> zawierającej liczniki można warunkowo utworzyć wystąpienie, gdy <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> Metoda jest wywoływana z <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> wartością `EventCommand.Enable` .</span><span class="sxs-lookup"><span data-stu-id="58180-156">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="58180-157">Aby bezpiecznie utworzyć wystąpienie wystąpienia licznika tylko wtedy, gdy jest to możliwe `null` , użyj [operatora przypisania łączenia z wartością null](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="58180-157">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="58180-158">Ponadto metody niestandardowe mogą oszacować metodę, <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> Aby określić, czy bieżące źródło zdarzeń jest włączone.</span><span class="sxs-lookup"><span data-stu-id="58180-158">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="58180-159">Liczniki warunkowe są licznikami, które są warunkowo tworzone, a mikro Optymalizacja.</span><span class="sxs-lookup"><span data-stu-id="58180-159">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="58180-160">Środowisko uruchomieniowe przyjmuje ten wzorzec dla scenariuszy, w których liczniki nie są zwykle używane, aby zaoszczędzić część milisekundy.</span><span class="sxs-lookup"><span data-stu-id="58180-160">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="58180-161">Przykładowe liczniki środowiska uruchomieniowego platformy .NET Core</span><span class="sxs-lookup"><span data-stu-id="58180-161">.NET Core runtime example counters</span></span>

<span data-ttu-id="58180-162">Środowisko uruchomieniowe platformy .NET Core zawiera wiele doskonałych przykładowych implementacji.</span><span class="sxs-lookup"><span data-stu-id="58180-162">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="58180-163">Oto implementacja środowiska uruchomieniowego dla licznika, który śledzi rozmiar zestawu roboczego aplikacji.</span><span class="sxs-lookup"><span data-stu-id="58180-163">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="58180-164"><xref:System.Diagnostics.Tracing.PollingCounter>Raport przedstawia bieżącą ilość pamięci fizycznej zamapowanej na proces (zestaw roboczy) aplikacji, ponieważ w momencie przechwytuje ona metrykę.</span><span class="sxs-lookup"><span data-stu-id="58180-164">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="58180-165">Wywołanie zwrotne do sondowania wartości jest podanym wyrażeniem lambda, które jest tylko wywołaniem <xref:System.Environment.WorkingSet?displayProperty=fullName> interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="58180-165">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="58180-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> i <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> są opcjonalnymi właściwościami, które można ustawić, aby ułatwić konsumentowi licznika Wyświetlanie wartości dokładniej.</span><span class="sxs-lookup"><span data-stu-id="58180-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="58180-167">Na przykład, program [dotnet-Counters](dotnet-counters.md) używa tych właściwości do wyświetlania większej przyjaznej dla wyświetlania wersji nazw liczników.</span><span class="sxs-lookup"><span data-stu-id="58180-167">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="58180-168">`DisplayName`Właściwości nie są zlokalizowane.</span><span class="sxs-lookup"><span data-stu-id="58180-168">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="58180-169">W przypadku <xref:System.Diagnostics.Tracing.PollingCounter> <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> elementów i nic nie trzeba wykonywać żadnych innych czynności.</span><span class="sxs-lookup"><span data-stu-id="58180-169">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="58180-170">Oba te wartości są sondowane w przedziale czasowym żądanym przez klienta.</span><span class="sxs-lookup"><span data-stu-id="58180-170">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="58180-171">Oto przykład licznika czasu wykonywania zaimplementowanego przy użyciu <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> .</span><span class="sxs-lookup"><span data-stu-id="58180-171">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="58180-172"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter>Używa <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> interfejsu API do raportowania przyrostu całkowitej liczby rywalizacji o blokadę.</span><span class="sxs-lookup"><span data-stu-id="58180-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="58180-173"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale>Właściwość jest opcjonalna, ale jeśli jest używana, może zapewnić wskazówkę dotyczącą interwału czasu, w którym licznik jest najlepiej wyświetlany.</span><span class="sxs-lookup"><span data-stu-id="58180-173">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="58180-174">Na przykład liczba rywalizacji blokad jest najlepiej wyświetlana jako _Liczba na sekundę_, więc jej <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> wartość jest równa jednej sekundzie.</span><span class="sxs-lookup"><span data-stu-id="58180-174">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="58180-175">Współczynnik wyświetlania można dopasować dla różnych typów liczników szybkości.</span><span class="sxs-lookup"><span data-stu-id="58180-175">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="58180-176"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> _Nie_ jest używany przez program [dotnet-Counters](dotnet-counters.md), a detektory zdarzeń nie są wymagane do korzystania z niego.</span><span class="sxs-lookup"><span data-stu-id="58180-176">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="58180-177">Istnieje więcej implementacji liczników do użycia jako odwołanie w repozytorium [środowiska uruchomieniowego platformy .NET](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) .</span><span class="sxs-lookup"><span data-stu-id="58180-177">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="58180-178">Współbieżność</span><span class="sxs-lookup"><span data-stu-id="58180-178">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="58180-179">Interfejs API EventCounters nie gwarantuje bezpieczeństwa wątków.</span><span class="sxs-lookup"><span data-stu-id="58180-179">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="58180-180">Gdy Delegaty przechodzą do <xref:System.Diagnostics.Tracing.PollingCounter> lub <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> wystąpienia są wywoływane przez wiele wątków, odpowiedzialność za zagwarantowanie bezpieczeństwa wątków delegatów.</span><span class="sxs-lookup"><span data-stu-id="58180-180">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="58180-181">Rozważmy na przykład następujące, <xref:System.Diagnostics.Tracing.EventSource> Aby śledzić żądania.</span><span class="sxs-lookup"><span data-stu-id="58180-181">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="58180-182">`AddRequest()`Metodę można wywołać z procedury obsługi żądań, a następnie `RequestRateCounter` sonduje wartość w interwale określonym przez odbiorcę licznika.</span><span class="sxs-lookup"><span data-stu-id="58180-182">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="58180-183">Jednak `AddRequest()` Metoda może być wywoływana przez wiele wątków jednocześnie, co w przypadku wystąpienia warunku `_requestCount` .</span><span class="sxs-lookup"><span data-stu-id="58180-183">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="58180-184">Bezpieczny wątkowo alternatywny sposób, aby zwiększyć `_requestCount` użycie <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="58180-184">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="58180-185">Aby zapobiec rozdartym odczytom (na 32-bitowych architekturach) `long` `_requestCount` użycia pola <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="58180-185">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="58180-186">Korzystanie z EventCounters</span><span class="sxs-lookup"><span data-stu-id="58180-186">Consume EventCounters</span></span>

<span data-ttu-id="58180-187">Istnieją dwa podstawowe sposoby używania EventCounters, w ramach procesu lub out-of-proc.</span><span class="sxs-lookup"><span data-stu-id="58180-187">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="58180-188">Użycie EventCounters można podzielić na trzy warstwy różnych zużywanych technologii.</span><span class="sxs-lookup"><span data-stu-id="58180-188">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="58180-189">Transportowanie zdarzeń w strumieniu nieprzetworzonym za pośrednictwem funkcji ETW lub EventPipe:</span><span class="sxs-lookup"><span data-stu-id="58180-189">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="58180-190">Interfejsy API ETW są dostarczane z systemem operacyjnym Windows, a EventPipe jest dostępny jako [interfejs API platformy .NET](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console)lub diagnostyczny [Protokół IPC](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span><span class="sxs-lookup"><span data-stu-id="58180-190">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="58180-191">Dekodowanie strumienia zdarzeń binarnych do zdarzeń:</span><span class="sxs-lookup"><span data-stu-id="58180-191">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="58180-192">[Biblioteka zdarzenie śledzenia](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) obsługuje zarówno formaty strumieni ETW, jak i EventPipe.</span><span class="sxs-lookup"><span data-stu-id="58180-192">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="58180-193">Narzędzia wiersza polecenia i graficznego interfejsu użytkownika:</span><span class="sxs-lookup"><span data-stu-id="58180-193">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="58180-194">Narzędzia takie jak narzędzia PerfView (ETW lub EventPipe), dotnet-Counters (tylko EventPipe) i monitor dotnet (tylko EventPipe).</span><span class="sxs-lookup"><span data-stu-id="58180-194">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="58180-195">Korzystanie z zewnątrz procesu</span><span class="sxs-lookup"><span data-stu-id="58180-195">Consume out-of-proc</span></span>

<span data-ttu-id="58180-196">Korzystanie z EventCounters out-of-proc jest bardzo typowym podejściem.</span><span class="sxs-lookup"><span data-stu-id="58180-196">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="58180-197">Za pomocą programu [dotnet-Counters](dotnet-counters.md) można korzystać na wielu platformach za pośrednictwem EventPipe.</span><span class="sxs-lookup"><span data-stu-id="58180-197">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="58180-198">To `dotnet-counters` Narzędzie jest globalnym narzędziem interfejsu wiersza polecenia dotnet dla wielu platform, które może służyć do monitorowania wartości liczników.</span><span class="sxs-lookup"><span data-stu-id="58180-198">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="58180-199">Aby dowiedzieć się, jak używać `dotnet-counters` do monitorowania liczników, zobacz [dotnet-Counters](dotnet-counters.md)lub pracuj przez [wydajność miary za pomocą](event-counter-perf.md) samouczka EventCounters.</span><span class="sxs-lookup"><span data-stu-id="58180-199">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="58180-200">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="58180-200">dotnet-trace</span></span>

<span data-ttu-id="58180-201">`dotnet-trace`Za pomocą tego narzędzia można korzystać z danych licznika przez EventPipe.</span><span class="sxs-lookup"><span data-stu-id="58180-201">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="58180-202">Oto przykład użycia `dotnet-trace` do zbierania danych licznika.</span><span class="sxs-lookup"><span data-stu-id="58180-202">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="58180-203">Aby uzyskać więcej informacji na temat zbierania wartości licznika w czasie, zobacz dokumentację [śledzenia dotnet](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) .</span><span class="sxs-lookup"><span data-stu-id="58180-203">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="58180-204">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="58180-204">Azure Application Insights</span></span>

<span data-ttu-id="58180-205">EventCounters mogą być używane przez Azure Monitor, w tym Application Insights platformy Azure.</span><span class="sxs-lookup"><span data-stu-id="58180-205">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="58180-206">Liczniki można dodawać i usuwać oraz korzystać z nich, aby można było określić liczniki niestandardowe lub dobrze znane liczniki.</span><span class="sxs-lookup"><span data-stu-id="58180-206">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="58180-207">Aby uzyskać więcej informacji, zobacz [Dostosowywanie liczników do zebrania](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="58180-207">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="58180-208">dotnet-monitor</span><span class="sxs-lookup"><span data-stu-id="58180-208">dotnet-monitor</span></span>

<span data-ttu-id="58180-209">`dotnet-monitor`Narzędzie to eksperymentalne narzędzie, które ułatwia uzyskiwanie dostępu do informacji diagnostycznych w procesie platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="58180-209">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="58180-210">Narzędzie służy jako nadzbiór wszystkich narzędzi diagnostycznych.</span><span class="sxs-lookup"><span data-stu-id="58180-210">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="58180-211">Oprócz śledzenia można monitorować metryki, zbierać zrzuty pamięci i zbierać zrzuty GC.</span><span class="sxs-lookup"><span data-stu-id="58180-211">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="58180-212">Jest dystrybuowany jako narzędzie interfejsu wiersza polecenia i obraz platformy Docker.</span><span class="sxs-lookup"><span data-stu-id="58180-212">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="58180-213">Udostępnia interfejs API REST, a kolekcja artefaktów diagnostycznych odbywa się za pomocą wywołań REST.</span><span class="sxs-lookup"><span data-stu-id="58180-213">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="58180-214">Aby uzyskać więcej informacji, zobacz [wprowadzenie do monitora dotnet-monitor, narzędzia eksperymentalne](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="58180-214">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="58180-215">Używanie w procesie</span><span class="sxs-lookup"><span data-stu-id="58180-215">Consume in-proc</span></span>

<span data-ttu-id="58180-216">Można korzystać z wartości licznika za pośrednictwem <xref:System.Diagnostics.Tracing.EventListener> interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="58180-216">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="58180-217"><xref:System.Diagnostics.Tracing.EventListener>Jest to wewnątrzprocesowy sposób zużywania wszelkich zdarzeń, które są zapisywane przez wszystkie wystąpienia <xref:System.Diagnostics.Tracing.EventSource> w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="58180-217">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="58180-218">Aby uzyskać więcej informacji na temat korzystania z `EventListener` interfejsu API, zobacz <xref:System.Diagnostics.Tracing.EventListener> .</span><span class="sxs-lookup"><span data-stu-id="58180-218">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="58180-219">Najpierw należy <xref:System.Diagnostics.Tracing.EventSource> włączyć wartość licznika.</span><span class="sxs-lookup"><span data-stu-id="58180-219">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="58180-220">Zastąp <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> metodę, aby otrzymać powiadomienie, gdy <xref:System.Diagnostics.Tracing.EventSource> zostanie utworzony, a jeśli jest to poprawne <xref:System.Diagnostics.Tracing.EventSource> w EventCounters, możesz je wywoływać <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="58180-220">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="58180-221">Oto przykładowe przesłonięcie:</span><span class="sxs-lookup"><span data-stu-id="58180-221">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="16-27":::

#### <a name="sample-code"></a><span data-ttu-id="58180-222">Przykładowy kod</span><span class="sxs-lookup"><span data-stu-id="58180-222">Sample code</span></span>

<span data-ttu-id="58180-223">Poniżej znajduje się przykładowa <xref:System.Diagnostics.Tracing.EventListener> Klasa, która drukuje wszystkie nazwy liczników i wartości z środowiska uruchomieniowego platformy .NET <xref:System.Diagnostics.Tracing.EventSource> , aby opublikować jego liczniki wewnętrzne ( `System.Runtime` ) w pewnym interwale.</span><span class="sxs-lookup"><span data-stu-id="58180-223">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) at some interval.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="58180-224">Jak pokazano powyżej, _należy_ upewnić się, że `"EventCounterIntervalSec"` argument jest ustawiony w `filterPayload` argumencie podczas wywoływania <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A> .</span><span class="sxs-lookup"><span data-stu-id="58180-224">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="58180-225">W przeciwnym razie liczniki nie będą mogły opróżniać wartości, ponieważ nie wie, z jakim interwałem należy uzyskać opróżnianie.</span><span class="sxs-lookup"><span data-stu-id="58180-225">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="58180-226">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="58180-226">See also</span></span>

- [<span data-ttu-id="58180-227">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="58180-227">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="58180-228">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="58180-228">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
