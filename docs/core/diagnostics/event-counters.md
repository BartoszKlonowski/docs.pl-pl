---
title: EventCounters na platformie .NET Core
description: W tym artykule dowiesz się, co EventCounters, jak je wdrożyć i jak je wykorzystać.
ms.date: 08/07/2020
ms.openlocfilehash: 212cd6b495785dcd091187f97a1b5e44e5597a4a
ms.sourcegitcommit: 34968a61e9bac0f6be23ed6ffb837f52d2390c85
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/17/2020
ms.locfileid: "94687645"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="6eea0-103">EventCounters na platformie .NET Core</span><span class="sxs-lookup"><span data-stu-id="6eea0-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="6eea0-104">**Ten artykuł ma zastosowanie do: ✔️** .net Core 3,0 SDK i nowszych wersjach</span><span class="sxs-lookup"><span data-stu-id="6eea0-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="6eea0-105">EventCounters to interfejsy API platformy .NET Core używane dla lekkiej, międzyplatformowej i niemal w czasie rzeczywistym zbierania metryk wydajności.</span><span class="sxs-lookup"><span data-stu-id="6eea0-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="6eea0-106">EventCounters zostały dodane jako alternatywa dla wielu platform dla "liczników wydajności" .NET Framework w systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="6eea0-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="6eea0-107">W tym artykule dowiesz się, co EventCounters, jak je wdrożyć i jak je wykorzystać.</span><span class="sxs-lookup"><span data-stu-id="6eea0-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="6eea0-108">Środowisko uruchomieniowe platformy .NET Core i kilka bibliotek .NET publikują podstawowe informacje diagnostyczne przy użyciu EventCounters, począwszy od platformy .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="6eea0-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="6eea0-109">Oprócz EventCounters, które są dostarczane przez środowisko uruchomieniowe platformy .NET, można zaimplementować swój własny EventCounters.</span><span class="sxs-lookup"><span data-stu-id="6eea0-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="6eea0-110">EventCounters może służyć do śledzenia różnych metryk.</span><span class="sxs-lookup"><span data-stu-id="6eea0-110">EventCounters can be used to track various metrics.</span></span>

<span data-ttu-id="6eea0-111">EventCounters na żywo jako część <xref:System.Diagnostics.Tracing.EventSource> i są automatycznie wypychane do narzędzi odbiornika.</span><span class="sxs-lookup"><span data-stu-id="6eea0-111">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="6eea0-112">Podobnie jak w przypadku wszystkich innych zdarzeń w <xref:System.Diagnostics.Tracing.EventSource> , mogą one być używane zarówno w procesie, jak i na zewnątrz w procesie za pośrednictwem <xref:System.Diagnostics.Tracing.EventListener> i [EventPipe](./eventpipe.md).</span><span class="sxs-lookup"><span data-stu-id="6eea0-112">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and [EventPipe](./eventpipe.md).</span></span> <span data-ttu-id="6eea0-113">Ten artykuł koncentruje się na funkcjach EventCounters i celowo wyklucza narzędzia PerfView i funkcję ETW (śledzenie zdarzeń dla systemu Windows), chociaż oba mogą być używane z EventCounters.</span><span class="sxs-lookup"><span data-stu-id="6eea0-113">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Obraz przedstawiający diagram w procesie EventCounters i out-of-proc](media/event-counters.svg)

[!INCLUDE [available-counters](includes/available-counters.md)]

## <a name="eventcounter-api-overview"></a><span data-ttu-id="6eea0-115">Przegląd interfejsu API EventCounter</span><span class="sxs-lookup"><span data-stu-id="6eea0-115">EventCounter API overview</span></span>

<span data-ttu-id="6eea0-116">Istnieją dwie podstawowe kategorie liczników.</span><span class="sxs-lookup"><span data-stu-id="6eea0-116">There are two primary categories of counters.</span></span> <span data-ttu-id="6eea0-117">Niektóre liczniki są przeznaczone do wartości "rate", takich jak łączna liczba wyjątków, Łączna liczba operacje odzyskiwania pamięci i łączna liczba żądań.</span><span class="sxs-lookup"><span data-stu-id="6eea0-117">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="6eea0-118">Inne liczniki to wartości "snapshot", takie jak użycie sterty, użycie procesora CPU i rozmiar zestawu roboczego.</span><span class="sxs-lookup"><span data-stu-id="6eea0-118">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="6eea0-119">W ramach każdej z tych kategorii liczników istnieją dwa typy liczników, które różnią się w zależności od ich wartości.</span><span class="sxs-lookup"><span data-stu-id="6eea0-119">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="6eea0-120">Liczniki sondowania pobierają ich wartości za pośrednictwem wywołania zwrotnego, a liczniki bez sondowania mają swoje wartości bezpośrednio ustawione w wystąpieniu licznika.</span><span class="sxs-lookup"><span data-stu-id="6eea0-120">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="6eea0-121">Liczniki są reprezentowane przez następujące implementacje:</span><span class="sxs-lookup"><span data-stu-id="6eea0-121">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="6eea0-122">Odbiornik zdarzeń określa, jak długo są interwały pomiaru.</span><span class="sxs-lookup"><span data-stu-id="6eea0-122">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="6eea0-123">Na końcu każdego interwału wartość jest przekazywana do odbiornika dla każdego licznika.</span><span class="sxs-lookup"><span data-stu-id="6eea0-123">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="6eea0-124">Implementacje licznika określają, jakie interfejsy API i obliczenia są używane do tworzenia wartości każdego interwału.</span><span class="sxs-lookup"><span data-stu-id="6eea0-124">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="6eea0-125"><xref:System.Diagnostics.Tracing.EventCounter>Rejestruje zbiór wartości.</span><span class="sxs-lookup"><span data-stu-id="6eea0-125">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="6eea0-126"><xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType>Metoda dodaje nową wartość do zestawu.</span><span class="sxs-lookup"><span data-stu-id="6eea0-126">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="6eea0-127">Dla każdego interwału obliczane jest podsumowanie statystyczne dla zestawu, takie jak min, Max i średnia.</span><span class="sxs-lookup"><span data-stu-id="6eea0-127">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="6eea0-128">W narzędziu [dotnet-Counters](dotnet-counters.md) zawsze będzie wyświetlana wartość średnia.</span><span class="sxs-lookup"><span data-stu-id="6eea0-128">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="6eea0-129"><xref:System.Diagnostics.Tracing.EventCounter>Jest to przydatne do opisywania dyskretnego zestawu operacji.</span><span class="sxs-lookup"><span data-stu-id="6eea0-129">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="6eea0-130">Typowym użyciem może być monitorowanie średniego rozmiaru w bajtach ostatnich operacji we/wy lub średniej wartości pieniężnej zestawu transakcji finansowych.</span><span class="sxs-lookup"><span data-stu-id="6eea0-130">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="6eea0-131"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Rejestruje sumę całkowitą dla każdego przedziału czasu.</span><span class="sxs-lookup"><span data-stu-id="6eea0-131">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="6eea0-132"><xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType>Metoda dodaje do sumy.</span><span class="sxs-lookup"><span data-stu-id="6eea0-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="6eea0-133">Na przykład, jeśli `Increment()` jest wywoływana trzy razy w jednym interwale z wartościami `1` , `2` , i `5` , wówczas suma uruchomiona wartości `8` będzie raportowana jako wartość licznika dla tego interwału.</span><span class="sxs-lookup"><span data-stu-id="6eea0-133">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="6eea0-134">W narzędziu [dotnet-Counters](dotnet-counters.md) zostanie wyświetlona stawka jako nagrana suma/czas.</span><span class="sxs-lookup"><span data-stu-id="6eea0-134">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="6eea0-135"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Jest to przydatne do mierzenia, jak często występuje akcja, na przykład liczby żądań przetwarzanych na sekundę.</span><span class="sxs-lookup"><span data-stu-id="6eea0-135">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="6eea0-136"><xref:System.Diagnostics.Tracing.PollingCounter>Używa wywołania zwrotnego do określenia wartości, która jest raportowana.</span><span class="sxs-lookup"><span data-stu-id="6eea0-136">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="6eea0-137">Za każdym razem, gdy jest wywoływana funkcja wywołania zwrotnego użytkownika, a zwracana wartość jest używana jako wartość licznika.</span><span class="sxs-lookup"><span data-stu-id="6eea0-137">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="6eea0-138"><xref:System.Diagnostics.Tracing.PollingCounter>Program może służyć do wykonywania zapytań dotyczących metryki z zewnętrznego źródła, na przykład przy pobieraniu bieżących bajtów wolnego miejsca na dysku.</span><span class="sxs-lookup"><span data-stu-id="6eea0-138">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="6eea0-139">Może on również służyć do raportowania niestandardowych statystyk, które mogą być obliczane na żądanie przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="6eea0-139">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="6eea0-140">Przykłady obejmują raportowanie używany 95. percentylu ostatnich opóźnień żądań lub bieżącego współczynnika trafień lub chybień pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="6eea0-140">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="6eea0-141"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter>Używa wywołania zwrotnego, aby określić raportowaną wartość przyrostu.</span><span class="sxs-lookup"><span data-stu-id="6eea0-141">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="6eea0-142">Za każdym razem interwał wywołania zwrotnego jest wywoływany, a następnie różnica między bieżącym wywołaniem a ostatnim wywołaniem jest raportowaną wartością.</span><span class="sxs-lookup"><span data-stu-id="6eea0-142">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="6eea0-143">W narzędziu [dotnet-Counters](dotnet-counters.md) zawsze będzie wyświetlana różnica w postaci stawki, zgłoszonej wartości/godziny.</span><span class="sxs-lookup"><span data-stu-id="6eea0-143">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="6eea0-144">Ten licznik jest przydatny, gdy nie jest możliwe wywołanie interfejsu API dla każdego wystąpienia, ale możliwe jest zbadanie łącznej liczby wystąpień.</span><span class="sxs-lookup"><span data-stu-id="6eea0-144">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="6eea0-145">Można na przykład zgłosić liczbę bajtów zapisanych do pliku na sekundę, nawet bez powiadomienia za każdym razem, gdy zostanie zapisany bajt.</span><span class="sxs-lookup"><span data-stu-id="6eea0-145">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="6eea0-146">Implementowanie elementu EventSource</span><span class="sxs-lookup"><span data-stu-id="6eea0-146">Implement an EventSource</span></span>

<span data-ttu-id="6eea0-147">Poniższy kod implementuje przykład <xref:System.Diagnostics.Tracing.EventSource> uwidoczniony jako nazwany `"Sample.EventCounter.Minimal"` dostawca.</span><span class="sxs-lookup"><span data-stu-id="6eea0-147">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="6eea0-148">To źródło zawiera <xref:System.Diagnostics.Tracing.EventCounter> czas przetwarzania żądania.</span><span class="sxs-lookup"><span data-stu-id="6eea0-148">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="6eea0-149">Taki licznik ma nazwę (czyli jego unikatowy identyfikator w źródle) i nazwę wyświetlaną używaną przez narzędzia odbiornika, takie jak [dotnet-Counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="6eea0-149">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="6eea0-150">Służy `dotnet-counters ps` do wyświetlania listy procesów platformy .NET, które mogą być monitorowane:</span><span class="sxs-lookup"><span data-stu-id="6eea0-150">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="6eea0-151">Przekaż <xref:System.Diagnostics.Tracing.EventSource> nazwę do przełącznika, `counter_list` Aby rozpocząć monitorowanie licznika:</span><span class="sxs-lookup"><span data-stu-id="6eea0-151">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `counter_list` switch to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 Sample.EventCounter.Minimal
```

<span data-ttu-id="6eea0-152">Poniższy przykład przedstawia dane wyjściowe monitora:</span><span class="sxs-lookup"><span data-stu-id="6eea0-152">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="6eea0-153">Naciśnij pozycję <kbd>q</kbd> , aby zatrzymać polecenie monitorowania.</span><span class="sxs-lookup"><span data-stu-id="6eea0-153">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="6eea0-154">Liczniki warunkowe</span><span class="sxs-lookup"><span data-stu-id="6eea0-154">Conditional counters</span></span>

<span data-ttu-id="6eea0-155">Podczas wdrażania klasy <xref:System.Diagnostics.Tracing.EventSource> zawierającej liczniki można warunkowo utworzyć wystąpienie, gdy <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> Metoda jest wywoływana z <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> wartością `EventCommand.Enable` .</span><span class="sxs-lookup"><span data-stu-id="6eea0-155">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="6eea0-156">Aby bezpiecznie utworzyć wystąpienie wystąpienia licznika tylko wtedy, gdy jest to możliwe `null` , użyj [operatora przypisania łączenia z wartością null](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="6eea0-156">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="6eea0-157">Ponadto metody niestandardowe mogą oszacować metodę, <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> Aby określić, czy bieżące źródło zdarzeń jest włączone.</span><span class="sxs-lookup"><span data-stu-id="6eea0-157">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="6eea0-158">Liczniki warunkowe są licznikami, które są warunkowo tworzone, a mikro Optymalizacja.</span><span class="sxs-lookup"><span data-stu-id="6eea0-158">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="6eea0-159">Środowisko uruchomieniowe przyjmuje ten wzorzec dla scenariuszy, w których liczniki nie są zwykle używane, aby zaoszczędzić część milisekundy.</span><span class="sxs-lookup"><span data-stu-id="6eea0-159">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="6eea0-160">Przykładowe liczniki środowiska uruchomieniowego platformy .NET Core</span><span class="sxs-lookup"><span data-stu-id="6eea0-160">.NET Core runtime example counters</span></span>

<span data-ttu-id="6eea0-161">Środowisko uruchomieniowe platformy .NET Core zawiera wiele doskonałych przykładowych implementacji.</span><span class="sxs-lookup"><span data-stu-id="6eea0-161">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="6eea0-162">Oto implementacja środowiska uruchomieniowego dla licznika, który śledzi rozmiar zestawu roboczego aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6eea0-162">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="6eea0-163"><xref:System.Diagnostics.Tracing.PollingCounter>Raport przedstawia bieżącą ilość pamięci fizycznej zamapowanej na proces (zestaw roboczy) aplikacji, ponieważ w momencie przechwytuje ona metrykę.</span><span class="sxs-lookup"><span data-stu-id="6eea0-163">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="6eea0-164">Wywołanie zwrotne do sondowania wartości jest podanym wyrażeniem lambda, które jest tylko wywołaniem <xref:System.Environment.WorkingSet?displayProperty=fullName> interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6eea0-164">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="6eea0-165"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> i <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> są opcjonalnymi właściwościami, które można ustawić, aby ułatwić konsumentowi licznika Wyświetlanie wartości dokładniej.</span><span class="sxs-lookup"><span data-stu-id="6eea0-165"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="6eea0-166">Na przykład, program [dotnet-Counters](dotnet-counters.md) używa tych właściwości do wyświetlania większej przyjaznej dla wyświetlania wersji nazw liczników.</span><span class="sxs-lookup"><span data-stu-id="6eea0-166">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="6eea0-167">`DisplayName`Właściwości nie są zlokalizowane.</span><span class="sxs-lookup"><span data-stu-id="6eea0-167">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="6eea0-168">W przypadku <xref:System.Diagnostics.Tracing.PollingCounter> <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> elementów i nic nie trzeba wykonywać żadnych innych czynności.</span><span class="sxs-lookup"><span data-stu-id="6eea0-168">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="6eea0-169">Oba te wartości są sondowane w przedziale czasowym żądanym przez klienta.</span><span class="sxs-lookup"><span data-stu-id="6eea0-169">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="6eea0-170">Oto przykład licznika czasu wykonywania zaimplementowanego przy użyciu <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> .</span><span class="sxs-lookup"><span data-stu-id="6eea0-170">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="6eea0-171"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter>Używa <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> interfejsu API do raportowania przyrostu całkowitej liczby rywalizacji o blokadę.</span><span class="sxs-lookup"><span data-stu-id="6eea0-171">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="6eea0-172"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale>Właściwość jest opcjonalna, ale jeśli jest używana, może zapewnić wskazówkę dotyczącą interwału czasu, w którym licznik jest najlepiej wyświetlany.</span><span class="sxs-lookup"><span data-stu-id="6eea0-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="6eea0-173">Na przykład liczba rywalizacji blokad jest najlepiej wyświetlana jako _Liczba na sekundę_, więc jej <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> wartość jest równa jednej sekundzie.</span><span class="sxs-lookup"><span data-stu-id="6eea0-173">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="6eea0-174">Współczynnik wyświetlania można dopasować dla różnych typów liczników szybkości.</span><span class="sxs-lookup"><span data-stu-id="6eea0-174">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="6eea0-175"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> _Nie_ jest używany przez program [dotnet-Counters](dotnet-counters.md), a detektory zdarzeń nie są wymagane do korzystania z niego.</span><span class="sxs-lookup"><span data-stu-id="6eea0-175">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="6eea0-176">Istnieje więcej implementacji liczników do użycia jako odwołanie w repozytorium [środowiska uruchomieniowego platformy .NET](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) .</span><span class="sxs-lookup"><span data-stu-id="6eea0-176">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="6eea0-177">Współbieżność</span><span class="sxs-lookup"><span data-stu-id="6eea0-177">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="6eea0-178">Interfejs API EventCounters nie gwarantuje bezpieczeństwa wątków.</span><span class="sxs-lookup"><span data-stu-id="6eea0-178">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="6eea0-179">Gdy Delegaty przechodzą do <xref:System.Diagnostics.Tracing.PollingCounter> lub <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> wystąpienia są wywoływane przez wiele wątków, odpowiedzialność za zagwarantowanie bezpieczeństwa wątków delegatów.</span><span class="sxs-lookup"><span data-stu-id="6eea0-179">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="6eea0-180">Rozważmy na przykład następujące, <xref:System.Diagnostics.Tracing.EventSource> Aby śledzić żądania.</span><span class="sxs-lookup"><span data-stu-id="6eea0-180">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="6eea0-181">`AddRequest()`Metodę można wywołać z procedury obsługi żądań, a następnie `RequestRateCounter` sonduje wartość w interwale określonym przez odbiorcę licznika.</span><span class="sxs-lookup"><span data-stu-id="6eea0-181">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="6eea0-182">Jednak `AddRequest()` Metoda może być wywoływana przez wiele wątków jednocześnie, co w przypadku wystąpienia warunku `_requestCount` .</span><span class="sxs-lookup"><span data-stu-id="6eea0-182">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="6eea0-183">Bezpieczny wątkowo alternatywny sposób, aby zwiększyć `_requestCount` użycie <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="6eea0-183">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="6eea0-184">Aby zapobiec rozdartym odczytom (na 32-bitowych architekturach) `long` `_requestCount` użycia pola <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="6eea0-184">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="6eea0-185">Korzystanie z EventCounters</span><span class="sxs-lookup"><span data-stu-id="6eea0-185">Consume EventCounters</span></span>

<span data-ttu-id="6eea0-186">Istnieją dwa podstawowe sposoby używania EventCounters, w ramach procesu lub out-of-proc.</span><span class="sxs-lookup"><span data-stu-id="6eea0-186">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="6eea0-187">Użycie EventCounters można podzielić na trzy warstwy różnych zużywanych technologii.</span><span class="sxs-lookup"><span data-stu-id="6eea0-187">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="6eea0-188">Transportowanie zdarzeń w strumieniu nieprzetworzonym za pośrednictwem funkcji ETW lub EventPipe:</span><span class="sxs-lookup"><span data-stu-id="6eea0-188">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="6eea0-189">Interfejsy API ETW są dostarczane z systemem operacyjnym Windows, a EventPipe jest dostępny jako [interfejs API platformy .NET](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console)lub diagnostyczny [Protokół IPC](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span><span class="sxs-lookup"><span data-stu-id="6eea0-189">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="6eea0-190">Dekodowanie strumienia zdarzeń binarnych do zdarzeń:</span><span class="sxs-lookup"><span data-stu-id="6eea0-190">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="6eea0-191">[Biblioteka zdarzenie śledzenia](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) obsługuje zarówno formaty strumieni ETW, jak i EventPipe.</span><span class="sxs-lookup"><span data-stu-id="6eea0-191">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="6eea0-192">Narzędzia wiersza polecenia i graficznego interfejsu użytkownika:</span><span class="sxs-lookup"><span data-stu-id="6eea0-192">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="6eea0-193">Narzędzia takie jak narzędzia PerfView (ETW lub EventPipe), dotnet-Counters (tylko EventPipe) i monitor dotnet (tylko EventPipe).</span><span class="sxs-lookup"><span data-stu-id="6eea0-193">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="6eea0-194">Korzystanie z zewnątrz procesu</span><span class="sxs-lookup"><span data-stu-id="6eea0-194">Consume out-of-proc</span></span>

<span data-ttu-id="6eea0-195">Korzystanie z EventCounters out-of-proc jest bardzo typowym podejściem.</span><span class="sxs-lookup"><span data-stu-id="6eea0-195">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="6eea0-196">Za pomocą programu [dotnet-Counters](dotnet-counters.md) można korzystać na wielu platformach za pośrednictwem EventPipe.</span><span class="sxs-lookup"><span data-stu-id="6eea0-196">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="6eea0-197">To `dotnet-counters` Narzędzie jest globalnym narzędziem interfejsu wiersza polecenia dotnet dla wielu platform, które może służyć do monitorowania wartości liczników.</span><span class="sxs-lookup"><span data-stu-id="6eea0-197">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="6eea0-198">Aby dowiedzieć się, jak używać `dotnet-counters` do monitorowania liczników, zobacz [dotnet-Counters](dotnet-counters.md)lub pracuj przez [wydajność miary za pomocą](event-counter-perf.md) samouczka EventCounters.</span><span class="sxs-lookup"><span data-stu-id="6eea0-198">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="6eea0-199">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="6eea0-199">dotnet-trace</span></span>

<span data-ttu-id="6eea0-200">`dotnet-trace`Za pomocą tego narzędzia można korzystać z danych licznika przez EventPipe.</span><span class="sxs-lookup"><span data-stu-id="6eea0-200">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="6eea0-201">Oto przykład użycia `dotnet-trace` do zbierania danych licznika.</span><span class="sxs-lookup"><span data-stu-id="6eea0-201">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="6eea0-202">Aby uzyskać więcej informacji na temat zbierania wartości licznika w czasie, zobacz dokumentację [śledzenia dotnet](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) .</span><span class="sxs-lookup"><span data-stu-id="6eea0-202">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="6eea0-203">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="6eea0-203">Azure Application Insights</span></span>

<span data-ttu-id="6eea0-204">EventCounters mogą być używane przez Azure Monitor, w tym Application Insights platformy Azure.</span><span class="sxs-lookup"><span data-stu-id="6eea0-204">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="6eea0-205">Liczniki można dodawać i usuwać oraz korzystać z nich, aby można było określić liczniki niestandardowe lub dobrze znane liczniki.</span><span class="sxs-lookup"><span data-stu-id="6eea0-205">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="6eea0-206">Aby uzyskać więcej informacji, zobacz [Dostosowywanie liczników do zebrania](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="6eea0-206">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="6eea0-207">dotnet-monitor</span><span class="sxs-lookup"><span data-stu-id="6eea0-207">dotnet-monitor</span></span>

<span data-ttu-id="6eea0-208">`dotnet-monitor`Narzędzie to eksperymentalne narzędzie, które ułatwia uzyskiwanie dostępu do informacji diagnostycznych w procesie platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="6eea0-208">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="6eea0-209">Narzędzie służy jako nadzbiór wszystkich narzędzi diagnostycznych.</span><span class="sxs-lookup"><span data-stu-id="6eea0-209">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="6eea0-210">Oprócz śledzenia można monitorować metryki, zbierać zrzuty pamięci i zbierać zrzuty GC.</span><span class="sxs-lookup"><span data-stu-id="6eea0-210">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="6eea0-211">Jest dystrybuowany jako narzędzie interfejsu wiersza polecenia i obraz platformy Docker.</span><span class="sxs-lookup"><span data-stu-id="6eea0-211">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="6eea0-212">Udostępnia interfejs API REST, a kolekcja artefaktów diagnostycznych odbywa się za pomocą wywołań REST.</span><span class="sxs-lookup"><span data-stu-id="6eea0-212">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="6eea0-213">Aby uzyskać więcej informacji, zobacz [wprowadzenie do monitora dotnet-monitor, narzędzia eksperymentalne](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="6eea0-213">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="6eea0-214">Używanie w procesie</span><span class="sxs-lookup"><span data-stu-id="6eea0-214">Consume in-proc</span></span>

<span data-ttu-id="6eea0-215">Można korzystać z wartości licznika za pośrednictwem <xref:System.Diagnostics.Tracing.EventListener> interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="6eea0-215">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="6eea0-216"><xref:System.Diagnostics.Tracing.EventListener>Jest to wewnątrzprocesowy sposób zużywania wszelkich zdarzeń, które są zapisywane przez wszystkie wystąpienia <xref:System.Diagnostics.Tracing.EventSource> w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6eea0-216">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="6eea0-217">Aby uzyskać więcej informacji na temat korzystania z `EventListener` interfejsu API, zobacz <xref:System.Diagnostics.Tracing.EventListener> .</span><span class="sxs-lookup"><span data-stu-id="6eea0-217">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="6eea0-218">Najpierw należy <xref:System.Diagnostics.Tracing.EventSource> włączyć wartość licznika.</span><span class="sxs-lookup"><span data-stu-id="6eea0-218">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="6eea0-219">Zastąp <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> metodę, aby otrzymać powiadomienie, gdy <xref:System.Diagnostics.Tracing.EventSource> zostanie utworzony, a jeśli jest to poprawne <xref:System.Diagnostics.Tracing.EventSource> w EventCounters, możesz je wywoływać <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="6eea0-219">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="6eea0-220">Oto przykładowe przesłonięcie:</span><span class="sxs-lookup"><span data-stu-id="6eea0-220">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="16-27":::

#### <a name="sample-code"></a><span data-ttu-id="6eea0-221">Przykładowy kod</span><span class="sxs-lookup"><span data-stu-id="6eea0-221">Sample code</span></span>

<span data-ttu-id="6eea0-222">Poniżej znajduje się przykładowa <xref:System.Diagnostics.Tracing.EventListener> Klasa, która drukuje wszystkie nazwy liczników i wartości z środowiska uruchomieniowego platformy .NET <xref:System.Diagnostics.Tracing.EventSource> , aby opublikować jego liczniki wewnętrzne ( `System.Runtime` ) w pewnym interwale.</span><span class="sxs-lookup"><span data-stu-id="6eea0-222">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) at some interval.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="6eea0-223">Jak pokazano powyżej, _należy_ upewnić się, że `"EventCounterIntervalSec"` argument jest ustawiony w `filterPayload` argumencie podczas wywoływania <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A> .</span><span class="sxs-lookup"><span data-stu-id="6eea0-223">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="6eea0-224">W przeciwnym razie liczniki nie będą mogły opróżniać wartości, ponieważ nie wie, z jakim interwałem należy uzyskać opróżnianie.</span><span class="sxs-lookup"><span data-stu-id="6eea0-224">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="6eea0-225">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="6eea0-225">See also</span></span>

- [<span data-ttu-id="6eea0-226">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="6eea0-226">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="6eea0-227">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="6eea0-227">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
