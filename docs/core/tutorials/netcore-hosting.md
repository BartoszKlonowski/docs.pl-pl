---
title: Napisz niestandardowego hosta środowiska uruchomieniowego platformy .NET Core
description: Dowiedz się, jak hostować środowisko uruchomieniowe platformy .NET Core z kodu natywnego, aby obsługiwać zaawansowane scenariusze, które wymagają kontrolowania sposobu działania środowiska uruchomieniowego .NET Core.
author: mjrousos
ms.topic: how-to
ms.date: 12/21/2018
ms.openlocfilehash: 380bfb3aa5e5715fe95e0d7772700bac9ab4a5be
ms.sourcegitcommit: ff5a4eb5cffbcac9521bc44a907a118cd7e8638d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/17/2020
ms.locfileid: "92160987"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="0ec4a-103">Napisz niestandardowego hosta .NET Core, aby kontrolować środowisko uruchomieniowe platformy .NET z kodu natywnego</span><span class="sxs-lookup"><span data-stu-id="0ec4a-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="0ec4a-104">Podobnie jak w przypadku wszystkich kodów zarządzanych, aplikacje platformy .NET Core są wykonywane przez hosta.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="0ec4a-105">Host jest odpowiedzialny za uruchamianie środowiska uruchomieniowego (w tym składników, takich jak moduł odzyskiwania JIT i elementów bezużytecznych) i wywoływanie zarządzanych punktów wejścia.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector) and invoking managed entry points.</span></span>

<span data-ttu-id="0ec4a-106">Hostowanie środowiska uruchomieniowego .NET Core jest zaawansowanym scenariuszem, a w większości przypadków Deweloperzy platformy .NET Core nie muszą martwić się o hosting, ponieważ procesy kompilacji platformy .NET Core udostępniają domyślny Host do uruchamiania aplikacji platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="0ec4a-107">W niektórych wyspecjalizowanych sytuacjach może być przydatne jawne hostowanie środowiska uruchomieniowego platformy .NET Core jako metody wywoływania kodu zarządzanego w procesie macierzystym lub w celu uzyskania większej kontroli nad sposobem działania środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="0ec4a-108">Ten artykuł zawiera omówienie kroków niezbędnych do uruchomienia środowiska uruchomieniowego platformy .NET Core z kodu natywnego i wykonywania w nim kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="0ec4a-109">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="0ec4a-109">Prerequisites</span></span>

<span data-ttu-id="0ec4a-110">Ponieważ hosty są aplikacjami natywnymi, ten samouczek obejmuje konstruowanie aplikacji C++ do hostowania programu .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-110">Because hosts are native applications, this tutorial covers constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="0ec4a-111">Konieczne będzie środowisko deweloperskie języka C++ (takie jak dostarczone przez [program Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="0ec4a-112">Ponadto potrzebna jest prosta aplikacja .NET Core do testowania hosta za pomocą programu, dlatego należy zainstalować [zestaw .NET Core SDK](https://dotnet.microsoft.com/download) i [utworzyć małą aplikację .NET Core test](with-visual-studio.md) (na przykład aplikację "Hello World").</span><span class="sxs-lookup"><span data-stu-id="0ec4a-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://dotnet.microsoft.com/download) and [build a small .NET Core test app](with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="0ec4a-113">Wystarczy aplikacja "Hello world" utworzona przy użyciu nowego szablonu projektu konsoli .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

## <a name="hosting-apis"></a><span data-ttu-id="0ec4a-114">Hostowanie interfejsów API</span><span class="sxs-lookup"><span data-stu-id="0ec4a-114">Hosting APIs</span></span>

<span data-ttu-id="0ec4a-115">Istnieją dwa różne interfejsy API, których można używać do hostowania programu .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-115">There are two different APIs that can be used to host .NET Core.</span></span> <span data-ttu-id="0ec4a-116">Ten artykuł (wraz ze skojarzonymi z nim [przykłady](https://github.com/dotnet/samples/tree/master/core/hosting)) obejmuje te dwie opcje.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-116">This article (and its associated [samples](https://github.com/dotnet/samples/tree/master/core/hosting)) covers these 2 options.</span></span>

* <span data-ttu-id="0ec4a-117">Preferowaną metodą hostowania środowiska uruchomieniowego .NET Core w programie .NET Core 3,0 i nowszym jest `nethost` `hostfxr` interfejs API bibliotek i.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-117">The preferred method of hosting the .NET Core runtime in .NET Core 3.0 and above is with the `nethost` and `hostfxr` libraries' APIs.</span></span> <span data-ttu-id="0ec4a-118">Te punkty wejścia obsługują złożoność znajdowania i konfigurowania środowiska uruchomieniowego na potrzeby inicjowania oraz umożliwiają uruchamianie aplikacji zarządzanej i wywoływanie jej w statycznej metodzie zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-118">These entry points handle the complexity of finding and setting up the runtime for initialization and allow both launching a managed application and calling into a static managed method.</span></span>
* <span data-ttu-id="0ec4a-119">Preferowaną metodą hostowania środowiska uruchomieniowego .NET Core przed programem .NET Core 3,0 jest [`coreclrhost.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/hosts/inc/coreclrhost.h) interfejs API.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-119">The preferred method of hosting the .NET Core runtime prior to .NET Core 3.0 is with the [`coreclrhost.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/hosts/inc/coreclrhost.h) API.</span></span> <span data-ttu-id="0ec4a-120">Ten interfejs API udostępnia funkcje ułatwiające uruchamianie i zatrzymywanie środowiska uruchomieniowego oraz Wywoływanie kodu zarządzanego (przez uruchomienie zarządzanego pliku exe lub poprzez wywoływanie statycznych metod zarządzanych).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-120">This API exposes functions for easily starting and stopping the runtime and invoking managed code (either by launching a managed exe or by calling static managed methods).</span></span>

## <a name="sample-hosts"></a><span data-ttu-id="0ec4a-121">Przykładowe hosty</span><span class="sxs-lookup"><span data-stu-id="0ec4a-121">Sample Hosts</span></span>

<span data-ttu-id="0ec4a-122">[Przykładowe hosty](https://github.com/dotnet/samples/tree/master/core/hosting) pokazujące kroki opisane w poniższych samouczkach są dostępne w repozytorium GitHub/Samples.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-122">[Sample hosts](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in the tutorials below are available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="0ec4a-123">Komentarze w przykładach jasno kojarzą numerowane kroki z tych samouczków z miejscem, w którym są wykonywane w próbce.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-123">Comments in the samples clearly associate the numbered steps from these tutorials with where they're performed in the sample.</span></span> <span data-ttu-id="0ec4a-124">Aby uzyskać instrukcje dotyczące pobierania, zobacz [przykłady i samouczki](../../samples-and-tutorials/index.md#view-and-download-samples).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-124">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#view-and-download-samples).</span></span>

<span data-ttu-id="0ec4a-125">Należy pamiętać, że przykładowe hosty są przeznaczone do celów edukacyjnych, dzięki czemu są one jasne przy sprawdzaniu błędów i zostały zaprojektowane w celu wyróżnienia czytelności przez zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-125">Keep in mind that the sample hosts are meant to be used for learning purposes, so they are light on error checking and are designed to emphasize readability over efficiency.</span></span>

## <a name="create-a-host-using-nethosth-and-hostfxrh"></a><span data-ttu-id="0ec4a-126">Tworzenie hosta przy użyciu programu `nethost.h` i `hostfxr.h`</span><span class="sxs-lookup"><span data-stu-id="0ec4a-126">Create a host using `nethost.h` and `hostfxr.h`</span></span>

<span data-ttu-id="0ec4a-127">Poniższe kroki szczegółowo opisują sposób użycia `nethost` `hostfxr` bibliotek i do uruchomienia środowiska uruchomieniowego platformy .NET Core w aplikacji natywnej i wywołania do zarządzanej metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-127">The following steps detail how to use the `nethost` and `hostfxr` libraries to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="0ec4a-128">[Przykład](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) używa `nethost` nagłówka i biblioteki zainstalowanej z zestawem SDK .NET i kopii [`coreclr_delegates.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/coreclr_delegates.h) [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) plików i z repozytorium [dotnet/Runtime](https://github.com/dotnet/runtime) .</span><span class="sxs-lookup"><span data-stu-id="0ec4a-128">The [sample](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) uses the `nethost` header and library installed with the .NET SDK and copies of the [`coreclr_delegates.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/coreclr_delegates.h) and [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) files from the [dotnet/runtime](https://github.com/dotnet/runtime) repository.</span></span>

### <a name="step-1---load-hostfxr-and-get-exported-hosting-functions"></a><span data-ttu-id="0ec4a-129">Krok 1 — Ładowanie `hostfxr` i uzyskiwanie eksportowanych funkcji hostingu</span><span class="sxs-lookup"><span data-stu-id="0ec4a-129">Step 1 - Load `hostfxr` and get exported hosting functions</span></span>

<span data-ttu-id="0ec4a-130">`nethost`Biblioteka zawiera `get_hostfxr_path` funkcję do lokalizowania `hostfxr` biblioteki.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-130">The `nethost` library provides the `get_hostfxr_path` function for locating the `hostfxr` library.</span></span> <span data-ttu-id="0ec4a-131">`hostfxr`Biblioteka udostępnia funkcje do hostowania środowiska uruchomieniowego platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-131">The `hostfxr` library exposes functions for hosting the .NET Core runtime.</span></span> <span data-ttu-id="0ec4a-132">Pełną listę funkcji można znaleźć w [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) dokumencie, a [natywny dokument projektu hostingu](https://github.com/dotnet/runtime/blob/master/docs/design/features/native-hosting.md).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-132">The full list of functions can be found in [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) and the [native hosting design document](https://github.com/dotnet/runtime/blob/master/docs/design/features/native-hosting.md).</span></span> <span data-ttu-id="0ec4a-133">W przykładzie i w tym samouczku są używane następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="0ec4a-133">The sample and this tutorial use the following:</span></span>

* <span data-ttu-id="0ec4a-134">`hostfxr_initialize_for_runtime_config`: Inicjuje kontekst hosta i przygotowuje się do inicjalizacji środowiska uruchomieniowego platformy .NET Core przy użyciu określonej konfiguracji środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-134">`hostfxr_initialize_for_runtime_config`: Initializes a host context and prepares for initialization of the .NET Core runtime using the specified runtime configuration.</span></span>
* <span data-ttu-id="0ec4a-135">`hostfxr_get_runtime_delegate`: Pobiera obiekt delegowany dla funkcji środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-135">`hostfxr_get_runtime_delegate`: Gets a delegate for runtime functionality.</span></span>
* <span data-ttu-id="0ec4a-136">`hostfxr_close`: Zamyka kontekst hosta.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-136">`hostfxr_close`: Closes a host context.</span></span>

<span data-ttu-id="0ec4a-137">`hostfxr`Biblioteka zostanie znaleziona przy użyciu `get_hostfxr_path` .</span><span class="sxs-lookup"><span data-stu-id="0ec4a-137">The `hostfxr` library is found using `get_hostfxr_path`.</span></span> <span data-ttu-id="0ec4a-138">Następnie jest ładowany, a jego eksporty są pobierane.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-138">It is then loaded and its exports are retrieved.</span></span>

[!code-cpp[HostFxrHost#LoadHostFxr](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadHostFxr)]

### <a name="step-2---initialize-and-start-the-net-core-runtime"></a><span data-ttu-id="0ec4a-139">Krok 2 — Inicjowanie i uruchamianie środowiska uruchomieniowego platformy .NET Core</span><span class="sxs-lookup"><span data-stu-id="0ec4a-139">Step 2 - Initialize and start the .NET Core runtime</span></span>

<span data-ttu-id="0ec4a-140">`hostfxr_initialize_for_runtime_config`Funkcje i `hostfxr_get_runtime_delegate` inicjują i uruchamiają środowisko uruchomieniowe platformy .NET Core przy użyciu konfiguracji środowiska uruchomieniowego zarządzanego składnika, który zostanie załadowany.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-140">The `hostfxr_initialize_for_runtime_config` and `hostfxr_get_runtime_delegate` functions initialize and start the .NET Core runtime using the runtime configuration for the managed component that will be loaded.</span></span> <span data-ttu-id="0ec4a-141">`hostfxr_get_runtime_delegate`Funkcja służy do uzyskania delegata środowiska uruchomieniowego, który umożliwia ładowanie zestawu zarządzanego i uzyskiwanie wskaźnika funkcji do statycznej metody w tym zestawie.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-141">The `hostfxr_get_runtime_delegate` function is used to get a runtime delegate that allows loading a managed assembly and getting a function pointer to a static method in that assembly.</span></span>

[!code-cpp[HostFxrHost#Initialize](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#Initialize)]

### <a name="step-3---load-managed-assembly-and-get-function-pointer-to-a-managed-method"></a><span data-ttu-id="0ec4a-142">Krok 3. Załaduj zestaw zarządzany i Pobierz wskaźnik funkcji do metody zarządzanej</span><span class="sxs-lookup"><span data-stu-id="0ec4a-142">Step 3 - Load managed assembly and get function pointer to a managed method</span></span>

<span data-ttu-id="0ec4a-143">Delegat środowiska uruchomieniowego jest wywoływany, aby załadować zestaw zarządzany i uzyskać wskaźnik funkcji do metody zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-143">The runtime delegate is called to load the managed assembly and get a function pointer to a managed method.</span></span> <span data-ttu-id="0ec4a-144">Delegat wymaga ścieżki zestawu, nazwy typu i nazwy metody jako danych wejściowych i zwraca wskaźnik funkcji, którego można użyć do wywołania metody zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-144">The delegate requires the assembly path, type name, and method name as inputs and returns a function pointer that can be used to invoke the managed method.</span></span>

[!code-cpp[HostFxrHost#LoadAndGet](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadAndGet)]

<span data-ttu-id="0ec4a-145">Przekazując `nullptr` jako nazwę typu delegata podczas wywoływania delegata środowiska uruchomieniowego, przykład używa sygnatury domyślnej dla metody zarządzanej:</span><span class="sxs-lookup"><span data-stu-id="0ec4a-145">By passing `nullptr` as the delegate type name when calling the runtime delegate, the sample uses a default signature for the managed method:</span></span>

```csharp
public delegate int ComponentEntryPoint(IntPtr args, int sizeBytes);
```

<span data-ttu-id="0ec4a-146">Można użyć innej sygnatury, określając nazwę typu delegata podczas wywoływania delegata środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-146">A different signature can be used by specifying the delegate type name when calling the runtime delegate.</span></span>

### <a name="step-4---run-managed-code"></a><span data-ttu-id="0ec4a-147">Krok 4. uruchamianie kodu zarządzanego!</span><span class="sxs-lookup"><span data-stu-id="0ec4a-147">Step 4 - Run managed code!</span></span>

<span data-ttu-id="0ec4a-148">Host macierzysty może teraz wywołać metodę zarządzaną i przekazać do niej odpowiednie parametry.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-148">The native host can now call the managed method and pass it the desired parameters.</span></span>

[!code-cpp[HostFxrHost#CallManaged](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#CallManaged)]

## <a name="create-a-host-using-coreclrhosth"></a><span data-ttu-id="0ec4a-149">Tworzenie hosta za pomocą `coreclrhost.h`</span><span class="sxs-lookup"><span data-stu-id="0ec4a-149">Create a host using `coreclrhost.h`</span></span>

<span data-ttu-id="0ec4a-150">Poniższe kroki szczegółowo opisują sposób użycia `coreclrhost.h` interfejsu API w celu uruchomienia środowiska uruchomieniowego .NET Core w aplikacji natywnej i wywołania do zarządzanej metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-150">The following steps detail how to use the `coreclrhost.h` API to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="0ec4a-151">Fragmenty kodu w tym dokumencie używają niektórych interfejsów API specyficznych dla systemu Windows, ale [pełny przykładowy Host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) pokazuje ścieżki kodu systemu Windows i Linux.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-151">The code snippets in this document use some Windows-specific APIs, but the [full sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) shows both Windows and Linux code paths.</span></span>

<span data-ttu-id="0ec4a-152">Host współdziałający w [systemie UNIX](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/unixcorerun) przedstawia bardziej skomplikowany, rzeczywisty przykład hostingu przy użyciu `coreclrhost.h` .</span><span class="sxs-lookup"><span data-stu-id="0ec4a-152">The [Unix CoreRun host](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/unixcorerun) shows a more complex, real-world example of hosting using `coreclrhost.h`.</span></span>

### <a name="step-1---find-and-load-coreclr"></a><span data-ttu-id="0ec4a-153">Krok 1 — Znajdowanie i ładowanie CoreCLR</span><span class="sxs-lookup"><span data-stu-id="0ec4a-153">Step 1 - Find and load CoreCLR</span></span>

<span data-ttu-id="0ec4a-154">Interfejsy API środowiska uruchomieniowego .NET Core są w *coreclr.dll* (w systemie Windows), w *libcoreclr.so* (w systemie Linux) lub w *Libcoreclr. DYLIB* (na macOS).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-154">The .NET Core runtime APIs are in *coreclr.dll* (on Windows), in *libcoreclr.so* (on Linux), or in *libcoreclr.dylib* (on macOS).</span></span> <span data-ttu-id="0ec4a-155">Pierwszym krokiem do hostowania programu .NET Core jest załadowanie biblioteki CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-155">The first step to hosting .NET Core is to load the CoreCLR library.</span></span> <span data-ttu-id="0ec4a-156">Niektóre hosty sonduje różne ścieżki lub używają parametrów wejściowych do znajdowania biblioteki, podczas gdy inni wiedzą, aby załadować ją z określonej ścieżki (obok hosta, na przykład lub z lokalizacji na całym komputerze).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-156">Some hosts probe different paths or use input parameters to find the library while others know to load it from a certain path (next to the host, for example, or from a machine-wide location).</span></span>

<span data-ttu-id="0ec4a-157">Po znalezieniu biblioteka jest załadowana do programu `LoadLibraryEx` (w systemie Windows) lub `dlopen` (na platformie Linux/macOS).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-157">Once found, the library is loaded with `LoadLibraryEx` (on Windows) or `dlopen` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#1](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#1)]

### <a name="step-2---get-net-core-hosting-functions"></a><span data-ttu-id="0ec4a-158">Krok 2. Uzyskiwanie funkcji hostingu platformy .NET Core</span><span class="sxs-lookup"><span data-stu-id="0ec4a-158">Step 2 - Get .NET Core hosting functions</span></span>

<span data-ttu-id="0ec4a-159">CoreClrHost ma kilka ważnych metod, które są przydatne do hostowania programu .NET Core:</span><span class="sxs-lookup"><span data-stu-id="0ec4a-159">CoreClrHost has several important methods useful for hosting .NET Core:</span></span>

* <span data-ttu-id="0ec4a-160">`coreclr_initialize`: Uruchamia środowisko uruchomieniowe programu .NET Core i konfiguruje domyślną (i tylko) domenę aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-160">`coreclr_initialize`: Starts the .NET Core runtime and sets up the default (and only) AppDomain.</span></span>
* <span data-ttu-id="0ec4a-161">`coreclr_execute_assembly`: Wykonuje zestaw zarządzany.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-161">`coreclr_execute_assembly`: Executes a managed assembly.</span></span>
* <span data-ttu-id="0ec4a-162">`coreclr_create_delegate`: Tworzy wskaźnik funkcji do metody zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-162">`coreclr_create_delegate`: Creates a function pointer to a managed method.</span></span>
* <span data-ttu-id="0ec4a-163">`coreclr_shutdown`: Zamyka środowisko uruchomieniowe platformy .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-163">`coreclr_shutdown`: Shuts down the .NET Core runtime.</span></span>
* <span data-ttu-id="0ec4a-164">`coreclr_shutdown_2`: Jak `coreclr_shutdown` , ale również Pobiera kod zakończenia kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-164">`coreclr_shutdown_2`: Like `coreclr_shutdown`, but also retrieves the managed code's exit code.</span></span>

<span data-ttu-id="0ec4a-165">Po załadowaniu biblioteki CoreCLR następnym krokiem jest uzyskanie odwołań do tych funkcji przy użyciu `GetProcAddress` systemu (w systemie Windows) lub `dlsym` (w systemie Linux/macOS).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-165">After loading the CoreCLR library, the next step is to get references to these functions using `GetProcAddress` (on Windows) or `dlsym` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#2](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#2)]

### <a name="step-3---prepare-runtime-properties"></a><span data-ttu-id="0ec4a-166">Krok 3 — Przygotowanie właściwości środowiska uruchomieniowego</span><span class="sxs-lookup"><span data-stu-id="0ec4a-166">Step 3 - Prepare runtime properties</span></span>

<span data-ttu-id="0ec4a-167">Przed uruchomieniem środowiska uruchomieniowego należy przygotować pewne właściwości, aby określić zachowanie (zwłaszcza dotyczące modułu ładującego zestawy).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-167">Before starting the runtime, it is necessary to prepare some properties to specify behavior (especially concerning the assembly loader).</span></span>

<span data-ttu-id="0ec4a-168">Typowe właściwości obejmują:</span><span class="sxs-lookup"><span data-stu-id="0ec4a-168">Common properties include:</span></span>

* <span data-ttu-id="0ec4a-169">`TRUSTED_PLATFORM_ASSEMBLIES` Jest to lista ścieżek zestawu (rozdzielonych znakami ";" w systemie Windows i ":" w systemie Linux), które środowisko uruchomieniowe będzie w stanie domyślnie rozpoznać.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-169">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Linux) which the runtime will be able to resolve by default.</span></span> <span data-ttu-id="0ec4a-170">Niektóre hosty mają zakodowane manifesty zawierające listę zestawów, które mogą zostać załadowane.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-170">Some hosts have hard-coded manifests listing assemblies they can load.</span></span> <span data-ttu-id="0ec4a-171">Inne umieściją dowolną bibliotekę w określonych lokalizacjach (obok *coreclr.dll*, na przykład) na tej liście.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-171">Others will put any library in certain locations (next to *coreclr.dll*, for example) on this list.</span></span>
* <span data-ttu-id="0ec4a-172">`APP_PATHS` Jest to lista ścieżek do sondowania w przypadku zestawu, jeśli nie można go znaleźć na liście zaufanych platform (TPA).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-172">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="0ec4a-173">Ponieważ Host ma większą kontrolę nad tym, które zestawy są ładowane przy użyciu listy TPA, najlepszym rozwiązaniem dla hostów jest określenie, które zestawy powinny być ładowane i wyświetlać je jawnie.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-173">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="0ec4a-174">Jeśli jednak jest wymagana sondowanie w czasie wykonywania, ta właściwość może włączyć ten scenariusz.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-174">If probing at run time is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="0ec4a-175">`APP_NI_PATHS` Ta lista jest podobna do APP_PATHS z tą różnicą, że jest to ścieżka, która będzie sondowana w przypadku obrazów natywnych.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-175">`APP_NI_PATHS` This list is similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="0ec4a-176">`NATIVE_DLL_SEARCH_DIRECTORIES` Ta właściwość jest listą ścieżek, które moduł ładujący powinien sondować podczas wyszukiwania bibliotek natywnych wywoływanych za pomocą p/Invoke.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-176">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native libraries called via p/invoke.</span></span>
* <span data-ttu-id="0ec4a-177">`PLATFORM_RESOURCE_ROOTS` Ta lista zawiera ścieżki do sondowania w przypadku zestawów satelickich zasobów (w podkatalogach specyficznych dla kultury).</span><span class="sxs-lookup"><span data-stu-id="0ec4a-177">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific subdirectories).</span></span>

<span data-ttu-id="0ec4a-178">Na tym przykładowym hoście lista TPA jest tworzona przez wyświetlenie listy wszystkich bibliotek w bieżącym katalogu:</span><span class="sxs-lookup"><span data-stu-id="0ec4a-178">In this sample host, the TPA list is constructed by simply listing all libraries in the current directory:</span></span>

[!code-cpp[CoreClrHost#7](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#7)]

<span data-ttu-id="0ec4a-179">Ponieważ przykład jest prosty, wymaga tylko `TRUSTED_PLATFORM_ASSEMBLIES` Właściwości:</span><span class="sxs-lookup"><span data-stu-id="0ec4a-179">Because the sample is simple, it only needs the `TRUSTED_PLATFORM_ASSEMBLIES` property:</span></span>

[!code-cpp[CoreClrHost#3](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#3)]

### <a name="step-4---start-the-runtime"></a><span data-ttu-id="0ec4a-180">Krok 4. Uruchamianie środowiska uruchomieniowego</span><span class="sxs-lookup"><span data-stu-id="0ec4a-180">Step 4 - Start the runtime</span></span>

<span data-ttu-id="0ec4a-181">`coreclrhost.h` Interfejsy API uruchamiają środowisko uruchomieniowe i tworzą domyślną domenę aplikacji z pojedynczym wywołaniem.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-181">`coreclrhost.h` APIs start the runtime and create the default AppDomain all with a single call.</span></span> <span data-ttu-id="0ec4a-182">`coreclr_initialize`Funkcja przyjmuje ścieżkę bazową, nazwę i właściwości opisane wcześniej i zwraca dojście do hosta za pośrednictwem `hostHandle` parametru.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-182">The `coreclr_initialize` function takes a base path, name, and the properties described earlier and returns back a handle to the host via the `hostHandle` parameter.</span></span>

[!code-cpp[CoreClrHost#4](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#4)]

### <a name="step-5---run-managed-code"></a><span data-ttu-id="0ec4a-183">Krok 5 — uruchamianie kodu zarządzanego!</span><span class="sxs-lookup"><span data-stu-id="0ec4a-183">Step 5 - Run managed code!</span></span>

<span data-ttu-id="0ec4a-184">Po uruchomieniu środowiska uruchomieniowego host może wywołać kod zarządzany.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-184">With the runtime started, the host can call managed code.</span></span> <span data-ttu-id="0ec4a-185">Można to zrobić na kilka różnych sposobów.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-185">This can be done in a couple of different ways.</span></span> <span data-ttu-id="0ec4a-186">Przykładowy kod połączony z tym samouczkiem używa `coreclr_create_delegate` funkcji, aby utworzyć delegata do statycznej metody zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-186">The sample code linked to this tutorial uses the `coreclr_create_delegate` function to create a delegate to a static managed method.</span></span> <span data-ttu-id="0ec4a-187">Ten interfejs API przyjmuje [nazwę zestawu](../../standard/assembly/names.md), nazwę typu kwalifikowanego przestrzeni nazw i nazwę metody jako dane wejściowe i zwraca delegat, którego można użyć do wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-187">This API takes the [assembly name](../../standard/assembly/names.md), namespace-qualified type name, and method name as inputs and returns a delegate that can be used to invoke the method.</span></span>

[!code-cpp[CoreClrHost#5](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#5)]

<span data-ttu-id="0ec4a-188">W tym przykładzie host może teraz wywołać, `managedDelegate` Aby uruchomić `ManagedWorker.DoWork` metodę.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-188">In this sample, the host can now call `managedDelegate` to run the `ManagedWorker.DoWork` method.</span></span>

<span data-ttu-id="0ec4a-189">Alternatywnie, `coreclr_execute_assembly` Funkcja może służyć do uruchamiania zarządzanego pliku wykonywalnego.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-189">Alternatively, the `coreclr_execute_assembly` function can be used to launch a managed executable.</span></span> <span data-ttu-id="0ec4a-190">Ten interfejs API Pobiera ścieżkę zestawu i tablicę argumentów jako parametry wejściowe.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-190">This API takes an assembly path and array of arguments as input parameters.</span></span> <span data-ttu-id="0ec4a-191">Ładuje zestaw w tej ścieżce i wywołuje jego metodę Main.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-191">It loads the assembly at that path and invokes its main method.</span></span>

```c++
int hr = executeAssembly(
        hostHandle,
        domainId,
        argumentCount,
        arguments,
        "HelloWorld.exe",
        (unsigned int*)&exitCode);
```

### <a name="step-6---shutdown-and-clean-up"></a><span data-ttu-id="0ec4a-192">Krok 6 — Zamykanie i oczyszczanie</span><span class="sxs-lookup"><span data-stu-id="0ec4a-192">Step 6 - Shutdown and clean up</span></span>

<span data-ttu-id="0ec4a-193">Na koniec, gdy host wykonuje kod zarządzany, środowisko uruchomieniowe programu .NET Core jest zamykane z systemem `coreclr_shutdown` lub `coreclr_shutdown_2` .</span><span class="sxs-lookup"><span data-stu-id="0ec4a-193">Finally, when the host is done running managed code, the .NET Core runtime is shut down with `coreclr_shutdown` or `coreclr_shutdown_2`.</span></span>

[!code-cpp[CoreClrHost#6](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#6)]

<span data-ttu-id="0ec4a-194">CoreCLR nie obsługuje ponownego inicjowania ani zwalniania.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-194">CoreCLR does not support reinitialization or unloading.</span></span> <span data-ttu-id="0ec4a-195">Nie wywołuj `coreclr_initialize` ponownie ani nie zwalniaj biblioteki CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-195">Do not call `coreclr_initialize` again or unload the CoreCLR library.</span></span>

## <a name="conclusion"></a><span data-ttu-id="0ec4a-196">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="0ec4a-196">Conclusion</span></span>
<span data-ttu-id="0ec4a-197">Po skompilowaniu hosta może on być testowany przez uruchomienie go z wiersza polecenia i przekazanie wszelkich argumentów oczekiwanych przez hosta.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-197">Once your host is built, it can be tested by running it from the command line and passing any arguments the host expects.</span></span> <span data-ttu-id="0ec4a-198">Podczas określania aplikacji .NET Core do uruchomienia hosta upewnij się, że korzystasz z biblioteki DLL, która jest generowana przez `dotnet build` .</span><span class="sxs-lookup"><span data-stu-id="0ec4a-198">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="0ec4a-199">Pliki wykonywalne (. exe) utworzone przez `dotnet publish` dla aplikacji samodzielnych są domyślnym hostem platformy .NET Core (aby można było uruchomić aplikację bezpośrednio z wiersza polecenia w scenariuszach linii głównej); kod użytkownika jest kompilowany do biblioteki DLL o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-199">Executables (.exe files) produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span>

<span data-ttu-id="0ec4a-200">Jeśli elementy nie działają na początku, należy sprawdzić, czy *coreclr.dll* jest dostępny w lokalizacji oczekiwanej przez hosta, że wszystkie niezbędne biblioteki struktury znajdują się na liście TPA i CoreCLR (32-bitowy lub 64-bitowy) są zgodne z sposobem kompilowania hosta.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-200">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32-bit or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="0ec4a-201">Hostowanie środowiska uruchomieniowego .NET Core jest zaawansowanym scenariuszem, który nie jest wymagany dla wielu deweloperów, ale dla tych, którzy muszą uruchamiać kod zarządzany z procesu macierzystego lub którzy potrzebują większej kontroli nad zachowaniem środowiska uruchomieniowego programu .NET Core, może być bardzo przydatna.</span><span class="sxs-lookup"><span data-stu-id="0ec4a-201">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span>
