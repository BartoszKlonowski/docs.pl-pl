---
title: Wartości
description: Dowiedz się, F# w jaki sposób wartości w są ilościami o określonym typie.
ms.date: 05/16/2016
ms.openlocfilehash: ed7a5b069a5a47aacf0cce4cfa754ded46f6e84a
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630800"
---
# <a name="values"></a><span data-ttu-id="bd524-103">Wartości</span><span class="sxs-lookup"><span data-stu-id="bd524-103">Values</span></span>

<span data-ttu-id="bd524-104">Wartości w F# to ilości, które mają określony typ; wartości mogą być liczbami całkowitymi lub zmiennoprzecinkowymi, znakami lub tekstem, listami, sekwencjami, tablicami, krotkami, związkami rozłącznych, rekordami, typami klas lub wartościami funkcji.</span><span class="sxs-lookup"><span data-stu-id="bd524-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="bd524-105">Powiązanie wartości</span><span class="sxs-lookup"><span data-stu-id="bd524-105">Binding a Value</span></span>

<span data-ttu-id="bd524-106">Termin *powiązania* oznacza skojarzenie nazwy z definicją.</span><span class="sxs-lookup"><span data-stu-id="bd524-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="bd524-107">`let` Słowo kluczowe wiąże wartość, jak w następujących przykładach:</span><span class="sxs-lookup"><span data-stu-id="bd524-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="bd524-108">Typ wartości jest wywnioskowany na podstawie definicji.</span><span class="sxs-lookup"><span data-stu-id="bd524-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="bd524-109">Dla typu pierwotnego, takiego jak liczba całkowita lub zmiennoprzecinkowa, typ jest określany na podstawie typu literału.</span><span class="sxs-lookup"><span data-stu-id="bd524-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="bd524-110">W związku z tym w poprzednim przykładzie `b` kompilator wnioskuje typ, który ma być `unsigned int`, podczas gdy `a` kompilator wnioskuje typ, który ma `int`być.</span><span class="sxs-lookup"><span data-stu-id="bd524-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="bd524-111">Typ wartości funkcji jest określany na podstawie wartości zwracanej w treści funkcji.</span><span class="sxs-lookup"><span data-stu-id="bd524-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="bd524-112">Aby uzyskać więcej informacji na temat typów wartości funkcji [](../functions/index.md), zobacz Functions.</span><span class="sxs-lookup"><span data-stu-id="bd524-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="bd524-113">Aby uzyskać więcej informacji na temat typów literałów, zobacz [literały](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="bd524-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="bd524-114">Kompilator nie wystawia domyślnie diagnostyki nieużywanych powiązań.</span><span class="sxs-lookup"><span data-stu-id="bd524-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="bd524-115">Aby otrzymywać te komunikaty, Włącz Ostrzeżenie 1182 w pliku projektu lub podczas wywoływania kompilatora (zobacz `--warnon` w obszarze [Opcje kompilatora](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="bd524-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="bd524-116">Dlaczego jest to niezmienne?</span><span class="sxs-lookup"><span data-stu-id="bd524-116">Why Immutable?</span></span>

<span data-ttu-id="bd524-117">Niezmienne wartości to wartości, których nie można zmienić w trakcie wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="bd524-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="bd524-118">Jeśli są używane do języków takich jak C++, Visual Basic lub C#, może się okazać, że F# zaskakujące Primacy zbyt zmienne wartości, a nie zmienne, które mogą przypisywać nowe wartości podczas wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="bd524-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="bd524-119">Niezmienne dane to istotny element programowania funkcjonalnego.</span><span class="sxs-lookup"><span data-stu-id="bd524-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="bd524-120">W środowisku wielowątkowym trudno jest zarządzać udostępnionymi zmiennymi modyfikowalnymi, które mogą być zmieniane przez wiele różnych wątków.</span><span class="sxs-lookup"><span data-stu-id="bd524-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="bd524-121">Ponadto ze zmiennymi modyfikowalnymi może być czasami trudno stwierdzić, czy zmienna może zostać zmieniona, gdy zostanie ona przeniesiona do innej funkcji.</span><span class="sxs-lookup"><span data-stu-id="bd524-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="bd524-122">W czystych językach funkcjonalnych nie ma żadnych zmiennych, a funkcje zachowują się wyłącznie jako funkcje matematyczne.</span><span class="sxs-lookup"><span data-stu-id="bd524-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="bd524-123">Gdzie kod w języku proceduralnym używa przypisania zmiennej do zmiany wartości, odpowiedni kod w języku funkcjonalnym ma niemodyfikowalną wartość, która jest danymi wejściowymi, niemodyfikowalną funkcją i różne zmienne wartości jako dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="bd524-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="bd524-124">Ten matematyczny efekt daje ściślejszy powód zachowania programu.</span><span class="sxs-lookup"><span data-stu-id="bd524-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="bd524-125">To ściślejsze przyczyny to umożliwienie kompilatorom dokładniejszego sprawdzenia kodu i bardziej wydajnego optymalizowania oraz ułatwia deweloperom zrozumienie i pisanie poprawnego kodu.</span><span class="sxs-lookup"><span data-stu-id="bd524-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="bd524-126">Z tego względu kod funkcjonalny jest łatwiejszy do debugowania niż zwykły kod proceduralny.</span><span class="sxs-lookup"><span data-stu-id="bd524-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="bd524-127">F#to nie jest czysty język funkcjonalny, ale w pełni obsługuje programowanie funkcjonalne.</span><span class="sxs-lookup"><span data-stu-id="bd524-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="bd524-128">Korzystanie z niezmiennych wartości jest dobrym sposobem, ponieważ dzięki temu kod może korzystać z ważnego aspektu programowania funkcjonalnego.</span><span class="sxs-lookup"><span data-stu-id="bd524-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="bd524-129">Zmienne modyfikowalne</span><span class="sxs-lookup"><span data-stu-id="bd524-129">Mutable Variables</span></span>

<span data-ttu-id="bd524-130">Możesz użyć słowa kluczowego `mutable` , aby określić zmienną, którą można zmienić.</span><span class="sxs-lookup"><span data-stu-id="bd524-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="bd524-131">Zmienne modyfikowalne F# w programie powinny zwykle mieć ograniczony zakres, jako pole typu lub jako wartość lokalną.</span><span class="sxs-lookup"><span data-stu-id="bd524-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="bd524-132">Zmienne modyfikowalne z ograniczonym zakresem są łatwiejsze w kontroli i nie mogą być modyfikowane w nieprawidłowy sposób.</span><span class="sxs-lookup"><span data-stu-id="bd524-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="bd524-133">Można przypisać wartość początkową do zmiennej modyfikowalnej za pomocą `let` słowa kluczowego w taki sam sposób jak w przypadku definiowania wartości.</span><span class="sxs-lookup"><span data-stu-id="bd524-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="bd524-134">Jednak różnica polega na tym, że można później przypisywać nowe wartości do zmiennych modyfikowalnych za `<-` pomocą operatora, jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="bd524-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="bd524-135">Wartości oznaczone `mutable` mogą zostać automatycznie podwyższone `'a ref` do, jeśli zostały przechwycone przez zamknięcie, w tym formularze tworzące zamknięcia, `seq` takie jak konstruktory.</span><span class="sxs-lookup"><span data-stu-id="bd524-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="bd524-136">Jeśli chcesz otrzymywać powiadomienia, gdy wystąpi taka sytuacja, Włącz Ostrzeżenie 3180 w pliku projektu lub podczas wywoływania kompilatora.</span><span class="sxs-lookup"><span data-stu-id="bd524-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="bd524-137">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="bd524-137">Related Topics</span></span>

|<span data-ttu-id="bd524-138">Tytuł</span><span class="sxs-lookup"><span data-stu-id="bd524-138">Title</span></span>|<span data-ttu-id="bd524-139">Opis</span><span class="sxs-lookup"><span data-stu-id="bd524-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="bd524-140">Powiązania „let”</span><span class="sxs-lookup"><span data-stu-id="bd524-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="bd524-141">Zawiera informacje dotyczące używania `let` słowa kluczowego do powiązania nazw z wartościami i funkcjami.</span><span class="sxs-lookup"><span data-stu-id="bd524-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="bd524-142">Funkcje</span><span class="sxs-lookup"><span data-stu-id="bd524-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="bd524-143">Zawiera omówienie funkcji w programie F#.</span><span class="sxs-lookup"><span data-stu-id="bd524-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="bd524-144">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="bd524-144">See also</span></span>

- [<span data-ttu-id="bd524-145">Wartości null</span><span class="sxs-lookup"><span data-stu-id="bd524-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="bd524-146">Dokumentacja języka F#</span><span class="sxs-lookup"><span data-stu-id="bd524-146">F# Language Reference</span></span>](../index.md)
