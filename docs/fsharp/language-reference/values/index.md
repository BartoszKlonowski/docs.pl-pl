---
title: "Wartości (F#)"
description: "Dowiedz się, jak wartości w języku F # to ilości, które mają określonego typu."
keywords: "Visual f #, f #, funkcjonalności programowania"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 5e1e73c3-5adb-4bba-9976-d57f1ff6cd8d
ms.openlocfilehash: a1e077552ba39a483be3129c89af48b547219733
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2017
---
# <a name="values"></a><span data-ttu-id="0bdca-104">Wartości</span><span class="sxs-lookup"><span data-stu-id="0bdca-104">Values</span></span>

<span data-ttu-id="0bdca-105">Wartości w języku F # to ilości, które mają określony typ; wartości mogą być liczbami całkowitą lub zmiennoprzecinkową, znaków lub tekstu, list, sekwencji, tablic, krotek, rozłączne, rekordy, typu klasy lub wartości funkcji.</span><span class="sxs-lookup"><span data-stu-id="0bdca-105">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>


## <a name="binding-a-value"></a><span data-ttu-id="0bdca-106">Powiązania wartości</span><span class="sxs-lookup"><span data-stu-id="0bdca-106">Binding a Value</span></span>
<span data-ttu-id="0bdca-107">Termin *powiązania* oznacza skojarzenie nazwy z definicji.</span><span class="sxs-lookup"><span data-stu-id="0bdca-107">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="0bdca-108">`let` — Słowo kluczowe wiąże wartość, na przykład:</span><span class="sxs-lookup"><span data-stu-id="0bdca-108">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="0bdca-109">Typ wartości jest wywnioskowany na podstawie definicji.</span><span class="sxs-lookup"><span data-stu-id="0bdca-109">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="0bdca-110">Dla typu pierwotnego, takie jak liczbą całkowitą lub zmiennoprzecinkową typ zależy od typu literału.</span><span class="sxs-lookup"><span data-stu-id="0bdca-110">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="0bdca-111">W związku z tym w poprzednim przykładzie, kompilator wnioskuje typ `b` jako `unsigned int`, podczas gdy kompilator wnioskuje typ `a` jako `int`.</span><span class="sxs-lookup"><span data-stu-id="0bdca-111">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="0bdca-112">Typ wartości funkcji zależy od wartości zwracanej w treści funkcji.</span><span class="sxs-lookup"><span data-stu-id="0bdca-112">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="0bdca-113">Aby uzyskać więcej informacji o typach wartości funkcji, zobacz [funkcji](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="0bdca-113">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="0bdca-114">Aby uzyskać więcej informacji na temat typów literału, zobacz [literały](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="0bdca-114">For more information about literal types, see [Literals](../literals.md).</span></span>


## <a name="why-immutable"></a><span data-ttu-id="0bdca-115">Dlaczego niezmienne?</span><span class="sxs-lookup"><span data-stu-id="0bdca-115">Why Immutable?</span></span>
<span data-ttu-id="0bdca-116">Niezmienne wartości są wartości, których nie można zmieniać w trakcie wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="0bdca-116">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="0bdca-117">Jeśli używasz dla języków C++, Visual Basic lub C#, może znaleźć zaskakująco, że F # umieszcza nadrzędności za pośrednictwem modyfikować wartości, a nie zmienne, które można przypisać nowe wartości podczas wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="0bdca-117">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="0bdca-118">Niezmienne danych jest ważnym elementem programowanie funkcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0bdca-118">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="0bdca-119">W środowisku wielowątkowym udostępnionego zmienne modyfikowalne, które może zostać zmieniona przez wiele różnych wątkach są trudne do zarządzania.</span><span class="sxs-lookup"><span data-stu-id="0bdca-119">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="0bdca-120">Ponadto z zmienne modyfikowalne czasami można stwierdzić, jeśli zmienna może ulec zmianie, gdy jest przekazywana do innej funkcji.</span><span class="sxs-lookup"><span data-stu-id="0bdca-120">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="0bdca-121">W czystym języków funkcjonalności istnieją żadnych zmiennych i funkcje działają wyłącznie jako funkcje matematyczne.</span><span class="sxs-lookup"><span data-stu-id="0bdca-121">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="0bdca-122">W przypadku, gdy kodu w języku procedurach używa przypisanie zmiennej, aby zmienić wartość, odpowiednik kodu w języku funkcjonalności ma niezmienne wartość danych wejściowych, funkcja niezmienne i różne wartości niezmienne jako dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="0bdca-122">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="0bdca-123">Ta matematyczne poziom ścisłości umożliwia większego wnioskowania o zachowaniu program.</span><span class="sxs-lookup"><span data-stu-id="0bdca-123">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="0bdca-124">Zwiększenie poziomu uzasadnienie jest temu kompilatory dokładniej Sprawdź kod i zoptymalizować efektywniej i podnosi poziom stało się łatwiejsze do zrozumienia i zapisać prawidłowego kodu.</span><span class="sxs-lookup"><span data-stu-id="0bdca-124">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="0bdca-125">Funkcjonalny kod jest w związku z tym mogą być łatwiejsze do debugowania niż zwykłe kod procedurach.</span><span class="sxs-lookup"><span data-stu-id="0bdca-125">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="0bdca-126">F # nie jest czysty język funkcjonalności jeszcze w pełni obsługuje programowanie funkcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0bdca-126">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="0bdca-127">Przy użyciu wartości niezmienne jest dobrym rozwiązaniem, ponieważ w ten sposób swój kod, aby korzystać z ważnym aspektem programowanie funkcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0bdca-127">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>


## <a name="mutable-variables"></a><span data-ttu-id="0bdca-128">Zmienne modyfikowalne</span><span class="sxs-lookup"><span data-stu-id="0bdca-128">Mutable Variables</span></span>
<span data-ttu-id="0bdca-129">Można użyć słowa kluczowego `mutable` określić zmienną, które można zmienić.</span><span class="sxs-lookup"><span data-stu-id="0bdca-129">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="0bdca-130">Zmienne modyfikowalne w języku F # ma zazwyczaj ograniczonym zakresie, albo jako pola typu wartości lokalnej.</span><span class="sxs-lookup"><span data-stu-id="0bdca-130">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="0bdca-131">Zmienne modyfikowalne o ograniczonym zakresie są łatwiejsze do formantu i mniej mogą być modyfikowane w nieprawidłowy sposób.</span><span class="sxs-lookup"><span data-stu-id="0bdca-131">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="0bdca-132">Wartość początkowa można przypisać do modyfikowalnej zmiennej, za pomocą `let` — słowo kluczowe w taki sam sposób, jak należy zdefiniować wartość.</span><span class="sxs-lookup"><span data-stu-id="0bdca-132">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="0bdca-133">Jednak różnica jest, że można następnie przypisać nowe wartości zmienne modyfikowalne przy użyciu `<-` operatora, jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0bdca-133">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]
    
## <a name="related-topics"></a><span data-ttu-id="0bdca-134">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="0bdca-134">Related Topics</span></span>


|<span data-ttu-id="0bdca-135">Tytuł</span><span class="sxs-lookup"><span data-stu-id="0bdca-135">Title</span></span>|<span data-ttu-id="0bdca-136">Opis</span><span class="sxs-lookup"><span data-stu-id="0bdca-136">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="0bdca-137">Let — powiązania</span><span class="sxs-lookup"><span data-stu-id="0bdca-137">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="0bdca-138">Zawiera informacje dotyczące używania `let` — słowo kluczowe można powiązać nazwy wartości i funkcje.</span><span class="sxs-lookup"><span data-stu-id="0bdca-138">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="0bdca-139">Funkcje</span><span class="sxs-lookup"><span data-stu-id="0bdca-139">Functions</span></span>](../functions/index.md)|<span data-ttu-id="0bdca-140">Zawiera omówienie funkcji w języku F #.</span><span class="sxs-lookup"><span data-stu-id="0bdca-140">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="0bdca-141">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="0bdca-141">See Also</span></span>
[<span data-ttu-id="0bdca-142">Wartości zerowe</span><span class="sxs-lookup"><span data-stu-id="0bdca-142">Null Values</span></span>](null-Values.md)

[<span data-ttu-id="0bdca-143">Dokumentacja języka F #</span><span class="sxs-lookup"><span data-stu-id="0bdca-143">F# Language Reference</span></span>](../index.md)
