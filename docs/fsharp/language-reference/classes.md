---
title: Klasy (F#)
description: "Dowiedz się, jak klas F # są typy, które reprezentują obiektów, które mogą mieć właściwości, metod i zdarzeń."
keywords: "Visual f #, f #, funkcjonalności programowania"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: d58679d5-7753-4b3b-a12f-6e9f00ed5ba3
ms.openlocfilehash: 2a73baba1f7c1b0d3bd09d22c9d6d9f0524daef3
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2017
---
# <a name="classes"></a><span data-ttu-id="bd851-104">Klasy</span><span class="sxs-lookup"><span data-stu-id="bd851-104">Classes</span></span>

<span data-ttu-id="bd851-105">*Klasy* są typy, które reprezentują obiektów, które mogą mieć właściwości, metod i zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="bd851-105">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>


## <a name="syntax"></a><span data-ttu-id="bd851-106">Składnia</span><span class="sxs-lookup"><span data-stu-id="bd851-106">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="bd851-107">Uwagi</span><span class="sxs-lookup"><span data-stu-id="bd851-107">Remarks</span></span>
<span data-ttu-id="bd851-108">Klasy reprezentuje opis podstawowych typów obiektu .NET. Klasa jest koncepcji typu podstawowego, który obsługuje programowanie zorientowane obiektowo w języku F #.</span><span class="sxs-lookup"><span data-stu-id="bd851-108">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="bd851-109">W powyższej składni `type-name` jest dowolny poprawny identyfikator.</span><span class="sxs-lookup"><span data-stu-id="bd851-109">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="bd851-110">`type-params` Opisano parametry opcjonalne typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="bd851-110">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="bd851-111">Składa się z nazwy parametrów typu i ograniczenia ujęte w nawiasy (`<` i `>`).</span><span class="sxs-lookup"><span data-stu-id="bd851-111">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="bd851-112">Aby uzyskać więcej informacji, zobacz [ogólne](generics/index.md) i [ograniczenia](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="bd851-112">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="bd851-113">`parameter-list` Opisuje parametrami konstruktora.</span><span class="sxs-lookup"><span data-stu-id="bd851-113">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="bd851-114">Pierwszy modyfikator dostępu odnoszą się do tego typu; Druga odnosi się do podstawowego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="bd851-114">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="bd851-115">W obu przypadkach wartość domyślna to `public`.</span><span class="sxs-lookup"><span data-stu-id="bd851-115">In both cases, the default is `public`.</span></span>

<span data-ttu-id="bd851-116">Określ klasę podstawową dla klasy przy użyciu `inherit` — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="bd851-116">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="bd851-117">Należy podać argumentów konstruktora klasy podstawowej, w nawiasach.</span><span class="sxs-lookup"><span data-stu-id="bd851-117">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="bd851-118">Deklaruj pól lub wartości, które znajdują się lokalnie do klasy przy użyciu funkcji `let` powiązania i wykonaj ogólne zasady `let` powiązania.</span><span class="sxs-lookup"><span data-stu-id="bd851-118">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="bd851-119">`do-bindings` Sekcja zawiera kod do wykonania po konstrukcji obiektów.</span><span class="sxs-lookup"><span data-stu-id="bd851-119">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="bd851-120">`member-list` Składa się z konstruktorów dodatkowe, wystąpienia i deklaracje metody statycznej deklaracji interfejsów, abstrakcyjny powiązania i deklaracje właściwości i zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bd851-120">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="bd851-121">Te ustawienia zostały opisane w [członków](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="bd851-121">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="bd851-122">`identifier` Używany z opcjonalnym `as` — słowo kluczowe nadaje nazwę zmiennej instancji lub własnego identyfikatora, którego można użyć do odwoływania się do wystąpienia typu w definicji typu.</span><span class="sxs-lookup"><span data-stu-id="bd851-122">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="bd851-123">Aby uzyskać więcej informacji zobacz sekcję samoobsługowego identyfikatorów w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="bd851-123">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="bd851-124">Słowa kluczowe `class` i `end` oznakowanie początek i koniec definicji są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="bd851-124">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="bd851-125">Wzajemnie typy cyklicznego, do których są typy, które odwołują się do siebie, są połączone razem z `and` tak samo jak wzajemnie są funkcje rekursywne — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="bd851-125">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="bd851-126">Na przykład zobacz sekcję wzajemnie rekursywne typów.</span><span class="sxs-lookup"><span data-stu-id="bd851-126">For an example, see the section Mutually Recursive Types.</span></span>


## <a name="constructors"></a><span data-ttu-id="bd851-127">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="bd851-127">Constructors</span></span>
<span data-ttu-id="bd851-128">Konstruktor jest kod, który tworzy wystąpienie typu klasy.</span><span class="sxs-lookup"><span data-stu-id="bd851-128">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="bd851-129">Konstruktory klas działają trochę inaczej w F # niż w innych językach .NET.</span><span class="sxs-lookup"><span data-stu-id="bd851-129">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="bd851-130">W F # klasa, jest zawsze podstawowego konstruktora, którego argumenty zostały opisane w `parameter-list` następujący nazwa typu, a których treści składa się z `let` (i `let rec`) powiązania na początku deklaracji klasy i `do`powiązania, które należy wykonać.</span><span class="sxs-lookup"><span data-stu-id="bd851-130">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="bd851-131">Argumenty konstruktora głównej znajdują się w zakresie w deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="bd851-131">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="bd851-132">Możesz dodać dodatkowe konstruktorów przy użyciu `new` — słowo kluczowe, aby dodać element członkowski, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="bd851-132">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="bd851-133">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="bd851-133">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="bd851-134">Treść konstruktora new należy wywołać konstruktora podstawowego, który został określony na początku deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="bd851-134">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="bd851-135">Poniższy przykład ilustruje tę koncepcję.</span><span class="sxs-lookup"><span data-stu-id="bd851-135">The following example illustrates this concept.</span></span> <span data-ttu-id="bd851-136">W poniższym kodzie `MyClass` ma dwa konstruktory, podstawowego konstruktora, który przyjmuje dwa argumenty i innego konstruktora, który nie przyjmuje żadnych argumentów.</span><span class="sxs-lookup"><span data-stu-id="bd851-136">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a><span data-ttu-id="bd851-137">Let i powiązania</span><span class="sxs-lookup"><span data-stu-id="bd851-137">let and do Bindings</span></span>

<span data-ttu-id="bd851-138">`let` i `do` powiązania w definicji klasy tworzą treść konstruktora klasy podstawowej i w związku z tym są uruchamiane zawsze, gdy jest tworzone wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="bd851-138">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="bd851-139">Jeśli `let` powiązania jest funkcją, a następnie jest on skompilowany do członka.</span><span class="sxs-lookup"><span data-stu-id="bd851-139">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="bd851-140">Jeśli `let` powiązanie to wartość, która nie jest używany w żadnych funkcji lub elementu członkowskiego, a następnie jest on skompilowany w zmiennej, która jest lokalny dla konstruktora.</span><span class="sxs-lookup"><span data-stu-id="bd851-140">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="bd851-141">W przeciwnym razie jest kompilowana do pola klasy.</span><span class="sxs-lookup"><span data-stu-id="bd851-141">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="bd851-142">`do` Wyrażeń, które należy wykonać są kompilowane do podstawowego konstruktora i wykonywanie kodu inicjowania dla każdego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="bd851-142">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="bd851-143">Ponieważ żadnych dodatkowych konstruktorów zawsze wywołać konstruktora podstawowego, `let` powiązania i `do` powiązania wykonać zawsze, niezależnie od tego, które jest nazywany konstruktora.</span><span class="sxs-lookup"><span data-stu-id="bd851-143">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="bd851-144">Pola, które zostały utworzone przy użyciu `let` powiązania są dostępne w ramach metod i właściwości klasy; jednak ich jest niedostępny z metody statyczne, nawet w przypadku statycznej metody przyjmują zmienna wystąpienia jako parametr.</span><span class="sxs-lookup"><span data-stu-id="bd851-144">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="bd851-145">Nie były dostępne przy użyciu własnego identyfikatora, jeśli taka istnieje.</span><span class="sxs-lookup"><span data-stu-id="bd851-145">They cannot be accessed by using the self identifier, if one exists.</span></span>


## <a name="self-identifiers"></a><span data-ttu-id="bd851-146">Samoidentyfikatory</span><span class="sxs-lookup"><span data-stu-id="bd851-146">Self Identifiers</span></span>

<span data-ttu-id="bd851-147">A *własnego identyfikatora* jest nazwą, która reprezentuje bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="bd851-147">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="bd851-148">Podobne samoidentyfikatory `this` słów kluczowych w języku C# lub C++ lub `Me` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="bd851-148">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="bd851-149">Można zdefiniować własnego identyfikatora na dwa różne sposoby, w zależności od tego, czy ma własnego identyfikatora znajdował się w zakresie dla definicji klasy całego lub tylko dla poszczególnych metod.</span><span class="sxs-lookup"><span data-stu-id="bd851-149">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="bd851-150">Aby zdefiniować własnego identyfikatora dla całej klasy, należy użyć `as` — słowo kluczowe po nawiasów zamykających parametru konstruktora listę i określ nazwę identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="bd851-150">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="bd851-151">Aby zdefiniować własnego identyfikatora dla tylko jednej metody, podaj własnego identyfikatora w deklaracji elementu członkowskiego, bezpośrednio przed nazwę metody i kropki (.) jako separatora.</span><span class="sxs-lookup"><span data-stu-id="bd851-151">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="bd851-152">Poniższy przykładowy kod przedstawia dwa sposoby tworzenia własnego identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="bd851-152">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="bd851-153">W pierwszym wierszu `as` — słowo kluczowe jest używane do definiowania własnego identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="bd851-153">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="bd851-154">W wierszu piątym identyfikator `this` służy do definiowania własnego identyfikatora, których zakres jest ograniczony do metody `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="bd851-154">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="bd851-155">W przeciwieństwie do innych języków .NET, można określić nazwę własnego identyfikatora jednak ma; użytkownik nie są ograniczone do nazw takich jak `self`, `Me`, lub `this`.</span><span class="sxs-lookup"><span data-stu-id="bd851-155">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="bd851-156">Własnego identyfikatora, który jest zadeklarowana z `as` — słowo kluczowe nie został zainicjowany dopiero po `let` powiązania są wykonywane.</span><span class="sxs-lookup"><span data-stu-id="bd851-156">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="bd851-157">W związku z tym nie można używać w `let` powiązania.</span><span class="sxs-lookup"><span data-stu-id="bd851-157">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="bd851-158">Można użyć własnego identyfikatora w `do` sekcji powiązania.</span><span class="sxs-lookup"><span data-stu-id="bd851-158">You can use the self identifier in the `do` bindings section.</span></span>


## <a name="generic-type-parameters"></a><span data-ttu-id="bd851-159">Parametry typu ogólnego</span><span class="sxs-lookup"><span data-stu-id="bd851-159">Generic Type Parameters</span></span>

<span data-ttu-id="bd851-160">Parametry typu ogólnego są określone w nawiasy (`<` i `>`), w postaci pojedynczego cudzysłowu następuje identyfikator.</span><span class="sxs-lookup"><span data-stu-id="bd851-160">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="bd851-161">Wiele parametrów typu ogólnego są oddzielone przecinkami.</span><span class="sxs-lookup"><span data-stu-id="bd851-161">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="bd851-162">Parametr typu ogólnego jest w zakresie całego zgłoszenia.</span><span class="sxs-lookup"><span data-stu-id="bd851-162">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="bd851-163">Poniższy przykład kodu pokazuje, jak określić parametry typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="bd851-163">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="bd851-164">Gdy jest używany typ, są wywnioskować argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="bd851-164">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="bd851-165">W poniższym kodzie wnioskowany typ jest sekwencją spójnych kolekcji.</span><span class="sxs-lookup"><span data-stu-id="bd851-165">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a><span data-ttu-id="bd851-166">Określanie dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="bd851-166">Specifying Inheritance</span></span>

<span data-ttu-id="bd851-167">`inherit` Klauzuli identyfikuje bezpośredniej klasie podstawowej, jeśli istnieje.</span><span class="sxs-lookup"><span data-stu-id="bd851-167">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="bd851-168">W języku F # jest dozwolony tylko jeden bezpośredniej klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="bd851-168">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="bd851-169">Interfejsy, które implementuje klasy nie są traktowane jako klasy podstawowe.</span><span class="sxs-lookup"><span data-stu-id="bd851-169">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="bd851-170">Interfejsy zostały omówione w [interfejsów](Interfaces.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="bd851-170">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="bd851-171">Dostępne metody i właściwości klasy podstawowej z klasy pochodnej przy użyciu słowa kluczowego języka `base` identyfikatorowi następuje znak kropki (.) i nazwa elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="bd851-171">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="bd851-172">Aby uzyskać więcej informacji, zobacz [dziedziczenia](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="bd851-172">For more information, see [Inheritance](inheritance.md).</span></span>


## <a name="members-section"></a><span data-ttu-id="bd851-173">Elementy członkowskie sekcji</span><span class="sxs-lookup"><span data-stu-id="bd851-173">Members Section</span></span>
<span data-ttu-id="bd851-174">W tej sekcji można zdefiniować statyczne lub wystąpienie metody, właściwości implementacje interfejsu, abstrakcyjne elementy członkowskie, deklaracje zdarzeń i dodatkowych konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="bd851-174">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="bd851-175">Pozwalają oraz czy powiązania nie może występować w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="bd851-175">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="bd851-176">Ponieważ można dodawać członków do różnych typów F # oprócz klas, zostały omówione w innym temacie [członków](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="bd851-176">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>


## <a name="mutually-recursive-types"></a><span data-ttu-id="bd851-177">Wzajemnie rekursywne typów</span><span class="sxs-lookup"><span data-stu-id="bd851-177">Mutually Recursive Types</span></span>
<span data-ttu-id="bd851-178">Po zdefiniowaniu typów odwołujące się do siebie nawzajem w sposób cykliczne można łączyć ze sobą definicje typów za pomocą `and` — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="bd851-178">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="bd851-179">`and` Zastępuje — słowo kluczowe `type` — słowo kluczowe na wszystkich z wyjątkiem pierwsza definicja w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="bd851-179">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="bd851-180">Dane wyjściowe znajduje się lista wszystkich plików w bieżącym katalogu.</span><span class="sxs-lookup"><span data-stu-id="bd851-180">The output is a list of all the files in the current directory.</span></span>


## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="bd851-181">Kiedy używać klas, Unii, rekordów i struktury</span><span class="sxs-lookup"><span data-stu-id="bd851-181">When to Use Classes, Unions, Records, and Structures</span></span>
<span data-ttu-id="bd851-182">Biorąc pod uwagę różne typy do wyboru, musisz mieć dobrą znajomość co każdego typu jest przeznaczona dla wybierz odpowiedni typ dla danej sytuacji.</span><span class="sxs-lookup"><span data-stu-id="bd851-182">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="bd851-183">Klasy są przeznaczone do użytku w kontekście programowania, zorientowany obiektowo.</span><span class="sxs-lookup"><span data-stu-id="bd851-183">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="bd851-184">Programowanie zorientowane obiektowo jest dominującą modelu, używany w aplikacjach, które są przeznaczone dla programu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="bd851-184">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="bd851-185">Jeśli ściśle współpracować z programu .NET Framework lub inną biblioteką zorientowane obiektowo kodzie języka F #, a zwłaszcza, jeśli masz system zorientowane obiektowo typów, takich jak biblioteki interfejsu użytkownika związane z klasy są prawdopodobnie odpowiednie.</span><span class="sxs-lookup"><span data-stu-id="bd851-185">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="bd851-186">Jeśli użytkownik nie są ściśle współdziałanie z kodem zorientowane obiektowo lub pisania kodu, która jest niezależna i dlatego chronione z częste interakcji z kodem zorientowane obiektowo, należy rozważyć użycie rekordów i Suma rozłączna Unii.</span><span class="sxs-lookup"><span data-stu-id="bd851-186">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="bd851-187">Jeden również myśl — limit czasu rozróżnianą Unię wraz z odpowiednią wzorzec dopasowany kodu, można często prostsze alternatywę do hierarchii obiektów.</span><span class="sxs-lookup"><span data-stu-id="bd851-187">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="bd851-188">Aby uzyskać więcej informacji na temat rozłączne, zobacz [Suma rozłączna unie](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="bd851-188">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="bd851-189">Rekordy zostały zaletą jest łatwiejsze niż w przypadku klasy, ale rekordy nie są odpowiednie wymagania typu przekracza, co można zrobić z ich uproszczenia.</span><span class="sxs-lookup"><span data-stu-id="bd851-189">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="bd851-190">Rekordy są zasadniczo proste agreguje wartości, bez konstruktorów oddzielne, które może wykonywać akcje niestandardowe, bez ukryte pola i bez implementacji dziedziczenia lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="bd851-190">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="bd851-191">Mimo że elementy członkowskie, takie jak właściwości i metod można dodać do rekordów do wykonania ich zachowanie bardziej złożonych, proste agregacji wartości są nadal pola przechowywane w rekordzie.</span><span class="sxs-lookup"><span data-stu-id="bd851-191">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="bd851-192">Aby uzyskać więcej informacji na temat rekordów, zobacz [rekordów](records.md).</span><span class="sxs-lookup"><span data-stu-id="bd851-192">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="bd851-193">Struktury są także przydatne dla małych wartości zagregowanych danych, ale różnią się od klasy i rekordów są typy wartości .NET.</span><span class="sxs-lookup"><span data-stu-id="bd851-193">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="bd851-194">Klasy i rekordów są typy referencyjne .NET.</span><span class="sxs-lookup"><span data-stu-id="bd851-194">Classes and records are .NET reference types.</span></span> <span data-ttu-id="bd851-195">Semantyka typów wartości i typy referencyjne są różne, w tym typy wartości są przekazywane przez wartość.</span><span class="sxs-lookup"><span data-stu-id="bd851-195">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="bd851-196">Oznacza to, że są one kopiowane bit bitu, gdy są one przekazywane jako parametr lub zwracane przez funkcję.</span><span class="sxs-lookup"><span data-stu-id="bd851-196">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="bd851-197">Są one również przechowywane na stosie lub, jeśli są używane jako pole osadzony w obiekcie nadrzędnym zamiast przechowywane w ich własnych osobnych lokalizacji na stosie.</span><span class="sxs-lookup"><span data-stu-id="bd851-197">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="bd851-198">W związku z tym struktury są odpowiednie dla często używanych danych, gdy obciążenie podczas uzyskiwania dostępu do sterty problem.</span><span class="sxs-lookup"><span data-stu-id="bd851-198">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="bd851-199">Aby uzyskać więcej informacji na temat struktury, zobacz [struktury](structures.md).</span><span class="sxs-lookup"><span data-stu-id="bd851-199">For more information about structures, see [Structures](structures.md).</span></span>


## <a name="see-also"></a><span data-ttu-id="bd851-200">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="bd851-200">See Also</span></span>
[<span data-ttu-id="bd851-201">Dokumentacja języka F #</span><span class="sxs-lookup"><span data-stu-id="bd851-201">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="bd851-202">Elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="bd851-202">Members</span></span>](members/index.md)

[<span data-ttu-id="bd851-203">Dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="bd851-203">Inheritance</span></span>](inheritance.md)

[<span data-ttu-id="bd851-204">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="bd851-204">Interfaces</span></span>](interfaces.md)

