---
title: Klasy
description: Dowiedz F# się, w jaki sposób klasy są typami reprezentującymi obiekty, które mogą mieć właściwości, metody i zdarzenia.
ms.date: 05/16/2016
ms.openlocfilehash: 5c012d028bc1f89e3e9f5969b3461faab9aad3a0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630442"
---
# <a name="classes"></a><span data-ttu-id="6c4e8-103">Klasy</span><span class="sxs-lookup"><span data-stu-id="6c4e8-103">Classes</span></span>

<span data-ttu-id="6c4e8-104">*Klasy* są typami reprezentującymi obiekty, które mogą mieć właściwości, metody i zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="6c4e8-105">Składnia</span><span class="sxs-lookup"><span data-stu-id="6c4e8-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="6c4e8-106">Uwagi</span><span class="sxs-lookup"><span data-stu-id="6c4e8-106">Remarks</span></span>

<span data-ttu-id="6c4e8-107">Klasy reprezentują podstawowy opis typów obiektów .NET; Klasa jest koncepcją typu podstawowego, która obsługuje programowanie zorientowane obiektowo w F#.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="6c4e8-108">W powyższej składni, `type-name` jest dowolnym prawidłowym identyfikatorem.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="6c4e8-109">`type-params` Opisuje opcjonalne parametry typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="6c4e8-110">Składa się z nazw parametrów typu i ograniczeń ujętych w nawiasy `>`kątowe (`<` i).</span><span class="sxs-lookup"><span data-stu-id="6c4e8-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="6c4e8-111">Aby uzyskać więcej informacji, zobacz [typy ogólne](./generics/index.md) i [ograniczenia](./generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="6c4e8-111">For more information, see [Generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span></span> <span data-ttu-id="6c4e8-112">`parameter-list` Opisuje parametry konstruktora.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="6c4e8-113">Pierwszy modyfikator dostępu dotyczy typu; sekunda odnosi się do głównego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="6c4e8-114">W obu przypadkach wartość domyślna to `public`.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="6c4e8-115">Należy określić klasę bazową dla klasy za pomocą `inherit` słowa kluczowego.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="6c4e8-116">W nawiasach należy podać argumenty dla konstruktora klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="6c4e8-117">Deklaruj pola lub wartości funkcji, które są lokalne dla klasy przy użyciu `let` powiązań, i musisz przestrzegać ogólnych `let` reguł powiązań.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="6c4e8-118">`do-bindings` Sekcja zawiera kod, który ma być wykonywany podczas konstruowania obiektu.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="6c4e8-119">`member-list` Składa się z dodatkowych konstruktorów, wystąpień i deklaracji metody statycznej, deklaracji interfejsu, powiązań abstrakcyjnych oraz deklaracji właściwości i zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="6c4e8-120">Są one opisane w obszarze [Członkowie](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="6c4e8-120">These are described in [Members](./members/index.md).</span></span>

<span data-ttu-id="6c4e8-121">Funkcja, która jest używana ze słowem kluczowym Optional `as` , zawiera nazwę zmiennej wystąpienia lub samego identyfikatora, która może być używana w definicji typu do odwoływania się do wystąpienia typu. `identifier`</span><span class="sxs-lookup"><span data-stu-id="6c4e8-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="6c4e8-122">Aby uzyskać więcej informacji, zobacz sekcję Identyfikatory własne w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="6c4e8-123">Słowa kluczowe `class` i `end` oznaczenie początku i końca definicji są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="6c4e8-124">Wzajemnie cykliczne typy, które są, które są wzajemnie odwołują się, są `and` sprzężone ze słowem kluczowym, tak jak funkcje wzajemnie cykliczne.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="6c4e8-125">Aby zapoznać się z przykładem, zobacz sekcję wzajemnie cykliczne typy.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="6c4e8-126">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="6c4e8-126">Constructors</span></span>

<span data-ttu-id="6c4e8-127">Konstruktor to kod, który tworzy wystąpienie typu klasy.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="6c4e8-128">Konstruktory dla klas działają nieco inaczej F# niż w innych językach .NET.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="6c4e8-129">W F# klasie jest zawsze konstruktorem podstawowym, którego argumenty są opisane w `parameter-list` , która następuje po nazwie typu i którego `let` treść składa się z powiązań (i `let rec`) na początku deklaracji klasy i `do` powiązania, które obserwują.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="6c4e8-130">Argumenty konstruktora podstawowego znajdują się w zakresie w całej deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="6c4e8-131">Można dodać więcej konstruktorów za pomocą `new` słowa kluczowego, aby dodać element członkowski w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="6c4e8-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="6c4e8-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="6c4e8-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="6c4e8-133">Treść nowego konstruktora musi wywoływać konstruktora podstawowego, który jest określony w górnej części deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="6c4e8-134">Poniższy przykład ilustruje tę koncepcję.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-134">The following example illustrates this concept.</span></span> <span data-ttu-id="6c4e8-135">W poniższym kodzie, `MyClass` ma dwa konstruktory, Konstruktor podstawowy, który przyjmuje dwa argumenty i inny Konstruktor, który nie przyjmuje argumentów.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="6c4e8-136">Powiązania let i do</span><span class="sxs-lookup"><span data-stu-id="6c4e8-136">let and do Bindings</span></span>

<span data-ttu-id="6c4e8-137">Powiązania `let` i`do` w definicji klasy tworzą treść konstruktora klasy podstawowej i dlatego są uruchamiane za każdym razem, gdy tworzone jest wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="6c4e8-138">`let` Jeśli powiązanie jest funkcją, zostanie ona skompilowana do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="6c4e8-139">`let` Jeśli powiązanie jest wartością, która nie jest używana w żadnej funkcji lub składowej, jest skompilowana do zmiennej, która jest lokalna dla konstruktora.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="6c4e8-140">W przeciwnym razie jest kompilowany do pola klasy.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="6c4e8-141">`do` Wyrażenia, które obserwują, są kompilowane do konstruktora podstawowego i wykonywanie kodu inicjacji dla każdego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="6c4e8-142">Ponieważ wszystkie dodatkowe konstruktory zawsze wywołują konstruktora podstawowego, `let` powiązania i `do` powiązania zawsze są wykonywane niezależnie od tego, który Konstruktor jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="6c4e8-143">Do pól tworzonych przez `let` powiązania można uzyskać dostęp w metodach i właściwościach klasy, jednak nie są one dostępne z metod statycznych, nawet jeśli metody statyczne przyjmują zmienną wystąpienia jako parametr.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="6c4e8-144">Nie można uzyskać do nich dostępu za pomocą identyfikatora własnego (jeśli taki istnieje).</span><span class="sxs-lookup"><span data-stu-id="6c4e8-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="6c4e8-145">Identyfikatory własne</span><span class="sxs-lookup"><span data-stu-id="6c4e8-145">Self Identifiers</span></span>

<span data-ttu-id="6c4e8-146">Samodzielny *Identyfikator* to nazwa, która reprezentuje bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="6c4e8-147">`this` Identyfikatory własne przypominają słowo kluczowe w C# lub C++ lub `Me` w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="6c4e8-148">Można zdefiniować własny identyfikator na dwa różne sposoby, w zależności od tego, czy identyfikator samodzielny ma być w zakresie dla całej definicji klasy, czy tylko dla pojedynczej metody.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="6c4e8-149">Aby zdefiniować samodzielny identyfikator dla całej klasy, użyj `as` słowa kluczowego po nawiasach zamykających listy parametrów konstruktora i podaj nazwę identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="6c4e8-150">Aby zdefiniować samodzielny identyfikator dla tylko jednej metody, należy podać własny identyfikator w deklaracji elementu członkowskiego, tuż przed nazwą metody i kropką (.) jako separatorem.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="6c4e8-151">Poniższy przykład kodu ilustruje dwa sposoby tworzenia identyfikatorów samodzielnych.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="6c4e8-152">W pierwszym wierszu `as` słowo kluczowe jest używane do definiowania własnego identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="6c4e8-153">W piątym wierszu identyfikator `this` jest używany do definiowania samego identyfikatora, którego zakres jest ograniczony do metody. `PrintMessage`</span><span class="sxs-lookup"><span data-stu-id="6c4e8-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="6c4e8-154">W przeciwieństwie do innych języków .NET, można nazwać swój identyfikator własny. nie są ograniczone do nazw takich jak `self`, `Me`, lub `this`.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="6c4e8-155">Sam identyfikator, który jest zadeklarowany za `as` pomocą słowa kluczowego, nie został `let` zainicjowany do momentu wykonania powiązań.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="6c4e8-156">W związku z tym nie można jej używać `let` w powiązaniach.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="6c4e8-157">Możesz użyć własnego identyfikatora w `do` sekcji powiązania.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-157">You can use the self identifier in the `do` bindings section.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="6c4e8-158">Parametry typu ogólnego</span><span class="sxs-lookup"><span data-stu-id="6c4e8-158">Generic Type Parameters</span></span>

<span data-ttu-id="6c4e8-159">Parametry typu ogólnego są określane w nawiasach kątowych `>`(`<` i) w postaci pojedynczego cudzysłowu, po którym następuje identyfikator.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="6c4e8-160">Wiele parametrów typu ogólnego jest oddzielonych przecinkami.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="6c4e8-161">Parametr typu ogólnego jest w zakresie w całej deklaracji.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="6c4e8-162">Poniższy przykład kodu pokazuje, jak określić parametry typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="6c4e8-163">Argumenty typu są wywnioskowane, gdy typ jest używany.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="6c4e8-164">W poniższym kodzie typ wnioskowany jest sekwencją krotek.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="6c4e8-165">Określanie dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="6c4e8-165">Specifying Inheritance</span></span>

<span data-ttu-id="6c4e8-166">`inherit` Klauzula identyfikuje bezpośrednią klasę bazową, jeśli istnieje.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="6c4e8-167">W F#programie dozwolona jest tylko jedna bezpośrednia klasa bazowa.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="6c4e8-168">Interfejsy implementowane przez klasę nie są uważane za klasy bazowe.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="6c4e8-169">Interfejsy zostały omówione w temacie [interfejsy](Interfaces.md) .</span><span class="sxs-lookup"><span data-stu-id="6c4e8-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="6c4e8-170">Można uzyskać dostęp do metod i właściwości klasy podstawowej z klasy pochodnej przy użyciu słowa kluczowego `base` Language jako identyfikatora, po którym następuje kropka (.) i nazwa elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="6c4e8-171">Aby uzyskać więcej informacji, [](inheritance.md)Zobacz dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="6c4e8-172">Sekcja członkowie</span><span class="sxs-lookup"><span data-stu-id="6c4e8-172">Members Section</span></span>

<span data-ttu-id="6c4e8-173">Można definiować metody statyczne lub wystąpienia, właściwości, implementacje interfejsów, abstrakcyjne elementy członkowskie, deklaracje zdarzeń i dodatkowe konstruktory w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="6c4e8-174">W tej sekcji nie można wyświetlać powiązań let i do.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="6c4e8-175">Ponieważ elementy członkowskie mogą być dodawane do różnych F# typów Oprócz klas, są one omówione w osobnych tematach, elementach [członkowskich](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="6c4e8-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](./members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="6c4e8-176">Wzajemnie cykliczne typy</span><span class="sxs-lookup"><span data-stu-id="6c4e8-176">Mutually Recursive Types</span></span>

<span data-ttu-id="6c4e8-177">W przypadku definiowania typów, które odwołują się do siebie w sposób cykliczny, można ciągować razem definicje typu `and` za pomocą słowa kluczowego.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="6c4e8-178">`and` Słowo kluczowe `type` zastępuje słowo kluczowe dla wszystkich oprócz pierwszej definicji w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="6c4e8-179">Dane wyjściowe to lista wszystkich plików w bieżącym katalogu.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="6c4e8-180">Kiedy używać klas, Unii, rekordów i struktur</span><span class="sxs-lookup"><span data-stu-id="6c4e8-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="6c4e8-181">Uwzględniając różne typy do wyboru, należy dobrze zrozumieć, co każdy typ jest przeznaczony do wyboru w celu wybrania odpowiedniego typu dla konkretnej sytuacji.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="6c4e8-182">Klasy są przeznaczone do użycia w kontekstach programowania zorientowanego obiektowo.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="6c4e8-183">Programowanie zorientowane obiektowo to dominujący model używany w aplikacjach, które są napisywane dla .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="6c4e8-184">Jeśli F# kod musi ściśle współpracować z .NET Framework lub inną biblioteką zorientowaną obiektowo, a zwłaszcza w przypadku, gdy konieczne jest przeciągnięcie z systemu typu zorientowanego obiektowo, takiego jak biblioteka UI, klasy są prawdopodobnie odpowiednie.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="6c4e8-185">Jeśli nie prowadzisz ścisłej współpracy z kodem zorientowanym obiektowo lub jeśli piszesz kod, który jest niezależny i dlatego jest chroniony przed częste interakcje z kodem zorientowanym obiektowo, należy rozważyć użycie rekordów i Unii rozłącznych.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="6c4e8-186">Pojedyncza, dobrze przemyślana Unia, wraz z odpowiednim kodem zgodnym z wzorcem, może być często używana jako uproszczona alternatywa dla hierarchii obiektów.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="6c4e8-187">Aby uzyskać więcej informacji na temat związków rozłącznych, zobacz [związki](discriminated-unions.md)rozłączne.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="6c4e8-188">Rekordy mają zalety uproszczenia niż klasy, ale rekordy nie są odpowiednie, gdy wymagania typu wykraczają poza to, co można osiągnąć przy użyciu prostoty.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="6c4e8-189">Rekordy są zasadniczo prostymi agregacjami wartości bez oddzielnych konstruktorów, które mogą wykonywać niestandardowe akcje, bez ukrytych pól i bez dziedziczenia lub implementacji interfejsów.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="6c4e8-190">Mimo że elementy członkowskie, takie jak właściwości i metody, można dodać do rekordów, aby zachować zachowanie bardziej złożone, pola przechowywane w rekordzie nadal są prostą agregacją wartości.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="6c4e8-191">Aby uzyskać więcej informacji o rekordach, zobacz [rekordy](records.md).</span><span class="sxs-lookup"><span data-stu-id="6c4e8-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="6c4e8-192">Struktury są również przydatne w przypadku małych zagregowanych danych, ale różnią się od klas i rekordów, które są typami wartości .NET.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="6c4e8-193">Klasy i rekordy są typami odwołań platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="6c4e8-194">Semantyka typów wartości i typów referencyjnych różni się w zależności od wartości.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="6c4e8-195">Oznacza to, że są one kopiowane bit dla bitu, gdy są przesyłane jako parametr lub zwracane z funkcji.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="6c4e8-196">Są one również przechowywane na stosie lub, jeśli są używane jako pola osadzone w obiekcie nadrzędnym, a nie przechowywane we własnej osobnej lokalizacji na stercie.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="6c4e8-197">W związku z tym struktury są odpowiednie dla często używanych danych, gdy narzuty dostępu do sterty jest problemem.</span><span class="sxs-lookup"><span data-stu-id="6c4e8-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="6c4e8-198">Aby uzyskać więcej informacji na temat struktur, zobacz [struktury](structures.md).</span><span class="sxs-lookup"><span data-stu-id="6c4e8-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="6c4e8-199">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="6c4e8-199">See also</span></span>

- [<span data-ttu-id="6c4e8-200">Dokumentacja języka F#</span><span class="sxs-lookup"><span data-stu-id="6c4e8-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="6c4e8-201">Elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="6c4e8-201">Members</span></span>](./members/index.md)
- [<span data-ttu-id="6c4e8-202">Dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="6c4e8-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="6c4e8-203">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="6c4e8-203">Interfaces</span></span>](interfaces.md)
