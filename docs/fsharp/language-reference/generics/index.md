---
title: "Typy ogólne (F#)"
description: "Dowiedz się, jak używać funkcje ogólne F # i typy, które umożliwiają pisania kodu, który współpracuje z różnymi typami bez powtarzania kodu."
keywords: "Visual f #, f #, funkcjonalności programowania"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: a9f2e2ee-bcb1-4ce3-8531-850aa183040f
ms.openlocfilehash: e7a5712fddf4d372d1ada86927f50e394a59a410
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2017
---
# <a name="generics"></a><span data-ttu-id="f30ba-104">Typy ogólne</span><span class="sxs-lookup"><span data-stu-id="f30ba-104">Generics</span></span>

<span data-ttu-id="f30ba-105">Funkcja F # wartości, metody, właściwości oraz typy agregacji, takich jak klasy, rejestruje i mogą być rozłączne *ogólnego*.</span><span class="sxs-lookup"><span data-stu-id="f30ba-105">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="f30ba-106">Konstrukcje ogólnego zawiera co najmniej jeden parametr typu, który zazwyczaj jest podany przez użytkownika Ogólna konstrukcja.</span><span class="sxs-lookup"><span data-stu-id="f30ba-106">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="f30ba-107">Funkcje ogólne i typy umożliwiają pisania kodu, który współpracuje z różnymi typami bez powtarzania kod dla każdego typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-107">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="f30ba-108">Tworzenie Kod rodzajowy może być proste w F #, ponieważ często kodu jest niejawnie wywnioskować, aby wartość była ogólna wnioskowanie o typie kompilatora i mechanizmów automatyczna Generalizacja.</span><span class="sxs-lookup"><span data-stu-id="f30ba-108">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>


## <a name="syntax"></a><span data-ttu-id="f30ba-109">Składnia</span><span class="sxs-lookup"><span data-stu-id="f30ba-109">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="f30ba-110">Uwagi</span><span class="sxs-lookup"><span data-stu-id="f30ba-110">Remarks</span></span>
<span data-ttu-id="f30ba-111">Deklaracja jawnie ogólnego funkcja lub typ jest inny niż ogólny funkcja lub typ, z wyjątkiem specyfikacji (i użyj) parametrów typu w nawiasach ostrych po nazwie funkcji lub typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-111">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="f30ba-112">Deklaracje są często niejawnie ogólnego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-112">Declarations are often implicitly generic.</span></span> <span data-ttu-id="f30ba-113">Jeśli nie zostanie całkowicie typu co parametr, który służy do tworzenia funkcji lub typu, kompilator próbuje wnioskować o typie każdego parametru, wartość oraz zmiennej tworzonego kodu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-113">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="f30ba-114">Aby uzyskać więcej informacji, zobacz [wnioskowanie o typie](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="f30ba-114">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="f30ba-115">Jeśli kod typu lub funkcji nie inaczej ograniczyć typami parametrów, funkcji lub typu jest niejawnie rodzajowa.</span><span class="sxs-lookup"><span data-stu-id="f30ba-115">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="f30ba-116">Ten proces nosi nazwę *automatyczna Generalizacja*.</span><span class="sxs-lookup"><span data-stu-id="f30ba-116">This process is named *automatic generalization*.</span></span> <span data-ttu-id="f30ba-117">Istnieją pewne ograniczenia na automatyczna Generalizacja.</span><span class="sxs-lookup"><span data-stu-id="f30ba-117">There are some limits on automatic generalization.</span></span> <span data-ttu-id="f30ba-118">Na przykład w przypadku nie można wywnioskować typów dla Ogólna konstrukcja kompilator języka F #, kompilator zgłasza błąd, który odwołuje się do ograniczenia o nazwie *wartość ograniczenia*.</span><span class="sxs-lookup"><span data-stu-id="f30ba-118">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="f30ba-119">W takim przypadku należy dodać niektóre adnotacji typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-119">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="f30ba-120">Aby uzyskać więcej informacji na temat automatyczna Generalizacja i ograniczenie wartości oraz jak zmienić swój kod, aby rozwiązać problem, zobacz [automatyczna Generalizacja](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="f30ba-120">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="f30ba-121">W poprzednich składni *parametry typu* jest rozdzielaną przecinkami listę parametrów, które reprezentują nieznanych typów, z których każdy rozpoczyna się od pojedynczego cudzysłowu, opcjonalnie z klauzula constraint ograniczającego dodatkowe typy mogą można użyć dla tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-121">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="f30ba-122">Składni ograniczenia klauzule różnego rodzaju oraz inne informacje o ograniczeniach, zobacz [ograniczenia](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="f30ba-122">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="f30ba-123">*Definicji typu* w składni jest taka sama jak definicji typu dla typu nieogólnego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-123">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="f30ba-124">Zawiera parametry konstruktora dla typu klasy, opcjonalny `as` klauzuli, symbol taki sam, pola rekordu `inherit` klauzuli, wybór rozróżnianą Unię `let` i `do` powiązań, definicji elementu członkowskiego i nic więcej w definicji typu nieogólnego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-124">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="f30ba-125">Inne elementy składni są takie same jak te funkcje nieogólnego i typów.</span><span class="sxs-lookup"><span data-stu-id="f30ba-125">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="f30ba-126">Na przykład *identyfikator obiektu* jest identyfikatorem, który reprezentuje samego obiektu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-126">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="f30ba-127">Właściwości, pól i konstruktory nie może być bardziej ogólne niż typ otaczający.</span><span class="sxs-lookup"><span data-stu-id="f30ba-127">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="f30ba-128">Ponadto w module nie mogą być ogólne.</span><span class="sxs-lookup"><span data-stu-id="f30ba-128">Also, values in a module cannot be generic.</span></span>


## <a name="implicitly-generic-constructs"></a><span data-ttu-id="f30ba-129">Konstrukcje niejawnie ogólny</span><span class="sxs-lookup"><span data-stu-id="f30ba-129">Implicitly Generic Constructs</span></span>
<span data-ttu-id="f30ba-130">Gdy kompilator języka F # wnioskuje typów w kodzie, automatycznie traktuje dowolnej funkcji, które mogą być ogólne jako ogólnego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-130">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="f30ba-131">Jeśli jawnie określić typ takich jak parametr typu, możesz zapobiec automatyczna Generalizacja.</span><span class="sxs-lookup"><span data-stu-id="f30ba-131">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="f30ba-132">W poniższym przykładzie kodu `makeList` jest rodzajowy, nawet jeśli ten plik ani jego parametrów są jawnie deklarować jako ogólnego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-132">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="f30ba-133">Podpis funkcji jest wywnioskowany jako `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="f30ba-133">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="f30ba-134">Należy pamiętać, że `a` i `b` w tym przykładzie są wartością tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-134">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="f30ba-135">Jest tak, ponieważ są one razem uwzględnione na liście, a wszystkie elementy listy muszą być tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-135">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="f30ba-136">Możesz również wprowadzić funkcję ogólnego za pomocą składni pojedynczego cudzysłowu w adnotację typu, aby wskazać, że parametr typu jest parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-136">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="f30ba-137">W poniższym kodzie `function1` jest rodzajowy, ponieważ jego parametrów są zadeklarowane w ten sposób jako parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-137">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]
    
## <a name="explicitly-generic-constructs"></a><span data-ttu-id="f30ba-138">Konstrukcje jawnie ogólny</span><span class="sxs-lookup"><span data-stu-id="f30ba-138">Explicitly Generic Constructs</span></span>
<span data-ttu-id="f30ba-139">Można również ustawić funkcję ogólnego przez zadeklarowanie jawnie swoich parametrów typu w nawiasach ostrych (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="f30ba-139">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="f30ba-140">Ilustruje to poniższy kod.</span><span class="sxs-lookup"><span data-stu-id="f30ba-140">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]
    
## <a name="using-generic-constructs"></a><span data-ttu-id="f30ba-141">Przy użyciu zwykłego konstrukcji</span><span class="sxs-lookup"><span data-stu-id="f30ba-141">Using Generic Constructs</span></span>
<span data-ttu-id="f30ba-142">Korzystając z funkcji ogólnego lub metody, nie masz określić argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-142">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="f30ba-143">Kompilator używa wnioskowanie o typie można wywnioskować argumentów odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-143">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="f30ba-144">Jeśli nadal niejednoznaczności, można podać argumentów typu w nawiasy, oddzielając przecinkami wiele argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-144">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="f30ba-145">Poniższy kod przedstawia użycie funkcji, które są zdefiniowane w poprzednich sekcjach.</span><span class="sxs-lookup"><span data-stu-id="f30ba-145">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]
    
>[!NOTE]
<span data-ttu-id="f30ba-146">Istnieją dwa sposoby odwołuje się do typu ogólnego według nazwy.</span><span class="sxs-lookup"><span data-stu-id="f30ba-146">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="f30ba-147">Na przykład `list<int>` i `int list` są dwa sposoby odwołuje się do typu ogólnego `list` mający jednym typem argumentu `int`.</span><span class="sxs-lookup"><span data-stu-id="f30ba-147">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="f30ba-148">Ostatni formularz jest powszechnie używana tylko z wbudowanych typów F # takich jak `list` i `option`.</span><span class="sxs-lookup"><span data-stu-id="f30ba-148">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="f30ba-149">Jeśli istnieje wiele argumentów typu, zwykle jest używana składnia `Dictionary<int, string>` , ale można również używać składni `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="f30ba-149">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="f30ba-150">Symboli wieloznacznych jako argumentów typu</span><span class="sxs-lookup"><span data-stu-id="f30ba-150">Wildcards as Type Arguments</span></span>
<span data-ttu-id="f30ba-151">Aby określić, że argument typu powinny być zakładane przez kompilator, można użyć znaku podkreślenia lub symbolu wieloznacznego (`_`), zamiast argumentu nazwanego typu.</span><span class="sxs-lookup"><span data-stu-id="f30ba-151">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="f30ba-152">Przedstawiono to w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="f30ba-152">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]
    
## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="f30ba-153">Ograniczenia ogólne typy i funkcje</span><span class="sxs-lookup"><span data-stu-id="f30ba-153">Constraints in Generic Types and Functions</span></span>
<span data-ttu-id="f30ba-154">W ogólnym typie lub definicji funkcji można użyć tylko tych konstrukcji, które są dostępne na parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="f30ba-154">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="f30ba-155">Jest to wymagane w celu włączenia weryfikacji wywołania funkcji i metody w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="f30ba-155">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="f30ba-156">Parametry typu jest jawnie zadeklarowana, można zastosować jawne ograniczenia parametru typu ogólnego, aby powiadomić kompilator niektórych metod i funkcje są dostępne.</span><span class="sxs-lookup"><span data-stu-id="f30ba-156">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="f30ba-157">Jednak jeśli zezwolisz wnioskować Twojej typy parametrów ogólnych kompilator języka F # zostanie określone odpowiednie ograniczenia dla Ciebie.</span><span class="sxs-lookup"><span data-stu-id="f30ba-157">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="f30ba-158">Aby uzyskać więcej informacji, zobacz [ograniczenia](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="f30ba-158">For more information, see [Constraints](constraints.md).</span></span>


## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="f30ba-159">Statycznie rozwiązywane parametry typu</span><span class="sxs-lookup"><span data-stu-id="f30ba-159">Statically Resolved Type Parameters</span></span>
<span data-ttu-id="f30ba-160">Istnieją dwa rodzaje parametrów typu, których można użyć w programach F #.</span><span class="sxs-lookup"><span data-stu-id="f30ba-160">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="f30ba-161">Pierwszy są parametry typu ogólnego określonych w poprzednich sekcjach.</span><span class="sxs-lookup"><span data-stu-id="f30ba-161">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="f30ba-162">Tego rodzaju pierwszy parametr typu jest odpowiednikiem parametry typu ogólnego, które są używane w językach takich jak Visual Basic i C#.</span><span class="sxs-lookup"><span data-stu-id="f30ba-162">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="f30ba-163">Inny rodzaj typu parametru są specyficzne dla języka F # i jest nazywany *parametr typu statycznie rozwiązywane*.</span><span class="sxs-lookup"><span data-stu-id="f30ba-163">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="f30ba-164">Informacje o tych konstrukcji, zobacz [statycznie rozwiązane parametrów typu](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="f30ba-164">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>


## <a name="examples"></a><span data-ttu-id="f30ba-165">Przykłady</span><span class="sxs-lookup"><span data-stu-id="f30ba-165">Examples</span></span>
[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]
    
## <a name="see-also"></a><span data-ttu-id="f30ba-166">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f30ba-166">See Also</span></span>
[<span data-ttu-id="f30ba-167">Odwołanie językowe</span><span class="sxs-lookup"><span data-stu-id="f30ba-167">Language Reference</span></span>](../index.md)

[<span data-ttu-id="f30ba-168">Typy</span><span class="sxs-lookup"><span data-stu-id="f30ba-168">Types</span></span>](../fsharp-types.md)

[<span data-ttu-id="f30ba-169">Statycznie rozwiązywane parametry typu</span><span class="sxs-lookup"><span data-stu-id="f30ba-169">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)

[<span data-ttu-id="f30ba-170">Typy ogólne w programie .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f30ba-170">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)

[<span data-ttu-id="f30ba-171">Automatyczna Generalizacja</span><span class="sxs-lookup"><span data-stu-id="f30ba-171">Automatic Generalization</span></span>](automatic-generalization.md)

[<span data-ttu-id="f30ba-172">Ograniczenia</span><span class="sxs-lookup"><span data-stu-id="f30ba-172">Constraints</span></span>](constraints.md)
