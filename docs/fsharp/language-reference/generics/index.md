---
title: Typy ogólne
description: Dowiedz się, F# jak używać funkcji i typów ogólnych, które umożliwiają pisanie kodu, który działa z różnymi typami bez powtarzania kodu.
ms.date: 05/16/2016
ms.openlocfilehash: 47eed0b8e074cfb591e6d8e2c382b9ea6a6e97f0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630608"
---
# <a name="generics"></a><span data-ttu-id="60b71-103">Typy ogólne</span><span class="sxs-lookup"><span data-stu-id="60b71-103">Generics</span></span>

<span data-ttu-id="60b71-104">F#wartości funkcji, metody, właściwości i typy agregujące, takie jak klasy, rekordy i Unii rozłącznych, mogą być *Ogólne*.</span><span class="sxs-lookup"><span data-stu-id="60b71-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="60b71-105">Konstrukcje generyczne zawierają co najmniej jeden parametr typu, który jest zwykle dostarczany przez użytkownika konstrukcji ogólnej.</span><span class="sxs-lookup"><span data-stu-id="60b71-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="60b71-106">Funkcje i typy ogólne umożliwiają pisanie kodu, który działa z różnymi typami bez powtarzania kodu dla każdego typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="60b71-107">Uczynienie kodu generycznego może być proste F#w, ponieważ często kod jest niejawnie wnioskowany jako ogólny przez wnioskowanie typu kompilatora i automatyczne mechanizmy generalize.</span><span class="sxs-lookup"><span data-stu-id="60b71-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="60b71-108">Składnia</span><span class="sxs-lookup"><span data-stu-id="60b71-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="60b71-109">Uwagi</span><span class="sxs-lookup"><span data-stu-id="60b71-109">Remarks</span></span>

<span data-ttu-id="60b71-110">Deklaracja jawnej funkcji ogólnej lub typu jest znacznie taka sama jak w przypadku funkcji niegenerycznej lub typu, z wyjątkiem specyfikacji (i użycia) parametrów typu w nawiasach kątowych po nazwie funkcji lub typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="60b71-111">Deklaracje są często niejawnie rodzajowe.</span><span class="sxs-lookup"><span data-stu-id="60b71-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="60b71-112">Jeśli nie określisz w pełni typu każdego parametru, który jest używany do redagowania funkcji lub typu, kompilator próbuje wnioskować o typie każdego parametru, wartości i zmiennej z kodu, który napiszesz.</span><span class="sxs-lookup"><span data-stu-id="60b71-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="60b71-113">Aby uzyskać więcej informacji, zobacz wnioskowanie o [typie](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="60b71-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="60b71-114">Jeśli kod typu lub funkcji nie ogranicza w inny sposób typów parametrów, funkcja lub typ są niejawnie rodzajowe.</span><span class="sxs-lookup"><span data-stu-id="60b71-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="60b71-115">Ten proces nosi nazwę *automatycznego uogólniania*.</span><span class="sxs-lookup"><span data-stu-id="60b71-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="60b71-116">Istnieją pewne ograniczenia dotyczące automatycznego uogólniania.</span><span class="sxs-lookup"><span data-stu-id="60b71-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="60b71-117">Jeśli na przykład F# kompilator nie może wywnioskować typów dla konstrukcji ogólnej, kompilator zgłosi błąd, który odwołuje się do ograniczenia o nazwie *ograniczenia wartości*.</span><span class="sxs-lookup"><span data-stu-id="60b71-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="60b71-118">W takim przypadku może być konieczne dodanie adnotacji typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="60b71-119">Aby uzyskać więcej informacji o automatycznym uogólnieniu i ograniczeniu wartości oraz sposobie zmiany kodu w celu rozwiązania problemu, zobacz [Automatyczne uogólnianie](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="60b71-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="60b71-120">W poprzedniej składni *Typ-parametry* jest rozdzielaną przecinkami listą parametrów, które reprezentują nieznane typy, z których każdy zaczyna się od pojedynczego znaku cudzysłowu, opcjonalnie z klauzulą ograniczenia, która dodatkowo ogranicza typy, które mogą być używane dla tego typu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="60b71-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="60b71-121">Aby poznać składnię klauzul ograniczenia różnych rodzajów i inne informacje o ograniczeniach, zobacz [ograniczenia](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="60b71-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="60b71-122">*Definicja typu* w składni jest taka sama jak definicja typu dla typu innego niż ogólny.</span><span class="sxs-lookup"><span data-stu-id="60b71-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="60b71-123">Obejmuje ona parametry konstruktora dla typu klasy, klauzulę opcjonalną `as` , znak równości, pola rekordu `inherit` , klauzulę, opcje dla Unii `let` rozłącznych i `do` powiązania, definicje elementów członkowskich, i wszystkie inne dozwolone w definicji typu nieogólnego.</span><span class="sxs-lookup"><span data-stu-id="60b71-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="60b71-124">Inne elementy składni są takie same jak dla funkcji i typów innych niż ogólne.</span><span class="sxs-lookup"><span data-stu-id="60b71-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="60b71-125">Na przykład *obiekt-identyfikator* to identyfikator reprezentujący zawierający go obiekt.</span><span class="sxs-lookup"><span data-stu-id="60b71-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="60b71-126">Właściwości, pola i konstruktory nie mogą być bardziej ogólne niż typ otaczający.</span><span class="sxs-lookup"><span data-stu-id="60b71-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="60b71-127">Ponadto wartości w module nie mogą być ogólne.</span><span class="sxs-lookup"><span data-stu-id="60b71-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="60b71-128">Niejawnie konstrukcje ogólne</span><span class="sxs-lookup"><span data-stu-id="60b71-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="60b71-129">Gdy F# kompilator wnioskuje typy w kodzie, automatycznie traktuje wszystkie funkcje, które mogą być generyczne jako ogólne.</span><span class="sxs-lookup"><span data-stu-id="60b71-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="60b71-130">W przypadku określenia typu jawnie, takiego jak typ parametru, można zapobiec automatycznemu generalizacji.</span><span class="sxs-lookup"><span data-stu-id="60b71-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="60b71-131">W poniższym przykładzie `makeList` kodu jest ogólny, nawet mimo że ani jego parametry nie są jawnie zadeklarowane jako ogólne.</span><span class="sxs-lookup"><span data-stu-id="60b71-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="60b71-132">Podpis funkcji jest wywnioskowany jako `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="60b71-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="60b71-133">Należy zauważyć `a` , `b` że i w tym przykładzie są wywnioskowane w celu uzyskania tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="60b71-134">Jest to spowodowane tym, że są one uwzględnione na liście razem, a wszystkie elementy listy muszą być tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="60b71-135">Możesz również uczynić funkcję ogólną przy użyciu składni pojedynczego cudzysłowu w adnotacji typu, aby wskazać, że typ parametru jest parametrem typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="60b71-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="60b71-136">W poniższym kodzie `function1` jest ogólny, ponieważ jego parametry są zadeklarowane w ten sposób jako parametry typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="60b71-137">Jawne konstrukcje generyczne</span><span class="sxs-lookup"><span data-stu-id="60b71-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="60b71-138">Można również wykonać funkcję ogólną, jawnie deklarując jej parametry typu w nawiasach kątowych (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="60b71-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="60b71-139">Ilustruje to poniższy kod.</span><span class="sxs-lookup"><span data-stu-id="60b71-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="60b71-140">Korzystanie z konstrukcji ogólnych</span><span class="sxs-lookup"><span data-stu-id="60b71-140">Using Generic Constructs</span></span>

<span data-ttu-id="60b71-141">W przypadku korzystania z funkcji ogólnych lub metod, może nie trzeba określać argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="60b71-142">Kompilator używa wnioskowania o typie do wnioskowania odpowiednich argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="60b71-143">Jeśli nadal występuje niejednoznaczność, można podać argumenty typu w nawiasach kątowych, oddzielając wiele argumentów typu przecinkami.</span><span class="sxs-lookup"><span data-stu-id="60b71-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="60b71-144">Poniższy kod przedstawia użycie funkcji, które są zdefiniowane w poprzednich sekcjach.</span><span class="sxs-lookup"><span data-stu-id="60b71-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

> [!NOTE]
> <span data-ttu-id="60b71-145">Istnieją dwa sposoby odwoływania się do typu ogólnego według nazwy.</span><span class="sxs-lookup"><span data-stu-id="60b71-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="60b71-146">Na przykład `list<int>` i `int list` są dwa sposoby odwoływania się do typu `list` ogólnego, który ma jeden argument `int`typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="60b71-147">Ten drugi formularz jest stosowany do Konwencji tylko z wbudowanymi F# typami, takimi `list` jak `option`i.</span><span class="sxs-lookup"><span data-stu-id="60b71-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="60b71-148">Jeśli istnieje wiele argumentów typu, zazwyczaj używana jest składnia `Dictionary<int, string>` , ale można również użyć składni. `(int, string) Dictionary`</span><span class="sxs-lookup"><span data-stu-id="60b71-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="60b71-149">Symbole wieloznaczne jako argumenty typu</span><span class="sxs-lookup"><span data-stu-id="60b71-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="60b71-150">Aby określić, że argument typu powinien być wywnioskowany przez kompilator, można użyć znaku podkreślenia lub symbolu wieloznacznego (`_`) zamiast argumentu nazwanego typu.</span><span class="sxs-lookup"><span data-stu-id="60b71-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="60b71-151">Jest to pokazane w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="60b71-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="60b71-152">Ograniczenia w typach ogólnych i funkcjach</span><span class="sxs-lookup"><span data-stu-id="60b71-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="60b71-153">W definicji typu ogólnego lub funkcji można używać tylko tych konstrukcji, które są znane jako dostępne dla parametru typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="60b71-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="60b71-154">Jest to wymagane, aby umożliwić weryfikację wywołań funkcji i metod w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="60b71-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="60b71-155">Jeśli jawnie deklarujesz parametry typu, możesz zastosować jawne ograniczenie do parametru typu ogólnego, aby powiadomić kompilator, że niektóre metody i funkcje są dostępne.</span><span class="sxs-lookup"><span data-stu-id="60b71-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="60b71-156">Jeśli jednak zezwolisz F# kompilatorowi na wnioskowanie o typach parametrów ogólnych, określisz odpowiednie ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="60b71-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="60b71-157">Aby uzyskać więcej informacji, zobacz [ograniczenia](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="60b71-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="60b71-158">Statycznie rozwiązywane parametry typu</span><span class="sxs-lookup"><span data-stu-id="60b71-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="60b71-159">Istnieją dwa rodzaje parametrów typu, które mogą być używane w F# programach.</span><span class="sxs-lookup"><span data-stu-id="60b71-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="60b71-160">Pierwsze są parametry typu ogólnego, które opisano w poprzednich sekcjach.</span><span class="sxs-lookup"><span data-stu-id="60b71-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="60b71-161">Ten pierwszy rodzaj parametru typu jest odpowiednikiem parametrów typu ogólnego, które są używane w językach takich jak Visual Basic i C#.</span><span class="sxs-lookup"><span data-stu-id="60b71-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="60b71-162">Inny rodzaj parametru typu jest specyficzny dla F# i jest określany jako *parametr typu statycznie rozpoznany*.</span><span class="sxs-lookup"><span data-stu-id="60b71-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="60b71-163">Aby uzyskać informacje o tych konstrukcjach, zobacz [statycznie rozpoznane parametry typu](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="60b71-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="60b71-164">Przykłady</span><span class="sxs-lookup"><span data-stu-id="60b71-164">Examples</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="60b71-165">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="60b71-165">See also</span></span>

- [<span data-ttu-id="60b71-166">Dokumentacja języka</span><span class="sxs-lookup"><span data-stu-id="60b71-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="60b71-167">Typy</span><span class="sxs-lookup"><span data-stu-id="60b71-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="60b71-168">Statycznie rozwiązywane parametry typu</span><span class="sxs-lookup"><span data-stu-id="60b71-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="60b71-169">Typy ogólne w .NET Framework</span><span class="sxs-lookup"><span data-stu-id="60b71-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)
- [<span data-ttu-id="60b71-170">Automatyczna generalizacja</span><span class="sxs-lookup"><span data-stu-id="60b71-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="60b71-171">Ograniczenia</span><span class="sxs-lookup"><span data-stu-id="60b71-171">Constraints</span></span>](constraints.md)
