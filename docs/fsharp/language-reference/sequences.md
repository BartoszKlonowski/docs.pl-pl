---
title: Sekwencje
description: 'Dowiedz się, jak używać sekwencji F #, gdy masz dużą, uporządkowaną kolekcję danych, ale niekoniecznie używać wszystkich elementów.'
ms.date: 08/13/2020
ms.openlocfilehash: c84e0aebcc79a595c0ae3b9075648fb629bdd65c
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/18/2020
ms.locfileid: "88559040"
---
# <a name="sequences"></a><span data-ttu-id="17193-103">Sekwencje</span><span class="sxs-lookup"><span data-stu-id="17193-103">Sequences</span></span>

<span data-ttu-id="17193-104">*Sekwencja* jest logiczną serią wszystkich elementów jednego typu.</span><span class="sxs-lookup"><span data-stu-id="17193-104">A *sequence* is a logical series of elements all of one type.</span></span> <span data-ttu-id="17193-105">Sekwencje są szczególnie przydatne w przypadku dużej, uporządkowanej kolekcji danych, ale niekoniecznie używać wszystkich elementów.</span><span class="sxs-lookup"><span data-stu-id="17193-105">Sequences are particularly useful when you have a large, ordered collection of data but do not necessarily expect to use all of the elements.</span></span> <span data-ttu-id="17193-106">Poszczególne elementy sekwencji są obliczane tylko w razie potrzeby, dlatego sekwencja może zapewnić lepszą wydajność niż lista w sytuacjach, w których nie wszystkie elementy są używane.</span><span class="sxs-lookup"><span data-stu-id="17193-106">Individual sequence elements are computed only as required, so a sequence can provide better performance than a list in situations in which not all the elements are used.</span></span> <span data-ttu-id="17193-107">Sekwencje są reprezentowane przez `seq<'T>` Typ, który jest aliasem dla <xref:System.Collections.Generic.IEnumerable%601> .</span><span class="sxs-lookup"><span data-stu-id="17193-107">Sequences are represented by the `seq<'T>` type, which is an alias for <xref:System.Collections.Generic.IEnumerable%601>.</span></span> <span data-ttu-id="17193-108">W związku z tym każdy typ .NET, który implementuje <xref:System.Collections.Generic.IEnumerable%601> interfejs, może być używany jako sekwencja.</span><span class="sxs-lookup"><span data-stu-id="17193-108">Therefore, any .NET type that implements <xref:System.Collections.Generic.IEnumerable%601> interface can be used as a sequence.</span></span> <span data-ttu-id="17193-109">[Moduł SEQ](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) zapewnia obsługę operacji dla operacji związanych z sekwencjami.</span><span class="sxs-lookup"><span data-stu-id="17193-109">The [Seq module](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) provides support for manipulations involving sequences.</span></span>

## <a name="sequence-expressions"></a><span data-ttu-id="17193-110">Wyrażenia sekwencji</span><span class="sxs-lookup"><span data-stu-id="17193-110">Sequence Expressions</span></span>

<span data-ttu-id="17193-111">*Wyrażenie sekwencji* jest wyrażeniem, którego wynikiem jest sekwencja.</span><span class="sxs-lookup"><span data-stu-id="17193-111">A *sequence expression* is an expression that evaluates to a sequence.</span></span> <span data-ttu-id="17193-112">Wyrażenia sekwencji mogą przyjmować wiele form.</span><span class="sxs-lookup"><span data-stu-id="17193-112">Sequence expressions can take a number of forms.</span></span> <span data-ttu-id="17193-113">Najprostsza forma określa zakres.</span><span class="sxs-lookup"><span data-stu-id="17193-113">The simplest form specifies a range.</span></span> <span data-ttu-id="17193-114">Na przykład `seq { 1 .. 5 }` tworzy sekwencję zawierającą pięć elementów, w tym punkty końcowe 1 i 5.</span><span class="sxs-lookup"><span data-stu-id="17193-114">For example, `seq { 1 .. 5 }` creates a sequence that contains five elements, including the endpoints 1 and 5.</span></span> <span data-ttu-id="17193-115">Możesz również określić przyrost (lub zmniejszany) między dwoma podwójnymi kropkami.</span><span class="sxs-lookup"><span data-stu-id="17193-115">You can also specify an increment (or decrement) between two double periods.</span></span> <span data-ttu-id="17193-116">Na przykład poniższy kod tworzy sekwencję wielokrotności 10.</span><span class="sxs-lookup"><span data-stu-id="17193-116">For example, the following code creates the sequence of multiples of 10.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

<span data-ttu-id="17193-117">Wyrażenia sekwencji składają się z wyrażeń F #, które tworzą wartości sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-117">Sequence expressions are made up of F# expressions that produce values of the sequence.</span></span> <span data-ttu-id="17193-118">Można również programowo generować wartości:</span><span class="sxs-lookup"><span data-stu-id="17193-118">You can also generate values programmatically:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

<span data-ttu-id="17193-119">Poprzedni przykład używa `->` operatora, który pozwala określić wyrażenie, którego wartość stanie się częścią sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-119">The previous sample uses the `->` operator, which allows you to specify an expression whose value will become a part of the sequence.</span></span> <span data-ttu-id="17193-120">Można używać tylko `->` wtedy, gdy każda część kodu, który następuje po zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="17193-120">You can only use `->` if every part of the code that follows it returns a value.</span></span>

<span data-ttu-id="17193-121">Alternatywnie możesz określić `do` słowo kluczowe, używając opcjonalnego `yield` :</span><span class="sxs-lookup"><span data-stu-id="17193-121">Alternatively, you can specify the `do` keyword, with an optional `yield` that follows:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

<span data-ttu-id="17193-122">Poniższy kod generuje listę par współrzędnych wraz z indeksem do tablicy, która reprezentuje siatkę.</span><span class="sxs-lookup"><span data-stu-id="17193-122">The following code generates a list of coordinate pairs along with an index into an array that represents the grid.</span></span> <span data-ttu-id="17193-123">Należy zauważyć, że pierwsze `for` wyrażenie wymaga `do` określenia.</span><span class="sxs-lookup"><span data-stu-id="17193-123">Note that the first `for` expression requires a `do` to be specified.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

<span data-ttu-id="17193-124">`if`Wyrażenie użyte w sekwencji jest filtrem.</span><span class="sxs-lookup"><span data-stu-id="17193-124">An `if` expression used in a sequence is a filter.</span></span> <span data-ttu-id="17193-125">Na przykład, aby wygenerować sekwencję tylko liczb pierwszych, przy założeniu, że masz funkcję `isprime` typu `int -> bool` , Konstruuj sekwencję w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="17193-125">For example, to generate a sequence of only prime numbers, assuming that you have a function `isprime` of type `int -> bool`, construct the sequence as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

<span data-ttu-id="17193-126">Jak wspomniano wcześniej, w `do` tym miejscu jest wymagane, ponieważ nie ma `else` rozgałęzienia z `if` .</span><span class="sxs-lookup"><span data-stu-id="17193-126">As mentioned previously, `do` is required here because there is no `else` branch that goes with the `if`.</span></span> <span data-ttu-id="17193-127">Jeśli spróbujesz użyć, otrzymasz komunikat `->` o błędzie informujący, że nie wszystkie gałęzie zwracają wartość.</span><span class="sxs-lookup"><span data-stu-id="17193-127">If you try to use `->`, you'll get an error saying that not all branches return a value.</span></span>

## <a name="the-yield-keyword"></a><span data-ttu-id="17193-128">Słowo kluczowe `yield!`</span><span class="sxs-lookup"><span data-stu-id="17193-128">The `yield!` keyword</span></span>

<span data-ttu-id="17193-129">Czasami może być konieczne dołączenie sekwencji elementów do innej sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-129">Sometimes, you may wish to include a sequence of elements into another sequence.</span></span> <span data-ttu-id="17193-130">Aby dołączyć sekwencję w innej sekwencji, należy użyć `yield!` słowa kluczowego:</span><span class="sxs-lookup"><span data-stu-id="17193-130">To include a sequence within another sequence, you'll need to use the `yield!` keyword:</span></span>

```fsharp
// Repeats '1 2 3 4 5' ten times
seq {
    for _ in 1..10 do
        yield! seq { 1; 2; 3; 4; 5}
}
```

<span data-ttu-id="17193-131">Innym sposobem na zastanawianie `yield!` się jest to, że spłaszcza sekwencję wewnętrzną, a następnie dołącza ją w sekwencji zawierającej.</span><span class="sxs-lookup"><span data-stu-id="17193-131">Another way of thinking of `yield!` is that it flattens an inner sequence and then includes that in the containing sequence.</span></span>

<span data-ttu-id="17193-132">Gdy `yield!` jest używany w wyrażeniu, wszystkie pozostałe pojedyncze wartości muszą używać `yield` słowa kluczowego:</span><span class="sxs-lookup"><span data-stu-id="17193-132">When `yield!` is used in an expression, all other single values must use the `yield` keyword:</span></span>

```fsharp
// Combine repeated values with their values
seq {
    for x in 1..10 do
        yield x
        yield! seq { for i in 1..x -> i}
}
```

<span data-ttu-id="17193-133">Poprzedni przykład spowoduje utworzenie wartości `x` oprócz wszystkich wartości z `1` do `x` dla każdego z nich `x` .</span><span class="sxs-lookup"><span data-stu-id="17193-133">The previous example will produce the value of `x` in addition to all values from `1` to `x` for each `x`.</span></span>

## <a name="examples"></a><span data-ttu-id="17193-134">Przykłady</span><span class="sxs-lookup"><span data-stu-id="17193-134">Examples</span></span>

<span data-ttu-id="17193-135">W pierwszym przykładzie używane jest wyrażenie sekwencji zawierające iterację, filtr i wartość Yield do wygenerowania tablicy.</span><span class="sxs-lookup"><span data-stu-id="17193-135">The first example uses a sequence expression that contains an iteration, a filter, and a yield to generate an array.</span></span> <span data-ttu-id="17193-136">Ten kod drukuje sekwencję numerów pierwszych z zakresu od 1 do 100 w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="17193-136">This code prints a sequence of prime numbers between 1 and 100 to the console.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

<span data-ttu-id="17193-137">Poniższy przykład tworzy tabelę mnożenia, która składa się z krotek trzech elementów, z których każdy składa się z dwóch czynników i produktu:</span><span class="sxs-lookup"><span data-stu-id="17193-137">The following example creates a multiplication table that consists of tuples of three elements, each consisting of two factors and the product:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

<span data-ttu-id="17193-138">Poniższy przykład ilustruje użycie, `yield!` Aby połączyć poszczególne sekwencje w jedną końcową sekwencję.</span><span class="sxs-lookup"><span data-stu-id="17193-138">The following example demonstrates the use of `yield!` to combine individual sequences into a single final sequence.</span></span> <span data-ttu-id="17193-139">W takim przypadku sekwencje dla każdego poddrzewa w drzewie binarnym są łączone w funkcji cyklicznej, aby utworzyć ostateczną sekwencję.</span><span class="sxs-lookup"><span data-stu-id="17193-139">In this case, the sequences for each subtree in a binary tree are concatenated in a recursive function to produce the final sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a><span data-ttu-id="17193-140">Używanie sekwencji</span><span class="sxs-lookup"><span data-stu-id="17193-140">Using Sequences</span></span>

<span data-ttu-id="17193-141">Sekwencje obsługują wiele takich samych funkcji, jak [listy](lists.md).</span><span class="sxs-lookup"><span data-stu-id="17193-141">Sequences support many of the same functions as [lists](lists.md).</span></span> <span data-ttu-id="17193-142">Sekwencje obsługują również operacje, takie jak grupowanie i zliczanie przy użyciu funkcji generujących klucze.</span><span class="sxs-lookup"><span data-stu-id="17193-142">Sequences also support operations such as grouping and counting by using key-generating functions.</span></span> <span data-ttu-id="17193-143">Sekwencje obsługują również bardziej różnorodne funkcje wyodrębniania podsekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-143">Sequences also support more diverse functions for extracting subsequences.</span></span>

<span data-ttu-id="17193-144">Wiele typów danych, takich jak listy, tablice, zestawy i mapy, to niejawne sekwencje, ponieważ są wyliczalnymi kolekcjami.</span><span class="sxs-lookup"><span data-stu-id="17193-144">Many data types, such as lists, arrays, sets, and maps are implicitly sequences because they are enumerable collections.</span></span> <span data-ttu-id="17193-145">Funkcja, która przyjmuje sekwencję jako argument, działa z dowolnym ze wspólnych typów danych F #, oprócz dowolnego typu danych platformy .NET, który implementuje `System.Collections.Generic.IEnumerable<'T>` .</span><span class="sxs-lookup"><span data-stu-id="17193-145">A function that takes a sequence as an argument works with any of the common F# data types, in addition to any .NET data type that implements `System.Collections.Generic.IEnumerable<'T>`.</span></span> <span data-ttu-id="17193-146">W przeciwieństwie do funkcji, która przyjmuje listę jako argument, który może przyjmować tylko listy.</span><span class="sxs-lookup"><span data-stu-id="17193-146">Contrast this to a function that takes a list as an argument, which can only take lists.</span></span> <span data-ttu-id="17193-147">Typ `seq<'T>` jest skrótem typu dla `IEnumerable<'T>` .</span><span class="sxs-lookup"><span data-stu-id="17193-147">The type `seq<'T>` is a type abbreviation for `IEnumerable<'T>`.</span></span> <span data-ttu-id="17193-148">Oznacza to, że każdy typ implementujący rodzaj ogólny `System.Collections.Generic.IEnumerable<'T>` , który obejmuje tablice, listy, zestawy i mapy w języku F #, a także większość typów kolekcji .NET, jest zgodny z `seq` typem i można go używać wszędzie tam, gdzie jest oczekiwana sekwencja.</span><span class="sxs-lookup"><span data-stu-id="17193-148">This means that any type that implements the generic `System.Collections.Generic.IEnumerable<'T>`, which includes arrays, lists, sets, and maps in F#, and also most .NET collection types, is compatible with the `seq` type and can be used wherever a sequence is expected.</span></span>

## <a name="module-functions"></a><span data-ttu-id="17193-149">Funkcje modułu</span><span class="sxs-lookup"><span data-stu-id="17193-149">Module Functions</span></span>

<span data-ttu-id="17193-150">[Moduł SEQ](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) w [przestrzeni nazw FSharp. Collections](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections.html) zawiera funkcje do pracy z sekwencjami.</span><span class="sxs-lookup"><span data-stu-id="17193-150">The [Seq module](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) in the [FSharp.Collections namespace](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections.html) contains functions for working with sequences.</span></span> <span data-ttu-id="17193-151">Te funkcje działają również z listami, tablicami, mapami i zestawami, ponieważ wszystkie te typy są wyliczalne i dlatego mogą być traktowane jako sekwencje.</span><span class="sxs-lookup"><span data-stu-id="17193-151">These functions work with lists, arrays, maps, and sets as well, because all of those types are enumerable, and therefore can be treated as sequences.</span></span>

## <a name="creating-sequences"></a><span data-ttu-id="17193-152">Tworzenie sekwencji</span><span class="sxs-lookup"><span data-stu-id="17193-152">Creating Sequences</span></span>

<span data-ttu-id="17193-153">Sekwencje można tworzyć przy użyciu wyrażeń sekwencji, jak opisano wcześniej lub korzystając z określonych funkcji.</span><span class="sxs-lookup"><span data-stu-id="17193-153">You can create sequences by using sequence expressions, as described previously, or by using certain functions.</span></span>

<span data-ttu-id="17193-154">Można utworzyć pustą sekwencję przy użyciu [SEQ. Empty](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#empty)lub można utworzyć sekwencję tylko jednego określonego elementu przy użyciu [SEQ. singleton](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#singleton).</span><span class="sxs-lookup"><span data-stu-id="17193-154">You can create an empty sequence by using [Seq.empty](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#empty), or you can create a sequence of just one specified element by using [Seq.singleton](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#singleton).</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet9.fs)]

<span data-ttu-id="17193-155">Za pomocą [Seq.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#init) można utworzyć sekwencję, dla której elementy są tworzone za pomocą podania funkcji.</span><span class="sxs-lookup"><span data-stu-id="17193-155">You can use [Seq.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#init) to create a sequence for which the elements are created by using a function that you provide.</span></span> <span data-ttu-id="17193-156">Możesz również podać rozmiar sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-156">You also provide a size for the sequence.</span></span> <span data-ttu-id="17193-157">Ta funkcja jest tak samo jak [List.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#init), z tą różnicą, że elementy nie są tworzone, dopóki nie przeprowadzisz iteracji przez sekwencję.</span><span class="sxs-lookup"><span data-stu-id="17193-157">This function is just like [List.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#init), except that the elements are not created until you iterate through the sequence.</span></span> <span data-ttu-id="17193-158">Poniższy kod ilustruje użycie `Seq.init` .</span><span class="sxs-lookup"><span data-stu-id="17193-158">The following code illustrates the use of `Seq.init`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet10.fs)]

<span data-ttu-id="17193-159">Dane wyjściowe to</span><span class="sxs-lookup"><span data-stu-id="17193-159">The output is</span></span>

```console
0 10 20 30 40
```

<span data-ttu-id="17193-160">Za pomocą [SEQ. ofArray —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofArray) i [seq. ofList —&#60;&#62; funkcji](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofList)można tworzyć sekwencje z tablic i list.</span><span class="sxs-lookup"><span data-stu-id="17193-160">By using [Seq.ofArray](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofArray) and [Seq.ofList&#60;'T&#62; Function](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofList), you can create sequences from arrays and lists.</span></span> <span data-ttu-id="17193-161">Można jednak skonwertować tablice i listy na sekwencje przy użyciu operatora rzutowania.</span><span class="sxs-lookup"><span data-stu-id="17193-161">However, you can also convert arrays and lists to sequences by using a cast operator.</span></span> <span data-ttu-id="17193-162">W poniższym kodzie przedstawiono obie techniki.</span><span class="sxs-lookup"><span data-stu-id="17193-162">Both techniques are shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet11.fs)]

<span data-ttu-id="17193-163">Za pomocą [SEQ. Cast](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cast)można utworzyć sekwencję z niejednoznacznie wpisanej kolekcji, takiej jak te zdefiniowane w `System.Collections` .</span><span class="sxs-lookup"><span data-stu-id="17193-163">By using [Seq.cast](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cast), you can create a sequence from a weakly typed collection, such as those defined in `System.Collections`.</span></span> <span data-ttu-id="17193-164">Takie kolekcje o jednoznacznie określonym typie mają typ elementu `System.Object` i są wyliczane przy użyciu typu niegenerycznego `System.Collections.Generic.IEnumerable&#96;1` .</span><span class="sxs-lookup"><span data-stu-id="17193-164">Such weakly typed collections have the element type `System.Object` and are enumerated by using the non-generic `System.Collections.Generic.IEnumerable&#96;1` type.</span></span> <span data-ttu-id="17193-165">Poniższy kod ilustruje użycie programu `Seq.cast` w celu przekonwertowania na `System.Collections.ArrayList` sekwencję.</span><span class="sxs-lookup"><span data-stu-id="17193-165">The following code illustrates the use of `Seq.cast` to convert an `System.Collections.ArrayList` into a sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet12.fs)]

<span data-ttu-id="17193-166">Można zdefiniować nieskończone sekwencje przy użyciu funkcji [Seq.initInfinite](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#initInfinite) .</span><span class="sxs-lookup"><span data-stu-id="17193-166">You can define infinite sequences by using the [Seq.initInfinite](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#initInfinite) function.</span></span> <span data-ttu-id="17193-167">Dla takiej sekwencji można dostarczyć funkcję, która generuje każdy element z indeksu elementu.</span><span class="sxs-lookup"><span data-stu-id="17193-167">For such a sequence, you provide a function that generates each element from the index of the element.</span></span> <span data-ttu-id="17193-168">Nieskończone sekwencje są możliwe z powodu oceny z opóźnieniem; elementy są tworzone zgodnie z wymaganiami, wywołując funkcję, którą określisz.</span><span class="sxs-lookup"><span data-stu-id="17193-168">Infinite sequences are possible because of lazy evaluation; elements are created as needed by calling the function that you specify.</span></span> <span data-ttu-id="17193-169">Poniższy przykład kodu tworzy nieskończoną sekwencję liczb zmiennoprzecinkowych, w tym przypadku przemienny szereg reciprocals kwadratów kolejnych liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="17193-169">The following code example produces an infinite sequence of floating point numbers, in this case the alternating series of reciprocals of squares of successive integers.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet13.fs)]

<span data-ttu-id="17193-170">[SEQ. unfold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#unfold) generuje sekwencję z funkcji obliczeniowej, która przyjmuje stan i przekształca ją w celu utworzenia każdego kolejnego elementu w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-170">[Seq.unfold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#unfold) generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</span></span> <span data-ttu-id="17193-171">Stan to tylko wartość, która jest używana do obliczenia każdego elementu i może ulec zmianie, gdy każdy element jest obliczany.</span><span class="sxs-lookup"><span data-stu-id="17193-171">The state is just a value that is used to compute each element, and can change as each element is computed.</span></span> <span data-ttu-id="17193-172">Drugi argument `Seq.unfold` jest wartością początkową, która jest używana do uruchomienia sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-172">The second argument to `Seq.unfold` is the initial value that is used to start the sequence.</span></span> <span data-ttu-id="17193-173">`Seq.unfold` używa typu opcji dla stanu, który umożliwia zakończenie sekwencji przez zwrócenie `None` wartości.</span><span class="sxs-lookup"><span data-stu-id="17193-173">`Seq.unfold` uses an option type for the state, which enables you to terminate the sequence by returning the `None` value.</span></span> <span data-ttu-id="17193-174">Poniższy kod przedstawia dwa przykłady sekwencji `seq1` i `fib` , które są generowane przez `unfold` operację.</span><span class="sxs-lookup"><span data-stu-id="17193-174">The following code shows two examples of sequences, `seq1` and `fib`, that are generated by an `unfold` operation.</span></span> <span data-ttu-id="17193-175">Pierwszy, `seq1` , jest prostą sekwencją z liczbami do 20.</span><span class="sxs-lookup"><span data-stu-id="17193-175">The first, `seq1`, is just a simple sequence with numbers up to 20.</span></span> <span data-ttu-id="17193-176">Sekunda, `fib` ,, używa `unfold` do obliczania sekwencji Fibonacci.</span><span class="sxs-lookup"><span data-stu-id="17193-176">The second, `fib`, uses `unfold` to compute the Fibonacci sequence.</span></span> <span data-ttu-id="17193-177">Ponieważ każdy element w sekwencji Fibonacci jest sumą poprzednich dwóch liczb Fibonacci, wartość stanu jest krotką, która składa się z poprzednich dwóch liczb w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-177">Because each element in the Fibonacci sequence is the sum of the previous two Fibonacci numbers, the state value is a tuple that consists of the previous two numbers in the sequence.</span></span> <span data-ttu-id="17193-178">Wartość początkowa to `(1,1)` , pierwsze dwie liczby w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-178">The initial value is `(1,1)`, the first two numbers in the sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet14.fs)]

<span data-ttu-id="17193-179">Wynik jest następujący:</span><span class="sxs-lookup"><span data-stu-id="17193-179">The output is as follows:</span></span>

```console
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

<span data-ttu-id="17193-180">Poniższy kod to przykład, który używa wielu funkcji modułu sekwencji opisanych tutaj do generowania i obliczania wartości nieskończonych sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-180">The following code is an example that uses many of the sequence module functions described here to generate and compute the values of infinite sequences.</span></span> <span data-ttu-id="17193-181">Uruchomienie kodu może potrwać kilka minut.</span><span class="sxs-lookup"><span data-stu-id="17193-181">The code might take a few minutes to run.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a><span data-ttu-id="17193-182">Wyszukiwanie i znajdowanie elementów</span><span class="sxs-lookup"><span data-stu-id="17193-182">Searching and Finding Elements</span></span>

<span data-ttu-id="17193-183">Funkcje obsługi sekwencji dostępne dla list: [SEQ. Exists](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [SEQ. exists2 —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [SEQ. Find](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#find), [SEQ. FindIndex —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#findIndex), [SEQ. pobranie](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pick), [SEQ. tryFind —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFind)i [SEQ. tryFindIndex —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFindIndex).</span><span class="sxs-lookup"><span data-stu-id="17193-183">Sequences support functionality available with lists: [Seq.exists](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [Seq.exists2](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [Seq.find](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#find), [Seq.findIndex](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#findIndex), [Seq.pick](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pick), [Seq.tryFind](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFind), and [Seq.tryFindIndex](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFindIndex).</span></span> <span data-ttu-id="17193-184">Wersje tych funkcji, które są dostępne dla sekwencji, ocenią sekwencję tylko do elementu, który jest wyszukiwany.</span><span class="sxs-lookup"><span data-stu-id="17193-184">The versions of these functions that are available for sequences evaluate the sequence only up to the element that is being searched for.</span></span> <span data-ttu-id="17193-185">Aby zapoznać się z przykładami, zobacz [listy](lists.md).</span><span class="sxs-lookup"><span data-stu-id="17193-185">For examples, see [Lists](lists.md).</span></span>

## <a name="obtaining-subsequences"></a><span data-ttu-id="17193-186">Uzyskiwanie podsekwencji</span><span class="sxs-lookup"><span data-stu-id="17193-186">Obtaining Subsequences</span></span>

<span data-ttu-id="17193-187">[SEQ. Filter](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#filter) i [SEQ. Choose](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#choose) przypomina odpowiadające im funkcje, które są dostępne dla list, z tą różnicą, że filtrowanie i wybór nie występują do momentu obliczenia elementów sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-187">[Seq.filter](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#filter) and [Seq.choose](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#choose) are like the corresponding functions that are available for lists, except that the filtering and choosing does not occur until the sequence elements are evaluated.</span></span>

<span data-ttu-id="17193-188">[SEQ. Truncate](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#truncate) tworzy sekwencję z innej sekwencji, ale ogranicza sekwencję do określonej liczby elementów.</span><span class="sxs-lookup"><span data-stu-id="17193-188">[Seq.truncate](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#truncate) creates a sequence from another sequence, but limits the sequence to a specified number of elements.</span></span> <span data-ttu-id="17193-189">[SEQ. Take](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#take) tworzy nową sekwencję zawierającą tylko określoną liczbę elementów na początku sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-189">[Seq.take](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#take) creates a new sequence that contains only a specified number of elements from the start of a sequence.</span></span> <span data-ttu-id="17193-190">Jeśli w sekwencji znajduje się mniej elementów niż określono do wykonania, program `Seq.take` wygeneruje `System.InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="17193-190">If there are fewer elements in the sequence than you specify to take, `Seq.take` throws a `System.InvalidOperationException`.</span></span> <span data-ttu-id="17193-191">Różnica między `Seq.take` i `Seq.truncate` jest `Seq.truncate` niegenerująca błędu, jeśli liczba elementów jest mniejsza niż liczba określona przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="17193-191">The difference between `Seq.take` and `Seq.truncate` is that `Seq.truncate` does not produce an error if the number of elements is fewer than the number you specify.</span></span>

<span data-ttu-id="17193-192">Poniższy kod przedstawia zachowanie i różnice między `Seq.truncate` i `Seq.take` .</span><span class="sxs-lookup"><span data-stu-id="17193-192">The following code shows the behavior of and differences between `Seq.truncate` and `Seq.take`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet16.fs)]

<span data-ttu-id="17193-193">Dane wyjściowe przed wystąpieniem błędu są następujące.</span><span class="sxs-lookup"><span data-stu-id="17193-193">The output, before the error occurs, is as follows.</span></span>

```console
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
```

<span data-ttu-id="17193-194">Za pomocą [SEQ. TakeWhile —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#takeWhile), można określić funkcję predykatu (funkcję logiczną) i utworzyć sekwencję z innej sekwencji składającej się z tych elementów oryginalnej sekwencji, która jest predykatem `true` , ale zatrzymać przed pierwszym elementem, dla którego zwracany jest predykat `false` .</span><span class="sxs-lookup"><span data-stu-id="17193-194">By using [Seq.takeWhile](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#takeWhile), you can specify a predicate function (a Boolean function) and create a sequence from another sequence made up of those elements of the original sequence for which the predicate is `true`, but stop before the first element for which the predicate returns `false`.</span></span> <span data-ttu-id="17193-195">[SEQ. Skip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skip) zwraca sekwencję, która pomija określoną liczbę pierwszych elementów w innej sekwencji i zwraca pozostałe elementy.</span><span class="sxs-lookup"><span data-stu-id="17193-195">[Seq.skip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skip) returns a sequence that skips a specified number of the first elements of another sequence and returns the remaining elements.</span></span> <span data-ttu-id="17193-196">[SEQ. SkipWhile —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skipWhile) zwraca sekwencję, która pomija pierwsze elementy innej sekwencji, tak długo, jak predykat zwraca `true` , a następnie zwraca pozostałe elementy, rozpoczynając od pierwszego elementu, dla którego zwracany jest predykat `false` .</span><span class="sxs-lookup"><span data-stu-id="17193-196">[Seq.skipWhile](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skipWhile) returns a sequence that skips the first elements of another sequence as long as the predicate returns `true`, and then returns the remaining elements, starting with the first element for which the predicate returns `false`.</span></span>

<span data-ttu-id="17193-197">Poniższy przykład kodu ilustruje zachowanie i różnice między `Seq.takeWhile` , `Seq.skip` i `Seq.skipWhile` .</span><span class="sxs-lookup"><span data-stu-id="17193-197">The following code example illustrates the behavior of and differences between `Seq.takeWhile`, `Seq.skip`, and `Seq.skipWhile`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet17.fs)]

<span data-ttu-id="17193-198">Dane wyjściowe są następujące:</span><span class="sxs-lookup"><span data-stu-id="17193-198">The output is as follows.</span></span>

```console
1 4 9
36 49 64 81 100
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a><span data-ttu-id="17193-199">Przekształcanie sekwencji</span><span class="sxs-lookup"><span data-stu-id="17193-199">Transforming Sequences</span></span>

<span data-ttu-id="17193-200">[SEQ. parowania](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pairwise) tworzy nową sekwencję, w której kolejne elementy sekwencji wejściowej są pogrupowane w krotki.</span><span class="sxs-lookup"><span data-stu-id="17193-200">[Seq.pairwise](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pairwise) creates a new sequence in which successive elements of the input sequence are grouped into tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet18.fs)]

<span data-ttu-id="17193-201">[SEQ. Windowd](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#windowed) przypomina `Seq.pairwise` , z tą różnicą, że zamiast tworzenia sekwencji krotek tworzy sekwencję tablic zawierających kopie sąsiadujących elementów ( *okna*) z sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-201">[Seq.windowed](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#windowed) is like `Seq.pairwise`, except that instead of producing a sequence of tuples, it produces a sequence of arrays that contain copies of adjacent elements (a *window*) from the sequence.</span></span> <span data-ttu-id="17193-202">Należy określić liczbę sąsiadujących elementów, które mają być w każdej tablicy.</span><span class="sxs-lookup"><span data-stu-id="17193-202">You specify the number of adjacent elements you want in each array.</span></span>

<span data-ttu-id="17193-203">Poniższy przykład kodu demonstruje użycie `Seq.windowed` .</span><span class="sxs-lookup"><span data-stu-id="17193-203">The following code example demonstrates the use of `Seq.windowed`.</span></span> <span data-ttu-id="17193-204">W takim przypadku liczba elementów w oknie to 3.</span><span class="sxs-lookup"><span data-stu-id="17193-204">In this case the number of elements in the window is 3.</span></span> <span data-ttu-id="17193-205">W przykładzie zastosowano `printSeq` , który jest zdefiniowany w poprzednim przykładzie kodu.</span><span class="sxs-lookup"><span data-stu-id="17193-205">The example uses `printSeq`, which is defined in the previous code example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet180.fs)]

<span data-ttu-id="17193-206">Dane wyjściowe są następujące:</span><span class="sxs-lookup"><span data-stu-id="17193-206">The output is as follows.</span></span>

<span data-ttu-id="17193-207">Sekwencja początkowa:</span><span class="sxs-lookup"><span data-stu-id="17193-207">Initial sequence:</span></span>

```console
1.0 1.5 2.0 1.5 1.0 1.5

Windows of length 3:
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|]

Moving average:
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a><span data-ttu-id="17193-208">Operacje z wieloma sekwencjami</span><span class="sxs-lookup"><span data-stu-id="17193-208">Operations with Multiple Sequences</span></span>

<span data-ttu-id="17193-209">[Seq.zip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip) i [Seq.zip3](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip3) mają dwie lub trzy sekwencje i tworzą sekwencję krotek.</span><span class="sxs-lookup"><span data-stu-id="17193-209">[Seq.zip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip) and [Seq.zip3](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip3) take two or three sequences and produce a sequence of tuples.</span></span> <span data-ttu-id="17193-210">Te funkcje są podobne do odpowiednich funkcji dostępnych dla [list](lists.md).</span><span class="sxs-lookup"><span data-stu-id="17193-210">These functions are like the corresponding functions available for [lists](lists.md).</span></span> <span data-ttu-id="17193-211">Nie ma odpowiedniej funkcjonalności do oddzielenia jednej sekwencji na dwie lub więcej sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-211">There is no corresponding functionality to separate one sequence into two or more sequences.</span></span> <span data-ttu-id="17193-212">Jeśli potrzebujesz tej funkcji dla sekwencji, przekonwertuj sekwencję na listę i użyj funkcji [list. Rozpakuj](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#unzip).</span><span class="sxs-lookup"><span data-stu-id="17193-212">If you need this functionality for a sequence, convert the sequence to a list and use [List.unzip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#unzip).</span></span>

## <a name="sorting-comparing-and-grouping"></a><span data-ttu-id="17193-213">Sortowanie, porównywanie i grupowanie</span><span class="sxs-lookup"><span data-stu-id="17193-213">Sorting, Comparing, and Grouping</span></span>

<span data-ttu-id="17193-214">Funkcje sortowania obsługiwane dla list również działają z sekwencjami.</span><span class="sxs-lookup"><span data-stu-id="17193-214">The sorting functions supported for lists also work with sequences.</span></span> <span data-ttu-id="17193-215">Obejmuje to [SEQ. Sort](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sort) i [SEQ. SortBy —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sortBy).</span><span class="sxs-lookup"><span data-stu-id="17193-215">This includes [Seq.sort](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sort) and [Seq.sortBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sortBy).</span></span> <span data-ttu-id="17193-216">Te funkcje iterą przez całą sekwencję.</span><span class="sxs-lookup"><span data-stu-id="17193-216">These functions iterate through the whole sequence.</span></span>

<span data-ttu-id="17193-217">Można porównać dwie sekwencje przy użyciu funkcji [SEQ. CompareWith —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#compareWith) .</span><span class="sxs-lookup"><span data-stu-id="17193-217">You compare two sequences by using the [Seq.compareWith](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#compareWith) function.</span></span> <span data-ttu-id="17193-218">Funkcja porównuje kolejne elementy z kolei i przerywa, gdy napotka on pierwszą nierówną parę.</span><span class="sxs-lookup"><span data-stu-id="17193-218">The function compares successive elements in turn, and stops when it encounters the first unequal pair.</span></span> <span data-ttu-id="17193-219">Wszelkie dodatkowe elementy nie przyczyniają się do porównania.</span><span class="sxs-lookup"><span data-stu-id="17193-219">Any additional elements do not contribute to the comparison.</span></span>

<span data-ttu-id="17193-220">Poniższy kod ilustruje użycie `Seq.compareWith` .</span><span class="sxs-lookup"><span data-stu-id="17193-220">The following code shows the use of `Seq.compareWith`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet19.fs)]

<span data-ttu-id="17193-221">W poprzednim kodzie tylko pierwszy element jest obliczany i sprawdzany, a wynik to-1.</span><span class="sxs-lookup"><span data-stu-id="17193-221">In the previous code, only the first element is computed and examined, and the result is -1.</span></span>

<span data-ttu-id="17193-222">[SEQ. countBy —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#countBy) pobiera funkcję, która generuje wartość o nazwie *Key* dla każdego elementu.</span><span class="sxs-lookup"><span data-stu-id="17193-222">[Seq.countBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#countBy) takes a function that generates a value called a *key* for each element.</span></span> <span data-ttu-id="17193-223">Dla każdego elementu jest generowany klucz, wywołując tę funkcję dla każdego elementu.</span><span class="sxs-lookup"><span data-stu-id="17193-223">A key is generated for each element by calling this function on each element.</span></span> <span data-ttu-id="17193-224">`Seq.countBy` następnie zwraca sekwencję zawierającą wartości klucza oraz liczbę elementów, które wygenerowały każdą wartość klucza.</span><span class="sxs-lookup"><span data-stu-id="17193-224">`Seq.countBy` then returns a sequence that contains the key values, and a count of the number of elements that generated each value of the key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet201.fs)]

<span data-ttu-id="17193-225">Dane wyjściowe są następujące:</span><span class="sxs-lookup"><span data-stu-id="17193-225">The output is as follows.</span></span>

```console
(1, 34) (2, 33) (0, 33)
```

<span data-ttu-id="17193-226">Poprzednie dane wyjściowe pokazują, że wystąpiły 34 elementy oryginalnej sekwencji, która wygenerowała wartości Key 1, 33, które wygenerowały klucz 2 i 33 wartości, które wygenerowały klucz 0.</span><span class="sxs-lookup"><span data-stu-id="17193-226">The previous output shows that there were 34 elements of the original sequence that produced the key 1, 33 values that produced the key 2, and 33 values that produced the key 0.</span></span>

<span data-ttu-id="17193-227">Elementy sekwencji można grupować przez wywołanie [SEQ. GroupBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#groupBy).</span><span class="sxs-lookup"><span data-stu-id="17193-227">You can group elements of a sequence by calling [Seq.groupBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#groupBy).</span></span> <span data-ttu-id="17193-228">`Seq.groupBy` przyjmuje sekwencję i funkcję, która generuje klucz z elementu.</span><span class="sxs-lookup"><span data-stu-id="17193-228">`Seq.groupBy` takes a sequence and a function that generates a key from an element.</span></span> <span data-ttu-id="17193-229">Funkcja jest wykonywana na każdym elemencie sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-229">The function is executed on each element of the sequence.</span></span> <span data-ttu-id="17193-230">`Seq.groupBy` zwraca sekwencję krotek, gdzie pierwszy element każdej krotki jest kluczem, a drugi to sekwencja elementów, które tworzą ten klucz.</span><span class="sxs-lookup"><span data-stu-id="17193-230">`Seq.groupBy` returns a sequence of tuples, where the first element of each tuple is the key and the second is a sequence of elements that produce that key.</span></span>

<span data-ttu-id="17193-231">Poniższy przykład kodu ilustruje użycie programu `Seq.groupBy` do partycjonowania sekwencji liczb z 1 do 100 w trzech grupach, które mają odrębne wartości klucza 0, 1 i 2.</span><span class="sxs-lookup"><span data-stu-id="17193-231">The following code example shows the use of `Seq.groupBy` to partition the sequence of numbers from 1 to 100 into three groups that have the distinct key values 0, 1, and 2.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet202.fs)]

<span data-ttu-id="17193-232">Dane wyjściowe są następujące:</span><span class="sxs-lookup"><span data-stu-id="17193-232">The output is as follows.</span></span>

```console
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

<span data-ttu-id="17193-233">Można utworzyć sekwencję, która eliminuje zduplikowane elementy przez wywołanie [SEQ. DISTINCT](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinct).</span><span class="sxs-lookup"><span data-stu-id="17193-233">You can create a sequence that eliminates duplicate elements by calling [Seq.distinct](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinct).</span></span> <span data-ttu-id="17193-234">Można też użyć [SEQ. distinctBy —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinctBy), który pobiera funkcję generującą klucz do wywołania dla każdego elementu.</span><span class="sxs-lookup"><span data-stu-id="17193-234">Or you can use [Seq.distinctBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinctBy), which takes a key-generating function to be called on each element.</span></span> <span data-ttu-id="17193-235">Utworzona sekwencja zawiera elementy oryginalnej sekwencji, które mają unikatowe klucze; późniejsze elementy, które generują zduplikowany klucz do wcześniejszego elementu, są odrzucane.</span><span class="sxs-lookup"><span data-stu-id="17193-235">The resulting sequence contains elements of the original sequence that have unique keys; later elements that produce a duplicate key to an earlier element are discarded.</span></span>

<span data-ttu-id="17193-236">Poniższy przykład kodu ilustruje użycie `Seq.distinct` .</span><span class="sxs-lookup"><span data-stu-id="17193-236">The following code example illustrates the use of `Seq.distinct`.</span></span> <span data-ttu-id="17193-237">`Seq.distinct` jest przedstawiany przez generowanie sekwencji, które reprezentują liczby binarne, a następnie pokazuje, że jedyne różne elementy to 0 i 1.</span><span class="sxs-lookup"><span data-stu-id="17193-237">`Seq.distinct` is demonstrated by generating sequences that represent binary numbers, and then showing that the only distinct elements are 0 and 1.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet22.fs)]

<span data-ttu-id="17193-238">Poniższy kod ilustruje `Seq.distinctBy` , rozpoczynając od sekwencji zawierającej liczby ujemne i dodatnie oraz używając funkcji wartości bezwzględnej jako funkcji generującej klucz.</span><span class="sxs-lookup"><span data-stu-id="17193-238">The following code demonstrates `Seq.distinctBy` by starting with a sequence that contains negative and positive numbers and using the absolute value function as the key-generating function.</span></span> <span data-ttu-id="17193-239">Wynikowa sekwencja nie zawiera wszystkich liczb dodatnich, które odpowiadają liczbom ujemnym w sekwencji, ponieważ liczby ujemne występują wcześniej w sekwencji i w związku z tym są wybierane zamiast liczb dodatnich, które mają taką samą wartość bezwzględną lub klucz.</span><span class="sxs-lookup"><span data-stu-id="17193-239">The resulting sequence is missing all the positive numbers that correspond to the negative numbers in the sequence, because the negative numbers appear earlier in the sequence and therefore are selected instead of the positive numbers that have the same absolute value, or key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a><span data-ttu-id="17193-240">Sekwencje ReadOnly i buforowane</span><span class="sxs-lookup"><span data-stu-id="17193-240">Readonly and Cached Sequences</span></span>

<span data-ttu-id="17193-241">[SEQ. ReadOnly](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#readonly) tworzy kopię sekwencji tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="17193-241">[Seq.readonly](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#readonly) creates a read-only copy of a sequence.</span></span> <span data-ttu-id="17193-242">`Seq.readonly` jest przydatne, gdy masz kolekcję do odczytu i zapisu, na przykład tablicę, i nie chcesz modyfikować oryginalnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="17193-242">`Seq.readonly` is useful when you have a read-write collection, such as an array, and you do not want to modify the original collection.</span></span> <span data-ttu-id="17193-243">Ta funkcja może służyć do zachowywania hermetyzacji danych.</span><span class="sxs-lookup"><span data-stu-id="17193-243">This function can be used to preserve data encapsulation.</span></span> <span data-ttu-id="17193-244">W poniższym przykładzie kodu zostanie utworzony typ zawierający tablicę.</span><span class="sxs-lookup"><span data-stu-id="17193-244">In the following code example, a type that contains an array is created.</span></span> <span data-ttu-id="17193-245">Właściwość uwidacznia tablicę, ale zamiast zwracać tablicę, zwraca sekwencję utworzoną z tablicy przy użyciu `Seq.readonly` .</span><span class="sxs-lookup"><span data-stu-id="17193-245">A property exposes the array, but instead of returning an array, it returns a sequence that is created from the array by using `Seq.readonly`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet24.fs)]

<span data-ttu-id="17193-246">[SEQ. cache](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cache) tworzy przechowywaną wersję sekwencji.</span><span class="sxs-lookup"><span data-stu-id="17193-246">[Seq.cache](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cache) creates a stored version of a sequence.</span></span> <span data-ttu-id="17193-247">Użyj `Seq.cache` , aby uniknąć ponownej oceny sekwencji lub jeśli masz wiele wątków, które używają sekwencji, ale musisz się upewnić, że każdy element jest poddany działaniu tylko jeden raz.</span><span class="sxs-lookup"><span data-stu-id="17193-247">Use `Seq.cache` to avoid reevaluation of a sequence, or when you have multiple threads that use a sequence, but you must make sure that each element is acted upon only one time.</span></span> <span data-ttu-id="17193-248">Jeśli masz sekwencję, która jest używana przez wiele wątków, możesz mieć jeden wątek, który wylicza i oblicza wartości dla oryginalnej sekwencji, a pozostałe wątki mogą używać sekwencji w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="17193-248">When you have a sequence that is being used by multiple threads, you can have one thread that enumerates and computes the values for the original sequence, and remaining threads can use the cached sequence.</span></span>

## <a name="performing-computations-on-sequences"></a><span data-ttu-id="17193-249">Wykonywanie obliczeń na sekwencjach</span><span class="sxs-lookup"><span data-stu-id="17193-249">Performing Computations on Sequences</span></span>

<span data-ttu-id="17193-250">Proste operacje arytmetyczne są podobne do tych list, takich jak [SEQ. Average](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#average), [SEQ. sum](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sum), [SEQ. averageBy —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#averageBy), [SEQ. sumBy —](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sumBy)i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="17193-250">Simple arithmetic operations are like those of lists, such as [Seq.average](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#average), [Seq.sum](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sum), [Seq.averageBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#averageBy), [Seq.sumBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sumBy), and so on.</span></span>

<span data-ttu-id="17193-251">[SEQ. złożenie](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#fold), [SEQ. Zmniejsz](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#reduce)i [SEQ. Scan](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#scan) przypomina odpowiednie funkcje, które są dostępne dla list.</span><span class="sxs-lookup"><span data-stu-id="17193-251">[Seq.fold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#fold), [Seq.reduce](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#reduce), and [Seq.scan](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#scan) are like the corresponding functions that are available for lists.</span></span> <span data-ttu-id="17193-252">Sekwencje obsługują podzestaw pełnych wariantów tych funkcji, które obsługują listę.</span><span class="sxs-lookup"><span data-stu-id="17193-252">Sequences support a subset of the full variations of these functions that lists support.</span></span> <span data-ttu-id="17193-253">Aby uzyskać więcej informacji i przykładów, zobacz [listy](lists.md).</span><span class="sxs-lookup"><span data-stu-id="17193-253">For more information and examples, see [Lists](lists.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="17193-254">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="17193-254">See also</span></span>

- [<span data-ttu-id="17193-255">Dokumentacja języka F #</span><span class="sxs-lookup"><span data-stu-id="17193-255">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="17193-256">Typy F#</span><span class="sxs-lookup"><span data-stu-id="17193-256">F# Types</span></span>](fsharp-types.md)
