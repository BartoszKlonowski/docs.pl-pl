---
title: Zagadnienia dotyczące wydajności (entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 0ff018fe0d8199dcd790bcd3de18751662e0a92b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "79149742"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="9f884-102">Zagadnienia dotyczące wydajności (entity Framework)</span><span class="sxs-lookup"><span data-stu-id="9f884-102">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="9f884-103">W tym temacie opisano charakterystyki wydajności ADO.NET entity framework i zawiera pewne zagadnienia, aby poprawić wydajność aplikacji entity framework.</span><span class="sxs-lookup"><span data-stu-id="9f884-103">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="9f884-104">Etapy wykonywania kwerendy</span><span class="sxs-lookup"><span data-stu-id="9f884-104">Stages of Query Execution</span></span>  
 <span data-ttu-id="9f884-105">Aby lepiej zrozumieć wydajność zapytań w entity framework, jest przydatne do zrozumienia operacji, które występują, gdy kwerenda wykonuje względem modelu koncepcyjnego i zwraca dane jako obiekty.</span><span class="sxs-lookup"><span data-stu-id="9f884-105">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="9f884-106">W poniższej tabeli opisano tę serię operacji.</span><span class="sxs-lookup"><span data-stu-id="9f884-106">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="9f884-107">Operacja</span><span class="sxs-lookup"><span data-stu-id="9f884-107">Operation</span></span>|<span data-ttu-id="9f884-108">Koszt względny</span><span class="sxs-lookup"><span data-stu-id="9f884-108">Relative Cost</span></span>|<span data-ttu-id="9f884-109">Częstotliwość</span><span class="sxs-lookup"><span data-stu-id="9f884-109">Frequency</span></span>|<span data-ttu-id="9f884-110">Komentarze</span><span class="sxs-lookup"><span data-stu-id="9f884-110">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="9f884-111">Ładowanie metadanych</span><span class="sxs-lookup"><span data-stu-id="9f884-111">Loading metadata</span></span>|<span data-ttu-id="9f884-112">Średni</span><span class="sxs-lookup"><span data-stu-id="9f884-112">Moderate</span></span>|<span data-ttu-id="9f884-113">Raz w każdej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9f884-113">Once in each application domain.</span></span>|<span data-ttu-id="9f884-114">Metadane modelu i mapowania używane przez <xref:System.Data.Metadata.Edm.MetadataWorkspace>entity framework jest ładowany do .</span><span class="sxs-lookup"><span data-stu-id="9f884-114">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="9f884-115">Te metadane są buforowane globalnie i <xref:System.Data.Objects.ObjectContext> są dostępne dla innych wystąpień w tej samej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9f884-115">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="9f884-116">Otwieranie połączenia z bazą danych</span><span class="sxs-lookup"><span data-stu-id="9f884-116">Opening the database connection</span></span>|<span data-ttu-id="9f884-117">Umiarkowany<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-117">Moderate<sup>1</sup></span></span>|<span data-ttu-id="9f884-118">W razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="9f884-118">As needed.</span></span>|<span data-ttu-id="9f884-119">Ponieważ otwarte połączenie z bazą danych zużywa cenny zasób, entity framework otwiera i zamyka połączenie z bazą danych tylko w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="9f884-119">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="9f884-120">Można również jawnie otworzyć połączenie.</span><span class="sxs-lookup"><span data-stu-id="9f884-120">You can also explicitly open the connection.</span></span> <span data-ttu-id="9f884-121">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-121">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="9f884-122">Generowanie widoków</span><span class="sxs-lookup"><span data-stu-id="9f884-122">Generating views</span></span>|<span data-ttu-id="9f884-123">Wysoka</span><span class="sxs-lookup"><span data-stu-id="9f884-123">High</span></span>|<span data-ttu-id="9f884-124">Raz w każdej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9f884-124">Once in each application domain.</span></span> <span data-ttu-id="9f884-125">(Może być wstępnie wygenerowany.)</span><span class="sxs-lookup"><span data-stu-id="9f884-125">(Can be pre-generated.)</span></span>|<span data-ttu-id="9f884-126">Zanim entity Framework można wykonać kwerendę względem modelu koncepcyjnego lub zapisać zmiany w źródle danych, musi wygenerować zestaw lokalnych widoków kwerendy, aby uzyskać dostęp do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-126">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="9f884-127">Ze względu na wysokie koszty generowania tych widoków można wstępnie wygenerować widoki i dodać je do projektu w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="9f884-127">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="9f884-128">Aby uzyskać więcej informacji, zobacz [Jak: Wstępnie generować widoki, aby poprawić wydajność kwerendy](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-128">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="9f884-129">Przygotowywanie kwerendy</span><span class="sxs-lookup"><span data-stu-id="9f884-129">Preparing the query</span></span>|<span data-ttu-id="9f884-130">Umiarkowany<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-130">Moderate<sup>2</sup></span></span>|<span data-ttu-id="9f884-131">Raz dla każdego unikatowego zapytania.</span><span class="sxs-lookup"><span data-stu-id="9f884-131">Once for each unique query.</span></span>|<span data-ttu-id="9f884-132">Zawiera koszty tworzenia polecenia kwerendy, generowania drzewa poleceń na podstawie metadanych modelu i mapowania oraz definiowania kształtu zwróconych danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-132">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="9f884-133">Ponieważ teraz zarówno polecenia kwerendy encji SQL, jak i zapytania LINQ są buforowane, późniejsze wykonania tej samej kwerendy zajmują mniej czasu.</span><span class="sxs-lookup"><span data-stu-id="9f884-133">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="9f884-134">Nadal można użyć skompilowanych zapytań LINQ, aby zmniejszyć ten koszt w późniejszych wykonaniach i skompilowanych kwerend może być bardziej wydajne niż zapytania LINQ, które są automatycznie buforowane.</span><span class="sxs-lookup"><span data-stu-id="9f884-134">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="9f884-135">Aby uzyskać więcej informacji, zobacz [Skompilowane kwerendy (LINQ do jednostek)](./language-reference/compiled-queries-linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="9f884-135">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="9f884-136">Aby uzyskać ogólne informacje na temat wykonywania kwerend LINQ, zobacz [LINQ do jednostek](./language-reference/linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="9f884-136">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="9f884-137">**Uwaga:**  LINQ do jednostek kwerendy, które stosują `Enumerable.Contains` operatora do kolekcji w pamięci nie są automatycznie buforowane.</span><span class="sxs-lookup"><span data-stu-id="9f884-137">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="9f884-138">Również parametryzowanie kolekcji w pamięci w skompilowanych kwerend LINQ jest niedozwolone.</span><span class="sxs-lookup"><span data-stu-id="9f884-138">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="9f884-139">Wykonywanie kwerendy</span><span class="sxs-lookup"><span data-stu-id="9f884-139">Executing the query</span></span>|<span data-ttu-id="9f884-140">Niski<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-140">Low<sup>2</sup></span></span>|<span data-ttu-id="9f884-141">Raz dla każdej kwerendy.</span><span class="sxs-lookup"><span data-stu-id="9f884-141">Once for each query.</span></span>|<span data-ttu-id="9f884-142">Koszt wykonania polecenia względem źródła danych przy użyciu dostawcy danych ADO.NET.</span><span class="sxs-lookup"><span data-stu-id="9f884-142">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="9f884-143">Ponieważ większość źródeł danych buforuje plany kwerend, późniejsze wykonanie tej samej kwerendy może zająć jeszcze mniej czasu.</span><span class="sxs-lookup"><span data-stu-id="9f884-143">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="9f884-144">Ładowanie i sprawdzanie poprawności typów</span><span class="sxs-lookup"><span data-stu-id="9f884-144">Loading and validating types</span></span>|<span data-ttu-id="9f884-145">Niski<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-145">Low<sup>3</sup></span></span>|<span data-ttu-id="9f884-146">Raz dla <xref:System.Data.Objects.ObjectContext> każdego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9f884-146">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="9f884-147">Typy są ładowane i sprawdzane względem typów zdefiniowanych przez model koncepcyjny.</span><span class="sxs-lookup"><span data-stu-id="9f884-147">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="9f884-148">Śledzenie</span><span class="sxs-lookup"><span data-stu-id="9f884-148">Tracking</span></span>|<span data-ttu-id="9f884-149">Niski<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-149">Low<sup>3</sup></span></span>|<span data-ttu-id="9f884-150">Raz dla każdego obiektu, który zwraca kwerenda.</span><span class="sxs-lookup"><span data-stu-id="9f884-150">Once for each object that a query returns.</span></span> <span data-ttu-id="9f884-151"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-151"><sup>4</sup></span></span>|<span data-ttu-id="9f884-152">Jeśli kwerenda używa <xref:System.Data.Objects.MergeOption.NoTracking> opcji scalania, ten etap nie wpływa na wydajność.</span><span class="sxs-lookup"><span data-stu-id="9f884-152">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="9f884-153">Jeśli kwerenda używa <xref:System.Data.Objects.MergeOption.AppendOnly> <xref:System.Data.Objects.MergeOption.PreserveChanges>opcji <xref:System.Data.Objects.MergeOption.OverwriteChanges> , lub scalania, wyniki <xref:System.Data.Objects.ObjectStateManager>kwerendy są śledzone w pliku .</span><span class="sxs-lookup"><span data-stu-id="9f884-153">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="9f884-154">Jest <xref:System.Data.EntityKey> generowany dla każdego śledzonego obiektu, który zwraca <xref:System.Data.Objects.ObjectStateEntry> kwerenda <xref:System.Data.Objects.ObjectStateManager>i jest używany do tworzenia w programie .</span><span class="sxs-lookup"><span data-stu-id="9f884-154">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="9f884-155">Jeśli istniejące <xref:System.Data.Objects.ObjectStateEntry> można znaleźć <xref:System.Data.EntityKey>dla , istniejący obiekt jest zwracany.</span><span class="sxs-lookup"><span data-stu-id="9f884-155">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="9f884-156">Jeśli <xref:System.Data.Objects.MergeOption.PreserveChanges>używana <xref:System.Data.Objects.MergeOption.OverwriteChanges> jest opcja , lub opcja, obiekt jest aktualizowany przed jego zwrotem.</span><span class="sxs-lookup"><span data-stu-id="9f884-156">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="9f884-157">Aby uzyskać więcej informacji, zobacz [Rozpoznawanie tożsamości, Zarządzanie stanami i Śledzenie zmian](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-157">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="9f884-158">Materializacja obiektów</span><span class="sxs-lookup"><span data-stu-id="9f884-158">Materializing the objects</span></span>|<span data-ttu-id="9f884-159">Umiarkowany<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-159">Moderate<sup>3</sup></span></span>|<span data-ttu-id="9f884-160">Raz dla każdego obiektu, który zwraca kwerenda.</span><span class="sxs-lookup"><span data-stu-id="9f884-160">Once for each object that a query returns.</span></span> <span data-ttu-id="9f884-161"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="9f884-161"><sup>4</sup></span></span>|<span data-ttu-id="9f884-162">Proces odczytywania <xref:System.Data.Common.DbDataReader> zwracanego obiektu i tworzenia obiektów i ustawiania wartości właściwości, <xref:System.Data.Common.DbDataRecord> które są oparte na wartościach w każdym wystąpieniu klasy.</span><span class="sxs-lookup"><span data-stu-id="9f884-162">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="9f884-163">Jeśli obiekt już istnieje <xref:System.Data.Objects.ObjectContext> w kwerendzie, <xref:System.Data.Objects.MergeOption.AppendOnly> a <xref:System.Data.Objects.MergeOption.PreserveChanges> kwerenda używa opcji lub scalania, ten etap nie wpływa na wydajność.</span><span class="sxs-lookup"><span data-stu-id="9f884-163">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="9f884-164">Aby uzyskać więcej informacji, zobacz [Rozpoznawanie tożsamości, Zarządzanie stanami i Śledzenie zmian](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-164">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="9f884-165"><sup>1</sup> Gdy dostawca źródła danych implementuje buforowanie połączeń, koszt otwarcia połączenia jest rozdzielany między pulę.</span><span class="sxs-lookup"><span data-stu-id="9f884-165"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="9f884-166">Dostawca platformy .NET dla programu SQL Server obsługuje buforowanie połączeń.</span><span class="sxs-lookup"><span data-stu-id="9f884-166">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="9f884-167"><sup>2</sup> Koszt wzrasta wraz ze zwiększoną złożonością zapytań.</span><span class="sxs-lookup"><span data-stu-id="9f884-167"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="9f884-168"><sup>3</sup> Całkowity koszt zwiększa się proporcjonalnie do liczby obiektów zwracanych przez kwerendę.</span><span class="sxs-lookup"><span data-stu-id="9f884-168"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="9f884-169"><sup>4</sup> To obciążenie nie jest wymagane dla entityclient kwerend, <xref:System.Data.EntityClient.EntityDataReader> ponieważ zapytania EntityClient zwracać zamiast obiektów.</span><span class="sxs-lookup"><span data-stu-id="9f884-169"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="9f884-170">Aby uzyskać więcej informacji, zobacz [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span><span class="sxs-lookup"><span data-stu-id="9f884-170">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="9f884-171">Dodatkowe uwagi</span><span class="sxs-lookup"><span data-stu-id="9f884-171">Additional Considerations</span></span>  
 <span data-ttu-id="9f884-172">Poniżej przedstawiono inne zagadnienia, które mogą mieć wpływ na wydajność aplikacji entity framework.</span><span class="sxs-lookup"><span data-stu-id="9f884-172">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="9f884-173">Wykonywanie zapytania</span><span class="sxs-lookup"><span data-stu-id="9f884-173">Query Execution</span></span>  
 <span data-ttu-id="9f884-174">Ponieważ kwerendy mogą być intensywnie korzystające z zasobów, należy wziąć pod uwagę, w jakim punkcie w kodzie i na jakim komputerze kwerenda jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="9f884-174">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="9f884-175">Odroczone a natychmiastowe wykonanie</span><span class="sxs-lookup"><span data-stu-id="9f884-175">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="9f884-176">Podczas tworzenia <xref:System.Data.Objects.ObjectQuery%601> kwerendy lub LINQ kwerenda może nie być wykonywane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="9f884-176">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="9f884-177">Wykonanie kwerendy jest odroczone, dopóki wyniki `foreach` są potrzebne, `For Each` takie jak podczas (C#) lub (Visual Basic) wyliczenie lub gdy jest przypisany do wypełnienia <xref:System.Collections.Generic.List%601> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="9f884-177">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="9f884-178">Wykonanie kwerendy rozpoczyna się <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> natychmiast <xref:System.Data.Objects.ObjectQuery%601> po wywołaniu metody na lub po wywołaniu metody <xref:System.Linq.Enumerable.First%2A> <xref:System.Linq.Enumerable.Any%2A>LINQ, która zwraca kwerendę singleton, taką jak lub .</span><span class="sxs-lookup"><span data-stu-id="9f884-178">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="9f884-179">Aby uzyskać więcej informacji, zobacz [Kwerendy obiektów](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) i [wykonywanie zapytań (LINQ do jednostek)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="9f884-179">For more information, see [Object Queries](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="9f884-180">Wykonywanie zapytań LINQ po stronie klienta</span><span class="sxs-lookup"><span data-stu-id="9f884-180">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="9f884-181">Mimo że wykonanie kwerendy LINQ występuje na komputerze, na którym znajduje się źródło danych, niektóre części zapytania LINQ mogą być oceniane na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="9f884-181">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="9f884-182">Aby uzyskać więcej informacji, zobacz sekcję Wykonywanie magazynu [wykonywania kwerend (LINQ do jednostek).](./language-reference/query-execution.md)</span><span class="sxs-lookup"><span data-stu-id="9f884-182">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="9f884-183">Złożoność zapytań i mapowania</span><span class="sxs-lookup"><span data-stu-id="9f884-183">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="9f884-184">Złożoność poszczególnych zapytań i mapowania w modelu jednostki będzie miała znaczący wpływ na wydajność kwerendy.</span><span class="sxs-lookup"><span data-stu-id="9f884-184">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="9f884-185">Złożoność mapowania</span><span class="sxs-lookup"><span data-stu-id="9f884-185">Mapping complexity</span></span>  
 <span data-ttu-id="9f884-186">Modele, które są bardziej złożone niż proste mapowanie jeden do jednego między jednostkami w modelu koncepcyjnym i tabel w modelu magazynu generują bardziej złożone polecenia niż modele, które mają mapowanie jeden do jednego.</span><span class="sxs-lookup"><span data-stu-id="9f884-186">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="9f884-187">Złożoność kwerendy</span><span class="sxs-lookup"><span data-stu-id="9f884-187">Query complexity</span></span>  
 <span data-ttu-id="9f884-188">Kwerendy, które wymagają dużej liczby sprzężeń w poleceniach, które są wykonywane względem źródła danych lub które zwracają dużą ilość danych, mogą wpływać na wydajność w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9f884-188">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="9f884-189">Zapytania dotyczące modelu koncepcyjnego, które wydają się proste, mogą spowodować wykonanie bardziej złożonych zapytań względem źródła danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-189">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="9f884-190">Może to nastąpić, ponieważ Entity Framework tłumaczy kwerendę względem modelu koncepcyjnego na równoważne zapytanie względem źródła danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-190">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="9f884-191">Gdy pojedyncza jednostka ustawiona w modelu koncepcyjnym jest mapowana na więcej niż jedną tabelę w źródle danych lub gdy relacja między jednostkami jest mapowana do tabeli sprzężenia, polecenie kwerendy wykonywane względem kwerendy źródła danych może wymagać co najmniej jednego sprzężenia.</span><span class="sxs-lookup"><span data-stu-id="9f884-191">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="9f884-192">Użyj <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody <xref:System.Data.Objects.ObjectQuery%601> lub <xref:System.Data.EntityClient.EntityCommand> klas, aby wyświetlić polecenia, które są wykonywane względem źródła danych dla danej kwerendy.</span><span class="sxs-lookup"><span data-stu-id="9f884-192">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="9f884-193">Aby uzyskać więcej informacji, zobacz [Jak: Wyświetlanie poleceń sklepu](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-193">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="9f884-194">Zagnieżdżone encji zapytań SQL może utworzyć sprzężenia na serwerze i może zwrócić dużą liczbę wierszy.</span><span class="sxs-lookup"><span data-stu-id="9f884-194">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="9f884-195">Poniżej przedstawiono przykład zagnieżdżonej kwerendy w klauzuli rzutowania:</span><span class="sxs-lookup"><span data-stu-id="9f884-195">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="9f884-196">Ponadto takie zapytania powodują potok kwerendy do generowania pojedynczej kwerendy z duplikacji obiektów w kwerendach zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9f884-196">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="9f884-197">Z tego powodu pojedyncza kolumna może być duplikowana wiele razy.</span><span class="sxs-lookup"><span data-stu-id="9f884-197">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="9f884-198">W niektórych bazach danych, w tym SQL Server, może to spowodować, że tabela TempDB wzrośnie bardzo duże, co może zmniejszyć wydajność serwera.</span><span class="sxs-lookup"><span data-stu-id="9f884-198">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="9f884-199">Należy zwrócić uwagę podczas wykonywania zapytań zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9f884-199">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="9f884-200">Wszelkie kwerendy, które zwracają dużą ilość danych może spowodować zmniejszenie wydajności, jeśli klient wykonuje operacje, które zużywają zasoby w sposób, który jest proporcjonalny do rozmiaru zestawu wyników.</span><span class="sxs-lookup"><span data-stu-id="9f884-200">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="9f884-201">W takich przypadkach należy rozważyć ograniczenie ilości danych zwracanych przez kwerendę.</span><span class="sxs-lookup"><span data-stu-id="9f884-201">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="9f884-202">Aby uzyskać więcej informacji, zobacz [Jak: Wyniki kwerendy na stronie](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))—</span><span class="sxs-lookup"><span data-stu-id="9f884-202">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="9f884-203">Wszystkie polecenia generowane automatycznie przez entity framework może być bardziej skomplikowane niż podobne polecenia napisane jawnie przez dewelopera bazy danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-203">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="9f884-204">Jeśli potrzebujesz jawną kontrolę nad poleceniami wykonywanymi dla źródła danych, należy rozważyć zdefiniowanie mapowania do funkcji wycenianej w tabeli lub procedury składowanej.</span><span class="sxs-lookup"><span data-stu-id="9f884-204">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="9f884-205">Relacje</span><span class="sxs-lookup"><span data-stu-id="9f884-205">Relationships</span></span>  
 <span data-ttu-id="9f884-206">Aby uzyskać optymalną wydajność kwerendy, należy zdefiniować relacje między jednostkami zarówno jako skojarzenia w modelu jednostki, jak i jako relacje logiczne w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-206">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="9f884-207">Ścieżki kwerend</span><span class="sxs-lookup"><span data-stu-id="9f884-207">Query Paths</span></span>  
 <span data-ttu-id="9f884-208">Domyślnie podczas wykonywania <xref:System.Data.Objects.ObjectQuery%601>, powiązane obiekty nie są zwracane (chociaż obiekty, które reprezentują same relacje są).</span><span class="sxs-lookup"><span data-stu-id="9f884-208">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="9f884-209">Powiązane obiekty można załadować na jeden z trzech sposobów:</span><span class="sxs-lookup"><span data-stu-id="9f884-209">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="9f884-210">Ustaw ścieżkę kwerendy przed wykonaniem. <xref:System.Data.Objects.ObjectQuery%601></span><span class="sxs-lookup"><span data-stu-id="9f884-210">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="9f884-211">Wywołanie `Load` metody na właściwość nawigacji, który udostępnia obiekt.</span><span class="sxs-lookup"><span data-stu-id="9f884-211">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="9f884-212">Ustaw <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> opcję na <xref:System.Data.Objects.ObjectContext> `true`do .</span><span class="sxs-lookup"><span data-stu-id="9f884-212">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="9f884-213">Należy zauważyć, że odbywa się to automatycznie podczas generowania kodu warstwy obiektowej za pomocą [projektanta modeli danych jednostki](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-213">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="9f884-214">Aby uzyskać więcej informacji, zobacz [Omówienie wygenerowanego kodu](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-214">For more information see [Generated Code Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="9f884-215">Jeśli wziąć pod uwagę, która opcja użyć, należy pamiętać, że istnieje kompromis między liczbą żądań w bazie danych i ilość danych zwracanych w jednej kwerendzie.</span><span class="sxs-lookup"><span data-stu-id="9f884-215">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="9f884-216">Aby uzyskać więcej informacji, zobacz [Ładowanie powiązanych obiektów](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-216">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="9f884-217">Korzystanie ze ścieżek kwerend</span><span class="sxs-lookup"><span data-stu-id="9f884-217">Using query paths</span></span>  
 <span data-ttu-id="9f884-218">Ścieżki kwerend definiują wykres obiektów zwracanych przez kwerendę.</span><span class="sxs-lookup"><span data-stu-id="9f884-218">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="9f884-219">Podczas definiowania ścieżki kwerendy, tylko jedno żądanie względem bazy danych jest wymagane do zwrócenia wszystkich obiektów, które ścieżka definiuje.</span><span class="sxs-lookup"><span data-stu-id="9f884-219">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="9f884-220">Za pomocą ścieżek kwerend może spowodować złożone polecenia wykonywane względem źródła danych z pozornie prostych zapytań obiektów.</span><span class="sxs-lookup"><span data-stu-id="9f884-220">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="9f884-221">Dzieje się tak, ponieważ co najmniej jedno sprzężenia są wymagane do zwrócenia powiązanych obiektów w jednej kwerendzie.</span><span class="sxs-lookup"><span data-stu-id="9f884-221">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="9f884-222">Ta złożoność jest większa w kwerendach względem złożonego modelu jednostki, takiego jak jednostka z dziedziczeniem lub ścieżka, która zawiera relacje wiele do wielu.</span><span class="sxs-lookup"><span data-stu-id="9f884-222">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9f884-223">Użyj <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody, aby wyświetlić polecenie, <xref:System.Data.Objects.ObjectQuery%601>które zostanie wygenerowane przez plik .</span><span class="sxs-lookup"><span data-stu-id="9f884-223">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="9f884-224">Aby uzyskać więcej informacji, zobacz [Jak: Wyświetlanie poleceń sklepu](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-224">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="9f884-225">Jeśli ścieżka kwerendy zawiera zbyt wiele powiązanych obiektów lub obiekty zawierają zbyt dużo danych wiersza, źródło danych może nie być w stanie ukończyć kwerendy.</span><span class="sxs-lookup"><span data-stu-id="9f884-225">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="9f884-226">Dzieje się tak, jeśli kwerenda wymaga pośredniego magazynu tymczasowego, który przekracza możliwości źródła danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-226">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="9f884-227">W takim przypadku można zmniejszyć złożoność kwerendy źródła danych, jawnie ładując powiązane obiekty.</span><span class="sxs-lookup"><span data-stu-id="9f884-227">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="9f884-228">Jawne ładowanie powiązanych obiektów</span><span class="sxs-lookup"><span data-stu-id="9f884-228">Explicitly loading related objects</span></span>  
 <span data-ttu-id="9f884-229">Można jawnie załadować powiązanych `Load` obiektów, wywołując metodę <xref:System.Data.Objects.DataClasses.EntityCollection%601> na <xref:System.Data.Objects.DataClasses.EntityReference%601>właściwość nawigacji, która zwraca lub .</span><span class="sxs-lookup"><span data-stu-id="9f884-229">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="9f884-230">Jawnie ładowania obiektów wymaga w obie strony `Load` do bazy danych za każdym razem jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="9f884-230">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9f884-231">jeśli wywołasz `Load` podczas zapętlania za pośrednictwem kolekcji `foreach` zwróconych`For Each` obiektów, takich jak podczas korzystania z instrukcji (w języku Visual Basic), dostawca specyficzne dla źródła danych musi obsługiwać wiele aktywnych zestawów wyników na jednym połączeniu.</span><span class="sxs-lookup"><span data-stu-id="9f884-231">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="9f884-232">W przypadku bazy danych programu SQL `MultipleActiveResultSets = true` Server należy określić wartość ciągu połączenia dostawcy.</span><span class="sxs-lookup"><span data-stu-id="9f884-232">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="9f884-233">Można również użyć <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metody, gdy <xref:System.Data.Objects.DataClasses.EntityCollection%601> <xref:System.Data.Objects.DataClasses.EntityReference%601> nie ma lub właściwości na jednostki.</span><span class="sxs-lookup"><span data-stu-id="9f884-233">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="9f884-234">Jest to przydatne, gdy używasz jednostek POCO.</span><span class="sxs-lookup"><span data-stu-id="9f884-234">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="9f884-235">Chociaż jawne ładowanie powiązanych obiektów zmniejszy liczbę sprzężeń `Load` i zmniejszy ilość nadmiarowych danych, wymaga powtarzających się połączeń z bazą danych, które mogą stać się kosztowne podczas jawnego ładowania dużej liczby obiektów.</span><span class="sxs-lookup"><span data-stu-id="9f884-235">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="9f884-236">Zapisywanie zmian</span><span class="sxs-lookup"><span data-stu-id="9f884-236">Saving Changes</span></span>  
 <span data-ttu-id="9f884-237">Po wywołaniu <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody <xref:System.Data.Objects.ObjectContext>na , oddzielne tworzenie, aktualizowanie lub usuwanie polecenia jest generowany dla każdego dodanego, zaktualizowanego lub usuniętego obiektu w kontekście.</span><span class="sxs-lookup"><span data-stu-id="9f884-237">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="9f884-238">Polecenia te są wykonywane w źródle danych w pojedynczej transakcji.</span><span class="sxs-lookup"><span data-stu-id="9f884-238">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="9f884-239">Podobnie jak w przypadku zapytań, wydajność operacji tworzenia, aktualizacji i usuwania zależy od złożoności mapowania w modelu koncepcyjnym.</span><span class="sxs-lookup"><span data-stu-id="9f884-239">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="9f884-240">Transakcje rozproszone</span><span class="sxs-lookup"><span data-stu-id="9f884-240">Distributed Transactions</span></span>  
 <span data-ttu-id="9f884-241">Operacje w jawnej transakcji, które wymagają zasobów, które są zarządzane przez koordynatora transakcji rozproszonych (DTC) będzie znacznie droższe niż podobnej operacji, która nie wymaga usługi DTC.</span><span class="sxs-lookup"><span data-stu-id="9f884-241">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="9f884-242">Awans do UOUE nastąpi w następujących sytuacjach:</span><span class="sxs-lookup"><span data-stu-id="9f884-242">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="9f884-243">Jawna transakcja z operacją względem bazy danych programu SQL Server 2000 lub innego źródła danych, które zawsze promują jawne transakcje do usługi DTC.</span><span class="sxs-lookup"><span data-stu-id="9f884-243">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="9f884-244">Jawna transakcja z operacją przeciwko programowi SQL Server 2005, gdy połączenie jest zarządzane przez platformę Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="9f884-244">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="9f884-245">Dzieje się tak, ponieważ SQL Server 2005 promuje do usługi DTC, gdy połączenie jest zamknięte i ponownie otwarte w ramach jednej transakcji, co jest domyślnym zachowaniem entity framework.</span><span class="sxs-lookup"><span data-stu-id="9f884-245">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="9f884-246">Ta promocja usługi DTC nie występuje podczas korzystania z programu SQL Server 2008.</span><span class="sxs-lookup"><span data-stu-id="9f884-246">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="9f884-247">Aby uniknąć tej promocji podczas korzystania z programu SQL Server 2005, należy jawnie otworzyć i zamknąć połączenie w ramach transakcji.</span><span class="sxs-lookup"><span data-stu-id="9f884-247">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="9f884-248">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-248">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="9f884-249">Jawna transakcja jest używana, gdy jedna <xref:System.Transactions> lub więcej operacji są wykonywane wewnątrz transakcji.</span><span class="sxs-lookup"><span data-stu-id="9f884-249">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="9f884-250">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-250">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="9f884-251">Strategie poprawy wydajności</span><span class="sxs-lookup"><span data-stu-id="9f884-251">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="9f884-252">Można poprawić ogólną wydajność zapytań w entity framework przy użyciu następujących strategii.</span><span class="sxs-lookup"><span data-stu-id="9f884-252">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="9f884-253">Wstępne generowanie widoków</span><span class="sxs-lookup"><span data-stu-id="9f884-253">Pre-generate views</span></span>  
 <span data-ttu-id="9f884-254">Generowanie widoków na podstawie modelu jednostki jest kosztem znacznym przy pierwszym wykonaniu kwerendy przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="9f884-254">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="9f884-255">Narzędzie EdmGen.exe służy do wstępnego generowania widoków jako pliku kodu języka Visual Basic lub C#, który można dodać do projektu podczas projektowania.</span><span class="sxs-lookup"><span data-stu-id="9f884-255">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="9f884-256">Można również użyć zestawu narzędzi do przekształcania szablonów tekstu do generowania wstępnie skompilowanych widoków.</span><span class="sxs-lookup"><span data-stu-id="9f884-256">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="9f884-257">Wstępnie wygenerowane widoki są sprawdzane w czasie wykonywania, aby upewnić się, że są one zgodne z bieżącą wersją określonego modelu jednostki.</span><span class="sxs-lookup"><span data-stu-id="9f884-257">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="9f884-258">Aby uzyskać więcej informacji, zobacz [Jak: Wstępnie generować widoki, aby poprawić wydajność kwerendy](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-258">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="9f884-259">Podczas pracy z bardzo dużymi modelami stosuje się następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="9f884-259">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="9f884-260">Format metadanych platformy .NET ogranicza liczbę znaków ciągu użytkownika w danym pliku binarnym do 16 777 215 (0xFFFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="9f884-260">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="9f884-261">Jeśli generujesz widoki dla bardzo dużego modelu, a plik widoku osiągnie ten limit rozmiaru, otrzymasz "Nie pozostało miejsce logiczne, aby utworzyć więcej ciągów użytkowników".</span><span class="sxs-lookup"><span data-stu-id="9f884-261">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="9f884-262">skompilować błąd.</span><span class="sxs-lookup"><span data-stu-id="9f884-262">compile error.</span></span> <span data-ttu-id="9f884-263">To ograniczenie rozmiaru dotyczy wszystkich zarządzanych plików binarnych.</span><span class="sxs-lookup"><span data-stu-id="9f884-263">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="9f884-264">Aby uzyskać więcej informacji, zobacz [blog,](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) który pokazuje, jak uniknąć błędu podczas pracy z dużymi i złożonymi modelami.</span><span class="sxs-lookup"><span data-stu-id="9f884-264">For more information see the [blog](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="9f884-265">Rozważ użycie opcji scalania NoTracking dla kwerend</span><span class="sxs-lookup"><span data-stu-id="9f884-265">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="9f884-266">Istnieje koszt wymagany do śledzenia zwróconych obiektów w kontekście obiektu.</span><span class="sxs-lookup"><span data-stu-id="9f884-266">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="9f884-267">Wykrywanie zmian w obiektach i zapewnienie, że wiele żądań dla tej samej <xref:System.Data.Objects.ObjectContext> jednostki logicznej zwraca to samo wystąpienie obiektu, wymaga dołączania obiektów do wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9f884-267">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="9f884-268">Jeśli nie planujesz wprowadzania aktualizacji lub usuwania obiektów i nie <xref:System.Data.Objects.MergeOption.NoTracking> wymagasz zarządzania tożsamościami, należy rozważyć użycie opcji scalania podczas wykonywania kwerend.</span><span class="sxs-lookup"><span data-stu-id="9f884-268">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="9f884-269">Zwracanie poprawnej ilości danych</span><span class="sxs-lookup"><span data-stu-id="9f884-269">Return the correct amount of data</span></span>  
 <span data-ttu-id="9f884-270">W niektórych scenariuszach określanie ścieżki <xref:System.Data.Objects.ObjectQuery%601.Include%2A> kwerendy przy użyciu metody jest znacznie szybsze, ponieważ wymaga mniej rund do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-270">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="9f884-271">Jednak w innych scenariuszach dodatkowe wycieczki w obie strony do bazy danych w celu załadowania powiązanych obiektów może być szybsze, ponieważ prostsze zapytania z mniejszą liczbą sprzężeń spowodować mniejszą nadmiarowość danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-271">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="9f884-272">Z tego powodu zaleca się przetestowanie wydajności różnych sposobów pobierania powiązanych obiektów.</span><span class="sxs-lookup"><span data-stu-id="9f884-272">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="9f884-273">Aby uzyskać więcej informacji, zobacz [Ładowanie powiązanych obiektów](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-273">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="9f884-274">Aby uniknąć zwracania zbyt dużej ilości danych w jednej kwerendzie, należy wziąć pod uwagę stronicowanie wyników kwerendy do grup łatwiej zarządzaniu.</span><span class="sxs-lookup"><span data-stu-id="9f884-274">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="9f884-275">Aby uzyskać więcej informacji, zobacz [Jak: Wyniki kwerendy na stronie](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))—</span><span class="sxs-lookup"><span data-stu-id="9f884-275">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="9f884-276">Ograniczanie zakresu obiektuContext</span><span class="sxs-lookup"><span data-stu-id="9f884-276">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="9f884-277">W większości przypadków należy <xref:System.Data.Objects.ObjectContext> utworzyć wystąpienie w instrukcji `using` (w`Using…End Using` języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9f884-277">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="9f884-278">Może to zwiększyć wydajność, zapewniając, że zasoby skojarzone z kontekstem obiektu są usuwane automatycznie, gdy kod kończy blok instrukcji.</span><span class="sxs-lookup"><span data-stu-id="9f884-278">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="9f884-279">Jednak gdy formanty są powiązane z obiektami zarządzanymi przez kontekst obiektu, <xref:System.Data.Objects.ObjectContext> wystąpienie powinno być obsługiwane tak długo, jak powiązanie jest potrzebne i usuwane ręcznie.</span><span class="sxs-lookup"><span data-stu-id="9f884-279">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="9f884-280">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-280">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="9f884-281">Rozważ ręczne otwarcie połączenia z bazą danych</span><span class="sxs-lookup"><span data-stu-id="9f884-281">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="9f884-282">Gdy aplikacja wykonuje serię zapytań o obiekt <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> lub często wywołuje do utrwalania operacji tworzenia, aktualizacji i usuwania do źródła danych, Entity Framework musi stale otwierać i zamykać połączenie ze źródłem danych.</span><span class="sxs-lookup"><span data-stu-id="9f884-282">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="9f884-283">W takich sytuacjach należy rozważyć ręczne otwarcie połączenia na początku tych operacji i zamknięcie lub usunięcie połączenia po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="9f884-283">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="9f884-284">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="9f884-284">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="9f884-285">Dane wydajności</span><span class="sxs-lookup"><span data-stu-id="9f884-285">Performance Data</span></span>  
 <span data-ttu-id="9f884-286">Niektóre dane dotyczące wydajności dla entity framework jest publikowany w następujących wpisach na [ADO.NET blogu zespołu:](https://docs.microsoft.com/archive/blogs/adonet/)</span><span class="sxs-lookup"><span data-stu-id="9f884-286">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](https://docs.microsoft.com/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="9f884-287">Badanie wydajności ADO.NET entity framework - część 1</span><span class="sxs-lookup"><span data-stu-id="9f884-287">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="9f884-288">Badanie wydajności ADO.NET entity framework – część 2</span><span class="sxs-lookup"><span data-stu-id="9f884-288">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="9f884-289">Porównanie wydajności ADO.NET entity framework</span><span class="sxs-lookup"><span data-stu-id="9f884-289">ADO.NET Entity Framework Performance Comparison</span></span>](https://docs.microsoft.com/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="9f884-290">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="9f884-290">See also</span></span>

- [<span data-ttu-id="9f884-291">Projektowanie i zagadnienia dotyczące wdrażania</span><span class="sxs-lookup"><span data-stu-id="9f884-291">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
