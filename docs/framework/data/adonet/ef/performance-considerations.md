---
title: Zagadnienia dotyczące wydajności (Entity Framework)
description: Dowiedz się więcej o charakterystyce wydajności ADO.NET Entity Framework i zagadnieniach, aby pomóc w ulepszaniu wydajności Entity Framework aplikacji.
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 2bdf088309dd178c1eef4cfb0b7e093b1f6be606
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/15/2020
ms.locfileid: "90557466"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="b6c86-103">Zagadnienia dotyczące wydajności (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="b6c86-103">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="b6c86-104">W tym temacie opisano charakterystyki wydajności ADO.NET Entity Framework i przedstawiono kilka kwestii, które pomogą ulepszyć wydajność aplikacji Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="b6c86-104">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="b6c86-105">Etapy wykonywania zapytania</span><span class="sxs-lookup"><span data-stu-id="b6c86-105">Stages of Query Execution</span></span>  
 <span data-ttu-id="b6c86-106">Aby lepiej zrozumieć wydajność zapytań w Entity Framework, warto zrozumieć operacje wykonywane, gdy zapytanie jest wykonywane względem modelu koncepcyjnego i zwraca dane jako obiekty.</span><span class="sxs-lookup"><span data-stu-id="b6c86-106">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="b6c86-107">W poniższej tabeli opisano tę serię operacji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-107">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="b6c86-108">Operacja</span><span class="sxs-lookup"><span data-stu-id="b6c86-108">Operation</span></span>|<span data-ttu-id="b6c86-109">Koszt względny</span><span class="sxs-lookup"><span data-stu-id="b6c86-109">Relative Cost</span></span>|<span data-ttu-id="b6c86-110">Częstotliwość</span><span class="sxs-lookup"><span data-stu-id="b6c86-110">Frequency</span></span>|<span data-ttu-id="b6c86-111">Komentarze</span><span class="sxs-lookup"><span data-stu-id="b6c86-111">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="b6c86-112">Ładowanie metadanych</span><span class="sxs-lookup"><span data-stu-id="b6c86-112">Loading metadata</span></span>|<span data-ttu-id="b6c86-113">Umiarkowane</span><span class="sxs-lookup"><span data-stu-id="b6c86-113">Moderate</span></span>|<span data-ttu-id="b6c86-114">Jeden raz w każdej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-114">Once in each application domain.</span></span>|<span data-ttu-id="b6c86-115">Metadane modelu i mapowania używane przez Entity Framework są ładowane do <xref:System.Data.Metadata.Edm.MetadataWorkspace> .</span><span class="sxs-lookup"><span data-stu-id="b6c86-115">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="b6c86-116">Te metadane są buforowane globalnie i są dostępne dla innych wystąpień <xref:System.Data.Objects.ObjectContext> w tej samej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-116">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="b6c86-117">Otwieranie połączenia z bazą danych</span><span class="sxs-lookup"><span data-stu-id="b6c86-117">Opening the database connection</span></span>|<span data-ttu-id="b6c86-118">Umiarkowane<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-118">Moderate<sup>1</sup></span></span>|<span data-ttu-id="b6c86-119">Zgodnie z wymaganiami.</span><span class="sxs-lookup"><span data-stu-id="b6c86-119">As needed.</span></span>|<span data-ttu-id="b6c86-120">Ponieważ otwarte połączenie z bazą danych zużywa cenny zasób, Entity Framework otwiera i zamyka połączenie z bazą danych tylko w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="b6c86-120">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="b6c86-121">Możesz również jawnie otworzyć połączenie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-121">You can also explicitly open the connection.</span></span> <span data-ttu-id="b6c86-122">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-122">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="b6c86-123">Generowanie widoków</span><span class="sxs-lookup"><span data-stu-id="b6c86-123">Generating views</span></span>|<span data-ttu-id="b6c86-124">Wysoki</span><span class="sxs-lookup"><span data-stu-id="b6c86-124">High</span></span>|<span data-ttu-id="b6c86-125">Jeden raz w każdej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-125">Once in each application domain.</span></span> <span data-ttu-id="b6c86-126">(Można wstępnie wygenerować).</span><span class="sxs-lookup"><span data-stu-id="b6c86-126">(Can be pre-generated.)</span></span>|<span data-ttu-id="b6c86-127">Zanim Entity Framework będzie mogła wykonać zapytanie względem modelu koncepcyjnego lub zapisać zmiany w źródle danych, musi wygenerować zestaw lokalnych widoków zapytań, aby uzyskać dostęp do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-127">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="b6c86-128">Ze względu na wysoki koszt generowania tych widoków można wstępnie wygenerować widoki i dodać je do projektu w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="b6c86-128">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="b6c86-129">Aby uzyskać więcej informacji, zobacz [How to: pregenerate viewss w celu zwiększenia wydajności zapytań](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-129">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="b6c86-130">Przygotowywanie zapytania</span><span class="sxs-lookup"><span data-stu-id="b6c86-130">Preparing the query</span></span>|<span data-ttu-id="b6c86-131">Umiarkowane<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-131">Moderate<sup>2</sup></span></span>|<span data-ttu-id="b6c86-132">Jednokrotnie dla każdego unikatowego zapytania.</span><span class="sxs-lookup"><span data-stu-id="b6c86-132">Once for each unique query.</span></span>|<span data-ttu-id="b6c86-133">Obejmuje koszty tworzenia polecenia zapytania, generowania drzewa poleceń na podstawie modelu i metadanych mapowania oraz definiowania kształtu zwracanych danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-133">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="b6c86-134">Ponieważ teraz zarówno Entity SQL polecenia zapytania i zapytania LINQ są buforowane, późniejsze wykonywanie tego samego zapytania trwa krócej.</span><span class="sxs-lookup"><span data-stu-id="b6c86-134">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="b6c86-135">Można nadal używać skompilowanych zapytań LINQ, aby ograniczyć ten koszt do późniejszych wykonań, a skompilowane zapytania mogą być bardziej wydajne niż zapytania LINQ, które są automatycznie buforowane.</span><span class="sxs-lookup"><span data-stu-id="b6c86-135">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="b6c86-136">Aby uzyskać więcej informacji, zobacz [skompilowane zapytania (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="b6c86-136">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="b6c86-137">Aby uzyskać ogólne informacje na temat wykonywania zapytań LINQ, zobacz [LINQ to Entities](./language-reference/linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="b6c86-137">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="b6c86-138">**Uwaga:**  LINQ to Entities zapytania, które stosują `Enumerable.Contains` operator do kolekcji w pamięci, nie są automatycznie buforowane.</span><span class="sxs-lookup"><span data-stu-id="b6c86-138">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="b6c86-139">Parametryzacja również kolekcje w pamięci w skompilowanych zapytaniach LINQ są niedozwolone.</span><span class="sxs-lookup"><span data-stu-id="b6c86-139">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="b6c86-140">Wykonywanie zapytania</span><span class="sxs-lookup"><span data-stu-id="b6c86-140">Executing the query</span></span>|<span data-ttu-id="b6c86-141">Niski<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-141">Low<sup>2</sup></span></span>|<span data-ttu-id="b6c86-142">Jeden raz dla każdego zapytania.</span><span class="sxs-lookup"><span data-stu-id="b6c86-142">Once for each query.</span></span>|<span data-ttu-id="b6c86-143">Koszt wykonywania polecenia względem źródła danych przy użyciu dostawcy danych ADO.NET.</span><span class="sxs-lookup"><span data-stu-id="b6c86-143">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="b6c86-144">Ze względu na to, że większość źródeł danych buforuje plany zapytań, późniejsze wykonania tego samego zapytania mogą trwać nawet krócej.</span><span class="sxs-lookup"><span data-stu-id="b6c86-144">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="b6c86-145">Ładowanie i sprawdzanie poprawności typów</span><span class="sxs-lookup"><span data-stu-id="b6c86-145">Loading and validating types</span></span>|<span data-ttu-id="b6c86-146">Niski<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-146">Low<sup>3</sup></span></span>|<span data-ttu-id="b6c86-147">Jeden raz dla każdego <xref:System.Data.Objects.ObjectContext> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="b6c86-147">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="b6c86-148">Typy są ładowane i sprawdzane pod kątem typów, które definiuje model koncepcyjny.</span><span class="sxs-lookup"><span data-stu-id="b6c86-148">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="b6c86-149">Śledzenie</span><span class="sxs-lookup"><span data-stu-id="b6c86-149">Tracking</span></span>|<span data-ttu-id="b6c86-150">Niski<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-150">Low<sup>3</sup></span></span>|<span data-ttu-id="b6c86-151">Jeden raz dla każdego obiektu zwracanego przez zapytanie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-151">Once for each object that a query returns.</span></span> <span data-ttu-id="b6c86-152"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-152"><sup>4</sup></span></span>|<span data-ttu-id="b6c86-153">Jeśli zapytanie używa <xref:System.Data.Objects.MergeOption.NoTracking> opcji scalania, ten etap nie ma wpływu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="b6c86-153">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="b6c86-154">Jeśli zapytanie używa <xref:System.Data.Objects.MergeOption.AppendOnly> <xref:System.Data.Objects.MergeOption.PreserveChanges> opcji, lub <xref:System.Data.Objects.MergeOption.OverwriteChanges> scalania, wyniki zapytania są śledzone w <xref:System.Data.Objects.ObjectStateManager> .</span><span class="sxs-lookup"><span data-stu-id="b6c86-154">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="b6c86-155"><xref:System.Data.EntityKey>Generowany jest dla każdego śledzonego obiektu zwracanego przez zapytanie i służy do tworzenia w obiekcie <xref:System.Data.Objects.ObjectStateEntry> <xref:System.Data.Objects.ObjectStateManager> .</span><span class="sxs-lookup"><span data-stu-id="b6c86-155">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="b6c86-156">Jeśli istniejący element <xref:System.Data.Objects.ObjectStateEntry> można znaleźć dla <xref:System.Data.EntityKey> , zwracany jest istniejący obiekt.</span><span class="sxs-lookup"><span data-stu-id="b6c86-156">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="b6c86-157">Jeśli jest <xref:System.Data.Objects.MergeOption.PreserveChanges> <xref:System.Data.Objects.MergeOption.OverwriteChanges> używana opcja lub, obiekt jest aktualizowany przed zwróceniem.</span><span class="sxs-lookup"><span data-stu-id="b6c86-157">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="b6c86-158">Aby uzyskać więcej informacji, zobacz [rozpoznawanie tożsamości, zarządzanie stanami i Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-158">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="b6c86-159">Materializacji obiekty</span><span class="sxs-lookup"><span data-stu-id="b6c86-159">Materializing the objects</span></span>|<span data-ttu-id="b6c86-160">Umiarkowane<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-160">Moderate<sup>3</sup></span></span>|<span data-ttu-id="b6c86-161">Jeden raz dla każdego obiektu zwracanego przez zapytanie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-161">Once for each object that a query returns.</span></span> <span data-ttu-id="b6c86-162"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="b6c86-162"><sup>4</sup></span></span>|<span data-ttu-id="b6c86-163">Proces odczytywania zwracanego <xref:System.Data.Common.DbDataReader> obiektu i tworzenia obiektów oraz ustawiania wartości właściwości, które są oparte na wartościach każdego wystąpienia <xref:System.Data.Common.DbDataRecord> klasy.</span><span class="sxs-lookup"><span data-stu-id="b6c86-163">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="b6c86-164">Jeśli obiekt już istnieje w, <xref:System.Data.Objects.ObjectContext> a zapytanie używa <xref:System.Data.Objects.MergeOption.AppendOnly> <xref:System.Data.Objects.MergeOption.PreserveChanges> opcji lub scalania, ten etap nie ma wpływu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="b6c86-164">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="b6c86-165">Aby uzyskać więcej informacji, zobacz [rozpoznawanie tożsamości, zarządzanie stanami i Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-165">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="b6c86-166"><sup>1</sup> gdy dostawca źródła danych implementuje pulę połączeń, koszt otwarcia połączenia jest dystrybuowany w całej puli.</span><span class="sxs-lookup"><span data-stu-id="b6c86-166"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="b6c86-167">Dostawca platformy .NET dla SQL Server obsługuje pule połączeń.</span><span class="sxs-lookup"><span data-stu-id="b6c86-167">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="b6c86-168"><sup>2</sup> koszty zwiększają się z większą złożonością zapytań.</span><span class="sxs-lookup"><span data-stu-id="b6c86-168"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="b6c86-169"><sup>3</sup> łączny koszt zwiększa się proporcjonalnie do liczby obiektów zwracanych przez zapytanie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-169"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="b6c86-170"><sup>4</sup> ten koszt nie jest wymagany w przypadku zapytań EntityClient, ponieważ zapytania EntityClient zwracają <xref:System.Data.EntityClient.EntityDataReader> obiekty zamiast obiektów.</span><span class="sxs-lookup"><span data-stu-id="b6c86-170"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="b6c86-171">Aby uzyskać więcej informacji, zobacz [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span><span class="sxs-lookup"><span data-stu-id="b6c86-171">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="b6c86-172">Dodatkowe zagadnienia</span><span class="sxs-lookup"><span data-stu-id="b6c86-172">Additional Considerations</span></span>  
 <span data-ttu-id="b6c86-173">Poniżej przedstawiono inne zagadnienia, które mogą mieć wpływ na wydajność aplikacji Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="b6c86-173">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="b6c86-174">Wykonywanie zapytania</span><span class="sxs-lookup"><span data-stu-id="b6c86-174">Query Execution</span></span>  
 <span data-ttu-id="b6c86-175">Ponieważ zapytania mogą być intensywnie obciążające zasoby, warto zastanowić się, w jakim miejscu kodu i na komputerze, na którym jest wykonywane zapytanie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-175">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="b6c86-176">Odroczone względem natychmiastowego wykonania</span><span class="sxs-lookup"><span data-stu-id="b6c86-176">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="b6c86-177">Po utworzeniu zapytania programu <xref:System.Data.Objects.ObjectQuery%601> lub LINQ zapytanie może nie zostać wykonane od razu.</span><span class="sxs-lookup"><span data-stu-id="b6c86-177">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="b6c86-178">Wykonywanie zapytania jest odroczone do momentu, gdy nie będą one konieczne, na przykład podczas `foreach` wyliczania (C#) lub `For Each` (Visual Basic) lub po przypisaniu do wypełnienia <xref:System.Collections.Generic.List%601> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-178">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="b6c86-179">Wykonywanie zapytania rozpoczyna się natychmiast po wywołaniu <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> metody na <xref:System.Data.Objects.ObjectQuery%601> lub WYWOŁANIU metody LINQ, która zwraca zapytanie pojedyncze, takie jak <xref:System.Linq.Enumerable.First%2A> lub <xref:System.Linq.Enumerable.Any%2A> .</span><span class="sxs-lookup"><span data-stu-id="b6c86-179">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="b6c86-180">Aby uzyskać więcej informacji, zobacz [zapytania dotyczące obiektów](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) i [wykonywanie zapytań (LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="b6c86-180">For more information, see [Object Queries](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="b6c86-181">Wykonywanie zapytań LINQ po stronie klienta</span><span class="sxs-lookup"><span data-stu-id="b6c86-181">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="b6c86-182">Mimo że wykonywanie zapytania LINQ odbywa się na komputerze hostującym źródło danych, niektóre części zapytania LINQ mogą być oceniane na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="b6c86-182">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="b6c86-183">Aby uzyskać więcej informacji, zobacz sekcję wykonywanie w sklepie [wykonywania zapytania (LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="b6c86-183">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="b6c86-184">Złożoność zapytań i mapowania</span><span class="sxs-lookup"><span data-stu-id="b6c86-184">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="b6c86-185">Złożoność poszczególnych zapytań i mapowania w modelu jednostki będą mieć znaczny wpływ na wydajność zapytań.</span><span class="sxs-lookup"><span data-stu-id="b6c86-185">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="b6c86-186">Złożoność mapowania</span><span class="sxs-lookup"><span data-stu-id="b6c86-186">Mapping complexity</span></span>  
 <span data-ttu-id="b6c86-187">Modele, które są bardziej złożone niż proste mapowanie jeden do jednego między jednostkami w modelu koncepcyjnym i tabelach w modelu magazynu, generują bardziej złożone polecenia niż modele, które mają mapowanie jeden do jednego.</span><span class="sxs-lookup"><span data-stu-id="b6c86-187">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="b6c86-188">Złożoność zapytania</span><span class="sxs-lookup"><span data-stu-id="b6c86-188">Query complexity</span></span>  
 <span data-ttu-id="b6c86-189">Zapytania, które wymagają dużej liczby sprzężeń w poleceniach, które są wykonywane względem źródła danych lub zwracają znaczną ilość danych, mogą mieć wpływ na wydajność w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="b6c86-189">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="b6c86-190">Zapytania względem modelu koncepcyjnego, który wydaje się proste, mogą spowodować wykonanie bardziej złożonych zapytań względem źródła danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-190">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="b6c86-191">Taka sytuacja może wystąpić, ponieważ Entity Framework tłumaczy zapytanie względem modelu koncepcyjnego na równoważne zapytanie względem źródła danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-191">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="b6c86-192">Gdy pojedynczy obiekt ustawiony w modelu koncepcyjnym mapuje się do więcej niż jednej tabeli w źródle danych lub jeśli relacja między jednostkami jest zamapowana na tabelę sprzężeń, polecenie zapytania wykonane względem zapytania źródła danych może wymagać co najmniej jednego sprzężenia.</span><span class="sxs-lookup"><span data-stu-id="b6c86-192">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="b6c86-193">Użyj <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody <xref:System.Data.Objects.ObjectQuery%601> lub, <xref:System.Data.EntityClient.EntityCommand> Aby wyświetlić polecenia, które są wykonywane względem źródła danych dla danego zapytania.</span><span class="sxs-lookup"><span data-stu-id="b6c86-193">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="b6c86-194">Aby uzyskać więcej informacji, zobacz [How to: Viewing Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-194">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="b6c86-195">Zagnieżdżone zapytania Entity SQL mogą tworzyć sprzężenia na serwerze i zwracać dużą liczbę wierszy.</span><span class="sxs-lookup"><span data-stu-id="b6c86-195">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="b6c86-196">Poniżej znajduje się przykład zagnieżdżonego zapytania w klauzuli projekcji:</span><span class="sxs-lookup"><span data-stu-id="b6c86-196">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="b6c86-197">Ponadto takie zapytania powodują, że potok zapytania generuje pojedyncze zapytanie z duplikowaniem obiektów w zagnieżdżonych zapytaniach.</span><span class="sxs-lookup"><span data-stu-id="b6c86-197">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="b6c86-198">Z tego powodu jedna kolumna może być zduplikowana wiele razy.</span><span class="sxs-lookup"><span data-stu-id="b6c86-198">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="b6c86-199">W przypadku niektórych baz danych, w tym SQL Server, może to spowodować duże powiększenie tabeli TempDB, co może zmniejszyć wydajność serwera.</span><span class="sxs-lookup"><span data-stu-id="b6c86-199">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="b6c86-200">Należy zachować ostrożność podczas wykonywania zagnieżdżonych zapytań.</span><span class="sxs-lookup"><span data-stu-id="b6c86-200">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="b6c86-201">Wszystkie zapytania, które zwracają duże ilości danych, mogą spowodować spadek wydajności, jeśli klient wykonuje operacje, które zużywają zasoby w sposób proporcjonalny do rozmiaru zestawu wyników.</span><span class="sxs-lookup"><span data-stu-id="b6c86-201">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="b6c86-202">W takich przypadkach należy rozważyć ograniczenie ilości danych zwracanych przez zapytanie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-202">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="b6c86-203">Aby uzyskać więcej informacji, zobacz [jak: Strona za poorednictwem wyników zapytania](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-203">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="b6c86-204">Wszystkie polecenia generowane automatycznie przez Entity Framework mogą być bardziej skomplikowane niż podobne polecenia, które są jawnie zapisywane przez dewelopera bazy danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-204">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="b6c86-205">Jeśli potrzebujesz jawnej kontroli nad poleceniami wykonywanymi względem źródła danych, rozważ zdefiniowanie mapowania do funkcji zwracającej tabelę lub procedury składowanej.</span><span class="sxs-lookup"><span data-stu-id="b6c86-205">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="b6c86-206">Relacje</span><span class="sxs-lookup"><span data-stu-id="b6c86-206">Relationships</span></span>  
 <span data-ttu-id="b6c86-207">Aby zapewnić optymalną wydajność zapytań, należy zdefiniować relacje między jednostkami zarówno jako skojarzenia w modelu jednostki, jak i jako relacje logiczne w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-207">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="b6c86-208">Ścieżki zapytań</span><span class="sxs-lookup"><span data-stu-id="b6c86-208">Query Paths</span></span>  
 <span data-ttu-id="b6c86-209">Domyślnie podczas wykonywania <xref:System.Data.Objects.ObjectQuery%601> obiekty powiązane nie są zwracane (chociaż obiekty reprezentujące same relacje są).</span><span class="sxs-lookup"><span data-stu-id="b6c86-209">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="b6c86-210">Obiekty powiązane można ładować na jeden z trzech sposobów:</span><span class="sxs-lookup"><span data-stu-id="b6c86-210">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="b6c86-211">Ustaw ścieżkę zapytania przed <xref:System.Data.Objects.ObjectQuery%601> wykonaniem.</span><span class="sxs-lookup"><span data-stu-id="b6c86-211">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="b6c86-212">Wywołaj `Load` metodę dla właściwości nawigacji, która uwidacznia obiekt.</span><span class="sxs-lookup"><span data-stu-id="b6c86-212">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="b6c86-213">Ustaw <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> opcję na <xref:System.Data.Objects.ObjectContext> `true` .</span><span class="sxs-lookup"><span data-stu-id="b6c86-213">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="b6c86-214">Należy zauważyć, że jest to wykonywane automatycznie podczas generowania kodu warstwy obiektu za pomocą [projektanta Entity Data Model](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-214">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="b6c86-215">Aby uzyskać więcej informacji, zobacz [Omówienie wygenerowanego kodu](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-215">For more information see [Generated Code Overview](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="b6c86-216">Jeśli zdecydujesz się na użycie opcji, pamiętaj, że istnieje kompromis między liczbą żądań względem bazy danych i ilością danych zwracanych w jednym zapytaniu.</span><span class="sxs-lookup"><span data-stu-id="b6c86-216">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="b6c86-217">Aby uzyskać więcej informacji, zobacz [ładowanie powiązanych obiektów](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-217">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="b6c86-218">Używanie ścieżek zapytania</span><span class="sxs-lookup"><span data-stu-id="b6c86-218">Using query paths</span></span>  
 <span data-ttu-id="b6c86-219">Ścieżki zapytań definiują wykres obiektów zwracanych przez zapytanie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-219">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="b6c86-220">Podczas definiowania ścieżki zapytania tylko jedno żądanie dotyczące bazy danych jest wymagane do zwrócenia wszystkich obiektów, które definiuje ścieżka.</span><span class="sxs-lookup"><span data-stu-id="b6c86-220">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="b6c86-221">Użycie ścieżek zapytania może spowodować, że złożone polecenia są wykonywane względem źródła danych z pozornie prostych zapytań obiektów.</span><span class="sxs-lookup"><span data-stu-id="b6c86-221">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="b6c86-222">Dzieje się tak, ponieważ co najmniej jedno sprzężenie jest wymagane do zwrócenia obiektów pokrewnych w pojedynczym zapytaniu.</span><span class="sxs-lookup"><span data-stu-id="b6c86-222">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="b6c86-223">Ta złożoność jest większa w przypadku zapytań względem złożonego modelu Entity, takiego jak jednostka z dziedziczeniem lub ścieżka, która zawiera relacje wiele-do-wielu.</span><span class="sxs-lookup"><span data-stu-id="b6c86-223">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b6c86-224">Użyj <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody, aby zobaczyć polecenie, które zostanie wygenerowane przez <xref:System.Data.Objects.ObjectQuery%601> .</span><span class="sxs-lookup"><span data-stu-id="b6c86-224">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="b6c86-225">Aby uzyskać więcej informacji, zobacz [How to: Viewing Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-225">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="b6c86-226">Gdy ścieżka zapytania zawiera zbyt wiele powiązanych obiektów lub obiekty zawierają zbyt dużo danych wierszy, źródło danych może nie być w stanie zakończyć zapytania.</span><span class="sxs-lookup"><span data-stu-id="b6c86-226">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="b6c86-227">Dzieje się tak, jeśli zapytanie wymaga pośredniego tymczasowego magazynu, który przekracza możliwości źródła danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-227">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="b6c86-228">W takim przypadku można zmniejszyć złożoność zapytania źródła danych, jawnie ładując powiązane obiekty.</span><span class="sxs-lookup"><span data-stu-id="b6c86-228">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="b6c86-229">Jawne ładowanie powiązanych obiektów</span><span class="sxs-lookup"><span data-stu-id="b6c86-229">Explicitly loading related objects</span></span>  
 <span data-ttu-id="b6c86-230">Można jawnie załadować powiązane obiekty przez wywołanie `Load` metody dla właściwości nawigacji, która zwraca <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> .</span><span class="sxs-lookup"><span data-stu-id="b6c86-230">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="b6c86-231">Jawne ładowanie obiektów wymaga przeprowadzenia rundy do bazy danych za każdym razem, gdy `Load` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="b6c86-231">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b6c86-232">w przypadku wywołania `Load` podczas zapętlenia przez kolekcję zwróconych obiektów, takich jak użycie `foreach` instrukcji ( `For Each` w Visual Basic), dostawca specyficzny dla źródła danych musi obsługiwać wiele aktywnych zestawów wyników w ramach jednego połączenia.</span><span class="sxs-lookup"><span data-stu-id="b6c86-232">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="b6c86-233">W przypadku bazy danych SQL Server należy określić wartość `MultipleActiveResultSets = true` w parametrach połączenia dostawcy.</span><span class="sxs-lookup"><span data-stu-id="b6c86-233">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="b6c86-234">Możesz również użyć metody, <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Jeśli nie ma żadnych <xref:System.Data.Objects.DataClasses.EntityCollection%601> <xref:System.Data.Objects.DataClasses.EntityReference%601> właściwości w jednostkach.</span><span class="sxs-lookup"><span data-stu-id="b6c86-234">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="b6c86-235">Jest to przydatne w przypadku korzystania z jednostek POCO.</span><span class="sxs-lookup"><span data-stu-id="b6c86-235">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="b6c86-236">Mimo że jawne ładowanie powiązanych obiektów zmniejsza liczbę sprzężeń i zmniejsza ilość nadmiarowych danych, `Load` wymaga powtarzających się połączeń z bazą danych, co może być kosztowne w przypadku jawnego ładowania dużej liczby obiektów.</span><span class="sxs-lookup"><span data-stu-id="b6c86-236">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="b6c86-237">Zapisywanie zmian</span><span class="sxs-lookup"><span data-stu-id="b6c86-237">Saving Changes</span></span>  
 <span data-ttu-id="b6c86-238">Po wywołaniu <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody na <xref:System.Data.Objects.ObjectContext> , oddzielnym poleceniem Create, Update lub DELETE jest generowane dla każdego dodanego, zaktualizowanego lub usuniętego obiektu w kontekście.</span><span class="sxs-lookup"><span data-stu-id="b6c86-238">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="b6c86-239">Te polecenia są wykonywane na źródle danych w jednej transakcji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-239">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="b6c86-240">Podobnie jak w przypadku zapytań, wydajność operacji tworzenia, aktualizowania i usuwania zależy od złożoności mapowania w modelu koncepcyjnym.</span><span class="sxs-lookup"><span data-stu-id="b6c86-240">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="b6c86-241">Transakcje rozproszone</span><span class="sxs-lookup"><span data-stu-id="b6c86-241">Distributed Transactions</span></span>  
 <span data-ttu-id="b6c86-242">Operacje w jawnej transakcji, które wymagają zasobów zarządzanych przez koordynatora transakcji rozproszonych (DTC), będą znacznie droższe niż podobna operacja, która nie wymaga usługi DTC.</span><span class="sxs-lookup"><span data-stu-id="b6c86-242">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="b6c86-243">Podwyższanie poziomu usługi DTC będzie odbywać się w następujących sytuacjach:</span><span class="sxs-lookup"><span data-stu-id="b6c86-243">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="b6c86-244">Transakcja jawna z operacją w odniesieniu do bazy danych SQL Server 2000 lub innego źródła danych, które zawsze Podnieś poziom jawnych transakcji do usługi DTC.</span><span class="sxs-lookup"><span data-stu-id="b6c86-244">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="b6c86-245">Transakcja jawna z operacją w odniesieniu do SQL Server 2005, gdy połączenie jest zarządzane przez Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="b6c86-245">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="b6c86-246">Dzieje się tak, ponieważ SQL Server 2005 podwyższa do usługi DTC przy każdym zamknięciu i ponownym otwarciu połączenia w ramach jednej transakcji, która jest domyślnym zachowaniem Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="b6c86-246">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="b6c86-247">Ta promocja usługi DTC nie występuje w przypadku korzystania z SQL Server 2008.</span><span class="sxs-lookup"><span data-stu-id="b6c86-247">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="b6c86-248">Aby uniknąć tego podwyższania poziomu w przypadku korzystania z SQL Server 2005, należy jawnie otworzyć i zamknąć połączenie w ramach transakcji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-248">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="b6c86-249">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-249">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="b6c86-250">Transakcja jawna jest używana, gdy co najmniej jedna operacja jest wykonywana wewnątrz <xref:System.Transactions> transakcji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-250">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="b6c86-251">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-251">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="b6c86-252">Strategie zwiększania wydajności</span><span class="sxs-lookup"><span data-stu-id="b6c86-252">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="b6c86-253">Można zwiększyć ogólną wydajność zapytań w Entity Framework, korzystając z poniższych strategii.</span><span class="sxs-lookup"><span data-stu-id="b6c86-253">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="b6c86-254">Wstępnie Generuj widoki</span><span class="sxs-lookup"><span data-stu-id="b6c86-254">Pre-generate views</span></span>  
 <span data-ttu-id="b6c86-255">Generowanie widoków opartych na modelu jednostki jest istotnym kosztem podczas pierwszego wykonywania zapytania przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="b6c86-255">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="b6c86-256">Użyj narzędzia EdmGen.exe, aby wstępnie wygenerować widoki jako plik kodu Visual Basic lub C#, który można dodać do projektu podczas projektowania.</span><span class="sxs-lookup"><span data-stu-id="b6c86-256">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="b6c86-257">Można również użyć zestawu narzędzi do przekształcania szablonów tekstowych do generowania wstępnie skompilowanych widoków.</span><span class="sxs-lookup"><span data-stu-id="b6c86-257">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="b6c86-258">Wstępnie wygenerowane widoki są weryfikowane w czasie wykonywania, aby upewnić się, że są one spójne z bieżącą wersją określonego modelu Entity.</span><span class="sxs-lookup"><span data-stu-id="b6c86-258">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="b6c86-259">Aby uzyskać więcej informacji, zobacz [How to: pregenerate viewss w celu zwiększenia wydajności zapytań](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-259">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="b6c86-260">Podczas pracy z bardzo dużymi modelami stosuje się następujące zagadnienia:</span><span class="sxs-lookup"><span data-stu-id="b6c86-260">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="b6c86-261">Format metadanych .NET ogranicza liczbę znaków ciągu użytkownika w danym pliku binarnym do 16 777 215 (0xFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="b6c86-261">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="b6c86-262">Jeśli tworzysz widoki dla bardzo dużego modelu, a plik widoku osiągnie ten limit rozmiaru, otrzymasz wartość "Brak pustego miejsca logicznego, aby utworzyć więcej ciągów użytkownika".</span><span class="sxs-lookup"><span data-stu-id="b6c86-262">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="b6c86-263">błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-263">compile error.</span></span> <span data-ttu-id="b6c86-264">To ograniczenie rozmiaru dotyczy wszystkich zarządzanych plików binarnych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-264">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="b6c86-265">Aby uzyskać więcej informacji, zobacz [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) pokazujący, jak uniknąć błędu podczas pracy z dużymi i złożonymi modelami.</span><span class="sxs-lookup"><span data-stu-id="b6c86-265">For more information see the [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="b6c86-266">Rozważ użycie opcji scalania NoTracking dla zapytań</span><span class="sxs-lookup"><span data-stu-id="b6c86-266">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="b6c86-267">Istnieje koszt wymagany do śledzenia zwracanych obiektów w kontekście obiektu.</span><span class="sxs-lookup"><span data-stu-id="b6c86-267">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="b6c86-268">Wykrywanie zmian obiektów i zagwarantowanie, że wiele żądań dla tej samej jednostki logicznej zwróci to samo wystąpienie obiektu, wymagane jest dołączenie obiektów do <xref:System.Data.Objects.ObjectContext> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="b6c86-268">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="b6c86-269">Jeśli nie planujesz przeprowadzać aktualizacji ani usunięć dla obiektów i nie wymagają zarządzania tożsamościami, rozważ użycie <xref:System.Data.Objects.MergeOption.NoTracking> opcji scalania podczas wykonywania zapytań.</span><span class="sxs-lookup"><span data-stu-id="b6c86-269">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="b6c86-270">Zwróć poprawną ilość danych</span><span class="sxs-lookup"><span data-stu-id="b6c86-270">Return the correct amount of data</span></span>  
 <span data-ttu-id="b6c86-271">W niektórych scenariuszach Określanie ścieżki zapytania przy użyciu <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metody jest znacznie szybsze, ponieważ wymaga mniejszej liczby rund do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-271">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="b6c86-272">Jednak w innych scenariuszach dodatkowe podróże do bazy danych w celu załadowania powiązanych obiektów mogą być szybsze, ponieważ prostsze zapytania z mniejszą liczbą sprzężeń powodują mniejszą nadmiarowość danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-272">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="b6c86-273">W związku z tym zalecamy przetestowanie wydajności różnych metod pobierania obiektów pokrewnych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-273">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="b6c86-274">Aby uzyskać więcej informacji, zobacz [ładowanie powiązanych obiektów](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-274">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="b6c86-275">Aby uniknąć powrotu zbyt dużej ilości danych w jednym zapytaniu, należy rozważyć stronicowanie wyników zapytania w celu łatwiejszego zarządzania grupami.</span><span class="sxs-lookup"><span data-stu-id="b6c86-275">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="b6c86-276">Aby uzyskać więcej informacji, zobacz [jak: Strona za poorednictwem wyników zapytania](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-276">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="b6c86-277">Ogranicz zakres obiektu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="b6c86-277">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="b6c86-278">W większości przypadków należy utworzyć <xref:System.Data.Objects.ObjectContext> wystąpienie wewnątrz `using` instrukcji ( `Using…End Using` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b6c86-278">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="b6c86-279">Może to zwiększyć wydajność, upewniając się, że zasoby skojarzone z kontekstem obiektu są usuwane automatycznie, gdy kod opuszcza blok instrukcji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-279">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="b6c86-280">Jeśli jednak formanty są powiązane z obiektami zarządzanymi przez kontekst obiektu, <xref:System.Data.Objects.ObjectContext> wystąpienie powinno być utrzymywane o ile jest to konieczne i usunięte ręcznie.</span><span class="sxs-lookup"><span data-stu-id="b6c86-280">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="b6c86-281">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-281">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="b6c86-282">Rozważ ręczne otworzenie połączenia z bazą danych</span><span class="sxs-lookup"><span data-stu-id="b6c86-282">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="b6c86-283">Gdy aplikacja wykonuje serię zapytań obiektów lub często wywołuje <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> do źródła danych operacje tworzenia, aktualizowania i usuwania, Entity Framework musi ciągle otwierać i zamykać połączenie ze źródłem danych.</span><span class="sxs-lookup"><span data-stu-id="b6c86-283">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="b6c86-284">W takich sytuacjach należy rozważyć ręczne otwarcie połączenia na początku tych operacji oraz zamknięcie lub odłączenie połączenia po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="b6c86-284">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="b6c86-285">Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcjami](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="b6c86-285">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="b6c86-286">Dane wydajności</span><span class="sxs-lookup"><span data-stu-id="b6c86-286">Performance Data</span></span>  
 <span data-ttu-id="b6c86-287">Niektóre dane dotyczące wydajności Entity Framework są publikowane w następujących wpisach na [blogu zespołu ADO.NET](/archive/blogs/adonet/):</span><span class="sxs-lookup"><span data-stu-id="b6c86-287">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="b6c86-288">Eksplorowanie wydajności Entity Framework ADO.NET — część 1</span><span class="sxs-lookup"><span data-stu-id="b6c86-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="b6c86-289">Eksplorowanie wydajności Entity Framework ADO.NET — część 2</span><span class="sxs-lookup"><span data-stu-id="b6c86-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="b6c86-290">Porównanie wydajności Entity Framework ADO.NET</span><span class="sxs-lookup"><span data-stu-id="b6c86-290">ADO.NET Entity Framework Performance Comparison</span></span>](/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="b6c86-291">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="b6c86-291">See also</span></span>

- [<span data-ttu-id="b6c86-292">Projektowanie i zagadnienia dotyczące wdrażania</span><span class="sxs-lookup"><span data-stu-id="b6c86-292">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
