---
title: Wypełnianie zestawu danych z elementu DataAdapter
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3fa0ac7d-e266-4954-bfac-3fbe2f913153
ms.openlocfilehash: ecfd2c3a31b42b380c593aef0bbc23775874cc7a
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61878205"
---
# <a name="populating-a-dataset-from-a-dataadapter"></a><span data-ttu-id="c7602-102">Wypełnianie zestawu danych z elementu DataAdapter</span><span class="sxs-lookup"><span data-stu-id="c7602-102">Populating a DataSet from a DataAdapter</span></span>
<span data-ttu-id="c7602-103">[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] <xref:System.Data.DataSet> Jest rezydentnego reprezentację danych, który zapewnia spójne relacyjnych programowania modelu niezależnie od źródła danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-103">The [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]<xref:System.Data.DataSet> is a memory-resident representation of data that provides a consistent relational programming model independent of the data source.</span></span> <span data-ttu-id="c7602-104">`DataSet` Przedstawia kompletny zestaw danych, który zawiera tabele, ograniczenia i relacje między tabelami.</span><span class="sxs-lookup"><span data-stu-id="c7602-104">The `DataSet` represents a complete set of data that includes tables, constraints, and relationships among the tables.</span></span> <span data-ttu-id="c7602-105">Ponieważ `DataSet` jest niezależna od źródła danych `DataSet` mogą obejmować dane lokalne do aplikacji i danych z wielu źródeł danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-105">Because the `DataSet` is independent of the data source, a `DataSet` can include data local to the application, and data from multiple data sources.</span></span> <span data-ttu-id="c7602-106">Interakcja z istniejących źródeł danych jest kontrolowany za pośrednictwem `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="c7602-106">Interaction with existing data sources is controlled through the `DataAdapter`.</span></span>  
  
 <span data-ttu-id="c7602-107">`SelectCommand` Właściwość `DataAdapter` jest `Command` obiekt, który pobiera dane ze źródła danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-107">The `SelectCommand` property of the `DataAdapter` is a `Command` object that retrieves data from the data source.</span></span> <span data-ttu-id="c7602-108">`InsertCommand`, `UpdateCommand`, I `DeleteCommand` właściwości `DataAdapter` są `Command` obiektów zarządzanych aktualizacji względem danych w źródle danych, zgodnie z modyfikacje wprowadzone do danych w `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-108">The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties of the `DataAdapter` are `Command` objects that manage updates to the data in the data source according to modifications made to the data in the `DataSet`.</span></span> <span data-ttu-id="c7602-109">Te właściwości są omówione bardziej szczegółowo w [aktualizowanie źródeł danych za pomocą elementów DataAdapters](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span><span class="sxs-lookup"><span data-stu-id="c7602-109">These properties are covered in more detail in [Updating Data Sources with DataAdapters](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="c7602-110">`Fill` Metody `DataAdapter` używany do wypełnienia `DataSet` z wynikami `SelectCommand` z `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="c7602-110">The `Fill` method of the `DataAdapter` is used to populate a `DataSet` with the results of the `SelectCommand` of the `DataAdapter`.</span></span> <span data-ttu-id="c7602-111">`Fill` przyjmuje jako argumenty `DataSet` wypełniona, a `DataTable` obiektu lub nazwę `DataTable` trzeba napełniać wierszy zwróconych `SelectCommand`.</span><span class="sxs-lookup"><span data-stu-id="c7602-111">`Fill` takes as its arguments a `DataSet` to be populated, and a `DataTable` object, or the name of the `DataTable` to be filled with the rows returned from the `SelectCommand`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c7602-112">Za pomocą `DataAdapter` do pobrania wszystkich tabeli wymaga czasu, szczególnie w przypadku wielu wierszy w tabeli.</span><span class="sxs-lookup"><span data-stu-id="c7602-112">Using the `DataAdapter` to retrieve all of a table takes time, especially if there are many rows in the table.</span></span> <span data-ttu-id="c7602-113">Jest to spowodowane dostęp do bazy danych, lokalizuje i przetwarzania danych, a następnie przesyłania danych do klienta jest czasochłonne.</span><span class="sxs-lookup"><span data-stu-id="c7602-113">This is because accessing the database, locating and processing the data, and then transferring the data to the client is time-consuming.</span></span> <span data-ttu-id="c7602-114">Pobieranie wszystkich tabeli do klienta również blokuje wszystkie wiersze na serwerze.</span><span class="sxs-lookup"><span data-stu-id="c7602-114">Pulling all of the table to the client also locks all of the rows on the server.</span></span> <span data-ttu-id="c7602-115">Aby poprawić wydajność, można użyć `WHERE` klauzulę, aby znacznie zmniejszyć liczbę wierszy jest zwracana do klienta.</span><span class="sxs-lookup"><span data-stu-id="c7602-115">To improve performance, you can use the `WHERE` clause to greatly reduce the number of rows returned to the client.</span></span> <span data-ttu-id="c7602-116">Można także zmniejszyć ilość danych zwracanych do klienta, wyświetlając tylko jawnie wymaganych kolumn w `SELECT` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="c7602-116">You can also reduce the amount of data returned to the client by only explicitly listing required columns in the `SELECT` statement.</span></span> <span data-ttu-id="c7602-117">Innym dobrym rozwiązaniem problemu jest pobieranie wierszy w partii (na przykład kilka wierszy kilkaset w danym momencie) i tylko pobieranie następnej partii, gdy klient jest gotowy, z użyciem bieżącej partii.</span><span class="sxs-lookup"><span data-stu-id="c7602-117">Another good workaround is to retrieve the rows in batches (such as several hundred rows at a time) and only retrieve the next batch when the client is finished with the current batch.</span></span>  
  
 <span data-ttu-id="c7602-118">`Fill` Metoda używa `DataReader` obiektu niejawnie, aby zwrócić nazwy kolumn i typy, które są używane do tworzenia tabel w `DataSet`i danych do wypełnienia wierszy w tabelach w `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-118">The `Fill` method uses the `DataReader` object implicitly to return the column names and types that are used to create the tables in the `DataSet`, and the data to populate the rows of the tables in the `DataSet`.</span></span> <span data-ttu-id="c7602-119">Tabele i kolumny są tworzone tylko jeśli ich jeszcze nie istnieje; w przeciwnym razie `Fill` wykorzystuje istniejące `DataSet` schematu.</span><span class="sxs-lookup"><span data-stu-id="c7602-119">Tables and columns are only created if they do not already exist; otherwise `Fill` uses the existing `DataSet` schema.</span></span> <span data-ttu-id="c7602-120">Typy kolumn są tworzone jako [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] typów zgodnie z tabelami w [mapowanie typu danych w ADO.NET](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md).</span><span class="sxs-lookup"><span data-stu-id="c7602-120">Column types are created as [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types according to the tables in [Data Type Mappings in ADO.NET](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md).</span></span> <span data-ttu-id="c7602-121">Klucze podstawowe nie są tworzone, chyba że istnieją one w źródle danych i `DataAdapter` **.**`MissingSchemaAction`</span><span class="sxs-lookup"><span data-stu-id="c7602-121">Primary keys are not created unless they exist in the data source and `DataAdapter`**.**`MissingSchemaAction`</span></span> <span data-ttu-id="c7602-122">ustawiono `MissingSchemaAction` **.** `AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="c7602-122">is set to `MissingSchemaAction`**.**`AddWithKey`.</span></span> <span data-ttu-id="c7602-123">Jeśli `Fill` stwierdza, że istnieje klucz podstawowy w tabeli, spowoduje zastąpienie danych w `DataSet` z danymi ze źródła danych dla wierszy, w których wartości kolumny klucza podstawowego pasują do właściwości wiersza zwrócone ze źródła danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-123">If `Fill` finds that a primary key exists for a table, it will overwrite data in the `DataSet` with data from the data source for rows where the primary key column values match those of the row returned from the data source.</span></span> <span data-ttu-id="c7602-124">Jeśli zostanie znaleziony żaden klucz podstawowy, dane są dołączane do tabel w `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-124">If no primary key is found, the data is appended to the tables in the `DataSet`.</span></span> <span data-ttu-id="c7602-125">`Fill` korzysta z żadnych mapowań, które mogą występować podczas wypełniania `DataSet` (zobacz [DataAdapter DataTable i mapowania elementu DataColumn](../../../../docs/framework/data/adonet/dataadapter-datatable-and-datacolumn-mappings.md)).</span><span class="sxs-lookup"><span data-stu-id="c7602-125">`Fill` uses any mappings that may exist when you populate the `DataSet` (see [DataAdapter DataTable and DataColumn Mappings](../../../../docs/framework/data/adonet/dataadapter-datatable-and-datacolumn-mappings.md)).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c7602-126">Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia `PrimaryKey` wartości wynikowe `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="c7602-126">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a `PrimaryKey` value for the resulting `DataTable`.</span></span> <span data-ttu-id="c7602-127">Należy zdefiniować `PrimaryKey` sobie, aby upewnić się, że poprawnie rozpoznać zduplikowane wiersze.</span><span class="sxs-lookup"><span data-stu-id="c7602-127">You must define the `PrimaryKey` yourself to make sure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="c7602-128">Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](../../../../docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span><span class="sxs-lookup"><span data-stu-id="c7602-128">For more information, see [Defining Primary Keys](../../../../docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="c7602-129">Poniższy przykład kodu tworzy wystąpienie <xref:System.Data.SqlClient.SqlDataAdapter> , który używa <xref:System.Data.SqlClient.SqlConnection> Microsoft SQL Server `Northwind` bazy danych i wypełnienie <xref:System.Data.DataTable> w `DataSet` listę klientów.</span><span class="sxs-lookup"><span data-stu-id="c7602-129">The following code example creates an instance of a <xref:System.Data.SqlClient.SqlDataAdapter> that uses a <xref:System.Data.SqlClient.SqlConnection> to the Microsoft SQL Server `Northwind` database and populates a <xref:System.Data.DataTable> in a `DataSet` with the list of customers.</span></span> <span data-ttu-id="c7602-130">Instrukcja SQL i <xref:System.Data.SqlClient.SqlConnection> argumenty przekazywane do <xref:System.Data.SqlClient.SqlDataAdapter> Konstruktor są używane do tworzenia <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> właściwość <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="c7602-130">The SQL statement and <xref:System.Data.SqlClient.SqlConnection> arguments passed to the <xref:System.Data.SqlClient.SqlDataAdapter> constructor are used to create the <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter>.</span></span>  
  
## <a name="example"></a><span data-ttu-id="c7602-131">Przykład</span><span class="sxs-lookup"><span data-stu-id="c7602-131">Example</span></span>  
  
```vb  
' Assumes that connection is a valid SqlConnection object.  
Dim queryString As String = _  
  "SELECT CustomerID, CompanyName FROM dbo.Customers"  
Dim adapter As SqlDataAdapter = New SqlDataAdapter( _  
  queryString, connection)  
  
Dim customers As DataSet = New DataSet  
adapter.Fill(customers, "Customers")  
```  
  
```csharp  
// Assumes that connection is a valid SqlConnection object.  
string queryString =   
  "SELECT CustomerID, CompanyName FROM dbo.Customers";  
SqlDataAdapter adapter = new SqlDataAdapter(queryString, connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
```  
  
> [!NOTE]
>  <span data-ttu-id="c7602-132">Kod przedstawiony w tym przykładzie nie jawnie można otworzyć i zamknąć `Connection`.</span><span class="sxs-lookup"><span data-stu-id="c7602-132">The code shown in this example does not explicitly open and close the `Connection`.</span></span> <span data-ttu-id="c7602-133">`Fill` Metodę niejawnie otwiera `Connection` , `DataAdapter` używa, jeśli wykryje, że połączenie nie jest już otwarty.</span><span class="sxs-lookup"><span data-stu-id="c7602-133">The `Fill` method implicitly opens the `Connection` that the `DataAdapter` is using if it finds that the connection is not already open.</span></span> <span data-ttu-id="c7602-134">Jeśli `Fill` otwarte połączenia, również zamyka połączenie podczas `Fill` zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="c7602-134">If `Fill` opened the connection, it also closes the connection when `Fill` is finished.</span></span> <span data-ttu-id="c7602-135">Może to uprościć kod, podczas operacji jednej operacji takich jak `Fill` lub `Update`.</span><span class="sxs-lookup"><span data-stu-id="c7602-135">This can simplify your code when you deal with a single operation such as a `Fill` or an `Update`.</span></span> <span data-ttu-id="c7602-136">Jednak jeśli wykonują wiele operacji, które wymagają otwarcia połączenia, możesz zwiększyć wydajność aplikacji przez jawne wywołanie `Open` metody `Connection`, wykonywanie operacji względem źródła danych i następnie wywoływania `Close` metody `Connection`.</span><span class="sxs-lookup"><span data-stu-id="c7602-136">However, if you are performing multiple operations that require an open connection, you can improve the performance of your application by explicitly calling the `Open` method of the `Connection`, performing the operations against the data source, and then calling the `Close` method of the `Connection`.</span></span> <span data-ttu-id="c7602-137">Należy starać się zachować połączeń ze źródłem danych Otwórz możliwie krótki aby zwolnić zasoby do użytku przez inne aplikacje klienckie.</span><span class="sxs-lookup"><span data-stu-id="c7602-137">You should try to keep connections to the data source open as briefly as possible to free resources for use by other client applications.</span></span>  
  
## <a name="multiple-result-sets"></a><span data-ttu-id="c7602-138">Wiele zestawów wyników</span><span class="sxs-lookup"><span data-stu-id="c7602-138">Multiple Result Sets</span></span>  
 <span data-ttu-id="c7602-139">Jeśli `DataAdapter` zestawy wielu wyników napotka, powoduje to utworzenie wielu tabel w `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-139">If the `DataAdapter` encounters multiple result sets, it creates multiple tables in the `DataSet`.</span></span> <span data-ttu-id="c7602-140">Tabele są podane przyrostowe domyślną nazwę tabeli*N*, począwszy od Table0 "tabeli".</span><span class="sxs-lookup"><span data-stu-id="c7602-140">The tables are given an incremental default name of Table*N*, starting with "Table" for Table0.</span></span> <span data-ttu-id="c7602-141">Jeśli nazwa tabeli jest przekazywany jako argument do `Fill` metody tabele są podane przyrostowe domyślną nazwę TableName*N*, począwszy od "TableName", aby uzyskać TableName0.</span><span class="sxs-lookup"><span data-stu-id="c7602-141">If a table name is passed as an argument to the `Fill` method, the tables are given an incremental default name of TableName*N*, starting with "TableName" for TableName0.</span></span>  
  
## <a name="populating-a-dataset-from-multiple-dataadapters"></a><span data-ttu-id="c7602-142">Wypełnianie zestawu danych z wielu elementów DataAdapters</span><span class="sxs-lookup"><span data-stu-id="c7602-142">Populating a DataSet from Multiple DataAdapters</span></span>  
 <span data-ttu-id="c7602-143">Dowolną liczbę `DataAdapter` obiekty mogą być używane z `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-143">Any number of `DataAdapter` objects can be used with a `DataSet`.</span></span> <span data-ttu-id="c7602-144">Każdy `DataAdapter` może służyć do wypełnienia co najmniej jeden `DataTable` obiektów i rozwiąż aktualizacje z powrotem do źródła danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-144">Each `DataAdapter` can be used to fill one or more `DataTable` objects and resolve updates back to the relevant data source.</span></span> <span data-ttu-id="c7602-145">`DataRelation` i `Constraint` obiekty mogą być dodawane do `DataSet` lokalnie, co umożliwia powiązać dane z różnych źródeł.</span><span class="sxs-lookup"><span data-stu-id="c7602-145">`DataRelation` and `Constraint` objects can be added to the `DataSet` locally, which enables you to relate data from dissimilar data sources.</span></span> <span data-ttu-id="c7602-146">Na przykład `DataSet` może zawierać dane z bazy danych programu Microsoft SQL Server, bazy danych programu IBM DB2 udostępniane za pośrednictwem OLE DB i źródła danych, które strumieni XML.</span><span class="sxs-lookup"><span data-stu-id="c7602-146">For example, a `DataSet` can contain data from a Microsoft SQL Server database, an IBM DB2 database exposed through OLE DB, and a data source that streams XML.</span></span> <span data-ttu-id="c7602-147">Co najmniej jeden `DataAdapter` obiektów może obsługiwać komunikację z każdego źródła danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-147">One or more `DataAdapter` objects can handle communication to each data source.</span></span>  
  
### <a name="example"></a><span data-ttu-id="c7602-148">Przykład</span><span class="sxs-lookup"><span data-stu-id="c7602-148">Example</span></span>  
 <span data-ttu-id="c7602-149">Poniższy przykład kodu wypełnia listę klientów z `Northwind` bazy danych, program Microsoft SQL Server i listę zamówień z `Northwind` bazy danych programu Microsoft Access 2000.</span><span class="sxs-lookup"><span data-stu-id="c7602-149">The following code example populates a list of customers from the `Northwind` database on Microsoft SQL Server, and a list of orders from the `Northwind` database stored in Microsoft Access 2000.</span></span> <span data-ttu-id="c7602-150">Wypełniony tabele są powiązane z `DataRelation`, a następnie zostanie wyświetlona lista klientów przy użyciu zamówień tego klienta.</span><span class="sxs-lookup"><span data-stu-id="c7602-150">The filled tables are related with a `DataRelation`, and the list of customers is then displayed with the orders for that customer.</span></span> <span data-ttu-id="c7602-151">Aby uzyskać więcej informacji na temat `DataRelation` obiekty, zobacz [Dodawanie elementów DataRelation](../../../../docs/framework/data/adonet/dataset-datatable-dataview/adding-datarelations.md) i [przejść elementów DataRelation](../../../../docs/framework/data/adonet/dataset-datatable-dataview/navigating-datarelations.md).</span><span class="sxs-lookup"><span data-stu-id="c7602-151">For more information about `DataRelation` objects, see [Adding DataRelations](../../../../docs/framework/data/adonet/dataset-datatable-dataview/adding-datarelations.md) and [Navigating DataRelations](../../../../docs/framework/data/adonet/dataset-datatable-dataview/navigating-datarelations.md).</span></span>  
  
```vb  
' Assumes that customerConnection is a valid SqlConnection object.  
' Assumes that orderConnection is a valid OleDbConnection object.  
Dim custAdapter As SqlDataAdapter = New SqlDataAdapter( _  
  "SELECT * FROM dbo.Customers", customerConnection)  
  
Dim ordAdapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SELECT * FROM Orders", orderConnection)  
  
Dim customerOrders As DataSet = New DataSet()  
custAdapter.Fill(customerOrders, "Customers")  
ordAdapter.Fill(customerOrders, "Orders")  
  
Dim relation As DataRelation = _  
  customerOrders.Relations.Add("CustOrders", _  
  customerOrders.Tables("Customers").Columns("CustomerID"), _   
  customerOrders.Tables("Orders").Columns("CustomerID"))  
  
Dim pRow, cRow As DataRow  
For Each pRow In customerOrders.Tables("Customers").Rows  
  Console.WriteLine(pRow("CustomerID").ToString())  
  
  For Each cRow In pRow.GetChildRows(relation)  
    Console.WriteLine(vbTab & cRow("OrderID").ToString())  
  Next  
Next  
```  
  
```csharp  
// Assumes that customerConnection is a valid SqlConnection object.  
// Assumes that orderConnection is a valid OleDbConnection object.  
SqlDataAdapter custAdapter = new SqlDataAdapter(  
  "SELECT * FROM dbo.Customers", customerConnection);  
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(  
  "SELECT * FROM Orders", orderConnection);  
  
DataSet customerOrders = new DataSet();  
  
custAdapter.Fill(customerOrders, "Customers");  
ordAdapter.Fill(customerOrders, "Orders");  
  
DataRelation relation = customerOrders.Relations.Add("CustOrders",  
  customerOrders.Tables["Customers"].Columns["CustomerID"],  
  customerOrders.Tables["Orders"].Columns["CustomerID"]);  
  
foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)  
{  
  Console.WriteLine(pRow["CustomerID"]);  
   foreach (DataRow cRow in pRow.GetChildRows(relation))  
    Console.WriteLine("\t" + cRow["OrderID"]);  
}  
```  
  
## <a name="sql-server-decimal-type"></a><span data-ttu-id="c7602-152">Typu dziesiętnego programu SQL Server</span><span class="sxs-lookup"><span data-stu-id="c7602-152">SQL Server Decimal Type</span></span>  
 <span data-ttu-id="c7602-153">Domyślnie `DataSet` przechowuje dane przy użyciu [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] typów danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-153">By default, the `DataSet` stores data by using [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] data types.</span></span> <span data-ttu-id="c7602-154">W przypadku większości aplikacji te zapewniają wygodny reprezentacja informacje o źródle danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-154">For most applications, these provide a convenient representation of data source information.</span></span> <span data-ttu-id="c7602-155">Jednak taka reprezentacja może powodować problem, jeśli typ danych w źródle danych jest typu dziesiętnego lub liczbowego danych programu SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c7602-155">However, this representation may cause a problem when the data type in the data source is a SQL Server decimal or numeric data type.</span></span> <span data-ttu-id="c7602-156">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] `decimal` — Typ danych pozwala maksymalnie 28 cyfr znaczących, podczas gdy program SQL Server `decimal` typ danych umożliwia 38 cyfr znaczących.</span><span class="sxs-lookup"><span data-stu-id="c7602-156">The [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] `decimal` data type allows a maximum of 28 significant digits, whereas the SQL Server `decimal` data type allows 38 significant digits.</span></span> <span data-ttu-id="c7602-157">Jeśli `SqlDataAdapter` określa podczas `Fill` operacji, dokładność programu SQL Server `decimal` pola jest większy niż 28 znaków, bieżący wiersz nie jest dodawany do `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="c7602-157">If the `SqlDataAdapter` determines during a `Fill` operation that the precision of a SQL Server `decimal` field is larger than 28 characters, the current row is not added to the `DataTable`.</span></span> <span data-ttu-id="c7602-158">Zamiast tego `FillError` wystąpi zdarzenie, co pozwala określić, czy utratę dokładności będą występować reagować odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="c7602-158">Instead the `FillError` event occurs, which enables you to determine whether a loss of precision will occur, and respond appropriately.</span></span> <span data-ttu-id="c7602-159">Aby uzyskać więcej informacji na temat `FillError` zdarzeń, zobacz [Obsługa zdarzeń elementu DataAdapter](../../../../docs/framework/data/adonet/handling-dataadapter-events.md).</span><span class="sxs-lookup"><span data-stu-id="c7602-159">For more information about the `FillError` event, see [Handling DataAdapter Events](../../../../docs/framework/data/adonet/handling-dataadapter-events.md).</span></span> <span data-ttu-id="c7602-160">Można pobrać serwera SQL `decimal` wartości, można również użyć <xref:System.Data.SqlClient.SqlDataReader> obiektu, a następnie wywołać <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c7602-160">To get the SQL Server `decimal` value, you can also use a <xref:System.Data.SqlClient.SqlDataReader> object and call the <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> method.</span></span>  
  
 [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] <span data-ttu-id="c7602-161">2.0 wprowadzono rozszerzoną obsługę <xref:System.Data.SqlTypes> w `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-161">2.0 introduced enhanced support for <xref:System.Data.SqlTypes> in the `DataSet`.</span></span> <span data-ttu-id="c7602-162">Aby uzyskać więcej informacji, zobacz [SqlTypes i zestaw danych](../../../../docs/framework/data/adonet/sql/sqltypes-and-the-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="c7602-162">For more information, see [SqlTypes and the DataSet](../../../../docs/framework/data/adonet/sql/sqltypes-and-the-dataset.md).</span></span>  
  
## <a name="ole-db-chapters"></a><span data-ttu-id="c7602-163">OLE DB rozdziałów</span><span class="sxs-lookup"><span data-stu-id="c7602-163">OLE DB Chapters</span></span>  
 <span data-ttu-id="c7602-164">Hierarchiczna zestawów wierszy i rozdziałami (typ OLE DB `DBTYPE_HCHAPTER`, typ ADO `adChapter`) może służyć do wypełnienia zawartość `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-164">Hierarchical rowsets, or chapters (OLE DB type `DBTYPE_HCHAPTER`, ADO type `adChapter`) can be used to fill the contents of a `DataSet`.</span></span> <span data-ttu-id="c7602-165">Podczas <xref:System.Data.OleDb.OleDbDataAdapter> napotka podzielony na rozdziały kolumny podczas `Fill` operacji `DataTable` jest tworzony w kolumnie podzielony na rozdziały i tej tabeli jest wypełniany kolumn i wierszy od działu.</span><span class="sxs-lookup"><span data-stu-id="c7602-165">When the <xref:System.Data.OleDb.OleDbDataAdapter> encounters a chaptered column during a `Fill` operation, a `DataTable` is created for the chaptered column, and that table is filled with the columns and rows from the chapter.</span></span> <span data-ttu-id="c7602-166">Tabela utworzona dla podzielony na rozdziały kolumna nosiła nazwę za pomocą nazwy tabeli nadrzędnej i nazwę kolumny podzielony na rozdziały w formie "*ParentTableNameChapteredColumnName*".</span><span class="sxs-lookup"><span data-stu-id="c7602-166">The table created for the chaptered column is named by using both the parent table name and the chaptered column name in the form "*ParentTableNameChapteredColumnName*".</span></span> <span data-ttu-id="c7602-167">Jeśli tabela już istnieje w `DataSet` który pasuje do nazwy kolumny podzielony na rozdziały, bieżącej tabeli jest wypełniony przy użyciu danych działu.</span><span class="sxs-lookup"><span data-stu-id="c7602-167">If a table already exists in the `DataSet` that matches the name of the chaptered column, the current table is filled with the chapter data.</span></span> <span data-ttu-id="c7602-168">Jeśli nie ma żadnej kolumny w istniejącej tabeli, która jest zgodna z kolumną znaleźć w rozdziale, nowa kolumna zostanie dodana.</span><span class="sxs-lookup"><span data-stu-id="c7602-168">If there is no column in an existing table that matches a column found in the chapter, a new column is added.</span></span>  
  
 <span data-ttu-id="c7602-169">Przed tabel w `DataSet` są wypełniane przy użyciu danych w kolumnach podzielony na rozdziały relacji jest tworzony między nadrzędnym a podrzędnym tabel hierarchiczne zestawu wierszy, dodając kolumna liczb całkowitych do tabeli nadrzędne i podrzędne, ustawienie kolumny nadrzędnej automatycznego przyrostu i tworzenie `DataRelation` przy użyciu dodanych kolumn z obu tabel.</span><span class="sxs-lookup"><span data-stu-id="c7602-169">Before the tables in the `DataSet` are filled with the data in the chaptered columns, a relation is created between the parent and child tables of the hierarchical rowset by adding an integer column to both the parent and child table, setting the parent column to auto-increment, and creating a `DataRelation` using the added columns from both tables.</span></span> <span data-ttu-id="c7602-170">Dodano relacji nosi nazwę przy użyciu nazw kolumn tabeli i rozdział nadrzędnego w formie "*ParentTableNameChapterColumnName*".</span><span class="sxs-lookup"><span data-stu-id="c7602-170">The added relation is named by using the parent table and chapter column names in the form "*ParentTableNameChapterColumnName*".</span></span>  
  
 <span data-ttu-id="c7602-171">Należy zauważyć, że istnieje tylko powiązane kolumny w `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c7602-171">Note that the related column only exists in the `DataSet`.</span></span> <span data-ttu-id="c7602-172">Kolejne wypełnienia ze źródła danych może spowodować nowe wiersze, które mają zostać dodane do tabel, zamiast zmiany są scalane w istniejących wierszy.</span><span class="sxs-lookup"><span data-stu-id="c7602-172">Subsequent fills from the data source can cause new rows to be added to the tables instead of changes being merged into existing rows.</span></span>  
  
 <span data-ttu-id="c7602-173">Należy zauważyć, że, jeśli używasz `DataAdapter.Fill` przeciążenia przyjmującego `DataTable`, tylko w tej tabeli zostaną wypełnione.</span><span class="sxs-lookup"><span data-stu-id="c7602-173">Note also that, if you use the `DataAdapter.Fill` overload that takes a `DataTable`, only that table will be filled.</span></span> <span data-ttu-id="c7602-174">Kolumna liczb całkowitych o wartości auto nadal będzie dodawany do tabeli, ale nie tabeli podrzędnej będzie można utworzyć ani wypełnione, a zostanie utworzona żadna relacja.</span><span class="sxs-lookup"><span data-stu-id="c7602-174">An auto-incrementing integer column will still be added to the table, but no child table will be created or filled, and no relation will be created.</span></span>  
  
 <span data-ttu-id="c7602-175">W poniższym przykładzie użyto dostawcy MSDataShape do generowania kolumny rozdziałów zamówień dla każdego klienta na liście klientów.</span><span class="sxs-lookup"><span data-stu-id="c7602-175">The following example uses the MSDataShape Provider to generate a chapter column of orders for each customer in a list of customers.</span></span> <span data-ttu-id="c7602-176">Element `DataSet` jest następnie wypełniana przy użyciu danych.</span><span class="sxs-lookup"><span data-stu-id="c7602-176">A `DataSet` is then filled with the data.</span></span>  
  
```vb  
Using connection As OleDbConnection = New OleDbConnection( _  
  "Provider=MSDataShape;Data Provider=SQLOLEDB;" & _  
  "Data Source=(local);Integrated " & _  
  "Security=SSPI;Initial Catalog=northwind")  
  
Dim adapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SHAPE {SELECT CustomerID, CompanyName FROM Customers} " & _  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " & _  
  "RELATE CustomerID TO CustomerID)", connection)  
  
Dim customers As DataSet = New DataSet()  
  
adapter.Fill(customers, "Customers")  
End Using  
```  
  
```csharp  
using (OleDbConnection connection = new OleDbConnection("Provider=MSDataShape;Data Provider=SQLOLEDB;" +  
  "Data Source=(local);Integrated Security=SSPI;Initial Catalog=northwind"))  
{  
OleDbDataAdapter adapter = new OleDbDataAdapter("SHAPE {SELECT CustomerID, CompanyName FROM Customers} " +  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " +  
  "RELATE CustomerID TO CustomerID)", connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
}  
```  
  
 <span data-ttu-id="c7602-177">Gdy `Fill` operacja została zakończona, `DataSet` zawiera dwie tabele: `Customers` i `CustomersOrders`, gdzie `CustomersOrders` reprezentuje podzielony na rozdziały kolumnę.</span><span class="sxs-lookup"><span data-stu-id="c7602-177">When the `Fill` operation is complete, the `DataSet` contains two tables: `Customers` and `CustomersOrders`, where `CustomersOrders` represents the chaptered column.</span></span> <span data-ttu-id="c7602-178">Dodatkową kolumnę o nazwie `Orders` jest dodawany do `Customers` tabeli i dodatkową kolumnę o nazwie `CustomersOrders` jest dodawany do `CustomersOrders` tabeli.</span><span class="sxs-lookup"><span data-stu-id="c7602-178">An additional column named `Orders` is added to the `Customers` table, and an additional column named `CustomersOrders` is added to the `CustomersOrders` table.</span></span> <span data-ttu-id="c7602-179">`Orders` Kolumny w `Customers` tabeli jest ustawiony do automatycznego przyrostu.</span><span class="sxs-lookup"><span data-stu-id="c7602-179">The `Orders` column in the `Customers` table is set to auto-increment.</span></span> <span data-ttu-id="c7602-180">A `DataRelation`, `CustomersOrders`, jest tworzona przy użyciu kolumn, które zostały dodane do tabel `Customers` jako tabelę nadrzędną.</span><span class="sxs-lookup"><span data-stu-id="c7602-180">A `DataRelation`, `CustomersOrders`, is created by using the columns that were added to the tables with `Customers` as the parent table.</span></span> <span data-ttu-id="c7602-181">W poniższej tabeli przedstawiono niektóre przykładowe wyniki.</span><span class="sxs-lookup"><span data-stu-id="c7602-181">The following tables show some sample results.</span></span>  
  
### <a name="tablename-customers"></a><span data-ttu-id="c7602-182">Właściwość TableName: Klienci</span><span class="sxs-lookup"><span data-stu-id="c7602-182">TableName: Customers</span></span>  
  
|<span data-ttu-id="c7602-183">CustomerID</span><span class="sxs-lookup"><span data-stu-id="c7602-183">CustomerID</span></span>|<span data-ttu-id="c7602-184">CompanyName</span><span class="sxs-lookup"><span data-stu-id="c7602-184">CompanyName</span></span>|<span data-ttu-id="c7602-185">Zamówienia</span><span class="sxs-lookup"><span data-stu-id="c7602-185">Orders</span></span>|  
|----------------|-----------------|------------|  
|<span data-ttu-id="c7602-186">ALFKI</span><span class="sxs-lookup"><span data-stu-id="c7602-186">ALFKI</span></span>|<span data-ttu-id="c7602-187">Alfreds Futterkiste</span><span class="sxs-lookup"><span data-stu-id="c7602-187">Alfreds Futterkiste</span></span>|<span data-ttu-id="c7602-188">0</span><span class="sxs-lookup"><span data-stu-id="c7602-188">0</span></span>|  
|<span data-ttu-id="c7602-189">ANATR</span><span class="sxs-lookup"><span data-stu-id="c7602-189">ANATR</span></span>|<span data-ttu-id="c7602-190">Helados y ana Trujillo Emparedados</span><span class="sxs-lookup"><span data-stu-id="c7602-190">Ana Trujillo Emparedados y helados</span></span>|<span data-ttu-id="c7602-191">1</span><span class="sxs-lookup"><span data-stu-id="c7602-191">1</span></span>|  
  
### <a name="tablename-customersorders"></a><span data-ttu-id="c7602-192">Właściwość TableName: CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="c7602-192">TableName: CustomersOrders</span></span>  
  
|<span data-ttu-id="c7602-193">CustomerID</span><span class="sxs-lookup"><span data-stu-id="c7602-193">CustomerID</span></span>|<span data-ttu-id="c7602-194">OrderID</span><span class="sxs-lookup"><span data-stu-id="c7602-194">OrderID</span></span>|<span data-ttu-id="c7602-195">CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="c7602-195">CustomersOrders</span></span>|  
|----------------|-------------|---------------------|  
|<span data-ttu-id="c7602-196">ALFKI</span><span class="sxs-lookup"><span data-stu-id="c7602-196">ALFKI</span></span>|<span data-ttu-id="c7602-197">10643</span><span class="sxs-lookup"><span data-stu-id="c7602-197">10643</span></span>|<span data-ttu-id="c7602-198">0</span><span class="sxs-lookup"><span data-stu-id="c7602-198">0</span></span>|  
|<span data-ttu-id="c7602-199">ALFKI</span><span class="sxs-lookup"><span data-stu-id="c7602-199">ALFKI</span></span>|<span data-ttu-id="c7602-200">10692</span><span class="sxs-lookup"><span data-stu-id="c7602-200">10692</span></span>|<span data-ttu-id="c7602-201">0</span><span class="sxs-lookup"><span data-stu-id="c7602-201">0</span></span>|  
|<span data-ttu-id="c7602-202">ANATR</span><span class="sxs-lookup"><span data-stu-id="c7602-202">ANATR</span></span>|<span data-ttu-id="c7602-203">10308</span><span class="sxs-lookup"><span data-stu-id="c7602-203">10308</span></span>|<span data-ttu-id="c7602-204">1</span><span class="sxs-lookup"><span data-stu-id="c7602-204">1</span></span>|  
|<span data-ttu-id="c7602-205">ANATR</span><span class="sxs-lookup"><span data-stu-id="c7602-205">ANATR</span></span>|<span data-ttu-id="c7602-206">10625</span><span class="sxs-lookup"><span data-stu-id="c7602-206">10625</span></span>|<span data-ttu-id="c7602-207">1</span><span class="sxs-lookup"><span data-stu-id="c7602-207">1</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="c7602-208">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="c7602-208">See also</span></span>

- [<span data-ttu-id="c7602-209">Elementy DataAdapter i DataReaders</span><span class="sxs-lookup"><span data-stu-id="c7602-209">DataAdapters and DataReaders</span></span>](../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)
- [<span data-ttu-id="c7602-210">Mapowanie typu danych w ADO.NET</span><span class="sxs-lookup"><span data-stu-id="c7602-210">Data Type Mappings in ADO.NET</span></span>](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="c7602-211">Modyfikowanie danych za pomocą obiektu DbDataAdapter</span><span class="sxs-lookup"><span data-stu-id="c7602-211">Modifying Data with a DbDataAdapter</span></span>](../../../../docs/framework/data/adonet/modifying-data-with-a-dbdataadapter.md)
- [<span data-ttu-id="c7602-212">Wiele aktywnych zestawów wyników (MARS)</span><span class="sxs-lookup"><span data-stu-id="c7602-212">Multiple Active Result Sets (MARS)</span></span>](../../../../docs/framework/data/adonet/sql/multiple-active-result-sets-mars.md)
- [<span data-ttu-id="c7602-213">ADO.NET zarządzanego dostawcy i Centrum deweloperów zestawu danych</span><span class="sxs-lookup"><span data-stu-id="c7602-213">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
