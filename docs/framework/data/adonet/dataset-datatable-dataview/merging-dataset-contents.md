---
title: Scalanie zawartości zestawu danych
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: c0cc0834dc087df89131a720f517cd34f757a0f3
ms.sourcegitcommit: 11f11ca6cefe555972b3a5c99729d1a7523d8f50
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/03/2018
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="3c627-102">Scalanie zawartości zestawu danych</span><span class="sxs-lookup"><span data-stu-id="3c627-102">Merging DataSet Contents</span></span>
<span data-ttu-id="3c627-103">Można użyć <xref:System.Data.DataSet.Merge%2A> sposób scalania zawartość <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, lub <xref:System.Data.DataRow> tablicy do istniejącej `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="3c627-103">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="3c627-104">Kilka czynników, jak i opcje mają wpływ na sposób nowe dane są scalane istniejące `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="3c627-104">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>  
  
## <a name="primary-keys"></a><span data-ttu-id="3c627-105">Klucze podstawowe</span><span class="sxs-lookup"><span data-stu-id="3c627-105">Primary Keys</span></span>  
 <span data-ttu-id="3c627-106">Jeśli klucz podstawowy tabeli odbieranie nowych danych i schematu z scalania, nowe wiersze z danych przychodzących są wspomagane istniejących wierszy, które mają taki sam <xref:System.Data.DataRowVersion.Original> wartości klucza podstawowego, jak przychodzących danych.</span><span class="sxs-lookup"><span data-stu-id="3c627-106">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="3c627-107">Jeśli kolumny z przychodzącego schematu pasują do właściwości istniejącego schematu, dane w istniejących wierszy jest modyfikowany.</span><span class="sxs-lookup"><span data-stu-id="3c627-107">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="3c627-108">Kolumny, która nie pasuje do istniejącego schematu są ignorowane lub dodane na podstawie <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parametru.</span><span class="sxs-lookup"><span data-stu-id="3c627-108">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="3c627-109">Nowe wiersze z wartości kluczy podstawowych, które nie pasują jakiekolwiek istniejące wiersze są dołączane do istniejącej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3c627-109">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>  
  
 <span data-ttu-id="3c627-110">Jeśli przychodzących lub istniejących wierszy mają stan wiersza <xref:System.Data.DataRowState.Added>, ich wartości klucza podstawowego są identyfikowane przy użyciu <xref:System.Data.DataRowVersion.Current> wartość klucza podstawowego `Added` wiersza, ponieważ nie `Original` istnieje wersji wiersza.</span><span class="sxs-lookup"><span data-stu-id="3c627-110">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>  
  
 <span data-ttu-id="3c627-111">Jeśli przychodzące tabeli i istniejącej tabeli zawierają kolumnę o tej samej nazwie, ale różne typy danych, jest zgłaszany wyjątek i <xref:System.Data.DataSet.MergeFailed> zdarzenie `DataSet` jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="3c627-111">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="3c627-112">Jeśli przychodzące tabeli i istniejącej tabeli zdefiniowano kluczy, ale klucze główne są przeznaczone dla różnych kolumn, jest zgłaszany wyjątek i `MergeFailed` zdarzenie `DataSet` jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="3c627-112">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>  
  
 <span data-ttu-id="3c627-113">Jeśli tabela otrzymuje nowych danych z scalania nie ma klucza podstawowego, nowych wierszy z przychodzących danych nie można dopasować do istniejących wierszy w tabeli i zamiast tego są dołączane do istniejącej tabeli.</span><span class="sxs-lookup"><span data-stu-id="3c627-113">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>  
  
## <a name="table-names-and-namespaces"></a><span data-ttu-id="3c627-114">Nazwy tabel i przestrzenie nazw</span><span class="sxs-lookup"><span data-stu-id="3c627-114">Table Names and Namespaces</span></span>  
 <span data-ttu-id="3c627-115"><xref:System.Data.DataTable> Opcjonalnie można przypisać obiektów <xref:System.Data.DataTable.Namespace%2A> wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="3c627-115"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="3c627-116">Gdy <xref:System.Data.DataTable.Namespace%2A> przypisywania wartości <xref:System.Data.DataSet> może zawierać wiele <xref:System.Data.DataTable> obiektów z takimi samymi <xref:System.Data.DataTable.TableName%2A> wartość.</span><span class="sxs-lookup"><span data-stu-id="3c627-116">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="3c627-117">Podczas operacji scalania zarówno <xref:System.Data.DataTable.TableName%2A> i <xref:System.Data.DataTable.Namespace%2A> są używane do identyfikowania element docelowy scalania.</span><span class="sxs-lookup"><span data-stu-id="3c627-117">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="3c627-118">Jeśli nie <xref:System.Data.DataTable.Namespace%2A> przypisano, tylko <xref:System.Data.DataTable.TableName%2A> służy do identyfikowania element docelowy scalania.</span><span class="sxs-lookup"><span data-stu-id="3c627-118">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c627-119">To zachowanie, zmiany w wersji 2.0 programu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3c627-119">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="3c627-120">W wersji 1.1 przestrzenie nazw są obsługiwane, ale zostały zignorowane podczas operacji scalania.</span><span class="sxs-lookup"><span data-stu-id="3c627-120">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="3c627-121">Z tego powodu <xref:System.Data.DataSet> używającą <xref:System.Data.DataTable.Namespace%2A> wartości właściwości mają różne zachowania, w zależności od instalowanej wersji programu .NET Framework są uruchomione.</span><span class="sxs-lookup"><span data-stu-id="3c627-121">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="3c627-122">Załóżmy na przykład, jeśli masz dwa `DataSets` zawierający `DataTables` o takim samym <xref:System.Data.DataTable.TableName%2A> ale o innej wartości właściwości <xref:System.Data.DataTable.Namespace%2A> wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="3c627-122">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="3c627-123">W wersji 1.1 programu .NET Framework różnych <xref:System.Data.DataTable.Namespace%2A> nazwy zostaną pominięte podczas scalania dwa <xref:System.Data.DataSet> obiektów.</span><span class="sxs-lookup"><span data-stu-id="3c627-123">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="3c627-124">Jednak począwszy od wersji 2.0, scalanie powoduje, że dwa nowe `DataTables` ma zostać utworzony w celu <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="3c627-124">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="3c627-125">Oryginalna `DataTables` będą mieć wpływu na scalanie.</span><span class="sxs-lookup"><span data-stu-id="3c627-125">The original `DataTables` will be unaffected by the merge.</span></span>  
  
## <a name="preservechanges"></a><span data-ttu-id="3c627-126">PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="3c627-126">PreserveChanges</span></span>  
 <span data-ttu-id="3c627-127">Podczas przekazywania `DataSet`, `DataTable`, lub `DataRow` tablicy do `Merge` metody, można uwzględnić parametry opcjonalne, które określają, czy chcesz zachować zmiany w istniejących `DataSet`oraz sposób obsługi nowych elementów schematu znaleziono w danych przychodzących.</span><span class="sxs-lookup"><span data-stu-id="3c627-127">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="3c627-128">Pierwsza z tych parametrów po danych przychodzących jest flaga wartości logicznej, <xref:System.Data.LoadOption.PreserveChanges>, który określa, czy chcesz zachować zmiany w istniejących `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="3c627-128">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="3c627-129">Jeśli `PreserveChanges` flaga jest ustawiona na `true`, wartości przychodzących nie zastępują istniejące wartości w `Current` wersji wierszy istniejącego wiersza.</span><span class="sxs-lookup"><span data-stu-id="3c627-129">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="3c627-130">Jeśli `PreserveChanges` flaga jest ustawiona na `false`, wartości przychodzących zastąpić istniejące wartości w `Current` wersji wierszy istniejącego wiersza.</span><span class="sxs-lookup"><span data-stu-id="3c627-130">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="3c627-131">Jeśli `PreserveChanges` flaga nie zostanie określony, jest równa `false` domyślnie.</span><span class="sxs-lookup"><span data-stu-id="3c627-131">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="3c627-132">Aby uzyskać więcej informacji dotyczących wersji wierszy, zobacz [stany wiersza i wersje wiersza](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span><span class="sxs-lookup"><span data-stu-id="3c627-132">For more information about row versions, see [Row States and Row Versions](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>  
  
 <span data-ttu-id="3c627-133">Gdy `PreserveChanges` jest `true`, dane z istniejącym wierszu są przechowywane w <xref:System.Data.DataRowVersion.Current> wersja wiersza z istniejącym wierszu danych z <xref:System.Data.DataRowVersion.Original> wersji wierszy istniejącego wiersza jest zastępowany przy użyciu danych z `Original` wiersza Wersja wiersza przychodzących.</span><span class="sxs-lookup"><span data-stu-id="3c627-133">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="3c627-134"><xref:System.Data.DataRow.RowState%2A> Istniejącego wiersza jest ustawiony na wartość <xref:System.Data.DataRowState.Modified>.</span><span class="sxs-lookup"><span data-stu-id="3c627-134">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="3c627-135">Zastosuj następujące wyjątki:</span><span class="sxs-lookup"><span data-stu-id="3c627-135">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="3c627-136">Jeśli istniejący wiersz ma `RowState` z `Deleted`, to `RowState` pozostaje `Deleted` i nie jest ustawiony na `Modified`.</span><span class="sxs-lookup"><span data-stu-id="3c627-136">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="3c627-137">W takim przypadku dane z przychodzącego wiersza, nadal będą przechowywane w `Original` wersja wiersza istniejącego wiersza zastępowanie `Original` wersji wierszy istniejącego wiersza (chyba że przychodzące wiersz ma `RowState` z `Added`).</span><span class="sxs-lookup"><span data-stu-id="3c627-137">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>  
  
-   <span data-ttu-id="3c627-138">Jeśli wiersz ma `RowState` z `Added`, dane z `Original` wersji wierszy istniejącego wiersza nie zostaną zastąpione danymi z przychodzącego wiersza, ponieważ wiersz nie ma `Original` wersji wiersza.</span><span class="sxs-lookup"><span data-stu-id="3c627-138">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
 <span data-ttu-id="3c627-139">Gdy `PreserveChanges` jest `false`, zarówno `Current` i `Original` wersji wierszy w istniejącym wierszu zostaną zastąpione danymi z przychodzącego wiersza i `RowState` istniejącego wiersza jest ustawiony na wartość `RowState` przychodzące wiersza.</span><span class="sxs-lookup"><span data-stu-id="3c627-139">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="3c627-140">Zastosuj następujące wyjątki:</span><span class="sxs-lookup"><span data-stu-id="3c627-140">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="3c627-141">Jeśli wiersz przychodzące ma `RowState` z `Unchanged` i istniejący wiersz ma `RowState` z `Modified`, `Deleted`, lub `Added`, `RowState` istniejącego wiersza jest ustawiony na wartość `Modified`.</span><span class="sxs-lookup"><span data-stu-id="3c627-141">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>  
  
-   <span data-ttu-id="3c627-142">Jeśli wiersz przychodzące ma `RowState` z `Added`, a istniejący wiersz ma `RowState` z `Unchanged`, `Modified`, lub `Deleted`, `RowState` istniejącego wiersza jest ustawiony na wartość `Modified`.</span><span class="sxs-lookup"><span data-stu-id="3c627-142">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="3c627-143">Ponadto dane z `Original` wersji wierszy istniejącego wiersza nie jest zastępowany dane z przychodzącego wiersza, ponieważ wiersz nie ma `Original` wersji wiersza.</span><span class="sxs-lookup"><span data-stu-id="3c627-143">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
## <a name="missingschemaaction"></a><span data-ttu-id="3c627-144">MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="3c627-144">MissingSchemaAction</span></span>  
 <span data-ttu-id="3c627-145">Można użyć opcjonalnego <xref:System.Data.MissingSchemaAction> parametr `Merge` metodę, aby określić sposób `Merge` obsłuży elementy schematu przychodzących danych, które nie są częścią istniejącej `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="3c627-145">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>  
  
 <span data-ttu-id="3c627-146">W poniższej tabeli opisano opcje `MissingSchemaAction`.</span><span class="sxs-lookup"><span data-stu-id="3c627-146">The following table describes the options for `MissingSchemaAction`.</span></span>  
  
|<span data-ttu-id="3c627-147">Opcja MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="3c627-147">MissingSchemaAction option</span></span>|<span data-ttu-id="3c627-148">Opis</span><span class="sxs-lookup"><span data-stu-id="3c627-148">Description</span></span>|  
|--------------------------------|-----------------|  
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="3c627-149">Dodawanie nowych informacji o schemacie `DataSet` i wypełnić nowe kolumny przy użyciu wartości przychodzących.</span><span class="sxs-lookup"><span data-stu-id="3c627-149">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="3c627-150">Domyślnie włączone.</span><span class="sxs-lookup"><span data-stu-id="3c627-150">This is the default.</span></span>|  
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="3c627-151">Dodawanie nowego schematu i informacje o kluczu podstawowym do `DataSet` i wypełnić nowe kolumny przy użyciu wartości przychodzących.</span><span class="sxs-lookup"><span data-stu-id="3c627-151">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="3c627-152">Zgłoś wyjątek, jeśli okaże się informacje o schemacie niezgodne.</span><span class="sxs-lookup"><span data-stu-id="3c627-152">Throw an exception if mismatched schema information is encountered.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="3c627-153">Ignoruj nowych informacji o schemacie.</span><span class="sxs-lookup"><span data-stu-id="3c627-153">Ignore the new schema information.</span></span>|  
  
## <a name="constraints"></a><span data-ttu-id="3c627-154">Ograniczenia</span><span class="sxs-lookup"><span data-stu-id="3c627-154">Constraints</span></span>  
 <span data-ttu-id="3c627-155">Z `Merge` metody ograniczenia nie są sprawdzane, dopóki wszystkie nowe dane zostały dodane do istniejącej `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="3c627-155">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="3c627-156">Po dodaniu danych na bieżące wartości wymuszone są ograniczenia `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="3c627-156">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="3c627-157">Należy się upewnić, że kod obsługuje wszystkie wyjątki, które może zostać zgłoszone z powodu naruszenia ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="3c627-157">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>  
  
 <span data-ttu-id="3c627-158">Rozważmy przykład w przypadku, gdy istniejący wiersz w `DataSet` jest `Unchanged` wiersza z wartości klucza podstawowego 1.</span><span class="sxs-lookup"><span data-stu-id="3c627-158">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="3c627-159">Podczas operacji scalania z `Modified` wiersz z `Original` wartość klucza podstawowego 2 i `Current` wartość klucza podstawowego równą 1, istniejący wiersz i wiersz nie są uznawane za zgodnych, ponieważ `Original` wartości klucza podstawowego różnią się.</span><span class="sxs-lookup"><span data-stu-id="3c627-159">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="3c627-160">Jednak po ukończeniu scalania i ograniczenia są zaznaczone, zostanie wygenerowany wyjątek ponieważ `Current` wartości kluczy podstawowych narusza ograniczenie unique dla kolumny klucza podstawowego.</span><span class="sxs-lookup"><span data-stu-id="3c627-160">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c627-161">Jeśli wiersze zostaną wstawione do tabeli bazy danych zawierające automatyczne zwiększanie kolumny, takich jak kolumny tożsamości, zwracane przez wstawienie wartości kolumny tożsamości mogą nie pasuje do wartości w `DataSet`, powodując zwrócone wiersze, które mają być dołączane zamiast scalone.</span><span class="sxs-lookup"><span data-stu-id="3c627-161">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="3c627-162">Aby uzyskać więcej informacji, zobacz [pobierania tożsamości lub wartości automatycznie numerowane](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).</span><span class="sxs-lookup"><span data-stu-id="3c627-162">For more information, see [Retrieving Identity or Autonumber Values](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).</span></span>  
  
 <span data-ttu-id="3c627-163">Poniższy przykład kodu scala dwie `DataSet` obiektów ze schematami differents do jednej `DataSet` z połączonych schematów dwóch przychodzących `DataSet` obiektów.</span><span class="sxs-lookup"><span data-stu-id="3c627-163">The following code example merges two `DataSet` objects with differents schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>  
  
 [!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]  
  
 <span data-ttu-id="3c627-164">Poniższy przykładowy kod ma istniejące `DataSet` aktualizacje i przekazuje te aktualizacje `DataAdapter` do przetworzenia w źródle danych.</span><span class="sxs-lookup"><span data-stu-id="3c627-164">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="3c627-165">Wyniki są następnie scalane w oryginalnym `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="3c627-165">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="3c627-166">Po odrzuceniu zmian, które spowodowały błąd, są zatwierdzone z zmiany scalone `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="3c627-166">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="3c627-167">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="3c627-167">See Also</span></span>  
 [<span data-ttu-id="3c627-168">Elementy DataSet, DataTable i DataView</span><span class="sxs-lookup"><span data-stu-id="3c627-168">DataSets, DataTables, and DataViews</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/index.md)  
 [<span data-ttu-id="3c627-169">Stany wiersza i wersje wiersza</span><span class="sxs-lookup"><span data-stu-id="3c627-169">Row States and Row Versions</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)  
 [<span data-ttu-id="3c627-170">Elementy DataAdapter i DataReaders</span><span class="sxs-lookup"><span data-stu-id="3c627-170">DataAdapters and DataReaders</span></span>](../../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)  
 [<span data-ttu-id="3c627-171">Pobieranie i modyfikowanie danych ADO.NET</span><span class="sxs-lookup"><span data-stu-id="3c627-171">Retrieving and Modifying Data in ADO.NET</span></span>](../../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)  
 [<span data-ttu-id="3c627-172">Pobieranie tożsamości lub wartości automatycznych numerów</span><span class="sxs-lookup"><span data-stu-id="3c627-172">Retrieving Identity or Autonumber Values</span></span>](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)  
 [<span data-ttu-id="3c627-173">ADO.NET zarządzanego dostawcy i zestawu danych w Centrum deweloperów</span><span class="sxs-lookup"><span data-stu-id="3c627-173">ADO.NET Managed Providers and DataSet Developer Center</span></span>](http://go.microsoft.com/fwlink/?LinkId=217917)
