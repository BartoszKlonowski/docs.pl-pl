---
title: Translacja standardowego operatora zapytania
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a60c30fa-1e68-45fe-b984-f6abb9ede40e
ms.openlocfilehash: fb4910e48af58463c5c851173f8e3caf4594cc3a
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/08/2018
ms.locfileid: "44197475"
---
# <a name="standard-query-operator-translation"></a><span data-ttu-id="a4cbf-102">Translacja standardowego operatora zapytania</span><span class="sxs-lookup"><span data-stu-id="a4cbf-102">Standard Query Operator Translation</span></span>
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-103"> tłumaczy standardowych operatorów zapytań do polecenia SQL.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-103"> translates Standard Query Operators to SQL commands.</span></span> <span data-ttu-id="a4cbf-104">Procesor zapytań bazy danych określa semantyka wykonania tłumaczenia SQL.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-104">The query processor of the database determines the execution semantics of SQL translation.</span></span>  
  
 <span data-ttu-id="a4cbf-105">Standardowe operatory zapytań są zdefiniowane dla *sekwencje*.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-105">Standard Query Operators are defined against *sequences*.</span></span> <span data-ttu-id="a4cbf-106">Sekwencja jest *uporządkowane* i opiera się na tożsamości referencyjnej dla każdego elementu w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-106">A sequence is *ordered* and relies on reference identity for each element of the sequence.</span></span> <span data-ttu-id="a4cbf-107">Aby uzyskać więcej informacji, zobacz [standardowe operatory zapytań — Przegląd](https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-107">For more information, see [Standard Query Operators Overview](https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2).</span></span>  
  
 <span data-ttu-id="a4cbf-108">SQL dotyczy przede wszystkim *nieuporządkowane zestawy wartości*.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-108">SQL deals primarily with *unordered sets of values*.</span></span> <span data-ttu-id="a4cbf-109">Kolejność jest zazwyczaj wyraźnie określone, przetwarzanie końcowe operacji, która jest stosowana do końcowego wyniku zapytania, a nie do wyników pośrednich.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-109">Ordering is typically an explicitly stated, post-processing operation that is applied to the final result of a query rather than to intermediate results.</span></span> <span data-ttu-id="a4cbf-110">Tożsamość jest definiowany przez wartości.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-110">Identity is defined by values.</span></span> <span data-ttu-id="a4cbf-111">Z tego powodu zapytania SQL są zrozumiałe radzenia sobie z multisets (*zbiory*) zamiast *ustawia*.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-111">For this reason, SQL queries are understood to deal with multisets (*bags*) instead of *sets*.</span></span>  
  
 <span data-ttu-id="a4cbf-112">Następuje opisano różnice między standardowych operatorów zapytań i ich tłumaczenia SQL dla dostawcy programu SQL Server dla [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-112">The following paragraphs describe the differences between the Standard Query Operators and their SQL translation for the SQL Server provider for [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span>  
  
## <a name="operator-support"></a><span data-ttu-id="a4cbf-113">Operator pomocy technicznej</span><span class="sxs-lookup"><span data-stu-id="a4cbf-113">Operator Support</span></span>  
  
### <a name="concat"></a><span data-ttu-id="a4cbf-114">concat</span><span class="sxs-lookup"><span data-stu-id="a4cbf-114">Concat</span></span>  
 <span data-ttu-id="a4cbf-115"><xref:System.Linq.Enumerable.Concat%2A> Metoda jest zdefiniowana dla uporządkowane multisets, których kolejność odbiornik i kolejność argument są takie same.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-115">The <xref:System.Linq.Enumerable.Concat%2A> method is defined for ordered multisets where the order of the receiver and the order of the argument are the same.</span></span> <span data-ttu-id="a4cbf-116"><xref:System.Linq.Enumerable.Concat%2A> działa jako `UNION ALL` za pośrednictwem multisets, a następnie według kolejności wspólne.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-116"><xref:System.Linq.Enumerable.Concat%2A> works as `UNION ALL` over the multisets followed by the common order.</span></span>  
  
 <span data-ttu-id="a4cbf-117">Ostatnim krokiem jest kolejność w języku SQL, zanim wyniki są tworzone.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-117">The final step is ordering in SQL before results are produced.</span></span> <span data-ttu-id="a4cbf-118"><xref:System.Linq.Enumerable.Concat%2A> nie pozwala zachować kolejność argumentów.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-118"><xref:System.Linq.Enumerable.Concat%2A> does not preserve the order of its arguments.</span></span> <span data-ttu-id="a4cbf-119">W celu zapewnienia odpowiedniej kolejności, należy jawnie kolejność wyników <xref:System.Linq.Enumerable.Concat%2A>.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-119">To ensure appropriate ordering, you must explicitly order the results of <xref:System.Linq.Enumerable.Concat%2A>.</span></span>  
  
### <a name="intersect-except-union"></a><span data-ttu-id="a4cbf-120">INTERSECT, z wyjątkiem Unii</span><span class="sxs-lookup"><span data-stu-id="a4cbf-120">Intersect, Except, Union</span></span>  
 <span data-ttu-id="a4cbf-121"><xref:System.Linq.Enumerable.Intersect%2A> i <xref:System.Linq.Enumerable.Except%2A> metody są dobrze zdefiniowane tylko na zestawach.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-121">The <xref:System.Linq.Enumerable.Intersect%2A> and <xref:System.Linq.Enumerable.Except%2A> methods are well defined only on sets.</span></span> <span data-ttu-id="a4cbf-122">Semantyka dla multisets jest niezdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-122">The semantics for multisets is undefined.</span></span>  
  
 <span data-ttu-id="a4cbf-123"><xref:System.Linq.Enumerable.Union%2A> Metoda jest zdefiniowana dla multisets jako Nieuporządkowana łączenie multisets (skutecznie wynik klauzuli UNION ALL w języku SQL).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-123">The <xref:System.Linq.Enumerable.Union%2A> method is defined for multisets as the unordered concatenation of the multisets (effectively the result of the UNION ALL clause in SQL).</span></span>  
  
### <a name="take-skip"></a><span data-ttu-id="a4cbf-124">Take, Skip</span><span class="sxs-lookup"><span data-stu-id="a4cbf-124">Take, Skip</span></span>  
 <span data-ttu-id="a4cbf-125"><xref:System.Linq.Enumerable.Take%2A> i <xref:System.Linq.Enumerable.Skip%2A> metody są dobrze zdefiniowane wyłącznie w odniesieniu do *uporządkowane zestawy*.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-125"><xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> methods are well defined only against *ordered sets*.</span></span> <span data-ttu-id="a4cbf-126">Semantyka nieuporządkowane zestawy lub multisets są niezdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-126">The semantics for unordered sets or multisets are undefined.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a4cbf-127"><xref:System.Linq.Enumerable.Take%2A> i <xref:System.Linq.Enumerable.Skip%2A> mają pewne ograniczenia, gdy są one używane w kwerendach do programu SQL Server 2000.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-127"><xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against SQL Server 2000.</span></span> <span data-ttu-id="a4cbf-128">Aby uzyskać więcej informacji, zobacz wpis "Pomiń i Pobierz wyjątki w programie SQL Server 2000 do niego dostępu" w [Rozwiązywanie problemów](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-128">For more information, see the "Skip and Take Exceptions in SQL Server 2000" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).</span></span>  
  
 <span data-ttu-id="a4cbf-129">Ze względu na ograniczenia dotyczące kolejności w programie SQL [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] spróbuje przenieść Kolejność argumentów z tych metod do wyniku metody.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-129">Because of limitations on ordering in SQL, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] tries to move the ordering of the argument of these methods to the result of the method.</span></span> <span data-ttu-id="a4cbf-130">Na przykład, należy wziąć pod uwagę następujące [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] kwerendy:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-130">For example, consider the following [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] query:</span></span>  
  
 [!code-csharp[DLinqSQOTranslation#1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#1)]
 [!code-vb[DLinqSQOTranslation#1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#1)]  
  
 <span data-ttu-id="a4cbf-131">Wygenerowany SQL dla tego kodu przenosi, to porządkowanie-to-end, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-131">The generated SQL for this code moves the ordering to the end, as follows:</span></span>  
  
```  
SELECT TOP 1 [t0].[CustomerID], [t0].[CompanyName],  
FROM [Customers] AS [t0]  
WHERE (NOT (EXISTS(  
    SELECT NULL AS [EMPTY]  
    FROM (  
        SELECT TOP 1 [t1].[CustomerID]  
        FROM [Customers] AS [t1]  
        WHERE [t1].[City] = @p0  
        ORDER BY [t1].[CustomerID]  
        ) AS [t2]  
    WHERE [t0].[CustomerID] = [t2].[CustomerID]  
    ))) AND ([t0].[City] = @p1)  
ORDER BY [t0].[CustomerID]  
```  
  
 <span data-ttu-id="a4cbf-132">Staje się oczywiste, że wszystkie określonej kolejności, muszą być zgodne po <xref:System.Linq.Enumerable.Take%2A> i <xref:System.Linq.Enumerable.Skip%2A> są połączone.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-132">It becomes obvious that all the specified ordering must be consistent when <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> are chained together.</span></span> <span data-ttu-id="a4cbf-133">W przeciwnym wypadku wyniki są niezdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-133">Otherwise, the results are undefined.</span></span>  
  
 <span data-ttu-id="a4cbf-134">Zarówno <xref:System.Linq.Enumerable.Take%2A> i <xref:System.Linq.Enumerable.Skip%2A> są dobrze zdefiniowanych dla wartość nieujemną, stała argumentów całkowitych na podstawie specyfikacji standardowej kwerendy operatora.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-134">Both <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> are well-defined for non-negative, constant integral arguments based on the Standard Query Operator specification.</span></span>  
  
### <a name="operators-with-no-translation"></a><span data-ttu-id="a4cbf-135">Operatory bez translacji</span><span class="sxs-lookup"><span data-stu-id="a4cbf-135">Operators with No Translation</span></span>  
 <span data-ttu-id="a4cbf-136">Następujących metod nie są one tłumaczone przez [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-136">The following methods are not translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span> <span data-ttu-id="a4cbf-137">Najbardziej typową przyczyną jest różnica między multisets nieuporządkowane i sekwencji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-137">The most common reason is the difference between unordered multisets and sequences.</span></span>  
  
|<span data-ttu-id="a4cbf-138">Operatory</span><span class="sxs-lookup"><span data-stu-id="a4cbf-138">Operators</span></span>|<span data-ttu-id="a4cbf-139">Racjonalne uzasadnienie</span><span class="sxs-lookup"><span data-stu-id="a4cbf-139">Rationale</span></span>|  
|---------------|---------------|  
|<span data-ttu-id="a4cbf-140"><xref:System.Linq.Enumerable.TakeWhile%2A>, <xref:System.Linq.Enumerable.SkipWhile%2A></span><span class="sxs-lookup"><span data-stu-id="a4cbf-140"><xref:System.Linq.Enumerable.TakeWhile%2A>, <xref:System.Linq.Enumerable.SkipWhile%2A></span></span>|<span data-ttu-id="a4cbf-141">Zapytania SQL działają na multisets nie w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-141">SQL queries operate on multisets, not on sequences.</span></span> <span data-ttu-id="a4cbf-142">`ORDER BY` musi zostać ostatniej zastosowana do wyników.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-142">`ORDER BY` must be the last clause applied to the results.</span></span> <span data-ttu-id="a4cbf-143">Z tego powodu nie ma żadnych tłumaczeń ogólnego przeznaczenia dla tych dwóch metod.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-143">For this reason, there is no general-purpose translation for these two methods.</span></span>|  
|<xref:System.Linq.Enumerable.Reverse%2A>|<span data-ttu-id="a4cbf-144">Tłumaczenie tej metody jest możliwe, aby uporządkowany zestaw, ale nie jest obecnie tłumaczyć [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-144">Translation of this method is possible for an ordered set but is not currently translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span>|  
|<span data-ttu-id="a4cbf-145"><xref:System.Linq.Enumerable.Last%2A>, <xref:System.Linq.Enumerable.LastOrDefault%2A></span><span class="sxs-lookup"><span data-stu-id="a4cbf-145"><xref:System.Linq.Enumerable.Last%2A>, <xref:System.Linq.Enumerable.LastOrDefault%2A></span></span>|<span data-ttu-id="a4cbf-146">Tłumaczenie tych metod jest możliwe uporządkowany zestaw, ale nie jest obecnie tłumaczyć [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-146">Translation of these methods is possible for an ordered set but is not currently translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span>|  
|<span data-ttu-id="a4cbf-147"><xref:System.Linq.Enumerable.ElementAt%2A>, <xref:System.Linq.Enumerable.ElementAtOrDefault%2A></span><span class="sxs-lookup"><span data-stu-id="a4cbf-147"><xref:System.Linq.Enumerable.ElementAt%2A>, <xref:System.Linq.Enumerable.ElementAtOrDefault%2A></span></span>|<span data-ttu-id="a4cbf-148">Zapytania SQL działają na multisets na nie można indeksować sekwencji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-148">SQL queries operate on multisets, not on indexable sequences.</span></span>|  
|<span data-ttu-id="a4cbf-149"><xref:System.Linq.Enumerable.DefaultIfEmpty%2A> (przeciążenia za pomocą domyślnego argumentu)</span><span class="sxs-lookup"><span data-stu-id="a4cbf-149"><xref:System.Linq.Enumerable.DefaultIfEmpty%2A> (overload with default arg)</span></span>|<span data-ttu-id="a4cbf-150">Ogólnie rzecz biorąc wartość domyślna, nie można określić dla dowolnego spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-150">In general, a default value cannot be specified for an arbitrary tuple.</span></span> <span data-ttu-id="a4cbf-151">Wartości null dla krotek są możliwe w niektórych przypadkach za pomocą sprzężeń zewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-151">Null values for tuples are possible in some cases through outer joins.</span></span>|  
  
## <a name="expression-translation"></a><span data-ttu-id="a4cbf-152">Translacja wyrażeń</span><span class="sxs-lookup"><span data-stu-id="a4cbf-152">Expression Translation</span></span>  
  
### <a name="null-semantics"></a><span data-ttu-id="a4cbf-153">Semantyka wartości null</span><span class="sxs-lookup"><span data-stu-id="a4cbf-153">Null semantics</span></span>  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-154"> nie wymusza semantykę porównania wartości null w języku SQL.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-154"> does not impose null comparison semantics on SQL.</span></span> <span data-ttu-id="a4cbf-155">Operatory porównania składniowo są tłumaczone na ich odpowiedniki SQL.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-155">Comparison operators are syntactically translated to their SQL equivalents.</span></span> <span data-ttu-id="a4cbf-156">Z tego powodu semantykę odzwierciedlają semantyki SQL, które są definiowane przez ustawienia serwera lub połączenia.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-156">For this reason, the semantics reflect SQL semantics that are defined by server or connection settings.</span></span> <span data-ttu-id="a4cbf-157">Na przykład dwie wartości null są uznawane za nierówne w obszarze domyślne ustawienia programu SQL Server, ale możesz zmienić ustawienia, aby zmienić semantyki.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-157">For example, two null values are considered unequal under default SQL Server settings, but you can change the settings to change the semantics.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-158"> nie należy traktować ustawienia serwera, gdy przekłada zapytania.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-158"> does not consider server settings when it translates queries.</span></span>  
  
 <span data-ttu-id="a4cbf-159">Porównanie z literałem o wartości null jest tłumaczona na odpowiednią wersję programu SQL (`is null` lub `is not null`).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-159">A comparison with the literal null is translated to the appropriate SQL version (`is null` or `is not null`).</span></span>  
  
 <span data-ttu-id="a4cbf-160">Wartość `null` w sortowaniu jest zdefiniowany przez program SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-160">The value of `null` in collation is defined by SQL Server.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-161"> nie powoduje zmiany sortowania.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-161"> does not change the collation.</span></span>  
  
### <a name="aggregates"></a><span data-ttu-id="a4cbf-162">Agregaty</span><span class="sxs-lookup"><span data-stu-id="a4cbf-162">Aggregates</span></span>  
 <span data-ttu-id="a4cbf-163">Metoda agregacji standardowej kwerendy operatora <xref:System.Linq.Enumerable.Sum%2A> osiągnie wartość zero dla pustej sekwencji lub sekwencję która zawiera tylko wartości null.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-163">The Standard Query Operator aggregate method <xref:System.Linq.Enumerable.Sum%2A> evaluates to zero for an empty sequence or for a sequence that contains only nulls.</span></span> <span data-ttu-id="a4cbf-164">W [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], semantyki programu SQL Server są pozostawione bez zmian, i <xref:System.Linq.Enumerable.Sum%2A> daje w wyniku `null` zamiast zero sekwencję która zawiera tylko wartości null lub pustą sekwencją.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-164">In [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], the semantics of SQL are left unchanged, and <xref:System.Linq.Enumerable.Sum%2A> evaluates to `null` instead of zero for an empty sequence or for a sequence that contains only nulls.</span></span>  
  
 <span data-ttu-id="a4cbf-165">SQL na wyniki pośrednie ograniczenia wartości zagregowanych umieszczonych w [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-165">SQL limitations on intermediate results apply to aggregates in [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span> <span data-ttu-id="a4cbf-166"><xref:System.Linq.Enumerable.Sum%2A> Z 32-bitowej liczby całkowitej ilości nie jest kolumną obliczaną za pomocą 64-bitowych wyników.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-166">The <xref:System.Linq.Enumerable.Sum%2A> of 32-bit integer quantities is not computed by using 64-bit results.</span></span> <span data-ttu-id="a4cbf-167">Przepełnienie mogą wystąpić w przypadku [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] tłumaczenia <xref:System.Linq.Enumerable.Sum%2A>nawet wtedy, gdy implementacja standardowej kwerendy operatora nie powoduje przepełnienie w odpowiedniej sekwencji w pamięci.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-167">Overflow might occur for a [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translation of <xref:System.Linq.Enumerable.Sum%2A>, even if the Standard Query Operator implementation does not cause an overflow for the corresponding in-memory sequence.</span></span>  
  
 <span data-ttu-id="a4cbf-168">Podobnie [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] tłumaczenia <xref:System.Linq.Enumerable.Average%2A> liczby całkowitej wartości jest obliczana jako `integer`, nie jako `double`.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-168">Likewise, the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translation of <xref:System.Linq.Enumerable.Average%2A> of integer values is computed as an `integer`, not as a `double`.</span></span>  
  
### <a name="entity-arguments"></a><span data-ttu-id="a4cbf-169">Argumenty jednostki</span><span class="sxs-lookup"><span data-stu-id="a4cbf-169">Entity Arguments</span></span>  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-170"> Włącza typów jednostek, które zostaną użyte w <xref:System.Linq.Enumerable.GroupBy%2A> i <xref:System.Linq.Enumerable.OrderBy%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-170"> enables entity types to be used in the <xref:System.Linq.Enumerable.GroupBy%2A> and <xref:System.Linq.Enumerable.OrderBy%2A> methods.</span></span> <span data-ttu-id="a4cbf-171">W tłumaczeniu tych operatorów Użyj argumentu typu jest uważana za równoważne do określania wszystkie elementy członkowskie tego typu.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-171">In the translation of these operators, the use of an argument of a type is considered to be the equivalent to specifying all members of that type.</span></span> <span data-ttu-id="a4cbf-172">Na przykład poniższy kod jest równoważne:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-172">For example, the following code is equivalent:</span></span>  
  
 [!code-csharp[DLinqSQOTranslation#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#2)]
 [!code-vb[DLinqSQOTranslation#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#2)]  
  
### <a name="equatable--comparable-arguments"></a><span data-ttu-id="a4cbf-173">Argumenty equatable / porównywalnych</span><span class="sxs-lookup"><span data-stu-id="a4cbf-173">Equatable / Comparable Arguments</span></span>  
 <span data-ttu-id="a4cbf-174">Równość argumentów jest wymagany w celu wykonania poniższych metod:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-174">Equality of arguments is required in the implementation of the following methods:</span></span>  
  
 <xref:System.Linq.Enumerable.Contains%2A>  
  
 <xref:System.Linq.Enumerable.Skip%2A>  
  
 <xref:System.Linq.Enumerable.Union%2A>  
  
 <xref:System.Linq.Enumerable.Intersect%2A>  
  
 <xref:System.Linq.Enumerable.Except%2A>  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-175"> obsługuje równości i porównanie \*prostego* argumentów, ale nie dla argumentów, które są lub zawierać sekwencje.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-175"> supports equality and comparison for \*flat* arguments, but not for arguments that are or contain sequences.</span></span> <span data-ttu-id="a4cbf-176">Płaski argument jest typu, które mogą być mapowane do wiersza SQL.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-176">A flat argument is a type that can be mapped to a SQL row.</span></span> <span data-ttu-id="a4cbf-177">Rzutowanie typów jednostek, które mogą być statycznie uznane za nie zawierać sekwencję jest traktowany jako stała argumentu.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-177">A projection of one or more entity types that can be statically determined not to contain a sequence is considered a flat argument.</span></span>  
  
 <span data-ttu-id="a4cbf-178">Poniżej przedstawiono przykłady prostego argumenty:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-178">Following are examples of flat arguments:</span></span>  
  
 [!code-csharp[DLinqSQOTranslation#3](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#3)]
 [!code-vb[DLinqSQOTranslation#3](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#3)]  
  
 <span data-ttu-id="a4cbf-179">Poniżej przedstawiono przykłady argumentów płaskiej (hierarchiczne).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-179">The following are examples of non-flat (hierarchical) arguments.</span></span>  
  
 [!code-csharp[DLinqSQOTranslation#4](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#4)]
 [!code-vb[DLinqSQOTranslation#4](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#4)]  
  
### <a name="visual-basic-function-translation"></a><span data-ttu-id="a4cbf-180">Tłumaczenie funkcji języka Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a4cbf-180">Visual Basic Function Translation</span></span>  
 <span data-ttu-id="a4cbf-181">Następujące funkcje pomocnika, które są używane przez kompilator Visual Basic są tłumaczone na odpowiednie operatory SQL i funkcje:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-181">The following helper functions that are used by the Visual Basic compiler are translated to corresponding SQL operators and functions:</span></span>  
  
 `CompareString`  
  
 `DateTime.Compare`  
  
 `Decimal.Compare`  
  
 `IIf (in Microsoft.VisualBasic.Interaction)`  
  
 <span data-ttu-id="a4cbf-182">Metody konwersji:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-182">Conversion methods:</span></span>  
  
|||||  
|-|-|-|-|  
|<span data-ttu-id="a4cbf-183">ToBoolean</span><span class="sxs-lookup"><span data-stu-id="a4cbf-183">ToBoolean</span></span>|<span data-ttu-id="a4cbf-184">Tosbyte —</span><span class="sxs-lookup"><span data-stu-id="a4cbf-184">ToSByte</span></span>|<span data-ttu-id="a4cbf-185">Tobyte —</span><span class="sxs-lookup"><span data-stu-id="a4cbf-185">ToByte</span></span>|<span data-ttu-id="a4cbf-186">ToChar</span><span class="sxs-lookup"><span data-stu-id="a4cbf-186">ToChar</span></span>|  
|<span data-ttu-id="a4cbf-187">ToCharArrayRankOne</span><span class="sxs-lookup"><span data-stu-id="a4cbf-187">ToCharArrayRankOne</span></span>|<span data-ttu-id="a4cbf-188">ToDate</span><span class="sxs-lookup"><span data-stu-id="a4cbf-188">ToDate</span></span>|<span data-ttu-id="a4cbf-189">Todecimal —</span><span class="sxs-lookup"><span data-stu-id="a4cbf-189">ToDecimal</span></span>|<span data-ttu-id="a4cbf-190">Todouble —</span><span class="sxs-lookup"><span data-stu-id="a4cbf-190">ToDouble</span></span>|  
|<span data-ttu-id="a4cbf-191">ToInteger</span><span class="sxs-lookup"><span data-stu-id="a4cbf-191">ToInteger</span></span>|<span data-ttu-id="a4cbf-192">ToUInteger</span><span class="sxs-lookup"><span data-stu-id="a4cbf-192">ToUInteger</span></span>|<span data-ttu-id="a4cbf-193">ToLong</span><span class="sxs-lookup"><span data-stu-id="a4cbf-193">ToLong</span></span>|<span data-ttu-id="a4cbf-194">ToULong</span><span class="sxs-lookup"><span data-stu-id="a4cbf-194">ToULong</span></span>|  
|<span data-ttu-id="a4cbf-195">ToShort</span><span class="sxs-lookup"><span data-stu-id="a4cbf-195">ToShort</span></span>|<span data-ttu-id="a4cbf-196">ToUShort</span><span class="sxs-lookup"><span data-stu-id="a4cbf-196">ToUShort</span></span>|<span data-ttu-id="a4cbf-197">Tosingle —</span><span class="sxs-lookup"><span data-stu-id="a4cbf-197">ToSingle</span></span>|<span data-ttu-id="a4cbf-198">ToString</span><span class="sxs-lookup"><span data-stu-id="a4cbf-198">ToString</span></span>|  
  
## <a name="inheritance-support"></a><span data-ttu-id="a4cbf-199">Obsługa dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="a4cbf-199">Inheritance Support</span></span>  
  
### <a name="inheritance-mapping-restrictions"></a><span data-ttu-id="a4cbf-200">Ograniczenia dotyczące mapowania dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="a4cbf-200">Inheritance Mapping Restrictions</span></span>  
 <span data-ttu-id="a4cbf-201">Aby uzyskać więcej informacji, zobacz [jak: hierarchii dziedziczenia mapy](../../../../../../docs/framework/data/adonet/sql/linq/how-to-map-inheritance-hierarchies.md).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-201">For more information, see [How to: Map Inheritance Hierarchies](../../../../../../docs/framework/data/adonet/sql/linq/how-to-map-inheritance-hierarchies.md).</span></span>  
  
### <a name="inheritance-in-queries"></a><span data-ttu-id="a4cbf-202">Dziedziczenie w zapytaniach</span><span class="sxs-lookup"><span data-stu-id="a4cbf-202">Inheritance in Queries</span></span>  
 <span data-ttu-id="a4cbf-203">C# rzutowania są obsługiwane tylko w projekcji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-203">C# casts are supported only in projection.</span></span> <span data-ttu-id="a4cbf-204">Wzory, które są używane w innym miejscu, nie są przekształcane i są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-204">Casts that are used elsewhere are not translated and are ignored.</span></span> <span data-ttu-id="a4cbf-205">Oprócz SQL nazwy funkcji, SQL tak naprawdę tylko wykonuje odpowiednik środowisko uruchomieniowe języka wspólnego (CLR) <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-205">Aside from SQL function names, SQL really only performs the equivalent of the common language runtime (CLR) <xref:System.Convert>.</span></span> <span data-ttu-id="a4cbf-206">Oznacza to SQL, można zmienić wartości z jednego typu na inny.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-206">That is, SQL can change the value of one type to another.</span></span> <span data-ttu-id="a4cbf-207">Nie ma odpowiednika rzutowania, ponieważ nie istnieje koncepcji reinterpretacja tej samej usługi bits, jak te innego typu CLR.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-207">There is no equivalent of CLR cast because there is no concept of reinterpreting the same bits as those of another type.</span></span> <span data-ttu-id="a4cbf-208">Właśnie dlatego rzutowania języka C# działa tylko lokalnie.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-208">That is why a C# cast works only locally.</span></span> <span data-ttu-id="a4cbf-209">Nie jest zdalny.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-209">It is not remoted.</span></span>  
  
 <span data-ttu-id="a4cbf-210">Operatory, `is` i `as`i `GetType` metody nie są ograniczone do `Select` operatora.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-210">The operators, `is` and `as`, and the `GetType` method are not restricted to the `Select` operator.</span></span> <span data-ttu-id="a4cbf-211">Ich zastosowania w innych operatorów zapytania również.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-211">They can be used in other query operators also.</span></span>  
  
## <a name="sql-server-2008-support"></a><span data-ttu-id="a4cbf-212">Obsługa programu SQL Server 2008</span><span class="sxs-lookup"><span data-stu-id="a4cbf-212">SQL Server 2008 Support</span></span>  
 <span data-ttu-id="a4cbf-213">Począwszy od .NET Framework 3.5 SP1, LINQ to SQL obsługuje mapowanie na nową datę i czas typy wprowadzone w programie SQL Server 2008.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-213">Starting with the .NET Framework 3.5 SP1, LINQ to SQL supports mapping to new date and time types introduced with SQL Server 2008.</span></span> <span data-ttu-id="a4cbf-214">Istnieją jednak pewne ograniczenia dotyczące LINQ to SQL operatorów zapytań, które można użyć podczas pracy w odniesieniu do wartości mapowane na te nowe typy.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-214">But, there are some limitations to the LINQ to SQL query operators that you can use when operating against values mapped to these new types.</span></span>  
  
### <a name="unsupported-query-operators"></a><span data-ttu-id="a4cbf-215">Nieobsługiwane zapytanie operatorów</span><span class="sxs-lookup"><span data-stu-id="a4cbf-215">Unsupported Query Operators</span></span>  
 <span data-ttu-id="a4cbf-216">Następujące operatory zapytań nie są obsługiwane na wartościach mapowane na nowe typy daty i godziny programu SQL Server: `DATETIME2`, `DATE`, `TIME`, i `DATETIMEOFFSET`.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-216">The following query operators are not supported on values mapped to the new SQL Server date and time types: `DATETIME2`, `DATE`, `TIME`, and `DATETIMEOFFSET`.</span></span>  
  
-   `Aggregate`  
  
-   `Average`  
  
-   `LastOrDefault`  
  
-   `OfType`  
  
-   `Sum`  
  
 <span data-ttu-id="a4cbf-217">Aby uzyskać więcej informacji na temat mapowania do tych typów daty i godziny programu SQL Server, zobacz [mapowanie typu SQL CLR](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mapping.md).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-217">For more information about mapping to these SQL Server date and time types, see [SQL-CLR Type Mapping](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mapping.md).</span></span>  
  
## <a name="sql-server-2005-support"></a><span data-ttu-id="a4cbf-218">Obsługa programu SQL Server 2005</span><span class="sxs-lookup"><span data-stu-id="a4cbf-218">SQL Server 2005 Support</span></span>  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-219"> nie obsługuje następujących funkcji programu SQL Server 2005:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-219"> does not support the following SQL Server 2005 features:</span></span>  
  
-   <span data-ttu-id="a4cbf-220">Procedury składowane napisane dla środowiska CLR programu SQL.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-220">Stored procedures written for SQL CLR.</span></span>  
  
-   <span data-ttu-id="a4cbf-221">Typ zdefiniowany przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-221">User-defined type.</span></span>  
  
-   <span data-ttu-id="a4cbf-222">Funkcje zapytania XML.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-222">XML query features.</span></span>  
  
## <a name="sql-server-2000-support"></a><span data-ttu-id="a4cbf-223">Obsługa programu SQL Server 2000</span><span class="sxs-lookup"><span data-stu-id="a4cbf-223">SQL Server 2000 Support</span></span>  
 <span data-ttu-id="a4cbf-224">Następujące [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] ograniczenia (w porównaniu do [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)]) wpływają na [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] pomocy technicznej.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-224">The following [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] limitations (compared to [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)]) affect [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] support.</span></span>  
  
### <a name="cross-apply-and-outer-apply-operators"></a><span data-ttu-id="a4cbf-225">Cross Apply i zewnętrznych stosowanie operatorów</span><span class="sxs-lookup"><span data-stu-id="a4cbf-225">Cross Apply and Outer Apply Operators</span></span>  
 <span data-ttu-id="a4cbf-226">Te operatory nie są dostępne w [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-226">These operators are not available in [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)].</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="a4cbf-227"> próbuje szereg modyfikacji oprogramowania, aby zastąpić odpowiednie sprzężenia.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-227"> tries a series of rewrites to replace them with appropriate joins.</span></span>  
  
 <span data-ttu-id="a4cbf-228">`Cross Apply` i `Outer Apply` są generowane dla tego relacji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-228">`Cross Apply` and `Outer Apply` are generated for relationship navigations.</span></span> <span data-ttu-id="a4cbf-229">Zestaw zapytań, dla których są możliwe takich modyfikacji oprogramowania nie jest dobrze zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-229">The set of queries for which such rewrites are possible is not well defined.</span></span> <span data-ttu-id="a4cbf-230">Z tego powodu minimalny zestaw zapytań, które jest obsługiwane w przypadku [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] to zestaw, który nie wymaga nawigacji relacji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-230">For this reason, the minimal set of queries that is supported for [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] is the set that does not involve relationship navigation.</span></span>  
  
### <a name="text--ntext"></a><span data-ttu-id="a4cbf-231">Text / ntext</span><span class="sxs-lookup"><span data-stu-id="a4cbf-231">text / ntext</span></span>  
 <span data-ttu-id="a4cbf-232">Typy danych `text`  /  `ntext` nie można używać w niektórych operacji zapytań dotyczących `varchar(max)`  /  `nvarchar(max)`, które są obsługiwane przez [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-232">Data types `text` / `ntext` cannot be used in certain query operations against `varchar(max)` / `nvarchar(max)`, which are supported by [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)].</span></span>  
  
 <span data-ttu-id="a4cbf-233">Rozwiązanie jest dostępne dla tego ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-233">No resolution is available for this limitation.</span></span> <span data-ttu-id="a4cbf-234">Ściślej mówiąc, nie można użyć `Distinct()` na dowolny wynik, który zawiera elementy członkowskie, które są mapowane na `text` lub `ntext` kolumn.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-234">Specifically, you cannot use `Distinct()` on any result that contains members that are mapped to `text` or `ntext` columns.</span></span>  
  
### <a name="behavior-triggered-by-nested-queries"></a><span data-ttu-id="a4cbf-235">Zachowanie wyzwolone przez zapytań zagnieżdżonej</span><span class="sxs-lookup"><span data-stu-id="a4cbf-235">Behavior Triggered by Nested Queries</span></span>  
 [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]<span data-ttu-id="a4cbf-236"> (za pośrednictwem SP4) integratorów modeli zawiera specyfikę, które są uruchamiane w zapytań zagnieżdżonej.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-236"> (through SP4) binder has some idiosyncrasies that are triggered by nested queries.</span></span> <span data-ttu-id="a4cbf-237">Zestaw zapytań SQL, który wyzwala te idiosyncrasies nie jest dobrze zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-237">The set of SQL queries that triggers these idiosyncrasies is not well defined.</span></span> <span data-ttu-id="a4cbf-238">Z tego powodu nie można zdefiniować zestaw [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] zapytań, które mogłyby spowodować wyjątków programu SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-238">For this reason, you cannot define the set of [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] queries that might cause SQL Server exceptions.</span></span>  
  
### <a name="skip-and-take-operators"></a><span data-ttu-id="a4cbf-239">Pomiń i Pobierz operatorów</span><span class="sxs-lookup"><span data-stu-id="a4cbf-239">Skip and Take Operators</span></span>  
 <span data-ttu-id="a4cbf-240"><xref:System.Linq.Enumerable.Take%2A> i <xref:System.Linq.Enumerable.Skip%2A> mają pewne ograniczenia, gdy są one używane w zapytaniach względem [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a4cbf-240"><xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)].</span></span> <span data-ttu-id="a4cbf-241">Aby uzyskać więcej informacji, zobacz wpis "Pomiń i Pobierz wyjątki w programie SQL Server 2000 do niego dostępu" w [Rozwiązywanie problemów](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).</span><span class="sxs-lookup"><span data-stu-id="a4cbf-241">For more information, see the "Skip and Take Exceptions in SQL Server 2000" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).</span></span>  
  
## <a name="object-materialization"></a><span data-ttu-id="a4cbf-242">Materializacja obiektu</span><span class="sxs-lookup"><span data-stu-id="a4cbf-242">Object Materialization</span></span>  
 <span data-ttu-id="a4cbf-243">Materializacja tworzy obiekty CLR z wierszy zwracanych przez co najmniej jeden zapytania SQL.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-243">Materialization creates CLR objects from rows that are returned by one or more SQL queries.</span></span>  
  
-   <span data-ttu-id="a4cbf-244">Następujące wywołania są *wykonywany lokalnie,* jako część materializacja:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-244">The following calls are *executed locally* as a part of materialization:</span></span>  
  
    -   <span data-ttu-id="a4cbf-245">Konstruktorów</span><span class="sxs-lookup"><span data-stu-id="a4cbf-245">Constructors</span></span>  
  
    -   <span data-ttu-id="a4cbf-246">`ToString` metody w projekcji</span><span class="sxs-lookup"><span data-stu-id="a4cbf-246">`ToString` methods in projections</span></span>  
  
    -   <span data-ttu-id="a4cbf-247">Rzutowania typów w projekcji</span><span class="sxs-lookup"><span data-stu-id="a4cbf-247">Type casts in projections</span></span>  
  
-   <span data-ttu-id="a4cbf-248">Metody, które należy wykonać <xref:System.Linq.Enumerable.AsEnumerable%2A> metoda są *wykonywany lokalnie,*.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-248">Methods that follow the <xref:System.Linq.Enumerable.AsEnumerable%2A> method are *executed locally*.</span></span> <span data-ttu-id="a4cbf-249">Ta metoda nie powoduje natychmiastowe wykonanie.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-249">This method does not cause immediate execution.</span></span>  
  
-   <span data-ttu-id="a4cbf-250">Możesz użyć `struct` jako zwracany typ wyniku zapytania lub elementem członkowskim typu wyniku.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-250">You can use a `struct` as the return type of a query result or as a member of the result type.</span></span> <span data-ttu-id="a4cbf-251">Jednostki są wymagane do klasy.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-251">Entities are required to be classes.</span></span> <span data-ttu-id="a4cbf-252">Typy anonimowe są zmaterializowanego jako wystąpienia klasy, ale nazwanej struktury (inne niż jednostek) mogą być używane w projekcji.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-252">Anonymous types are materialized as class instances, but named structs (non-entities) can be used in projection.</span></span>  
  
-   <span data-ttu-id="a4cbf-253">Członek typu zwracanego wyniku zapytania mogą być typu <xref:System.Linq.IQueryable%601>.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-253">A member of the return type of a query result can be of type <xref:System.Linq.IQueryable%601>.</span></span> <span data-ttu-id="a4cbf-254">Jest on zmaterializowany jako kolekcja lokalna.</span><span class="sxs-lookup"><span data-stu-id="a4cbf-254">It is materialized as a local collection.</span></span>  
  
-   <span data-ttu-id="a4cbf-255">Następujące metody powodują *natychmiastowego materializacja* sekwencji, które metody są stosowane do:</span><span class="sxs-lookup"><span data-stu-id="a4cbf-255">The following methods cause the *immediate materialization* of the sequence that the methods are applied to:</span></span>  
  
    -   <xref:System.Linq.Enumerable.ToList%2A>  
  
    -   <xref:System.Linq.Enumerable.ToDictionary%2A>  
  
    -   <xref:System.Linq.Enumerable.ToArray%2A>  
  
## <a name="see-also"></a><span data-ttu-id="a4cbf-256">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="a4cbf-256">See Also</span></span>  
 [<span data-ttu-id="a4cbf-257">Dokumentacja</span><span class="sxs-lookup"><span data-stu-id="a4cbf-257">Reference</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/reference.md)  
 [<span data-ttu-id="a4cbf-258">Zwracanie lub pomijanie elementów w sekwencji</span><span class="sxs-lookup"><span data-stu-id="a4cbf-258">Return Or Skip Elements in a Sequence</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/return-or-skip-elements-in-a-sequence.md)  
 [<span data-ttu-id="a4cbf-259">Łączenie dwóch sekwencji</span><span class="sxs-lookup"><span data-stu-id="a4cbf-259">Concatenate Two Sequences</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/concatenate-two-sequences.md)  
 [<span data-ttu-id="a4cbf-260">Zwracanie zestawu różnic między dwoma sekwencjami</span><span class="sxs-lookup"><span data-stu-id="a4cbf-260">Return the Set Difference Between Two Sequences</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-difference-between-two-sequences.md)  
 [<span data-ttu-id="a4cbf-261">Zwracanie zestawu części wspólnych dwóch sekwencji</span><span class="sxs-lookup"><span data-stu-id="a4cbf-261">Return the Set Intersection of Two Sequences</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-intersection-of-two-sequences.md)  
 [<span data-ttu-id="a4cbf-262">Zwracanie sumy zbiorów dwóch sekwencji</span><span class="sxs-lookup"><span data-stu-id="a4cbf-262">Return the Set Union of Two Sequences</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-union-of-two-sequences.md)
