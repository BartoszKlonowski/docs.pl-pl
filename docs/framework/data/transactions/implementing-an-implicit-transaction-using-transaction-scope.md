---
title: Implementowanie transakcji niejawnej przy użyciu zakresu transakcji
description: Zaimplementuj niejawną transakcję przy użyciu klasy TransactionScope w programie .NET. Ta klasa umożliwia oznaczenie bloku kodu jako udziału w transakcji.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: ff2fe64156d5d72773549d78b2e29631905cbb10
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186864"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a><span data-ttu-id="aaf26-104">Implementowanie transakcji niejawnej przy użyciu zakresu transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-104">Implementing an Implicit Transaction using Transaction Scope</span></span>

<span data-ttu-id="aaf26-105"><xref:System.Transactions.TransactionScope>Klasa zapewnia prosty sposób oznaczania bloku kodu, który uczestniczy w transakcji, bez konieczności korzystania z samej transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-105">The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.</span></span> <span data-ttu-id="aaf26-106">Zakres transakcji można wybrać i automatycznie zarządzać otoczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-106">A transaction scope can select and manage the ambient transaction automatically.</span></span> <span data-ttu-id="aaf26-107">Ze względu na łatwość użycia i wydajność zaleca się użycie <xref:System.Transactions.TransactionScope> klasy podczas tworzenia aplikacji transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-107">Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.</span></span>  
  
 <span data-ttu-id="aaf26-108">Ponadto nie trzeba jawnie zarejestrować zasobów w ramach transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-108">In addition, you do not need to enlist resources explicitly with the transaction.</span></span> <span data-ttu-id="aaf26-109">Wszelkie <xref:System.Transactions> Menedżera zasobów (takich jak SQL Server 2005) można wykryć istnienie otoczenia transakcji utworzone przez zakres i automatycznie zarejestrować.</span><span class="sxs-lookup"><span data-stu-id="aaf26-109">Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.</span></span>  
  
## <a name="creating-a-transaction-scope"></a><span data-ttu-id="aaf26-110">Tworzenie zakresu transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-110">Creating a transaction scope</span></span>  

 <span data-ttu-id="aaf26-111">Poniższy przykład pokazuje proste użycie <xref:System.Transactions.TransactionScope> klasy.</span><span class="sxs-lookup"><span data-stu-id="aaf26-111">The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.</span></span>  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 <span data-ttu-id="aaf26-112">Zakres transakcji jest uruchamiany po utworzeniu nowego <xref:System.Transactions.TransactionScope> obiektu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-112">The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.</span></span>  <span data-ttu-id="aaf26-113">Jak pokazano w przykładzie kodu, zaleca się utworzenie zakresów z `using` instrukcją.</span><span class="sxs-lookup"><span data-stu-id="aaf26-113">As illustrated in the code sample, it is recommended that you create scopes with a `using` statement.</span></span> <span data-ttu-id="aaf26-114">`using`Instrukcja jest dostępna zarówno w języku C#, jak i w Visual Basic i działa jak `try` blok..., `finally` Aby upewnić się, że zakres jest prawidłowo usunięty.</span><span class="sxs-lookup"><span data-stu-id="aaf26-114">The `using` statement is available both in C# and in Visual Basic, and works like a `try`...`finally` block to ensure that the scope is disposed of properly.</span></span>  
  
 <span data-ttu-id="aaf26-115">Podczas tworzenia instancji <xref:System.Transactions.TransactionScope>, Menedżer transakcji określa, która transakcja wziąć udział w.</span><span class="sxs-lookup"><span data-stu-id="aaf26-115">When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in.</span></span> <span data-ttu-id="aaf26-116">Po określeniu zakresu zawsze uczestniczy w danej transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-116">Once determined, the scope always participates in that transaction.</span></span> <span data-ttu-id="aaf26-117">Decyzja opiera się na dwa czynniki: Określa, czy transakcja otoczenia jest obecny i ma wartość `TransactionScopeOption` parametr w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="aaf26-117">The decision is based on two factors: whether an ambient transaction is present and the value of the `TransactionScopeOption` parameter in the constructor.</span></span> <span data-ttu-id="aaf26-118">Transakcja otoczenia jest transakcji, w którym wykonuje kodu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-118">The ambient transaction is the transaction within which your code executes.</span></span> <span data-ttu-id="aaf26-119">Odwołanie do transakcji otoczenia można uzyskać przez wywołanie metody statyczne klasy <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> właściwości <xref:System.Transactions.Transaction> klasy.</span><span class="sxs-lookup"><span data-stu-id="aaf26-119">You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class.</span></span> <span data-ttu-id="aaf26-120">Więcej informacji na temat sposobu użycia tego parametru znajduje się w sekcji [Zarządzanie przepływem transakcji przy użyciu usługi TransactionScopeOption](#ManageTxFlow) w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="aaf26-120">For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.</span></span>  
  
## <a name="completing-a-transaction-scope"></a><span data-ttu-id="aaf26-121">Wykonywanie zakresu transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-121">Completing a transaction scope</span></span>  

 <span data-ttu-id="aaf26-122">Gdy aplikacja ukończy wszystkie zadania, które chce wykonać w transakcji, należy wywołać <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> metodę tylko raz, aby poinformować Menedżera transakcji, że jest on akceptowalny do zatwierdzenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-122">When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> method only once to inform the transaction manager that it is acceptable to commit the transaction.</span></span> <span data-ttu-id="aaf26-123">Dobrym sposobem jest umieszczenie wywołania <xref:System.Transactions.TransactionScope.Complete%2A> jako ostatniej instrukcji w `using` bloku.</span><span class="sxs-lookup"><span data-stu-id="aaf26-123">It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the `using` block.</span></span>  
  
 <span data-ttu-id="aaf26-124">Wywołanie tej metody przerywa transakcję, ponieważ Menedżer transakcji interpretuje ją jako błąd systemu lub równoważy wyjątek zgłoszony w zakresie transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-124">Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.</span></span> <span data-ttu-id="aaf26-125">Jednak wywołanie tej metody nie gwarantuje, że transakcji będzie zatwierdzone.</span><span class="sxs-lookup"><span data-stu-id="aaf26-125">However, calling this method does not guarantee that the transaction wil be committed.</span></span> <span data-ttu-id="aaf26-126">Jest tylko sposób informowania menedżera transakcji Twój status.</span><span class="sxs-lookup"><span data-stu-id="aaf26-126">It is merely a way of informing the transaction manager of your status.</span></span> <span data-ttu-id="aaf26-127">Po wywołaniu <xref:System.Transactions.TransactionScope.Complete%2A> metody jest już dostępne otoczenia transakcji przy użyciu <xref:System.Transactions.Transaction.Current%2A> właściwości i próby podjęły spowodują wyjątek.</span><span class="sxs-lookup"><span data-stu-id="aaf26-127">After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.</span></span>  
  
 <span data-ttu-id="aaf26-128">Jeśli <xref:System.Transactions.TransactionScope> obiekt utworzył transakcję początkowo, rzeczywista ilość pracy zatwierdzania transakcji przez Menedżera transakcji następuje po ostatnim wierszu kodu w `using` bloku.</span><span class="sxs-lookup"><span data-stu-id="aaf26-128">If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the `using` block.</span></span> <span data-ttu-id="aaf26-129">Jeśli nie utworzył transakcji, zatwierdzanie występuje zawsze, gdy <xref:System.Transactions.CommittableTransaction.Commit%2A> jest wywoływana przez właściciela <xref:System.Transactions.CommittableTransaction> obiektu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-129">If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object.</span></span> <span data-ttu-id="aaf26-130">W tym momencie Menedżer transakcji wywołuje menedżerów zasobów i informuje je o zatwierdzeniu lub wycofaniu w zależności od tego, czy <xref:System.Transactions.TransactionScope.Complete%2A> Metoda została wywołana dla <xref:System.Transactions.TransactionScope> obiektu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-130">At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.</span></span>  
  
 <span data-ttu-id="aaf26-131">`using`Instrukcja zapewnia, że <xref:System.Transactions.TransactionScope.Dispose%2A> Metoda <xref:System.Transactions.TransactionScope> obiektu jest wywoływana, nawet jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="aaf26-131">The `using` statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs.</span></span> <span data-ttu-id="aaf26-132"><xref:System.Transactions.TransactionScope.Dispose%2A> Metody oznacza koniec zakresu transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-132">The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope.</span></span> <span data-ttu-id="aaf26-133">Wyjątki, które mogą występować po wywołaniu tej metody nie może mieć wpływ na transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-133">Exceptions that occur after calling this method may not affect the transaction.</span></span> <span data-ttu-id="aaf26-134">Ta metoda również przywraca otoczenia transakcji jej poprzedniego stanu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-134">This method also restores the ambient transaction to it previous state.</span></span>  
  
 <span data-ttu-id="aaf26-135">Element <xref:System.Transactions.TransactionAbortedException> jest generowany, jeśli zakres tworzy transakcji, a transakcja została przerwana.</span><span class="sxs-lookup"><span data-stu-id="aaf26-135">A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted.</span></span> <span data-ttu-id="aaf26-136">Element <xref:System.Transactions.TransactionInDoubtException> jest generowany, gdy Menedżer transakcji nie może podjąć decyzję zatwierdzania.</span><span class="sxs-lookup"><span data-stu-id="aaf26-136">A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision.</span></span> <span data-ttu-id="aaf26-137">Nie wyjątku, jeśli transakcja została zatwierdzona.</span><span class="sxs-lookup"><span data-stu-id="aaf26-137">No exception is thrown if the transaction is committed.</span></span>  
  
## <a name="rolling-back-a-transaction"></a><span data-ttu-id="aaf26-138">Wycofywanie transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-138">Rolling back a transaction</span></span>  

 <span data-ttu-id="aaf26-139">Jeśli chcesz wycofać transakcji, nie należy wywołać <xref:System.Transactions.TransactionScope.Complete%2A> metody w zakresie transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-139">If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope.</span></span> <span data-ttu-id="aaf26-140">Na przykład można zgłosić wyjątek w zakresie.</span><span class="sxs-lookup"><span data-stu-id="aaf26-140">For example, you can throw an exception within the scope.</span></span> <span data-ttu-id="aaf26-141">Transakcji, w których uczestniczy w zostaną wycofane.</span><span class="sxs-lookup"><span data-stu-id="aaf26-141">The transaction in which it participates in will be rolled back.</span></span>  
  
## <a name="managing-transaction-flow-using-transactionscopeoption"></a><a name="ManageTxFlow"></a> <span data-ttu-id="aaf26-142">Zarządzanie przepływem transakcji przy użyciu TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="aaf26-142">Managing transaction flow using TransactionScopeOption</span></span>  

 <span data-ttu-id="aaf26-143">Zakres transakcji może być zagnieżdżony przez wywołanie metody używającej z metody, <xref:System.Transactions.TransactionScope> która używa własnego zakresu, podobnie jak `RootMethod` w przypadku metody w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="aaf26-143">Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,</span></span>  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 <span data-ttu-id="aaf26-144">Zakres transakcji wierzchu nosi nazwę zakres głównego.</span><span class="sxs-lookup"><span data-stu-id="aaf26-144">The top-most transaction scope is referred to as the root scope.</span></span>  
  
 <span data-ttu-id="aaf26-145"><xref:System.Transactions.TransactionScope> Udostępnia kilka przeciążenia konstruktorów, które akceptują wyliczenie typu <xref:System.Transactions.TransactionScopeOption>, definiujący transakcyjnych zachowanie zakresu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-145">The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.</span></span>  
  
 <span data-ttu-id="aaf26-146">Element <xref:System.Transactions.TransactionScope> obiekt zawiera trzy pozycje:</span><span class="sxs-lookup"><span data-stu-id="aaf26-146">A <xref:System.Transactions.TransactionScope> object has three options:</span></span>  
  
- <span data-ttu-id="aaf26-147">Dołącz do otoczenia transakcji lub Utwórz nową, jeśli nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="aaf26-147">Join the ambient transaction, or create a new one if one does not exist.</span></span>  
  
- <span data-ttu-id="aaf26-148">Można nowego zakresu głównego, oznacza to, że uruchomić nowej transakcji i skonfigurować danej transakcji można nowej transakcji otoczenia w zakresie własnej.</span><span class="sxs-lookup"><span data-stu-id="aaf26-148">Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.</span></span>  
  
- <span data-ttu-id="aaf26-149">Nie w ogóle brać udział w transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-149">Not take part in a transaction at all.</span></span> <span data-ttu-id="aaf26-150">Z tego względu nie ma żadnej otoczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-150">There is no ambient transaction as a result.</span></span>  
  
 <span data-ttu-id="aaf26-151">Jeśli zakres jest utworzone za pomocą elementów <xref:System.Transactions.TransactionScopeOption.Required>i transakcja otoczenia jest obecna, zakres sprzężenia danej transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-151">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction.</span></span> <span data-ttu-id="aaf26-152">Jeśli z drugiej strony, nie ma żadnej transakcji otoczenia, następnie zakres tworzy nową transakcję i stają się zakres głównego.</span><span class="sxs-lookup"><span data-stu-id="aaf26-152">If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.</span></span> <span data-ttu-id="aaf26-153">Jest to wartość domyślna.</span><span class="sxs-lookup"><span data-stu-id="aaf26-153">This is the default value.</span></span> <span data-ttu-id="aaf26-154">Gdy <xref:System.Transactions.TransactionScopeOption.Required> jest używany, kod w zakresie nie jest konieczne działają inaczej, czy jest to główny lub po prostu dołączenie do otoczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-154">When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.</span></span> <span data-ttu-id="aaf26-155">Powinna ona działać tak samo w obu przypadkach.</span><span class="sxs-lookup"><span data-stu-id="aaf26-155">It should operate identically in both cases.</span></span>  
  
 <span data-ttu-id="aaf26-156">Jeśli zakres jest utworzone za pomocą elementów <xref:System.Transactions.TransactionScopeOption.RequiresNew>, zawsze jest zakres głównego.</span><span class="sxs-lookup"><span data-stu-id="aaf26-156">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope.</span></span> <span data-ttu-id="aaf26-157">Rozpoczyna się nowej transakcji, a jego transakcji staje się nowe otoczenia transakcji w zakresie.</span><span class="sxs-lookup"><span data-stu-id="aaf26-157">It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.</span></span>  
  
 <span data-ttu-id="aaf26-158">Jeśli zakres jest utworzone za pomocą elementów <xref:System.Transactions.TransactionScopeOption.Suppress>, nigdy nie bierze udział w transakcji, niezależnie od tego, czy transakcja otoczenia jest obecny.</span><span class="sxs-lookup"><span data-stu-id="aaf26-158">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present.</span></span> <span data-ttu-id="aaf26-159">Zakres utworzony przy użyciu tej wartości zawsze ma `null` charakter otoczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-159">A scope instantiated with this value always have `null` as its ambient transaction.</span></span>  
  
 <span data-ttu-id="aaf26-160">Powyższych opcji przedstawiono w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="aaf26-160">The above options are summarized in the following table.</span></span>  
  
|<span data-ttu-id="aaf26-161">TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="aaf26-161">TransactionScopeOption</span></span>|<span data-ttu-id="aaf26-162">Otoczenia transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-162">Ambient Transaction</span></span>|<span data-ttu-id="aaf26-163">Zakres uczestniczy</span><span class="sxs-lookup"><span data-stu-id="aaf26-163">The scope takes part in</span></span>|  
|----------------------------|-------------------------|-----------------------------|  
|<span data-ttu-id="aaf26-164">Wymagane</span><span class="sxs-lookup"><span data-stu-id="aaf26-164">Required</span></span>|<span data-ttu-id="aaf26-165">Nie</span><span class="sxs-lookup"><span data-stu-id="aaf26-165">No</span></span>|<span data-ttu-id="aaf26-166">Nowa transakcja (będzie główny)</span><span class="sxs-lookup"><span data-stu-id="aaf26-166">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="aaf26-167">Wymagane nowe</span><span class="sxs-lookup"><span data-stu-id="aaf26-167">Requires New</span></span>|<span data-ttu-id="aaf26-168">Nie</span><span class="sxs-lookup"><span data-stu-id="aaf26-168">No</span></span>|<span data-ttu-id="aaf26-169">Nowa transakcja (będzie główny)</span><span class="sxs-lookup"><span data-stu-id="aaf26-169">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="aaf26-170">Pomiń</span><span class="sxs-lookup"><span data-stu-id="aaf26-170">Suppress</span></span>|<span data-ttu-id="aaf26-171">Nie</span><span class="sxs-lookup"><span data-stu-id="aaf26-171">No</span></span>|<span data-ttu-id="aaf26-172">Nie transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-172">No Transaction</span></span>|  
|<span data-ttu-id="aaf26-173">Wymagane</span><span class="sxs-lookup"><span data-stu-id="aaf26-173">Required</span></span>|<span data-ttu-id="aaf26-174">Yes</span><span class="sxs-lookup"><span data-stu-id="aaf26-174">Yes</span></span>|<span data-ttu-id="aaf26-175">Otoczenia transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-175">Ambient  Transaction</span></span>|  
|<span data-ttu-id="aaf26-176">Wymagane nowe</span><span class="sxs-lookup"><span data-stu-id="aaf26-176">Requires New</span></span>|<span data-ttu-id="aaf26-177">Yes</span><span class="sxs-lookup"><span data-stu-id="aaf26-177">Yes</span></span>|<span data-ttu-id="aaf26-178">Nowa transakcja (będzie główny)</span><span class="sxs-lookup"><span data-stu-id="aaf26-178">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="aaf26-179">Pomiń</span><span class="sxs-lookup"><span data-stu-id="aaf26-179">Suppress</span></span>|<span data-ttu-id="aaf26-180">Yes</span><span class="sxs-lookup"><span data-stu-id="aaf26-180">Yes</span></span>|<span data-ttu-id="aaf26-181">Nie transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-181">No Transaction</span></span>|  
  
 <span data-ttu-id="aaf26-182">Gdy <xref:System.Transactions.TransactionScope> obiektu sprzężenia istniejącej transakcji otoczenia, usuwania obiektu zakres nie może kończyć się transakcji, chyba że zakres przerywa transakcję.</span><span class="sxs-lookup"><span data-stu-id="aaf26-182">When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.</span></span> <span data-ttu-id="aaf26-183">Jeśli otoczenia transakcji został utworzony przez zakres głównego, tylko wtedy, gdy zakres główny jest usunięty, nie <xref:System.Transactions.CommittableTransaction.Commit%2A> jest wywoływana w transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-183">If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction.</span></span> <span data-ttu-id="aaf26-184">Jeśli transakcja została utworzona ręcznie, zakończenia transakcji, gdy jest to zostało przerwane lub przydzielonej przez jej twórcę.</span><span class="sxs-lookup"><span data-stu-id="aaf26-184">If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.</span></span>  
  
 <span data-ttu-id="aaf26-185">Poniższy przykład pokazuje <xref:System.Transactions.TransactionScope> obiekt, który tworzy trzy obiekty zagnieżdżonych zakresów, każde wystąpienie z inną <xref:System.Transactions.TransactionScopeOption> wartością.</span><span class="sxs-lookup"><span data-stu-id="aaf26-185">The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 <span data-ttu-id="aaf26-186">W przykładzie pokazano blok kodu bez żadnej otaczającej transakcji tworząc nowy zakres ( `scope1` ) za pomocą <xref:System.Transactions.TransactionScopeOption.Required> .</span><span class="sxs-lookup"><span data-stu-id="aaf26-186">The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>.</span></span> <span data-ttu-id="aaf26-187">Zakres `scope1` jest zakresem głównego, ponieważ tworzy nową transakcję (transakcji A) i sprawia, że transakcja A otoczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-187">The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.</span></span> <span data-ttu-id="aaf26-188">`Scope1`następnie tworzy trzy więcej obiektów, każdy z inną <xref:System.Transactions.TransactionScopeOption> wartość.</span><span class="sxs-lookup"><span data-stu-id="aaf26-188">`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span> <span data-ttu-id="aaf26-189">Na przykład, `scope2` jest tworzony przy użyciu <xref:System.Transactions.TransactionScopeOption.Required> , i ponieważ istnieje otoczenia transakcji, powoduje sprzężenie pierwszej transakcji utworzonej przez `scope1` .</span><span class="sxs-lookup"><span data-stu-id="aaf26-189">For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`.</span></span> <span data-ttu-id="aaf26-190">Należy pamiętać, że `scope3` zakres główny nowej transakcji, a `scope4` ma ma otoczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-190">Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.</span></span>  
  
 <span data-ttu-id="aaf26-191">Chociaż często używane wartości domyślne i większość <xref:System.Transactions.TransactionScopeOption> jest <xref:System.Transactions.TransactionScopeOption.Required>, inne wartości ma unikatowy z przeznaczeniem.</span><span class="sxs-lookup"><span data-stu-id="aaf26-191">Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.</span></span>  

### <a name="non-transactional-code-inside-a-transaction-scope"></a><span data-ttu-id="aaf26-192">Kod nietransakcyjny wewnątrz zakresu transakcji</span><span class="sxs-lookup"><span data-stu-id="aaf26-192">Non-transactional code inside a transaction scope</span></span>

 <span data-ttu-id="aaf26-193"><xref:System.Transactions.TransactionScopeOption.Suppress>jest przydatne, gdy chcesz zachować operacji wykonywanych przez sekcję kodu, a nie chcesz przerwać otoczenia transakcji, jeśli operacje kończą się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="aaf26-193"><xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.</span></span> <span data-ttu-id="aaf26-194">Na przykład, gdy chcesz wykonać operacje rejestrowania lub inspekcji lub Kiedy chcesz opublikować zdarzenia dla subskrybentów, niezależnie od tego, czy otoczenia transakcji zatwierdzeń lub przerwań.</span><span class="sxs-lookup"><span data-stu-id="aaf26-194">For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.</span></span> <span data-ttu-id="aaf26-195">Ta wartość umożliwia posiadanie sekcji kodu nietransakcyjnej wewnątrz zakresu transakcji, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="aaf26-195">This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a><span data-ttu-id="aaf26-196">Głosowanie wewnątrz zagnieżdżonej zakresu</span><span class="sxs-lookup"><span data-stu-id="aaf26-196">Voting inside a nested scope</span></span>  

 <span data-ttu-id="aaf26-197">Chociaż zagnieżdżony zakres może dołączyć do otoczenia transakcji zakresu głównego, wywoływania <xref:System.Transactions.TransactionScope.Complete%2A> w zakresie zagnieżdżone nie ma wpływu na zakres głównego.</span><span class="sxs-lookup"><span data-stu-id="aaf26-197">Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope.</span></span> <span data-ttu-id="aaf26-198">Tylko wtedy, gdy wszystkie zakresy z zakresu głównego do ostatni zakres zagnieżdżonych głosowania można zatwierdzić transakcji, będzie można zatwierdzić transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-198">Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.</span></span> <span data-ttu-id="aaf26-199">Nie wywołuje metody <xref:System.Transactions.TransactionScope.Complete%2A> w zakresie zagnieżdżonych będzie miała wpływ na zakres głównego zgodnie z otoczenia transakcja zostanie natychmiast przerwane.</span><span class="sxs-lookup"><span data-stu-id="aaf26-199">Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.</span></span>  
  
## <a name="setting-the-transactionscope-timeout"></a><span data-ttu-id="aaf26-200">Ustawienie limitu czasu elementu TransactionScope</span><span class="sxs-lookup"><span data-stu-id="aaf26-200">Setting the TransactionScope timeout</span></span>  

 <span data-ttu-id="aaf26-201">Niektóre z przeciążenia konstruktorów z <xref:System.Transactions.TransactionScope> akceptować wartości typu <xref:System.TimeSpan>, używany do sterowania limit czasu transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-201">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction.</span></span> <span data-ttu-id="aaf26-202">Upłynął limit czasu ustawioną wartość zero oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-202">A timeout set to zero means an infinite timeout.</span></span> <span data-ttu-id="aaf26-203">Nieskończony limit czasu przydaje się głównie na potrzeby debugowania, gdy chcesz wyizolować problem w logiki biznesowej przez krokowe wykonywanie kodu, a użytkownik nie chce transakcji, które można debugować limitu czasu podczas próby zlokalizowania problemu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-203">Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.</span></span> <span data-ttu-id="aaf26-204">Ostrożność bardzo przy użyciu wartości nieskończony limit czasu we wszystkich innych przypadkach, ponieważ zastępuje zabezpiecza przed zakleszczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-204">Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.</span></span>  
  
 <span data-ttu-id="aaf26-205">Zwykle ustawiana <xref:System.Transactions.TransactionScope> limitu czasu w celu wartości innej niż domyślny w obu przypadkach.</span><span class="sxs-lookup"><span data-stu-id="aaf26-205">You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases.</span></span> <span data-ttu-id="aaf26-206">Pierwszy jest podczas opracowywania, gdy chcesz przetestować sposób, w jaki aplikacja obsługuje przerwane transakcje.</span><span class="sxs-lookup"><span data-stu-id="aaf26-206">The first is during development, when you want to test the way your application handles aborted transactions.</span></span> <span data-ttu-id="aaf26-207">Przez ustawienie limitu czasu małej wartości (na przykład jeden milisekund), spowodować transakcji nie powiedzie się i w związku z tym można obserwować obsługę kodu błędu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-207">By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.</span></span> <span data-ttu-id="aaf26-208">Drugi przypadek, w którym można ustawić wartość jest mniejsza niż domyślna wartość limitu czasu jest, jeśli uważasz, że zakres polega konfliktu zasobów, co spowoduje zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="aaf26-208">The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.</span></span> <span data-ttu-id="aaf26-209">W takim przypadku chcesz przerwać transakcji, jak najszybciej i nie czeka na domyślna wartość limitu czasu wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="aaf26-209">In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.</span></span>  
  
 <span data-ttu-id="aaf26-210">Gdy zakres sprzężenia otoczenia transakcji, ale określa limit czasu mniejsze niż ma ustawioną wartość transakcji otoczenia, nowe, krótszy limit czasu jest wymuszane na <xref:System.Transactions.TransactionScope> obiektu i zakres musi kończyć się w czasie zagnieżdżonych określonym lub transakcja jest automatycznie przerwana.</span><span class="sxs-lookup"><span data-stu-id="aaf26-210">When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.</span></span> <span data-ttu-id="aaf26-211">Jeśli limit czasu zagnieżdżony zakres jest więcej niż otoczenia transakcji, ustawienie nie działa.</span><span class="sxs-lookup"><span data-stu-id="aaf26-211">If the nested scope's timeout is more than that of the ambient transaction, it has no effect.</span></span>  
  
## <a name="setting-the-transactionscope-isolation-level"></a><span data-ttu-id="aaf26-212">Ustawienie poziomu izolacji elementu TransactionScope</span><span class="sxs-lookup"><span data-stu-id="aaf26-212">Setting the TransactionScope isolation level</span></span>  

 <span data-ttu-id="aaf26-213">Niektóre z przeciążenia konstruktorów z <xref:System.Transactions.TransactionScope> zaakceptować struktury typu <xref:System.Transactions.TransactionOptions> określa poziom izolacji, oprócz wartość limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-213">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value.</span></span> <span data-ttu-id="aaf26-214">Domyślnie transakcji wykonuje z ustawioną poziom izolacji <xref:System.Transactions.IsolationLevel.Serializable>.</span><span class="sxs-lookup"><span data-stu-id="aaf26-214">By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>.</span></span> <span data-ttu-id="aaf26-215">Wybranie innego niż poziom izolacji <xref:System.Transactions.IsolationLevel.Serializable> jest najczęściej używana w systemach intensywnie korzysta z odczytu.</span><span class="sxs-lookup"><span data-stu-id="aaf26-215">Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems.</span></span> <span data-ttu-id="aaf26-216">Wymaga to pełny opis przetwarzania interpretacją i semantyka transakcja współbieżności problemy związane z i skutków spójności systemu transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-216">This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.</span></span>  
  
 <span data-ttu-id="aaf26-217">Ponadto nie wszystkie menedżerów zasobów obsługuje wszystkie poziomy izolacji i może zdecydować się do wzięcia udziału w transakcji na wyższym poziomie niż skonfigurowane.</span><span class="sxs-lookup"><span data-stu-id="aaf26-217">In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.</span></span>  
  
 <span data-ttu-id="aaf26-218">Każdy poziom izolacji poza <xref:System.Transactions.IsolationLevel.Serializable> się niespójność wynikające z innych transakcji dostęp do tych samych informacji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-218">Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information.</span></span> <span data-ttu-id="aaf26-219">Różnica między izolacji różne poziomy w ten sposób do odczytu i zapisu blokady są używane.</span><span class="sxs-lookup"><span data-stu-id="aaf26-219">The difference between the different isolation levels is in the way read and write locks are used.</span></span> <span data-ttu-id="aaf26-220">Blokada może zostać pociągnięty tylko wtedy, gdy transakcji uzyskuje dostęp do danych w Menedżerze zasobów lub może zostać pociągnięty do momentu transakcji nie zostanie przekazana lub zostało przerwane.</span><span class="sxs-lookup"><span data-stu-id="aaf26-220">A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.</span></span> <span data-ttu-id="aaf26-221">Jest lepsze przepustowości, ten ostatni w celu zachowania spójności.</span><span class="sxs-lookup"><span data-stu-id="aaf26-221">The former is better for throughput, the latter for consistency.</span></span> <span data-ttu-id="aaf26-222">Dwa rodzaje blokady i dwa rodzaje operacji (odczyt/zapis) dostarcza cztery poziomy izolacji podstawowe.</span><span class="sxs-lookup"><span data-stu-id="aaf26-222">The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.</span></span> <span data-ttu-id="aaf26-223">Aby uzyskać więcej informacji, zobacz <xref:System.Transactions.IsolationLevel>.</span><span class="sxs-lookup"><span data-stu-id="aaf26-223">See <xref:System.Transactions.IsolationLevel> for more information.</span></span>  
  
 <span data-ttu-id="aaf26-224">Po użyciu zagnieżdżone <xref:System.Transactions.TransactionScope> obiektów, wszystkie zakresy zagnieżdżonych musi być skonfigurowany do użycia dokładnie ten sam poziom izolacji, aby dołączyć otoczenia transakcji.</span><span class="sxs-lookup"><span data-stu-id="aaf26-224">When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.</span></span> <span data-ttu-id="aaf26-225">Jeśli zagnieżdżonych <xref:System.Transactions.TransactionScope> obiektu próbuje dołączyć otoczenia transakcji, jeszcze określa poziom izolacji różnych <xref:System.ArgumentException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="aaf26-225">If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.</span></span>  
  
## <a name="interop-with-com"></a><span data-ttu-id="aaf26-226">Usługę międzyoperacyjną z modelu COM +</span><span class="sxs-lookup"><span data-stu-id="aaf26-226">Interop with COM+</span></span>  

 <span data-ttu-id="aaf26-227">Podczas tworzenia nowego <xref:System.Transactions.TransactionScope> wystąpienie, można użyć <xref:System.Transactions.EnterpriseServicesInteropOption> wyliczenia w jednym z konstruktorów do określenia sposobu interakcji z modelu COM +.</span><span class="sxs-lookup"><span data-stu-id="aaf26-227">When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+.</span></span> <span data-ttu-id="aaf26-228">Aby uzyskać więcej informacji na ten temat, zobacz [współdziałanie z usługami przedsiębiorstwa i transakcjami modelu COM+](interoperability-with-enterprise-services-and-com-transactions.md).</span><span class="sxs-lookup"><span data-stu-id="aaf26-228">For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aaf26-229">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="aaf26-229">See also</span></span>

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
