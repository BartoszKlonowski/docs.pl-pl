---
title: Rozszerzenia znacznikowania i WPF XAML
ms.date: 03/30/2017
helpviewer_keywords:
- brace character [WPF]
- Binding markup extensions [WPF]
- RelativeSource markup extensions [WPF]
- XAML [WPF], markup extensions
- markup extensions [WPF]
- nesting extension syntax [WPF]
- curly brace characters ({})
- TemplateBinding markup extensions [WPF]
- StaticResource markup extensions [WPF]
- literal curly brace characters ({})
- characters [WPF], curly brace
- DynamicResource markup extensions [WPF]
ms.assetid: 618dc745-8b14-4886-833f-486d2254bb78
ms.openlocfilehash: e678dcf9606c3ad545e93a4389bccb3d49423dec
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/05/2019
ms.locfileid: "57355236"
---
# <a name="markup-extensions-and-wpf-xaml"></a><span data-ttu-id="b1f4a-102">Rozszerzenia znacznikowania i WPF XAML</span><span class="sxs-lookup"><span data-stu-id="b1f4a-102">Markup Extensions and WPF XAML</span></span>
<span data-ttu-id="b1f4a-103">W tym temacie przedstawiono koncepcję — rozszerzenia znaczników dla XAML, w tym ich reguły składni, cel i model obiektów klasy, która jest podporządkowana narzędziu je.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-103">This topic introduces the concept of markup extensions for XAML, including their syntax rules, purpose, and the class object model that underlies them.</span></span> <span data-ttu-id="b1f4a-104">Rozszerzenia znaczników są ogólną funkcją języka XAML i implementacji .NET usług XAML.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-104">Markup extensions are a general feature of the XAML language and of the .NET implementation of XAML services.</span></span> <span data-ttu-id="b1f4a-105">W tym temacie szczegółowo specjalnie do użytku w programie WPF XAML — rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-105">This topic specifically details markup extensions for use in WPF XAML.</span></span>  
  
  
<a name="XAML_Processors_and_Markup_Extensions"></a>   
## <a name="xaml-processors-and-markup-extensions"></a><span data-ttu-id="b1f4a-106">Procesory XAML i rozszerzeń znaczników</span><span class="sxs-lookup"><span data-stu-id="b1f4a-106">XAML Processors and Markup Extensions</span></span>  
 <span data-ttu-id="b1f4a-107">Ogólnie rzecz biorąc analizator składni XAML albo może interpretować wartość atrybutu jako ciąg literału, który można przekonwertować elementu podstawowego lub przekonwertować obiekt za pomocą środków.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-107">Generally speaking, a XAML parser can either interpret an attribute value as a literal string that can be converted to a primitive, or convert it to an object by some means.</span></span> <span data-ttu-id="b1f4a-108">Jednego takiego oznacza, że jest odwołując konwertera typów; jest to opisane w temacie [TypeConverters i XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-108">One such means is by referencing a type converter; this is documented in the topic [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span> <span data-ttu-id="b1f4a-109">Jednak istnieją scenariusze, w których wymagane są różne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-109">However, there are scenarios where different behavior is required.</span></span> <span data-ttu-id="b1f4a-110">Na przykład procesora XAML może się instrukcja, że wartość atrybutu nie powinno spowodować nowy obiekt na grafie obiektu.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-110">For example, a XAML processor can be instructed that a value of an attribute should not result in a new object in the object graph.</span></span> <span data-ttu-id="b1f4a-111">Zamiast tego atrybutu powinno spowodować wykresu obiektu, który sprawia, że odwołanie do już skonstruowanego obiektu w innej części wykres lub obiekt statyczny.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-111">Instead, the attribute should result in an object graph that makes a reference to an already constructed object in another part of the graph, or a static object.</span></span> <span data-ttu-id="b1f4a-112">Inny scenariusz polega na tym, że procesor XAML może być zobowiązany do używania składni, która zawiera argumenty inne niż domyślne do konstruktora obiektu.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-112">Another scenario is that a XAML processor can be instructed to use a syntax that provides non-default arguments to the constructor of an object.</span></span> <span data-ttu-id="b1f4a-113">Są to typy scenariuszy, w którym rozszerzenie znaczników mogą udostępniać rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-113">These are the types of scenarios where a markup extension can provide the solution.</span></span>  
  
<a name="Basic_Markup_Extension_Syntax"></a>   
## <a name="basic-markup-extension-syntax"></a><span data-ttu-id="b1f4a-114">Składni rozszerzenia znaczników podstawowych</span><span class="sxs-lookup"><span data-stu-id="b1f4a-114">Basic Markup Extension Syntax</span></span>  
 <span data-ttu-id="b1f4a-115">Rozszerzenie znaczników można zaimplementować o podanie wartości właściwości użycie atrybutu, właściwości w użycie elementu właściwości lub obu.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-115">A markup extension can be implemented to provide values for properties in an attribute usage, properties in a property element usage, or both.</span></span>  
  
 <span data-ttu-id="b1f4a-116">W przypadku użycia, aby zapewnić wartość atrybutu, składnia, która odróżnia sekwencji rozszerzenia znaczników w celu procesora XAML jest obecność otwierający i zamykający nawias klamrowy ({i}).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-116">When used to provide an attribute value, the syntax that distinguishes a markup extension sequence to a XAML processor is the presence of the opening and closing curly braces ({ and }).</span></span> <span data-ttu-id="b1f4a-117">Typ — rozszerzenie znaczników następnie jest identyfikowany przez token ciągu bezpośrednio po otwierającym nawiasie klamrowym.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-117">The type of markup extension is then identified by the string token immediately following the opening curly brace.</span></span>  
  
 <span data-ttu-id="b1f4a-118">W przypadku użycia w składni elementu właściwości, rozszerzenie znaczników wizualnie jest taka sama jak inny element używane do zapewnienia wartości właściwości elementu: deklaracji elementu XAML, który odwołuje się klasa rozszerzenia struktury znaczników jako element, ujęte w nawiasach kątowych (<> ).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-118">When used in property element syntax, a markup extension is visually the same as any other element used to provide a property element value: a XAML element declaration that references the markup extension class as an element, enclosed within angle brackets (<>).</span></span>  
  
<a name="XAML_Defined_Markup_Extensions"></a>   
## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="b1f4a-119">Rozszerzenia znaczników zdefiniowane w XAML</span><span class="sxs-lookup"><span data-stu-id="b1f4a-119">XAML-Defined Markup Extensions</span></span>  
 <span data-ttu-id="b1f4a-120">Istnieją kilka rozszerzeń struktury znaczników, które nie są specyficzne dla implementacji WPF XAML, ale zamiast tego są w implementacji funkcji wewnętrznych lub funkcje XAML jako język.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-120">Several markup extensions exist that are not specific to the WPF implementation of XAML, but are instead implementations of intrinsics or features of XAML as a language.</span></span> <span data-ttu-id="b1f4a-121">Te rozszerzenia znaczników są implementowane w zestawie System.Xaml jako część ogólnego usług .NET Framework XAML i znajdują się w przestrzeni nazw XAML dla języka XAML.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-121">These markup extensions are implemented in the System.Xaml assembly as part of the general .NET Framework XAML services, and are within the XAML language XAML namespace.</span></span> <span data-ttu-id="b1f4a-122">Pod względem wspólne użycie znaczników, te rozszerzenia znaczników są zazwyczaj identyfikowane przez `x:` prefiks w użycia.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-122">In terms of common markup usage, these markup extensions are typically identifiable by the `x:` prefix in the usage.</span></span> <span data-ttu-id="b1f4a-123"><xref:System.Windows.Markup.MarkupExtension> Klasę bazową (również zdefiniowanej w System.Xaml) zawiera wzorzec, która powinna być używana wszystkie rozszerzenia znaczników, aby mogły być obsługiwane w XAML czytników i składników zapisywania XAML, w tym w WPF XAML.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-123">The <xref:System.Windows.Markup.MarkupExtension> base class (also defined in System.Xaml) provides the pattern that all markup extensions should use in order to be supported in XAML readers and XAML writers, including in WPF XAML.</span></span>  
  
-   <span data-ttu-id="b1f4a-124">`x:Type` dostarcza <xref:System.Type> obiektu dla typu nazwanego.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-124">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="b1f4a-125">Ten obiekt jest używana najczęściej w — style i szablony.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-125">This facility is used most frequently in styles and templates.</span></span> <span data-ttu-id="b1f4a-126">Aby uzyskać więcej informacji, zobacz [x: Type Markup Extension](../../xaml-services/x-type-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-126">For details, see [x:Type Markup Extension](../../xaml-services/x-type-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-127">`x:Static` Tworzy wartości statyczne.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-127">`x:Static` produces static values.</span></span> <span data-ttu-id="b1f4a-128">Wartości pochodzą z jednostki kodu typ wartości, które nie są bezpośrednio typ wartości właściwości docelowych, ale mogą być obliczane do tego typu.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-128">The values come from value-type code entities that are not directly the type of a target property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="b1f4a-129">Aby uzyskać więcej informacji, zobacz [x: Static — rozszerzenie znaczników](../../xaml-services/x-static-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-129">For details, see [x:Static Markup Extension](../../xaml-services/x-static-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-130">`x:Null` Określa `null` jako wartość właściwości i mogą być używane dla atrybutów lub wartości elementu właściwości.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-130">`x:Null` specifies `null` as a value for a property and can be used either for attributes or property element values.</span></span> <span data-ttu-id="b1f4a-131">Aby uzyskać więcej informacji, zobacz [x: Null — rozszerzenie znaczników](../../xaml-services/x-null-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-131">For details, see [x:Null Markup Extension](../../xaml-services/x-null-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-132">`x:Array` zapewnia obsługę tworzenia tablic ogólne w XAML składni w przypadkach, gdzie kolekcji pomoc techniczna świadczona przez elementy bazy WPF i modele kontroli celowo nie jest używana.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-132">`x:Array` provides support for creation of general arrays in XAML syntax, for cases where the collection support provided by WPF base elements and control models is deliberately not used.</span></span> <span data-ttu-id="b1f4a-133">Aby uzyskać więcej informacji, zobacz [x: Array — rozszerzenie znaczników](../../xaml-services/x-array-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-133">For details, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1f4a-134">`x:` Prefiks jest używany dla typowych mapowania przestrzeni nazw XAML wewnętrzne języka XAML, w elemencie głównym pliku XAML lub produkcji.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-134">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language intrinsics, in the root element of a XAML file or production.</span></span> <span data-ttu-id="b1f4a-135">Na przykład szablony programu Visual Studio dla aplikacji WPF zainicjować pliku XAML, za pomocą tego `x:` mapowania.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-135">For example, the Visual Studio templates for WPF applications initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="b1f4a-136">Możesz wybrać inny token własne mapowania przestrzeni nazw XAML, ale ta dokumentacja przyjmie domyślną `x:` mapowanie jako sposób identyfikacji tych jednostek, które są zdefiniowane części przestrzeni nazw XAML dla języka XAML, w przeciwieństwie Aby WPF domyślny obszar nazw lub w innych przestrzeniach nazw XAML nie związane z określonym środowiskiem.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-136">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML namespace for the XAML language, as opposed to the WPF default namespace or other XAML namespaces not related to a specific framework.</span></span>  
  
<a name="WPF_Specific_Markup_Extensions"></a>   
## <a name="wpf-specific-markup-extensions"></a><span data-ttu-id="b1f4a-137">Rozszerzenia znaczników charakterystyczne dla WPF</span><span class="sxs-lookup"><span data-stu-id="b1f4a-137">WPF-Specific Markup Extensions</span></span>  
 <span data-ttu-id="b1f4a-138">Najbardziej typowe rozszerzenia znaczników, używany w programowaniu WPF to te, które obsługuje odwołania do zasobów (`StaticResource` i `DynamicResource`) oraz te, które obsługuje powiązanie danych (`Binding`).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-138">The most common markup extensions used in WPF programming are those that support resource references (`StaticResource` and `DynamicResource`), and those that support data binding (`Binding`).</span></span>  
  
-   <span data-ttu-id="b1f4a-139">`StaticResource` zawiera wartość dla właściwości, zastępując wartości zasobu już zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-139">`StaticResource` provides a value for a property by substituting the value of an already defined resource.</span></span> <span data-ttu-id="b1f4a-140">A `StaticResource` oceny ostatecznie jest wykonywane w czasie ładowania XAML i nie ma dostępu do wykresu obiektu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-140">A `StaticResource` evaluation is ultimately made at XAML load time and does not have access to the object graph at run time.</span></span> <span data-ttu-id="b1f4a-141">Aby uzyskać więcej informacji, zobacz [staticresource — rozszerzenie znaczników](staticresource-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-141">For details, see [StaticResource Markup Extension](staticresource-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-142">`DynamicResource` zawiera wartość dla właściwości, opóźnienie tej wartości jako odwołanie do zasobu środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-142">`DynamicResource` provides a value for a property by deferring that value to be a run-time reference to a resource.</span></span> <span data-ttu-id="b1f4a-143">Odwołanie do zasobu dynamicznego wymusza nowe wyszukiwanie każdym razem, że taki zasób jest dostępny i ma dostęp do wykresu obiektu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-143">A dynamic resource reference forces a new lookup each time that such a resource is accessed and has access to the object graph at run time.</span></span> <span data-ttu-id="b1f4a-144">Aby uzyskać dostęp, `DynamicResource` koncepcji jest obsługiwana przez właściwości zależności w systemie właściwości WPF i obliczone wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-144">In order to get this access, `DynamicResource` concept is supported by dependency properties in the WPF property system, and evaluated expressions.</span></span> <span data-ttu-id="b1f4a-145">W związku z tym można używać tylko `DynamicResource` dla obiektu docelowego właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-145">Therefore you can only use `DynamicResource` for a dependency property target.</span></span> <span data-ttu-id="b1f4a-146">Aby uzyskać więcej informacji, zobacz [dynamicresource — rozszerzenie znaczników](dynamicresource-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-146">For details, see [DynamicResource Markup Extension](dynamicresource-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-147">`Binding` zawiera wartość dla właściwości, za pomocą kontekstu danych, która ma zastosowanie do obiektu nadrzędnego w czasie wykonywania powiązany z danymi.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-147">`Binding` provides a data bound value for a property, using the data context that applies to the parent object at run time.</span></span> <span data-ttu-id="b1f4a-148">Tego rozszerzenia znacznika jest dość złożone, ponieważ umożliwia wbudowane istotne składnia określająca powiązanie danych.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-148">This markup extension is relatively complex, because it enables a substantial inline syntax for specifying a data binding.</span></span> <span data-ttu-id="b1f4a-149">Aby uzyskać więcej informacji, zobacz [— rozszerzenie znaczników powiązania](binding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-149">For details, see [Binding Markup Extension](binding-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-150">`RelativeSource` zawiera informacje o źródle <xref:System.Windows.Data.Binding> , można przejść kilka możliwych relacji w drzewie obiektów czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-150">`RelativeSource` provides source information for a <xref:System.Windows.Data.Binding> that can navigate several possible relationships in the run-time object tree.</span></span> <span data-ttu-id="b1f4a-151">Zapewnia to wyspecjalizowane określania źródła dla powiązań, które są w szablonach wielokrotnego użytku lub tworzony kod bez pełnej znajomości otaczającego drzewa obiektów.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-151">This provides specialized sourcing for bindings that are created in multi-use templates or created in code without full knowledge of the surrounding object tree.</span></span> <span data-ttu-id="b1f4a-152">Aby uzyskać więcej informacji, zobacz [RelativeSource, rozszerzenie znaczników](relativesource-markupextension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-152">For details, see [RelativeSource MarkupExtension](relativesource-markupextension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-153">`TemplateBinding` Umożliwia szablonu kontrolki użyć wartości dla właściwości oparte na szablonach, które pochodzą z zdefiniowana przez model obiektu właściwości klasy, która będzie używać szablonu.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-153">`TemplateBinding` enables a control template to use values for templated properties that come from object-model-defined properties of the class that will use the template.</span></span> <span data-ttu-id="b1f4a-154">Innymi słowy właściwości wewnątrz definicji szablonu mają dostęp do kontekstu, który istnieje tylko po zastosowaniu szablonu.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-154">In other words, the property within the template definition can access a context that only exists once the template is applied.</span></span> <span data-ttu-id="b1f4a-155">Aby uzyskać więcej informacji, zobacz [TemplateBinding Markup Extension](templatebinding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-155">For details, see [TemplateBinding Markup Extension](templatebinding-markup-extension.md).</span></span> <span data-ttu-id="b1f4a-156">Aby uzyskać więcej informacji na temat praktyczne wykorzystanie `TemplateBinding`, zobacz [style przykład ControlTemplates](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-156">For more information on the practical use of `TemplateBinding`, see [Styling with ControlTemplates Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span></span>  
  
-   <span data-ttu-id="b1f4a-157">`ColorConvertedBitmap` obsługuje stosunkowo zaawansowanym scenariuszu przetwarzania obrazów.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-157">`ColorConvertedBitmap` supports a relatively advanced imaging scenario.</span></span> <span data-ttu-id="b1f4a-158">Aby uzyskać więcej informacji, zobacz [colorconvertedbitmap — rozszerzenie znaczników](colorconvertedbitmap-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-158">For details, see [ColorConvertedBitmap Markup Extension](colorconvertedbitmap-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="b1f4a-159">`ComponentResourceKey` i `ThemeDictionary` obsługuje aspektów wyszukiwania zasobów, szczególnie w przypadku zasobów i motywów, które są dostarczane z formantami niestandardowymi.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-159">`ComponentResourceKey` and `ThemeDictionary` support aspects of resource lookup, particularly for resources and themes that are packaged with custom controls.</span></span> <span data-ttu-id="b1f4a-160">Aby uzyskać więcej informacji, zobacz [componentresourcekey — rozszerzenie znaczników](componentresourcekey-markup-extension.md), [themedictionary — rozszerzenie znaczników](themedictionary-markup-extension.md), lub [omówienie tworzenia kontrolek](../controls/control-authoring-overview.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-160">For more information, see [ComponentResourceKey Markup Extension](componentresourcekey-markup-extension.md), [ThemeDictionary Markup Extension](themedictionary-markup-extension.md), or [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>  
  
<a name="StarExtension"></a>   
## <a name="extension-classes"></a><span data-ttu-id="b1f4a-161">\* Rozszerzenie klasy</span><span class="sxs-lookup"><span data-stu-id="b1f4a-161">\*Extension Classes</span></span>  
 <span data-ttu-id="b1f4a-162">Dla języka XAML ogólnego i rozszerzenia znaczników charakterystyczne dla WPF, zachowanie każdego rozszerzenia znaczników jest identyfikowana procesor XAML za pośrednictwem `*Extension` klasę pochodzącą od <xref:System.Windows.Markup.MarkupExtension>i oferuje implementację <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> Metoda.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-162">For both the general XAML language and WPF-specific markup extensions, the behavior of each markup extension is identified to a XAML processor through a `*Extension` class that derives from <xref:System.Windows.Markup.MarkupExtension>, and provides an implementation of the <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> method.</span></span> <span data-ttu-id="b1f4a-163">Ta metoda na każde rozszerzenie zapewnia obiekt, który jest zwracany, jeśli rozszerzenie znaczników jest oceniany.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-163">This method on each extension provides the object that is returned when the markup extension is evaluated.</span></span> <span data-ttu-id="b1f4a-164">Zwrócony obiekt zwykle jest oceniany na podstawie różnych tokenów parametrów, które są przekazywane do rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-164">The returned object is typically evaluated based on the various string tokens that are passed to the markup extension.</span></span>  
  
 <span data-ttu-id="b1f4a-165">Na przykład <xref:System.Windows.StaticResourceExtension> klasa udostępnia powierzchni implementacji wyszukiwania rzeczywistego zasobu, aby jego <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> implementacja zwraca obiekt, który jest wnioskowany z danymi wejściowymi tego określonego wykonania jest ciąg, który jest używany do wyszukiwania zasobów przez jego `x:Key`.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-165">For example, the <xref:System.Windows.StaticResourceExtension> class provides the surface implementation of actual resource lookup so that its <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> implementation returns the object that is requested, with the input of that particular implementation being a string that is used to look up the resource by its `x:Key`.</span></span> <span data-ttu-id="b1f4a-166">Większość tych szczegółów implementacji nie jest ważna, jeśli używasz istniejącego rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-166">Much of this implementation detail is unimportant if you are using an existing markup extension.</span></span>  
  
 <span data-ttu-id="b1f4a-167">Niektóre rozszerzenia znaczników nie należy używać tokenu argumenty typu string.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-167">Some markup extensions do not use string token arguments.</span></span> <span data-ttu-id="b1f4a-168">Jest to ponieważ zwracają wartość statycznych lub spójne lub kontekst powinna być zwracana wartość, jaką jest dostępna za pośrednictwem jednej z usług przekazywanych `serviceProvider` parametru.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-168">This is either because they return a static or consistent value, or because context for what value should be returned is available through one of the services passed through the `serviceProvider` parameter.</span></span>  
  
 <span data-ttu-id="b1f4a-169">`*Extension` Wzorzec nazewnictwa jest dla wygody i spójności.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-169">The `*Extension` naming pattern is for convenience and consistency.</span></span> <span data-ttu-id="b1f4a-170">Nie jest konieczne w kolejności dla procesora XAML do identyfikowania tej klasy, jak pomoc techniczna dla rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-170">It is not necessary in order for a XAML processor to identify that class as support for a markup extension.</span></span> <span data-ttu-id="b1f4a-171">Tak długo, jak baza kodu obejmuje System.Xaml i korzysta z usług programu .NET Framework XAML implementacji, wszystko co jest rozpoznawane, rozszerzenie znaczników XAML jest pochodną <xref:System.Windows.Markup.MarkupExtension> oraz zapewnić obsługę składni konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-171">So long as your codebase includes System.Xaml and uses .NET Framework XAML Services implementations, all that is necessary to be recognized as a XAML markup extension is to derive from <xref:System.Windows.Markup.MarkupExtension> and to support a construction syntax.</span></span> <span data-ttu-id="b1f4a-172">WPF definiuje Włączanie rozszerzenia klasy znaczników, które nie podlegają `*Extension` nazewnictwa wzorca, na przykład <xref:System.Windows.Data.Binding>.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-172">WPF defines markup extension-enabling classes that do not follow the `*Extension` naming pattern, for example <xref:System.Windows.Data.Binding>.</span></span> <span data-ttu-id="b1f4a-173">Zazwyczaj przyczyną jest klasy obsługuje scenariusze poza obsługą rozszerzenia znaczników czysty.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-173">Typically the reason for this is that the class supports scenarios beyond pure markup extension support.</span></span> <span data-ttu-id="b1f4a-174">W przypadku właściwości <xref:System.Windows.Data.Binding>, że klasa obsługuje dostępu do metod i właściwości obiektu w czasie wykonywania dla scenariuszy, w których mają one nic wspólnego z XAML.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-174">In the case of <xref:System.Windows.Data.Binding>, that class supports run-time access to methods and properties of the object for scenarios that have nothing to do with XAML.</span></span>  
  
### <a name="extension-class-interpretation-of-initialization-text"></a><span data-ttu-id="b1f4a-175">Rozszerzenie klasy interpretacji inicjowania tekstu</span><span class="sxs-lookup"><span data-stu-id="b1f4a-175">Extension Class Interpretation of Initialization Text</span></span>  
 <span data-ttu-id="b1f4a-176">Tokeny ciągu następujące rozszerzenie znaczników nazwy, a nadal mieszczą się w nawiasy klamrowe są interpretowane przez procesor XAML w jednym z następujących sposobów:</span><span class="sxs-lookup"><span data-stu-id="b1f4a-176">The string tokens following the markup extension name and still within the braces are interpreted by a XAML processor in one of the following ways:</span></span>  
  
-   <span data-ttu-id="b1f4a-177">Przecinek zawsze odzwierciedla separator lub ogranicznika oddzielne tokeny.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-177">A comma always represents the separator or delimiter of individual tokens.</span></span>  
  
-   <span data-ttu-id="b1f4a-178">Jeśli oddzielne tokeny rozdzielonych nie zawierają żadnych znaków równości, każdy token jest traktowany jako argument konstruktora.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-178">If the individual separated tokens do not contain any equals signs, each token is treated as a constructor argument.</span></span> <span data-ttu-id="b1f4a-179">Każdy parametr konstruktora musi zostać podany jako typ oczekiwany przez ten podpis i w odpowiedniej kolejności, oczekiwany przez ten podpis.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-179">Each constructor parameter must be given as the type expected by that signature, and in the proper order expected by that signature.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b1f4a-180">Procesor XAML musi wywołać konstruktora, który jest zgodna z liczbą argumentów liczby pary.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-180">A XAML processor must call the constructor that matches the argument count of the number of pairs.</span></span> <span data-ttu-id="b1f4a-181">Z tego powodu w przypadku wdrażania jako rozszerzenie znacznika niestandardowego nie udostępniają wiele konstruktorów z tej samej liczby argumentów.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-181">For this reason, if you are implementing a custom markup extension, do not provide multiple constructors with the same argument count.</span></span> <span data-ttu-id="b1f4a-182">Zachowanie jak procesor XAML zachowuje się, jeśli istnieje więcej niż jedną ścieżkę Konstruktor rozszerzenia znaczników przy użyciu tego samego liczba parametrów nie jest zdefiniowany, ale powinien przewidywać procesora XAML będzie mógł zgłosić wyjątek użycia, jeśli ta sytuacja występuje w Definicje typu rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-182">The behavior for how a XAML processor behaves if more than one markup extension constructor path with the same parameter count exists is not defined, but you should anticipate that a XAML processor is permitted to throw an exception on usage if this situation exists in the markup extension type definitions.</span></span>  
  
-   <span data-ttu-id="b1f4a-183">Jeśli poszczególne oddzielone tokeny zawierają znaki równości, a następnie procesora XAML najpierw wywołuje konstruktor domyślny dla rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-183">If the individual separated tokens contain equals signs, then a XAML processor first calls the default constructor for the markup extension.</span></span> <span data-ttu-id="b1f4a-184">Następnie w każdej pary nazwa =-wartość jest interpretowana jako nazwa właściwości, która istnieje na rozszerzenia znaczników i wartość do przypisania do właściwości.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-184">Then, each name=value pair is interpreted as a property name that exists on the markup extension, and a value to assign to that property.</span></span>  
  
-   <span data-ttu-id="b1f4a-185">W przypadku równoległego wynik między zachowanie konstruktora i ustawienia zachowania rozszerzenia znaczników właściwości nie ma znaczenia, zachowanie, których używasz.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-185">If there is a parallel result between the constructor behavior and the property setting behavior in a markup extension, it does not matter which behavior you use.</span></span> <span data-ttu-id="b1f4a-186">To bardziej powszechne, użycia, aby użyć *właściwość*`=`*wartość* pary — rozszerzenia znaczników, które mają więcej niż jedną konfigurowalną właściwość, jeśli jest to jedyna, ponieważ dzięki niemu znaczników bardziej celowe i jesteś mniej prawdopodobne przypadkowo TRANSPONUJ parametry konstruktora.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-186">It is more common usage to use the *property*`=`*value* pairs for markup extensions that have more than one settable property, if only because it makes your markup more intentional and you are less likely to accidentally transpose constructor parameters.</span></span> <span data-ttu-id="b1f4a-187">(Po określeniu właściwość = para kluczy, te właściwości mogą być w dowolnej kolejności.) Ponadto nie ma żadnej gwarancji, że rozszerzenie znaczników dostarcza parametr konstruktora, który ustawia każdego z jego właściwości można ustawić jeden.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-187">(When you specify property=value pairs, those properties may be in any order.) Also, there is no guarantee that a markup extension supplies a constructor parameter that sets every one of its settable properties.</span></span> <span data-ttu-id="b1f4a-188">Na przykład <xref:System.Windows.Data.Binding> jest rozszerzeniem znacznika o wiele właściwości, które można za pomocą rozszerzenia w *właściwość*`=`*wartość* formularza, ale <xref:System.Windows.Data.Binding> obsługuje tylko dwa Konstruktory: domyślny konstruktor a, który ustawia ścieżkę początkowej.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-188">For example, <xref:System.Windows.Data.Binding> is a markup extension, with many properties that are settable through the extension in *property*`=`*value* form, but <xref:System.Windows.Data.Binding> only supports two constructors: a default constructor, and one that sets an initial path.</span></span>  
  
-   <span data-ttu-id="b1f4a-189">Literał przecinek nie można przekazać do rozszerzenia znacznika bez escapement.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-189">A literal comma cannot be passed to a markup extension without escapement.</span></span>  
  
<a name="EscapeSequences"></a>   
## <a name="escape-sequences-and-markup-extensions"></a><span data-ttu-id="b1f4a-190">Sekwencje unikowe i rozszerzeń znaczników</span><span class="sxs-lookup"><span data-stu-id="b1f4a-190">Escape Sequences and Markup Extensions</span></span>  
 <span data-ttu-id="b1f4a-191">Obsługa w XAML procesor atrybutu używa nawiasów klamrowych jako wskaźniki sekwencji rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-191">Attribute handling in a XAML processor uses the curly braces as indicators of a markup extension sequence.</span></span> <span data-ttu-id="b1f4a-192">Istnieje również możliwość utworzenia nawiasów klamrowych literału znaku wartością atrybutu w razie potrzeby, wprowadzając sekwencji unikowej za pomocą pary pustych nawiasów klamrowych, następuje nawiasów klamrowych literału.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-192">It is also possible to produce a literal curly brace character attribute value if necessary, by entering an escape sequence using an empty curly brace pair followed by the literal curly brace.</span></span> <span data-ttu-id="b1f4a-193">Zobacz [ {} ucieczki sekwencja — rozszerzenie znaczników](../../xaml-services/escape-sequence-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-193">See [{} Escape Sequence - Markup Extension](../../xaml-services/escape-sequence-markup-extension.md).</span></span>  
  
<a name="Nesting"></a>   
## <a name="nesting-markup-extensions-in-xaml-usage"></a><span data-ttu-id="b1f4a-194">Rozszerzenia znaczników w XAML użycie zagnieżdżania</span><span class="sxs-lookup"><span data-stu-id="b1f4a-194">Nesting Markup Extensions in XAML Usage</span></span>  
 <span data-ttu-id="b1f4a-195">Zagnieżdżanie wiele rozszerzeń znaczników jest obsługiwany, a każde rozszerzenie znaczników zostaną ocenione najgłębiej zagnieżdżoną najpierw.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-195">Nesting of multiple markup extensions is supported, and each markup extension will be evaluated deepest first.</span></span> <span data-ttu-id="b1f4a-196">Na przykład należy wziąć pod uwagę następujące użycie:</span><span class="sxs-lookup"><span data-stu-id="b1f4a-196">For example, consider the following usage:</span></span>  
  
```  
<Setter Property="Background"  
  Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}" />  
```  
  
 <span data-ttu-id="b1f4a-197">W tym użycie `x:Static` instrukcji jest stosowana jako pierwsza i zwraca wartość typu ciąg.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-197">In this usage, the `x:Static` statement is evaluated first and returns a string.</span></span> <span data-ttu-id="b1f4a-198">Czy ciąg jest następnie używany jako argument dla `DynamicResource`.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-198">That string is then used as the argument for `DynamicResource`.</span></span>  
  
## <a name="markup-extensions-and-property-element-syntax"></a><span data-ttu-id="b1f4a-199">Rozszerzenia znacznikowania i składnia elementu właściwości</span><span class="sxs-lookup"><span data-stu-id="b1f4a-199">Markup Extensions and Property Element Syntax</span></span>  
 <span data-ttu-id="b1f4a-200">Gdy jest używana jako elementu obiektu, który wypełnia wartością elementu właściwości, klasa rozszerzenia struktury znaczników jest wizualnie nie do odróżnienia od elementu typowe opartych na typ obiektu, który może być używana w XAML.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-200">When used as an object element that fills a property element value, a markup extension class is visually indistinguishable from a typical type-backed object element that can be used in XAML.</span></span> <span data-ttu-id="b1f4a-201">Praktyczne różnią się element typowego obiektu i rozszerzenia znaczników, rozszerzenie znaczników jest obliczane do wartości typizowane lub jest odroczone jako wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-201">The practical difference between a typical object element and a markup extension is that the markup extension is either evaluated to a typed value or deferred as an expression.</span></span> <span data-ttu-id="b1f4a-202">W związku z tym mechanizmów pod kątem błędów możliwych typów wartości właściwości rozszerzenia znaczników będą różne, podobnie jak właściwość późno wiązana są używane w innych modeli programowania.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-202">Therefore the mechanisms for any possible type errors of property values for the markup extension will be different, similar to how a late-bound property is treated in other programming models.</span></span> <span data-ttu-id="b1f4a-203">Element zwykłej obiektu zostanie obliczone dla typu dopasowania wyników właściwość docelowa, który jest ustawienie, jeśli XAML jest analizowany.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-203">An ordinary object element will be evaluated for type match against the target property it is setting when the XAML is parsed.</span></span>  
  
 <span data-ttu-id="b1f4a-204">Większość rozszerzenia znaczników, gdy są używane w składni obiektów do wypełnienia elementu właściwości, nie będzie zawierało składnia elementu zawartości lub więcej właściwości, w ramach.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-204">Most markup extensions, when used in object element syntax to fill a property element, would not have content or any further property element syntax within.</span></span> <span data-ttu-id="b1f4a-205">Ten sposób będzie zamknięcie tagu elementu obiektu i zapewniają nie podrzędnych elementów.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-205">Thus you would close the object element tag, and provide no child elements.</span></span> <span data-ttu-id="b1f4a-206">Napotkaniu każdy element obiektu przez procesor XAML, Konstruktor dla klasy, nosi nazwę, która tworzy wystąpienie obiektu utworzonego na podstawie przeanalizowany element.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-206">Whenever any object element is encountered by a XAML processor, the constructor for that class is called, which instantiates the object created from the parsed element.</span></span> <span data-ttu-id="b1f4a-207">Klasa rozszerzenia struktury znaczników nie różni się: Jeśli chcesz, rozszerzenie znaczników w składni obiektów można używać, należy podać domyślnego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-207">A markup extension class is no different: if you want your markup extension to be usable in object element syntax, you must provide a default constructor.</span></span> <span data-ttu-id="b1f4a-208">Niektóre istniejące rozszerzenia znaczników mają co najmniej jedną wartość wymagana właściwość, która musi być określona dla inicjowania skuteczne.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-208">Some existing markup extensions have at least one required property value that must be specified for effective initialization.</span></span> <span data-ttu-id="b1f4a-209">Jeśli tak, wartości tej właściwości jest zazwyczaj podawana jako atrybut właściwości w elemencie obiektu.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-209">If so, that property value is typically given as a property attribute on the object element.</span></span> <span data-ttu-id="b1f4a-210">W [Namespace XAML (x:) Funkcje języka](../../xaml-services/xaml-namespace-x-language-features.md) i [WPF XAML rozszerzenia](wpf-xaml-extensions.md) odwoływać się do strony, znaczników, które będą wyświetlane informacje dotyczące rozszerzeń, które mają wymagane właściwości (i nazwy właściwości wymagane).</span><span class="sxs-lookup"><span data-stu-id="b1f4a-210">In the [XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md) and [WPF XAML Extensions](wpf-xaml-extensions.md) reference pages, markup extensions that have required properties (and the names of required properties) will be noted.</span></span> <span data-ttu-id="b1f4a-211">Strony podręcznika udostępniamy również Jeśli składnia elementu obiektu lub Składnia atrybutu jest niedozwolona dla rozszerzenia znaczników określonej.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-211">Reference pages will also note if either object element syntax or attribute syntax is disallowed for particular markup extensions.</span></span> <span data-ttu-id="b1f4a-212">Jest istotne [x: Array — rozszerzenie znaczników](../../xaml-services/x-array-markup-extension.md), który nie obsługuje składni atrybutów zawartości tej tablicy muszą być określone w tagowania jako zawartość.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-212">A notable case is [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md), which cannot support attribute syntax because the contents of that array must be specified within the tagging as content.</span></span> <span data-ttu-id="b1f4a-213">Zawartość tablicy są obsługiwane jako obiekty ogólne, w związku z tym nie konwertera typów domyślna dla atrybutu jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-213">The array contents are handled as general objects, therefore no default type converter for the attribute is feasible.</span></span> <span data-ttu-id="b1f4a-214">Ponadto [x: Array — rozszerzenie znaczników](../../xaml-services/x-array-markup-extension.md) wymaga `type` parametru.</span><span class="sxs-lookup"><span data-stu-id="b1f4a-214">Also, [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md) requires a `type` parameter.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b1f4a-215">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="b1f4a-215">See also</span></span>
- [<span data-ttu-id="b1f4a-216">Przegląd XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="b1f4a-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="b1f4a-217">Namespace XAML (x:) Funkcje językowe</span><span class="sxs-lookup"><span data-stu-id="b1f4a-217">XAML Namespace (x:) Language Features</span></span>](../../xaml-services/xaml-namespace-x-language-features.md)
- [<span data-ttu-id="b1f4a-218">Rozszerzenia WPF XAML</span><span class="sxs-lookup"><span data-stu-id="b1f4a-218">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="b1f4a-219">StaticResource, rozszerzenie znaczników</span><span class="sxs-lookup"><span data-stu-id="b1f4a-219">StaticResource Markup Extension</span></span>](staticresource-markup-extension.md)
- [<span data-ttu-id="b1f4a-220">Rozszerzenie znaczników powiązania</span><span class="sxs-lookup"><span data-stu-id="b1f4a-220">Binding Markup Extension</span></span>](binding-markup-extension.md)
- [<span data-ttu-id="b1f4a-221">DynamicResource, rozszerzenie znaczników</span><span class="sxs-lookup"><span data-stu-id="b1f4a-221">DynamicResource Markup Extension</span></span>](dynamicresource-markup-extension.md)
- [<span data-ttu-id="b1f4a-222">x:Type, rozszerzenie znaczników</span><span class="sxs-lookup"><span data-stu-id="b1f4a-222">x:Type Markup Extension</span></span>](../../xaml-services/x-type-markup-extension.md)
