---
title: Rozszerzenia znaczników i XAML
ms.date: 03/30/2017
helpviewer_keywords:
- brace character [WPF]
- Binding markup extensions [WPF]
- RelativeSource markup extensions [WPF]
- XAML [WPF], markup extensions
- markup extensions [WPF]
- nesting extension syntax [WPF]
- curly brace characters ({})
- TemplateBinding markup extensions [WPF]
- StaticResource markup extensions [WPF]
- literal curly brace characters ({})
- characters [WPF], curly brace
- DynamicResource markup extensions [WPF]
ms.assetid: 618dc745-8b14-4886-833f-486d2254bb78
ms.openlocfilehash: c288055a27cbab75a5cdf541e539ea20e490c965
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141058"
---
# <a name="markup-extensions-and-wpf-xaml"></a><span data-ttu-id="90c1c-102">Rozszerzenia znacznikowania i WPF XAML</span><span class="sxs-lookup"><span data-stu-id="90c1c-102">Markup Extensions and WPF XAML</span></span>
<span data-ttu-id="90c1c-103">W tym temacie przedstawiono pojęcie rozszerzeń znaczników dla XAML, w tym ich reguły składni, cel i model obiektu klasy, który jest u ich podstaw.</span><span class="sxs-lookup"><span data-stu-id="90c1c-103">This topic introduces the concept of markup extensions for XAML, including their syntax rules, purpose, and the class object model that underlies them.</span></span> <span data-ttu-id="90c1c-104">Rozszerzenia znaczników są ogólną cechą języka XAML i implementacji usług XAML .NET.</span><span class="sxs-lookup"><span data-stu-id="90c1c-104">Markup extensions are a general feature of the XAML language and of the .NET implementation of XAML services.</span></span> <span data-ttu-id="90c1c-105">W tym temacie szczegółowo rozszerzenia znaczników do użycia w WPF XAML.</span><span class="sxs-lookup"><span data-stu-id="90c1c-105">This topic specifically details markup extensions for use in WPF XAML.</span></span>  

<a name="XAML_Processors_and_Markup_Extensions"></a>
## <a name="xaml-processors-and-markup-extensions"></a><span data-ttu-id="90c1c-106">Procesory XAML i rozszerzenia znaczników</span><span class="sxs-lookup"><span data-stu-id="90c1c-106">XAML Processors and Markup Extensions</span></span>  
 <span data-ttu-id="90c1c-107">Ogólnie rzecz biorąc, analizator XAML może interpretować wartość atrybutu jako ciąg literał, który można przekonwertować na element pierwotny, lub przekonwertować go na obiekt za pomocą niektórych środków.</span><span class="sxs-lookup"><span data-stu-id="90c1c-107">Generally speaking, a XAML parser can either interpret an attribute value as a literal string that can be converted to a primitive, or convert it to an object by some means.</span></span> <span data-ttu-id="90c1c-108">Jednym z takich środków jest odwoływanie się do konwertera typu; jest to udokumentowane w temacie [TypeConverters i XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-108">One such means is by referencing a type converter; this is documented in the topic [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span> <span data-ttu-id="90c1c-109">Istnieją jednak scenariusze, w których wymagane jest inne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="90c1c-109">However, there are scenarios where different behavior is required.</span></span> <span data-ttu-id="90c1c-110">Na przykład procesor XAML można poinstruować, że wartość atrybutu nie powinna spowodować nowego obiektu na wykresie obiektu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-110">For example, a XAML processor can be instructed that a value of an attribute should not result in a new object in the object graph.</span></span> <span data-ttu-id="90c1c-111">Zamiast tego atrybut powinien spowodować wykres obiektu, który sprawia, że odwołanie do już skonstruowany obiekt w innej części wykresu lub obiektu statycznego.</span><span class="sxs-lookup"><span data-stu-id="90c1c-111">Instead, the attribute should result in an object graph that makes a reference to an already constructed object in another part of the graph, or a static object.</span></span> <span data-ttu-id="90c1c-112">Innym scenariuszem jest to, że procesor XAML może być poinstruowany, aby użyć składni, która zapewnia domyślne argumenty do konstruktora obiektu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-112">Another scenario is that a XAML processor can be instructed to use a syntax that provides non-default arguments to the constructor of an object.</span></span> <span data-ttu-id="90c1c-113">Są to typy scenariuszy, w których rozszerzenie znaczników może zapewnić rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="90c1c-113">These are the types of scenarios where a markup extension can provide the solution.</span></span>  
  
<a name="Basic_Markup_Extension_Syntax"></a>
## <a name="basic-markup-extension-syntax"></a><span data-ttu-id="90c1c-114">Składnia rozszerzenia znacznika podstawowego</span><span class="sxs-lookup"><span data-stu-id="90c1c-114">Basic Markup Extension Syntax</span></span>  
 <span data-ttu-id="90c1c-115">Rozszerzenie znaczników można zaimplementować, aby zapewnić wartości właściwości w użyciu atrybutu, właściwości w użyciu elementu właściwości lub obu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-115">A markup extension can be implemented to provide values for properties in an attribute usage, properties in a property element usage, or both.</span></span>  
  
 <span data-ttu-id="90c1c-116">W przypadku podania wartości atrybutu składnia, która odróżnia sekwencję rozszerzenia znaczników od procesora XAML, jest obecnością nawiasów klamrowych otwierających i zamykających ({ i }).</span><span class="sxs-lookup"><span data-stu-id="90c1c-116">When used to provide an attribute value, the syntax that distinguishes a markup extension sequence to a XAML processor is the presence of the opening and closing curly braces ({ and }).</span></span> <span data-ttu-id="90c1c-117">Typ rozszerzenia znaczników jest następnie identyfikowany przez token ciągu bezpośrednio po otwarciu nawiasu klamrowego.</span><span class="sxs-lookup"><span data-stu-id="90c1c-117">The type of markup extension is then identified by the string token immediately following the opening curly brace.</span></span>  
  
 <span data-ttu-id="90c1c-118">W przypadku użycia w składni elementu właściwości rozszerzenie znaczników jest wizualnie takie samo jak każdy inny element używany do zapewnienia wartości elementu właściwości: deklaracja elementu XAML, która odwołuje się do klasy rozszerzenia znaczników jako elementu, ujętego w nawiasy kątowe (<>).</span><span class="sxs-lookup"><span data-stu-id="90c1c-118">When used in property element syntax, a markup extension is visually the same as any other element used to provide a property element value: a XAML element declaration that references the markup extension class as an element, enclosed within angle brackets (<>).</span></span>  
  
<a name="XAML_Defined_Markup_Extensions"></a>
## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="90c1c-119">Rozszerzenia znaczników zdefiniowanych przez XAML</span><span class="sxs-lookup"><span data-stu-id="90c1c-119">XAML-Defined Markup Extensions</span></span>  
 <span data-ttu-id="90c1c-120">Istnieje kilka rozszerzeń znaczników, które nie są specyficzne dla implementacji WPF XAML, ale zamiast tego są implementacje wewnętrznego lub funkcje XAML jako język.</span><span class="sxs-lookup"><span data-stu-id="90c1c-120">Several markup extensions exist that are not specific to the WPF implementation of XAML, but are instead implementations of intrinsics or features of XAML as a language.</span></span> <span data-ttu-id="90c1c-121">Te rozszerzenia znaczników są implementowane w zestawie System.Xaml jako część ogólnych usług XAML programu .NET Framework i znajdują się w obszarze nazw XAML języka XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="90c1c-121">These markup extensions are implemented in the System.Xaml assembly as part of the general .NET Framework XAML services, and are within the XAML language XAML namespace.</span></span> <span data-ttu-id="90c1c-122">Jeśli chodzi o typowe użycie znaczników, te rozszerzenia znaczników `x:` są zazwyczaj identyfikowalne przez prefiks w użyciu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-122">In terms of common markup usage, these markup extensions are typically identifiable by the `x:` prefix in the usage.</span></span> <span data-ttu-id="90c1c-123">Klasa <xref:System.Windows.Markup.MarkupExtension> podstawowa (również zdefiniowana w systemie.Xaml) udostępnia wzorzec, który wszystkie rozszerzenia znaczników powinny być używane w celu zapewnienia obsługi w czytnikach XAML i modułach zapisujących XAML, w tym w WPF XAML.</span><span class="sxs-lookup"><span data-stu-id="90c1c-123">The <xref:System.Windows.Markup.MarkupExtension> base class (also defined in System.Xaml) provides the pattern that all markup extensions should use in order to be supported in XAML readers and XAML writers, including in WPF XAML.</span></span>  
  
- <span data-ttu-id="90c1c-124">`x:Type`dostarcza <xref:System.Type> obiekt dla nazwanego typu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-124">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="90c1c-125">Ta funkcja jest najczęściej używana w stylach i szablonach.</span><span class="sxs-lookup"><span data-stu-id="90c1c-125">This facility is used most frequently in styles and templates.</span></span> <span data-ttu-id="90c1c-126">Aby uzyskać szczegółowe informacje, zobacz [x:Wpisz rozszerzenie znaczników](../../../desktop-wpf/xaml-services/xtype-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-126">For details, see [x:Type Markup Extension](../../../desktop-wpf/xaml-services/xtype-markup-extension.md).</span></span>  
  
- <span data-ttu-id="90c1c-127">`x:Static`tworzy wartości statyczne.</span><span class="sxs-lookup"><span data-stu-id="90c1c-127">`x:Static` produces static values.</span></span> <span data-ttu-id="90c1c-128">Wartości pochodzą z jednostek kodu typu wartości, które nie są bezpośrednio typu wartości właściwości docelowej, ale mogą być oceniane do tego typu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-128">The values come from value-type code entities that are not directly the type of a target property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="90c1c-129">Aby uzyskać szczegółowe informacje, zobacz [x:Static Markup Extension](../../../desktop-wpf/xaml-services/xstatic-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-129">For details, see [x:Static Markup Extension](../../../desktop-wpf/xaml-services/xstatic-markup-extension.md).</span></span>  
  
- <span data-ttu-id="90c1c-130">`x:Null`określa `null` jako wartość właściwości i może być używany dla atrybutów lub wartości elementu właściwości.</span><span class="sxs-lookup"><span data-stu-id="90c1c-130">`x:Null` specifies `null` as a value for a property and can be used either for attributes or property element values.</span></span> <span data-ttu-id="90c1c-131">Aby uzyskać szczegółowe informacje, zobacz [x:Rozszerzenie znaczników zerowych](../../../desktop-wpf/xaml-services/xnull-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-131">For details, see [x:Null Markup Extension](../../../desktop-wpf/xaml-services/xnull-markup-extension.md).</span></span>  
  
- <span data-ttu-id="90c1c-132">`x:Array`zapewnia obsługę tworzenia tablic ogólnych w składni XAML, w przypadkach, gdy obsługa kolekcji zapewniana przez podstawowe elementy WPF i modele kontroli nie jest celowo używana.</span><span class="sxs-lookup"><span data-stu-id="90c1c-132">`x:Array` provides support for creation of general arrays in XAML syntax, for cases where the collection support provided by WPF base elements and control models is deliberately not used.</span></span> <span data-ttu-id="90c1c-133">Aby uzyskać szczegółowe informacje, zobacz [x:Rozszerzenie znaczników tablicy](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-133">For details, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="90c1c-134">`x:` Prefiks jest używany do typowego mapowania przestrzeni nazw XAML wewnętrznego języka XAML w elemencie głównym pliku lub produkcji XAML.</span><span class="sxs-lookup"><span data-stu-id="90c1c-134">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language intrinsics, in the root element of a XAML file or production.</span></span> <span data-ttu-id="90c1c-135">Na przykład szablony programu Visual Studio dla aplikacji WPF inicjują plik XAML przy użyciu tego `x:` mapowania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-135">For example, the Visual Studio templates for WPF applications initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="90c1c-136">Można wybrać inny token prefiksu w mapowaniu przestrzeni nazw XAML, ale w tej dokumentacji przyjęto domyślne `x:` mapowanie jako sposób identyfikowania tych jednostek, które są zdefiniowaną częścią obszaru nazw XAML dla języka XAML, w przeciwieństwie do domyślnego obszaru nazw WPF lub innych obszarów nazw XAML niezwiązanych z określoną strukturą.</span><span class="sxs-lookup"><span data-stu-id="90c1c-136">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML namespace for the XAML language, as opposed to the WPF default namespace or other XAML namespaces not related to a specific framework.</span></span>  
  
<a name="WPF_Specific_Markup_Extensions"></a>
## <a name="wpf-specific-markup-extensions"></a><span data-ttu-id="90c1c-137">Rozszerzenia znaczników specyficznych dla WPF</span><span class="sxs-lookup"><span data-stu-id="90c1c-137">WPF-Specific Markup Extensions</span></span>  
 <span data-ttu-id="90c1c-138">Najczęstsze rozszerzenia znaczników używane w programowaniu WPF są`StaticResource` te, które obsługują odwołania do zasobów ( i `DynamicResource`), i te, które obsługują powiązanie danych (`Binding`).</span><span class="sxs-lookup"><span data-stu-id="90c1c-138">The most common markup extensions used in WPF programming are those that support resource references (`StaticResource` and `DynamicResource`), and those that support data binding (`Binding`).</span></span>  
  
- <span data-ttu-id="90c1c-139">`StaticResource`zapewnia wartość właściwości, zastępując wartość już zdefiniowanego zasobu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-139">`StaticResource` provides a value for a property by substituting the value of an already defined resource.</span></span> <span data-ttu-id="90c1c-140">Ocena `StaticResource` jest ostatecznie dokonywana w czasie ładowania XAML i nie ma dostępu do wykresu obiektu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-140">A `StaticResource` evaluation is ultimately made at XAML load time and does not have access to the object graph at run time.</span></span> <span data-ttu-id="90c1c-141">Aby uzyskać szczegółowe informacje, zobacz [StaticResource Markup Extension](staticresource-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-141">For details, see [StaticResource Markup Extension](staticresource-markup-extension.md).</span></span>  
  
- <span data-ttu-id="90c1c-142">`DynamicResource`zapewnia wartość właściwości przez odroczenie tej wartości, aby być odwołaniem w czasie wykonywania do zasobu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-142">`DynamicResource` provides a value for a property by deferring that value to be a run-time reference to a resource.</span></span> <span data-ttu-id="90c1c-143">Odwołanie do zasobu dynamicznego wymusza nowe wyszukiwanie za każdym razem, gdy taki zasób jest dostępny i ma dostęp do wykresu obiektu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-143">A dynamic resource reference forces a new lookup each time that such a resource is accessed and has access to the object graph at run time.</span></span> <span data-ttu-id="90c1c-144">Aby uzyskać ten dostęp, `DynamicResource` koncepcja jest obsługiwana przez właściwości zależności w systemie właściwości WPF i oceniane wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="90c1c-144">In order to get this access, `DynamicResource` concept is supported by dependency properties in the WPF property system, and evaluated expressions.</span></span> <span data-ttu-id="90c1c-145">W związku z `DynamicResource` tym można używać tylko dla obiektu docelowego właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="90c1c-145">Therefore you can only use `DynamicResource` for a dependency property target.</span></span> <span data-ttu-id="90c1c-146">Aby uzyskać szczegółowe informacje, zobacz [Rozszerzenie znaczników dynamicresource](dynamicresource-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-146">For details, see [DynamicResource Markup Extension](dynamicresource-markup-extension.md).</span></span>  
  
- <span data-ttu-id="90c1c-147">`Binding`zapewnia wartość powiązaną z danymi dla właściwości, przy użyciu kontekstu danych, który ma zastosowanie do obiektu nadrzędnego w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-147">`Binding` provides a data bound value for a property, using the data context that applies to the parent object at run time.</span></span> <span data-ttu-id="90c1c-148">To rozszerzenie znaczników jest stosunkowo złożone, ponieważ umożliwia istotne składnię w ykań do określania powiązania danych.</span><span class="sxs-lookup"><span data-stu-id="90c1c-148">This markup extension is relatively complex, because it enables a substantial inline syntax for specifying a data binding.</span></span> <span data-ttu-id="90c1c-149">Aby uzyskać szczegółowe informacje, zobacz [Rozszerzenie znaczników powiązania](binding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-149">For details, see [Binding Markup Extension](binding-markup-extension.md).</span></span>  
  
- <span data-ttu-id="90c1c-150">`RelativeSource`zawiera informacje źródłowe dla, <xref:System.Windows.Data.Binding> które można poruszać się kilka możliwych relacji w drzewie obiektów w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-150">`RelativeSource` provides source information for a <xref:System.Windows.Data.Binding> that can navigate several possible relationships in the run-time object tree.</span></span> <span data-ttu-id="90c1c-151">Zapewnia to specjalistyczne pozyskiwanie powiązań, które są tworzone w szablonach wielofunkcyjnych lub tworzone w kodzie bez pełnej wiedzy otaczającego drzewa obiektów.</span><span class="sxs-lookup"><span data-stu-id="90c1c-151">This provides specialized sourcing for bindings that are created in multi-use templates or created in code without full knowledge of the surrounding object tree.</span></span> <span data-ttu-id="90c1c-152">Aby uzyskać szczegółowe informacje, zobacz [RelativeSource MarkupExtension](relativesource-markupextension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-152">For details, see [RelativeSource MarkupExtension](relativesource-markupextension.md).</span></span>  
  
- <span data-ttu-id="90c1c-153">`TemplateBinding`umożliwia szablon formantu do używania wartości dla właściwości szablonu, które pochodzą z właściwości zdefiniowanych przez model obiektu klasy, która będzie używać szablonu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-153">`TemplateBinding` enables a control template to use values for templated properties that come from object-model-defined properties of the class that will use the template.</span></span> <span data-ttu-id="90c1c-154">Innymi słowy właściwość w definicji szablonu można uzyskać dostęp do kontekstu, który istnieje tylko po zastosowaniu szablonu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-154">In other words, the property within the template definition can access a context that only exists once the template is applied.</span></span> <span data-ttu-id="90c1c-155">Aby uzyskać szczegółowe informacje, zobacz [Rozszerzenie znaczników przywiązywania szablonu.](templatebinding-markup-extension.md)</span><span class="sxs-lookup"><span data-stu-id="90c1c-155">For details, see [TemplateBinding Markup Extension](templatebinding-markup-extension.md).</span></span> <span data-ttu-id="90c1c-156">Aby uzyskać więcej informacji `TemplateBinding`na temat praktycznego stosowania programu , zobacz [Stylowanie za pomocą przykładu ControlTemplates](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span><span class="sxs-lookup"><span data-stu-id="90c1c-156">For more information on the practical use of `TemplateBinding`, see [Styling with ControlTemplates Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span></span>  
  
- <span data-ttu-id="90c1c-157">`ColorConvertedBitmap`obsługuje stosunkowo zaawansowany scenariusz obrazowania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-157">`ColorConvertedBitmap` supports a relatively advanced imaging scenario.</span></span> <span data-ttu-id="90c1c-158">Aby uzyskać szczegółowe informacje, zobacz [ColorConvertedBitmap Markup Extension](colorconvertedbitmap-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-158">For details, see [ColorConvertedBitmap Markup Extension](colorconvertedbitmap-markup-extension.md).</span></span>  
  
- <span data-ttu-id="90c1c-159">`ComponentResourceKey`i `ThemeDictionary` obsługuje aspekty wyszukiwania zasobów, szczególnie dla zasobów i tematów, które są pakowane z formantami niestandardowymi.</span><span class="sxs-lookup"><span data-stu-id="90c1c-159">`ComponentResourceKey` and `ThemeDictionary` support aspects of resource lookup, particularly for resources and themes that are packaged with custom controls.</span></span> <span data-ttu-id="90c1c-160">Aby uzyskać więcej informacji, zobacz [ComponentResourceKey Markup Extension](componentresourcekey-markup-extension.md), [ThemeDictionary Markup Extension](themedictionary-markup-extension.md)lub [Control Authoring Overview](../controls/control-authoring-overview.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-160">For more information, see [ComponentResourceKey Markup Extension](componentresourcekey-markup-extension.md), [ThemeDictionary Markup Extension](themedictionary-markup-extension.md), or [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>  
  
<a name="StarExtension"></a>
## <a name="extension-classes"></a><span data-ttu-id="90c1c-161">\*Klasy rozszerzeń</span><span class="sxs-lookup"><span data-stu-id="90c1c-161">\*Extension Classes</span></span>  
 <span data-ttu-id="90c1c-162">W przypadku ogólnego języka XAML i wyszerzeń znaczników specyficznych dla WPF zachowanie każdego rozszerzenia `*Extension` znaczników jest <xref:System.Windows.Markup.MarkupExtension>identyfikowane z <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> procesorem XAML za pośrednictwem klasy, która wywodzi się z metody i zapewnia implementację metody.</span><span class="sxs-lookup"><span data-stu-id="90c1c-162">For both the general XAML language and WPF-specific markup extensions, the behavior of each markup extension is identified to a XAML processor through a `*Extension` class that derives from <xref:System.Windows.Markup.MarkupExtension>, and provides an implementation of the <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> method.</span></span> <span data-ttu-id="90c1c-163">Ta metoda na każdym rozszerzeniu zapewnia obiekt, który jest zwracany podczas oceny rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-163">This method on each extension provides the object that is returned when the markup extension is evaluated.</span></span> <span data-ttu-id="90c1c-164">Zwrócony obiekt jest zazwyczaj oceniane na podstawie różnych tokenów ciąg, które są przekazywane do rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-164">The returned object is typically evaluated based on the various string tokens that are passed to the markup extension.</span></span>  
  
 <span data-ttu-id="90c1c-165">Na przykład <xref:System.Windows.StaticResourceExtension> klasa zapewnia implementacji powierzchni rzeczywistego wyszukiwania <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> zasobów, tak aby jego implementacja zwraca obiekt, który jest wymagany, z danych wejściowych tej konkretnej implementacji jest ciąg, który jest używany do wyszukiwania zasobu przez jego `x:Key`.</span><span class="sxs-lookup"><span data-stu-id="90c1c-165">For example, the <xref:System.Windows.StaticResourceExtension> class provides the surface implementation of actual resource lookup so that its <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> implementation returns the object that is requested, with the input of that particular implementation being a string that is used to look up the resource by its `x:Key`.</span></span> <span data-ttu-id="90c1c-166">Wiele z tych szczegółów implementacji jest nieistotne, jeśli używasz istniejącego rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-166">Much of this implementation detail is unimportant if you are using an existing markup extension.</span></span>  
  
 <span data-ttu-id="90c1c-167">Niektóre rozszerzenia znaczników nie używają argumentów tokenu ciągu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-167">Some markup extensions do not use string token arguments.</span></span> <span data-ttu-id="90c1c-168">Jest to spowodowane zwróceniem wartości statycznej lub spójnej lub ponieważ kontekst dla wartości, która powinna `serviceProvider` zostać zwrócona, jest dostępny za pośrednictwem jednej z usług przekazanych przez parametr.</span><span class="sxs-lookup"><span data-stu-id="90c1c-168">This is either because they return a static or consistent value, or because context for what value should be returned is available through one of the services passed through the `serviceProvider` parameter.</span></span>  
  
 <span data-ttu-id="90c1c-169">Wzorzec `*Extension` nazewnictwa jest dla wygody i spójności.</span><span class="sxs-lookup"><span data-stu-id="90c1c-169">The `*Extension` naming pattern is for convenience and consistency.</span></span> <span data-ttu-id="90c1c-170">Nie jest konieczne, aby procesor XAML zidentyfikować tę klasę jako obsługę rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-170">It is not necessary in order for a XAML processor to identify that class as support for a markup extension.</span></span> <span data-ttu-id="90c1c-171">Tak długo, jak codebase zawiera System.Xaml i używa .NET Framework XAML Services implementacje, wszystko, co jest <xref:System.Windows.Markup.MarkupExtension> niezbędne do rozpoznania jako rozszerzenie znaczników XAML jest pochodzić z i do obsługi składni konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="90c1c-171">So long as your codebase includes System.Xaml and uses .NET Framework XAML Services implementations, all that is necessary to be recognized as a XAML markup extension is to derive from <xref:System.Windows.Markup.MarkupExtension> and to support a construction syntax.</span></span> <span data-ttu-id="90c1c-172">WPF WPF definiuje klasy włączania rozszerzenia znaczników, które nie są zgodne ze wzorcem `*Extension` nazewnictwa, na przykład <xref:System.Windows.Data.Binding>.</span><span class="sxs-lookup"><span data-stu-id="90c1c-172">WPF defines markup extension-enabling classes that do not follow the `*Extension` naming pattern, for example <xref:System.Windows.Data.Binding>.</span></span> <span data-ttu-id="90c1c-173">Zazwyczaj powodem tego jest, że klasa obsługuje scenariusze poza czystej obsługi rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-173">Typically the reason for this is that the class supports scenarios beyond pure markup extension support.</span></span> <span data-ttu-id="90c1c-174">W przypadku <xref:System.Windows.Data.Binding>, że klasa obsługuje dostęp w czasie wykonywania do metod i właściwości obiektu dla scenariuszy, które nie mają nic wspólnego z XAML.</span><span class="sxs-lookup"><span data-stu-id="90c1c-174">In the case of <xref:System.Windows.Data.Binding>, that class supports run-time access to methods and properties of the object for scenarios that have nothing to do with XAML.</span></span>  
  
### <a name="extension-class-interpretation-of-initialization-text"></a><span data-ttu-id="90c1c-175">Interpretacja klasy rozszerzenia tekstu inicjowania</span><span class="sxs-lookup"><span data-stu-id="90c1c-175">Extension Class Interpretation of Initialization Text</span></span>  
 <span data-ttu-id="90c1c-176">Tokeny ciągu po nazwie rozszerzenia znaczników i nadal w nawiasach klamrowych są interpretowane przez procesor XAML w jeden z następujących sposobów:</span><span class="sxs-lookup"><span data-stu-id="90c1c-176">The string tokens following the markup extension name and still within the braces are interpreted by a XAML processor in one of the following ways:</span></span>  
  
- <span data-ttu-id="90c1c-177">Przecinek zawsze reprezentuje separator lub ogranicznik poszczególnych tokenów.</span><span class="sxs-lookup"><span data-stu-id="90c1c-177">A comma always represents the separator or delimiter of individual tokens.</span></span>  
  
- <span data-ttu-id="90c1c-178">Jeśli poszczególne tokeny oddzielone nie zawierają żadnych znaków równości, każdy token jest traktowany jako argument konstruktora.</span><span class="sxs-lookup"><span data-stu-id="90c1c-178">If the individual separated tokens do not contain any equals signs, each token is treated as a constructor argument.</span></span> <span data-ttu-id="90c1c-179">Każdy parametr konstruktora musi być podany jako typ oczekiwany przez ten podpis i w odpowiedniej kolejności oczekiwanej przez ten podpis.</span><span class="sxs-lookup"><span data-stu-id="90c1c-179">Each constructor parameter must be given as the type expected by that signature, and in the proper order expected by that signature.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="90c1c-180">Procesor XAML musi wywołać konstruktora, który pasuje do liczby argumentów liczby par.</span><span class="sxs-lookup"><span data-stu-id="90c1c-180">A XAML processor must call the constructor that matches the argument count of the number of pairs.</span></span> <span data-ttu-id="90c1c-181">Z tego powodu jeśli implementujesz niestandardowe rozszerzenie znaczników, nie podaj wielu konstruktorów z tą samą liczbą argumentów.</span><span class="sxs-lookup"><span data-stu-id="90c1c-181">For this reason, if you are implementing a custom markup extension, do not provide multiple constructors with the same argument count.</span></span> <span data-ttu-id="90c1c-182">Zachowanie procesora XAML zachowuje się, jeśli istnieje więcej niż jedna ścieżka konstruktora rozszerzenia znaczników z tą samą liczbą parametrów, ale należy przewidzieć, że procesor XAML może zgłaszać wyjątek dotyczący użycia, jeśli taka sytuacja występuje w definicje typów rozszerzeń znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-182">The behavior for how a XAML processor behaves if more than one markup extension constructor path with the same parameter count exists is not defined, but you should anticipate that a XAML processor is permitted to throw an exception on usage if this situation exists in the markup extension type definitions.</span></span>  
  
- <span data-ttu-id="90c1c-183">Jeśli poszczególne oddzielone tokeny zawierają znaki równe, procesor XAML najpierw wywołuje konstruktora bez parametrów dla rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-183">If the individual separated tokens contain equals signs, then a XAML processor first calls the parameterless constructor for the markup extension.</span></span> <span data-ttu-id="90c1c-184">Następnie każda para name=value jest interpretowana jako nazwa właściwości, która istnieje w rozszerzeniu znaczników i wartość do przypisania do tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="90c1c-184">Then, each name=value pair is interpreted as a property name that exists on the markup extension, and a value to assign to that property.</span></span>  
  
- <span data-ttu-id="90c1c-185">Jeśli istnieje równoległy wynik między zachowaniem konstruktora i zachowanie ustawienie właściwości w rozszerzeniu znaczników, nie ma znaczenia, które zachowanie używasz.</span><span class="sxs-lookup"><span data-stu-id="90c1c-185">If there is a parallel result between the constructor behavior and the property setting behavior in a markup extension, it does not matter which behavior you use.</span></span> <span data-ttu-id="90c1c-186">Jest bardziej powszechne użycie do korzystania z par*wartości* *właściwości*`=`dla rozszerzeń znaczników, które mają więcej niż jedną właściwość settable, jeśli tylko dlatego, że sprawia, że znaczników bardziej zamierzone i są mniej prawdopodobne, aby przypadkowo transponować parametry konstruktora.</span><span class="sxs-lookup"><span data-stu-id="90c1c-186">It is more common usage to use the *property*`=`*value* pairs for markup extensions that have more than one settable property, if only because it makes your markup more intentional and you are less likely to accidentally transpose constructor parameters.</span></span> <span data-ttu-id="90c1c-187">(Po określeniu par property=value te właściwości mogą być w dowolnej kolejności). Ponadto nie ma żadnej gwarancji, że rozszerzenie znaczników dostarcza parametr konstruktora, który ustawia każdą z jego właściwości settable.</span><span class="sxs-lookup"><span data-stu-id="90c1c-187">(When you specify property=value pairs, those properties may be in any order.) Also, there is no guarantee that a markup extension supplies a constructor parameter that sets every one of its settable properties.</span></span> <span data-ttu-id="90c1c-188">Na przykład <xref:System.Windows.Data.Binding> jest rozszerzenie znaczników, z wielu właściwości, które są settable <xref:System.Windows.Data.Binding> za pośrednictwem rozszerzenia w postaci*wartości* *właściwości,*`=`ale obsługuje tylko dwa konstruktory: konstruktor bez parametrów i jeden, który ustawia ścieżkę początkową.</span><span class="sxs-lookup"><span data-stu-id="90c1c-188">For example, <xref:System.Windows.Data.Binding> is a markup extension, with many properties that are settable through the extension in *property*`=`*value* form, but <xref:System.Windows.Data.Binding> only supports two constructors: a parameterless constructor, and one that sets an initial path.</span></span>  
  
- <span data-ttu-id="90c1c-189">Przecinek dosłowny nie może być przekazany do rozszerzenia znaczników bez wychwytu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-189">A literal comma cannot be passed to a markup extension without escapement.</span></span>  
  
<a name="EscapeSequences"></a>
## <a name="escape-sequences-and-markup-extensions"></a><span data-ttu-id="90c1c-190">Sekwencje ucieczki i rozszerzenia znaczników</span><span class="sxs-lookup"><span data-stu-id="90c1c-190">Escape Sequences and Markup Extensions</span></span>  
 <span data-ttu-id="90c1c-191">Obsługa atrybutów w procesorze XAML używa nawiasów klamrowych jako wskaźników sekwencji rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-191">Attribute handling in a XAML processor uses the curly braces as indicators of a markup extension sequence.</span></span> <span data-ttu-id="90c1c-192">Istnieje również możliwość uzyskania dosłownej wartości atrybutu nawiasu klamrowego, jeśli to konieczne, wprowadzając sekwencję ucieczki przy użyciu pustej pary nawiasów klamrowych, po której następuje dosłowny nawias klamrowy.</span><span class="sxs-lookup"><span data-stu-id="90c1c-192">It is also possible to produce a literal curly brace character attribute value if necessary, by entering an escape sequence using an empty curly brace pair followed by the literal curly brace.</span></span> <span data-ttu-id="90c1c-193">Zobacz [ {} Sekwencja ucieczki — rozszerzenie znaczników](../../../desktop-wpf/xaml-services/escape-sequence-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="90c1c-193">See [{} Escape Sequence - Markup Extension](../../../desktop-wpf/xaml-services/escape-sequence-markup-extension.md).</span></span>  
  
<a name="Nesting"></a>
## <a name="nesting-markup-extensions-in-xaml-usage"></a><span data-ttu-id="90c1c-194">Zagnieżdżanie rozszerzeń znaczników w użyciu XAML</span><span class="sxs-lookup"><span data-stu-id="90c1c-194">Nesting Markup Extensions in XAML Usage</span></span>  
 <span data-ttu-id="90c1c-195">Zagnieżdżanie wielu rozszerzeń znaczników jest obsługiwane, a każde rozszerzenie znaczników zostanie najpierw ocenione najgłębniej.</span><span class="sxs-lookup"><span data-stu-id="90c1c-195">Nesting of multiple markup extensions is supported, and each markup extension will be evaluated deepest first.</span></span> <span data-ttu-id="90c1c-196">Rozważmy na przykład następujące użycie:</span><span class="sxs-lookup"><span data-stu-id="90c1c-196">For example, consider the following usage:</span></span>  
  
```xaml  
<Setter Property="Background"  
  Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}" />  
```  
  
 <span data-ttu-id="90c1c-197">W tym użyciu `x:Static` instrukcja jest oceniane najpierw i zwraca ciąg.</span><span class="sxs-lookup"><span data-stu-id="90c1c-197">In this usage, the `x:Static` statement is evaluated first and returns a string.</span></span> <span data-ttu-id="90c1c-198">Ten ciąg jest następnie używany `DynamicResource`jako argument dla .</span><span class="sxs-lookup"><span data-stu-id="90c1c-198">That string is then used as the argument for `DynamicResource`.</span></span>  
  
## <a name="markup-extensions-and-property-element-syntax"></a><span data-ttu-id="90c1c-199">Rozszerzenia znaczników i składnia elementu właściwości</span><span class="sxs-lookup"><span data-stu-id="90c1c-199">Markup Extensions and Property Element Syntax</span></span>  
 <span data-ttu-id="90c1c-200">Gdy jest używany jako element obiektu, który wypełnia wartość elementu właściwości, klasa rozszerzenia znaczników jest wizualnie nie do odróżnienia od typowego elementu obiektu, który może być używany w XAML.</span><span class="sxs-lookup"><span data-stu-id="90c1c-200">When used as an object element that fills a property element value, a markup extension class is visually indistinguishable from a typical type-backed object element that can be used in XAML.</span></span> <span data-ttu-id="90c1c-201">Praktyczna różnica między typowym elementem obiektu a rozszerzeniem znaczników polega na tym, że rozszerzenie znaczników jest oceniane na wartość wpisaną lub odroczone jako wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="90c1c-201">The practical difference between a typical object element and a markup extension is that the markup extension is either evaluated to a typed value or deferred as an expression.</span></span> <span data-ttu-id="90c1c-202">W związku z tym mechanizmy dla wszystkich możliwych błędów typu wartości właściwości dla rozszerzenia znaczników będą różne, podobnie jak późno powiązana właściwość jest traktowana w innych modelach programowania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-202">Therefore the mechanisms for any possible type errors of property values for the markup extension will be different, similar to how a late-bound property is treated in other programming models.</span></span> <span data-ttu-id="90c1c-203">Zwykły element obiektu będą oceniane dla dopasowania typu do właściwości docelowej jest ustawienie, gdy XAML jest analizowany.</span><span class="sxs-lookup"><span data-stu-id="90c1c-203">An ordinary object element will be evaluated for type match against the target property it is setting when the XAML is parsed.</span></span>  
  
 <span data-ttu-id="90c1c-204">Większość rozszerzeń znaczników, gdy jest używana w składni elementu obiektu do wypełnienia elementu właściwości, nie będzie miała zawartości ani żadnej dalszej składni elementu właściwości w obrębie.</span><span class="sxs-lookup"><span data-stu-id="90c1c-204">Most markup extensions, when used in object element syntax to fill a property element, would not have content or any further property element syntax within.</span></span> <span data-ttu-id="90c1c-205">W związku z tym należy zamknąć znacznik elementu obiektu i nie podaj żadnych elementów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="90c1c-205">Thus you would close the object element tag, and provide no child elements.</span></span> <span data-ttu-id="90c1c-206">Za każdym razem, gdy dowolny element obiektu zostanie napotkany przez procesor XAML, wywoływany jest konstruktor dla tej klasy, który tworzy wystąpienia obiektu utworzonego na podstawie analizowanego elementu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-206">Whenever any object element is encountered by a XAML processor, the constructor for that class is called, which instantiates the object created from the parsed element.</span></span> <span data-ttu-id="90c1c-207">Klasa rozszerzenia znaczników nie różni się inaczej: jeśli rozszerzenie znaczników ma być użyteczne w składni elementu obiektu, musisz podać konstruktor bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="90c1c-207">A markup extension class is no different: if you want your markup extension to be usable in object element syntax, you must provide a parameterless constructor.</span></span> <span data-ttu-id="90c1c-208">Niektóre istniejące rozszerzenia znaczników mają co najmniej jedną wymaganą wartość właściwości, która musi być określona dla efektywnego inicjowania.</span><span class="sxs-lookup"><span data-stu-id="90c1c-208">Some existing markup extensions have at least one required property value that must be specified for effective initialization.</span></span> <span data-ttu-id="90c1c-209">Jeśli tak, ta wartość właściwości jest zazwyczaj podana jako atrybut właściwości w elemencie obiektu.</span><span class="sxs-lookup"><span data-stu-id="90c1c-209">If so, that property value is typically given as a property attribute on the object element.</span></span> <span data-ttu-id="90c1c-210">W [obszarze nazw XAML (x:) Funkcje języka](../../../desktop-wpf/xaml-services/namespace-language-features.md) i [WPF XAML Rozszerzenia](wpf-xaml-extensions.md) stron odwołania, rozszerzenia znaczników, które mają wymagane właściwości (i nazwy wymaganych właściwości) zostaną odnotowane.</span><span class="sxs-lookup"><span data-stu-id="90c1c-210">In the [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md) and [WPF XAML Extensions](wpf-xaml-extensions.md) reference pages, markup extensions that have required properties (and the names of required properties) will be noted.</span></span> <span data-ttu-id="90c1c-211">Strony odwołań będą również pamiętać, jeśli składnia elementu obiektu lub składnia atrybutów jest niedozwolona dla określonych rozszerzeń znaczników.</span><span class="sxs-lookup"><span data-stu-id="90c1c-211">Reference pages will also note if either object element syntax or attribute syntax is disallowed for particular markup extensions.</span></span> <span data-ttu-id="90c1c-212">Godnym uwagi przypadkiem jest [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md), które nie obsługuje składni atrybutów, ponieważ zawartość tej tablicy musi być określona w tagowaniu jako zawartość.</span><span class="sxs-lookup"><span data-stu-id="90c1c-212">A notable case is [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md), which cannot support attribute syntax because the contents of that array must be specified within the tagging as content.</span></span> <span data-ttu-id="90c1c-213">Zawartość tablicy są obsługiwane jako obiekty ogólne, w związku z tym nie domyślny konwerter typu dla atrybutu jest możliwe.</span><span class="sxs-lookup"><span data-stu-id="90c1c-213">The array contents are handled as general objects, therefore no default type converter for the attribute is feasible.</span></span> <span data-ttu-id="90c1c-214">Ponadto [x:Rozszerzenie znaczników tablicy](../../../desktop-wpf/xaml-services/xarray-markup-extension.md) wymaga parametru. `type`</span><span class="sxs-lookup"><span data-stu-id="90c1c-214">Also, [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md) requires a `type` parameter.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="90c1c-215">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="90c1c-215">See also</span></span>

- [<span data-ttu-id="90c1c-216">Przegląd XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="90c1c-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="90c1c-217">Przestrzeń nazwa (x:) XAML — Funkcje językowe</span><span class="sxs-lookup"><span data-stu-id="90c1c-217">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="90c1c-218">Rozszerzenia WPF XAML</span><span class="sxs-lookup"><span data-stu-id="90c1c-218">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="90c1c-219">StaticResource — Rozszerzenie znaczników</span><span class="sxs-lookup"><span data-stu-id="90c1c-219">StaticResource Markup Extension</span></span>](staticresource-markup-extension.md)
- [<span data-ttu-id="90c1c-220">Rozszerzenie znaczników powiązania</span><span class="sxs-lookup"><span data-stu-id="90c1c-220">Binding Markup Extension</span></span>](binding-markup-extension.md)
- [<span data-ttu-id="90c1c-221">DynamicResource — Rozszerzenie znaczników</span><span class="sxs-lookup"><span data-stu-id="90c1c-221">DynamicResource Markup Extension</span></span>](dynamicresource-markup-extension.md)
- [<span data-ttu-id="90c1c-222">x:Type — Rozszerzenie znaczników</span><span class="sxs-lookup"><span data-stu-id="90c1c-222">x:Type Markup Extension</span></span>](../../../desktop-wpf/xaml-services/xtype-markup-extension.md)
