---
title: Model wątkowości
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 9e8bcd4503ec840e46022a55cc08dc0610eaa60b
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/02/2018
ms.locfileid: "43468214"
---
# <a name="threading-model"></a><span data-ttu-id="59213-102">Model wątkowości</span><span class="sxs-lookup"><span data-stu-id="59213-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="59213-103"> Służy do zapisywania deweloperów trudności wątkowości.</span><span class="sxs-lookup"><span data-stu-id="59213-103"> is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="59213-104">W rezultacie, większość [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] deweloperzy nie będą musieli napisać interfejs, który korzysta z więcej niż jeden wątek.</span><span class="sxs-lookup"><span data-stu-id="59213-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="59213-105">Ponieważ złożonej i trudnej do debugowania programów wielowątkowych, należy ich unikać gdy istnieje jednowątkowe rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="59213-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="59213-106">Niezależnie od tego, jak dobrze zaprojektowana, jednak nie [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework nigdy nie będą mogli stanowią rozwiązanie jednowątkowe dla każdego rodzaju problemu.</span><span class="sxs-lookup"><span data-stu-id="59213-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="59213-107"> pochodzi Zamknij, ale nadal istnieją sytuacje, gdy wiele wątków poprawić [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] wydajności aplikacji lub czas odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="59213-107"> comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="59213-108">Po omówieniu niektóre materiały tła, w tym dokumencie analizuje niektóre z tych sytuacji, a następnie uzna, za pomocą dyskusję na temat niektórych informacji niższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="59213-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  
  

  
> [!NOTE]
>  <span data-ttu-id="59213-109">W tym temacie omówiono wielowątkowości za pomocą <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> metodę wywołania asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="59213-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="59213-110">Asynchroniczne wywołania można również ustawić, wywołując <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> metody, która zająć <xref:System.Action> lub <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="59213-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="59213-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> Metoda zwraca <xref:System.Windows.Threading.DispatcherOperation> lub <xref:System.Windows.Threading.DispatcherOperation%601>, który ma <xref:System.Windows.Threading.DispatcherOperation.Task%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="59213-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="59213-112">Możesz użyć `await` — słowo kluczowe z oboma <xref:System.Windows.Threading.DispatcherOperation> lub skojarzonego <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="59213-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="59213-113">Jeśli musisz czekać synchronicznie <xref:System.Threading.Tasks.Task> zwracanym przez <xref:System.Windows.Threading.DispatcherOperation> lub <xref:System.Windows.Threading.DispatcherOperation%601>, wywołaj <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> — metoda rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="59213-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="59213-114">Wywoływanie <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> spowoduje zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="59213-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="59213-115">Aby uzyskać więcej informacji o korzystaniu z <xref:System.Threading.Tasks.Task> do wykonywania operacji asynchronicznych, zobacz równoległość zadań.</span><span class="sxs-lookup"><span data-stu-id="59213-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="59213-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> Metoda ta ma również przeciążeń, które przyjmują <xref:System.Action> lub <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="59213-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="59213-117">Możesz użyć <xref:System.Windows.Threading.Dispatcher.Invoke%2A> synchroniczne metody wywołania, przekazując delegata, <xref:System.Action> lub <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="59213-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="59213-118">Omówienie i Dyspozytor</span><span class="sxs-lookup"><span data-stu-id="59213-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="59213-119">Zazwyczaj [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacje są uruchamiane z dwoma wątkami: jeden do obsługi renderowania i inny wpis dla zarządzania [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="59213-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="59213-120">Wątek renderowania skutecznie uruchomiony w trybie ukrytym w tle podczas [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku odbiera dane wejściowe, obsługuje zdarzenia, rysują ekranu i uruchamia kod aplikacji.</span><span class="sxs-lookup"><span data-stu-id="59213-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="59213-121">Większość aplikacji używa pojedynczego [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątków, mimo że w niektórych sytuacjach warto korzystać z kilku.</span><span class="sxs-lookup"><span data-stu-id="59213-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="59213-122">Omówimy to przykład później.</span><span class="sxs-lookup"><span data-stu-id="59213-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="59213-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Kolejek wątków elementach wewnątrz obiektu o nazwie <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="59213-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="59213-124"><xref:System.Windows.Threading.Dispatcher> Wybiera elementy robocze w pierwszej kolejności i działa każdy z nich do zakończenia.</span><span class="sxs-lookup"><span data-stu-id="59213-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="59213-125">Co [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątek musi mieć co najmniej jeden <xref:System.Windows.Threading.Dispatcher>, a każdy <xref:System.Windows.Threading.Dispatcher> można wykonać elementy robocze w dokładnie jeden wątek.</span><span class="sxs-lookup"><span data-stu-id="59213-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="59213-126">Lewy do tworzenia aplikacji interaktywnych, przyjazny dla użytkownika jest zwiększenie <xref:System.Windows.Threading.Dispatcher> przepływność przy zachowaniu małych elementów roboczych.</span><span class="sxs-lookup"><span data-stu-id="59213-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="59213-127">Nigdy nie ten sposób elementy Pobierz starych, znajdują się <xref:System.Windows.Threading.Dispatcher> kolejki oczekiwania na przetwarzanie.</span><span class="sxs-lookup"><span data-stu-id="59213-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="59213-128">Wszelkie odczytywane opóźnienia między dane wejściowe i odpowiedzi może frustrować użytkownika.</span><span class="sxs-lookup"><span data-stu-id="59213-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="59213-129">Jak można [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji powinien obsługiwać operacje big Data?</span><span class="sxs-lookup"><span data-stu-id="59213-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="59213-130">Co zrobić, jeśli kod wymaga dużych obliczeń lub musi zapytanie dotyczące bazy danych na niektórych serwerze zdalnym?</span><span class="sxs-lookup"><span data-stu-id="59213-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="59213-131">Zazwyczaj jest odpowiedź do obsługi dużych operacji w oddzielnym wątku, pozostawiając [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] się zwykle do elementów w wątku <xref:System.Windows.Threading.Dispatcher> kolejki.</span><span class="sxs-lookup"><span data-stu-id="59213-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="59213-132">Po zakończeniu operacji big Data, wynik może raportować do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku do wyświetlenia.</span><span class="sxs-lookup"><span data-stu-id="59213-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="59213-133">W przeszłości [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] umożliwia [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementy, aby był dostępny tylko dla wątku, który je utworzył.</span><span class="sxs-lookup"><span data-stu-id="59213-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="59213-134">Oznacza to, czy wątku w tle odpowiedzialnym za niektóre długotrwałe zadanie nie można zaktualizować pola tekstowego po jego zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="59213-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="59213-135"> robi to w celu zapewnienia integralności [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] składników.</span><span class="sxs-lookup"><span data-stu-id="59213-135"> does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="59213-136">Pole listy mogłoby wyglądać dziwne, jeśli jego zawartość zostały zaktualizowane przez wątku w tle podczas rysowania.</span><span class="sxs-lookup"><span data-stu-id="59213-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="59213-137"> ma mechanizm wbudowanych wzajemne wykluczenie, który wymusza to koordynacji.</span><span class="sxs-lookup"><span data-stu-id="59213-137"> has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="59213-138">Większość klas w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dziedziczyć <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="59213-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="59213-139">W konstrukcji <xref:System.Windows.Threading.DispatcherObject> przechowuje odwołania do <xref:System.Windows.Threading.Dispatcher> połączone z aktualnie uruchomionemu wątkowi.</span><span class="sxs-lookup"><span data-stu-id="59213-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="59213-140">W efekcie <xref:System.Windows.Threading.DispatcherObject> kojarzy z wątku, który tworzy go.</span><span class="sxs-lookup"><span data-stu-id="59213-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="59213-141">Podczas wykonywania programu <xref:System.Windows.Threading.DispatcherObject> może wywołać jej publicznego <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="59213-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="59213-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> sprawdza, czy <xref:System.Windows.Threading.Dispatcher> skojarzone z bieżącym wątkiem i porównuje go do <xref:System.Windows.Threading.Dispatcher> odwołanie przechowywanych w trakcie konstruowania.</span><span class="sxs-lookup"><span data-stu-id="59213-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="59213-143">Jeśli nie są zgodne, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="59213-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="59213-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> jest przeznaczona do wywoływania na początku każdej metody należących do <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="59213-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="59213-145">Jeśli tylko jeden wątek może modyfikować [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], wątków w tle interakcję z użytkownikiem?</span><span class="sxs-lookup"><span data-stu-id="59213-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="59213-146">Poproś wątku w tle [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku w celu wykonania operacji w jej imieniu.</span><span class="sxs-lookup"><span data-stu-id="59213-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="59213-147">Jest to realizowane przez zarejestrowanie kodowań z elementu roboczego <xref:System.Windows.Threading.Dispatcher> z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-148"><xref:System.Windows.Threading.Dispatcher> Klasa udostępnia dwie metody rejestrowania elementów roboczych: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="59213-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="59213-149">Obie metody zaplanować delegata do wykonania.</span><span class="sxs-lookup"><span data-stu-id="59213-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="59213-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> to wywołanie synchroniczne — oznacza to, nie zwracać do momentu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku faktycznie kończy wykonywanie delegata.</span><span class="sxs-lookup"><span data-stu-id="59213-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="59213-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchroniczne i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="59213-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="59213-152"><xref:System.Windows.Threading.Dispatcher> Porządkuje elementy które w swojej kolejki według priorytetu.</span><span class="sxs-lookup"><span data-stu-id="59213-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="59213-153">Istnieją dziesięć poziomy, które może być określona podczas dodawania elementu <xref:System.Windows.Threading.Dispatcher> kolejki.</span><span class="sxs-lookup"><span data-stu-id="59213-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="59213-154">Priorytety są obsługiwane w <xref:System.Windows.Threading.DispatcherPriority> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="59213-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="59213-155">Szczegółowe informacje na temat <xref:System.Windows.Threading.DispatcherPriority> poziomy znajdują się w [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] dokumentacji.</span><span class="sxs-lookup"><span data-stu-id="59213-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="59213-156">Wątki w działaniu: przykłady</span><span class="sxs-lookup"><span data-stu-id="59213-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="59213-157">Aplikacja jednowątkowa z obliczeniami długotrwałych</span><span class="sxs-lookup"><span data-stu-id="59213-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="59213-158">Większość [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] poświęcić dużo czasu bezczynności podczas oczekiwania na zdarzenia, które są generowane w odpowiedzi na interakcję użytkownika.</span><span class="sxs-lookup"><span data-stu-id="59213-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="59213-159">Za pomocą programowania dokładnej tego czasu bezczynności może służyć konstruktywnie, bez wywierania wpływu na czas odpowiedzi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="59213-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="59213-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Model wątkowości nie zezwala na dane wejściowe przerwać operację działań wykonywanych w [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-161">Oznacza to, należy upewnić się powrócić do <xref:System.Windows.Threading.Dispatcher> okresowo, aby proces oczekujące zdarzenia wejściowe, zanim staną się przestarzałe.</span><span class="sxs-lookup"><span data-stu-id="59213-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="59213-162">Rozważmy następujący przykład:</span><span class="sxs-lookup"><span data-stu-id="59213-162">Consider the following example:</span></span>  
  
 <span data-ttu-id="59213-163">![Zrzut ekranu przedstawiający liczby pierwsze](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span><span class="sxs-lookup"><span data-stu-id="59213-163">![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span></span>  
  
 <span data-ttu-id="59213-164">Ta prosta aplikacja, do góry liczy się z trzech, wyszukując liczb pierwszych.</span><span class="sxs-lookup"><span data-stu-id="59213-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="59213-165">Kiedy użytkownik kliknie **Start** przycisku, wyszukiwanie rozpoczyna się.</span><span class="sxs-lookup"><span data-stu-id="59213-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="59213-166">Gdy program znajduje się zapora, aktualizacje interfejsu użytkownika jego poznawania.</span><span class="sxs-lookup"><span data-stu-id="59213-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="59213-167">W dowolnym momencie użytkownik może zatrzymać wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="59213-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="59213-168">Mimo że jest to prosta, wyszukiwanie liczba pierwsza można przejść w nieskończoność, który przedstawia pewne trudności.</span><span class="sxs-lookup"><span data-stu-id="59213-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="59213-169">Jeśli firma Microsoft obsługi całej wyszukiwania wewnątrz program obsługi zdarzeń kliknięcie przycisku, firma Microsoft nigdy nie dałaby [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku szansę, aby obsłużyć inne zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="59213-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="59213-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Można odpowiedzieć na dane wejściowe lub przetwarzania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="59213-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="59213-171">Będzie ona nigdy nie repaint i nigdy nie odpowiadanie na kliknięcia przycisków.</span><span class="sxs-lookup"><span data-stu-id="59213-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="59213-172">Przeprowadzamy wyszukiwania liczba pierwsza w oddzielnym wątku, ale następnie będziemy potrzebować radzenia sobie z problemów z synchronizacją.</span><span class="sxs-lookup"><span data-stu-id="59213-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="59213-173">Jednowątkowe podejście możemy bezpośrednio zaktualizować etykietę, która wyświetla największą priorytetowe znaleziono.</span><span class="sxs-lookup"><span data-stu-id="59213-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="59213-174">Jeśli firma Microsoft Podziel zadanie obliczania w partiach łatwych do zarządzania, firma Microsoft okresowo powrócić do <xref:System.Windows.Threading.Dispatcher> i przetwarzania zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="59213-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="59213-175">Możemy udostępnić [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] możliwość odświeżenia i przetwarzania danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="59213-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="59213-176">Najlepszym sposobem podziału czas przetwarzania między obliczeń i obsługa zdarzeń jest zarządzanie obliczeń z <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="59213-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="59213-177">Za pomocą <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> metody, możemy zaplanować liczba pierwsza kontroli w taki sam kolejki [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] zdarzenia są pobierane z.</span><span class="sxs-lookup"><span data-stu-id="59213-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="59213-178">W tym przykładzie firma Microsoft zaplanować tylko sprawdzanie pojedyncza liczba prime w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="59213-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="59213-179">Po zakończeniu wyboru liczba pierwsza możemy zaplanować następne sprawdzenie natychmiast.</span><span class="sxs-lookup"><span data-stu-id="59213-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="59213-180">Tego wyboru rozpoczynające się tylko po oczekiwaniu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] zdarzenia zostały obsłużone.</span><span class="sxs-lookup"><span data-stu-id="59213-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 <span data-ttu-id="59213-181">![Ilustracja przedstawiająca kolejkę dyspozytora](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span><span class="sxs-lookup"><span data-stu-id="59213-181">![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span></span>  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="59213-182"> w ramach przy użyciu tego mechanizmu sprawdzania pisowni.</span><span class="sxs-lookup"><span data-stu-id="59213-182"> accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="59213-183">Sprawdzanie pisowni jest wykonywane w tle za pomocą czas bezczynności, po z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-184">Spójrzmy na kod.</span><span class="sxs-lookup"><span data-stu-id="59213-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="59213-185">Poniższy przykład pokazuje XAML, który jest tworzony interfejs użytkownika.</span><span class="sxs-lookup"><span data-stu-id="59213-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="59213-186">Poniższy przykład pokazuje związanym z kodem.</span><span class="sxs-lookup"><span data-stu-id="59213-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="59213-187">W poniższym przykładzie pokazano program obsługi zdarzeń dla <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="59213-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="59213-188">Oprócz Aktualizowanie tekstu w <xref:System.Windows.Controls.Button>, ten program obsługi jest odpowiedzialny za planowanie pierwszego wyboru liczba pierwsza, dodając obiekt delegowany do <xref:System.Windows.Threading.Dispatcher> kolejki.</span><span class="sxs-lookup"><span data-stu-id="59213-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="59213-189">Za jakiś czas, po tej obsługi zdarzeń zakończy pracę, <xref:System.Windows.Threading.Dispatcher> wybierze ten delegat do wykonania.</span><span class="sxs-lookup"><span data-stu-id="59213-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="59213-190">Jak wspomniano wcześniej, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest <xref:System.Windows.Threading.Dispatcher> składowa użyta do zaplanowania delegata do wykonania.</span><span class="sxs-lookup"><span data-stu-id="59213-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="59213-191">W tym przypadku Wybraliśmy <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priorytetu.</span><span class="sxs-lookup"><span data-stu-id="59213-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="59213-192"><xref:System.Windows.Threading.Dispatcher> Ten delegat będą wykonywane tylko wtedy, gdy Brak ważnych zdarzeń do przetworzenia.</span><span class="sxs-lookup"><span data-stu-id="59213-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="59213-193"> czas odpowiedzi jest ważniejsza niż Sprawdzanie numeru.</span><span class="sxs-lookup"><span data-stu-id="59213-193"> responsiveness is more important than number checking.</span></span> <span data-ttu-id="59213-194">Możemy również przekazać nowe delegowanie reprezentujący sprawdzanie numer procedury.</span><span class="sxs-lookup"><span data-stu-id="59213-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="59213-195">Ta metoda sprawdza, czy najbliższej nieparzystej liczby pierwsze.</span><span class="sxs-lookup"><span data-stu-id="59213-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="59213-196">Jeśli jest zainicjowanie, metoda bezpośrednio aktualizuje `bigPrime` <xref:System.Windows.Controls.TextBlock> aby odzwierciedlić ich odnajdywania.</span><span class="sxs-lookup"><span data-stu-id="59213-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="59213-197">Możemy to zrobić, ponieważ obliczenie jest wykonywane w tym samym wątku, który został użyty do utworzenia składnika.</span><span class="sxs-lookup"><span data-stu-id="59213-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="59213-198">Firma Microsoft wybierze użyć oddzielnego wątku do obliczenia, firma Microsoft musiałaby używany był mechanizm synchronizacji bardziej skomplikowane i wykonać aktualizację w [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-199">Następnie zademonstrujemy tę sytuację.</span><span class="sxs-lookup"><span data-stu-id="59213-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="59213-200">Aby uzyskać pełnego kodu źródłowego dla tego przykładu, zobacz [Single-Threaded aplikacji z przykładem obliczania długotrwałych](https://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="59213-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="59213-201">Obsługa blokowania operacji z wątku w tle</span><span class="sxs-lookup"><span data-stu-id="59213-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="59213-202">Obsługa operacji blokowania w aplikacji graficznej może być trudne.</span><span class="sxs-lookup"><span data-stu-id="59213-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="59213-203">Nie chcemy wywoływać metody blokowania z programu obsługi zdarzeń, ponieważ aplikacja pojawi się można zablokować w.</span><span class="sxs-lookup"><span data-stu-id="59213-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="59213-204">Możemy użyć oddzielnego wątku, aby obsługiwać te operacje, ale gdy wszystko jest gotowe, mamy do synchronizacji z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątków, ponieważ nie można zmodyfikować bezpośrednio [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] z naszych wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="59213-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="59213-205">Możemy użyć <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> do wstawienia delegatów do <xref:System.Windows.Threading.Dispatcher> z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-206">Po pewnym czasie te delegaty zostanie wykonana przy użyciu uprawnień do modyfikowania [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementów.</span><span class="sxs-lookup"><span data-stu-id="59213-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="59213-207">W tym przykładzie firma Microsoft naśladować wywołanie procedury zdalnej, która pobiera prognozę pogody.</span><span class="sxs-lookup"><span data-stu-id="59213-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="59213-208">Firma Microsoft wątku roboczego oddzielnych do wykonania tego wywołania, a firma Microsoft zaplanować metodę aktualizacji w <xref:System.Windows.Threading.Dispatcher> z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku, gdy będziemy zakończone.</span><span class="sxs-lookup"><span data-stu-id="59213-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 <span data-ttu-id="59213-209">![Zrzut ekranu interfejsu użytkownika pogodowe](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span><span class="sxs-lookup"><span data-stu-id="59213-209">![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span></span>  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="59213-210">Poniżej przedstawiono niektóre szczegółowe informacje, można zauważyć.</span><span class="sxs-lookup"><span data-stu-id="59213-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="59213-211">Tworzenie procedury obsługi przycisku</span><span class="sxs-lookup"><span data-stu-id="59213-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="59213-212">Po kliknięciu przycisku, możemy wyświetlić rysowania zegara, a następnie uruchom, zanimowaniu jej.</span><span class="sxs-lookup"><span data-stu-id="59213-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="59213-213">Firma Microsoft wyłączenie przycisku.</span><span class="sxs-lookup"><span data-stu-id="59213-213">We disable the button.</span></span> <span data-ttu-id="59213-214">Możemy wywołać `FetchWeatherFromServer` metody w nowym wątku, a następnie utworzymy zwrotu, dzięki czemu <xref:System.Windows.Threading.Dispatcher> do przetwarzania zdarzeń, gdy firma Microsoft poczekać na zebranie prognozę pogody.</span><span class="sxs-lookup"><span data-stu-id="59213-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="59213-215">Pobieranie pogody</span><span class="sxs-lookup"><span data-stu-id="59213-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="59213-216">Aby zachować ich prostotę, faktycznie nie ma żadnego kodu sieci w tym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="59213-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="59213-217">Zamiast tego możemy symulować opóźnienia dostępu do sieci, umieszczając nasze nowy wątek w stan uśpienia na czterech sekund.</span><span class="sxs-lookup"><span data-stu-id="59213-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="59213-218">W tym okresie, oryginalnym [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątek jest nadal uruchomiona i reagowanie na zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="59213-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="59213-219">Pokaż, firma Microsoft odeszli animację, uruchamianie i Minimalizuj i zmaksymalizować przyciski również kontynuować pracę.</span><span class="sxs-lookup"><span data-stu-id="59213-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="59213-220">Po zakończeniu opóźnienie i losowo Wybraliśmy naszych prognozę pogody, nadszedł czas na raportowane [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-221">Możemy to zrobić, planowanie wywołanie `UpdateUserInterface` w [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku, przy użyciu tego wątku <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="59213-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="59213-222">Przekazanie ciąg opisujący pogody na to wywołanie metody zaplanowane.</span><span class="sxs-lookup"><span data-stu-id="59213-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="59213-223">Aktualizowanie [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="59213-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="59213-224">Gdy <xref:System.Windows.Threading.Dispatcher> w [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątek ma czas, wykonuje wywołanie zaplanowane `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="59213-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="59213-225">Ta metoda zatrzymuje animacji zegara i wybiera obraz do opisania pogody.</span><span class="sxs-lookup"><span data-stu-id="59213-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="59213-226">On wyświetla ten obraz i przywraca przycisku "pobierania forecast".</span><span class="sxs-lookup"><span data-stu-id="59213-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="59213-227">Windows wielu, wielu wątków</span><span class="sxs-lookup"><span data-stu-id="59213-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="59213-228">Niektóre [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji wymaga wiele okien najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="59213-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="59213-229">Doskonale dopuszczalna jeden wątek jest /<xref:System.Windows.Threading.Dispatcher> kombinację, aby zarządzać wieloma oknami, ale czasami kilku wątków wykonywanie lepszej pracy.</span><span class="sxs-lookup"><span data-stu-id="59213-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="59213-230">Jest to szczególnie istotne w przypadku każdej okazji ten. systemu windows będzie zajmą wszystkich wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="59213-231"> Eksplorator działa w ten sposób.</span><span class="sxs-lookup"><span data-stu-id="59213-231"> Explorer works in this fashion.</span></span> <span data-ttu-id="59213-232">Każde nowe okno Eksploratora należy do oryginalnego proces, ale jest tworzona pod kontrolą, niezależnie od wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="59213-233">Za pomocą [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> kontrolki, można też wyświetlać stron sieci Web.</span><span class="sxs-lookup"><span data-stu-id="59213-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="59213-234">Firma Microsoft można łatwo utworzyć prostą [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="59213-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="59213-235">Rozpoczniemy pracę ważną funkcją: możliwości, aby otworzyć nowe okno Eksploratora.</span><span class="sxs-lookup"><span data-stu-id="59213-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="59213-236">Gdy użytkownik kliknie przycisk "nowe okno" przycisk, możemy uruchomić kopię naszych okna w oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="59213-237">W ten sposób operacji długotrwałych lub blokowania w jednym z systemu windows nie będzie blokować inne okna.</span><span class="sxs-lookup"><span data-stu-id="59213-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="59213-238">W rzeczywistości modelu przeglądarki sieci Web ma swój własny skomplikowany model wątkowości.</span><span class="sxs-lookup"><span data-stu-id="59213-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="59213-239">Wybraliśmy on, ponieważ powinna być znane większość odbiorców.</span><span class="sxs-lookup"><span data-stu-id="59213-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="59213-240">Poniższy przykład zawiera kod.</span><span class="sxs-lookup"><span data-stu-id="59213-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="59213-241">Cię najbardziej interesuje NAS w tym kontekście są następujące segmenty wątkowości tego kodu:</span><span class="sxs-lookup"><span data-stu-id="59213-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="59213-242">Ta metoda jest wywoływana, gdy "nowe okno" przycisku.</span><span class="sxs-lookup"><span data-stu-id="59213-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="59213-243">Tworzy nowy wątek i uruchamia go asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="59213-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="59213-244">Ta metoda jest punkt początkowy dla nowego wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="59213-245">Możemy utworzyć nowe okno pod kontrolą tego wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="59213-246"> automatycznie tworzy nową <xref:System.Windows.Threading.Dispatcher> Zarządzanie nowy wątek.</span><span class="sxs-lookup"><span data-stu-id="59213-246"> automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="59213-247">Musimy to zrobić, aby wyświetlić to okno funkcjonalności wystarczy uruchomić <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="59213-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="59213-248">Szczegóły techniczne i Stumbling punktów</span><span class="sxs-lookup"><span data-stu-id="59213-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="59213-249">Składniki zapisywania za pomocą wielowątkowości</span><span class="sxs-lookup"><span data-stu-id="59213-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="59213-250">Podręcznik dewelopera programu Microsoft .NET Framework w tym artykule opisano wzorzec jak składnik może narazić zachowanie asynchroniczne swoim klientom (zobacz [oparte na zdarzeniach asynchronicznych omówienie wzorca](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="59213-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="59213-251">Na przykład załóżmy, że Chcieliśmy utworzyć pakiet `FetchWeatherFromServer` metody do wielokrotnego użytku, które składnika.</span><span class="sxs-lookup"><span data-stu-id="59213-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="59213-252">Następujące standardowego wzorca Microsoft .NET Framework to będzie wyglądać poniżej.</span><span class="sxs-lookup"><span data-stu-id="59213-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="59213-253">`GetWeatherAsync` użyć jednej z metod opisanych wcześniej, takich jak tworzenie wątku w tle, które wykonają tę pracę asynchronicznie, nie blokuje wątek wywołujący.</span><span class="sxs-lookup"><span data-stu-id="59213-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="59213-254">Jeden z najważniejszych elementów tego wzorca wywoływany *MethodName* `Completed` metody w tym samym wątku, który wywołał *MethodName* `Async` zaczynają się od metody.</span><span class="sxs-lookup"><span data-stu-id="59213-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="59213-255">Użytkownik może to zrobić za pomocą [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dość łatwe dzięki przechowywaniu <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—, ale następnie które składnik może być używana tylko w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji, nie w [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] lub [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programów.</span><span class="sxs-lookup"><span data-stu-id="59213-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="59213-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext> Klasy eliminuje to potrzebę — ją traktować jako uproszczoną wersję <xref:System.Windows.Threading.Dispatcher> która współdziała z innymi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] również struktury.</span><span class="sxs-lookup"><span data-stu-id="59213-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="59213-257">Zagnieżdżone przekazywanie</span><span class="sxs-lookup"><span data-stu-id="59213-257">Nested Pumping</span></span>  
 <span data-ttu-id="59213-258">Czasami nie jest to możliwe, całkowicie blokuje się [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-259">Rozważmy <xref:System.Windows.MessageBox.Show%2A> metody <xref:System.Windows.MessageBox> klasy.</span><span class="sxs-lookup"><span data-stu-id="59213-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="59213-260"><xref:System.Windows.MessageBox.Show%2A> nie zwraca, dopóki użytkownik kliknie przycisk OK.</span><span class="sxs-lookup"><span data-stu-id="59213-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="59213-261">Jednak to utworzyć okno które musi mieć pętli komunikatów, aby być interaktywna.</span><span class="sxs-lookup"><span data-stu-id="59213-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="59213-262">Gdy firma Microsoft oczekuje na użytkownika, kliknij przycisk OK, oryginalnym okna aplikacji nie odpowiada na dane wejściowe użytkownika.</span><span class="sxs-lookup"><span data-stu-id="59213-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="59213-263">Jednak nadal przetwarzać komunikaty dotyczące malowania.</span><span class="sxs-lookup"><span data-stu-id="59213-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="59213-264">Okno oryginalne odrysowuje samego w sobie podczas wchodzi w zakres i reakcja.</span><span class="sxs-lookup"><span data-stu-id="59213-264">The original window redraws itself when covered and revealed.</span></span>  
  
 <span data-ttu-id="59213-265">![MessageBox za pomocą przycisku "OK"](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span><span class="sxs-lookup"><span data-stu-id="59213-265">![MessageBox with an "OK" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span></span>  
  
 <span data-ttu-id="59213-266">Niektóre wątek musi być odpowiedzialnym za okno komunikatu.</span><span class="sxs-lookup"><span data-stu-id="59213-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="59213-267"> można utworzyć nowego wątku, tylko dla okno komunikatu, ale ten wątek nie będzie można malować wyłączone elementy w oknie oryginalnego (należy pamiętać o wcześniej dyskusji wzajemne wykluczenie).</span><span class="sxs-lookup"><span data-stu-id="59213-267"> could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="59213-268">Zamiast tego [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] używa komunikatu zagnieżdżonych, systemu przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="59213-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="59213-269"><xref:System.Windows.Threading.Dispatcher> Klasa zawiera specjalne metodę o nazwie <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, który następnie zapisuje bieżący punkt wykonania aplikacji rozpocznie się nowych pętli komunikatów.</span><span class="sxs-lookup"><span data-stu-id="59213-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="59213-270">Po zakończeniu pętli komunikatów zagnieżdżonych, wykonanie zostanie wznowione po oryginalnej <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> wywołania.</span><span class="sxs-lookup"><span data-stu-id="59213-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="59213-271">W tym przypadku <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> utrzymuje kontekst program w wywołaniu do <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, i jest on uruchamiany pętlę komunikatów repaint okna tła i obsługiwać dane wejściowe okno komunikatu.</span><span class="sxs-lookup"><span data-stu-id="59213-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="59213-272">Gdy użytkownik kliknie przycisk OK i czyści okno podręczne, zamyka zagnieżdżonej pętli i sterowania wznawia działanie po wywołaniu <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="59213-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="59213-273">Stare zdarzenia trasowanego</span><span class="sxs-lookup"><span data-stu-id="59213-273">Stale Routed Events</span></span>  
 <span data-ttu-id="59213-274">System zdarzenia trasowanego w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] powiadamia całego drzewa, gdy zdarzenia są wywoływane.</span><span class="sxs-lookup"><span data-stu-id="59213-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="59213-275">Po naciśnięciu lewego przycisku myszy na wielokropku przy `handler2` jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="59213-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="59213-276">Po `handler2` zostanie zakończone, zdarzenie jest przekazywany do <xref:System.Windows.Controls.Canvas> obiektu, który używa `handler1` go przetworzyć.</span><span class="sxs-lookup"><span data-stu-id="59213-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="59213-277">Dzieje się tak tylko wtedy, gdy `handler2` jest nie zostały jawnie znak z obiektem zdarzenia jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="59213-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="59213-278">Istnieje możliwość, że `handler2` zajmie się dużym stopniem czas przetwarzania tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="59213-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="59213-279">`handler2` może używać <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> pętlę komunikatów zagnieżdżonych, która nie zwraca godziny rozpoczęcia.</span><span class="sxs-lookup"><span data-stu-id="59213-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="59213-280">Jeśli `handler2` nie nie znacznika zdarzenia jako obsłużony, gdy jest to pętli komunikatów ukończenia, zdarzenie jest przekazywany górę drzewa, mimo że jest to bardzo starych.</span><span class="sxs-lookup"><span data-stu-id="59213-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="59213-281">Wielobieżność i blokowania</span><span class="sxs-lookup"><span data-stu-id="59213-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="59213-282">Mechanizm blokowania [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] nie zachowywać się dokładnie tak jak jedną może imagine; można oczekiwać, że wątek całkowicie zaprzestania operacji podczas żądania blokady.</span><span class="sxs-lookup"><span data-stu-id="59213-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="59213-283">W rzeczywistości wątku w dalszym ciągu odbierania i przetwarzania wiadomości o wysokim priorytecie.</span><span class="sxs-lookup"><span data-stu-id="59213-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="59213-284">Pomaga to zapobiegać zakleszczenia i wprowadź minimalny zestaw dynamiczny interfejsów, ale wprowadza możliwość subtelnych błędów.</span><span class="sxs-lookup"><span data-stu-id="59213-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="59213-285">Większość czasu nie muszą nic wiedzieć o tym, ale w bardzo rzadkich przypadkach (zwykle obejmujące [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] komunikatów okien lub składniki COM STA) może to być warte wiedzy.</span><span class="sxs-lookup"><span data-stu-id="59213-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="59213-286">Większość interfejsów nie są tworzone za pomocą bezpieczeństwo wątków, pamiętając, ponieważ deweloperzy pracują przy założeniu, że [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nigdy nie odbywa się przez więcej niż jeden wątek.</span><span class="sxs-lookup"><span data-stu-id="59213-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="59213-287">W tym przypadku jeden wątek mogą wprowadzać zmiany środowiska w nieoczekiwanym czasie, powodując tych źle wpływ, <xref:System.Windows.Threading.DispatcherObject> wzajemne wykluczenie mechanizm powinien rozwiązać.</span><span class="sxs-lookup"><span data-stu-id="59213-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="59213-288">Należy wziąć pod uwagę poniższym pseudokodzie:</span><span class="sxs-lookup"><span data-stu-id="59213-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="59213-289">![Diagram współużytkowania wątkowości](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="59213-289">![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="59213-290">W większości przypadków to właściwe, ale istnieją momenty, w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] gdzie takie nieoczekiwany współużytkowania wątkowości naprawdę może powodować problemy.</span><span class="sxs-lookup"><span data-stu-id="59213-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="59213-291">Tak, w określonym czasie klucza [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] wywołania <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, który zmienia instrukcji lock dla tego wątku użyć [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] wielobieżność bez blokady, zamiast zwykłego [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] blokady.</span><span class="sxs-lookup"><span data-stu-id="59213-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="59213-292">Dlaczego czy [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] zespołu, wybierz ten problem?</span><span class="sxs-lookup"><span data-stu-id="59213-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="59213-293">Należało wykonać za pomocą obiektów COM, STA i wątku finalizacji.</span><span class="sxs-lookup"><span data-stu-id="59213-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="59213-294">Gdy obiekt jest bezużyteczne, jego `Finalize` metoda jest uruchomiona w wątku finalizatora dedykowanych nie [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-295">I tam jest problem, ponieważ obiekt COM STA, który został utworzony na [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku, tylko może zostać usunięty w [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku.</span><span class="sxs-lookup"><span data-stu-id="59213-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="59213-296">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] Jest odpowiednikiem <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (w tym przypadku przy użyciu firmy Win32 `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="59213-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="59213-297">Ale w tym przypadku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątku jest zajęty i został zablokowany wątek finalizatora obiektu COM STA nie można usunąć, co powoduje utworzenie przeciek pamięci poważne.</span><span class="sxs-lookup"><span data-stu-id="59213-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="59213-298">Więc [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] zespołu wprowadzone trudne wywołanie się blokad, które działają w ten sposób wykonują.</span><span class="sxs-lookup"><span data-stu-id="59213-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="59213-299">Zadanie dotyczące [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] jest unikanie nieoczekiwanych wielobieżność bez ponownym wprowadzeniem przeciek pamięci, dlatego firma Microsoft nie blokują współużytkowania wątkowości w dowolnym miejscu.</span><span class="sxs-lookup"><span data-stu-id="59213-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="59213-300">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="59213-300">See Also</span></span>  
 [<span data-ttu-id="59213-301">Aplikacja jednowątkowa z przykładem obliczania długotrwałych</span><span class="sxs-lookup"><span data-stu-id="59213-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
