---
title: Model wątkowości
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: ae120311e7e58b34437de987e9f9a18e917043c0
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/12/2019
ms.locfileid: "73974074"
---
# <a name="threading-model"></a><span data-ttu-id="5633b-102">Model wątkowości</span><span class="sxs-lookup"><span data-stu-id="5633b-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="5633b-103">zaprojektowano w celu zaoszczędzenia deweloperom trudności związanych z wątkami.</span><span class="sxs-lookup"><span data-stu-id="5633b-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="5633b-104">W związku z tym większość deweloperów [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] nie będzie musiała pisać interfejsu, który używa więcej niż jednego wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="5633b-105">Ponieważ programy wielowątkowe są skomplikowane i trudne do debugowania, należy je unikać, gdy istnieją rozwiązania jednowątkowe.</span><span class="sxs-lookup"><span data-stu-id="5633b-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="5633b-106">Niezależnie od tego, jak dobrze jest zaprojektowana architektura, żadna platforma [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nie będzie w stanie zapewnić jednowątkowego rozwiązania dla każdego rodzaju problemu.</span><span class="sxs-lookup"><span data-stu-id="5633b-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="5633b-107">się zamyka, ale nadal występują sytuacje, w których wiele wątków poprawia [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] czas odpowiedzi lub wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="5633b-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="5633b-108">Po przedyskutowaniu pewnego materiału tła ten dokument eksploruje niektóre z tych sytuacji, a następnie kończy dyskusje na temat pewnych szczegółów niższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="5633b-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="5633b-109">W tym temacie omówiono wątki przy użyciu metody <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> dla wywołań asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="5633b-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="5633b-110">Można również wykonywać wywołania asynchroniczne, wywołując metodę <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>, która przyjmuje <xref:System.Action> lub <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="5633b-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="5633b-111">Metoda <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> zwraca <xref:System.Windows.Threading.DispatcherOperation> lub <xref:System.Windows.Threading.DispatcherOperation%601>, który ma właściwość <xref:System.Windows.Threading.DispatcherOperation.Task%2A>.</span><span class="sxs-lookup"><span data-stu-id="5633b-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="5633b-112">Można użyć słowa kluczowego `await` z <xref:System.Windows.Threading.DispatcherOperation> lub skojarzonych <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="5633b-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="5633b-113">Jeśli musisz odczekać synchronicznie dla <xref:System.Threading.Tasks.Task> zwracanych przez <xref:System.Windows.Threading.DispatcherOperation> lub <xref:System.Windows.Threading.DispatcherOperation%601>, wywołaj metodę rozszerzenia <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="5633b-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="5633b-114">Wywołanie <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> spowoduje zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="5633b-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="5633b-115">Aby uzyskać więcej informacji na temat używania <xref:System.Threading.Tasks.Task> do wykonywania operacji asynchronicznych, zobacz równoległość zadań.</span><span class="sxs-lookup"><span data-stu-id="5633b-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="5633b-116">Metoda <xref:System.Windows.Threading.Dispatcher.Invoke%2A> również ma przeciążenia, które pobierają <xref:System.Action> lub <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="5633b-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="5633b-117">Metody <xref:System.Windows.Threading.Dispatcher.Invoke%2A> można użyć do wykonywania wywołań synchronicznych przez przekazanie delegata, <xref:System.Action> lub <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="5633b-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="5633b-118">Przegląd i Dyspozytor</span><span class="sxs-lookup"><span data-stu-id="5633b-118">Overview and the Dispatcher</span></span>
 <span data-ttu-id="5633b-119">Zazwyczaj aplikacje [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] zaczynają się od dwóch wątków: jeden do obsługi renderowania i drugi dla zarządzania [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="5633b-120">Wątek renderowania efektywnie działa jako ukryty w tle, podczas gdy wątek [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] odbiera dane wejściowe, obsługuje zdarzenia, maluje na ekranie i uruchamia kod aplikacji.</span><span class="sxs-lookup"><span data-stu-id="5633b-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="5633b-121">Większość aplikacji używa jednego wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], chociaż w niektórych sytuacjach najlepiej jest użyć kilku.</span><span class="sxs-lookup"><span data-stu-id="5633b-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="5633b-122">Omawiamy ten przykład w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="5633b-122">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="5633b-123">Wątek [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] kolejkuje elementy robocze wewnątrz obiektu o nazwie <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5633b-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="5633b-124"><xref:System.Windows.Threading.Dispatcher> wybiera elementy robocze w oparciu o priorytet i uruchamia każdy z nich do ukończenia.</span><span class="sxs-lookup"><span data-stu-id="5633b-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="5633b-125">Każdy wątek [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] musi mieć co najmniej jeden <xref:System.Windows.Threading.Dispatcher>, a każdy <xref:System.Windows.Threading.Dispatcher> może wykonywać elementy robocze w dokładnie jednym wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="5633b-126">Najlepszą do kompilowania aplikacji, przyjaznych dla użytkowników, jest maksymalizacja przepływności <xref:System.Windows.Threading.Dispatcher> przez utrzymywanie niewielkich elementów roboczych.</span><span class="sxs-lookup"><span data-stu-id="5633b-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="5633b-127">W ten sposób elementy nigdy nie uzyskują starych w kolejce <xref:System.Windows.Threading.Dispatcher>, oczekując na przetworzenie.</span><span class="sxs-lookup"><span data-stu-id="5633b-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="5633b-128">Wszelkie widoczne opóźnienia między wejściem i odpowiedzią mogą frustrować użytkownika.</span><span class="sxs-lookup"><span data-stu-id="5633b-128">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="5633b-129">Jak są [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacje, które mają obsługiwać duże operacje?</span><span class="sxs-lookup"><span data-stu-id="5633b-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="5633b-130">Co zrobić, jeśli kod obejmuje duże obliczenia lub że musi wysyłać zapytania do bazy danych na niektórych serwerach zdalnych?</span><span class="sxs-lookup"><span data-stu-id="5633b-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="5633b-131">Zwykle odpowiedź polega na obsłudze operacji Big w osobnym wątku, pozostawiając [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] wątek wolny do elementów w kolejce <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5633b-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="5633b-132">Po zakończeniu operacji Big można zgłosić jej wynik z powrotem do wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], aby wyświetlić.</span><span class="sxs-lookup"><span data-stu-id="5633b-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="5633b-133">Historycznie system Windows zezwala na dostęp do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementów tylko przez wątek, który go utworzył.</span><span class="sxs-lookup"><span data-stu-id="5633b-133">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="5633b-134">Oznacza to, że wątek w tle, który jest odpowiedzialny za niektóre długotrwałe zadania, nie może zaktualizować pola tekstowego po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="5633b-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="5633b-135">System Windows robi to, aby zapewnić integralność składników [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-135">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="5633b-136">Pole listy może wyglądać dziwnie, jeśli jego zawartość została zaktualizowana przez wątek w tle podczas malowania.</span><span class="sxs-lookup"><span data-stu-id="5633b-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="5633b-137">ma wbudowany mechanizm wzajemnego wykluczania, który wymusza tę koordynację.</span><span class="sxs-lookup"><span data-stu-id="5633b-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="5633b-138">Większość klas w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] pochodzi od <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="5633b-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="5633b-139">W konstrukcji <xref:System.Windows.Threading.DispatcherObject> przechowuje odwołanie do <xref:System.Windows.Threading.Dispatcher> połączone z aktualnie uruchomionym wątkiem.</span><span class="sxs-lookup"><span data-stu-id="5633b-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="5633b-140">W efekcie <xref:System.Windows.Threading.DispatcherObject> kojarzy z wątkiem, który tworzy go.</span><span class="sxs-lookup"><span data-stu-id="5633b-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="5633b-141">Podczas wykonywania programu <xref:System.Windows.Threading.DispatcherObject> może wywoływać swoją publiczną metodę <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>.</span><span class="sxs-lookup"><span data-stu-id="5633b-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="5633b-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> analizuje <xref:System.Windows.Threading.Dispatcher> skojarzone z bieżącym wątkiem i porównuje go z odwołaniem <xref:System.Windows.Threading.Dispatcher> przechowywanym podczas konstruowania.</span><span class="sxs-lookup"><span data-stu-id="5633b-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="5633b-143">Jeśli nie są zgodne, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="5633b-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="5633b-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> jest przeznaczony do wywołania na początku każdej metody należącej do <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="5633b-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="5633b-145">Jeśli tylko jeden wątek może zmodyfikować [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], jak wątki w tle współdziałają z użytkownikiem?</span><span class="sxs-lookup"><span data-stu-id="5633b-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="5633b-146">Wątek w tle może zażądać wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], aby wykonać operację w jej imieniu.</span><span class="sxs-lookup"><span data-stu-id="5633b-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="5633b-147">Robi to poprzez zarejestrowanie elementu pracy z <xref:System.Windows.Threading.Dispatcher> wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-148">Klasa <xref:System.Windows.Threading.Dispatcher> udostępnia dwie metody rejestrowania elementów roboczych: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="5633b-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="5633b-149">Obie metody planują delegata do wykonania.</span><span class="sxs-lookup"><span data-stu-id="5633b-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="5633b-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest wywołaniem synchronicznym — to oznacza, że nie zwraca do momentu, gdy wątek [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rzeczywiście kończy wykonywanie delegata.</span><span class="sxs-lookup"><span data-stu-id="5633b-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="5633b-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczny i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="5633b-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="5633b-152"><xref:System.Windows.Threading.Dispatcher> Porządkuje elementy w kolejce według priorytetu.</span><span class="sxs-lookup"><span data-stu-id="5633b-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="5633b-153">Istnieje dziesięć poziomów, które można określić podczas dodawania elementu do kolejki <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5633b-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="5633b-154">Te priorytety są utrzymywane w wyliczeniu <xref:System.Windows.Threading.DispatcherPriority>.</span><span class="sxs-lookup"><span data-stu-id="5633b-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="5633b-155">Szczegółowe informacje na temat poziomów <xref:System.Windows.Threading.DispatcherPriority> można znaleźć w dokumentacji Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="5633b-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="5633b-156">Wątki w akcji: przykłady</span><span class="sxs-lookup"><span data-stu-id="5633b-156">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="5633b-157">Jednowątkowa aplikacja z długotrwałym obliczaniem</span><span class="sxs-lookup"><span data-stu-id="5633b-157">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="5633b-158">Większość graficznych interfejsów użytkownika (GUI) poświęca dużą część czasu bezczynności podczas oczekiwania na zdarzenia, które są generowane w odpowiedzi na interakcje użytkownika.</span><span class="sxs-lookup"><span data-stu-id="5633b-158">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="5633b-159">Ostrożne programowanie tego czasu bezczynności może być stosowane zwyczajowo, bez wywierania wpływu na czas odpowiedzi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="5633b-160">Model wątkowości [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] nie zezwala na dane wejściowe do przerwania operacji wykonywanej w wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-161">Oznacza to, że należy pamiętać, aby okresowo wrócić do <xref:System.Windows.Threading.Dispatcher>, aby przetworzyć oczekujące zdarzenia wejściowe, zanim staną się nieaktualne.</span><span class="sxs-lookup"><span data-stu-id="5633b-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="5633b-162">Rozważmy następujący przykład:</span><span class="sxs-lookup"><span data-stu-id="5633b-162">Consider the following example:</span></span>

 ![Zrzut ekranu pokazujący wątki numerów pierwszych.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="5633b-164">Ta prosta aplikacja liczy się w górę od trzech, wyszukując cyfry podstawowe.</span><span class="sxs-lookup"><span data-stu-id="5633b-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="5633b-165">Gdy użytkownik kliknie przycisk **Start** , rozpocznie się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="5633b-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="5633b-166">Po znalezieniu programu Program aktualizuje interfejs użytkownika przy użyciu odnajdywania.</span><span class="sxs-lookup"><span data-stu-id="5633b-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="5633b-167">W dowolnym momencie użytkownik może zatrzymać wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="5633b-167">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="5633b-168">Chociaż jest to bardzo proste, wyszukiwanie w liczbie pierwszych może być bardzo trudne, co stwarza pewne problemy.</span><span class="sxs-lookup"><span data-stu-id="5633b-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="5633b-169">Jeśli przeprowadzimy całe wyszukiwanie w ramach programu obsługi zdarzeń kliknięcia przycisku, nigdy nie wyślemy do wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] szansy do obsługi innych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="5633b-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="5633b-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nie będzie w stanie odpowiedzieć na komunikaty wejściowe lub procesowe.</span><span class="sxs-lookup"><span data-stu-id="5633b-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="5633b-171">Nigdy nie będzie można go odświeżyć i nigdy nie reaguje na kliknięcia przycisku.</span><span class="sxs-lookup"><span data-stu-id="5633b-171">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="5633b-172">Możemy przeszukać numer w osobnym wątku, ale należy zająć się problemami z synchronizacją.</span><span class="sxs-lookup"><span data-stu-id="5633b-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="5633b-173">Dzięki podejściu jednowątkowego można bezpośrednio zaktualizować etykietę, która wyświetla największy znaleziony.</span><span class="sxs-lookup"><span data-stu-id="5633b-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="5633b-174">W przypadku podziału zadania obliczeń na fragmenty zarządzane można okresowo wrócić do <xref:System.Windows.Threading.Dispatcher> i przetwarzania zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="5633b-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="5633b-175">Możemy dać [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] możliwość odświeżenia i przetworzenia danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="5633b-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="5633b-176">Najlepszym sposobem podziału czasu przetwarzania między obliczeniami a obsługą zdarzeń jest zarządzanie obliczeniami z <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5633b-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="5633b-177">Za pomocą metody <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> możemy zaplanować sprawdzanie liczby pierwszych w tej samej kolejce, z której są rysowane [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="5633b-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="5633b-178">W naszym przykładzie zaplanuję tylko jednolite sprawdzenie liczby.</span><span class="sxs-lookup"><span data-stu-id="5633b-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="5633b-179">Po zakończeniu sprawdzania numeru na stronie zostanie zaplanowana natychmiastowa ponowna kontrola.</span><span class="sxs-lookup"><span data-stu-id="5633b-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="5633b-180">To sprawdzanie jest wykonywane dopiero po obsłużoniu oczekujących zdarzeń [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Zrzut ekranu przedstawiający kolejkę dyspozytora.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="5633b-182">Program Microsoft Word wykonuje sprawdzanie pisowni przy użyciu tego mechanizmu.</span><span class="sxs-lookup"><span data-stu-id="5633b-182">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="5633b-183">Sprawdzanie pisowni odbywa się w tle przy użyciu czasu bezczynności wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-184">Spójrzmy na kod.</span><span class="sxs-lookup"><span data-stu-id="5633b-184">Let's take a look at the code.</span></span>

 <span data-ttu-id="5633b-185">Poniższy przykład pokazuje kod XAML, który tworzy interfejs użytkownika.</span><span class="sxs-lookup"><span data-stu-id="5633b-185">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="5633b-186">Poniższy przykład pokazuje kod w tle.</span><span class="sxs-lookup"><span data-stu-id="5633b-186">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="5633b-187">Poniższy przykład pokazuje procedurę obsługi zdarzeń dla <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="5633b-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="5633b-188">Oprócz aktualizowania tekstu w <xref:System.Windows.Controls.Button>, program obsługi jest odpowiedzialny za planowanie pierwszego sprawdzenia numeru, dodając delegata do kolejki <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5633b-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="5633b-189">Gdy ten program obsługi zdarzeń zakończy pracę, <xref:System.Windows.Threading.Dispatcher> wybierze tego delegata do wykonania.</span><span class="sxs-lookup"><span data-stu-id="5633b-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="5633b-190">Jak wspomniano wcześniej, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest członkiem <xref:System.Windows.Threading.Dispatcher> używanym do zaplanowania delegata do wykonania.</span><span class="sxs-lookup"><span data-stu-id="5633b-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="5633b-191">W takim przypadku wybieramy priorytet <xref:System.Windows.Threading.DispatcherPriority.SystemIdle>.</span><span class="sxs-lookup"><span data-stu-id="5633b-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="5633b-192"><xref:System.Windows.Threading.Dispatcher> będzie wykonywać tego delegata tylko wtedy, gdy nie ma ważnych zdarzeń do przetworzenia.</span><span class="sxs-lookup"><span data-stu-id="5633b-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> <span data-ttu-id="5633b-193">czas odpowiedzi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] jest ważniejszy niż sprawdzanie liczby.</span><span class="sxs-lookup"><span data-stu-id="5633b-193">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking.</span></span> <span data-ttu-id="5633b-194">Przekazujemy również nowy delegat reprezentujący procedurę sprawdzania liczby.</span><span class="sxs-lookup"><span data-stu-id="5633b-194">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="5633b-195">Ta metoda sprawdza, czy Następna liczba nieparzysta jest podstawowa.</span><span class="sxs-lookup"><span data-stu-id="5633b-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="5633b-196">Jeśli jest to zapora, metoda bezpośrednio aktualizuje <xref:System.Windows.Controls.TextBlock> `bigPrime`, aby odzwierciedlała ich odnajdywanie.</span><span class="sxs-lookup"><span data-stu-id="5633b-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="5633b-197">Można to zrobić, ponieważ obliczenia występują w tym samym wątku, który został użyty do utworzenia składnika.</span><span class="sxs-lookup"><span data-stu-id="5633b-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="5633b-198">Wybrano, aby użyć oddzielnego wątku do obliczenia. będziemy musieli użyć bardziej skomplikowanego mechanizmu synchronizacji i wykonać aktualizację w wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-199">Zobaczymy tę sytuację dalej.</span><span class="sxs-lookup"><span data-stu-id="5633b-199">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="5633b-200">Aby uzyskać pełny kod źródłowy dla tego przykładu, zobacz [jednowątkowa aplikacja z przykładowym obliczeniem długotrwałym](https://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="5633b-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="5633b-201">Obsługa operacji blokowania z wątkiem w tle</span><span class="sxs-lookup"><span data-stu-id="5633b-201">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="5633b-202">Obsługa operacji blokowania w aplikacji graficznej może być trudna.</span><span class="sxs-lookup"><span data-stu-id="5633b-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="5633b-203">Nie chcemy wywoływać metod blokowania z obsługi zdarzeń, ponieważ aplikacja zostanie wyświetlona w celu zablokowania.</span><span class="sxs-lookup"><span data-stu-id="5633b-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="5633b-204">Możemy użyć oddzielnego wątku, aby obsłużyć te operacje, ale gdy wszystko będzie gotowe, musimy przeprowadzić synchronizację z wątkiem [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], ponieważ nie można bezpośrednio zmodyfikować graficznego interfejsu użytkownika z naszego wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="5633b-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="5633b-205">Za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> można wstawiać delegatów do <xref:System.Windows.Threading.Dispatcher> wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-206">W rezultacie te Delegaty zostaną wykonane z uprawnieniami do modyfikowania elementów [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="5633b-207">W tym przykładzie naśladuje zdalne wywołanie procedury, które pobiera prognozę pogody.</span><span class="sxs-lookup"><span data-stu-id="5633b-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="5633b-208">Używamy oddzielnego wątku roboczego do wykonania tego wywołania i planujemy metodę Update w <xref:System.Windows.Threading.Dispatcher> wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="5633b-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Zrzut ekranu przedstawiający interfejs użytkownika pogody.](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="5633b-210">Poniżej przedstawiono niektóre szczegółowe informacje, które należy zanotować.</span><span class="sxs-lookup"><span data-stu-id="5633b-210">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="5633b-211">Tworzenie procedury obsługi przycisku</span><span class="sxs-lookup"><span data-stu-id="5633b-211">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="5633b-212">Po kliknięciu przycisku zostanie wyświetlony rysunek zegar i rozpocznie się jego animowanie.</span><span class="sxs-lookup"><span data-stu-id="5633b-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="5633b-213">Wyłącz przycisk.</span><span class="sxs-lookup"><span data-stu-id="5633b-213">We disable the button.</span></span> <span data-ttu-id="5633b-214">Wywołujemy metodę `FetchWeatherFromServer` w nowym wątku, a następnie zwracamy, aby <xref:System.Windows.Threading.Dispatcher> do przetwarzania zdarzeń w czasie oczekiwania na zebranie prognozy pogody.</span><span class="sxs-lookup"><span data-stu-id="5633b-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="5633b-215">Pobieranie pogody</span><span class="sxs-lookup"><span data-stu-id="5633b-215">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="5633b-216">Aby zachować prostotę, w tym przykładzie nie ma żadnego kodu sieciowego.</span><span class="sxs-lookup"><span data-stu-id="5633b-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="5633b-217">Zamiast tego symulowanie opóźnień dostępu do sieci przez umieszczenie nowego wątku w stanie uśpienia przez cztery sekundy.</span><span class="sxs-lookup"><span data-stu-id="5633b-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="5633b-218">W tym czasie oryginalny wątek [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nadal działa i odpowiada na zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="5633b-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="5633b-219">Aby to pokazać, pozostawiłeś animację, a przyciski Minimalizuj i Maksymalizuj również nadal działają.</span><span class="sxs-lookup"><span data-stu-id="5633b-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="5633b-220">Gdy opóźnienie zostanie zakończone i losowo wybieramy prognozę pogody, czas na zgłoszenie do wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-221">Możemy to zrobić przez zaplanowanie wywołania `UpdateUserInterface` w wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] przy użyciu <xref:System.Windows.Threading.Dispatcher>tego wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="5633b-222">Przekazujemy ciąg opisujący Pogoda do tego wywołania metody zaplanowanej.</span><span class="sxs-lookup"><span data-stu-id="5633b-222">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="5633b-223">Aktualizowanie [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="5633b-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="5633b-224">Gdy <xref:System.Windows.Threading.Dispatcher> w wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] ma czas wykonywania zaplanowanego wywołania do `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="5633b-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="5633b-225">Ta metoda powoduje zatrzymanie animacji zegara i wybranie obrazu opisującego Pogoda.</span><span class="sxs-lookup"><span data-stu-id="5633b-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="5633b-226">Wyświetla ten obraz i przywraca przycisk "Pobierz prognozę".</span><span class="sxs-lookup"><span data-stu-id="5633b-226">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="5633b-227">Wiele okien, wiele wątków</span><span class="sxs-lookup"><span data-stu-id="5633b-227">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="5633b-228">Niektóre aplikacje [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] wymagają wielu okien najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="5633b-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="5633b-229">Jest to doskonale akceptowalne dla jednej kombinacji wątku/<xref:System.Windows.Threading.Dispatcher>, aby zarządzać wieloma oknami, ale czasami kilka wątków ma lepsze zadanie.</span><span class="sxs-lookup"><span data-stu-id="5633b-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="5633b-230">Jest to szczególnie prawdziwe, jeśli istnieje prawdopodobieństwo, że jeden z okien będzie monopolize wątek.</span><span class="sxs-lookup"><span data-stu-id="5633b-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="5633b-231">Eksplorator Windows działa w ten sposób.</span><span class="sxs-lookup"><span data-stu-id="5633b-231">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="5633b-232">Każde nowe okno Eksploratora należy do oryginalnego procesu, ale jest tworzone w ramach formantu niezależnego wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="5633b-233">Za pomocą kontrolki <xref:System.Windows.Controls.Frame> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]można wyświetlić strony sieci Web.</span><span class="sxs-lookup"><span data-stu-id="5633b-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="5633b-234">Można łatwo utworzyć prosty substytut programu Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="5633b-234">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="5633b-235">Zaczynamy od ważnej funkcji: możliwość otwarcia nowego okna Eksploratora.</span><span class="sxs-lookup"><span data-stu-id="5633b-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="5633b-236">Gdy użytkownik kliknie przycisk "nowe okno", zostanie uruchomiona kopia naszego okna w osobnym wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="5633b-237">W ten sposób długotrwałe lub zablokowanie operacji w jednym z okien nie spowoduje zablokowania wszystkich innych okien.</span><span class="sxs-lookup"><span data-stu-id="5633b-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="5633b-238">W rzeczywistości model przeglądarki sieci Web ma swój własny skomplikowany model wątkowości.</span><span class="sxs-lookup"><span data-stu-id="5633b-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="5633b-239">Została wybrana, ponieważ powinna być znana większością czytelników.</span><span class="sxs-lookup"><span data-stu-id="5633b-239">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="5633b-240">Poniższy przykład pokazuje kod.</span><span class="sxs-lookup"><span data-stu-id="5633b-240">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="5633b-241">Następujące segmenty wątku tego kodu są najbardziej interesujące dla nas w tym kontekście:</span><span class="sxs-lookup"><span data-stu-id="5633b-241">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="5633b-242">Ta metoda jest wywoływana, gdy zostanie kliknięty przycisk "nowe okno".</span><span class="sxs-lookup"><span data-stu-id="5633b-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="5633b-243">Tworzy nowy wątek i uruchamia go asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="5633b-243">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="5633b-244">Ta metoda jest punktem początkowym dla nowego wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="5633b-245">Tworzymy nowe okno pod kontrolą tego wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="5633b-246">automatycznie tworzy nowy <xref:System.Windows.Threading.Dispatcher> do zarządzania nowym wątkiem.</span><span class="sxs-lookup"><span data-stu-id="5633b-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="5633b-247">Wszystko, co należy zrobić, aby uruchomić okno <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5633b-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="5633b-248">Szczegóły techniczne i punkty Stumbling</span><span class="sxs-lookup"><span data-stu-id="5633b-248">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="5633b-249">Pisanie składników przy użyciu wątków</span><span class="sxs-lookup"><span data-stu-id="5633b-249">Writing Components Using Threading</span></span>
 <span data-ttu-id="5633b-250">Przewodnik dewelopera Microsoft .NET Framework opisuje wzorzec, w jaki składnik może ujawniać asynchroniczne zachowanie klientom (zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="5633b-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="5633b-251">Na przykład załóżmy, że chcemy spakować metodę `FetchWeatherFromServer` w składniku wielokrotnego użytku, niegraficznym.</span><span class="sxs-lookup"><span data-stu-id="5633b-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="5633b-252">Zgodnie ze standardowym wzorcem programu Microsoft .NET Framework będzie wyglądać podobnie do poniższego.</span><span class="sxs-lookup"><span data-stu-id="5633b-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="5633b-253">`GetWeatherAsync` użyje jednej z opisanych wcześniej technik, takich jak tworzenie wątku w tle, do wykonywania pracy asynchronicznej, bez blokowania wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="5633b-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="5633b-254">Jedną z najważniejszych części tego wzorca jest wywołanie metody *MethodName*`Completed` w tym samym wątku, który wywołał metodę *MethodName*`Async`, aby rozpocząć od.</span><span class="sxs-lookup"><span data-stu-id="5633b-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="5633b-255">Można to zrobić za pomocą [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dość łatwo, przez przechowywanie <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>, a następnie składnika niegraficznego można używać tylko w aplikacjach [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], a nie w programach [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] i ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="5633b-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET programs.</span></span>

 <span data-ttu-id="5633b-256">Klasa <xref:System.Windows.Threading.DispatcherSynchronizationContext> zaspokaja tę potrzebę — należy traktować ją jako uproszczoną wersję <xref:System.Windows.Threading.Dispatcher>, która współpracuje z innymi środowiskami [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="5633b-257">Zagnieżdżona pompa</span><span class="sxs-lookup"><span data-stu-id="5633b-257">Nested Pumping</span></span>
 <span data-ttu-id="5633b-258">Czasami nie jest możliwe całkowite zablokowanie wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-259">Rozważmy metodę <xref:System.Windows.MessageBox.Show%2A> klasy <xref:System.Windows.MessageBox>.</span><span class="sxs-lookup"><span data-stu-id="5633b-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="5633b-260"><xref:System.Windows.MessageBox.Show%2A> nie zwraca do momentu kliknięcia przycisku OK przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="5633b-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="5633b-261">Istnieje jednak możliwość utworzenia okna, które musi zawierać pętlę komunikatów, aby można było go interaktywnie.</span><span class="sxs-lookup"><span data-stu-id="5633b-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="5633b-262">Gdy oczekujemy, że użytkownik kliknie przycisk OK, oryginalne okno aplikacji nie odpowiada na dane wejściowe użytkownika.</span><span class="sxs-lookup"><span data-stu-id="5633b-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="5633b-263">Można jednak nadal przetwarzać komunikaty programu Paint.</span><span class="sxs-lookup"><span data-stu-id="5633b-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="5633b-264">Oryginalne okno jest ponownie rysowane po pokrytym i ujawnionym czasie.</span><span class="sxs-lookup"><span data-stu-id="5633b-264">The original window redraws itself when covered and revealed.</span></span>

 ![Zrzut ekranu, który pokazuje element MessageBox z przyciskiem OK](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="5633b-266">Część wątku musi być obciążona oknem komunikatu.</span><span class="sxs-lookup"><span data-stu-id="5633b-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="5633b-267">może utworzyć nowy wątek tylko dla okna komunikatu, ale ten wątek nie będzie mógł malować wyłączonych elementów w oryginalnym oknie (należy pamiętać o wcześniejszym omówieniu wzajemnego wykluczenia).</span><span class="sxs-lookup"><span data-stu-id="5633b-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="5633b-268">Zamiast tego [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] używa zagnieżdżonego systemu przetwarzania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="5633b-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="5633b-269">Klasa <xref:System.Windows.Threading.Dispatcher> zawiera specjalną metodę o nazwie <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, która przechowuje bieżący punkt wykonywania aplikacji, a następnie rozpoczyna nową pętlę komunikatów.</span><span class="sxs-lookup"><span data-stu-id="5633b-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="5633b-270">Po zakończeniu zagnieżdżonej pętli komunikatów wykonywanie jest wznawiane po oryginalnym wywołaniu <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>.</span><span class="sxs-lookup"><span data-stu-id="5633b-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="5633b-271">W tym przypadku <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> utrzymuje kontekst programu w wywołaniu <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>i uruchamia nową pętlę komunikatów w celu odświeżenia okna tła i obsługi danych wejściowych w oknie komunikatu.</span><span class="sxs-lookup"><span data-stu-id="5633b-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="5633b-272">Gdy użytkownik kliknie przycisk OK i wyczyści okno podręczne, zagnieżdżona pętla zostanie ZAMKNIĘTA, a kontrolka zostanie wznowiona po wywołaniu <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="5633b-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="5633b-273">Nieodświeżone zdarzenia kierowane</span><span class="sxs-lookup"><span data-stu-id="5633b-273">Stale Routed Events</span></span>
 <span data-ttu-id="5633b-274">System zdarzeń kierowany w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] powiadamia całe drzewa o zdarzeniach.</span><span class="sxs-lookup"><span data-stu-id="5633b-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="5633b-275">Po naciśnięciu lewego przycisku myszy nad elipsą `handler2` jest wykonywane.</span><span class="sxs-lookup"><span data-stu-id="5633b-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="5633b-276">Po zakończeniu `handler2` zdarzenie jest przesyłane wraz z obiektem <xref:System.Windows.Controls.Canvas>, który używa `handler1` do przetworzenia.</span><span class="sxs-lookup"><span data-stu-id="5633b-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="5633b-277">Dzieje się tak tylko wtedy, gdy `handler2` nie oznacza jawnie oznaczenia obiektu zdarzenia jako obsłużonego.</span><span class="sxs-lookup"><span data-stu-id="5633b-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="5633b-278">Istnieje możliwość, że `handler2` będzie bardzo czasochłonne przetwarzanie tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="5633b-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="5633b-279">`handler2` może użyć <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, aby rozpocząć zagnieżdżoną pętlę komunikatów, która nie jest zwracana przez godziny.</span><span class="sxs-lookup"><span data-stu-id="5633b-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="5633b-280">Jeśli `handler2` nie oznacza zdarzenia jako obsługiwanego po zakończeniu tej pętli komunikatu, zdarzenie jest przenoszone w górę drzewa, mimo że jest bardzo stare.</span><span class="sxs-lookup"><span data-stu-id="5633b-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="5633b-281">Współużytkowania wątkowości i blokowanie</span><span class="sxs-lookup"><span data-stu-id="5633b-281">Reentrancy and Locking</span></span>
 <span data-ttu-id="5633b-282">Mechanizm blokowania aparatu plików wykonywalnych języka wspólnego (CLR) nie zachowuje się dokładnie tak, jak to możliwe. może oczekiwać, że wątek zaprzestanie operacji w całości podczas żądania blokady.</span><span class="sxs-lookup"><span data-stu-id="5633b-282">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="5633b-283">W rzeczywistości wątek nadal otrzymuje i przetwarza komunikaty o wysokim priorytecie.</span><span class="sxs-lookup"><span data-stu-id="5633b-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="5633b-284">Pomaga to zapobiegać zakleszczeniom i sprawiać, że interfejsy w minimalnym stopniu odpowiadają, ale wprowadzają możliwość delikatnych usterek.</span><span class="sxs-lookup"><span data-stu-id="5633b-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="5633b-285">Ogromna większość czasu nie musi wiedzieć o tym, ale w rzadkich przypadkach (zwykle dotyczy to komunikatów okien [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] lub komponentów STA COM). może to być świadome.</span><span class="sxs-lookup"><span data-stu-id="5633b-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="5633b-286">Większość interfejsów nie jest zbudowana z myślą o bezpieczeństwie wątków, ponieważ deweloperzy pracują w założeniu, że [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nigdy nie uzyskuje dostępu do więcej niż jednego wątku.</span><span class="sxs-lookup"><span data-stu-id="5633b-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="5633b-287">W takim przypadku ten pojedynczy wątek może wprowadzać zmiany w środowisku w nieoczekiwanym czasie, powodując niekorzystne skutki, że <xref:System.Windows.Threading.DispatcherObject> mechanizm wzajemnego wykluczania ma zostać rozwiązany.</span><span class="sxs-lookup"><span data-stu-id="5633b-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="5633b-288">Weź pod uwagę następujące pseudokodzie:</span><span class="sxs-lookup"><span data-stu-id="5633b-288">Consider the following pseudocode:</span></span>

 <span data-ttu-id="5633b-289">![Diagram przedstawiający współużytkowania wątkowości wątków.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="5633b-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="5633b-290">W większości przypadków jest to możliwe, ale istnieją czasy [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], w których takie nieoczekiwane współużytkowania wątkowości może naprawdę spowodować problemy.</span><span class="sxs-lookup"><span data-stu-id="5633b-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="5633b-291">Tak więc w określonych godzinach klucze [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] wywołuje <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, co zmienia instrukcje blokady dla tego wątku, tak aby używały blokady [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] współużytkowania wątkowości-Free, zamiast zwykłej blokady środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="5633b-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="5633b-292">Dlaczego zespół CLR wybiera takie zachowanie?</span><span class="sxs-lookup"><span data-stu-id="5633b-292">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="5633b-293">Musiało to zrobić z obiektami COM STA i wątkiem finalizacji.</span><span class="sxs-lookup"><span data-stu-id="5633b-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="5633b-294">Gdy obiekt jest odzyskiwany jako elementy bezużyteczne, jego `Finalize` Metoda jest uruchamiana w ramach dedykowanego wątku finalizatora, a nie wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-295">Jest to problem, ponieważ obiekt STA COM, który został utworzony w wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] można usunąć tylko w wątku [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5633b-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5633b-296">Środowisko CLR pełni odpowiednik <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (w tym przypadku przy użyciu `SendMessage`Win32's).</span><span class="sxs-lookup"><span data-stu-id="5633b-296">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="5633b-297">Ale jeśli wątek [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] jest zajęty, wątek finalizatora jest wstrzymany i nie można usunąć obiektu COM STA, co powoduje powstanie poważnych przecieków pamięci.</span><span class="sxs-lookup"><span data-stu-id="5633b-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="5633b-298">Dlatego zespół CLR wykonał trudne wywołanie, aby blokady działały w taki sposób.</span><span class="sxs-lookup"><span data-stu-id="5633b-298">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="5633b-299">Zadaniem dla [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] jest uniknięcie nieoczekiwanej współużytkowania wątkowości bez konieczności podania wycieku pamięci, dlatego nie blokujemy współużytkowania wątkowości wszędzie.</span><span class="sxs-lookup"><span data-stu-id="5633b-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="5633b-300">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="5633b-300">See also</span></span>

- [<span data-ttu-id="5633b-301">Przykładowa aplikacja jednowątkowa o długim czasie wykonywania obliczeń</span><span class="sxs-lookup"><span data-stu-id="5633b-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
