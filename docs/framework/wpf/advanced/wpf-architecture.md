---
title: Architektura
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: b16be8470a47f3e8e362feb0b13e10aa901baacb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187130"
---
# <a name="wpf-architecture"></a><span data-ttu-id="de5a5-102">Architektura WPF</span><span class="sxs-lookup"><span data-stu-id="de5a5-102">WPF Architecture</span></span>
<span data-ttu-id="de5a5-103">Ten temat zawiera przewodnik po hierarchii klas Programu Windows Presentation Foundation (WPF).</span><span class="sxs-lookup"><span data-stu-id="de5a5-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="de5a5-104">Obejmuje większość głównych podsystemów WPF I opisuje, jak współdziałają.</span><span class="sxs-lookup"><span data-stu-id="de5a5-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="de5a5-105">Zawiera również szczegółowe informacje na temat niektórych wyborów dokonanych przez architektów WPF.</span><span class="sxs-lookup"><span data-stu-id="de5a5-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>
## <a name="systemobject"></a><span data-ttu-id="de5a5-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="de5a5-106">System.Object</span></span>  
 <span data-ttu-id="de5a5-107">Podstawowy model programowania WPF jest udostępniane za pośrednictwem kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="de5a5-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="de5a5-108">Na początku fazy projektowania WPF było wiele dyskusji na temat tego, gdzie linia powinna być rysowana między zarządzanymi składnikami systemu a niezarządzanymi.</span><span class="sxs-lookup"><span data-stu-id="de5a5-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="de5a5-109">Środowisko CLR zapewnia szereg funkcji, które sprawiają, że rozwój jest bardziej produktywny i niezawodny (w tym zarządzanie pamięcią, obsługa błędów, system typowych typów itp.), ale są one kosztowne.</span><span class="sxs-lookup"><span data-stu-id="de5a5-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="de5a5-110">Główne składniki WPF są zilustrowane na poniższym rysunku.</span><span class="sxs-lookup"><span data-stu-id="de5a5-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="de5a5-111">Czerwone sekcje diagramu (PresentationFramework, PresentationCore i milcore) są głównymi częściami kodu WPF.</span><span class="sxs-lookup"><span data-stu-id="de5a5-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="de5a5-112">Z nich tylko jeden jest niezarządzanym składnikiem – milcore.</span><span class="sxs-lookup"><span data-stu-id="de5a5-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="de5a5-113">Milcore jest napisany w niezarządzanym kodzie w celu umożliwienia ścisłej integracji z DirectX.</span><span class="sxs-lookup"><span data-stu-id="de5a5-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="de5a5-114">Wszystkie wyświetlacze w WPF odbywa się za pośrednictwem silnika DirectX, co pozwala na wydajne renderowanie sprzętu i oprogramowania.</span><span class="sxs-lookup"><span data-stu-id="de5a5-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="de5a5-115">WPF WPF również wymaga precyzyjnej kontroli nad pamięcią i wykonaniem.</span><span class="sxs-lookup"><span data-stu-id="de5a5-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="de5a5-116">Silnik kompozycji w milicore jest niezwykle czuły na wydajność i wymaga rezygnacji z wielu zalet CLR, aby uzyskać wydajność.</span><span class="sxs-lookup"><span data-stu-id="de5a5-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="de5a5-117">![Pozycja WPF WPF w ramach .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="de5a5-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="de5a5-118">Komunikacja między zarządzanych i niezarządzanych części WPF WPF jest omówione w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="de5a5-119">Pozostała część modelu programowania zarządzanego jest opisana poniżej.</span><span class="sxs-lookup"><span data-stu-id="de5a5-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="de5a5-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="de5a5-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="de5a5-121">Większość obiektów w WPF <xref:System.Windows.Threading.DispatcherObject>pochodzą od , który zapewnia podstawowe konstrukcje do czynienia z współbieżności i wątkowości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="de5a5-122">WPF WPF jest oparty na systemie obsługi wiadomości zaimplementowanym przez dyspozytora.</span><span class="sxs-lookup"><span data-stu-id="de5a5-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="de5a5-123">To działa podobnie jak znane Pompy wiadomości Win32; w rzeczywistości dyspozytor WPF używa user32 wiadomości do wykonywania wywołań wątku krzyżowego.</span><span class="sxs-lookup"><span data-stu-id="de5a5-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="de5a5-124">Istnieją naprawdę dwa podstawowe pojęcia do zrozumienia podczas omawiania współbieżności w WPF — dyspozytora i koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="de5a5-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="de5a5-125">W fazie projektowania WPF, celem było przejście do pojedynczego wątku wykonywania, ale nie wątku "affinitized" modelu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="de5a5-126">Koligacja wątku dzieje się, gdy składnik używa tożsamości wątku wykonującego do przechowywania pewnego typu stanu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="de5a5-127">Najczęstszą formą tego jest użycie magazynu lokalnego wątku (TLS) do przechowywania stanu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="de5a5-128">Koligacja wątku wymaga, aby każdy logiczny wątek wykonywania był własnością tylko jednego wątku fizycznego w systemie operacyjnym, który może stać się intensywnie korzystający z pamięci.</span><span class="sxs-lookup"><span data-stu-id="de5a5-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="de5a5-129">W końcu model wątkowości WPF był zsynchronizowany z istniejącym modelem wątkowości User32 wykonywania jednowtowego z koligacją wątku.</span><span class="sxs-lookup"><span data-stu-id="de5a5-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="de5a5-130">Głównym powodem tego było współdziałanie — systemy takie jak OLE 2.0, schowek i program Internet Explorer wymagają wykonywania koligacji pojedynczego wątku (STA).</span><span class="sxs-lookup"><span data-stu-id="de5a5-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="de5a5-131">Biorąc pod uwagę, że masz obiekty z wątków STA, należy sposób komunikowania się między wątkami i sprawdź, czy jesteś na poprawny wątek.</span><span class="sxs-lookup"><span data-stu-id="de5a5-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="de5a5-132">Tutaj leży rola dyspozytora.</span><span class="sxs-lookup"><span data-stu-id="de5a5-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="de5a5-133">Dyspozytor jest podstawowym systemem dyspozytora wiadomości, z wieloma priorytetowymi kolejkami.</span><span class="sxs-lookup"><span data-stu-id="de5a5-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="de5a5-134">Przykłady komunikatów obejmują nieprzetworzone powiadomienia wejściowe (przenoszone myszą), funkcje struktury (układ) lub polecenia użytkownika (wykonaj tę metodę).</span><span class="sxs-lookup"><span data-stu-id="de5a5-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="de5a5-135">Wywodząc <xref:System.Windows.Threading.DispatcherObject>się z obiektu CLR, który ma zachowanie STA i zostanie podany wskaźnik do dyspozytora w czasie tworzenia.</span><span class="sxs-lookup"><span data-stu-id="de5a5-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="de5a5-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="de5a5-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="de5a5-137">Jedną z podstawowych filozofii architektonicznych stosowanych w budowaniu WPF było preferowanie właściwości nad metodami lub zdarzeniami.</span><span class="sxs-lookup"><span data-stu-id="de5a5-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="de5a5-138">Właściwości są deklaratywne i umożliwiają łatwiejsze określenie intencji zamiast akcji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="de5a5-139">Obsługa modelu opartego na modelu lub opartego na danych systemu do wyświetlania zawartości interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="de5a5-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="de5a5-140">Ta filozofia miała zamierzony efekt tworzenia większej liczby właściwości, które można powiązać, w celu lepszego kontrolowania zachowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="de5a5-141">Aby mieć więcej systemu napędzanego przez właściwości, potrzebny był bogatszy system właściwości niż to, co zapewnia CLR.</span><span class="sxs-lookup"><span data-stu-id="de5a5-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="de5a5-142">Prostym przykładem tego bogactwa są powiadomienia o zmianach.</span><span class="sxs-lookup"><span data-stu-id="de5a5-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="de5a5-143">Aby włączyć dwukierunkowe powiązanie, potrzebujesz obu stron powiązania do obsługi powiadomienia o zmianie.</span><span class="sxs-lookup"><span data-stu-id="de5a5-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="de5a5-144">Aby zachowanie było powiązane z wartościami właściwości, należy otrzymywać powiadomienia o zmianie wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="de5a5-145">Microsoft .NET Framework ma interfejs **INotifyPropertyChange**, który umożliwia obiektowi publikowanie powiadomień o zmianie, jednak jest to opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="de5a5-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="de5a5-146">WPF WPF zapewnia bogatszy system <xref:System.Windows.DependencyObject> właściwości, pochodzące od typu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="de5a5-147">System właściwości jest naprawdę "zależności" system właściwości, w tym śledzi zależności między wyrażeniami właściwości i automatycznie ponownie zmienia waloryzuje wartości właściwości po zmianie zależności.</span><span class="sxs-lookup"><span data-stu-id="de5a5-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="de5a5-148">Na przykład jeśli masz właściwość, która <xref:System.Windows.Controls.Control.FontSize%2A>dziedziczy (jak ), system jest automatycznie aktualizowany, jeśli właściwość zmienia się na element nadrzędny elementu, który dziedziczy wartość.</span><span class="sxs-lookup"><span data-stu-id="de5a5-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="de5a5-149">Podstawą systemu właściwości WPF jest pojęcie wyrażenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="de5a5-150">W tej pierwszej wersji WPF WPF system wyrażeń właściwości jest zamknięty, a wyrażenia są dostarczane jako część struktury.</span><span class="sxs-lookup"><span data-stu-id="de5a5-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="de5a5-151">Wyrażenia są dlaczego system właściwości nie ma powiązania danych, stylizacji lub dziedziczenia zakodowane na czas, ale raczej dostarczane przez późniejsze warstwy w ramach.</span><span class="sxs-lookup"><span data-stu-id="de5a5-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="de5a5-152">System właściwości zapewnia również rozrzedzone przechowywanie wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="de5a5-153">Ponieważ obiekty mogą mieć dziesiątki (jeśli nie setki) właściwości, a większość wartości jest w stanie domyślnym (dziedziczona, ustawiana przez style itp.), nie każde wystąpienie obiektu musi mieć pełną wagę każdej właściwości zdefiniowanej na nim.</span><span class="sxs-lookup"><span data-stu-id="de5a5-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="de5a5-154">Ostatnią nową cechą systemu nieruchomości jest pojęcie dołączonych właściwości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="de5a5-155">Elementy WPF są zbudowane na zasadzie składu i ponownego użycia komponentu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="de5a5-156">Często jest tak, że niektóre zawierające <xref:System.Windows.Controls.Grid> element (jak element układu) potrzebuje dodatkowych danych na elementy podrzędne do kontrolowania jego zachowanie (jak wiersz/kolumna informacji).</span><span class="sxs-lookup"><span data-stu-id="de5a5-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="de5a5-157">Zamiast kojarzenia wszystkich tych właściwości z każdym elementem, każdy obiekt może podać definicje właściwości dla dowolnego innego obiektu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="de5a5-158">Jest to podobne do funkcji "expando" języka JavaScript.</span><span class="sxs-lookup"><span data-stu-id="de5a5-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="de5a5-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="de5a5-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="de5a5-160">Po zdefiniowaeniu systemu następnym krokiem jest rysowanie pikseli na ekranie.</span><span class="sxs-lookup"><span data-stu-id="de5a5-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="de5a5-161">Klasa <xref:System.Windows.Media.Visual> umożliwia tworzenie drzewa obiektów wizualnych, z których każdy opcjonalnie zawiera instrukcje rysowania i metadane dotyczące sposobu renderowania tych instrukcji (przycinanie, transformacja itp.).</span><span class="sxs-lookup"><span data-stu-id="de5a5-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="de5a5-162"><xref:System.Windows.Media.Visual>został zaprojektowany tak, aby był niezwykle lekki i elastyczny, więc większość funkcji nie ma publicznego interfejsu API i w dużym stopniu polega na chronionych funkcjach wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="de5a5-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="de5a5-163"><xref:System.Windows.Media.Visual>jest naprawdę punktem wejścia do systemu kompozycji WPF.</span><span class="sxs-lookup"><span data-stu-id="de5a5-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="de5a5-164"><xref:System.Windows.Media.Visual>jest punktem połączenia między tymi dwoma podsystemami, zarządzanym interfejsem API i niezarządzanym milcore.</span><span class="sxs-lookup"><span data-stu-id="de5a5-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="de5a5-165">WPF WPF wyświetla dane przez przechodzenie przez struktury danych niezarządzanych zarządzanych przez milcore.</span><span class="sxs-lookup"><span data-stu-id="de5a5-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="de5a5-166">Te struktury, zwane węzłami kompozycji, reprezentują hierarchiczne drzewo wyświetlania z instrukcjami renderowania w każdym węźle.</span><span class="sxs-lookup"><span data-stu-id="de5a5-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="de5a5-167">To drzewo, zilustrowane po prawej stronie poniższego rysunku, jest dostępne tylko za pośrednictwem protokołu wiadomości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="de5a5-168">Podczas programowania WPF, <xref:System.Windows.Media.Visual> można utworzyć elementy i typy pochodne, które wewnętrznie komunikują się z drzewa kompozycji za pośrednictwem tego protokołu obsługi wiadomości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="de5a5-169">Każdy <xref:System.Windows.Media.Visual> w WPF może utworzyć jeden, brak lub kilka węzłów kompozycji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="de5a5-170">![Drzewo wizualne programu Windows Presentation Foundation Foundation.](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="de5a5-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="de5a5-171">Jest tu bardzo ważny szczegół architektoniczny - całe drzewo wizualizacji i instrukcji rysowania jest buforowane.</span><span class="sxs-lookup"><span data-stu-id="de5a5-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="de5a5-172">Pod względem graficznym WPF WPF używa zachowanego systemu renderowania.</span><span class="sxs-lookup"><span data-stu-id="de5a5-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="de5a5-173">Dzięki temu system do odświeżania z dużą szybkością odświeżania bez blokowania systemu kompozycji na wywołania zwrotne do kodu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="de5a5-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="de5a5-174">Pomaga to zapobiec pojawianiu się aplikacji, która nie odpowiada.</span><span class="sxs-lookup"><span data-stu-id="de5a5-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="de5a5-175">Innym ważnym szczegółem, który nie jest tak naprawdę zauważalny na diagramie, jest to, jak system faktycznie wykonuje kompozycję.</span><span class="sxs-lookup"><span data-stu-id="de5a5-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="de5a5-176">W User32 i GDI system działa w systemie przycinania trybu natychmiastowego.</span><span class="sxs-lookup"><span data-stu-id="de5a5-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="de5a5-177">Gdy komponent musi być renderowany, system ustanawia granice przycinania, poza którymi składnik nie może dotykać pikseli, a następnie komponent jest proszony o malowanie pikseli w tym polu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="de5a5-178">System ten działa bardzo dobrze w systemach o ograniczonej pamięci, ponieważ gdy coś się zmienia, wystarczy dotknąć dotkniętego komponentu - żadne dwa składniki nigdy nie przyczyniają się do koloru pojedynczego piksela.</span><span class="sxs-lookup"><span data-stu-id="de5a5-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="de5a5-179">WPF używa modelu malarskiego "algorytm malarza".</span><span class="sxs-lookup"><span data-stu-id="de5a5-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="de5a5-180">Oznacza to, że zamiast przycinania każdego komponentu, każdy komponent jest proszony o renderowanie od tyłu do przodu wyświetlacza.</span><span class="sxs-lookup"><span data-stu-id="de5a5-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="de5a5-181">Dzięki temu każdy komponent może malować na wyświetlaczu poprzedniego komponentu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="de5a5-182">Zaletą tego modelu jest to, że można mieć złożone, częściowo przezroczyste kształty.</span><span class="sxs-lookup"><span data-stu-id="de5a5-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="de5a5-183">Dzięki dzisiejszemu nowoczesnemu sprzętowi graficznemu model ten jest stosunkowo szybki (co nie miało miejsca w przypadku tworzenia User32/ GDI).</span><span class="sxs-lookup"><span data-stu-id="de5a5-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="de5a5-184">Jak wspomniano wcześniej, podstawową filozofią WPF jest przejście do bardziej deklaratywnego, "zorientowanego na właściwości" modelu programowania.</span><span class="sxs-lookup"><span data-stu-id="de5a5-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="de5a5-185">W systemie wizualnym pojawia się to w kilku ciekawych miejscach.</span><span class="sxs-lookup"><span data-stu-id="de5a5-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="de5a5-186">Po pierwsze, jeśli myślisz o systemie graficznym trybu zachowanego, jest to naprawdę odejście od imperatywu DrawLine / DrawLine modelu typu, do modelu zorientowanego na dane - nowy Line()/new Line().</span><span class="sxs-lookup"><span data-stu-id="de5a5-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="de5a5-187">To przejście do renderowania opartego na danych umożliwia złożone operacje na instrukcjach rysowania, które mają być wyrażone przy użyciu właściwości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="de5a5-188">Typy pochodzące <xref:System.Windows.Media.Drawing> z są skutecznie modelu obiektu do renderowania.</span><span class="sxs-lookup"><span data-stu-id="de5a5-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="de5a5-189">Po drugie, jeśli ocenisz system animacji, zobaczysz, że jest prawie całkowicie deklaratywny.</span><span class="sxs-lookup"><span data-stu-id="de5a5-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="de5a5-190">Zamiast wymagać od dewelopera obliczenia następnej lokalizacji lub następnego koloru, można wyrazić animacje jako zestaw właściwości obiektu animacji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="de5a5-191">Animacje te można następnie wyrazić intencji dewelopera lub projektanta (przenieść ten przycisk z tego miejsca w tym miejscu w 5 sekund), a system może określić najbardziej efektywny sposób, aby to osiągnąć.</span><span class="sxs-lookup"><span data-stu-id="de5a5-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>
## <a name="systemwindowsuielement"></a><span data-ttu-id="de5a5-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="de5a5-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="de5a5-193"><xref:System.Windows.UIElement>definiuje podstawowe podsystemy, w tym Układ, Dane wejściowe i Zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="de5a5-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="de5a5-194">Układ jest podstawową koncepcją w WPF.</span><span class="sxs-lookup"><span data-stu-id="de5a5-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="de5a5-195">W wielu systemach istnieje albo stały zestaw modeli układu (HTML obsługuje trzy modele układu; przepływ, bezwzględny i tabele) lub brak modelu układu (User32 naprawdę obsługuje tylko pozycjonowanie bezwzględne).</span><span class="sxs-lookup"><span data-stu-id="de5a5-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="de5a5-196">WPF WPF rozpoczął się od założenia, że deweloperzy i projektanci chcieli elastyczny, rozszerzalny model układu, który może być napędzany przez wartości właściwości, a nie logiki imperatywnej.</span><span class="sxs-lookup"><span data-stu-id="de5a5-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="de5a5-197">Na <xref:System.Windows.UIElement> poziomie wprowadza się podstawowy kontrakt na układ – <xref:System.Windows.UIElement.Measure%2A> <xref:System.Windows.UIElement.Arrange%2A> model dwufazowy z i przechodzi.</span><span class="sxs-lookup"><span data-stu-id="de5a5-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="de5a5-198"><xref:System.Windows.UIElement.Measure%2A>umożliwia składnikowi określenie, ile rozmiaru chciałby podjąć.</span><span class="sxs-lookup"><span data-stu-id="de5a5-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="de5a5-199">Jest to oddzielna <xref:System.Windows.UIElement.Arrange%2A> faza, ponieważ istnieje wiele sytuacji, w których element nadrzędny poprosi element podrzędny o kilka razy zmierzyć, aby określić jego optymalną pozycję i rozmiar.</span><span class="sxs-lookup"><span data-stu-id="de5a5-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="de5a5-200">Fakt, że elementy nadrzędne poprosić elementy podrzędne do pomiaru pokazuje inną kluczową filozofię WPF — rozmiar do zawartości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="de5a5-201">Wszystkie formanty w WPF obsługują możliwość rozmiaru do naturalnego rozmiaru ich zawartości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="de5a5-202">Dzięki temu lokalizacja znacznie łatwiejsze i pozwala na dynamiczny układ elementów, jak rzeczy zmienić rozmiar.</span><span class="sxs-lookup"><span data-stu-id="de5a5-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="de5a5-203">Faza <xref:System.Windows.UIElement.Arrange%2A> umożliwia elementowi nadrzędnemu położenie i określenie ostatecznego rozmiaru każdego dziecka.</span><span class="sxs-lookup"><span data-stu-id="de5a5-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="de5a5-204">Dużo czasu jest często spędzane na rozmowach <xref:System.Windows.Media.Visual> o stronie wyjściowej WPF — i powiązanych obiektów.</span><span class="sxs-lookup"><span data-stu-id="de5a5-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="de5a5-205">Jednak po stronie nakładów jest jednak również ogromna ilość innowacji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="de5a5-206">Prawdopodobnie najbardziej podstawową zmianą w modelu wejściowym dla WPF jest spójny model, za pomocą którego zdarzenia wejściowe są kierowane przez system.</span><span class="sxs-lookup"><span data-stu-id="de5a5-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="de5a5-207">Dane wejściowe pochodzą jako sygnał na sterowniku urządzenia trybu jądra i pobiera kierowane do prawidłowego procesu i wątku przez skomplikowany proces z udziałem jądra systemu Windows i User32.</span><span class="sxs-lookup"><span data-stu-id="de5a5-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="de5a5-208">Gdy user32 komunikat odpowiadający dane wejściowe jest kierowany do WPF, jest konwertowany na WPF nieprzetworzony komunikat wejściowy i wysyłane do dyspozytora.</span><span class="sxs-lookup"><span data-stu-id="de5a5-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="de5a5-209">WPF WPF umożliwia raw zdarzenia wejściowe mają być konwertowane na wiele rzeczywistych zdarzeń, dzięki czemu funkcje, takie jak "MouseEnter" mają być implementowane na niskim poziomie systemu z gwarantowaną dostawą.</span><span class="sxs-lookup"><span data-stu-id="de5a5-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="de5a5-210">Każde zdarzenie wejściowe jest konwertowane na co najmniej dwa zdarzenia — zdarzenie "podgląd" i rzeczywiste zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="de5a5-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="de5a5-211">Wszystkie zdarzenia w WPF mają pojęcie routingu za pośrednictwem drzewa elementów.</span><span class="sxs-lookup"><span data-stu-id="de5a5-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="de5a5-212">Zdarzenia są mówi się , że "bańka", jeśli przechodzenie od celu w górę drzewa do katalogu głównego, i mówi się, że "tunel", jeśli zaczynają się od katalogu głównego i przechodzenie w dół do celu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="de5a5-213">Tunel zdarzeń podglądu wejściowego, włączając dowolny element w drzewie możliwość filtrowania lub podjęcia działań w przypadku.</span><span class="sxs-lookup"><span data-stu-id="de5a5-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="de5a5-214">Zdarzenia regularne (nie podgląd) następnie bańki od obiektu docelowego do katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="de5a5-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="de5a5-215">Ten podział między fazą tunelu i bąbelkową sprawia, że implementacja funkcji, takich jak akceleratory klawiatury, działa w spójny sposób w świecie kompozytowym.</span><span class="sxs-lookup"><span data-stu-id="de5a5-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="de5a5-216">W user32 można zaimplementować akceleratory klawiatury, mając jedną globalną tabelę zawierającą wszystkie akceleratory, które chcesz obsługiwać (Ctrl + N mapowanie do "Nowy").</span><span class="sxs-lookup"><span data-stu-id="de5a5-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="de5a5-217">W dyspozytorze dla aplikacji należy **wywołać TranslateAccelerator,** który wąchać komunikaty wejściowe w User32 i określić, czy którykolwiek z nich dopasowane zarejestrowany akcelerator.</span><span class="sxs-lookup"><span data-stu-id="de5a5-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="de5a5-218">W WPF nie będzie działać, ponieważ system jest w pełni "composable" - każdy element może obsługiwać i używać dowolnego akceleratora klawiatury.</span><span class="sxs-lookup"><span data-stu-id="de5a5-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="de5a5-219">Posiadanie tego dwufazowego modelu wprowadzania umożliwia komponentom implementowanie własnego "TranslateAccelerator".</span><span class="sxs-lookup"><span data-stu-id="de5a5-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="de5a5-220">Aby zrobić ten krok <xref:System.Windows.UIElement> dalej, wprowadza również pojęcie CommandBindings.</span><span class="sxs-lookup"><span data-stu-id="de5a5-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="de5a5-221">System poleceń WPF umożliwia deweloperom definiowanie funkcji w kategoriach <xref:System.Windows.Input.ICommand>punktu końcowego polecenia – czegoś, co implementuje.</span><span class="sxs-lookup"><span data-stu-id="de5a5-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="de5a5-222">Powiązania poleceń umożliwiają elementowi zdefiniowanie mapowania między gestem wejściowym (Ctrl+N) a poleceniem (Nowy).</span><span class="sxs-lookup"><span data-stu-id="de5a5-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="de5a5-223">Gesty wejściowe i definicje poleceń są rozszerzalne i mogą być połączone ze sobą w czasie użytkowania.</span><span class="sxs-lookup"><span data-stu-id="de5a5-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="de5a5-224">To sprawia, że trywialne, na przykład, aby umożliwić użytkownikowi końcowemu dostosować powiązania klucza, które mają być używane w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="de5a5-225">Do tego punktu w temacie, "core" funkcje WPF — funkcje zaimplementowane w PresentationCore zestawu, były w centrum uwagi.</span><span class="sxs-lookup"><span data-stu-id="de5a5-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="de5a5-226">Podczas tworzenia WPF, czyste oddzielenie elementów fundamentowych (jak umowa na układ z **Measure** i **Arrange)** <xref:System.Windows.Controls.Grid>i elementy ramowe (jak implementacja określonego układu, jak) był pożądany wynik.</span><span class="sxs-lookup"><span data-stu-id="de5a5-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="de5a5-227">Celem było zapewnienie punktu rozszerzalności niski w stosie, który pozwoliłby zewnętrznym deweloperom na tworzenie własnych struktur w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="de5a5-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="de5a5-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="de5a5-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="de5a5-229"><xref:System.Windows.FrameworkElement>można przyjrzeć się na dwa różne sposoby.</span><span class="sxs-lookup"><span data-stu-id="de5a5-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="de5a5-230">Wprowadza zestaw zasad i dostosowań w podsystemach wprowadzonych w niższych warstwach WPF.</span><span class="sxs-lookup"><span data-stu-id="de5a5-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="de5a5-231">Wprowadza również zestaw nowych podsystemów.</span><span class="sxs-lookup"><span data-stu-id="de5a5-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="de5a5-232">Podstawowe zasady wprowadzone <xref:System.Windows.FrameworkElement> przez jest wokół układu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="de5a5-233"><xref:System.Windows.FrameworkElement>opiera się na podstawowym kontrakcie układu wprowadzonym przez <xref:System.Windows.UIElement> i dodaje pojęcie układu "slot", który ułatwia autorom układu mieć spójny zestaw semantyki układu opartego na właściwościach.</span><span class="sxs-lookup"><span data-stu-id="de5a5-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="de5a5-234">Właściwości, <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>takie <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> <xref:System.Windows.FrameworkElement.MinWidth%2A>jak <xref:System.Windows.FrameworkElement.Margin%2A> , , i (aby wymienić <xref:System.Windows.FrameworkElement> tylko kilka) dają wszystkie składniki pochodzące ze spójnego zachowania wewnątrz kontenerów układu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="de5a5-235"><xref:System.Windows.FrameworkElement>zapewnia również łatwiejsze narażenie interfejsu API na wiele funkcji znalezionych w podstawowych warstwach WPF.</span><span class="sxs-lookup"><span data-stu-id="de5a5-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="de5a5-236">Na przykład <xref:System.Windows.FrameworkElement> zapewnia bezpośredni dostęp <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> do animacji za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="de5a5-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="de5a5-237">A <xref:System.Windows.Media.Animation.Storyboard> umożliwia skrypt wiele animacji względem zestawu właściwości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="de5a5-238">Dwie najważniejsze rzeczy, <xref:System.Windows.FrameworkElement> które wprowadza są powiązania danych i style.</span><span class="sxs-lookup"><span data-stu-id="de5a5-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="de5a5-239">Podsystem wiązania danych w WPF powinien być względnie znany każdemu, kto używał formularzy systemu Windows lub ASP.NET do tworzenia aplikacji [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="de5a5-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used Windows Forms or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="de5a5-240">W każdym z tych systemów istnieje prosty sposób, aby wyrazić, że chcesz, aby jedna lub więcej właściwości z danego elementu były powiązane z fragmentem danych.</span><span class="sxs-lookup"><span data-stu-id="de5a5-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="de5a5-241">WPF WPF ma pełną obsługę powiązania właściwości, transformacji i powiązania listy.</span><span class="sxs-lookup"><span data-stu-id="de5a5-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="de5a5-242">Jedną z najbardziej interesujących funkcji powiązania danych w WPF jest wprowadzenie szablonów danych.</span><span class="sxs-lookup"><span data-stu-id="de5a5-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="de5a5-243">Szablony danych umożliwiają deklaratywnie określić, jak fragment danych powinny być wizualizowane.</span><span class="sxs-lookup"><span data-stu-id="de5a5-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="de5a5-244">Zamiast tworzyć niestandardowy interfejs użytkownika, który może być powiązany z danymi, można zamiast tego obrócić problem i pozwolić danym określić wyświetlanie, które zostaną utworzone.</span><span class="sxs-lookup"><span data-stu-id="de5a5-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="de5a5-245">Stylizacja jest naprawdę lekką formą wiązania danych.</span><span class="sxs-lookup"><span data-stu-id="de5a5-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="de5a5-246">Za pomocą stylizacji można powiązać zestaw właściwości z definicji udostępnionej do jednego lub więcej wystąpień elementu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="de5a5-247">Style są stosowane do elementu przez jawne odwołanie <xref:System.Windows.FrameworkElement.Style%2A> (przez ustawienie właściwości) lub niejawnie, kojarząc styl z typem CLR elementu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="de5a5-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="de5a5-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="de5a5-249">Najważniejszą cechą formantu jest tworzenie szablonów.</span><span class="sxs-lookup"><span data-stu-id="de5a5-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="de5a5-250">Jeśli myślisz o systemie kompozycji WPF jako system renderowania trybu zachowanego, templating umożliwia formantowi opisanie jego renderowania w sposób sparametryzowany, deklaratywny.</span><span class="sxs-lookup"><span data-stu-id="de5a5-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="de5a5-251">A <xref:System.Windows.Controls.ControlTemplate> jest naprawdę nic więcej niż skrypt do tworzenia zestawu elementów podrzędnych, z powiązań do właściwości oferowanych przez formant.</span><span class="sxs-lookup"><span data-stu-id="de5a5-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="de5a5-252"><xref:System.Windows.Controls.Control>udostępnia zestaw właściwości <xref:System.Windows.Controls.Control.Foreground%2A>zapasów, <xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Control.Padding%2A>, , aby wymienić tylko kilka, których autorów szablonów można następnie użyć do dostosowania wyświetlania formantu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="de5a5-253">Implementacja formantu zapewnia model danych i model interakcji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="de5a5-254">Model interakcji definiuje zestaw poleceń (takich jak Zamknij dla okna) i powiązania z gestami wejściowymi (na przykład kliknięcie czerwonego X w górnym rogu okna).</span><span class="sxs-lookup"><span data-stu-id="de5a5-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="de5a5-255">Model danych udostępnia zestaw właściwości, aby dostosować model interakcji lub dostosować wyświetlanie (określone przez szablon).</span><span class="sxs-lookup"><span data-stu-id="de5a5-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="de5a5-256">Ten podział między model danych (właściwości), model interakcji (polecenia i zdarzenia) i model wyświetlania (szablony) umożliwia pełne dostosowanie wyglądu i zachowania formantu.</span><span class="sxs-lookup"><span data-stu-id="de5a5-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="de5a5-257">Typowym aspektem modelu danych formantów jest model zawartości.</span><span class="sxs-lookup"><span data-stu-id="de5a5-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="de5a5-258">Jeśli spojrzysz na <xref:System.Windows.Controls.Button>formant jak , zobaczysz, że ma właściwość o nazwie "Zawartość" typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="de5a5-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="de5a5-259">W formularzach systemu Windows i ASP.NET ta właściwość zazwyczaj będzie ciągiem znaków — jednak ogranicza typ zawartości, którą można umieścić w przycisku.</span><span class="sxs-lookup"><span data-stu-id="de5a5-259">In Windows Forms and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="de5a5-260">Zawartość przycisku może być prostym ciągiem, złożonym obiektem danych lub całym drzewem elementów.</span><span class="sxs-lookup"><span data-stu-id="de5a5-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="de5a5-261">W przypadku obiektu danych szablon danych jest używany do konstruowania wyświetlania.</span><span class="sxs-lookup"><span data-stu-id="de5a5-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>
## <a name="summary"></a><span data-ttu-id="de5a5-262">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="de5a5-262">Summary</span></span>  
 <span data-ttu-id="de5a5-263">WPF WPF jest przeznaczony do tworzenia dynamicznych, opartych na danych systemów prezentacji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="de5a5-264">Każda część systemu jest przeznaczona do tworzenia obiektów za pomocą zestawów właściwości, które napędzają zachowanie.</span><span class="sxs-lookup"><span data-stu-id="de5a5-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="de5a5-265">Powiązanie danych jest podstawową częścią systemu i jest zintegrowane w każdej warstwie.</span><span class="sxs-lookup"><span data-stu-id="de5a5-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="de5a5-266">Tradycyjne aplikacje tworzą wyświetlanie, a następnie wiążą się z niektórymi danymi.</span><span class="sxs-lookup"><span data-stu-id="de5a5-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="de5a5-267">W WPF WPF wszystko o formancie, każdy aspekt wyświetlania, jest generowany przez jakiś typ powiązania danych.</span><span class="sxs-lookup"><span data-stu-id="de5a5-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="de5a5-268">Tekst znajdujący się wewnątrz przycisku jest wyświetlany przez utworzenie skomponowanego formantu wewnątrz przycisku i powiązanie jego wyświetlania z właściwością zawartości przycisku.</span><span class="sxs-lookup"><span data-stu-id="de5a5-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="de5a5-269">Po rozpoczęciu tworzenia aplikacji opartych na WPF, powinno czuć się bardzo znane.</span><span class="sxs-lookup"><span data-stu-id="de5a5-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="de5a5-270">Właściwości, obiekty i powiązania danych można ustawić w taki sam sposób, jak za pomocą formularzy systemu Windows lub ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="de5a5-270">You can set properties, use objects, and data bind in much the same way that you can using Windows Forms or ASP.NET.</span></span> <span data-ttu-id="de5a5-271">Dzięki głębszemu badaniu architektury WPF, przekonasz się, że istnieje możliwość tworzenia znacznie bogatszych aplikacji, które zasadniczo traktują dane jako podstawowy sterownik aplikacji.</span><span class="sxs-lookup"><span data-stu-id="de5a5-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="de5a5-272">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="de5a5-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="de5a5-273">Przegląd Wiązanie danych</span><span class="sxs-lookup"><span data-stu-id="de5a5-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="de5a5-274">Układ</span><span class="sxs-lookup"><span data-stu-id="de5a5-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="de5a5-275">Przegląd Animacja</span><span class="sxs-lookup"><span data-stu-id="de5a5-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
