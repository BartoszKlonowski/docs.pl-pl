---
title: Metadane zależności właściwości
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: f0aa1d2962b0bccea7a0901877b29550319aaa3f
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="dependency-property-metadata"></a><span data-ttu-id="3667c-102">Metadane zależności właściwości</span><span class="sxs-lookup"><span data-stu-id="3667c-102">Dependency Property Metadata</span></span>
<span data-ttu-id="3667c-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] Właściwości systemu obejmuje metadanych systemu, które wykraczają poza, które mogą być zgłoszony dotyczące właściwości przy użyciu odbicia lub ogólne raportowania [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] właściwości.</span><span class="sxs-lookup"><span data-stu-id="3667c-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system includes a metadata reporting system that goes beyond what can be reported about a property through reflection or general [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] characteristics.</span></span> <span data-ttu-id="3667c-104">Metadane dla właściwości zależności można również przypisać unikatowo przez klasę, która definiuje właściwości zależności, można zmienić, gdy właściwość zależności jest dodana do innej klasy i może zostać przesłonięta w szczególności wszystkie klasy pochodne, które dziedziczą Właściwości zależności od definiującego klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="3667c-104">Metadata for a dependency property can also be assigned uniquely by the class that defines a dependency property, can be changed when the dependency property is added to a different class, and can be specifically overridden by all derived classes that inherit the dependency property from the defining base class.</span></span>  
  
 
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="3667c-105">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="3667c-105">Prerequisites</span></span>  
 <span data-ttu-id="3667c-106">W tym temacie założono zrozumieć właściwości zależności z punktu widzenia użytkownika istniejących właściwości zależności na [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] klas i przeczytanie [Przegląd właściwości zależności](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="3667c-107">Aby można było wykonać przykłady w tym temacie, należy również zapoznać się [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] i wiedzieć, jak napisać [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3667c-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a><span data-ttu-id="3667c-108">Sposób użycia metadanych właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="3667c-108">How Dependency Property Metadata is Used</span></span>  
 <span data-ttu-id="3667c-109">Metadane właściwości zależności istnieje jako obiekt, który można wykonać zapytania do sprawdzenia właściwości właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-109">Dependency property metadata exists as an object that can be queried to examine the characteristics of a dependency property.</span></span> <span data-ttu-id="3667c-110">Te metadane są dostępne często przez system właściwości podczas przetwarzania żadnych danej właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-110">This metadata is also accessed frequently by the property system as it processes any given dependency property.</span></span> <span data-ttu-id="3667c-111">Obiekt metadanych dla właściwości zależności może zawierać następujące informacje:</span><span class="sxs-lookup"><span data-stu-id="3667c-111">The metadata object for a dependency property can contain the following types of information:</span></span>  
  
-   <span data-ttu-id="3667c-112">Wartość domyślna dla właściwości zależności, jeśli żadna inna wartość można określić dla właściwości zależności według wartości lokalnej, style, dziedziczenia, itp. Omówienie dokładnego jak domyślne wartości uczestniczyć w pierwszeństwo używaną przez system właściwości podczas przypisywania wartości dla właściwości zależności, zobacz [pierwszeństwo wartość właściwości zależności](../../../../docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-112">Default value for the dependency property, if no other value can be determined for the dependency property by local value, style, inheritance, etc. For a thorough discussion of how default values participate in the precedence used by the property system when assigning values for dependency properties, see [Dependency Property Value Precedence](../../../../docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
-   <span data-ttu-id="3667c-113">Odwołania do implementacje wywołania zwrotnego, które mają wpływ na zachowania koercja lub zmiany powiadomienia na podstawie ciągu właściciel type.</span><span class="sxs-lookup"><span data-stu-id="3667c-113">References to callback implementations that affect coercion or change-notification behaviors on a per-owner-type basis.</span></span> <span data-ttu-id="3667c-114">Należy pamiętać, że tych wywołań zwrotnych często są zdefiniowane z poziomu dostępu niepubliczne, uzyskiwanie rzeczywiste odwołań z metadanych zwykle nie jest możliwe odwołania nie znajdują się w ramach zakresu dozwolonych dostępu.</span><span class="sxs-lookup"><span data-stu-id="3667c-114">Note that these callbacks are often defined with a nonpublic access level, so obtaining the actual references from metadata is generally not possible unless the references are within your permitted access scope.</span></span> <span data-ttu-id="3667c-115">Aby uzyskać więcej informacji na wartość właściwości zależności, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-115">For more information on dependency property callbacks, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="3667c-116">Jeśli w danej właściwości zależności jest traktowany jako właściwość poziomie struktury WPF, metadane mogą zawierać WPF zależności poziomie struktury właściwość właściwości, które raportuje informacje i stan usług, takich jak poziomie struktury WPF Układ aparatu, a właściwość logika dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="3667c-116">If the dependency property in question is considered to be a WPF framework-level property, the metadata might contain WPF framework-level dependency property characteristics, which report information and state for services such as the WPF framework-level layout engine and property inheritance logic.</span></span> <span data-ttu-id="3667c-117">Aby uzyskać więcej informacji na ten aspekt metadanych właściwości zależności, zobacz [metadanych właściwości Framework](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-117">For more information on this aspect of dependency property metadata, see [Framework Property Metadata](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a><span data-ttu-id="3667c-118">Interfejsy API metadanych</span><span class="sxs-lookup"><span data-stu-id="3667c-118">Metadata APIs</span></span>  
 <span data-ttu-id="3667c-119">Typ, który zgłasza większość informacji metadanych używane przez system właściwości jest <xref:System.Windows.PropertyMetadata> klasy.</span><span class="sxs-lookup"><span data-stu-id="3667c-119">The type that reports most of the metadata information used by the property system is the <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="3667c-120">Metadane wystąpień opcjonalnie są określane podczas właściwości zależności są rejestrowane w systemie właściwości i mogą być ponownie określone dla dodatkowe typy, które Dodawanie siebie jako właściciele lub zastępowanie metadanych, które dziedziczą z zależność klasy podstawowej Definicja właściwości.</span><span class="sxs-lookup"><span data-stu-id="3667c-120">Metadata instances are optionally specified when dependency properties are registered with the property system, and can be specified again for additional types that either add themselves as owners or override metadata they inherit from the base class dependency property definition.</span></span> <span data-ttu-id="3667c-121">(W przypadku których rejestracji właściwość nie określa metadanych, domyślny <xref:System.Windows.PropertyMetadata> jest tworzony z wartościami domyślnymi dla tej klasy.) Zarejestrowany metadanych jest zwracana jako <xref:System.Windows.PropertyMetadata> podczas wywoływania różnych <xref:System.Windows.DependencyProperty.GetMetadata%2A> przeciążeń, które pobierać metadane z właściwości zależności na <xref:System.Windows.DependencyObject> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3667c-121">(For cases where a property registration does not specify metadata, a default <xref:System.Windows.PropertyMetadata> is created with default values for that class.)The registered metadata is returned as <xref:System.Windows.PropertyMetadata> when you call the various <xref:System.Windows.DependencyProperty.GetMetadata%2A> overloads that get metadata from a dependency property on a <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 <span data-ttu-id="3667c-122"><xref:System.Windows.PropertyMetadata> Klasy jest następnie pochodną do udostępnienia metadanych bardziej specyficzne dla architektury podziałów, takich jak klasy poziomie struktury WPF.</span><span class="sxs-lookup"><span data-stu-id="3667c-122">The <xref:System.Windows.PropertyMetadata> class is then derived from to provide more specific metadata for architectural divisions such as the WPF framework-level classes.</span></span> <span data-ttu-id="3667c-123"><xref:System.Windows.UIPropertyMetadata> dodaje raportowania animacji i <xref:System.Windows.FrameworkPropertyMetadata> zawiera właściwości poziomie struktury WPF wymienionych w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="3667c-123"><xref:System.Windows.UIPropertyMetadata> adds animation reporting, and <xref:System.Windows.FrameworkPropertyMetadata> provides the WPF framework-level properties mentioned in the previous section.</span></span> <span data-ttu-id="3667c-124">W przypadku właściwości zależności są zarejestrowane, może być zarejestrowany z tych <xref:System.Windows.PropertyMetadata> klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="3667c-124">When dependency properties are registered, they can be registered with these <xref:System.Windows.PropertyMetadata> derived classes.</span></span> <span data-ttu-id="3667c-125">Gdy metadanych się zbadana, podstawowym <xref:System.Windows.PropertyMetadata> typu potencjalnie mogą być rzutowane na klasy pochodnej, dzięki czemu można przejrzeć bardziej szczegółowe właściwości.</span><span class="sxs-lookup"><span data-stu-id="3667c-125">When the metadata is examined, the base <xref:System.Windows.PropertyMetadata> type can potentially be cast to the derived classes so that you can examine the more specific properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3667c-126">Właściwości właściwości, które można określić w <xref:System.Windows.FrameworkPropertyMetadata> są czasami określane w tej dokumentacji jako "flag".</span><span class="sxs-lookup"><span data-stu-id="3667c-126">The property characteristics that can be specified in <xref:System.Windows.FrameworkPropertyMetadata> are sometimes referred to in this documentation as "flags".</span></span> <span data-ttu-id="3667c-127">Podczas tworzenia nowych wystąpień metadanych do użycia w zależności właściwości rejestracji lub zastępuje metadane, określ te wartości przy użyciu wyliczania flagwise <xref:System.Windows.FrameworkPropertyMetadataOptions> , a następnie podaj prawdopodobnie połączonych wartości wyliczenia do <xref:System.Windows.FrameworkPropertyMetadata> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="3667c-127">When you create new metadata instances for use in dependency property registrations or metadata overrides, you specify these values using the flagwise enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> and then you supply possibly concatenated values of the enumeration to the <xref:System.Windows.FrameworkPropertyMetadata> constructor.</span></span> <span data-ttu-id="3667c-128">Jednak po utworzone, te właściwości opcji są widoczne w <xref:System.Windows.FrameworkPropertyMetadata> jako szereg właściwości logicznych zamiast tworzenia wartości wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="3667c-128">However, once constructed, these option characteristics are exposed within a <xref:System.Windows.FrameworkPropertyMetadata> as a series of Boolean properties rather than the constructing enumeration value.</span></span> <span data-ttu-id="3667c-129">Operatory logiczne pozwalają sprawdzić każdego warunkowego, a nie konieczności dotyczą maski wartość wyliczenia flagwise, aby uzyskać informacje myślisz.</span><span class="sxs-lookup"><span data-stu-id="3667c-129">The Boolean properties enable you to check each conditional, rather than requiring you to apply a mask to a flagwise enumeration value to get the information you are interested in.</span></span> <span data-ttu-id="3667c-130">Konstruktor korzysta z połączonych <xref:System.Windows.FrameworkPropertyMetadataOptions> aby zapewnić długość podpisu konstruktora uzasadnione, podczas gdy rzeczywisty metadanych skonstruowane przedstawia odrębny właściwości, aby zapytanie dotyczące metadanych bardziej intuicyjne.</span><span class="sxs-lookup"><span data-stu-id="3667c-130">The constructor uses the concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> in order to keep the length of the constructor signature reasonable, whereas the actual constructed metadata exposes the discrete properties to make querying the metadata more intuitive.</span></span>  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a><span data-ttu-id="3667c-131">Gdy na zastępowanie metadanych, gdy wyprowadzenia klasy</span><span class="sxs-lookup"><span data-stu-id="3667c-131">When to Override Metadata, When to Derive a Class</span></span>  
 <span data-ttu-id="3667c-132">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Właściwości systemu przejęło możliwości zmiany niektórych właściwości właściwości zależności bez konieczności ich być całkowicie ponownie wdrożony.</span><span class="sxs-lookup"><span data-stu-id="3667c-132">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system has established capabilities for changing some characteristics of dependency properties without requiring them to be entirely re-implemented.</span></span> <span data-ttu-id="3667c-133">Jest to osiągane przez konstruowania inne wystąpienie metadanych właściwości dla właściwości zależności, które znajdują się na określony typ.</span><span class="sxs-lookup"><span data-stu-id="3667c-133">This is accomplished by constructing a different instance of property metadata for the dependency property as it exists on a particular type.</span></span> <span data-ttu-id="3667c-134">Należy pamiętać, że najbardziej istniejącej właściwości zależności nie są właściwościami wirtualny tak mówiąc ściślej "ponownie"ich wdrożenie na klasy dziedziczone można wykonywać tylko przez przesłanianie istniejącego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="3667c-134">Note that most existing dependency properties are not virtual properties, so strictly speaking "re-implementing" them on inherited classes could only be accomplished by shadowing the existing member.</span></span>  
  
 <span data-ttu-id="3667c-135">Jeśli scenariusz chcesz włączyć dla właściwości zależności dla typu nie może być realizowane przez zmodyfikowanie właściwości istniejącej właściwości zależności, może następnie być niezbędne do tworzenia klasy pochodnej, a następnie, aby zadeklarować właściwość zależności niestandardowych w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="3667c-135">If the scenario you are trying to enable for a dependency property on a type cannot be accomplished by modifying characteristics of existing dependency properties, it might then be necessary to create a derived class, and then to declare a custom dependency property on your derived class.</span></span> <span data-ttu-id="3667c-136">Właściwości niestandardowe zależności działa tak samo właściwości zależności zdefiniowanych przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3667c-136">A custom dependency property behaves identically to dependency properties defined by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)].</span></span> <span data-ttu-id="3667c-137">Aby uzyskać więcej informacji o właściwościach niestandardowych zależności, zobacz [niestandardowe właściwości zależności](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-137">For more details about custom dependency properties, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="3667c-138">Pojedynczy parametr zauważalne właściwości zależności, która nie może zastąpić jest jej typ wartości.</span><span class="sxs-lookup"><span data-stu-id="3667c-138">One notable characteristic of a dependency property that you cannot override is its value type.</span></span> <span data-ttu-id="3667c-139">Jeśli są dziedziczenie właściwości zależności, która ma przybliżonej zachowanie wymagane, ale wymaga innego typu dla niego, należy zaimplementować właściwości niestandardowe zależności i może połączyć za pomocą konwersji typu lub inne właściwości Implementacja na klasę niestandardową.</span><span class="sxs-lookup"><span data-stu-id="3667c-139">If you are inheriting a dependency property that has the approximate behavior you require, but you require a different type for it, you will have to implement a custom dependency property and perhaps link the properties through type conversion or other implementation on your custom class.</span></span> <span data-ttu-id="3667c-140">Ponadto nie można zamienić istniejącego <xref:System.Windows.ValidateValueCallback>, ponieważ to wywołanie zwrotne istnieje samo pole rejestracji, a nie w metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-140">Also, you cannot replace an existing <xref:System.Windows.ValidateValueCallback>, because this callback exists in the registration field itself and not within its metadata.</span></span>  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a><span data-ttu-id="3667c-141">Scenariusze dotyczące zmiana istniejących metadanych</span><span class="sxs-lookup"><span data-stu-id="3667c-141">Scenarios for Changing Existing Metadata</span></span>  
 <span data-ttu-id="3667c-142">Jeśli pracujesz z metadanymi istniejącej właściwości zależności, co typowy scenariusz zmiany metadanych właściwości zależności jest zmienić domyślną wartość.</span><span class="sxs-lookup"><span data-stu-id="3667c-142">If you are working with metadata of an existing dependency property, one common scenario for changing dependency property metadata is to change the default value.</span></span> <span data-ttu-id="3667c-143">Zmiana lub dodanie właściwości wywołania zwrotne — system jest bardziej zaawansowanym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="3667c-143">Changing or adding property system callbacks is a more advanced scenario.</span></span> <span data-ttu-id="3667c-144">Można to zrobić, jeśli implementacji klasy pochodnej ma inną współzależności między właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-144">You might want to do this if your implementation of a derived class has different interrelationships between dependency properties.</span></span> <span data-ttu-id="3667c-145">Jeden z warunków o modelu programowania, który obsługuje zarówno kod i deklaratywne użycia jest właściwości należy włączyć, ustawiany w dowolnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="3667c-145">One of the conditionals of having a programming model that supports both code and declarative usage is that properties must enable being set in any order.</span></span> <span data-ttu-id="3667c-146">W związku z tym wszystkie zależne właściwości należy ustawić just-in-time bez kontekstu i nie zależą od tego, wiedząc, że kolejność ustawienia takie jak może można znaleźć w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="3667c-146">Thus any dependent properties need to be set just-in-time without context and cannot rely on knowing a setting order such as might be found in a constructor.</span></span> <span data-ttu-id="3667c-147">Aby uzyskać więcej informacji na ten aspekt właściwości systemu, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-147">For more information on this aspect of the property system, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span> <span data-ttu-id="3667c-148">Należy pamiętać, że wywołania zwrotne walidacji nie są częścią metadanych; są one częścią identyfikatora właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-148">Note that validation callbacks are not part of the metadata; they are part of the dependency property identifier.</span></span> <span data-ttu-id="3667c-149">W związku z tym wywołania zwrotne walidacji nie może zostać zmienione przez zastępowanie metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-149">Therefore, validation callbacks cannot be changed by overriding the metadata.</span></span>  
  
 <span data-ttu-id="3667c-150">W niektórych przypadkach można również zmienić opcje WPF właściwość framework poziom metadanych na istniejącej właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-150">In some cases you might also want to alter the WPF framework-level property metadata options on existing dependency properties.</span></span> <span data-ttu-id="3667c-151">Te opcje komunikowania się niektórych warunków znane informacje o właściwościach poziomie struktury WPF do innych procesów poziomie struktury WPF, takich jak system układu.</span><span class="sxs-lookup"><span data-stu-id="3667c-151">These options communicate certain known conditionals about WPF framework-level properties to other WPF framework-level processes such as the layout system.</span></span>  <span data-ttu-id="3667c-152">Ustawianie opcji zwykle odbywa się tylko wtedy, gdy rejestrowanie nowych właściwości zależności, ale jest również można zmienić metadanych właściwości poziomie struktury WPF jako część <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> lub <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołania.</span><span class="sxs-lookup"><span data-stu-id="3667c-152">Setting the options is generally done only when registering a new dependency property, but it is also possible to change the WPF framework-level property metadata as part of a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> or <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="3667c-153">Określone wartości do użycia i uzyskać więcej informacji, zobacz [metadanych właściwości Framework](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-153">For the specific values to use and more information, see [Framework Property Metadata](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).</span></span> <span data-ttu-id="3667c-154">Aby uzyskać więcej informacji dotyczących konfiguracji tych opcji dla właściwości zależności nowo zarejestrowanych, zobacz [właściwości zależności niestandardowe](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-154">For more information that is pertinent to how these options should be set for a newly registered dependency property, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a><span data-ttu-id="3667c-155">Zastępowanie metadanych</span><span class="sxs-lookup"><span data-stu-id="3667c-155">Overriding Metadata</span></span>  
 <span data-ttu-id="3667c-156">Zastępowanie metadanych służy głównie tak, aby mieć możliwość zmiany różne zachowania pochodnych metadanych, które są stosowane do właściwości zależności, ponieważ istnieje w typie.</span><span class="sxs-lookup"><span data-stu-id="3667c-156">The purpose of overriding metadata is primarily so that you have the opportunity to change the various metadata-derived behaviors that are applied to the dependency property as it exists on your type.</span></span> <span data-ttu-id="3667c-157">To omówiono bardziej szczegółowo w [metadanych](#dp_metadata_contents) sekcji.</span><span class="sxs-lookup"><span data-stu-id="3667c-157">The reasons for this are explained in more detail in the [Metadata](#dp_metadata_contents) section.</span></span> <span data-ttu-id="3667c-158">Aby uzyskać więcej informacji, w tym przykłady kodu, zobacz [zastąpienia metadane dla właściwości zależności](../../../../docs/framework/wpf/advanced/how-to-override-metadata-for-a-dependency-property.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-158">For more information including some code examples, see [Override Metadata for a Dependency Property](../../../../docs/framework/wpf/advanced/how-to-override-metadata-for-a-dependency-property.md).</span></span>  
  
 <span data-ttu-id="3667c-159">Metadane właściwości mogą być dostarczane dla właściwości zależności podczas rejestracji połączenia (<xref:System.Windows.DependencyProperty.Register%2A>).</span><span class="sxs-lookup"><span data-stu-id="3667c-159">Property metadata can be supplied for a dependency property during the registration call (<xref:System.Windows.DependencyProperty.Register%2A>).</span></span> <span data-ttu-id="3667c-160">Jednak w wielu przypadkach można udzielać metadanych określonego typu dla klasy dziedziczy właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-160">However, in many cases, you might want to provide type-specific metadata for your class when it inherits that dependency property.</span></span> <span data-ttu-id="3667c-161">Można to zrobić przez wywołanie metody <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3667c-161">You can do this by calling the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method.</span></span>  <span data-ttu-id="3667c-162">Na przykład z [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], <xref:System.Windows.FrameworkElement> klasy jest typem, który najpierw rejestruje <xref:System.Windows.UIElement.Focusable%2A> właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-162">For an example from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], the <xref:System.Windows.FrameworkElement> class is the type that first registers the <xref:System.Windows.UIElement.Focusable%2A> dependency property.</span></span> <span data-ttu-id="3667c-163">Ale <xref:System.Windows.Controls.Control> klasy zastępuje metadane dla właściwości zależności zapewnić własnej wartości początkowej domyślne, zmieniając go z `false` do `true`, a w przeciwnym razie ponownie używa oryginalnej <xref:System.Windows.UIElement.Focusable%2A> implementacji.</span><span class="sxs-lookup"><span data-stu-id="3667c-163">But the <xref:System.Windows.Controls.Control> class overrides metadata for the dependency property to provide its own initial default value, changing it from `false` to `true`, and otherwise re-uses the original <xref:System.Windows.UIElement.Focusable%2A> implementation.</span></span>  
  
 <span data-ttu-id="3667c-164">Aby zastąpić metadanych, właściwości metadanych są scalane lub wymiany.</span><span class="sxs-lookup"><span data-stu-id="3667c-164">When you override metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
-   <span data-ttu-id="3667c-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> scalania.</span><span class="sxs-lookup"><span data-stu-id="3667c-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="3667c-166">Po dodaniu nowego <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, wywołanie zwrotne jest przechowywany w metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-166">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="3667c-167">Jeśli nie określisz <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> w zastąpienie wartości <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> jest podwyższany jako odwołanie z najbliższym elemencie nadrzędnym on określony w metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-167">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
-   <span data-ttu-id="3667c-168">Właściwość rzeczywiste zachowanie systemowe dla <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> jest zachowywana i dodawane do tabeli, z kolejność wykonywania przez system właściwości, że wywołania zwrotne najdalszych pochodnych klas są wywoływane najpierw implementacje wszystkich właścicieli metadanych w hierarchii.</span><span class="sxs-lookup"><span data-stu-id="3667c-168">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the most derived class's callbacks are invoked first.</span></span>  
  
-   <span data-ttu-id="3667c-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> zostanie zastąpiony.</span><span class="sxs-lookup"><span data-stu-id="3667c-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="3667c-170">Jeśli nie określisz <xref:System.Windows.PropertyMetadata.DefaultValue%2A> w zastąpienie wartości <xref:System.Windows.PropertyMetadata.DefaultValue%2A> pochodzi z najbliższym elemencie nadrzędnym on określony w metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-170">If you do not specify a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
-   <span data-ttu-id="3667c-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementacje zostaną zastąpione.</span><span class="sxs-lookup"><span data-stu-id="3667c-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="3667c-172">Po dodaniu nowego <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, wywołanie zwrotne jest przechowywany w metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-172">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="3667c-173">Jeśli nie określisz <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> w zastąpienie wartości <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> jest podwyższany jako odwołanie z najbliższym elemencie nadrzędnym on określony w metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-173">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
-   <span data-ttu-id="3667c-174">Zachowanie systemu właściwość jest tylko <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> w bezpośrednim metadanych jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="3667c-174">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="3667c-175">Nie odwołania do innych <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementacji w hierarchii są zachowywane.</span><span class="sxs-lookup"><span data-stu-id="3667c-175">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
 <span data-ttu-id="3667c-176">To zachowanie jest implementowany przez <xref:System.Windows.PropertyMetadata.Merge%2A>i może zostać zastąpiona w klasach pochodnych metadanych.</span><span class="sxs-lookup"><span data-stu-id="3667c-176">This behavior is implemented by <xref:System.Windows.PropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
#### <a name="overriding-attached-property-metadata"></a><span data-ttu-id="3667c-177">Zastępowanie metadanych dołączona właściwość</span><span class="sxs-lookup"><span data-stu-id="3667c-177">Overriding Attached Property Metadata</span></span>  
 <span data-ttu-id="3667c-178">W [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], dołączone właściwości są zaimplementowane jako właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-178">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], attached properties are implemented as dependency properties.</span></span> <span data-ttu-id="3667c-179">Oznacza to również mają metadanych właściwości, można zastąpić, które poszczególne klasy.</span><span class="sxs-lookup"><span data-stu-id="3667c-179">This means that they also have property metadata, which individual classes can override.</span></span> <span data-ttu-id="3667c-180">Określania zakresu zagadnienia dotyczące dołączona właściwość w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] są zazwyczaj który <xref:System.Windows.DependencyObject> może mieć właściwości dołączonej ustawiony na nich.</span><span class="sxs-lookup"><span data-stu-id="3667c-180">The scoping considerations for an attached property in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are generally that any <xref:System.Windows.DependencyObject> can have an attached property set on them.</span></span> <span data-ttu-id="3667c-181">W związku z tym wszelkie <xref:System.Windows.DependencyObject> klasy pochodnej można zmienić metadanych dla dowolnego dołączona właściwość, jak może być ustawiony na wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="3667c-181">Therefore, any <xref:System.Windows.DependencyObject> derived class can override the metadata for any attached property, as it might be set on an instance of the class.</span></span> <span data-ttu-id="3667c-182">Można zastąpić wartości domyślne, wywołania zwrotne lub właściwości raportowania cech poziomie struktury WPF.</span><span class="sxs-lookup"><span data-stu-id="3667c-182">You can override default values, callbacks, or WPF framework-level characteristic-reporting properties.</span></span> <span data-ttu-id="3667c-183">Jeśli dołączona właściwość jest ustawiona na wystąpienie klasy, te zastąpienia metadanych właściwości, które obowiązują.</span><span class="sxs-lookup"><span data-stu-id="3667c-183">If the attached property is set on an instance of your class, those override property metadata characteristics apply.</span></span> <span data-ttu-id="3667c-184">Na przykład można zastąpić, wartością domyślną tak, aby wartość zastąpienia został zgłoszony jako wartość właściwości dołączonych na wystąpień klasy, zawsze, gdy właściwość nie jest w przeciwnym razie ustawiona.</span><span class="sxs-lookup"><span data-stu-id="3667c-184">For instance, you can override the default value, such that your override value is reported as the value of the attached property on instances of your class, whenever the property is not otherwise set.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3667c-185"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Właściwość nie jest ważna w przypadku dołączonych właściwości.</span><span class="sxs-lookup"><span data-stu-id="3667c-185">The <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property is not relevant for attached properties.</span></span>  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a><span data-ttu-id="3667c-186">Dodawanie klasy jako właściciela istniejącej właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="3667c-186">Adding a Class as an Owner of an Existing Dependency Property</span></span>  
 <span data-ttu-id="3667c-187">Klasę można dodać się jako właściciela właściwości zależności, który został już zarejestrowany, za pomocą <xref:System.Windows.DependencyProperty.AddOwner%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3667c-187">A class can add itself as an owner of a dependency property that has already been registered, by using the <xref:System.Windows.DependencyProperty.AddOwner%2A> method.</span></span> <span data-ttu-id="3667c-188">Dzięki temu klasę, aby użyć właściwości zależności, który pierwotnie został zarejestrowany dla innego typu.</span><span class="sxs-lookup"><span data-stu-id="3667c-188">This enables the class to use a dependency property that was originally registered for a different type.</span></span> <span data-ttu-id="3667c-189">Dodawanie klasy nie jest zwykle klasy pochodnej typu, który najpierw zarejestrowany jako właściciela tej właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-189">The adding class is typically not a derived class of the type that first registered that dependency property as owner.</span></span> <span data-ttu-id="3667c-190">Efektywnie umożliwia klasy i jej klas pochodnych "dziedziczy" implementacja właściwości zależności, bez oryginalnej klasy właściciela i dodawanie klasy w tej samej hierarchii klas wartość true.</span><span class="sxs-lookup"><span data-stu-id="3667c-190">Effectively, this allows your class and its derived classes to "inherit" a dependency property implementation without the original owner class and the adding class being in the same true class hierarchy.</span></span> <span data-ttu-id="3667c-191">Dodanie, dodawanie klasy (i wszystkich klas pochodnych również) można dostarczać metadanych specyficznych dla typu dla oryginalnego właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-191">In addition, the adding class (and all derived classes as well) can then provide type-specific metadata for the original dependency property.</span></span>  
  
 <span data-ttu-id="3667c-192">A także dodawanie się jako właściciela za pośrednictwem metody narzędziowe właściwości systemu, dodawanie klasy powinny deklarować dodatkowe publiczne elementy członkowskie od siebie samego Aby ustawić właściwości zależności] pełnego uczestnika właściwości systemowi narażenia na kodzie i znaczników .</span><span class="sxs-lookup"><span data-stu-id="3667c-192">As well as adding itself as owner through the property system utility methods, the adding class should declare additional public members on itself in order to make the dependency property] a full participant in the property system with exposure to both code and markup.</span></span> <span data-ttu-id="3667c-193">Klasa, która dodaje istniejącej właściwości zależności ma tego samego obowiązki jak udostępnianie model obiektów dla danej właściwości zależności, tak jak w przypadku klasy definiującej nowej właściwości niestandardowej zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-193">A class that adds an existing dependency property has the same responsibilities as far as exposing the object model for that dependency property as does a class that defines a new custom dependency property.</span></span> <span data-ttu-id="3667c-194">Najpierw taki element członkowski do udostępnienia jest pole identyfikatora właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-194">The first such member to expose is a dependency property identifier field.</span></span> <span data-ttu-id="3667c-195">To pole może mieć `public static readonly` pola typu <xref:System.Windows.DependencyProperty>, który jest przypisany do zwracanej wartości <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołania.</span><span class="sxs-lookup"><span data-stu-id="3667c-195">This field should be a `public static readonly` field of type <xref:System.Windows.DependencyProperty>, which is assigned to the return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="3667c-196">Drugi element członkowski, aby zdefiniować jest [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] właściwości "otoki".</span><span class="sxs-lookup"><span data-stu-id="3667c-196">The second member to define is the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] "wrapper" property.</span></span> <span data-ttu-id="3667c-197">Otoka wygodniej znacznie do manipulowania z właściwości zależności w kodzie (uniknąć wywołań <xref:System.Windows.DependencyObject.SetValue%2A> każdego czasu i może wykonać tego wywołanie tylko raz w otoki, sam).</span><span class="sxs-lookup"><span data-stu-id="3667c-197">The wrapper makes it much more convenient to manipulate your dependency property in code (you avoid calls to <xref:System.Windows.DependencyObject.SetValue%2A> each time, and can make that call only once in the wrapper itself).</span></span> <span data-ttu-id="3667c-198">Otoka zaimplementowano tak samo jak mogą być realizowane były rejestracji właściwości niestandardowe zależności.</span><span class="sxs-lookup"><span data-stu-id="3667c-198">The wrapper is implemented identically to how it would be implemented if you were registering a custom dependency property.</span></span> <span data-ttu-id="3667c-199">Aby uzyskać więcej informacji o implementacji właściwości zależności, zobacz [właściwości zależności niestandardowe](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) i [Dodaj typ właściciela dla właściwości zależności](../../../../docs/framework/wpf/advanced/how-to-add-an-owner-type-for-a-dependency-property.md).</span><span class="sxs-lookup"><span data-stu-id="3667c-199">For more information about implementing a dependency property, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [Add an Owner Type for a Dependency Property](../../../../docs/framework/wpf/advanced/how-to-add-an-owner-type-for-a-dependency-property.md).</span></span>  
  
#### <a name="addowner-and-attached-properties"></a><span data-ttu-id="3667c-200">AddOwner i dołączone właściwości</span><span class="sxs-lookup"><span data-stu-id="3667c-200">AddOwner and Attached Properties</span></span>  
 <span data-ttu-id="3667c-201">Możesz wywołać <xref:System.Windows.DependencyProperty.AddOwner%2A> dla właściwości zależności, który jest zdefiniowany jako dołączona właściwość przez klasę właściciela.</span><span class="sxs-lookup"><span data-stu-id="3667c-201">You can call <xref:System.Windows.DependencyProperty.AddOwner%2A> for a dependency property that is defined as an attached property by the owner class.</span></span> <span data-ttu-id="3667c-202">Ogólnie rzecz biorąc Przyczyna w ten sposób jest ujawnia wcześniej dołączona właściwość jako właściwość zależności nie jest dołączony.</span><span class="sxs-lookup"><span data-stu-id="3667c-202">Generally the reason for doing this is to expose the previously attached property as a non-attached dependency property.</span></span> <span data-ttu-id="3667c-203">Następnie uwidoczni <xref:System.Windows.DependencyProperty.AddOwner%2A> zwrócić wartość jako `public static readonly` pola do użycia jako identyfikatora właściwości zależności oraz zostaną zdefiniowane właściwości "otoki", dzięki czemu właściwość pojawia się w tabeli elementów członkowskich i obsługuje niedołączonych właściwości Użycie w klasie.</span><span class="sxs-lookup"><span data-stu-id="3667c-203">You then will expose the <xref:System.Windows.DependencyProperty.AddOwner%2A> return value as a `public static readonly` field for use as the dependency property identifier, and will define appropriate "wrapper" properties so that the property appears in the members table and supports a non-attached property usage in your class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3667c-204">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="3667c-204">See Also</span></span>  
 <xref:System.Windows.PropertyMetadata>  
 <xref:System.Windows.DependencyObject>  
 <xref:System.Windows.DependencyProperty>  
 <xref:System.Windows.DependencyProperty.GetMetadata%2A>  
 [<span data-ttu-id="3667c-205">Przegląd właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="3667c-205">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="3667c-206">Metadane właściwości struktury</span><span class="sxs-lookup"><span data-stu-id="3667c-206">Framework Property Metadata</span></span>](../../../../docs/framework/wpf/advanced/framework-property-metadata.md)
