---
title: Metadane zależności właściwości
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 98f8c6611340c89409697918ff8a16eaabe3c7a3
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "62010565"
---
# <a name="dependency-property-metadata"></a>Metadane zależności właściwości
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] System właściwość zawiera metadane systemu, który wykracza poza jakie mogą być zgłaszane o właściwości przy użyciu odbicia lub ogólne raportowania [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] właściwości. Metadane dla właściwości zależności można przypisać również jednoznacznie przez klasę, która definiuje właściwości zależności, można zmienić, gdy właściwość zależności jest dodawany do innej klasy i mogą być szczególnie zastąpione przez wszystkie klasy pochodne, które dziedziczą Właściwości zależności z Definiowanie klasy bazowej.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Wymagania wstępne  
 W tym temacie założono, że rozumiesz właściwości zależności z punktu widzenia użytkownika istniejących właściwości zależności na [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] klasy, a po ich przeczytaniu [Przegląd właściwości zależności](dependency-properties-overview.md). Aby można było wykonać instrukcje opisane w przykładach w tym temacie, należy również mieć świadomość [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] i wiedzieć, jak napisać [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji.  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>Sposób użycia metadane zależności właściwości  
 Metadane zależności właściwości istnieje jako obiekt, który może być odpytywany do sprawdzenia właściwości właściwość zależności. Te metadane są dostępne często przez system właściwości podczas przetwarzania wszelkich danej właściwości zależności. Obiekt metadanych dla właściwości zależności może zawierać następujące typy informacji:  
  
- Wartość domyślna dla właściwości zależności, jeśli brak innych wartości można określić dla właściwości zależności przy wartości lokalnej, style, dziedziczenie, itp. Szczegółowe omówienie jak domyślne wartości uczestniczyć w pierwszeństwo używaną przez system właściwości podczas przypisywania wartości dla właściwości zależności, zobacz [następstwo wartości właściwości](dependency-property-value-precedence.md).  
  
- Odwołania do implementacji wywołanie zwrotne, które mają wpływ na zachowania wymuszenia lub powiadomienia o zmianie na podstawie poszczególnych właściciel type. Należy pamiętać o tym, czy te wywołania zwrotne często są definiowane z poziomem dostępu niepublicznych, więc uzyskanie rzeczywiste odwołań z metadanych ogólnie nie jest możliwe, chyba że odwołania są w ramach zakresu dozwolonych dostępu. Aby uzyskać więcej informacji na temat zależność wartości wywołania zwrotnego, zobacz [zależność wartości wywołania zwrotnego i walidacji](dependency-property-callbacks-and-validation.md).  
  
- Jeśli w danym właściwość zależności jest uważany za właściwość poziomie struktury WPF, metadanych może zawierać WPF framework zależnością właściwość właściwości, które raportują informacje i stan usługi, takie jak poziomie struktury WPF Układ aparatu i właściwość logika dziedziczenia. Aby uzyskać więcej informacji na ten aspekt metadane zależności właściwości, zobacz [metadane właściwości szablonu](framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>Interfejsy API metadanych  
 Typ, który zgłasza większość informacji o metadanych używane przez system właściwości jest <xref:System.Windows.PropertyMetadata> klasy. Metadane wystąpień opcjonalnie są określone właściwości zależności są rejestrowane w systemie właściwości, gdy można można określić, aby uzyskać dodatkowe typy, które samodzielnie dodawać jako właścicieli lub zastąpić metadane, które dziedziczą z zależność klasy bazowej Definicja właściwości. (W przypadkach, w którym rejestracji właściwość nie określa metadane, domyślny <xref:System.Windows.PropertyMetadata> jest tworzony z wartościami domyślnymi dla tej klasy.) Zarejestrowane metadanych jest zwracana jako <xref:System.Windows.PropertyMetadata> wywołanie różnych <xref:System.Windows.DependencyProperty.GetMetadata%2A> przeciążenia, które pobierają metadane z właściwości zależności na <xref:System.Windows.DependencyObject> wystąpienia.  
  
 <xref:System.Windows.PropertyMetadata> Klasy jest następnie tworzony na podstawie do udostępnienia metadanych bardziej szczegółowe dla podziałów architektury, takich jak WPF poziomie struktury klas. <xref:System.Windows.UIPropertyMetadata> dodaje raportowania animacji i <xref:System.Windows.FrameworkPropertyMetadata> udostępnia właściwości poziomie struktury WPF, które są wymienione w poprzedniej sekcji. Gdy właściwości zależności są zarejestrowane, mogą być rejestrowane za pomocą tych <xref:System.Windows.PropertyMetadata> klas pochodnych. Kiedy jest badany metadanych, base <xref:System.Windows.PropertyMetadata> typu potencjalnie mogą być rzutowane na klasach pochodnych, dzięki czemu można sprawdzić bardziej szczegółowe właściwości.  
  
> [!NOTE]
>  Właściwości właściwości określonych w <xref:System.Windows.FrameworkPropertyMetadata> są czasami określane w tej dokumentacji jako "flags". Podczas tworzenia nowych wystąpień metadanych do użycia w zależności rejestracje właściwości lub zastępuje metadanych, określ te wartości przy użyciu funkcji wyliczania flagwise <xref:System.Windows.FrameworkPropertyMetadataOptions> zostaje następnie dostarczona prawdopodobnie połączone wartości wyliczenia do <xref:System.Windows.FrameworkPropertyMetadata> konstruktora. Jednak po skonstruowany, te cechy opcji są ujawniane w obrębie <xref:System.Windows.FrameworkPropertyMetadata> jako szereg właściwości logiczne zamiast tworzenia wartości wyliczenia. Właściwości logiczne pozwalają sprawdzić każdy warunkowych, zamiast konieczności stosowanie maski na wartość wyliczenia flagwise, aby uzyskać informacje Cię interesuje. Konstruktor korzysta z połączonych <xref:System.Windows.FrameworkPropertyMetadataOptions> Aby zachować długość sygnatury konstruktora rozsądne, podczas gdy rzeczywisty metadanych skonstruowany udostępnia dyskretnych właściwości, aby podczas badania bardziej intuicyjne metadanych.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Kiedy należy zastąpić metadane, kiedy należy wyprowadzić klasę  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] System właściwości ustanowiła możliwości zmiany niektórych właściwości właściwości zależności bez konieczności ich być całkowicie ponownie zaimplementowane. Jest to realizowane przez utworzenie innego wystąpienia metadanych właściwości modelu dla właściwości zależności, zgodnie z jego lokalizacją w określonym typie. Należy pamiętać, że większości istniejących właściwości zależności nie są właściwości wirtualnego, więc ściślej "ponownie"ich wdrożenie na dziedziczonych klas można wykonywać tylko przez przesłanianie istniejącego elementu członkowskiego.  
  
 Jeśli scenariusz chcesz włączyć dla właściwości zależności typu nie da się osiągnąć, modyfikując właściwości istniejących właściwości zależności, następnie może być konieczne utworzenie klasy pochodnej, a następnie, aby zadeklarować właściwość zależność niestandardową w klasie pochodnej. Właściwości zależności niestandardowej działa identycznie do właściwości zależności zdefiniowane przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)]. Aby uzyskać więcej szczegółów na temat niestandardowe właściwości zależności zobacz [niestandardowe właściwości zależności](custom-dependency-properties.md).  
  
 Co istotne cechy właściwości zależności, który nie może przesłonić jest jej typ wartości. Jeśli dziedziczą właściwości zależności, która ma przybliżony zachowanie wymagane, ale wymaga innego typu dla niego, trzeba będzie implementować właściwość zależności niestandardowej i być może połączyć właściwości, za pomocą konwersji typu i innych Implementacja na klasę niestandardową. Ponadto nie można zamienić istniejącego <xref:System.Windows.ValidateValueCallback>, ponieważ to wywołanie zwrotne nie istnieje w samym polu rejestracji, a nie w jego metadanych.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Scenariusze dotyczące zmieniania istniejących metadanych  
 Jeśli pracujesz z metadanymi istniejącej właściwości zależności, jeden typowy scenariusz wielokanałowej metadane zależności właściwości jest zmiana wartości domyślnej. Zmiana lub dodanie wywołania zwrotne z systemu właściwości jest bardziej zaawansowanym scenariuszu. Można to zrobić, jeśli implementacja klasy pochodnej ma inną współzależności między właściwości zależności. Jedną z warunkowych o model programowania, który obsługuje zarówno kod, jak i deklaratywne użycia jest właściwości należy włączyć, ustawiany w dowolnej kolejności. Dlatego wszelkie zależne właściwości należy ustawić just-in-time bez kontekstu i nie zależą od tego, że kolejność ustawienia takie jak może można znaleźć w konstruktorze. Aby uzyskać więcej informacji na ten aspekt systemu właściwości, zobacz [zależność wartości wywołania zwrotnego i walidacji](dependency-property-callbacks-and-validation.md). Należy pamiętać, że wywołania zwrotne weryfikacji nie są częścią metadanych; są one częścią identyfikatora właściwości zależności. W związku z tym wywołania zwrotne sprawdzania poprawności, nie można zmienić poprzez zastąpienie metadanych.  
  
 W niektórych przypadkach można również zmienić opcje WPF właściwości na poziomie struktury metadanych w istniejących właściwości zależności. Te opcje komunikują się niektóre znane warunkowych, informacje o właściwościach poziomie struktury WPF do innych procesów WPF poziomie struktury, takich jak system układu.  Ustawianie opcji zwykle odbywa się tylko wtedy, gdy rejestrowanie nową właściwość zależności, ale jest również możliwość zmiany metadanych właściwości na poziomie struktury WPF jako część <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> lub <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołania. Określone wartości i więcej informacji, zobacz [metadane właściwości szablonu](framework-property-metadata.md). Aby uzyskać więcej informacji dotyczących konfiguracji tych opcji dla właściwości zależności nowo zarejestrowanych, zobacz [niestandardowe właściwości zależności](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Zastępowanie metadanych  
 Zastępowanie metadanych ma przede wszystkim, aby mieć możliwość zmiany różnych zachowań pochodne metadanych, które są stosowane do właściwości zależności, ponieważ znajduje się na danego typu. Przyczyny tego omówiona bardziej szczegółowo w [metadanych](#dp_metadata_contents) sekcji. Aby uzyskać więcej informacji, w tym przykłady kodu, zobacz [zastąpić metadane dla właściwości zależności](how-to-override-metadata-for-a-dependency-property.md).  
  
 Metadane właściwości mogą być podawane dla właściwości zależności podczas wywołania rejestracji (<xref:System.Windows.DependencyProperty.Register%2A>). Jednak w wielu przypadkach możesz chcieć zapewniające metadanych specyficznych dla typu klasy dziedziczy właściwości zależności. Można to zrobić, wywołując <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metody.  Na przykład z [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], <xref:System.Windows.FrameworkElement> klasa jest typem, który najpierw rejestruje <xref:System.Windows.UIElement.Focusable%2A> właściwość zależności. Ale <xref:System.Windows.Controls.Control> klasa zastępuje metadane dla właściwości zależności, aby zapewnić jego własnej wartości początkowej domyślnej, zmieniając go z `false` do `true`, a w przeciwnym razie ponownie używa oryginalny <xref:System.Windows.UIElement.Focusable%2A> implementacji.  
  
 Podczas zastąpienia metadanych właściwości metadanych są scalane lub zastąpiony.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> scalone. W przypadku dodania nowego <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, wywołanie zwrotne jest przechowywany w metadanych. Jeśli nie określisz <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> w przesłonięciu wartość <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> jest podnoszony jako odwołanie z najbliższym elemencie nadrzędnym, która zostanie określona, w metadanych.  
  
- Zachowanie systemu rzeczywiste właściwości dla <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> jest zachowywana i dodawane do tabeli, za pomocą kolejność wykonywania przez system właściwości, możliwe, że wywołania zwrotne najbardziej pochodnej klasy są wywoływane najpierw implementacje dla wszystkich właścicieli metadanych w hierarchii.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A> zostanie zastąpiona. Jeśli nie określisz <xref:System.Windows.PropertyMetadata.DefaultValue%2A> w przesłonięciu wartość <xref:System.Windows.PropertyMetadata.DefaultValue%2A> pochodzi z najbliższym elemencie nadrzędnym, która zostanie określona, w metadanych.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementacje są zastępowane. W przypadku dodania nowego <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, wywołanie zwrotne jest przechowywany w metadanych. Jeśli nie określisz <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> w przesłonięciu wartość <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> jest podnoszony jako odwołanie z najbliższym elemencie nadrzędnym, która zostanie określona, w metadanych.  
  
- Zachowanie systemu właściwość jest tylko <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> w bezpośrednim metadanych jest wywołana. Nie odwołania do innych <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementacji w hierarchii są zachowywane.  
  
 To zachowanie jest implementowany przez <xref:System.Windows.PropertyMetadata.Merge%2A>i może zostać zastąpiona w klasach pochodnych metadanych.  
  
#### <a name="overriding-attached-property-metadata"></a>Zastępowanie metadanych właściwości dołączone  
 W [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], dołączone właściwości są implementowane jako właściwości zależności. Oznacza to również mają metadanych właściwości modelu poszczególnych klas, które można przesłonić. Wyznaczanie zakresu zagadnienia dotyczące dołączoną właściwość w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] są ogólnie, <xref:System.Windows.DependencyObject> może mieć dołączoną właściwość dla nich ustawionych. W związku z tym, dowolny <xref:System.Windows.DependencyObject> klasy pochodnej można zastąpić metadane dla wszelkich dołączonych właściwości, ponieważ może być ustawione na wystąpienie klasy. Możesz przesłonić wartości domyślne, wywołania zwrotne lub właściwości raportowania cechy na poziomie struktury WPF. Jeśli dołączona właściwość jest ustawiona w wystąpieniu klasy, zastąpić te metadane właściwości, które obowiązują. Na przykład można zastąpić, wartość domyślna to takie, że wartość zastępowania zostanie zgłoszone jako wartość właściwości dołączone w wystąpieniach klasy, zawsze, gdy właściwość nie jest w przeciwnym razie ustawiona.  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Właściwość nie jest ważna w przypadku dołączonych właściwości.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Dodawanie klasy jako właściciel istniejącej właściwości zależności  
 Klasę można dodać się jako właściciele właściwości zależności, który został już zarejestrowany, używając <xref:System.Windows.DependencyProperty.AddOwner%2A> metody. Dzięki temu klasy, aby użyć właściwości zależności, który pierwotnie został zarejestrowany dla innego typu. Dodawanie klasy nie jest zazwyczaj klasę pochodną typu, który najpierw zarejestrować tę właściwość zależności jako właściciela. Skutecznie dzięki temu klasy i jej klasy pochodne "inherit" implementacja właściwości zależności, bez oryginalnej klasy właściciela i dodawanie klasy znajdujące się w tej samej hierarchii klas wartość true. Dodawanie, dodawanie klasy (i wszystkie klasy pochodne także) może następnie udostępniać metadanych specyficznych dla typu oryginalne właściwości zależności.  
  
 A także dodawanie się jako właściciel za pośrednictwem metody narzędziowe właściwości systemu, dodawanie klasy powinny deklarować przed właściwości zależności dodatkowe publiczne elementy członkowskie na siebie] pełnego uczestnika w systemie ma właściwość narażenia na kodzie i znaczników . Klasa, która dodaje istniejącej właściwości zależności ma ten sam obowiązki w miarę udostępniania modelu obiektu dla tej właściwości zależności, podobnie jak klasa, która definiuje nową właściwość zależności niestandardowej. Najpierw takiego członka do udostępnienia jest pole identyfikatora właściwości zależności. To pole powinno być `public static readonly` pole typu <xref:System.Windows.DependencyProperty>, która jest przypisana do wartość zwracaną przez <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołania. Drugi element członkowski do definiowania jest [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] właściwość "otoki". Otoka sprawia, że znacznie bardziej wygodne do manipulowania swoje właściwości zależności w kodzie (uniknąć wywołania <xref:System.Windows.DependencyObject.SetValue%2A> każda czasu i wykonać to wywołanie tylko raz w otoki, sam). Otoka zaimplementowano identycznie jak mogą być realizowane były rejestracji właściwość zależności niestandardowej. Aby uzyskać więcej informacji na temat implementowania właściwości zależności zobacz [niestandardowe właściwości zależności](custom-dependency-properties.md) i [Dodawanie typu właściciela dla właściwości zależności](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner i dołączone właściwości  
 Możesz wywołać <xref:System.Windows.DependencyProperty.AddOwner%2A> dla właściwości zależności, która jest zdefiniowana jako dołączoną właściwość przez klasę właściciela. Ogólnie rzecz biorąc przyczyną takiego postępowania jest do udostępnienia wcześniej dołączona właściwość jako właściwość niedołączonych zależności. Następnie udostępni <xref:System.Windows.DependencyProperty.AddOwner%2A> zwracają wartość jako `public static readonly` pola do wykorzystania jako identyfikator właściwości zależności, a następnie zostaną zdefiniowane właściwości "otoki", tak aby właściwość pojawia się w tabeli składowych i obsługuje niedołączonych właściwości Użycie w klasie.  
  
## <a name="see-also"></a>Zobacz także

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Przegląd właściwości zależności](dependency-properties-overview.md)
- [Metadane właściwości struktury](framework-property-metadata.md)
