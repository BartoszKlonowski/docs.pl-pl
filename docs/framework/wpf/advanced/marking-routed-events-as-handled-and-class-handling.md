---
title: Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 8a21b5e69e8fb3f9781d862bd62b0db92073b1dc
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/18/2019
ms.locfileid: "59172110"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy
Programy obsługi dla zdarzenia trasowanego oznaczyć zdarzeń przetwarzanych w ramach danych zdarzenia. Obsługa zdarzenia skróci efektywne trasy. Obsługa klasy jest koncepcji programowania, który jest obsługiwany przez zdarzenia trasowane. Klasa program obsługi ma możliwość obsługi określonego zdarzenia trasowanego na poziomie klasy, za pomocą programu obsługi, które jest wywoływane przed jakakolwiek Obsługa wystąpienia na dowolne wystąpienie klasy.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Wymagania wstępne  
 W tym temacie rosnącego założenia [Przegląd zdarzeń kierowane](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Gdy do oznaczenia zdarzeń jako obsługiwane  
 Po ustawieniu wartości <xref:System.Windows.RoutedEventArgs.Handled%2A> właściwości `true` w zdarzeniu dane dla zdarzenia trasowanego, to jest określane jako "Oznaczanie zdarzeń obsługiwane". Nie ma bezwzględne reguły dla podczas należy oznaczyć zdarzeń trasowanych jako obsłużony, jako autor aplikacji lub jako kontrolka zdarzenia trasowanego Autor, który reaguje na zdarzenia trasowane istniejących lub nowych implementuje. W większości przypadków koncepcji "obsługiwane" jako zdarzenie trasowane zdarzeń danych powinny służyć jako ograniczona protokołu własną aplikację odpowiedzi na różne zdarzenia trasowane ujawnione w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] oraz jak w przypadku niestandardowych kierowane zdarzenia. Innym sposobem, aby wziąć pod uwagę "obsługiwane" problem jest, zazwyczaj należy oznaczyć zdarzenia trasowanego obsługiwane kod odpowiedzi zdarzenia trasowanego w sposób znaczące i względnie kompletne. Zazwyczaj nie powinno być więcej niż jeden znaczące odpowiedź, która wymaga implementacji programu obsługi oddzielnych dowolne wystąpienie, pojedyncze zdarzenie trasowane. Jeśli potrzebne są odpowiedzi więcej, niezbędny kod powinien być implementowane za pomocą logiki aplikacji, która jest połączonych w ramach jednego programu obsługi, a nie za pomocą systemu zdarzenie trasowane do przesyłania dalej. Pojęcie co to jest "znaczących" również zależy od wielu czynników i jest zależna od aplikacji lub kodu. Jako ogólne wskazówki "znaczące response" Przykłady: ustawienie fokusu, modyfikowania stanu publicznych, ustawianie właściwości, które wpływają na wizualnej reprezentacji i wywoływanie innych nowych zdarzeń. Przykłady nonsignificant odpowiedzi: modyfikowanie stanu prywatny (bez wizualny, i z reprezentacji programowy), rejestrowanie zdarzeń, lub spojrzenie na argumenty zdarzenia i wybierając nie odpowiedzieć.  
  
 Zachowanie systemu zdarzenia trasowanego wzmacnia ten model "znaczące response" dla przy użyciu obsługiwanego stanu zdarzenia trasowane, ponieważ programy obsługi [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] lub wspólnej podpis <xref:System.Windows.UIElement.AddHandler%2A> nie są wywoływane w odpowiedzi na zdarzenia trasowanego gdzie zdarzenia dane są oznaczane już obsługiwany. Musisz przejść przez dodatkowego wysiłku dodawania programu obsługi z `handledEventsToo` parametru wersji (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) w celu obsługi w zdarzeniu kierować zdarzenia trasowane, które są oznaczone obsługiwany przez wcześniejsze uczestników.  
  
 W niektórych sytuacjach samych formantów oznaczyć niektórych zdarzeń trasowanych jako obsługiwane. Obsługuje zdarzenie trasowane reprezentuje decyzji [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kontrolować autorów, którzy są akcje formantu w odpowiedzi na zdarzenia trasowanego znaczących lub pełnej zgodnie z implementacją kontrolki i zdarzenia wymagających nie dalszych czynności. Zazwyczaj jest to realizowane przez dodanie obsługi klasy dla zdarzenia lub poprzez zastąpienie jeden z elementów obsługi wirtualnych klasy, która istnieje w klasie bazowej. Nadal można obejść to zdarzenie obsługi, jeśli jest to konieczne. zobacz [Praca wokół zdarzeń pomijanie przez formanty](#WorkingAroundEventSuppressionByControls) w dalszej części tego tematu.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Wersja zapoznawcza" vs zdarzenia (tunelowanie). Propagacja zdarzeń i obsługa zdarzeń  
 Zdarzenia (wersja zapoznawcza) jest kierowany są zdarzenia, które należy wykonać trasy tunelowania za pośrednictwem drzewa elementów. "Preview" wyrażone w konwencji nazewnictwa jest wskaźnikiem ogólną zasadą dla zdarzenia wejściowe, czy w wersji zapoznawczej (z tunelowaniem) kierowane zdarzenia są wywoływane przed równoważne zdarzenia trasowanego propagacji. Ponadto wejściowego trasowane zdarzenia, które mają parę tunelowania i propagacji mieć logikę obsługi distinct. Jeśli zdarzenie tunelowania/Podgląd kierowany jest oznaczony jako obsługiwane przez odbiornik zdarzeń, następnie propagacji, zdarzenie trasowane zostaną oznaczone obsługiwane nawet w przypadku, zanim żadnych odbiorników propagacji zdarzenia trasowanego otrzymasz go. Zdarzenia trasowane tunelowania i propagacji są pod względem technicznym odrębne zdarzenia, ale one celowo współużytkują to samo wystąpienie danych zdarzenia, aby włączyć to zachowanie.  
  
 Połączenie między zdarzenia trasowane tunelowania i propagacji odbywa się przez wewnętrzną implementację, w jaki sposób dowolnej podanej [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] klasa wywołuje swoje własne zdarzenia trasowane zadeklarowane, a ta zasada obowiązuje sparowane zdarzeń trasowanych wejściowych. Ale chyba że istnieje tej implementacji na poziomie klasy, nie ma połączenia między tunelowania zdarzenia trasowanego i propagacji zdarzenia trasowane, które mają schemat nazewnictwa: bez takie wdrożenie będzie dwa rozłączne zdarzenia trasowane i nie będzie wywoływane w kolejności lub udziału danych zdarzeń.  
  
 Aby uzyskać więcej informacji o sposobie implementacji pary dane wejściowe zdarzenia trasowane tunelu/bąbelków w niestandardowej klasy, zobacz [Utwórz niestandardowe zdarzenie kierowane](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Funkcje obsługi klas i wystąpień obsługi  
 Zdarzenia trasowane należy wziąć pod uwagę dwa różne typy obiektów nasłuchujących na zdarzenie: klasy detektory i odbiorniki wystąpień. Odbiorniki klas istnieje, ponieważ typy mają wywołany konkretny <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, w jego konstruktorze statycznym lub ma zastąpić metodę wirtualną obsługi klasę z klasy bazowej elementu. Odbiorniki wystąpień elementów konkretnej klasy wystąpienia/gdzie obsługi co najmniej jeden zostały dołączone do tego zdarzenia trasowanego przez wywołanie <xref:System.Windows.UIElement.AddHandler%2A>. Istniejące [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] zdarzenia trasowane wykonywać wywołania <xref:System.Windows.UIElement.AddHandler%2A> jako część [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] Dodaj zdarzenie otoki{} i Usuń{} implementacji zdarzenia, który jest również, jak prostą [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanizm dołączania programy obsługi zdarzeń za pomocą składni atrybutów jest włączona. W związku z tym nawet prostą [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] użycia ostatecznie jest równa <xref:System.Windows.UIElement.AddHandler%2A> wywołania.  
  
 Elementy w drzewie wizualnym, są sprawdzane pod kątem implementacji zarejestrowanego programu obsługi. Programy obsługi potencjalnie są wywoływane w całej trasie, w kolejności, należącej do rodzaju strategii routingu dla tego zdarzenia trasowane. Na przykład Propagacja zdarzeń trasowanych najpierw będzie wywoływać te programy obsługi, które są dołączone do tego samego elementu, który spowodował zdarzenie trasowane. Następnie zdarzenia trasowanego "bąbelki", aby następny element nadrzędny i tak dalej, aż zostanie osiągnięty elementu głównego aplikacji.  
  
 Z punktu widzenia głównego elementu propagacji trasy Jeśli obsługa klasy lub dowolnego elementu bliżej do źródła zdarzenia trasowanego wywoływanie programów obsługi, które Oznacz argumenty zdarzenia, co jest obsługiwane, następnie obsługi w katalogu głównym, które elementy nie są wywoływane i zdarzenia kierować skutecznie został skrócony przed osiągnięciem tego elementu głównego. Jednak trasy jest nie całkowicie zostało zatrzymane, ponieważ programy obsługi można dodać za pomocą specjalnych warunkowe, że są nadal powinny być używane, nawet wtedy, gdy program obsługi klasy lub wystąpienia programu obsługi oznaczyła zdarzenia trasowanego jako obsługiwane. Wyjaśnienie jest zawarte w [dodanie wystąpienia obsługi są wywoływane, nawet podczas zdarzenia oznaczone obsługiwania](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)w dalszej części tego tematu.  
  
 Na poziom głębiej niż trasy zdarzeń są również potencjalnie wiele funkcje obsługi klas na dowolne wystąpienie danej klasy. To jest ponieważ model obsługi klasy dla zdarzenia trasowane umożliwia wszystkich możliwych klas w hierarchii klas do każdego zarejestrować własne klasy programu obsługi dla każdego zdarzenia trasowane. Każdy program obsługi klasy jest dodawany do wewnętrznego magazynu, a gdy jest konstruowany trasy zdarzeń dla aplikacji, funkcje obsługi klas są wszystkie dodane do trasy zdarzeń. Funkcje obsługi klas są dodawane do trasy tak, aby najpierw zostanie wywołany uchwytu najbardziej pochodnego klasy i funkcje obsługi klas z każdym kolejnym klasy bazowej są wywoływane dalej. Ogólnie rzecz biorąc funkcje obsługi klas nie są zarejestrowane w taki sposób, że odpowiada one także zdarzenia trasowane, które już zostały oznaczone jako obsługiwane. W związku z tym ta klasa mechanizm obsługi umożliwia jedną z dwóch opcji:  
  
-   Klasy pochodne mogą uzupełniać Obsługa klasy, która jest dziedziczona z klasy bazowej przez dodanie obsługi, które nie są oznaczane zdarzenia trasowanego obsługiwane, ponieważ program obsługi klasy bazowej zostanie wywołany jakiś czas po obsługi klasy pochodnej.  
  
-   Klasy pochodne mogą zastąpić klasy obsługi z klasy bazowej, dodając klasy programu obsługi, oznaczający zdarzenia trasowanego obsługiwane. Należy zachować ostrożność w przypadku tej metody, ponieważ potencjalnie zmienią projektowania zamierzony kontrolki podstawowej w obszarach, takich jak wygląd, logika stanu, obsługi danych wejściowych i obsługa polecenia.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Klasy obsługi zdarzeń trasowanych przez formant klas bazowych  
 Dany element w każdym węźle trasę w protokole zdarzeń odbiorniki klas mieć możliwość odpowiadanie na zdarzenia trasowanego przed dowolnego odbiornika wystąpienia na może elementu. Z tego powodu funkcje obsługi klas są czasami używane do pomijania zdarzenia trasowane, których implementacja klasy określonego formantu nie ma dalszych Propagacja lub w celu udostępnienia specjalnej obsługi tego zdarzenia trasowanego, która jest funkcją klasy. Na przykład klasa może podnieść swoje własne zdarzenia swoiste dla klas, które zawiera więcej szczegółowych informacji na temat jakiś warunek danych wejściowych użytkownika znaczenia w kontekście danej klasy. Implementacja klasy może następnie oznaczyć bardziej ogólnych zdarzenia trasowanego jako obsługiwane. Funkcje obsługi klas są zwykle dodawane taki sposób, że nie są wywoływane dla kierowane zdarzenia, gdzie dane zdarzenia udostępnionych zostało już oznaczone obsługiwane, ale w nietypowych sytuacjach jest również <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> podpisu, który rejestruje funkcje obsługi klas do wywołania, nawet wtedy, gdy zdarzenia trasowane są oznaczone jako obsługiwane.  
  
### <a name="class-handler-virtuals"></a>Klasy obsługi elementy wirtualne  
 Niektóre elementy, takie jak szczególnie podstawowych elementów <xref:System.Windows.UIElement>, pusta udostępniają "na * zdarzeń" i "OnPreview\*zdarzeń" wirtualne metody, które odnoszą się do ich listy zdarzeń trasowanych publicznych. Tych metod wirtualnych może zostać zastąpiona w celu implementacji programu obsługi klasy dla zdarzenia trasowanego. Klasy bazowej elementów zarejestrować tych metod wirtualnych, ponieważ ich obsługi klasy dla każdego takiego kierowane za pomocą zdarzeń <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> zgodnie z wcześniejszym opisem. On\*zdarzenia metod wirtualnych stał się znacznie prostsza do zaimplementowania obsługę klasy dla odpowiedniego kierowane zdarzenia, bez konieczności specjalnego inicjowania w konstruktorach statycznych dla każdego typu. Na przykład można dodać obsługę klasy dla <xref:System.Windows.UIElement.DragEnter> zdarzeń w dowolnym <xref:System.Windows.UIElement> klasy pochodnej poprzez zastąpienie <xref:System.Windows.UIElement.OnDragEnter%2A> metodę wirtualną. W ramach zastąpienia można obsłużyć zdarzenie trasowane, wywołania innych zdarzeń, zainicjować logikę specyficzną dla klasy, która może spowodować zmianę właściwości elementu w wystąpieniach lub dowolnej kombinacji tych akcji. Zazwyczaj powinien wywoływać implementację podstawową w takich zastąpienia, nawet wtedy, gdy oznaczyć zdarzenie obsługi. Zdecydowanie zalecane jest wywoływanie implementację podstawową, ponieważ metoda wirtualna znajduje się w klasie bazowej. Chronione standardowego wzorca wirtualnego wywołania podstawowe implementacje z Każda wirtualna zasadniczo zastępuje i równoleżnikami podobny mechanizm, który jest natywnym Obsługa klasy zdarzenia trasowanego, zgodnie z którymi są funkcje obsługi klas dla wszystkich klas w hierarchii klas wywołana w danym przypadku, począwszy od najbardziej pochodnego klasy programu obsługi i przechodzić do obsługi klasy bazowej. Wywołanie implementację podstawową należy pominąć jedynie w przypadku, jeśli klasa ma zamierzonego konieczność, Zmień klasę bazową, logika obsługi. Czy wywoływać implementację podstawową przed lub po kodzie nadrzędne będzie zależeć od charakteru implementacji.  
  
#### <a name="input-event-class-handling"></a>Dane wejściowe zdarzenia Obsługa klasy  
 Metody wirtualne klasy programu obsługi są wszystkie zarejestrowane taki sposób, że jest wywoływana tylko w przypadkach, w którym wszystkie dane zdarzeń udostępnionego nie są już oznaczone obsługiwane. Ponadto dla zdarzenia wejściowe jednoznacznie, tunelowania i propagacji wersji zazwyczaj są wywoływane w kolejności i udostępniaj dane zdarzenia. To pociąga za sobą, że dla danego pary funkcje obsługi klas zdarzeń wejściowych, których jednym jest wersja tunelowania, a drugi to propagacji wersji, może nie chcesz oznaczyć zdarzenie obsługi natychmiast. W przypadku zastosowania obsługę metody wirtualnej do oznaczenia zdarzeń obsługiwane klasy tunelowania, który uniemożliwi propagacji obsługi klasy wywoływanej (a także uniemożliwia dowolnej obsługi zwykle zarejestrowanych wystąpień tunelowania lub propagacji zdarzenie z wywoływana).  
  
 Po zakończeniu obsługi w węźle klasy są traktowane jako odbiorniki wystąpień.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Dodawanie obsługi wystąpienia, które są wywoływane, nawet wtedy, gdy zdarzenia są oznaczone jako obsługiwane  
 <xref:System.Windows.UIElement.AddHandler%2A> Metoda dostarcza określonego przeciążenia, które pozwala na dodawanie programów obsługi, które zostanie wywołany przez system zdarzeń zawsze wtedy, gdy zdarzenie osiągnie element obsługi dla trasy, nawet wtedy, gdy innego programu obsługi ma już dopasowane dane zdarzeń, aby oznaczyć, że Zdarzenie jako obsługiwane. Nie jest to zazwyczaj wykonywane. Ogólnie rzecz biorąc aby dopasować wszystkich obszarów kodu aplikacji, które mogą mieć wpływ zdarzenie, niezależnie od tego, gdzie go obsłużono w drzewie elementów, nawet jeśli są potrzebne wiele wyników końcowych można napisać procedury obsługi. Ponadto zwykle jest tak naprawdę tylko jeden element, który musi odpowiedzieć na to zdarzenie i odpowiedniej aplikacji logiki ma już wystąpiły. Ale `handledEventsToo` przeciążenie jest dostępna w wyjątkowych przypadkach, gdzie innego elementu w element składania drzewa lub kontrolki ma już oznaczone zdarzenia, jako obsłużony, ale inne elementy wyższe lub niższe w drzewie elementów (w zależności od trasy) nadal chcesz, aby własne programy obsługi wywołana.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Kiedy oznaczyć obsługi wydarzeń jako nieobsługiwany  
 Ogólnie rzecz biorąc, zdarzenia trasowane, które są oznaczone jako obsłużonych nie powinien być oznaczony nieobsługiwany (<xref:System.Windows.RoutedEventArgs.Handled%2A> powraca do `false`) nawet przez programy obsługi, które działają w `handledEventsToo`. Jednak niektóre zdarzenia wejściowe mają reprezentacji wysokiego poziomu niższego poziomu wydarzenie, które może pokrywać się, gdy występuje zdarzenie wysokiego poziomu o jedną pozycję w drzewie i niskiego poziomu zdarzenia w inne miejsce. Na przykład, należy rozważyć przypadek, w której nie zawiera elementu podrzędnego nasłuchuje wysokiego poziomu zdarzeń klucza takich jak <xref:System.Windows.UIElement.TextInput> podczas elementu nadrzędnego nasłuchuje zdarzenia niskiego poziomu, takich jak <xref:System.Windows.UIElement.KeyDown>. Jeśli element nadrzędny obsługuje zdarzenie niskiego poziomu, można pominąć wyższego poziomu zdarzeń, nawet w przypadku elementu podrzędnego, którą powinien posiadać intuicyjnie pierwsza okazja, aby obsłużyć zdarzenie.  
  
 W takich sytuacjach może być konieczne dodanie obsługi zarówno elementów nadrzędnych, jak i elementy podrzędne dla zdarzenia niskiego poziomu. Implementacja procedury obsługi elementu podrzędnego można oznaczyć niskiego poziomu zdarzeń, jako obsłużony, ale implementację obsługi elementu nadrzędnego będzie zestaw, który ponownie nieobsługiwany tak, aby dodatkowo elementy w górę drzewa (a także ogólne zdarzenie) może mieć możliwość udzielenia odpowiedzi. Ta sytuacja powinna być stosunkowo rzadkie.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Celowo pomijanie zdarzeń wejściowych do składania do sterowania  
 Główne scenariusz użycia klasy obsługi zdarzeń trasowanych służy do zdarzenia wejściowe i formanty złożone. Złożone formant jest zgodnie z definicją składające się z wielu praktycznych kontrolki lub kontrolki klas bazowych. Często Autor formantu chce amalgamate wszystkich możliwych zdarzeń wejściowych, każdy podskładniki mogą zgłaszać, aby można było zgłosić całego kontroli jako źródło zdarzenia pojedynczej. W niektórych przypadkach Autor kontroli może chcieć całkowicie pominąć zdarzenia ze składników, lub Zastąp zdarzeń zdefiniowanych przez składnik, niesie ze sobą więcej informacji lub oznacza dokładniejsze zachowanie. Canonical przykładu, który jest natychmiast widoczny dla dowolnego autora składnika jest jak [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> obsługuje wszystkie zdarzenia myszy, które ostatecznie zostanie rozwiązany do zdarzenia intuicyjne, wszystkie przyciski powinny mieć: <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń.  
  
 <xref:System.Windows.Controls.Button> Klasy podstawowej (<xref:System.Windows.Controls.Primitives.ButtonBase>) pochodzi od klasy <xref:System.Windows.Controls.Control> który z kolei pochodzi od klasy <xref:System.Windows.FrameworkElement> i <xref:System.Windows.UIElement>i większość infrastruktury zdarzeń, potrzebne kontroli przetwarzania danych wejściowych jest dostępny w <xref:System.Windows.UIElement> poziom. W szczególności <xref:System.Windows.UIElement> przetwarza ogólne <xref:System.Windows.Input.Mouse> zdarzenia, które obsługi testowania trafień dla kursora myszy w jego granicach, a także różne zdarzenia najczęściej przycisk akcje, takie jak <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> udostępnia pustego wirtualnego <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> jako klasa wyświetlenie wcześniej zarejestrowanych Obsługa <xref:System.Windows.UIElement.MouseLeftButtonDown>, i <xref:System.Windows.Controls.Primitives.ButtonBase> zastępuje ją. Podobnie <xref:System.Windows.Controls.Primitives.ButtonBase> używa klasy obsługi <xref:System.Windows.UIElement.MouseLeftButtonUp>. Zastąpienia, które są przekazywane dane zdarzenia, implementacje znaku który <xref:System.Windows.RoutedEventArgs> wystąpienia tak, jak obsługiwany dzięki ustawieniu <xref:System.Windows.RoutedEventArgs.Handled%2A> do `true`, i że jest tych samych danych zdarzeń, co będzie się powtarzał wzdłuż pozostałą część trasy do innych programów obsługi klasy i także do obsługi wystąpienia lub zdarzenia metod ustawiających. Ponadto <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> obok zgłosi zastąpienie <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń. Wynik końcowy dla większości detektorów będą odpowiadać danym <xref:System.Windows.UIElement.MouseLeftButtonDown> i <xref:System.Windows.UIElement.MouseLeftButtonUp> zdarzenia "zniknąć" i są zastępowane zamiast <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, zdarzenie, który zawiera więcej co oznacza, ponieważ wiadomo, że pochodzi to zdarzenie od przycisku wartość true, a nie niektóre złożony element całkowicie przycisku lub z innego elementu.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Praca wokół pomijanie zdarzenia kontrolki  
 Czasami to zachowanie pomijanie zdarzeń w ramach poszczególnych formantów może zakłócać pewne bardziej ogólnych zamiarach logiki aplikacji do obsługi zdarzeń. Na przykład jeśli jakiegoś powodu aplikacji ma program obsługi <xref:System.Windows.UIElement.MouseLeftButtonDown> znajduje się w elemencie głównym aplikacji, zauważysz spowoduje, że wszelkie kliknięcie na przycisk powodowałoby wywołanie nie <xref:System.Windows.UIElement.MouseLeftButtonDown> lub <xref:System.Windows.UIElement.MouseLeftButtonUp> programów obsługi na poziomie głównym. Samego zdarzenia rzeczywiście przetwarzany (ponownie trasy zdarzenia nie są naprawdę zakończone, ale ich zachowanie wywołania programu obsługi systemu zdarzenia trasowanego zmienia się po oznaczanie obsługiwane). Gdy zdarzenie trasowane przycisku <xref:System.Windows.Controls.Primitives.ButtonBase> Obsługa klasy oznaczone <xref:System.Windows.UIElement.MouseLeftButtonDown> obsługiwane, ponieważ chciałby zastąpić <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia o więcej znaczenia. W związku z tym, wszystkie standardowe <xref:System.Windows.UIElement.MouseLeftButtonDown> wywołana procedura obsługi nieprawidłowego dalsze zapasowej trasy może nie być. Istnieją dwie metody, których można użyć, aby upewnić się, że inne programy obsługi będzie wywołana w takiej sytuacji.  
  
 Pierwszą techniką jest celowo dodać program obsługi, za pomocą `handledEventsToo` podpis <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Ograniczenie tej metody jest, że ta technika Dołączanie programu obsługi zdarzeń jest możliwe tylko w kodzie, a nie z kodu znaczników. Prosta składnia określania Nazwa procedury obsługi zdarzeń jako wartość atrybutu zdarzeń za pośrednictwem [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] nie uwzględnia tego zachowania.  
  
 Druga metoda działa tylko w przypadku zdarzeń wejściowych, gdzie tunelowania i propagacji wersje zdarzenia trasowanego są skojarzone. Te zdarzenia trasowane można dodać procedury obsługi do wersji zapoznawczej/tunelowania równoważne kierowane zdarzeń zamiast tego. To zdarzenie trasowane będzie tunelowania za pośrednictwem trasy, począwszy od katalogu głównego, więc klasa przycisków kod obsługi będzie przechwytuje, przy założeniu dołączonym procedury obsługi podglądu w pewien poziom elementu nadrzędnego w drzewie elementów aplikacji. Jeśli używasz tego podejścia, należy zachować ostrożność oznaczanie dowolnego zdarzenia (wersja zapoznawcza), obsługiwane. Na przykład, biorąc pod uwagę przy użyciu <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> przetwarzanego w elemencie głównym oznaczone zdarzenia jako <xref:System.Windows.RoutedEventArgs.Handled%2A> w implementacji programu obsługi, czy rzeczywiście Pomiń <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń. To zwykle nie jest pożądane zachowania.  
  
## <a name="see-also"></a>Zobacz także

- <xref:System.Windows.EventManager>
- [Podgląd zdarzeń](preview-events.md)
- [Tworzenie niestandardowego zdarzenia trasowanego](how-to-create-a-custom-routed-event.md)
- [Przegląd zdarzeń trasowanych](routed-events-overview.md)
