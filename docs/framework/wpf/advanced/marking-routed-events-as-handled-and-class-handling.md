---
title: "Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: b2c9a550e1423acb37da9645d09cdb4ccefcea66
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/22/2017
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="6b86d-102">Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy</span><span class="sxs-lookup"><span data-stu-id="6b86d-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="6b86d-103">Programy obsługi dla kierowanego zdarzenia można oznaczyć zdarzeń przetwarzanych w ramach danych zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="6b86d-104">Obsługa zdarzenia skutecznie skrócić trasy.</span><span class="sxs-lookup"><span data-stu-id="6b86d-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="6b86d-105">Obsługa klasy to pojęcie programowania, który jest obsługiwany przez kierowane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="6b86d-106">Klasy obsługi ma możliwość obsługi określonego kierowanego zdarzenia na poziomie klasy z programem obsługi, które jest wywoływane przed wszystkie wystąpienia obsługi na dowolne wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="6b86d-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="6b86d-107">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="6b86d-107">Prerequisites</span></span>  
 <span data-ttu-id="6b86d-108">W tym temacie rosnącego założenia [kierowane Przegląd zdarzeń](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="6b86d-108">This topic elaborates on concepts introduced in the [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="6b86d-109">Kiedy zostać oznaczone jako obsługi zdarzeń</span><span class="sxs-lookup"><span data-stu-id="6b86d-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="6b86d-110">Jeśli ustawisz wartość <xref:System.Windows.RoutedEventArgs.Handled%2A> właściwości `true` zdarzeń dane kierowanego zdarzenia, jest to określane jako "oznaczenie zdarzeń obsługiwane".</span><span class="sxs-lookup"><span data-stu-id="6b86d-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="6b86d-111">Nie bezwzględne zasady dla kiedy należy oznaczyć kierowane zdarzenia jako obsługiwany, jako autor aplikacji lub jako formant Autor, który reaguje na zdarzenia routingiem istniejących lub nowych implementuje kierowane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="6b86d-112">W większości przypadków, pojęcie "obsługiwana", jak odbywa się w danych zdarzenia kierowanego zdarzenia powinna być używana jako ograniczona protokołu dla odpowiedzi własnych aplikacji do różnych kierowane zdarzenia w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] jak również za kierowane niestandardowe zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] as well as for any custom routed events.</span></span> <span data-ttu-id="6b86d-113">Innym sposobem należy wziąć pod uwagę "obsłużone" problem jest czy zazwyczaj należy oznaczyć kierowanego zdarzenia obsłużone w sposób znaczny i względnie pełną kod odpowiedzi kierowanego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="6b86d-114">Zazwyczaj nie powinien zawierać więcej niż jeden znaczących odpowiedzi, która wymaga obsługi oddzielnych implementacji dla wystąpienia dowolnego pojedynczego kierowanego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="6b86d-115">Jeśli potrzebne są odpowiedzi więcej, niezbędne kodu powinny być implementowane przez logikę aplikacji, który jest powiązany łańcuchem zależności w ramach jednej procedury obsługi, a nie za pomocą systemu kierowanego zdarzenia do przesyłania dalej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="6b86d-116">Co to jest "znaczących" pojęcia również subiektywne i zależy od aplikacji lub kodu.</span><span class="sxs-lookup"><span data-stu-id="6b86d-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="6b86d-117">Stanowią ogólne wskazówki "znaczących odpowiedzi" Przykłady: Ustawianie fokusu, modyfikowania stanu publicznej właściwości, które mają wpływ na wizualną reprezentację i wywoływanie innych nowych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="6b86d-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="6b86d-118">Przykłady nonsignificant odpowiedzi: modyfikowanie prywatnej stanu (Brak wizualny lub programowe reprezentacja), rejestrowanie zdarzeń, lub patrzeć argumenty zdarzeń i wybierając pozycję nie odpowiedzieć.</span><span class="sxs-lookup"><span data-stu-id="6b86d-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="6b86d-119">Zachowanie systemu kierowanego zdarzenia wzmacnia ten model "znaczących odpowiedzi" dotyczące korzystania z obsługiwanego stanu kierowanego zdarzenia, ponieważ programy obsługi [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] lub wspólnej podpis <xref:System.Windows.UIElement.AddHandler%2A> nie są wywoływane w odpowiedzi na kierowanego zdarzenia gdzie zdarzenia dane są oznaczane już obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="6b86d-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="6b86d-120">Musi przechodzić przez dodatkowy nakład pracy dodawania obsługi z `handledEventsToo` wersji parametr (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) w celu obsługi zdarzeń trasy kierowanego zdarzenia, które są oznaczone obsługiwane przez wcześniejszą uczestników.</span><span class="sxs-lookup"><span data-stu-id="6b86d-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="6b86d-121">W niektórych sytuacjach samych formantów oznaczyć niektórych kierowane zdarzenia obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="6b86d-122">Obsługiwany kierowanego zdarzenia reprezentuje decyzji [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kontrolowania autorom dostępnych akcji formantu w odpowiedzi na kierowanego zdarzenia znaczących lub pełną zgodnie z implementacją kontrolki i zdarzenia wymagających nie dalszych czynności.</span><span class="sxs-lookup"><span data-stu-id="6b86d-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="6b86d-123">Zazwyczaj jest to realizowane przez dodanie obsługi klasy zdarzenia lub przez zastąpienie jednego z elementów wirtualnych obsługi klasy, który istnieje w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="6b86d-124">Nadal można obejść to zdarzenie obsługi, jeśli jest to konieczne. zobacz [pracy wokół zdarzeń pomijanie przez formanty](#WorkingAroundEventSuppressionByControls) dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="6b86d-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="6b86d-125">"W wersji zapoznawczej" vs zdarzenia (Tunneling). Propagacji zdarzeń i obsługa zdarzeń</span><span class="sxs-lookup"><span data-stu-id="6b86d-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="6b86d-126">Podgląd kierowane zdarzenia są zdarzenia, które wykonaj tunelowania trasę przez element drzewa.</span><span class="sxs-lookup"><span data-stu-id="6b86d-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="6b86d-127">"Wersja zapoznawcza" wyrażone w konwencji nazewnictwa jest wskaźnikiem zasady dla zdarzenia wejściowe, że przed równoważne propagacji kierowanego zdarzenia są generowane w wersji zapoznawczej (z tunelowaniem) kierowane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="6b86d-128">Ponadto wejściowych kierowane zdarzenia, które mają tunelowania propagacji parę ma logiki Obsługa unikatowych.</span><span class="sxs-lookup"><span data-stu-id="6b86d-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="6b86d-129">Jeśli zdarzenie tunelowania/Podgląd kierowane jest oznaczony jako obsługiwane przez odbiornik zdarzeń, następnie propagacji, które zostaną oznaczone jako kierowanego zdarzenia obsługiwane nawet przed odebrane przez wszystkie odbiorniki propagacji kierowanego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="6b86d-130">Tunelowania i propagacji kierowane zdarzenia są technicznie odrębne zdarzenia, ale one celowo współużytkują to samo wystąpienie danych zdarzenia, aby włączyć to zachowanie.</span><span class="sxs-lookup"><span data-stu-id="6b86d-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="6b86d-131">Połączenie między tunelowania i propagacji kierowane zdarzenia odbywa się przy implementacji wewnętrznego, jak żadnej podanej [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] klasy wywołuje własną zadeklarowane kierowane zdarzenia, a jest to istotne w parach kierowane zdarzenia wejściowe.</span><span class="sxs-lookup"><span data-stu-id="6b86d-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="6b86d-132">Ale chyba, że ta implementacja klasy poziomie istnieje, nie połączenia między tunelowania kierowanego zdarzenia i propagacji kierowanego zdarzenia, które używają schemat nazewnictwa: bez takie wdrożenie będzie dwa rozłączne kierowane zdarzenia, a nie będzie wywoływane w kolejności lub w udziale danych zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="6b86d-133">Aby uzyskać więcej informacji dotyczących sposobu wdrażania tunelu/bąbelków pary wejściowych kierowanego zdarzenia w klasie niestandardowych, zobacz [utworzyć niestandardowe zdarzenia rozsyłane](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="6b86d-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="6b86d-134">Obsługę klas i wystąpień obsługi</span><span class="sxs-lookup"><span data-stu-id="6b86d-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="6b86d-135">Kierowane zdarzenia należy wziąć pod uwagę dwa typy obiektów nasłuchujących na zdarzenie: klasy odbiorników i odbiorników wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="6b86d-136">Odbiorniki klasy istnieje, ponieważ typy wywołano określonego <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, w ich Konstruktor statyczny lub przesłonili metodą wirtualną klasę programu obsługi z klasy podstawowej elementu.</span><span class="sxs-lookup"><span data-stu-id="6b86d-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="6b86d-137">Obiekty nasłuchujące wystąpienia są wystąpień określonej klasy/elementy gdzie obsługi co najmniej jeden zostały dołączone do tego kierowanego zdarzenia przez wywołanie do <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="6b86d-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="6b86d-138">Istniejące [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kierowane zdarzenia wykonywania wywołań do <xref:System.Windows.UIElement.AddHandler%2A> jako część [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] otoki zdarzeń Dodawanie {} i usuwanie implementacje {} zdarzenia, który jest także sposób prosty [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanizm obsługi zdarzeń za pomocą atrybutu dołączania Składnia jest włączone.</span><span class="sxs-lookup"><span data-stu-id="6b86d-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="6b86d-139">W związku z tym nawet prosty [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] użycia ostatecznie jest równa <xref:System.Windows.UIElement.AddHandler%2A> wywołania.</span><span class="sxs-lookup"><span data-stu-id="6b86d-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="6b86d-140">Elementy w drzewie wizualnym są sprawdzane pod kątem implementacje zarejestrowaną usługę programu obsługi.</span><span class="sxs-lookup"><span data-stu-id="6b86d-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="6b86d-141">Programy obsługi są wywoływane potencjalnie w całym trasy, w kolejności należącej do typu strategii routingu dla tego kierowanego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="6b86d-142">Na przykład propagacji kierowane zdarzenia najpierw wywoła te programy obsługi, które są dołączone do tego samego elementu, który wywołał zdarzenie routingiem.</span><span class="sxs-lookup"><span data-stu-id="6b86d-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="6b86d-143">Następnie kierowanego zdarzenia "propaguje" do następnego elementu nadrzędnego itd. aż do osiągnięcia elementu katalogu głównego aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6b86d-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="6b86d-144">Z punktu widzenia głównego elementu propagacji trasy Jeśli obsługa klasy lub dowolnego elementu bliżej źródło kierowanego zdarzenia wywołania obsługi, które Oznacz argumenty zdarzeń jako obsłużony, następnie programów obsługi na główny elementy nie są wywoływane i zdarzenia trasy efektywne jest obcinana przed osiągnięciem tego elementu głównego.</span><span class="sxs-lookup"><span data-stu-id="6b86d-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="6b86d-145">Jednak trasy nie jest całkowicie zatrzymywany, ponieważ programy obsługi można dodać za pomocą specjalnych warunkowego, że są nadal powinna być wywoływana, nawet jeśli program obsługi klasy lub wystąpienia obsługi oznaczyła kierowanego zdarzenia jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="6b86d-146">Wyjaśnienie jest zawarte w [dodanie wystąpienia obsługi czy są wywoływane nawet podczas zdarzenia są oznaczone obsługiwane](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="6b86d-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="6b86d-147">Na poziomie głębiej niż trasy zdarzenia są również potencjalnie klasy procedury obsługi wielu działającą w danym przypadku klasy.</span><span class="sxs-lookup"><span data-stu-id="6b86d-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="6b86d-148">To jest ponieważ model obsługi klasy dla kierowane zdarzenia umożliwia wszystkich możliwych klas w hierarchii klasy do każdego zarejestrować własnej klasy obsługi dla każdego kierowanego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="6b86d-149">Każdy program obsługi klasy jest dodawany do magazynu wewnętrznej, a gdy trasy zdarzenia dla aplikacji jest tworzony, obsługę klas są wszystkie dodane do trasy zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="6b86d-150">Obsługę klas są dodawane do trasy tak, aby najpierw wywołaniu obsługi klas pochodnych większość i obsługę klas z każdym kolejnych klasy podstawowej są wywoływane dalej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="6b86d-151">Ogólnie rzecz biorąc obsługę klas nie są zarejestrowane w taki sposób, że odpowiada one także kierowane zdarzenia oznaczone już obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="6b86d-152">W związku z tym ta klasa mechanizmu obsługi umożliwia jedną z dwóch opcji:</span><span class="sxs-lookup"><span data-stu-id="6b86d-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
-   <span data-ttu-id="6b86d-153">Klasy pochodne można uzupełnić Obsługa klasy, która jest dziedziczona z klasy podstawowej przez dodanie obsługi, które nie są oznaczane kierowanego zdarzenia obsługiwane, ponieważ program obsługi klasy podstawowej zostanie wywołany pewnego czasu po obsługi klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
-   <span data-ttu-id="6b86d-154">Klasy pochodne mogą zastąpić klasy obsługi z klasy podstawowej przez dodanie obsługi klasy, która oznacza kierowanego zdarzenia obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="6b86d-155">Należy zachować ostrożność przy takie podejście, ponieważ potencjalnie zmieni projektowania podstawowej kontrolnych w obszarach, takich jak wygląd, stan logiki obsługi danych wejściowych i obsługa polecenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="6b86d-156">Klasy obsługi kierowane zdarzenia przez formant klas podstawowych</span><span class="sxs-lookup"><span data-stu-id="6b86d-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="6b86d-157">Danego elementu w każdym węźle trasy zdarzenia odbiorników klasy mają możliwość udzielenia odpowiedzi na kierowanego zdarzenia przed żadnych odbiornika wystąpienia na może element.</span><span class="sxs-lookup"><span data-stu-id="6b86d-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="6b86d-158">Z tego powodu obsługę klas są czasami używane do pomijania kierowane zdarzenia, które implementację klasy określonego formantu nie ma dalszych propagację lub w celu zapewnienia specjalnej obsługi tego kierowanego zdarzenia, który jest funkcją klasy.</span><span class="sxs-lookup"><span data-stu-id="6b86d-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="6b86d-159">Dla wystąpienia klasy może podnieść własne zdarzenia specyficzne dla klasy, zawierający więcej szczegółowych informacji o niektórych warunku wejściowych użytkownika oznacza w ramach danej klasy.</span><span class="sxs-lookup"><span data-stu-id="6b86d-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="6b86d-160">Implementacja klasy może następnie oznaczenie bardziej ogólne kierowanego zdarzenia jako obsłużone.</span><span class="sxs-lookup"><span data-stu-id="6b86d-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="6b86d-161">Obsługę klas są zwykle dodane taki sposób, że nie jest wywoływana dla kierowane zdarzenia, których dane zdarzenia udostępnionych zostało już oznaczone obsługiwane, ale dla nietypowe dostępna jest również <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> podpisie, który rejestruje obsługę klas można wywołać, nawet wtedy, gdy kierowane zdarzenia są oznaczone obsłużone.</span><span class="sxs-lookup"><span data-stu-id="6b86d-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="6b86d-162">Klasy obsługi elementy wirtualne</span><span class="sxs-lookup"><span data-stu-id="6b86d-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="6b86d-163">Niektóre elementy, takie jak szczególnie podstawowych elementów <xref:System.Windows.UIElement>, pusty Uwidacznianie "na * zdarzeń" i "OnPreview\*zdarzeń" metody wirtualne, które odpowiadają ich lista publicznego kierowane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="6b86d-164">Te metody wirtualne mogą zostać zastąpione do zaimplementowania klasy obsługę tego kierowanego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="6b86d-165">Klasy podstawowej elementu zarejestrować tych metod wirtualnych podczas rozsyłania ich obsługi klasy dla każdej z takich zdarzeń za pomocą <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> zgodnie z wcześniejszym opisem.</span><span class="sxs-lookup"><span data-stu-id="6b86d-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="6b86d-166">On\*zdarzenia metod wirtualnych stał się znacznie prostsza do zaimplementowania klasy obsługi dla odpowiedniego kierowane zdarzenia, bez konieczności specjalne inicjowania w konstruktorów statycznych dla każdego typu.</span><span class="sxs-lookup"><span data-stu-id="6b86d-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="6b86d-167">Na przykład można dodać obsługi dla klasy <xref:System.Windows.UIElement.DragEnter> zdarzeń w żadnym <xref:System.Windows.UIElement> pochodnej klasy przez zastąpienie <xref:System.Windows.UIElement.OnDragEnter%2A> metoda wirtualna.</span><span class="sxs-lookup"><span data-stu-id="6b86d-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="6b86d-168">W ramach override można obsłużyć kierowanego zdarzenia, wywołania innych zdarzeń, zainicjować logiki specyficzne, która może spowodować zmianę właściwości elementu w wystąpieniach czy dowolnej kombinacji tych akcji.</span><span class="sxs-lookup"><span data-stu-id="6b86d-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="6b86d-169">Należy zwykle wywoływać implementację podstawową w takich zastąpienia nawet wtedy, gdy oznaczyć obsługi zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="6b86d-170">Zdecydowanie zaleca się wywołanie do podstawowej implementacji, ponieważ metoda wirtualna znajduje się w klasie podstawowej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="6b86d-171">Standardowe chronionych wzorzec wirtualnego zasadniczo wywołania podstawowych implementacji z każdego wirtualnego zastępuje i równoleżnikami podobny mechanizm, który jest natywnej do obsługi klasy kierowanego zdarzenia, według którego obsługę klas dla wszystkich klas w hierarchii klas są wywołuje się w danym przypadku, począwszy od obsługi pochodnych większość klasy i kontynuowanie obsługi klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="6b86d-172">Wywołanie implementacji podstawowej należy pominąć tylko, jeśli klasy zamierzonego wymagane Zmiana klasy podstawowej obsługi logiki.</span><span class="sxs-lookup"><span data-stu-id="6b86d-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="6b86d-173">Określa, czy można wywoływać implementację podstawową przed lub po kodzie zastępowanie zależy od rodzaju implementacji.</span><span class="sxs-lookup"><span data-stu-id="6b86d-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="6b86d-174">Dane wejściowe zdarzeń klasy obsługi</span><span class="sxs-lookup"><span data-stu-id="6b86d-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="6b86d-175">Metody wirtualne obsługi klasy wszystkich zarejestrowanych w taki sposób, że są one wywołać tylko w przypadkach, gdy wszystkie dane zdarzeń udostępnionego nie są już oznaczone obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="6b86d-176">Ponadto dla zdarzenia wejściowe jednoznacznie, wersje tunelowania i propagacji zwykle są zgłaszane w sekwencji i udziału dane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="6b86d-177">Dzięki temu, czy dla danego pary klasy obsługi zdarzeń wprowadzania których jeden jest tunelowania wersji, a drugi to propagacji wersji, może nie chcesz oznaczyć zdarzenia obsługiwane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="6b86d-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="6b86d-178">Klasa tunelowania obsługi metody wirtualnej do oznaczenia zdarzeń obsługiwane w przypadku zastosowania, która uniemożliwi propagacji obsługi klasy wywoływaną (a także uniemożliwia wszelkie obsługi zwykle zarejestrowanych wystąpień tunelowania lub propagacji zdarzenia z wywoływany).</span><span class="sxs-lookup"><span data-stu-id="6b86d-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="6b86d-179">Po zakończeniu obsługi w węźle klasy są traktowane jako obiekty nasłuchujące wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="6b86d-180">Dodawanie obsługi wystąpienia, które są generowane, nawet wtedy, gdy zdarzenia są oznaczone obsługiwane</span><span class="sxs-lookup"><span data-stu-id="6b86d-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="6b86d-181"><xref:System.Windows.UIElement.AddHandler%2A> Określonego przeciążenia, które umożliwia dodanie obsługi, które będzie wywoływany przez system zdarzeń zawsze, gdy zdarzenie osiągnie element obsługi trasy, nawet jeśli niektóre procedury obsługi zostały skorygowane już dane zdarzenia, aby oznaczyć, który dostarcza — metoda zdarzenie, ponieważ obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="6b86d-182">Nie jest to zazwyczaj wykonywane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-182">This is not typically done.</span></span> <span data-ttu-id="6b86d-183">Ogólnie rzecz biorąc programy obsługi można napisać tak aby dopasować wszystkich obszarów kodu aplikacji, która może zależeć od zdarzenia, niezależnie od tego, gdzie go obsłużono w drzewie elementu, nawet jeśli wiele wyników zakończenia są potrzebne.</span><span class="sxs-lookup"><span data-stu-id="6b86d-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="6b86d-184">Ponadto zwykle jest naprawdę tylko jeden element, który musi odpowiadać na zdarzenie i logiki aplikacji już miał wystąpił.</span><span class="sxs-lookup"><span data-stu-id="6b86d-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="6b86d-185">Ale `handledEventsToo` przeciążenia jest dostępna dla większości przypadków, gdy niektóre innego elementu w element składania drzewa lub formant już oznaczyła zdarzenia jako obsługiwane, ale inne elementy wyższe lub niższe w drzewie elementu (w zależności od trasy) nadal chcesz, aby własne programy obsługi wywołany.</span><span class="sxs-lookup"><span data-stu-id="6b86d-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="6b86d-186">Kiedy należy oznaczyć obsługi zdarzeń jako nieobsługiwany</span><span class="sxs-lookup"><span data-stu-id="6b86d-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="6b86d-187">Ogólnie rzecz biorąc, kierowane zdarzenia, które są oznaczone jako obsługiwany nie powinien być oznaczony nieobsługiwany (<xref:System.Windows.RoutedEventArgs.Handled%2A> ustawiana dla `false`) nawet przez programy obsługi, które mają wpływ na `handledEventsToo`.</span><span class="sxs-lookup"><span data-stu-id="6b86d-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="6b86d-188">Jednak niektóre zdarzenia wejściowe mają reprezentacje zdarzenia wysokiego poziomu oraz niższych poziomach, nakładające podczas wysokiego poziomu zdarzeń jest widoczna w jedną pozycję w drzewie i niskiego poziomu zdarzeń w innym miejscu.</span><span class="sxs-lookup"><span data-stu-id="6b86d-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="6b86d-189">Na przykład rozważmy przypadek, gdzie element podrzędny nasłuchuje wysokiego poziomu zdarzeń klucza takich jak <xref:System.Windows.UIElement.TextInput> podczas, gdy element nadrzędny nasłuchuje na niskiego poziomu zdarzeń, takich jak <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="6b86d-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="6b86d-190">Jeśli element nadrzędny obsługuje zdarzenie niskiego poziomu, można pominąć wyższego poziomu zdarzeń nawet w przypadku elementu podrzędnego, który intuicyjnie powinien mieć możliwość pierwsze zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="6b86d-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="6b86d-191">W takich sytuacjach może być konieczne jest dodanie obsługi zarówno elementy nadrzędne i elementy podrzędne dla niskiego poziomu zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="6b86d-192">Implementacja programu obsługi elementu podrzędnego oznaczyć niskiego poziomu zdarzeń jako obsługiwany, ale implementację obsługi elementu nadrzędnego czy zestaw, który ponownie nieobsługiwany tak, aby dodatkowe elementy w górę drzewa (a także wysokiego poziomu zdarzeń) może mieć możliwość udzielenia odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="6b86d-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="6b86d-193">Ta sytuacja powinna być stosunkowo rzadko.</span><span class="sxs-lookup"><span data-stu-id="6b86d-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="6b86d-194">Celowo pomijanie zdarzenia wejściowe dla formantu składania</span><span class="sxs-lookup"><span data-stu-id="6b86d-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="6b86d-195">Jest głównym scenariusz, gdzie klasa obsługę kierowane zdarzenia są używane dla zdarzenia wejściowe i połączone formantów.</span><span class="sxs-lookup"><span data-stu-id="6b86d-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="6b86d-196">Połączone formant jest zgodnie z definicją składa się z wielu praktycznych kontrolki lub kontroli klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="6b86d-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="6b86d-197">Często autora formantu zamierza amalgamate wszystkie możliwe zdarzenia wejściowe czy każdego podskładniki może podnieść, aby można było zgłosić cały formant jako źródło zdarzenia liczbie pojedynczej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="6b86d-198">W niektórych przypadkach autora formant może chcieć całkowicie pominąć zdarzenia ze składników, lub Zastąp zdarzenia zdefiniowane przez składnik, zawiera więcej informacji lub oznacza więcej określone zachowanie.</span><span class="sxs-lookup"><span data-stu-id="6b86d-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="6b86d-199">Canonical przykład natychmiast widocznego dla dowolnego autora składnika jest sposób [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> obsługuje wszystkie zdarzenia myszy, który ostatecznie zostanie rozwiązany w zdarzeniu intuicyjne że wszystkie przyciski: <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="6b86d-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="6b86d-200"><xref:System.Windows.Controls.Button> Klasy podstawowej (<xref:System.Windows.Controls.Primitives.ButtonBase>) jest pochodną <xref:System.Windows.Controls.Control> co z kolei wynika z <xref:System.Windows.FrameworkElement> i <xref:System.Windows.UIElement>i wielu infrastrukturę zdarzeń potrzebną do kontrolki wprowadzania przetwarzania jest dostępny w <xref:System.Windows.UIElement> poziom.</span><span class="sxs-lookup"><span data-stu-id="6b86d-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="6b86d-201">W szczególności <xref:System.Windows.UIElement> przetwarza ogólne <xref:System.Windows.Input.Mouse> zdarzenia, które obsługi testowania trafień dla kursora myszy w jego zakresie oraz zapewnia różne zdarzenia od najczęstszych przycisku akcji, takich jak <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="6b86d-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="6b86d-202"><xref:System.Windows.UIElement>udostępnia pustego wirtualnego <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> jako programu obsługi klasy preregistered <xref:System.Windows.UIElement.MouseLeftButtonDown>, i <xref:System.Windows.Controls.Primitives.ButtonBase> zastępuje go.</span><span class="sxs-lookup"><span data-stu-id="6b86d-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="6b86d-203">Podobnie <xref:System.Windows.Controls.Primitives.ButtonBase> programy obsługi dla klasy używa <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="6b86d-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="6b86d-204">W zastąpienia, które są przekazywane dane zdarzenia, implementacje znak, który <xref:System.Windows.RoutedEventArgs> wystąpienia jako obsługiwany dzięki ustawieniu <xref:System.Windows.RoutedEventArgs.Handled%2A> do `true`, i że tych samych danych zdarzenia jest nadal co wzdłuż pozostałej części trasy do innych programów obsługi klasy i do obsługi wystąpienia lub ustawiające zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="6b86d-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="6b86d-205">Ponadto <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> obok zgłosi zastąpienie <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="6b86d-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="6b86d-206">W rezultacie w przypadku większości odbiorników będzie <xref:System.Windows.UIElement.MouseLeftButtonDown> i <xref:System.Windows.UIElement.MouseLeftButtonUp> zdarzenia "znikają" i zastępuje zamiast tego <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, zawierający więcej co oznacza, ponieważ wiadomo, czy to zdarzenie pochodzi z przycisku wartość true, a nie niektóre zdarzenia złożony element całkowicie przycisku lub niektóre z innego elementu.</span><span class="sxs-lookup"><span data-stu-id="6b86d-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="6b86d-207">Praca wokół pomijanie zdarzeń przez formanty</span><span class="sxs-lookup"><span data-stu-id="6b86d-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="6b86d-208">Czasami to zachowanie pomijanie zdarzeń w ramach poszczególnych formantów może zakłócać pewne ogólne zamiarach logiki aplikacji obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="6b86d-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="6b86d-209">Na przykład jeśli zaistnieje aplikacji ma obsługi dla <xref:System.Windows.UIElement.MouseLeftButtonDown> znajduje się w elemencie głównym aplikacji, można będzie zauważyć, że żadnych kliknięcie przycisku nie może wywołać <xref:System.Windows.UIElement.MouseLeftButtonDown> lub <xref:System.Windows.UIElement.MouseLeftButtonUp> programów obsługi na poziomie głównym.</span><span class="sxs-lookup"><span data-stu-id="6b86d-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="6b86d-210">Samym zdarzeniu faktycznie bąbelkowy górę (ponownie, trasy zdarzenia nie są naprawdę zakończone, ale system kierowanego zdarzenia zmiany ich zachowanie wywołania programu obsługi po oznaczana obsłużonych).</span><span class="sxs-lookup"><span data-stu-id="6b86d-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="6b86d-211">Po kierowanego zdarzenia po kliknięciu przycisku <xref:System.Windows.Controls.Primitives.ButtonBase> Obsługa klasy oznaczona <xref:System.Windows.UIElement.MouseLeftButtonDown> obsługiwane, ponieważ chciałby zastępuje <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia o znaczeniu więcej.</span><span class="sxs-lookup"><span data-stu-id="6b86d-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="6b86d-212">W związku z tym wszystkie standardowe <xref:System.Windows.UIElement.MouseLeftButtonDown> obsługi dalsze zapasowej trasy nie będzie wywołana.</span><span class="sxs-lookup"><span data-stu-id="6b86d-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="6b86d-213">Istnieją dwie metody, których można użyć, aby upewnić się, że Twoje programy obsługi będzie wywołana w takiej sytuacji.</span><span class="sxs-lookup"><span data-stu-id="6b86d-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="6b86d-214">Pierwszy technika jest celowo dodanie obsługi, za pomocą `handledEventsToo` podpis <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="6b86d-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="6b86d-215">Ograniczenie tej metody jest, że ta technika dołączanie program obsługi zdarzeń jest możliwe tylko z kodu, a nie z kodu znaczników.</span><span class="sxs-lookup"><span data-stu-id="6b86d-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="6b86d-216">Proste składnia Określanie nazwa programu obsługi zdarzeń jako wartość atrybutu zdarzenia za pośrednictwem [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] nie obsługuje tego zachowania.</span><span class="sxs-lookup"><span data-stu-id="6b86d-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="6b86d-217">Druga metoda dotyczy tylko zdarzenia wejściowe, gdzie wersje tunelowania i propagacji kierowanego zdarzenia są skojarzone.</span><span class="sxs-lookup"><span data-stu-id="6b86d-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="6b86d-218">Dla tych kierowane zdarzenia można zamiast tego dodać obsługi do podglądu/tunelowania równoważne kierowane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="6b86d-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="6b86d-219">Tego kierowanego zdarzenia będą tunelowania za pomocą trasy, począwszy od katalogu głównego, więc klasy przycisk Kod obsługi będzie przechwytuje, przy założeniu, że dołączony obsługi podglądu na określonym poziomie elementu nadrzędnego w drzewie elementu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="6b86d-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="6b86d-220">Jeśli używasz tej metody, należy zachować ostrożność oznaczenie dowolnego zdarzenia w wersji zapoznawczej obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="6b86d-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="6b86d-221">Na przykład z <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> obsługiwane w elemencie głównym, jeśli jest oznaczony jako zdarzenie <xref:System.Windows.RoutedEventArgs.Handled%2A> w implementacji programu obsługi, czy rzeczywiście Pomiń <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="6b86d-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="6b86d-222">Która zazwyczaj nie jest pożądane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="6b86d-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6b86d-223">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="6b86d-223">See Also</span></span>  
 <xref:System.Windows.EventManager>  
 [<span data-ttu-id="6b86d-224">Podgląd zdarzeń</span><span class="sxs-lookup"><span data-stu-id="6b86d-224">Preview Events</span></span>](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [<span data-ttu-id="6b86d-225">Tworzenie niestandardowego zdarzenia trasowanego</span><span class="sxs-lookup"><span data-stu-id="6b86d-225">Create a Custom Routed Event</span></span>](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [<span data-ttu-id="6b86d-226">Przegląd zdarzeń trasowanych</span><span class="sxs-lookup"><span data-stu-id="6b86d-226">Routed Events Overview</span></span>](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
