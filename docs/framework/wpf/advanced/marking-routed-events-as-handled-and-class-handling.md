---
title: Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401633"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="fd66d-102">Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy</span><span class="sxs-lookup"><span data-stu-id="fd66d-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="fd66d-103">Procedury obsługi dla zdarzenia kierowanego mogą oznaczać zdarzenie obsługiwane w danych zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="fd66d-104">Obsługa zdarzenia w praktyce spowoduje skrócenie trasy.</span><span class="sxs-lookup"><span data-stu-id="fd66d-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="fd66d-105">Obsługa klas jest koncepcją programowania obsługiwaną przez rozesłane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="fd66d-106">Obsługa klasy ma możliwość obsługi określonego zdarzenia kierowanego na poziomie klasy z obsługą, która jest wywoływana przed jakimkolwiek wystąpieniem dowolnego wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="fd66d-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="fd66d-107">Wymagania wstępne</span><span class="sxs-lookup"><span data-stu-id="fd66d-107">Prerequisites</span></span>  
 <span data-ttu-id="fd66d-108">W tym temacie opisano koncepcje wprowadzone w [omówieniu zdarzeń kierowanych](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="fd66d-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="fd66d-109">Kiedy należy oznaczyć zdarzenia jako obsłużone</span><span class="sxs-lookup"><span data-stu-id="fd66d-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="fd66d-110">Po ustawieniu wartości <xref:System.Windows.RoutedEventArgs.Handled%2A> właściwości na `true` wartość w danych zdarzenia dla zdarzenia kierowanego jest to określane jako "Oznaczanie zdarzenia obsłużonego".</span><span class="sxs-lookup"><span data-stu-id="fd66d-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="fd66d-111">Nie istnieje bezwzględna reguła dla sytuacji, gdy należy oznaczyć zdarzenia kierowane jako obsługiwane przez autora aplikacji albo jako autora kontrolki, który reaguje na istniejące zdarzenia kierowane lub implementuje nowe zdarzenia kierowane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="fd66d-112">W większości przypadków pojęcie "obsłużone" zgodnie z danymi zdarzeń zdarzenia kierowanego zdarzenia powinno być używane jako ograniczony protokół dla odpowiedzi aplikacji na różne zdarzenia kierowane w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] interfejsie API, a także dla wszystkich niestandardowych zdarzeń kierowanych.</span><span class="sxs-lookup"><span data-stu-id="fd66d-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="fd66d-113">Innym sposobem rozważenia problemu "obsłużonego" jest to, że zwykle należy oznaczyć zdarzenie kierowane, które jest obsługiwane, jeśli kod odpowiedział na zdarzenie kierowane w znaczący i stosunkowo kompletny sposób.</span><span class="sxs-lookup"><span data-stu-id="fd66d-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="fd66d-114">Zwykle nie powinna istnieć więcej niż jedna znacząca odpowiedź, która wymaga oddzielnych implementacji obsługi dla dowolnego wystąpienia zdarzenia pojedynczego rozesłania.</span><span class="sxs-lookup"><span data-stu-id="fd66d-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="fd66d-115">Jeśli potrzebne są więcej odpowiedzi, należy wdrożyć wymagany kod za pośrednictwem logiki aplikacji, która jest łańcuchem w ramach jednego programu obsługi, a nie przy użyciu systemu zdarzeń kierowanych do przekazywania.</span><span class="sxs-lookup"><span data-stu-id="fd66d-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="fd66d-116">Pojęcie "znaczące" jest również subiektywne i zależy od aplikacji lub kodu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="fd66d-117">Ogólnie rzecz biorąc, niektóre "znaczące odpowiedzi" obejmują: Ustawianie fokusu, modyfikowanie stanu publicznego, Ustawianie właściwości, które mają wpływ na reprezentację wizualną i wywoływanie innych nowych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="fd66d-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="fd66d-118">Przykładami nieznaczących odpowiedzi są: modyfikowanie stanu prywatnego (bez wpływu na wizualizacje lub reprezentacja programowa), rejestrowanie zdarzeń lub sprawdzanie argumentów zdarzenia i wybór braku odpowiedzi na nie.</span><span class="sxs-lookup"><span data-stu-id="fd66d-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="fd66d-119">Zachowanie systemu zdarzenia kierowanego wzmacnia ten model "znaczna odpowiedź" dla użycia obsługiwanego stanu zdarzenia kierowanego, ponieważ programy obsługi dodane w [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] lub typowy <xref:System.Windows.UIElement.AddHandler%2A> podpis nie są wywoływane w odpowiedzi na zdarzenie kierowane, w którym zdarzenie dane są już oznaczone jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="fd66d-120">Aby obsłużyć zdarzenia kierowane, które są oznaczone jako obsługiwane przez `handledEventsToo` wcześniejszych uczestników trasy<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>zdarzeń, należy przejść przez dodatkowy nakład pracy.</span><span class="sxs-lookup"><span data-stu-id="fd66d-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="fd66d-121">W niektórych okolicznościach formanty same oznaczą niektóre zdarzenia kierowane jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="fd66d-122">Obsłużone zdarzenie kierowane reprezentuje decyzję przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] autorów kontroli, że akcje kontrolki w odpowiedzi na zdarzenie kierowane są istotne lub kompletne w ramach implementacji kontroli, a zdarzenie nie wymaga dalszej obsługi.</span><span class="sxs-lookup"><span data-stu-id="fd66d-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="fd66d-123">Zwykle jest to realizowane przez dodanie obsługi klasy dla zdarzenia lub przez zastąpienie jednej z wirtualnych elementów obsługi klasy istniejących w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="fd66d-124">W razie potrzeby można nadal obejść tę obsługę zdarzeń; Zobacz [Praca z pomijaniem zdarzeń przez kontrolki](#WorkingAroundEventSuppressionByControls) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="fd66d-125">Zdarzenia "wersja zapoznawcza" (tunelowanie) a Zdarzenia propagacji i obsługa zdarzeń</span><span class="sxs-lookup"><span data-stu-id="fd66d-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="fd66d-126">Zdarzenia kierowane do wersji zapoznawczej to zdarzenia, które obserwują trasy tunelowania za pomocą drzewa elementów.</span><span class="sxs-lookup"><span data-stu-id="fd66d-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="fd66d-127">"Wersja zapoznawcza" wyrażona w konwencji nazewnictwa jest wskazówką ogólnej zasady dla zdarzeń wejściowych, które są zgłaszane przez zdarzenia kierowane (tunelowanie), które są wywoływane przed równoważeniem zdarzenia propagacji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="fd66d-128">Ponadto w przypadku wejściowych zdarzeń, które mają parę tunelowanie i Propagacja, istnieją różne logiki obsługi.</span><span class="sxs-lookup"><span data-stu-id="fd66d-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="fd66d-129">Jeśli zdarzenie Tunneling/Preview jest oznaczone jako obsługiwane przez odbiornik zdarzeń, zdarzenie propagacji kierowane zostanie oznaczone jako obsługiwane nawet przed odebraniem przez nie wszystkich odbiorników zdarzenia propagacji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="fd66d-130">Zdarzenia tunelowania i propagacji kierowane są technicznie oddzielnymi zdarzeniami, ale świadomie współużytkują to samo wystąpienie danych zdarzeń, aby umożliwić takie zachowanie.</span><span class="sxs-lookup"><span data-stu-id="fd66d-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="fd66d-131">Połączenie między zdarzeniami tunelowania i propagacji jest realizowane przez wewnętrzną implementację podanej [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] klasy, która wywołuje własne zadeklarowane zdarzenia kierowane, i jest to prawdziwe dla sparowanych zdarzeń wejściowych.</span><span class="sxs-lookup"><span data-stu-id="fd66d-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="fd66d-132">Ale jeśli nie istnieje taka implementacja na poziomie klasy, nie ma połączenia między zdarzeniem tunelowania kierowanego a zdarzeniem propagacji, które udostępnia schemat nazewnictwa: bez takiej implementacji, byłyby dwa całkowicie oddzielone zdarzenia kierowane i nie będą uruchamiany w sekwencji lub Udostępnij dane zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="fd66d-133">Aby uzyskać więcej informacji na temat implementowania par zdarzeń danych wejściowych tunelu/bąbelków w klasie niestandardowej, zobacz [Tworzenie niestandardowego zdarzenia kierowanego](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="fd66d-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="fd66d-134">Programy obsługi klas i programy obsługi wystąpień</span><span class="sxs-lookup"><span data-stu-id="fd66d-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="fd66d-135">Zdarzenia kierowane uwzględniają dwa różne typy odbiorników dla zdarzenia: detektory klas i detektory wystąpień.</span><span class="sxs-lookup"><span data-stu-id="fd66d-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="fd66d-136">Odbiorniki klas istnieją, ponieważ typy wywołały <xref:System.Windows.EventManager> konkretny<xref:System.Windows.EventManager.RegisterClassHandler%2A>interfejs API,, w konstruktorze statycznym lub przesłonili metodę wirtualną procedury obsługi klasy z klasy bazowej elementu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="fd66d-137">Detektory wystąpień są określonymi wystąpieniami klasy/elementami, w których co najmniej jeden program obsługi został dołączony do tego zdarzenia przez wywołanie <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="fd66d-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="fd66d-138">Istniejące [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] zdarzenia kierowane powodują <xref:System.Windows.UIElement.AddHandler%2A> wywołania jako część otoki zdarzeń środowiska uruchomieniowego języka wspólnego (CLR) Dodaj{} i Usuń{} implementacje zdarzenia, co jest również prostym [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanizmem Dołączanie programów obsługi zdarzeń za pomocą składni atrybutów jest włączone.</span><span class="sxs-lookup"><span data-stu-id="fd66d-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="fd66d-139">W związku z tym [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] nawet proste użycie jest ostatecznie równe <xref:System.Windows.UIElement.AddHandler%2A> wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="fd66d-140">Elementy w drzewie wizualnym są sprawdzane pod kątem zastrzeżonych implementacji programu obsługi.</span><span class="sxs-lookup"><span data-stu-id="fd66d-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="fd66d-141">Procedury obsługi są potencjalnie wywoływane w całej trasie, w kolejności, która jest nieodłączna w ramach strategii routingu dla tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="fd66d-142">Na przykład Propagacja zdarzeń kierowanych najpierw wywoła te procedury obsługi, które są dołączone do tego samego elementu, który wywołał zdarzenie kierowane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="fd66d-143">Następnie rozesłane zdarzenie "bąbelki" do następnego elementu nadrzędnego i tak dalej, aż do osiągnięcia elementu głównego aplikacji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="fd66d-144">Z punktu widzenia elementu głównego w trasie propagacji, jeśli obsługa klasy lub dowolna element bliżej źródła wywołania wywoływanego wywołała zdarzenia, które oznaczają argumenty zdarzeń jako obsługiwane, a następnie programy obsługi dla elementów głównych nie są wywoływane, a trasa zdarzenia jest efektywnie skracana przed osiągnięciem tego elementu głównego.</span><span class="sxs-lookup"><span data-stu-id="fd66d-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="fd66d-145">Trasa nie jest jednak całkowicie zatrzymana, ponieważ programy obsługi można dodać przy użyciu warunku specjalnego, że powinny być nadal wywoływane, nawet jeśli procedura obsługi klasy lub program obsługi wystąpienia oznaczył zdarzenia kierowane jako obsłużone.</span><span class="sxs-lookup"><span data-stu-id="fd66d-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="fd66d-146">Jest to wyjaśnione w temacie [Dodawanie programów obsługi wystąpień, które są wywoływane nawet wtedy, gdy zdarzenia są oznaczone jako obsługiwane](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="fd66d-147">Na wyższym poziomie niż trasa zdarzenia istnieje również możliwość obsługi wielu klas, które działają na dowolnym wystąpieniu klasy.</span><span class="sxs-lookup"><span data-stu-id="fd66d-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="fd66d-148">Jest to spowodowane tym, że model obsługi klasy dla zdarzeń kierowanych umożliwia wszystkim klasom w hierarchii klas każdemu zarejestrowaniu własnej obsługi klasy dla każdego zdarzenia kierowanego.</span><span class="sxs-lookup"><span data-stu-id="fd66d-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="fd66d-149">Każda procedura obsługi klas jest dodawana do magazynu wewnętrznego. Po skonstruowaniu trasy zdarzenia dla aplikacji programy obsługi klas są dodawane do trasy zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="fd66d-150">Procedury obsługi klas są dodawane do trasy w taki sposób, aby procedura obsługi klasy najbardziej pochodnej była wywoływana jako pierwsza, a procedury obsługi klas z każdej kolejnej klasy bazowej są wywoływane dalej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="fd66d-151">Ogólnie rzecz biorąc, programy obsługi klas nie są zarejestrowane w taki sposób, że reagują również na zdarzenia kierowane, które zostały już oznaczone jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="fd66d-152">W związku z tym mechanizm obsługi klasy umożliwia wybranie jednej z dwóch opcji:</span><span class="sxs-lookup"><span data-stu-id="fd66d-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="fd66d-153">Klasy pochodne mogą uzupełniać obsługę klasy, która jest dziedziczona z klasy podstawowej przez dodanie programu obsługi, który nie oznacza obsłużonego zdarzenia kierowanego, ponieważ procedura obsługi klasy bazowej zostanie wywołana jakiś czas po obsłudze klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="fd66d-154">Klasy pochodne mogą zastąpić obsługę klasy z klasy podstawowej przez dodanie obsługi klasy, która oznacza obsłużone zdarzenie kierowane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="fd66d-155">Należy zachować ostrożność w tym podejściu, ponieważ może to spowodować zmianę zamierzonego projektu kontrolki podstawowej w obszarach takich jak wygląd wizualizacji, logika stanu, obsługa danych wejściowych i obsługa poleceń.</span><span class="sxs-lookup"><span data-stu-id="fd66d-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="fd66d-156">Obsługa klasy zdarzeń kierowanych przez klasy bazowe kontroli</span><span class="sxs-lookup"><span data-stu-id="fd66d-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="fd66d-157">W każdym z podanym węzłem elementu w marszrucie zdarzeń detektory klas mają możliwość odpowiadania na zdarzenia kierowane przed dowolnym odbiornikiem wystąpienia elementu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="fd66d-158">Z tego powodu procedury obsługi klas są czasami używane do pomijania zdarzeń kierowanych, których dana implementacja klasy kontroli nie chce bardziej propagować ani w celu zapewnienia specjalnej obsługi tego zdarzenia, które jest funkcją klasy.</span><span class="sxs-lookup"><span data-stu-id="fd66d-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="fd66d-159">Na przykład Klasa może zgłosić własne zdarzenie specyficzne dla klasy, które zawiera bardziej szczegółowe informacje o tym, co dany warunek wejściowy użytkownika wskazuje w kontekście tej konkretnej klasy.</span><span class="sxs-lookup"><span data-stu-id="fd66d-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="fd66d-160">Implementacja klasy może następnie oznaczyć bardziej ogólne zdarzenie routingu jako obsłużone.</span><span class="sxs-lookup"><span data-stu-id="fd66d-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="fd66d-161">Procedury obsługi klas są zazwyczaj dodawane, tak że nie są wywoływane dla zdarzeń kierowanych, w przypadku których dane zdarzenia udostępnionego zostały już oznaczone jako obsłużone, ale w <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> przypadku nietypowych przypadków istnieje również sygnatura, która rejestruje procedury obsługi do wywołania nawet wtedy, gdy zdarzenia kierowane są oznaczone jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="fd66d-162">Wirtualne procedury obsługi klas</span><span class="sxs-lookup"><span data-stu-id="fd66d-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="fd66d-163">Niektóre elementy, szczególnie elementy podstawowe, takie jak <xref:System.Windows.UIElement>, uwidaczniają metody wirtualne "on \* Event" i "\*onpreview Event", które odpowiadają ich liście publicznych tras routingu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="fd66d-164">Te metody wirtualne można zastąpić, aby zaimplementować obsługę klasy dla tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="fd66d-165">Klasy elementów podstawowych rejestrują te metody wirtualne jako obsługę klas dla każdego takiego zdarzenia <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> kierowanego, zgodnie z wcześniejszym opisem.</span><span class="sxs-lookup"><span data-stu-id="fd66d-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="fd66d-166">W\*przypadku takich zdarzeń wirtualne metody są znacznie prostsze do implementowania obsługi klas dla odpowiednich zdarzeń kierowanych, bez konieczności specjalnej inicjalizacji w konstruktorach statycznych dla każdego typu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="fd66d-167">Na przykład można dodać obsługę klasy dla <xref:System.Windows.UIElement.DragEnter> zdarzenia w dowolnej <xref:System.Windows.UIElement> klasie <xref:System.Windows.UIElement.OnDragEnter%2A> pochodnej przez zastąpienie metody wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="fd66d-168">W ramach przesłonięcia można obsłużyć zdarzenie trasowane, zgłosić inne zdarzenia, zainicjować logikę specyficzną dla klasy, która może zmienić właściwości elementu w wystąpieniach lub dowolną kombinację tych akcji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="fd66d-169">Na ogół należy wywołać implementację podstawową w takich zastąpień, nawet jeśli zostanie zaznaczone zdarzenie obsłużone.</span><span class="sxs-lookup"><span data-stu-id="fd66d-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="fd66d-170">Wywołanie podstawowej implementacji jest zdecydowanie zalecane, ponieważ metoda wirtualna znajduje się w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="fd66d-171">Standardowy, chroniony wzorzec wirtualny wywołujący implementacje podstawowe z poszczególnych wirtualnych, zasadniczo zastępuje i równoległy podobny mechanizm, który jest natywny dla routingu kierowanego klasy zdarzeń, zgodnie z którymi obsługiwane są klasy obsługi dla wszystkich klas w hierarchii klas wywoływana dla dowolnego wystąpienia, rozpoczynając od procedury obsługi najbardziej pochodnej klasy i kontynuując procedurę obsługi klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="fd66d-172">Należy pominąć podstawowe wywołanie implementacji tylko wtedy, gdy Klasa ma zamierzone wymaganie zmiany logiki obsługi klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="fd66d-173">Niezależnie od tego, czy zostanie wywołana implementacja podstawowa przed czy po zastępujący kod zależą od charakteru implementacji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="fd66d-174">Obsługa klasy zdarzeń wejściowych</span><span class="sxs-lookup"><span data-stu-id="fd66d-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="fd66d-175">Metody wirtualne procedury obsługi klas są rejestrowane w taki sposób, że są wywoływane tylko w przypadkach, gdy żadne udostępnione dane zdarzenia nie są już oznaczone jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="fd66d-176">Ponadto dla zdarzeń wejściowych w unikatowy sposób tunelowanie i wersje propagacji są zwykle wywoływane w kolejności i udostępniania danych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="fd66d-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="fd66d-177">Pociąga to za sobą, że dla danej pary programów obsługi klasy zdarzeń wejściowych, gdzie jedna jest wersją tunelowania, a druga jest wersją propagacji, można nie chcieć oznaczyć zdarzenia natychmiast.</span><span class="sxs-lookup"><span data-stu-id="fd66d-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="fd66d-178">W przypadku zaimplementowania klasy tunelowania obsługującej metodę wirtualną w celu oznaczenia obsłużonego zdarzenia, co uniemożliwi wywoływanie procedury obsługi klasy propagacji (a także zapobieganie wszelkim zwykle zarejestrowanym obsłudze wystąpień dla zdarzenia tunelowania lub propagacji z Wywoływanie).</span><span class="sxs-lookup"><span data-stu-id="fd66d-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="fd66d-179">Po zakończeniu obsługi klasy w węźle są brane pod uwagę detektory wystąpień.</span><span class="sxs-lookup"><span data-stu-id="fd66d-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="fd66d-180">Dodawanie programów obsługi wystąpień, które są wywoływane nawet wtedy, gdy zdarzenia są oznaczone jako obsługiwane</span><span class="sxs-lookup"><span data-stu-id="fd66d-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="fd66d-181"><xref:System.Windows.UIElement.AddHandler%2A> Metoda dostarcza konkretne Przeciążenie, które pozwala na dodawanie programów obsługi, które będą wywoływane przez system zdarzeń za każdym razem, gdy zdarzenie osiągnie element obsługi w marszrucie, nawet jeśli inna procedura obsługi już dostosowuje dane zdarzenia, aby oznaczyć to zdarzenie jako obsłużone.</span><span class="sxs-lookup"><span data-stu-id="fd66d-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="fd66d-182">Nie jest to zwykle wykonywane.</span><span class="sxs-lookup"><span data-stu-id="fd66d-182">This is not typically done.</span></span> <span data-ttu-id="fd66d-183">Ogólnie rzecz biorąc, programy obsługi można napisać, aby dostosować wszystkie obszary kodu aplikacji, które mogą mieć wpływ na zdarzenie, bez względu na to, gdzie zostało obsłużone w drzewie elementów, nawet jeśli pożądane jest wiele wyników końcowych.</span><span class="sxs-lookup"><span data-stu-id="fd66d-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="fd66d-184">Ponadto zazwyczaj istnieje tylko jeden element, który musi odpowiedzieć na to zdarzenie, a odpowiednia logika aplikacji już się zakończyła.</span><span class="sxs-lookup"><span data-stu-id="fd66d-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="fd66d-185">`handledEventsToo` Ale Przeciążenie jest dostępne dla wyjątkowych przypadków, w których jakiś inny element w drzewie elementów lub składowe kontrolki już oznaczył zdarzenie jako obsłużone, ale inne elementy w drzewie elementów (w zależności od trasy) są nadal Chcemy, aby zostały wywołane własne programy obsługi.</span><span class="sxs-lookup"><span data-stu-id="fd66d-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="fd66d-186">Kiedy należy oznaczyć zdarzenia obsłużone jako nieobsłużone</span><span class="sxs-lookup"><span data-stu-id="fd66d-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="fd66d-187">Na ogół zdarzenia kierowane, które są oznaczone jako obsługiwane, nie powinny być oznaczone jako<xref:System.Windows.RoutedEventArgs.Handled%2A> nieobsłużone `false`(ustawienie wstecz do), nawet przez `handledEventsToo`programy obsługi, które działają.</span><span class="sxs-lookup"><span data-stu-id="fd66d-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="fd66d-188">Jednak niektóre zdarzenia wejściowe zawierają reprezentacje zdarzeń wysokiego poziomu i niższego poziomu, które mogą się nakładać w przypadku wystąpienia zdarzenia wysokiego poziomu w drzewie oraz zdarzenia niskiego poziomu na innym miejscu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="fd66d-189">Na przykład rozważmy przypadek, w którym element podrzędny nasłuchuje zdarzenia klucza wysokiego poziomu, takiego jak <xref:System.Windows.UIElement.TextInput> while, gdy element nadrzędny nasłuchuje zdarzenia niskiego poziomu, takiego jak. <xref:System.Windows.UIElement.KeyDown></span><span class="sxs-lookup"><span data-stu-id="fd66d-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="fd66d-190">Jeśli element nadrzędny obsługuje zdarzenie niskiego poziomu, zdarzenie wyższego poziomu można pominąć nawet w elemencie podrzędnym, który intuicyjnie powinien mieć pierwszą okazję do obsłużenia zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="fd66d-191">W takich sytuacjach może być konieczne dodanie programów obsługi zarówno do elementów nadrzędnych, jak i elementów podrzędnych dla zdarzenia niskiego poziomu.</span><span class="sxs-lookup"><span data-stu-id="fd66d-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="fd66d-192">Implementacja obsługi elementu podrzędnego może oznaczyć zdarzenie niskiego poziomu jako obsłużone, ale implementacja obsługi elementu nadrzędnego ustawi ją nieobsłużoną ponownie, aby dalsze elementy drzewa (jak również zdarzenie wysokiego poziomu) mogły odpowiadać.</span><span class="sxs-lookup"><span data-stu-id="fd66d-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="fd66d-193">Ta sytuacja powinna być dość rzadki.</span><span class="sxs-lookup"><span data-stu-id="fd66d-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="fd66d-194">Świadome pomijanie zdarzeń wejściowych dla składowych kontroli</span><span class="sxs-lookup"><span data-stu-id="fd66d-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="fd66d-195">Głównym scenariuszem, w którym stosowana jest Klasa obsługi zdarzeń kierowanych, jest dla zdarzeń wejściowych i kontrolek złożonych.</span><span class="sxs-lookup"><span data-stu-id="fd66d-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="fd66d-196">Złożona kontrolka jest według definicji składającej się z wielu praktycznych formantów lub klas podstawowych kontroli.</span><span class="sxs-lookup"><span data-stu-id="fd66d-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="fd66d-197">Często autor formantu chce amalgamate wszystkie możliwe zdarzenia wejściowe, które mogą zostać zgłoszone przez każdy podskładniki, aby zgłosić cały formant jako pojedyncze Źródło zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="fd66d-198">W niektórych przypadkach autor kontrolki może chcieć całkowicie pominąć zdarzenia ze składników lub zastąpić zdarzenie zdefiniowane przez składnik, które zawiera więcej informacji, lub oznacza bardziej szczegółowe zachowanie.</span><span class="sxs-lookup"><span data-stu-id="fd66d-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="fd66d-199">Przykład kanoniczny, który jest natychmiast widoczny dla każdego autora składnika, polega [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] na <xref:System.Windows.Controls.Button> tym, jak obsługuje zdarzenie myszy, które ostatecznie rozwiąże się z intuicyjnym zdarzeniem, które ma <xref:System.Windows.Controls.Primitives.ButtonBase.Click> wszystkie przyciski: zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="fd66d-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="fd66d-200"><xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Control> <xref:System.Windows.UIElement> <xref:System.Windows.UIElement> <xref:System.Windows.FrameworkElement> Klasa bazowa () pochodzi z, która z kolei jest pochodząca z i, i większość infrastruktury zdarzeń wymaganych do przetwarzania danych wejściowych kontroli jest dostępna na poziomie. <xref:System.Windows.Controls.Button></span><span class="sxs-lookup"><span data-stu-id="fd66d-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="fd66d-201">W szczególności <xref:System.Windows.UIElement> przetwarza ogólne <xref:System.Windows.Input.Mouse> zdarzenia obsługujące testowanie trafień kursora myszy w granicach, a także udostępnia odrębne zdarzenia dla najbardziej typowych akcji przycisków, takich jak <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="fd66d-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="fd66d-202"><xref:System.Windows.UIElement>Program udostępnia także pustą <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> wirtualną jako prezarejestrowaną procedurę obsługi klasy <xref:System.Windows.UIElement.MouseLeftButtonDown>dla i <xref:System.Windows.Controls.Primitives.ButtonBase> zastępuje ją.</span><span class="sxs-lookup"><span data-stu-id="fd66d-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="fd66d-203">Podobnie, <xref:System.Windows.Controls.Primitives.ButtonBase> program używa obsługi klas dla <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="fd66d-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="fd66d-204">W przesłonięciach, które są przekazywać dane zdarzenia, implementacje oznaczają <xref:System.Windows.RoutedEventArgs> to wystąpienie jako obsługiwane przez <xref:System.Windows.RoutedEventArgs.Handled%2A> ustawienie `true`do, a te same dane zdarzenia są kontynuowane wzdłuż pozostałej części trasy do innych programów obsługi klas i także do obsługi wystąpień lub metod ustawiających zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd66d-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="fd66d-205">Ponadto przesłonięcie będzie dalej <xref:System.Windows.Controls.Primitives.ButtonBase.Click> podnieść zdarzenie. <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A></span><span class="sxs-lookup"><span data-stu-id="fd66d-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="fd66d-206">Wynik końcowy większości odbiorników będzie miał miejsce, gdy <xref:System.Windows.UIElement.MouseLeftButtonDown> zdarzenia <xref:System.Windows.UIElement.MouseLeftButtonUp> i "znikną" i zostaną zastąpione <xref:System.Windows.Controls.Primitives.ButtonBase.Click>przez, zdarzenie, które ma więcej znaczenia, ponieważ wiadomo, że to zdarzenie pochodzi z przycisku prawda, a nie niektórych część złożona przycisku lub z innego elementu w całości.</span><span class="sxs-lookup"><span data-stu-id="fd66d-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="fd66d-207">Praca nad pomijaniem zdarzeń przez kontrolki</span><span class="sxs-lookup"><span data-stu-id="fd66d-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="fd66d-208">Czasami takie zachowanie pominięcia zdarzeń w ramach poszczególnych kontrolek może kolidować z bardziej ogólnymi intencjami logiki obsługi zdarzeń aplikacji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="fd66d-209">Na przykład, jeśli z jakiegoś powodu aplikacja miała procedurę obsługi dla <xref:System.Windows.UIElement.MouseLeftButtonDown> elementu głównego aplikacji, należy zauważyć, że kliknięcie przycisku nie spowoduje wywołania <xref:System.Windows.UIElement.MouseLeftButtonDown> ani <xref:System.Windows.UIElement.MouseLeftButtonUp> obsługi na poziomie głównym.</span><span class="sxs-lookup"><span data-stu-id="fd66d-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="fd66d-210">Samo zdarzenie w rzeczywistości zostało wykonane ponownie, a trasy zdarzeń nie zakończyły się naprawdę, ale system zdarzeń został zmieniony przez wywołanie procedury obsługi po oznaczeniu jako obsługiwanego.</span><span class="sxs-lookup"><span data-stu-id="fd66d-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="fd66d-211">Gdy zdarzenie kierowane osiągnie przycisk, obsługa <xref:System.Windows.Controls.Primitives.ButtonBase> klasy <xref:System.Windows.UIElement.MouseLeftButtonDown> oznaczona jako obsłużona, ponieważ <xref:System.Windows.Controls.Primitives.ButtonBase.Click> życzy sobie, że zastąpi to zdarzenie bardziej sensem.</span><span class="sxs-lookup"><span data-stu-id="fd66d-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="fd66d-212">W związku z tym <xref:System.Windows.UIElement.MouseLeftButtonDown> , dowolna standardowa procedura obsługi nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="fd66d-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="fd66d-213">Istnieją dwie techniki, których można użyć, aby upewnić się, że procedury obsługi byłyby wywołane w tej sytuacji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="fd66d-214">Pierwszą techniką jest zamierzone dodanie procedury obsługi przy użyciu `handledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>sygnatury.</span><span class="sxs-lookup"><span data-stu-id="fd66d-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="fd66d-215">Ograniczenie tej metody polega na tym, że ta technika dołączania obsługi zdarzeń jest możliwa tylko z kodu, a nie z znaczników.</span><span class="sxs-lookup"><span data-stu-id="fd66d-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="fd66d-216">Prosta składnia określająca nazwę programu obsługi zdarzeń jako wartość atrybutu zdarzenia za pośrednictwem [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] nie pozwala na takie zachowanie.</span><span class="sxs-lookup"><span data-stu-id="fd66d-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="fd66d-217">Druga technika działa tylko dla zdarzeń wejściowych, w przypadku których są sparowane tunelowanie i propagacje wersji zdarzenia kierowanego.</span><span class="sxs-lookup"><span data-stu-id="fd66d-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="fd66d-218">W przypadku tych zdarzeń rozesłanych zamiast tego można dodać programy obsługi do odpowiedniego zdarzenia zapoznawczego/tunelowania.</span><span class="sxs-lookup"><span data-stu-id="fd66d-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="fd66d-219">To zdarzenie jest kierowane przez trasę rozpoczynającą się od elementu głównego, więc Klasa Button obsługująca kod nie przechwytuje go, co zakłada, że dołączono procedurę obsługi podglądu na pewnym poziomie elementu nadrzędnego w drzewie elementów aplikacji.</span><span class="sxs-lookup"><span data-stu-id="fd66d-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="fd66d-220">W przypadku korzystania z tej metody należy zachować ostrożność podczas oznaczania obsługi zdarzeń w wersji zapoznawczej.</span><span class="sxs-lookup"><span data-stu-id="fd66d-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="fd66d-221">W przypadku podanego <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> przykładu z obsługą w elemencie głównym, jeśli oznaczono zdarzenie jako <xref:System.Windows.RoutedEventArgs.Handled%2A> w implementacji programu obsługi, <xref:System.Windows.Controls.Primitives.ButtonBase.Click> można faktycznie pominąć zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="fd66d-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="fd66d-222">Zwykle nie jest to pożądane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="fd66d-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fd66d-223">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="fd66d-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="fd66d-224">Podgląd zdarzeń</span><span class="sxs-lookup"><span data-stu-id="fd66d-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="fd66d-225">Tworzenie niestandardowego zdarzenia trasowanego</span><span class="sxs-lookup"><span data-stu-id="fd66d-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="fd66d-226">Przegląd zdarzeń trasowanych</span><span class="sxs-lookup"><span data-stu-id="fd66d-226">Routed Events Overview</span></span>](routed-events-overview.md)
