---
title: Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 2d696c85be0f46c5f08e1770f0d695dbb4d50cb9
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
ms.locfileid: "33549412"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy
Programy obsługi dla kierowanego zdarzenia można oznaczyć zdarzeń przetwarzanych w ramach danych zdarzenia. Obsługa zdarzenia skutecznie skrócić trasy. Obsługa klasy to pojęcie programowania, który jest obsługiwany przez kierowane zdarzenia. Klasy obsługi ma możliwość obsługi określonego kierowanego zdarzenia na poziomie klasy z programem obsługi, które jest wywoływane przed wszystkie wystąpienia obsługi na dowolne wystąpienie klasy.  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Wymagania wstępne  
 W tym temacie rosnącego założenia [kierowane Przegląd zdarzeń](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Kiedy zostać oznaczone jako obsługi zdarzeń  
 Jeśli ustawisz wartość <xref:System.Windows.RoutedEventArgs.Handled%2A> właściwości `true` zdarzeń dane kierowanego zdarzenia, jest to określane jako "oznaczenie zdarzeń obsługiwane". Nie bezwzględne zasady dla kiedy należy oznaczyć kierowane zdarzenia jako obsługiwany, jako autor aplikacji lub jako formant Autor, który reaguje na zdarzenia routingiem istniejących lub nowych implementuje kierowane zdarzenia. W większości przypadków, pojęcie "obsługiwana", jak odbywa się w danych zdarzenia kierowanego zdarzenia powinna być używana jako ograniczona protokołu dla odpowiedzi własnych aplikacji do różnych kierowane zdarzenia w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] jak również za kierowane niestandardowe zdarzenia. Innym sposobem należy wziąć pod uwagę "obsłużone" problem jest czy zazwyczaj należy oznaczyć kierowanego zdarzenia obsłużone w sposób znaczny i względnie pełną kod odpowiedzi kierowanego zdarzenia. Zazwyczaj nie powinien zawierać więcej niż jeden znaczących odpowiedzi, która wymaga obsługi oddzielnych implementacji dla wystąpienia dowolnego pojedynczego kierowanego zdarzenia. Jeśli potrzebne są odpowiedzi więcej, niezbędne kodu powinny być implementowane przez logikę aplikacji, który jest powiązany łańcuchem zależności w ramach jednej procedury obsługi, a nie za pomocą systemu kierowanego zdarzenia do przesyłania dalej. Co to jest "znaczących" pojęcia również subiektywne i zależy od aplikacji lub kodu. Stanowią ogólne wskazówki "znaczących odpowiedzi" Przykłady: Ustawianie fokusu, modyfikowania stanu publicznej właściwości, które mają wpływ na wizualną reprezentację i wywoływanie innych nowych zdarzeń. Przykłady nonsignificant odpowiedzi: modyfikowanie prywatnej stanu (Brak wizualny lub programowe reprezentacja), rejestrowanie zdarzeń, lub patrzeć argumenty zdarzeń i wybierając pozycję nie odpowiedzieć.  
  
 Zachowanie systemu kierowanego zdarzenia wzmacnia ten model "znaczących odpowiedzi" dotyczące korzystania z obsługiwanego stanu kierowanego zdarzenia, ponieważ programy obsługi [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] lub wspólnej podpis <xref:System.Windows.UIElement.AddHandler%2A> nie są wywoływane w odpowiedzi na kierowanego zdarzenia gdzie zdarzenia dane są oznaczane już obsługiwany. Musi przechodzić przez dodatkowy nakład pracy dodawania obsługi z `handledEventsToo` wersji parametr (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) w celu obsługi zdarzeń trasy kierowanego zdarzenia, które są oznaczone obsługiwane przez wcześniejszą uczestników.  
  
 W niektórych sytuacjach samych formantów oznaczyć niektórych kierowane zdarzenia obsługiwane. Obsługiwany kierowanego zdarzenia reprezentuje decyzji [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kontrolowania autorom dostępnych akcji formantu w odpowiedzi na kierowanego zdarzenia znaczących lub pełną zgodnie z implementacją kontrolki i zdarzenia wymagających nie dalszych czynności. Zazwyczaj jest to realizowane przez dodanie obsługi klasy zdarzenia lub przez zastąpienie jednego z elementów wirtualnych obsługi klasy, który istnieje w klasie podstawowej. Nadal można obejść to zdarzenie obsługi, jeśli jest to konieczne. zobacz [pracy wokół zdarzeń pomijanie przez formanty](#WorkingAroundEventSuppressionByControls) dalszej części tego tematu.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"W wersji zapoznawczej" vs zdarzenia (Tunneling). Propagacji zdarzeń i obsługa zdarzeń  
 Podgląd kierowane zdarzenia są zdarzenia, które wykonaj tunelowania trasę przez element drzewa. "Wersja zapoznawcza" wyrażone w konwencji nazewnictwa jest wskaźnikiem zasady dla zdarzenia wejściowe, że przed równoważne propagacji kierowanego zdarzenia są generowane w wersji zapoznawczej (z tunelowaniem) kierowane zdarzenia. Ponadto wejściowych kierowane zdarzenia, które mają tunelowania propagacji parę ma logiki Obsługa unikatowych. Jeśli zdarzenie tunelowania/Podgląd kierowane jest oznaczony jako obsługiwane przez odbiornik zdarzeń, następnie propagacji, które zostaną oznaczone jako kierowanego zdarzenia obsługiwane nawet przed odebrane przez wszystkie odbiorniki propagacji kierowanego zdarzenia. Tunelowania i propagacji kierowane zdarzenia są technicznie odrębne zdarzenia, ale one celowo współużytkują to samo wystąpienie danych zdarzenia, aby włączyć to zachowanie.  
  
 Połączenie między tunelowania i propagacji kierowane zdarzenia odbywa się przy implementacji wewnętrznego, jak żadnej podanej [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] klasy wywołuje własną zadeklarowane kierowane zdarzenia, a jest to istotne w parach kierowane zdarzenia wejściowe. Ale chyba, że ta implementacja klasy poziomie istnieje, nie połączenia między tunelowania kierowanego zdarzenia i propagacji kierowanego zdarzenia, które używają schemat nazewnictwa: bez takie wdrożenie będzie dwa rozłączne kierowane zdarzenia, a nie będzie wywoływane w kolejności lub w udziale danych zdarzenia.  
  
 Aby uzyskać więcej informacji dotyczących sposobu wdrażania tunelu/bąbelków pary wejściowych kierowanego zdarzenia w klasie niestandardowych, zobacz [utworzyć niestandardowe zdarzenia rozsyłane](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Obsługę klas i wystąpień obsługi  
 Kierowane zdarzenia należy wziąć pod uwagę dwa typy obiektów nasłuchujących na zdarzenie: klasy odbiorników i odbiorników wystąpienia. Odbiorniki klasy istnieje, ponieważ typy wywołano określonego <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, w ich Konstruktor statyczny lub przesłonili metodą wirtualną klasę programu obsługi z klasy podstawowej elementu. Obiekty nasłuchujące wystąpienia są wystąpień określonej klasy/elementy gdzie obsługi co najmniej jeden zostały dołączone do tego kierowanego zdarzenia przez wywołanie do <xref:System.Windows.UIElement.AddHandler%2A>. Istniejące [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kierowane zdarzenia wykonywania wywołań do <xref:System.Windows.UIElement.AddHandler%2A> jako część [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] dodać otoki zdarzeń{} i Usuń{} implementacje zdarzenia, który jest także sposób uproszczonych [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanizm dołączania programy obsługi zdarzeń za pomocą składni atrybutu jest włączona. W związku z tym nawet prosty [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] użycia ostatecznie jest równa <xref:System.Windows.UIElement.AddHandler%2A> wywołania.  
  
 Elementy w drzewie wizualnym są sprawdzane pod kątem implementacje zarejestrowaną usługę programu obsługi. Programy obsługi są wywoływane potencjalnie w całym trasy, w kolejności należącej do typu strategii routingu dla tego kierowanego zdarzenia. Na przykład propagacji kierowane zdarzenia najpierw wywoła te programy obsługi, które są dołączone do tego samego elementu, który wywołał zdarzenie routingiem. Następnie kierowanego zdarzenia "propaguje" do następnego elementu nadrzędnego itd. aż do osiągnięcia elementu katalogu głównego aplikacji.  
  
 Z punktu widzenia głównego elementu propagacji trasy Jeśli obsługa klasy lub dowolnego elementu bliżej źródło kierowanego zdarzenia wywołania obsługi, które Oznacz argumenty zdarzeń jako obsłużony, następnie programów obsługi na główny elementy nie są wywoływane i zdarzenia trasy efektywne jest obcinana przed osiągnięciem tego elementu głównego. Jednak trasy nie jest całkowicie zatrzymywany, ponieważ programy obsługi można dodać za pomocą specjalnych warunkowego, że są nadal powinna być wywoływana, nawet jeśli program obsługi klasy lub wystąpienia obsługi oznaczyła kierowanego zdarzenia jako obsługiwane. Wyjaśnienie jest zawarte w [dodanie wystąpienia obsługi czy są wywoływane nawet podczas zdarzenia są oznaczone obsługiwane](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)w dalszej części tego tematu.  
  
 Na poziomie głębiej niż trasy zdarzenia są również potencjalnie klasy procedury obsługi wielu działającą w danym przypadku klasy. To jest ponieważ model obsługi klasy dla kierowane zdarzenia umożliwia wszystkich możliwych klas w hierarchii klasy do każdego zarejestrować własnej klasy obsługi dla każdego kierowanego zdarzenia. Każdy program obsługi klasy jest dodawany do magazynu wewnętrznej, a gdy trasy zdarzenia dla aplikacji jest tworzony, obsługę klas są wszystkie dodane do trasy zdarzenia. Obsługę klas są dodawane do trasy tak, aby najpierw wywołaniu obsługi klas pochodnych większość i obsługę klas z każdym kolejnych klasy podstawowej są wywoływane dalej. Ogólnie rzecz biorąc obsługę klas nie są zarejestrowane w taki sposób, że odpowiada one także kierowane zdarzenia oznaczone już obsługiwane. W związku z tym ta klasa mechanizmu obsługi umożliwia jedną z dwóch opcji:  
  
-   Klasy pochodne można uzupełnić Obsługa klasy, która jest dziedziczona z klasy podstawowej przez dodanie obsługi, które nie są oznaczane kierowanego zdarzenia obsługiwane, ponieważ program obsługi klasy podstawowej zostanie wywołany pewnego czasu po obsługi klasy pochodnej.  
  
-   Klasy pochodne mogą zastąpić klasy obsługi z klasy podstawowej przez dodanie obsługi klasy, która oznacza kierowanego zdarzenia obsługiwane. Należy zachować ostrożność przy takie podejście, ponieważ potencjalnie zmieni projektowania podstawowej kontrolnych w obszarach, takich jak wygląd, stan logiki obsługi danych wejściowych i obsługa polecenia.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Klasy obsługi kierowane zdarzenia przez formant klas podstawowych  
 Danego elementu w każdym węźle trasy zdarzenia odbiorników klasy mają możliwość udzielenia odpowiedzi na kierowanego zdarzenia przed żadnych odbiornika wystąpienia na może element. Z tego powodu obsługę klas są czasami używane do pomijania kierowane zdarzenia, które implementację klasy określonego formantu nie ma dalszych propagację lub w celu zapewnienia specjalnej obsługi tego kierowanego zdarzenia, który jest funkcją klasy. Dla wystąpienia klasy może podnieść własne zdarzenia specyficzne dla klasy, zawierający więcej szczegółowych informacji o niektórych warunku wejściowych użytkownika oznacza w ramach danej klasy. Implementacja klasy może następnie oznaczenie bardziej ogólne kierowanego zdarzenia jako obsłużone. Obsługę klas są zwykle dodane taki sposób, że nie jest wywoływana dla kierowane zdarzenia, których dane zdarzenia udostępnionych zostało już oznaczone obsługiwane, ale dla nietypowe dostępna jest również <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> podpisie, który rejestruje obsługę klas można wywołać, nawet wtedy, gdy kierowane zdarzenia są oznaczone obsłużone.  
  
### <a name="class-handler-virtuals"></a>Klasy obsługi elementy wirtualne  
 Niektóre elementy, takie jak szczególnie podstawowych elementów <xref:System.Windows.UIElement>, pusty Uwidacznianie "na * zdarzeń" i "OnPreview\*zdarzeń" metody wirtualne, które odpowiadają ich lista publicznego kierowane zdarzenia. Te metody wirtualne mogą zostać zastąpione do zaimplementowania klasy obsługę tego kierowanego zdarzenia. Klasy podstawowej elementu zarejestrować tych metod wirtualnych podczas rozsyłania ich obsługi klasy dla każdej z takich zdarzeń za pomocą <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> zgodnie z wcześniejszym opisem. On\*zdarzenia metod wirtualnych stał się znacznie prostsza do zaimplementowania klasy obsługi dla odpowiedniego kierowane zdarzenia, bez konieczności specjalne inicjowania w konstruktorów statycznych dla każdego typu. Na przykład można dodać obsługi dla klasy <xref:System.Windows.UIElement.DragEnter> zdarzeń w żadnym <xref:System.Windows.UIElement> pochodnej klasy przez zastąpienie <xref:System.Windows.UIElement.OnDragEnter%2A> metoda wirtualna. W ramach override można obsłużyć kierowanego zdarzenia, wywołania innych zdarzeń, zainicjować logiki specyficzne, która może spowodować zmianę właściwości elementu w wystąpieniach czy dowolnej kombinacji tych akcji. Należy zwykle wywoływać implementację podstawową w takich zastąpienia nawet wtedy, gdy oznaczyć obsługi zdarzenia. Zdecydowanie zaleca się wywołanie do podstawowej implementacji, ponieważ metoda wirtualna znajduje się w klasie podstawowej. Standardowe chronionych wzorzec wirtualnego zasadniczo wywołania podstawowych implementacji z każdego wirtualnego zastępuje i równoleżnikami podobny mechanizm, który jest natywnej do obsługi klasy kierowanego zdarzenia, według którego obsługę klas dla wszystkich klas w hierarchii klas są wywołuje się w danym przypadku, począwszy od obsługi pochodnych większość klasy i kontynuowanie obsługi klasy podstawowej. Wywołanie implementacji podstawowej należy pominąć tylko, jeśli klasy zamierzonego wymagane Zmiana klasy podstawowej obsługi logiki. Określa, czy można wywoływać implementację podstawową przed lub po kodzie zastępowanie zależy od rodzaju implementacji.  
  
#### <a name="input-event-class-handling"></a>Dane wejściowe zdarzeń klasy obsługi  
 Metody wirtualne obsługi klasy wszystkich zarejestrowanych w taki sposób, że są one wywołać tylko w przypadkach, gdy wszystkie dane zdarzeń udostępnionego nie są już oznaczone obsługiwane. Ponadto dla zdarzenia wejściowe jednoznacznie, wersje tunelowania i propagacji zwykle są zgłaszane w sekwencji i udziału dane zdarzenia. Dzięki temu, czy dla danego pary klasy obsługi zdarzeń wprowadzania których jeden jest tunelowania wersji, a drugi to propagacji wersji, może nie chcesz oznaczyć zdarzenia obsługiwane natychmiast. Klasa tunelowania obsługi metody wirtualnej do oznaczenia zdarzeń obsługiwane w przypadku zastosowania, która uniemożliwi propagacji obsługi klasy wywoływaną (a także uniemożliwia wszelkie obsługi zwykle zarejestrowanych wystąpień tunelowania lub propagacji zdarzenia z wywoływany).  
  
 Po zakończeniu obsługi w węźle klasy są traktowane jako obiekty nasłuchujące wystąpienia.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Dodawanie obsługi wystąpienia, które są generowane, nawet wtedy, gdy zdarzenia są oznaczone obsługiwane  
 <xref:System.Windows.UIElement.AddHandler%2A> Określonego przeciążenia, które umożliwia dodanie obsługi, które będzie wywoływany przez system zdarzeń zawsze, gdy zdarzenie osiągnie element obsługi trasy, nawet jeśli niektóre procedury obsługi zostały skorygowane już dane zdarzenia, aby oznaczyć, który dostarcza — metoda zdarzenie, ponieważ obsługiwane. Nie jest to zazwyczaj wykonywane. Ogólnie rzecz biorąc programy obsługi można napisać tak aby dopasować wszystkich obszarów kodu aplikacji, która może zależeć od zdarzenia, niezależnie od tego, gdzie go obsłużono w drzewie elementu, nawet jeśli wiele wyników zakończenia są potrzebne. Ponadto zwykle jest naprawdę tylko jeden element, który musi odpowiadać na zdarzenie i logiki aplikacji już miał wystąpił. Ale `handledEventsToo` przeciążenia jest dostępna dla większości przypadków, gdy niektóre innego elementu w element składania drzewa lub formant już oznaczyła zdarzenia jako obsługiwane, ale inne elementy wyższe lub niższe w drzewie elementu (w zależności od trasy) nadal chcesz, aby własne programy obsługi wywołany.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Kiedy należy oznaczyć obsługi zdarzeń jako nieobsługiwany  
 Ogólnie rzecz biorąc, kierowane zdarzenia, które są oznaczone jako obsługiwany nie powinien być oznaczony nieobsługiwany (<xref:System.Windows.RoutedEventArgs.Handled%2A> ustawiana dla `false`) nawet przez programy obsługi, które mają wpływ na `handledEventsToo`. Jednak niektóre zdarzenia wejściowe mają reprezentacje zdarzenia wysokiego poziomu oraz niższych poziomach, nakładające podczas wysokiego poziomu zdarzeń jest widoczna w jedną pozycję w drzewie i niskiego poziomu zdarzeń w innym miejscu. Na przykład rozważmy przypadek, gdzie element podrzędny nasłuchuje wysokiego poziomu zdarzeń klucza takich jak <xref:System.Windows.UIElement.TextInput> podczas, gdy element nadrzędny nasłuchuje na niskiego poziomu zdarzeń, takich jak <xref:System.Windows.UIElement.KeyDown>. Jeśli element nadrzędny obsługuje zdarzenie niskiego poziomu, można pominąć wyższego poziomu zdarzeń nawet w przypadku elementu podrzędnego, który intuicyjnie powinien mieć możliwość pierwsze zdarzenie.  
  
 W takich sytuacjach może być konieczne jest dodanie obsługi zarówno elementy nadrzędne i elementy podrzędne dla niskiego poziomu zdarzenia. Implementacja programu obsługi elementu podrzędnego oznaczyć niskiego poziomu zdarzeń jako obsługiwany, ale implementację obsługi elementu nadrzędnego czy zestaw, który ponownie nieobsługiwany tak, aby dodatkowe elementy w górę drzewa (a także wysokiego poziomu zdarzeń) może mieć możliwość udzielenia odpowiedzi. Ta sytuacja powinna być stosunkowo rzadko.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Celowo pomijanie zdarzenia wejściowe dla formantu składania  
 Jest głównym scenariusz, gdzie klasa obsługę kierowane zdarzenia są używane dla zdarzenia wejściowe i połączone formantów. Połączone formant jest zgodnie z definicją składa się z wielu praktycznych kontrolki lub kontroli klas podstawowych. Często autora formantu zamierza amalgamate wszystkie możliwe zdarzenia wejściowe czy każdego podskładniki może podnieść, aby można było zgłosić cały formant jako źródło zdarzenia liczbie pojedynczej. W niektórych przypadkach autora formant może chcieć całkowicie pominąć zdarzenia ze składników, lub Zastąp zdarzenia zdefiniowane przez składnik, zawiera więcej informacji lub oznacza więcej określone zachowanie. Canonical przykład natychmiast widocznego dla dowolnego autora składnika jest sposób [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> obsługuje wszystkie zdarzenia myszy, który ostatecznie zostanie rozwiązany w zdarzeniu intuicyjne że wszystkie przyciski: <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń.  
  
 <xref:System.Windows.Controls.Button> Klasy podstawowej (<xref:System.Windows.Controls.Primitives.ButtonBase>) jest pochodną <xref:System.Windows.Controls.Control> co z kolei wynika z <xref:System.Windows.FrameworkElement> i <xref:System.Windows.UIElement>i wielu infrastrukturę zdarzeń potrzebną do kontrolki wprowadzania przetwarzania jest dostępny w <xref:System.Windows.UIElement> poziom. W szczególności <xref:System.Windows.UIElement> przetwarza ogólne <xref:System.Windows.Input.Mouse> zdarzenia, które obsługi testowania trafień dla kursora myszy w jego zakresie oraz zapewnia różne zdarzenia od najczęstszych przycisku akcji, takich jak <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> udostępnia pustego wirtualnego <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> jako programu obsługi klasy preregistered <xref:System.Windows.UIElement.MouseLeftButtonDown>, i <xref:System.Windows.Controls.Primitives.ButtonBase> zastępuje go. Podobnie <xref:System.Windows.Controls.Primitives.ButtonBase> programy obsługi dla klasy używa <xref:System.Windows.UIElement.MouseLeftButtonUp>. W zastąpienia, które są przekazywane dane zdarzenia, implementacje znak, który <xref:System.Windows.RoutedEventArgs> wystąpienia jako obsługiwany dzięki ustawieniu <xref:System.Windows.RoutedEventArgs.Handled%2A> do `true`, i że tych samych danych zdarzenia jest nadal co wzdłuż pozostałej części trasy do innych programów obsługi klasy i do obsługi wystąpienia lub ustawiające zdarzeń. Ponadto <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> obok zgłosi zastąpienie <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń. W rezultacie w przypadku większości odbiorników będzie <xref:System.Windows.UIElement.MouseLeftButtonDown> i <xref:System.Windows.UIElement.MouseLeftButtonUp> zdarzenia "znikają" i zastępuje zamiast tego <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, zawierający więcej co oznacza, ponieważ wiadomo, czy to zdarzenie pochodzi z przycisku wartość true, a nie niektóre zdarzenia złożony element całkowicie przycisku lub niektóre z innego elementu.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Praca wokół pomijanie zdarzeń przez formanty  
 Czasami to zachowanie pomijanie zdarzeń w ramach poszczególnych formantów może zakłócać pewne ogólne zamiarach logiki aplikacji obsługi zdarzeń. Na przykład jeśli zaistnieje aplikacji ma obsługi dla <xref:System.Windows.UIElement.MouseLeftButtonDown> znajduje się w elemencie głównym aplikacji, można będzie zauważyć, że żadnych kliknięcie przycisku nie może wywołać <xref:System.Windows.UIElement.MouseLeftButtonDown> lub <xref:System.Windows.UIElement.MouseLeftButtonUp> programów obsługi na poziomie głównym. Samym zdarzeniu faktycznie bąbelkowy górę (ponownie, trasy zdarzenia nie są naprawdę zakończone, ale system kierowanego zdarzenia zmiany ich zachowanie wywołania programu obsługi po oznaczana obsłużonych). Po kierowanego zdarzenia po kliknięciu przycisku <xref:System.Windows.Controls.Primitives.ButtonBase> Obsługa klasy oznaczona <xref:System.Windows.UIElement.MouseLeftButtonDown> obsługiwane, ponieważ chciałby zastępuje <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia o znaczeniu więcej. W związku z tym wszystkie standardowe <xref:System.Windows.UIElement.MouseLeftButtonDown> obsługi dalsze zapasowej trasy nie będzie wywołana. Istnieją dwie metody, których można użyć, aby upewnić się, że Twoje programy obsługi będzie wywołana w takiej sytuacji.  
  
 Pierwszy technika jest celowo dodanie obsługi, za pomocą `handledEventsToo` podpis <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Ograniczenie tej metody jest, że ta technika dołączanie program obsługi zdarzeń jest możliwe tylko z kodu, a nie z kodu znaczników. Proste składnia Określanie nazwa programu obsługi zdarzeń jako wartość atrybutu zdarzenia za pośrednictwem [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] nie obsługuje tego zachowania.  
  
 Druga metoda dotyczy tylko zdarzenia wejściowe, gdzie wersje tunelowania i propagacji kierowanego zdarzenia są skojarzone. Dla tych kierowane zdarzenia można zamiast tego dodać obsługi do podglądu/tunelowania równoważne kierowane zdarzenia. Tego kierowanego zdarzenia będą tunelowania za pomocą trasy, począwszy od katalogu głównego, więc klasy przycisk Kod obsługi będzie przechwytuje, przy założeniu, że dołączony obsługi podglądu na określonym poziomie elementu nadrzędnego w drzewie elementu aplikacji. Jeśli używasz tej metody, należy zachować ostrożność oznaczenie dowolnego zdarzenia w wersji zapoznawczej obsługiwane. Na przykład z <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> obsługiwane w elemencie głównym, jeśli jest oznaczony jako zdarzenie <xref:System.Windows.RoutedEventArgs.Handled%2A> w implementacji programu obsługi, czy rzeczywiście Pomiń <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń. Która zazwyczaj nie jest pożądane zachowanie.  
  
## <a name="see-also"></a>Zobacz też  
 <xref:System.Windows.EventManager>  
 [Podgląd zdarzeń](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [Tworzenie niestandardowego zdarzenia trasowanego](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [Przegląd zdarzeń trasowanych](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
