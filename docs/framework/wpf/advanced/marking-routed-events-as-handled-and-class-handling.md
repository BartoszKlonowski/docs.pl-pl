---
title: Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400170"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Oznaczanie zdarzenia trasowanego jako obsłużonego oraz obsługa klasy
Programy obsługi kierowanego zdarzenia można oznaczyć zdarzenie obsługiwane w danych zdarzenia. Obsługa zdarzenia skutecznie skróci trasę. Obsługa klas jest koncepcją programowania, która jest obsługiwana przez kierowane zdarzenia. Program obsługi klas ma możliwość obsługi określonego zdarzenia routowane na poziomie klasy z obsługi, który jest wywoływany przed dowolnego programu obsługi wystąpienia w dowolnym wystąpieniu klasy.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Wymagania wstępne  
 W tym temacie omówiono pojęcia wprowadzone w [Przeglądzie zdarzeń trasowych](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a>Kiedy oznaczyć zdarzenia jako obsługiwane  
 Po ustawieniu wartości <xref:System.Windows.RoutedEventArgs.Handled%2A> właściwości `true` w danych zdarzenia dla kierowanego zdarzenia, jest to określane jako "oznaczanie zdarzenia obsługiwane". Nie ma bezwzględnej reguły, kiedy należy oznaczyć kierowane zdarzenia jako obsługiwane, jako autor aplikacji lub jako autor formantu, który odpowiada na istniejące kierowane zdarzenia lub implementuje nowe kierowane zdarzenia. W przeważającej części pojęcie "obsługiwane" jako przenoszone w danych zdarzeń kierowanego powinny być używane jako ograniczony protokół dla odpowiedzi własnej [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji na różne kierowane zdarzenia udostępniane w interfejsach API, a także dla wszelkich niestandardowych zdarzeń kierowanych. Innym sposobem, aby rozważyć "obsługiwane" problem jest, że zazwyczaj należy oznaczyć kierowane zdarzenie obsługiwane, jeśli kod odpowiedział na kierowane zdarzenie w sposób znaczący i stosunkowo kompletny. Zazwyczaj nie powinno być więcej niż jeden znaczący odpowiedzi, która wymaga oddzielnych implementacji obsługi dla dowolnego wystąpienia pojedynczego zdarzenia kierowanego. Jeśli potrzeba więcej odpowiedzi, następnie niezbędny kod powinien być zaimplementowany za pomocą logiki aplikacji, która jest łańcuchowa w ramach jednego programu obsługi, a nie przy użyciu kierowanego systemu zdarzeń do przekazywania. Pojęcie tego, co jest "istotne" jest również subiektywne i zależy od aplikacji lub kodu. Jako ogólne wskazówki niektóre przykłady "znaczącej odpowiedzi" obejmują: ustawianie fokusu, modyfikowanie stanu publicznego, ustawianie właściwości, które wpływają na reprezentację wizualną, i wywoływanie innych nowych zdarzeń. Przykłady nieznacznych odpowiedzi obejmują: modyfikowanie stanu prywatnego (bez wpływu wizualnego lub reprezentacji programowej), rejestrowanie zdarzeń lub przeglądanie argumentów zdarzenia i wybieranie odpowiedzi na nie.  
  
 Zachowanie systemu kierowanych zdarzeń wzmacnia ten model "znaczącej odpowiedzi" przy użyciu obsługiwanego stanu [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] kierowanego zdarzenia, ponieważ programy obsługi dodane lub typowy podpis nie <xref:System.Windows.UIElement.AddHandler%2A> są wywoływane w odpowiedzi na kierowane zdarzenie, w którym dane zdarzenia są już oznaczone obsługiwane. Należy przejść przez dodatkowy wysiłek dodawania `handledEventsToo` programu obsługi<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>z wersją parametru ( ) w celu obsługi kierowanych zdarzeń, które są oznaczone obsługiwane przez wcześniejszych uczestników w marszruty zdarzenia.  
  
 W niektórych okolicznościach same formanty oznaczają określone kierowane zdarzenia jako obsługiwane. Obsługiwane kierowane zdarzenie reprezentuje decyzję autorów [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kontroli, że akcje formantu w odpowiedzi na kierowane zdarzenie są znaczące lub ukończone w ramach implementacji formantu, a zdarzenie nie wymaga dalszej obsługi. Zwykle odbywa się to przez dodanie programu obsługi klasy dla zdarzenia lub zastąpienie jednego z wirtualnych obsługi klasy, które istnieją w klasie podstawowej. W razie potrzeby nadal można obejść tę obsługę zdarzeń; zobacz [Obejście tłumienia zdarzeń przez formanty](#WorkingAroundEventSuppressionByControls) w dalszej części tego tematu.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Podgląd" (tunelowanie) Wydarzenia vs. Bubbling wydarzenia i obsługa zdarzeń  
 Podgląd kierowanych zdarzeń to zdarzenia, które podążają za trasą tunelowania przez drzewo elementów. "Podgląd" wyrażony w konwencji nazewnictwa wskazuje na ogólną zasadę dla zdarzeń wejściowych, które podgląd (tunelowanie) kierowane zdarzenia są wywoływane przed równoważne propagowanie kierowane zdarzenie. Ponadto dane wejściowe kierowane zdarzenia, które mają tunelowanie i propagacji pary mają różne logiki obsługi. Jeśli tunelowanie/podgląd kierowane zdarzenie jest oznaczony jako obsługiwane przez detektor zdarzeń, a następnie propagacji routowane zdarzenie zostanie oznaczony obsługiwane jeszcze przed detektorów propagacji routowane zdarzenie otrzyma go. Tunelowanie i propagowanie kierowane zdarzenia są technicznie oddzielne zdarzenia, ale celowo współużytkują to samo wystąpienie danych zdarzeń, aby włączyć to zachowanie.  
  
 Połączenie między tunelowania i propagacji kierowanych zdarzeń jest realizowany przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] wewnętrzną implementację jak danej klasy podnosi własne zadeklarowane routowane zdarzenia i dotyczy to sparowanych zdarzeń routowanych danych wejściowych. Ale jeśli nie istnieje ta implementacja na poziomie klasy, nie ma połączenia między zdarzeniem kierowanym tunelowania a zdarzeniem kierowanym propagacji, które współużytkuje schemat nazewnictwa: bez takiej implementacji byłyby to dwa całkowicie oddzielne zdarzenia routowane i nie byłyby wywoływane w sekwencji lub udostępnianie danych zdarzeń.  
  
 Aby uzyskać więcej informacji na temat implementacji par zdarzeń kierowanych do tunelu/bąbelka w klasie [niestandardowej, zobacz Tworzenie niestandardowego zdarzenia kierowanego](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a>Programy obsługi klas i programy obsługi wystąpień  
 Kierowane zdarzenia należy wziąć pod uwagę dwa różne typy odbiorników do zdarzenia: detektory klasy i detektory wystąpienia. Detektory klas istnieją, ponieważ <xref:System.Windows.EventManager> typy<xref:System.Windows.EventManager.RegisterClassHandler%2A>mają wywołane określonego interfejsu API , w ich konstruktora statycznego lub mają zastąpić metody wirtualnej obsługi klasy z klasy podstawowej elementu. Detektory wystąpień są określonymi wystąpieniami/elementami klasy, w których do tego zdarzenia <xref:System.Windows.UIElement.AddHandler%2A>dołączone zostały co najmniej jeden program obsługi przez wywołanie . Istniejące [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kierowane zdarzenia <xref:System.Windows.UIElement.AddHandler%2A> nawiązują wywołania jako część otoki zdarzeń{} środowiska{} wykonawczego języka wspólnego (CLR) dodaj [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] i usuń implementacje zdarzenia, czyli jak prosty mechanizm dołączania programów obsługi zdarzeń za pośrednictwem składni atrybutów jest włączona. W związku z [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] tym nawet proste <xref:System.Windows.UIElement.AddHandler%2A> użycie ostatecznie równa się wywołanie.  
  
 Elementy w drzewie wizualnym są sprawdzane dla zarejestrowanych implementacji programu obsługi. Programy obsługi są potencjalnie wywoływane w całej trasie, w kolejności, która jest nieodłącznie związana z typem strategii routingu dla tego zdarzenia routingu. Na przykład propagowanie kierowanych zdarzeń najpierw wywoła te programy obsługi, które są dołączone do tego samego elementu, który wywołał kierowane zdarzenie. Następnie kierowane zdarzenie "pęcherzyki" do następnego elementu nadrzędnego i tak dalej, aż do osiągnięcia elementu głównego aplikacji.  
  
 Z punktu widzenia elementu głównego w trasie propagacji, jeśli obsługa klasy lub dowolny element bliżej źródła kierowanego zdarzenia wywoływać programy obsługi, które oznaczają argumenty zdarzenia jako obsługiwane, a następnie programy obsługi elementów głównych nie są wywoływane, a trasa zdarzenia jest skutecznie skracane przed osiągnięciem tego elementu korzeniowego. Jednak trasa nie jest całkowicie zatrzymana, ponieważ programy obsługi można dodać przy użyciu specjalnego warunku, który nadal powinien być wywoływany, nawet jeśli program obsługi klasy lub program obsługi wystąpienia oznaczył kierowane zdarzenie jako obsługiwane. Jest to wyjaśnione w [dodawanie obsługi wystąpienia, które są wywoływane nawet wtedy, gdy zdarzenia są oznaczone obsługiwane,](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)w dalszej części tego tematu.  
  
 Na poziomie głębszym niż trasa zdarzenia istnieje również potencjalnie wiele programów obsługi klas działających na danym wystąpieniu klasy. Dzieje się tak, ponieważ model obsługi klas dla kierowanych zdarzeń umożliwia wszystkie możliwe klasy w hierarchii klas do każdego zarejestrowania własnego programu obsługi klas dla każdego kierowanego zdarzenia. Każdy program obsługi klasy jest dodawany do magazynu wewnętrznego, a gdy trasa zdarzenia dla aplikacji jest konstruowana, programy obsługi klas są dodawane do trasy zdarzenia. Programy obsługi klas są dodawane do trasy w taki sposób, że najczęściej pochodny program obsługi klas jest wywoływany jako pierwszy, a programy obsługi klas z każdej kolejnej klasy podstawowej są wywoływane dalej. Ogólnie rzecz biorąc programy obsługi klas nie są rejestrowane w taki sposób, że również odpowiadać na kierowane zdarzenia, które zostały już oznaczone obsługiwane. W związku z tym ten mechanizm obsługi klasy umożliwia jedną z dwóch opcji:  
  
- Klasy pochodne można uzupełnić obsługi klasy, który jest dziedziczony z klasy podstawowej, dodając program obsługi, który nie oznacza kierowane zdarzenie obsługiwane, ponieważ program obsługi klasy podstawowej będą wywoływane jakiś czas po programie obsługi klasy pochodnej.  
  
- Klasy pochodne można zastąpić obsługi klasy z klasy podstawowej, dodając program obsługi klasy, który oznacza kierowane zdarzenie obsługiwane. Należy zachować ostrożność przy tym podejściu, ponieważ potencjalnie zmieni projekt formantu podstawowego w obszarach, takich jak wygląd, logika stanu, obsługa danych wejściowych i obsługa poleceń.  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Obsługa klas kierowanych zdarzeń według klas podstawowych kontroli  
 Na każdym węźle danego elementu w marszruty zdarzenia detektory klas mają możliwość reagowania na kierowane zdarzenie, zanim dowolny detektor wystąpienia w elemencie może. Z tego powodu programy obsługi klas są czasami używane do pomijania kierowanych zdarzeń, które implementacja określonej klasy kontroli nie chce propagować dalej lub zapewnić specjalną obsługę tego kierowanego zdarzenia, które jest cechą klasy. Na przykład klasa może podnieść własne zdarzenie specyficzne dla klasy, który zawiera więcej szczegółów na temat tego, co oznacza niektóre warunki wprowadzania danych użytkownika w kontekście tej określonej klasy. Implementacja klasy może następnie oznaczyć bardziej ogólne kierowane zdarzenie jako obsługiwane. Programy obsługi klas są zazwyczaj dodawane w taki sposób, że nie są wywoływane dla kierowanych zdarzeń, w <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> których udostępnione dane zdarzeń zostały już oznaczone jako obsługiwane, ale w przypadku nietypowych przypadków istnieje również podpis, który rejestruje programy obsługi klas do wywoływania nawet wtedy, gdy kierowane zdarzenia są oznaczone jako obsługiwane.  
  
### <a name="class-handler-virtuals"></a>Wirtualne obsługi klas  
 Niektóre elementy, w szczególności podstawowe <xref:System.Windows.UIElement>elementy, takie jak , uwidaczniają puste metody wirtualne "On*Event" i "OnPreview\*Event", które odpowiadają ich liście zdarzeń kierowanych publicznie. Te metody wirtualne można zastąpić, aby zaimplementować program obsługi klasy dla tego kierowanego zdarzenia. Klasy elementów podstawowych zarejestrować te metody wirtualne jako <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> ich obsługi klasy dla każdego takiego zdarzenia kierowane przy użyciu jak opisano wcześniej. On\*Event metody wirtualne znacznie prostsze do zaimplementowania obsługi klasy dla odpowiednich zdarzeń routowanych, bez konieczności specjalnego inicjowania w konstruktorów statycznych dla każdego typu. Na przykład można dodać obsługi <xref:System.Windows.UIElement.DragEnter> klasy dla <xref:System.Windows.UIElement> zdarzenia w dowolnej klasie <xref:System.Windows.UIElement.OnDragEnter%2A> pochodnej przez zastąpienie metody wirtualnej. W ramach zastąpienia można obsługiwać kierowane zdarzenie, podnieść inne zdarzenia, zainicjować logikę specyficzne dla klasy, która może zmienić właściwości elementu w wystąpieniach lub dowolną kombinację tych akcji. Zazwyczaj należy wywołać implementacji podstawowej w takich zastąpieniach, nawet jeśli oznaczysz zdarzenie obsługiwane. Wywołanie implementacji podstawowej jest zdecydowanie zalecane, ponieważ metoda wirtualna znajduje się w klasie podstawowej. Standardowy chroniony wzorzec wirtualny wywoływania podstawowych implementacji z każdej wirtualnej zasadniczo zastępuje i równoledzi podobny mechanizm, który jest natywny dla obsługi klas zdarzeń kierowanych, przy czym programy obsługi klas dla wszystkich klas w hierarchii klas są wywoływana w danym wystąpieniu, począwszy od programu obsługi klasy najbardziej pochodnej i kontynuując do obsługi klasy podstawowej. Należy pominąć wywołania implementacji podstawowej tylko wtedy, gdy klasa ma zamierzone wymaganie, aby zmienić logikę obsługi klasy podstawowej. Czy wywołać implementacji podstawowej przed lub po kod nadrzędny będzie zależeć od charakteru implementacji.  
  
#### <a name="input-event-class-handling"></a>Obsługa klasy zdarzeń wejściowych  
 Metody wirtualne obsługi klasy są rejestrowane w taki sposób, że są wywoływane tylko w przypadkach, gdy wszystkie udostępnione dane zdarzeń nie są już oznaczone. Ponadto dla zdarzeń wejściowych unikatowo tunelowanie i propagowanie wersje zazwyczaj są wywoływane w sekwencji i udostępnianie danych zdarzeń. Oznacza to, że dla danej pary programów obsługi klasy zdarzeń wejściowych, gdzie jeden jest wersja tunelowania, a drugi jest wersja propagacji, nie może chcesz oznaczyć zdarzenie obsługiwane natychmiast. Jeśli zaimplementujesz klasę tunelowania obsługi metody wirtualnej, aby oznaczyć zdarzenie obsługiwane, które uniemożliwi propagacji obsługi klasy propagacji z wywoływania (a także zapobieganie wszelkie normalnie zarejestrowanych programów obsługi wystąpienia dla tunelowania lub propagacji zdarzenia z przywoływanych).  
  
 Po zakończeniu obsługi klasy w węźle, detektory wystąpienia są brane pod uwagę.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Dodawanie programów obsługi wystąpienia, które są wywoływane nawet wtedy, gdy zdarzenia są oznaczone jako obsługiwane  
 Metoda <xref:System.Windows.UIElement.AddHandler%2A> dostarcza określonego przeciążenia, które umożliwia dodawanie programów obsługi, które będą wywoływane przez system zdarzeń, gdy zdarzenie osiągnie element obsługi w marszruty, nawet jeśli inny program obsługi już dostosować dane zdarzenia, aby oznaczyć to zdarzenie jako obsługiwane. Zazwyczaj nie jest to wykonywane. Ogólnie programy obsługi mogą być zapisywane, aby dostosować wszystkie obszary kodu aplikacji, które mogą być pod wpływem zdarzenia, niezależnie od tego, gdzie został obsłużona w drzewie elementów, nawet jeśli pożądane są wyniki wielu końcowych. Ponadto zazwyczaj istnieje naprawdę tylko jeden element, który musi odpowiedzieć na to zdarzenie, a logika odpowiedniej aplikacji już się wydarzyła. Ale `handledEventsToo` przeciążenie jest dostępne dla wyjątkowych przypadkach, gdy niektóre inne elementy w drzewie elementów lub formowania formantu już oznaczone zdarzenie jako obsługiwane, ale inne elementy wyższe lub niższe w drzewie elementów (w zależności od trasy) nadal chcą mieć własne programy obsługi wywoływane.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Kiedy oznaczyć obsługiwane zdarzenia jako nieobsługiwały  
 Ogólnie rzecz biorąc, kierowane zdarzenia, które są oznaczone<xref:System.Windows.RoutedEventArgs.Handled%2A> obsługiwane nie `false`powinny być oznaczone nieobsługiwał (ustaw wstecz do) nawet przez programy obsługi, które działają na `handledEventsToo`. Jednak niektóre zdarzenia wejściowe mają reprezentacje zdarzeń wysokiego i niższego poziomu, które mogą nakładać się, gdy zdarzenie wysokiego poziomu jest widoczne w jednej pozycji w drzewie i zdarzenia niskiego poziomu w innej pozycji. Rozważmy na przykład przypadek, w którym element podrzędny nasłuchuje zdarzenia klucza wysokiego poziomu, <xref:System.Windows.UIElement.TextInput> na <xref:System.Windows.UIElement.KeyDown>przykład podczas gdy element nadrzędny nasłuchuje zdarzenia niskiego poziomu, takiego jak . Jeśli element nadrzędny obsługuje zdarzenia niskiego poziomu, zdarzenie wyższego poziomu można pominąć nawet w elemencie podrzędnym, który intuicyjnie powinien mieć pierwszą okazję do obsługi zdarzenia.  
  
 W takich sytuacjach może być konieczne dodanie programów obsługi do elementów nadrzędnych i elementów podrzędnych dla zdarzenia niskiego poziomu. Implementacja obsługi elementu podrzędnego można oznaczyć zdarzenia niskiego poziomu jako obsługiwane, ale implementacji obsługi elementu nadrzędnego ustawi go nieobsługiwać ponownie tak, aby dalsze elementy w górę drzewa (jak również zdarzenia wysokiego poziomu) może mieć możliwość odpowiedzi. Sytuacja ta powinna być dość rzadka.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Celowe pomijanie zdarzeń wejściowych dla komponowania sterowania  
 Głównym scenariuszem, w którym jest używana obsługa klas kierowanych zdarzeń, jest zdarzenia wejściowe i formantów złożonych. Formant złożony składa się z wielu praktycznych formantów lub klas podstawowych kontroli. Często autor formantu chce zebrać wszystkie możliwe zdarzenia wejściowe, które każdy z podskładników może podnieść, aby zgłosić cały formant jako źródło pojedynczego zdarzenia. W niektórych przypadkach autor formantu może chcieć całkowicie pominąć zdarzenia ze składników lub zastąpić zdarzenie zdefiniowane przez składnik, które zawiera więcej informacji lub implikuje bardziej szczegółowe zachowanie. Przykład kanoniczny, który jest natychmiast widoczny dla [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> dowolnego autora składnika, to sposób obsługi dowolnego zdarzenia myszy, które ostatecznie rozwiąże intuicyjne zdarzenie, które mają wszystkie przyciski: <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenie.  
  
 Klasa <xref:System.Windows.Controls.Button> podstawowa<xref:System.Windows.Controls.Primitives.ButtonBase>( ) <xref:System.Windows.Controls.Control> wywodzi <xref:System.Windows.FrameworkElement> się <xref:System.Windows.UIElement>z którego z kolei pochodzi z i , <xref:System.Windows.UIElement> a większość infrastruktury zdarzeń potrzebnych do przetwarzania danych wejściowych kontroli jest dostępna na poziomie. W szczególności <xref:System.Windows.UIElement> przetwarza <xref:System.Windows.Input.Mouse> zdarzenia ogólne, które obsługują testowanie trafień dla kursora myszy w jego granicach <xref:System.Windows.UIElement.MouseLeftButtonDown>i zapewnia różne zdarzenia dla najczęstszych akcji przycisku, takich jak . <xref:System.Windows.UIElement>zapewnia również pusty <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> wirtualny jako wstępnie zarejestrowanego programu obsługi klasy dla <xref:System.Windows.UIElement.MouseLeftButtonDown>programu , i <xref:System.Windows.Controls.Primitives.ButtonBase> zastępuje go. Podobnie <xref:System.Windows.Controls.Primitives.ButtonBase> używa programów obsługi <xref:System.Windows.UIElement.MouseLeftButtonUp>klas dla . W zastąpieniach, które są przekazywane dane zdarzeń, implementacje <xref:System.Windows.RoutedEventArgs> oznaczyć <xref:System.Windows.RoutedEventArgs.Handled%2A> `true`to wystąpienie jako obsługiwane przez ustawienie , i te same dane zdarzenia jest to, co jest kontynuowane wzdłuż pozostałej części trasy do innych programów obsługi klasy, a także do obsługi wystąpień lub ustawiaczy zdarzeń. Ponadto <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> zastąpienie spowoduje następne podniesienie <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia. Efektem końcowym dla większości słuchaczy <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> będzie to, że i wydarzenia <xref:System.Windows.Controls.Primitives.ButtonBase.Click>"znikają" i są zastępowane przez , zdarzenie, które ma więcej znaczenia, ponieważ wiadomo, że to zdarzenie pochodzi z prawdziwego przycisku, a nie jakiś złożony kawałek przycisku lub z innego elementu całkowicie.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a>Praca wokół tłumienia zdarzeń przez formanty  
 Czasami to zachowanie tłumienia zdarzeń w poszczególnych formantów może kolidować z niektórych bardziej ogólnych intencji logiki obsługi zdarzeń dla aplikacji. Na przykład jeśli z jakiegoś powodu aplikacja <xref:System.Windows.UIElement.MouseLeftButtonDown> miała program obsługi dla znajduje się w elemencie głównym <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> aplikacji, można zauważyć, że każde kliknięcie myszą na przycisk nie wywołać lub obsługi na poziomie głównym. Samo zdarzenie rzeczywiście nie bańki w górę (ponownie, trasy zdarzeń nie są naprawdę zakończone, ale kierowane system zdarzeń zmienia ich zachowanie wywołania obsługi po oznaczeniu obsługiwane). Gdy kierowane zdarzenie dotarło <xref:System.Windows.Controls.Primitives.ButtonBase> do przycisku, obsługa klasy oznaczone <xref:System.Windows.UIElement.MouseLeftButtonDown> obsługiwane, ponieważ chciał zastąpić <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenie z więcej znaczenia. W związku z <xref:System.Windows.UIElement.MouseLeftButtonDown> tym wszelkie standardowe obsługi dalej trasy nie będzie wywoływana. Istnieją dwie techniki, których można użyć, aby upewnić się, że programy obsługi będą wywoływane w tej sytuacji.  
  
 Pierwszą techniką jest celowe dodanie `handledEventsToo` programu <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>obsługi przy użyciu podpisu programu . Ograniczeniem tego podejścia jest to, że ta technika dołączania programu obsługi zdarzeń jest możliwe tylko z kodu, a nie z znaczników. Prosta składnia określania nazwy programu obsługi zdarzeń jako wartości [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] atrybutu zdarzenia za pośrednictwem nie włącza tego zachowania.  
  
 Druga technika działa tylko dla zdarzeń wejściowych, gdzie tunelowanie i propagowanie wersje kierowanego zdarzenia są sparowane. W przypadku tych kierowanych zdarzeń można dodać programy obsługi do równoważnego zdarzenia kierowanego w wersji zapoznawczej/tunelowania. To kierowane zdarzenie będzie tunelować przez trasę, zaczynając od katalogu głównego, więc kod obsługi klasy przycisku nie przechwytuje go, zakładając, że dołączony program obsługi podglądu na poziomie elementu nadrzędnego w drzewie elementów aplikacji. Jeśli używasz tego podejścia, należy zachować ostrożność podczas oznaczania dowolnego zdarzenia podglądu obsługiwane. W przykładzie <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> podano, że są obsługiwane w elemencie głównym, jeśli oznaczone zdarzenie, jak <xref:System.Windows.RoutedEventArgs.Handled%2A> w implementacji programu obsługi, faktycznie pominąć <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenie. Zazwyczaj nie jest to pożądane zachowanie.  
  
## <a name="see-also"></a>Zobacz też

- <xref:System.Windows.EventManager>
- [Podgląd zdarzeń](preview-events.md)
- [Tworzenie niestandardowego zdarzenia trasowanego](how-to-create-a-custom-routed-event.md)
- [Przegląd Zdarzenia trasowane](routed-events-overview.md)
