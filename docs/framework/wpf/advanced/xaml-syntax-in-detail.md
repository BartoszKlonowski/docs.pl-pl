---
title: Szczegóły składni XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: eabb9c84824a4604319a346612e84563abaf2b76
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/03/2018
ms.locfileid: "43485732"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="c14dd-102">Szczegóły składni XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="c14dd-103">W tym temacie opisano terminy, które są używane do opisywania elementy składni XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="c14dd-104">Te warunki są często stosowane w pozostałej części tej dokumentacji, zarówno dla dokumentacji WPF specjalnie i dla innych platform, które używają XAML lub włączane przez obsługę języka XAML na poziomie System.Xaml podstawowe pojęcia dotyczące XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="c14dd-105">W tym temacie omówiono w podstawowej terminologii opisanymi w temacie [Przegląd XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span></span>  
  

  
<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="c14dd-106">Specyfikacja języka XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="c14dd-107">Terminologia składni XAML, które są zdefiniowane w tym miejscu jest również zdefiniowana lub odwołania w specyfikacji języka XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="c14dd-108">XAML jest językiem oparte na języku XML i następuje lub rozszerza strukturalnych reguł XML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="c14dd-109">Niektóre terminologii został udostępniony z lub opiera się na terminologii często używane podczas opisywania język XML lub XML document object model.</span><span class="sxs-lookup"><span data-stu-id="c14dd-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="c14dd-110">Aby uzyskać więcej informacji na temat specyfikacji języka XAML, Pobierz [ \[MS-XAML\] ](https://go.microsoft.com/fwlink/?LinkId=114525) z Microsoft Download Center.</span><span class="sxs-lookup"><span data-stu-id="c14dd-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="c14dd-111">XAML i środowiska CLR</span><span class="sxs-lookup"><span data-stu-id="c14dd-111">XAML and CLR</span></span>  
 <span data-ttu-id="c14dd-112">XAML jest językiem znaczników.</span><span class="sxs-lookup"><span data-stu-id="c14dd-112">XAML is a markup language.</span></span> <span data-ttu-id="c14dd-113">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], Jak dorozumianych według jego nazwy, włącza środowisko uruchomieniowe wykonywania.</span><span class="sxs-lookup"><span data-stu-id="c14dd-113">The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="c14dd-114">XAML nie jest samodzielnie jednym z języków, które bezpośrednio jest używane przez środowisko uruchomieniowe CLR.</span><span class="sxs-lookup"><span data-stu-id="c14dd-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="c14dd-115">Zamiast tego można traktować XAML jako obsługujące swój własny system typów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="c14dd-116">Określony system analizy XAML, który jest używany przez WPF jest oparta na CLR i system typów CLR.</span><span class="sxs-lookup"><span data-stu-id="c14dd-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="c14dd-117">Typy XAML są mapowane na typy CLR do utworzenia wystąpienia reprezentację w czasie wykonywania, gdy zostanie przeanalizowany XAML dla programu WPF.</span><span class="sxs-lookup"><span data-stu-id="c14dd-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="c14dd-118">Z tego powodu w pozostałej części dyskusję na temat składni, w tym dokumencie będzie zawierać odwołania do typu CLR systemu, nawet, jeśli nie obsługują dyskusje równoważny składni w specyfikacji języka XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="c14dd-119">(Na poziomie specyfikacji języka XAML, typy XAML mógłby być mapowany na innym systemie typu, który nie ma być środowiska CLR, ale wymagałoby stworzeniem i używaniem inny analizator XAML).</span><span class="sxs-lookup"><span data-stu-id="c14dd-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="c14dd-120">Członkowie typów i dziedziczenia klas</span><span class="sxs-lookup"><span data-stu-id="c14dd-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="c14dd-121">Właściwości i zdarzenia jako są wyświetlane jako elementy członkowskie XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] typu często są dziedziczone z typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="c14dd-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="c14dd-122">Rozważmy na przykład w tym przykładzie: `<Button Background="Blue" .../>`.</span><span class="sxs-lookup"><span data-stu-id="c14dd-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="c14dd-123"><xref:System.Windows.Controls.Control.Background%2A> Właściwość nie jest właściwością natychmiast zadeklarowane na <xref:System.Windows.Controls.Button> klasy, gdyby Spójrz na definicji klasy, wyniki odbicia lub dokumentacji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="c14dd-124">Zamiast tego <xref:System.Windows.Controls.Control.Background%2A> jest dziedziczony z podstawy <xref:System.Windows.Controls.Control> klasy.</span><span class="sxs-lookup"><span data-stu-id="c14dd-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="c14dd-125">Zachowanie dziedziczenia klasy [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elementów XAML jest znaczący opuszczenia wymuszane schematu interpretacji znaczników XML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="c14dd-126">Dziedziczenie klas może stać się skomplikowane, szczególnie w przypadku, gdy pośredni klasy bazowe są klasami abstrakcyjnymi lub interfejsy.</span><span class="sxs-lookup"><span data-stu-id="c14dd-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="c14dd-127">To jest jedną z przyczyn zbiór elementów XAML i ich atrybutów dopuszczalne jest trudne do reprezentowania dokładnie i całkowicie przy użyciu typów schematu są zwykle używane do [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programowania, takie jak format DTD lub XSD.</span><span class="sxs-lookup"><span data-stu-id="c14dd-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format.</span></span> <span data-ttu-id="c14dd-128">Kolejny powód jest tym rozszerzalności i mapowania typów funkcji języka XAML, sama wyklucza kompletności wszystkie stałych reprezentację dopuszczalna typów i elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="c14dd-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="c14dd-129">Składnia elementu obiektu</span><span class="sxs-lookup"><span data-stu-id="c14dd-129">Object Element Syntax</span></span>  
 <span data-ttu-id="c14dd-130">*Składnia elementu obiektu* jest składnia znaczników XAML, która tworzy wystąpienie klasy CLR lub struktury przez zadeklarowanie — element XML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="c14dd-131">Ta składnia przypomina składnię innych języków znaczników, takich jak HTML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="c14dd-132">Składnia elementu obiektu, który rozpoczyna się od lewego nawiasu ostrego (\<), a następnie natychmiast Nazwa typu klasy lub struktury, które są tworzone.</span><span class="sxs-lookup"><span data-stu-id="c14dd-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="c14dd-133">Zero lub więcej spacji po nazwie typu i zero lub więcej atrybutów może również być zadeklarowany w elemencie obiektu z jedną lub więcej spacji, oddzielając nazwy atrybutu = para "value".</span><span class="sxs-lookup"><span data-stu-id="c14dd-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="c14dd-134">Na koniec jedną z następujących muszą być spełnione:</span><span class="sxs-lookup"><span data-stu-id="c14dd-134">Finally, one of the following must be true:</span></span>  
  
-   <span data-ttu-id="c14dd-135">Element i tagów muszą być zamknięte przez ukośnikiem (/) od razu następuje prawego nawiasu ostrego (>).</span><span class="sxs-lookup"><span data-stu-id="c14dd-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
-   <span data-ttu-id="c14dd-136">Otwierający tag, należy wykonać prawego nawiasu ostrego (>).</span><span class="sxs-lookup"><span data-stu-id="c14dd-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="c14dd-137">Inne elementy obiektu, elementy właściwości lub tekst wewnętrzny wykonać otwierający tag.</span><span class="sxs-lookup"><span data-stu-id="c14dd-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="c14dd-138">Dokładnie zawartość może być zawarte w tym miejscu jest zwykle ograniczony przez model obiektów elementu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="c14dd-139">Odpowiednik tagu zamykającego elementu obiektu należy również objęte zagnieżdżanie właściwe i równoważyć z innych par tagu otwierającym i zamykającym.</span><span class="sxs-lookup"><span data-stu-id="c14dd-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="c14dd-140">XAML jako implementowany przez .NET zawiera zestaw reguł, które elementy obiektu mapy na typy i atrybuty do właściwości lub zdarzenia i XAML przestrzeni nazw z przestrzeni nazw CLR, a także zestaw.</span><span class="sxs-lookup"><span data-stu-id="c14dd-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="c14dd-141">Dla platformy WPF i .NET Framework XAML elementów obiektu mapowania [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] zestawów występujących w odwołaniu typów zgodnie z definicją w i atrybutów mapowania członków z tych typów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-141">For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="c14dd-142">Gdy odwołujesz się do typu CLR w XAML, masz dostęp do dziedziczone składowe tego typu, jak również.</span><span class="sxs-lookup"><span data-stu-id="c14dd-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="c14dd-143">Na przykład, poniższy przykład jest składnia elementu obiektu, który tworzy nowe wystąpienie klasy <xref:System.Windows.Controls.Button> klasy, a także określa <xref:System.Windows.FrameworkElement.Name%2A> atrybut i wartości dla tego atrybutu:</span><span class="sxs-lookup"><span data-stu-id="c14dd-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="c14dd-144">Poniższy przykład jest składnia elementu obiektu, który również uwzględnia Składnia właściwości zawartości XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="c14dd-145">Tekst wewnętrzny zawartych w będzie służyć do ustawiania <xref:System.Windows.Controls.TextBox> właściwość zawartości XAML, <xref:System.Windows.Controls.TextBox.Text%2A>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="c14dd-146">Modele zawartości</span><span class="sxs-lookup"><span data-stu-id="c14dd-146">Content Models</span></span>  
 <span data-ttu-id="c14dd-147">Klasa może obsługiwać użycia jako element obiektu XAML w kontekście składni, ale ten element będzie działać tylko prawidłowo w aplikacji lub strony, gdy znajduje się w oczekiwanej pozycji drzewo ogólnej zawartości modelu lub elementu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="c14dd-148">Na przykład <xref:System.Windows.Controls.MenuItem> zwykle tylko będzie umieszczona jako element podrzędny elementu <xref:System.Windows.Controls.Primitives.MenuBase> klasy pochodnej, takich jak <xref:System.Windows.Controls.Menu>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="c14dd-149">Zawartość, modele dla określonych elementów są udokumentowane w ramach uwagi na stronach klasy dla kontrolek i innych [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] klas, które mogą być używane jako elementów XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="c14dd-150">Właściwości elementów obiektu</span><span class="sxs-lookup"><span data-stu-id="c14dd-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="c14dd-151">Właściwości w XAML są ustawiane przez różne możliwe składni.</span><span class="sxs-lookup"><span data-stu-id="c14dd-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="c14dd-152">Składnia, która może służyć do określonej właściwości różnią się na podstawie podstawowej charakterystyki systemu typu właściwości, czy ustawienie.</span><span class="sxs-lookup"><span data-stu-id="c14dd-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="c14dd-153">Przez ustawienie wartości właściwości, Dodaj funkcje lub właściwości do obiektów występujących na grafie obiektu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="c14dd-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="c14dd-154">Początkowy stan utworzony obiekt z elementu obiektu opiera się na domyślne zachowanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c14dd-154">The initial state of the created object from a object element is based on the default constructor behavior.</span></span> <span data-ttu-id="c14dd-155">Zazwyczaj aplikacja użyje się coś innego niż wystąpienie domyślne całkowicie dowolnego danego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="c14dd-156">Składnia atrybutów (właściwości)</span><span class="sxs-lookup"><span data-stu-id="c14dd-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="c14dd-157">Składnią atrybutu jest składnia znaczników XAML, która ustawia wartości dla właściwości od zadeklarowania atrybutu dla istniejącego elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="c14dd-158">Nazwa atrybutu musi odpowiadać nazwie elementu członkowskiego CLR właściwości klasy, która będzie tworzyć kopię elementu odpowiedniego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="c14dd-159">Nazwa atrybutu następuje operatora przypisania (=).</span><span class="sxs-lookup"><span data-stu-id="c14dd-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="c14dd-160">Wartość atrybutu musi być ciąg ujęty w cudzysłów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c14dd-161">Przemienne cudzysłowów służy do umieszczenia na literalny znak cudzysłowu w ciągu atrybutu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="c14dd-162">Na przykład można użyć apostrofy jako środek do deklarowania ciąg, który zawiera znaku podwójnego cudzysłowu, znajdujący się w nim.</span><span class="sxs-lookup"><span data-stu-id="c14dd-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="c14dd-163">Czy korzystasz z pojedynczym lub podwójnym cudzysłowie, należy użyć pasującą parę dla otwierające i zamykające ciągu wartości atrybutu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="c14dd-164">Istnieją również sekwencje ucieczki lub innych technik dotyczące obejścia ograniczeń dla znaków nałożonych przez dowolnego określonego składnia XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="c14dd-165">Zobacz [jednostki znaków XML i XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-165">See [XML Character Entities and XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md).</span></span>  
  
 <span data-ttu-id="c14dd-166">Aby można było, można skonfigurować za pomocą składni atrybutów, właściwości muszą być publiczne i musi być zapisywalny.</span><span class="sxs-lookup"><span data-stu-id="c14dd-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="c14dd-167">Wartość właściwości w systemie typów zapasowy musi być typem wartości lub musi być typu odwołania, które mogą być tworzone lub przywoływany przez procesor XAML podczas uzyskiwania dostępu do odpowiedniego kopii typu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="c14dd-168">Dla WPF XAML zdarzeń zdarzenia, które jest przywoływane jako nazwa atrybutu musi być publiczne i mieć Delegat publiczny.</span><span class="sxs-lookup"><span data-stu-id="c14dd-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="c14dd-169">Właściwość lub zdarzenie musi należeć do klasy lub struktury, który zostanie uruchomiony przez element zawierający obiekt.</span><span class="sxs-lookup"><span data-stu-id="c14dd-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="c14dd-170">Przetwarzanie wartości atrybutów</span><span class="sxs-lookup"><span data-stu-id="c14dd-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="c14dd-171">Wartość ciągu, zawartych w otwierające i zamykające znaki cudzysłowu są przetwarzane przez procesor XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="c14dd-172">W przypadku właściwości domyślnego zachowania przetwarzania zależy od typu podstawowego właściwości CLR.</span><span class="sxs-lookup"><span data-stu-id="c14dd-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="c14dd-173">Wartość atrybutu jest wypełniana przez jedną z następujących czynności, za pomocą tego kolejność przetwarzania:</span><span class="sxs-lookup"><span data-stu-id="c14dd-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1.  <span data-ttu-id="c14dd-174">Jeśli procesor XAML napotka nawiasu klamrowego lub element obiektu, który pochodzi od klasy <xref:System.Windows.Markup.MarkupExtension>, następnie rozszerzenie znaczników odwołania jest stosowana jako pierwsza zamiast przetwarzania wartość jako ciąg i Obiekt zwrócony przez rozszerzenie znaczników jest używany jako wartość.</span><span class="sxs-lookup"><span data-stu-id="c14dd-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="c14dd-175">W wielu przypadkach obiektu zwróconego przez rozszerzenie znaczników będzie odwołanie do istniejącego obiektu lub wyrażenie, który odracza oceny do czasu wykonywania, a nie jest obiektem nowo utworzona.</span><span class="sxs-lookup"><span data-stu-id="c14dd-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2.  <span data-ttu-id="c14dd-176">Jeśli właściwość jest zadeklarowana za pomocą opartego na atrybutach <xref:System.ComponentModel.TypeConverter>, lub typ wartości tej właściwości jest zadeklarowany z atrybutami <xref:System.ComponentModel.TypeConverter>, wartość ciągu atrybutu jest przesyłany do usługi konwertera typów wejście konwersji i zwróci konwerter nowe wystąpienie obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3.  <span data-ttu-id="c14dd-177">Jeśli ma nie <xref:System.ComponentModel.TypeConverter>, podejmowana jest próba to bezpośrednia konwersji na typ właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="c14dd-178">Ten poziom ostatecznego jest to bezpośrednia konwersji wartość native analizatora między typów pierwotnych języka XAML lub wyboru dla nazw nazwanych stałych wyliczenia (analizator następnie uzyskuje dostęp do dopasowania wartości).</span><span class="sxs-lookup"><span data-stu-id="c14dd-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="c14dd-179">Wyliczanie wartości atrybutów</span><span class="sxs-lookup"><span data-stu-id="c14dd-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="c14dd-180">Wyliczenia w XAML są przetwarzane wewnętrznie przez analizatory składni XAML i elementy członkowskie wyliczenia powinien być określony przez określenie nazwy ciągu jednego nazwanych stałych wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="c14dd-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="c14dd-181">W przypadku wartości wyliczenia nonflag natywnych zachowaniem jest przetwarzania ciągu wartości atrybutu, a następnie Rozwiąż ją do jednej z wartości wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="c14dd-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="c14dd-182">Nie określaj wyliczenia w formacie *wyliczenie*. *Wartość*, tak jak w kodzie.</span><span class="sxs-lookup"><span data-stu-id="c14dd-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="c14dd-183">Zamiast tego można określić tylko *wartość*, i *wyliczenie* jest wnioskowany przez typ właściwości to ustawienie.</span><span class="sxs-lookup"><span data-stu-id="c14dd-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="c14dd-184">Jeśli określisz atrybut w *wyliczenie*. *Wartość* formularza, go nie działają prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="c14dd-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="c14dd-185">Dla wyliczenia flagwise zachowanie zależy od <xref:System.Enum.Parse%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="c14dd-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c14dd-186">Można określić wiele wartości wyliczenia flagwise, Oddziel poszczególne wartości przecinkami.</span><span class="sxs-lookup"><span data-stu-id="c14dd-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="c14dd-187">Jednak nie można połączyć wartości wyliczenia, które nie są flagwise.</span><span class="sxs-lookup"><span data-stu-id="c14dd-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="c14dd-188">Na przykład nie można użyć składni przecinkami próbuje utworzyć <xref:System.Windows.Trigger> działającego na wielu warunków wyliczenie nonflag:</span><span class="sxs-lookup"><span data-stu-id="c14dd-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="c14dd-189">Flagwise wyliczenia, obsługujące atrybuty, które są do ustawienia w XAML są rzadkie na platformie WPF.</span><span class="sxs-lookup"><span data-stu-id="c14dd-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="c14dd-190">Jednak jest jeden taki wyliczenie <xref:System.Windows.Media.StyleSimulations>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="c14dd-191">Można na przykład użyj składni rozdzielonych przecinkami flagwise atrybutu do modyfikowania podany w uwagi, na przykład <xref:System.Windows.Documents.Glyphs> klasy; `StyleSimulations = "BoldSimulation"` może stać się `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span><span class="sxs-lookup"><span data-stu-id="c14dd-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="c14dd-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> jest inna właściwość, w którym można określić więcej niż jedną wartość wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="c14dd-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="c14dd-193">Jednak ta właściwość ma miejsce w szczególnych przypadkach, ponieważ <xref:System.Windows.Input.ModifierKeys> wyliczenie obsługuje swój własny konwertera typów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="c14dd-194">Konwerter typu dla Modyfikatory używa znak plus (+) jako ogranicznika, a nie przecinka (,).</span><span class="sxs-lookup"><span data-stu-id="c14dd-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="c14dd-195">Ta konwersja obsługuje bardziej tradycyjny składni do reprezentowania kombinacje klawiszy w programowaniu Windows firmy Microsoft, takich jak "Ctrl + Alt".</span><span class="sxs-lookup"><span data-stu-id="c14dd-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="c14dd-196">Właściwości i zdarzenia odwołania do nazwy elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="c14dd-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="c14dd-197">Podczas określania atrybutów, można odwoływać się wszystkie właściwości lub zdarzenia, który istnieje jako element członkowski typu CLR, który skonkretyzowany zawierającego element obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="c14dd-198">Ewentualnie można odwoływać się do dołączoną właściwość lub dołączone zdarzenie, niezależnie od elementu obiektu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="c14dd-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="c14dd-199">(Dołączone właściwości zostały omówione w następnej sekcji).</span><span class="sxs-lookup"><span data-stu-id="c14dd-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="c14dd-200">Możesz też nazwać dowolne zdarzenie, z dowolnego obiektu, który jest dostępny za pośrednictwem domyślnej przestrzeni nazw za pomocą *typeName*. *Zdarzenie* częściowo kwalifikowane nazwy; ta składnia obsługuje dołączanie programy obsługi zdarzeń trasowanych gdzie program obsługi jest przeznaczona do obsługi zdarzenia, routing z elementów podrzędnych, ale element nadrzędny nie również ma tego zdarzenia w swojej tabeli elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="c14dd-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="c14dd-201">Ta składnia przypomina składnię dołączone zdarzenie, ale zdarzeń w tym miejscu nie jest spełniony, dołączone zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="c14dd-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="c14dd-202">Zamiast tego odwołuje się zdarzenie o kwalifikowanej nazwie.</span><span class="sxs-lookup"><span data-stu-id="c14dd-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="c14dd-203">Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń kierowane](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-203">For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="c14dd-204">W niektórych scenariuszach nazwy właściwości czasami są dostarczane jako wartość atrybutu, a nie nazwa atrybutu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="c14dd-205">Nazwa tej właściwości może również obejmować kwalifikatorów, takich jak właściwości określone w formie *ownerType*. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="c14dd-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="c14dd-206">Ten scenariusz jest typowy podczas zapisywania style lub szablony w XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="c14dd-207">Przetwarzanie reguł dla nazw właściwości podana jako wartość atrybutu różnią się i są zarządzane przez typ właściwości ustawiany lub zachowania określonego podsystemu WPF.</span><span class="sxs-lookup"><span data-stu-id="c14dd-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="c14dd-208">Aby uzyskać więcej informacji, zobacz [Tworzenie szablonów i stylów](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-208">For details, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="c14dd-209">Użycie innej nazwy właściwości jest, gdy wartość atrybutu w tym artykule opisano relację właściwość właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="c14dd-210">Ta funkcja jest używana do wiązania danych i dla celów scenorysu i został włączony przez <xref:System.Windows.PropertyPath> klasa i jej konwertera typów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="c14dd-211">Aby uzyskać bardziej szczegółowy opis semantyka wyszukiwania, zobacz [PropertyPath, składnia XAML](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="c14dd-212">Składnia elementu właściwości</span><span class="sxs-lookup"><span data-stu-id="c14dd-212">Property Element Syntax</span></span>  
 <span data-ttu-id="c14dd-213">*Składnia elementu właściwości* używa składni, która diverges nieco od podstawowych reguł dotyczących składni XML dla elementów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="c14dd-214">W pliku XML wartość atrybutu jest ciągiem de facto, za pomocą jedyną możliwą odmiany trwa jaki format kodowania ciąg jest używany.</span><span class="sxs-lookup"><span data-stu-id="c14dd-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="c14dd-215">W XAML można przypisać inne elementy obiektu jako wartość właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="c14dd-216">Ta funkcja jest włączona, składnia elementu właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="c14dd-217">Zamiast właściwości określany jako atrybut w tagu elementu, właściwość jest określony, przy użyciu elementu otwierający tag w *elementTypeName*. *propertyName* formularza, wartość właściwości jest określona w ramach, a następnie zamknięto element właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="c14dd-218">W szczególności składnia zaczyna się od lewego nawiasu ostrego (\<), a następnie natychmiast Nazwa typu klasy lub struktury, zawarty w składni elementu właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="c14dd-219">To następuje natychmiast przez pojedynczą kropką (.), następnie według nazwy właściwości, następnie prawego nawiasu ostrego (>).</span><span class="sxs-lookup"><span data-stu-id="c14dd-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="c14dd-220">Podobnie jak w przypadku składni atrybutów, ta właściwość musi istnieć w ramach zadeklarowany publiczne elementy członkowskie określonego typu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="c14dd-221">Wartość do przypisania do właściwości jest zawarty w elemencie właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="c14dd-222">Zazwyczaj wartość otrzymuje jedno lub więcej elementów obiektu, ponieważ określenie obiektów jako wartości jest scenariusz tej składni elementu właściwości jest przeznaczona do adresu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="c14dd-223">Na koniec tag zamykający równoważne, które są takie same określanie *elementTypeName*. *propertyName* połączenie musi być podana w odpowiednich zagnieżdżanie i równowagi z innych tagów elementu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="c14dd-224">Na przykład poniżej przedstawiono składnię elementu właściwości <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwość <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="c14dd-225">Wartość w elemencie właściwości można również nadać jako tekst wewnętrzny, w przypadkach, gdy jest określony typ właściwości jest typu wartości pierwotnej, takich jak <xref:System.String>, lub wyliczeniem, której nazwa jest określona.</span><span class="sxs-lookup"><span data-stu-id="c14dd-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="c14dd-226">Te dwa sposoby użycia są dość rzadko, ponieważ każdy z tych przypadków można również użyć prostsze składni atrybutów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="c14dd-227">Jeden scenariusz do wypełniania elementu właściwości przy użyciu parametrów jest dla właściwości, które nie są właściwość zawartości XAML, ale nadal są używane do reprezentacji tekst interfejsu użytkownika, a poszczególne elementy odstępu, takie jak znaki wysuwu wiersza są wymagane do pojawiają się w tym tekście interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="c14dd-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="c14dd-228">Składnia atrybutu nie można zachować znaki wysuwu wiersza, ale można składni elementu właściwości, tak długo, jak znaczące zachowywanie białych jest aktywna (Aby uzyskać więcej informacji, zobacz [biały znak przetwarzanie w XAML](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md)).</span><span class="sxs-lookup"><span data-stu-id="c14dd-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md)).</span></span> <span data-ttu-id="c14dd-229">Inny scenariusz polega na tak, aby [x: Uid — dyrektywa](../../../../docs/framework/xaml-services/x-uid-directive.md) można zastosować do elementu właściwości i tym samym Oznacz wartości w, zgodnie z wartością, który powinien być zlokalizowany w WPF danych wyjściowych BAML lub innych technik.</span><span class="sxs-lookup"><span data-stu-id="c14dd-229">Another scenario is so that [x:Uid Directive](../../../../docs/framework/xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="c14dd-230">Element właściwości nie jest uwzględniona w drzewie logicznym WPF.</span><span class="sxs-lookup"><span data-stu-id="c14dd-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="c14dd-231">Element właściwości jest po prostu specjalna składnia do ustawiania właściwości i nie jest element, który ma wystąpień lub wspierającą obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="c14dd-232">(Aby uzyskać szczegółowe informacje dotyczące koncepcji drzewo logiczne, zobacz [drzewa w WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="c14dd-232">(For details on the logical tree concept, see [Trees in WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="c14dd-233">W przypadku których są obsługiwane zarówno atrybut, jak i właściwość składnia elementu właściwości dwóch składni ogólnie ma ten sam wynik, ale precyzyjnie, takie jak obsługa białych mogą się nieznacznie różnić składni.</span><span class="sxs-lookup"><span data-stu-id="c14dd-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="c14dd-234">Składnia kolekcji</span><span class="sxs-lookup"><span data-stu-id="c14dd-234">Collection Syntax</span></span>  
 <span data-ttu-id="c14dd-235">Specyfikacja XAML wymaga implementacji procesora XAML, aby zidentyfikować właściwości, których typ wartości jest kolekcją.</span><span class="sxs-lookup"><span data-stu-id="c14dd-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="c14dd-236">Ogólne implementacji procesora XAML na platformie .NET opiera się na kodzie zarządzanym i środowiska CLR i identyfikuje typy kolekcji za pomocą jednego z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="c14dd-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
-   <span data-ttu-id="c14dd-237">Typ implementuje <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="c14dd-238">Typ implementuje <xref:System.Collections.IDictionary>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
-   <span data-ttu-id="c14dd-239">Typ pochodzi z <xref:System.Array> (Aby uzyskać więcej informacji na temat tablic w XAML, zobacz [x: Array — rozszerzenie znaczników](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="c14dd-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="c14dd-240">Jeśli typ właściwości to kolekcja, następnie typu wywnioskowanego kolekcji nie musi być określona w znaczników jako elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="c14dd-241">Zamiast tego elementów, które mają stać się elementów w kolekcji są określane jako jeden lub więcej elementów podrzędnych elementu właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="c14dd-242">Każdego takiego elementu jest oceniany na obiekt podczas ładowania i dodawane do kolekcji, wywołując `Add` metody dorozumianych kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="c14dd-243">Na przykład <xref:System.Windows.Style.Triggers%2A> właściwość <xref:System.Windows.Style> przyjmuje typ kolekcji wyspecjalizowane <xref:System.Windows.TriggerCollection>, który implementuje <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="c14dd-244">Nie jest konieczne do utworzenia wystąpienia <xref:System.Windows.TriggerCollection> element obiektu w znaczniku.</span><span class="sxs-lookup"><span data-stu-id="c14dd-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="c14dd-245">Zamiast tego należy określić co najmniej jedną <xref:System.Windows.Trigger> elementów jako elementów w obrębie `Style.Triggers` elementu właściwości, gdzie <xref:System.Windows.Trigger> (lub klasę pochodną) jest typu oczekiwanego typu elementu dla silnie typizowanym i niejawne <xref:System.Windows.TriggerCollection>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="c14dd-246">Właściwość może być typem kolekcji i właściwość zawartości XAML dla tego typu i pochodne typy, która została omówiona w następnej sekcji tego tematu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="c14dd-247">Element niejawnej kolekcji tworzy członka w reprezentacji drzewo logiczne, nawet jeśli nie ma w znacznikach jako element.</span><span class="sxs-lookup"><span data-stu-id="c14dd-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="c14dd-248">Zazwyczaj konstruktora obiektu nadrzędnego typu wykonuje utworzyć wystąpienia dla kolekcji, która jest jednym z jej właściwości i początkowo pusta kolekcja staje się częścią drzewa obiektów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c14dd-249">Interfejsy ogólne listy i słownika (<xref:System.Collections.Generic.IList%601> i <xref:System.Collections.Generic.IDictionary%602>) nie są obsługiwane przez wykrywanie kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="c14dd-250">Można jednak użyć <xref:System.Collections.Generic.List%601> klasy jako klasę bazową, ponieważ implementuje <xref:System.Collections.IList> bezpośrednio lub <xref:System.Collections.Generic.Dictionary%602> jako klasa bazowa, ponieważ implementuje <xref:System.Collections.IDictionary> bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="c14dd-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="c14dd-251">Dla typów kolekcji na stronach dokumentacja platformy .NET tej składni, z pominięciem zamierzonego element obiektu dla kolekcji co pewien czas jest rejestrowany w sekcjach składnia XAML jako niejawne składni kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="c14dd-252">Z wyjątkiem element główny każdego elementu obiektu w pliku XAML, który jest zagnieżdżona jako element podrzędny innego elementu jest naprawdę element, który jest jedno lub oba z następujących przypadków: członkiem niejawnej kolekcji własności odpowiedniego elementu nadrzędnego , lub element, który określa wartość właściwości zawartości XAML dla elementu nadrzędnego (XAML zawartości, właściwości, które zostanie omówiona w następnej sekcji).</span><span class="sxs-lookup"><span data-stu-id="c14dd-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="c14dd-253">Innymi słowy relacja elementów nadrzędnych i elementy podrzędne na stronie znaczników jest naprawdę pojedynczego obiektu w katalogu głównym, a każdy element obiektu poniżej katalogu głównego jest pojedyncze wystąpienie, które udostępnia wartość właściwości elementu nadrzędnego, albo jeden z elementów w obrębie kolumna Zaznaczenie, który jest również wartość właściwości typu kolekcji nadrzędnej.</span><span class="sxs-lookup"><span data-stu-id="c14dd-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="c14dd-254">To pojęcie z jednym elementem głównym jest wspólny z danymi XML i jest często wzmocnione zachowanie interfejsów API, które załadować XAML, takich jak <xref:System.Windows.Markup.XamlReader.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="c14dd-255">Poniższy przykład jest składnia elementu obiektu dla kolekcji (<xref:System.Windows.Media.GradientStopCollection>) jawnie określony.</span><span class="sxs-lookup"><span data-stu-id="c14dd-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="c14dd-256">Należy pamiętać, że nie zawsze jest możliwe jawnie deklarować kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="c14dd-257">Na przykład, próba zadeklarować <xref:System.Windows.TriggerCollection> jawnie, w jak pokazano wcześniej <xref:System.Windows.Style.Triggers%2A> przykład może zakończyć się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="c14dd-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="c14dd-258">Jawnie deklarowanie kolekcji wymaga, że klasa kolekcji musi obsługiwać domyślnego konstruktora, a <xref:System.Windows.TriggerCollection> nie ma domyślnego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c14dd-258">Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="c14dd-259">Właściwości zawartości XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-259">XAML Content Properties</span></span>  
 <span data-ttu-id="c14dd-260">Składnia zawartości XAML jest składni, w którym włączono tylko w klasach, które określają <xref:System.Windows.Markup.ContentPropertyAttribute> jako części swojej deklaracji klasy.</span><span class="sxs-lookup"><span data-stu-id="c14dd-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="c14dd-261"><xref:System.Windows.Markup.ContentPropertyAttribute> Odwołuje się do nazwy właściwości, który jest właściwość zawartości dla tego typu elementu (w tym klas pochodnych).</span><span class="sxs-lookup"><span data-stu-id="c14dd-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="c14dd-262">Podczas przetwarzania przez procesor XAML, wszystkie elementy podrzędne lub tekst wewnętrzny, które znajdują się pomiędzy otwierającym, a zamykającym tagiem elementu obiektu zostanie przypisany jako wartość właściwości zawartości XAML dla tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="c14dd-263">Możesz określić właściwości jawne elementy zawartości właściwości, ale to użycie nie jest zwykle wyświetlany w sekcji składni XAML w dokumentacji platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="c14dd-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="c14dd-264">Jawne/verbose technika ma okazjonalne wartość dla jasności znaczników lub jako styl znaczników, ale zazwyczaj celem właściwość content usprawniające znaczników, tak aby elementy, które są związane z intuicyjnie jako nadrzędny podrzędny, które mogą być zagnieżdżane bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="c14dd-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="c14dd-265">Tagi element właściwości dla innych właściwości w elemencie nie są przypisane jako "treści" na ścisłym definicji języka XAML; one są przetwarzane wcześniej w kolejności przetwarzania analizatora XAML i nie są uwzględniane jako "zawartość".</span><span class="sxs-lookup"><span data-stu-id="c14dd-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="c14dd-266">Wartości właściwości zawartości XAML muszą być ciągłe</span><span class="sxs-lookup"><span data-stu-id="c14dd-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="c14dd-267">Wartość właściwości zawartości XAML podaje się całkowicie przed lub w całości po innych elementów właściwości w elemencie tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="c14dd-268">Ta zasada obowiązuje, czy wartość właściwości zawartości XAML jest określony jako ciągu lub jako co najmniej jeden obiekt.</span><span class="sxs-lookup"><span data-stu-id="c14dd-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="c14dd-269">Na przykład następujące znaczniki nie analizuje:</span><span class="sxs-lookup"><span data-stu-id="c14dd-269">For example, the following markup does not parse:</span></span>  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="c14dd-270">Jest to niedozwolone zasadniczo ponieważ gdy ta składnia wprowadzono jawne przy użyciu składni elementu właściwości dla właściwości zawartości, następnie właściwość zawartości będzie miał ustawienie dwa razy:</span><span class="sxs-lookup"><span data-stu-id="c14dd-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="c14dd-271">Przykład podobnie niedozwolone jest właściwość content jest kolekcją, elementy podrzędne są grupową właściwości elementów:</span><span class="sxs-lookup"><span data-stu-id="c14dd-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="c14dd-272">Właściwości zawartości i składnię kolekcji, w połączeniu</span><span class="sxs-lookup"><span data-stu-id="c14dd-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="c14dd-273">Aby zaakceptować więcej niż element pojedynczy obiekt jako zawartość, typ właściwości zawartości specjalnie należy typem kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="c14dd-274">Podobnie jak w składni elementu właściwości dla kolekcji typów, procesor XAML należy określić typy, które są typy kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="c14dd-275">Jeśli element ma właściwości zawartości XAML, typ właściwości zawartości XAML jest kolekcją, dorozumianych kolekcji nie muszą być określone w znacznikach jako elementu obiektu i właściwość zawartości XAML nie musi być określona jako el właściwości ement.</span><span class="sxs-lookup"><span data-stu-id="c14dd-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="c14dd-276">W związku z tym jawnego modelu zawartości w znaczniku teraz może mieć więcej niż jeden element podrzędny przypisany jako zawartość.</span><span class="sxs-lookup"><span data-stu-id="c14dd-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="c14dd-277">Poniżej przedstawiono składnię zawartości <xref:System.Windows.Controls.Panel> klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c14dd-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="c14dd-278">Wszystkie <xref:System.Windows.Controls.Panel> klasy pochodne ustanowić właściwości zawartości XAML można <xref:System.Windows.Controls.Panel.Children%2A>, która wymaga wartości typu <xref:System.Windows.Controls.UIElementCollection>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="c14dd-279">Należy pamiętać, że żaden element właściwości dla <xref:System.Windows.Controls.Panel.Children%2A> ani element dla <xref:System.Windows.Controls.UIElementCollection> jest wymagany w znaczniku.</span><span class="sxs-lookup"><span data-stu-id="c14dd-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="c14dd-280">Jest to funkcja projektowania XAML aby rekursywnie zawiera elementy, które definiują [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] są bardziej intuicyjne reprezentowana jako drzewo elementów zagnieżdżonych z relacjami element natychmiastowego nadrzędny podrzędny, bez interwencji tagów elementu właściwości lub Obiekty kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="c14dd-281">W rzeczywistości <xref:System.Windows.Controls.UIElementCollection> nie może być określona wyraźnie w znaczników jako elementu obiektu zgodnie z projektem.</span><span class="sxs-lookup"><span data-stu-id="c14dd-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="c14dd-282">Ponieważ jedynym przeznaczeniem jest jako niejawnej kolekcji <xref:System.Windows.Controls.UIElementCollection> nie ujawnia publicznego konstruktora domyślnego i dlatego nie można utworzyć wystąpienia jako elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="c14dd-283">Łączenie elementów właściwości i elementów obiektu w obiekcie z właściwością zawartości</span><span class="sxs-lookup"><span data-stu-id="c14dd-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="c14dd-284">Specyfikacja XAML deklaruje, że procesor XAML mogą zostać wymuszone, muszą być ciągłe elementów obiektu, które są używane do wypełnienia właściwość zawartości XAML w obrębie elementu obiektu, a nie mogą być mieszane.</span><span class="sxs-lookup"><span data-stu-id="c14dd-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="c14dd-285">To ograniczenie względem łączenie elementów właściwości i zawartość jest wymuszana przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] procesorów XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="c14dd-286">Możesz mieć element podrzędny obiektu jako pierwszego natychmiastowego kod znaczników w obrębie elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="c14dd-287">Następnie możesz wprowadzić elementów właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-287">Then you can introduce property elements.</span></span> <span data-ttu-id="c14dd-288">Lub można określić jeden lub więcej elementów właściwości zawartości, a następnie więcej elementów właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="c14dd-289">Jednak po prvek Vlastnosti poniżej zawartości, nie wolno wprowadzać żadnych dalszych zawartości, można dodać tylko elementy właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="c14dd-290">Ta zawartość / wymaganie kolejności element właściwości nie ma zastosowania do tekst wewnętrzny używany jako zawartości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="c14dd-291">Jednak nadal jest styl znaczników dobre zapewnienie tekst wewnętrzny ciągłego, ponieważ istotnych białych będzie trudne do wykrycia wizualnie w znaczniku, jeśli właściwość elementy są grupową tekst wewnętrzny.</span><span class="sxs-lookup"><span data-stu-id="c14dd-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="c14dd-292">Przestrzeń nazw XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-292">XAML Namespaces</span></span>  
 <span data-ttu-id="c14dd-293">Żaden z powyższych przykładach składni określona przestrzeń nazw XAML innej niż domyślna przestrzeń nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="c14dd-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="c14dd-294">W przypadku typowych [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji, wartość domyślna przestrzeń nazw XAML jest określony jako [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="c14dd-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="c14dd-295">Można określić XAML przestrzenie nazw, innym niż domyślna przestrzeń nazw XAML i nadal używać podobnej składni.</span><span class="sxs-lookup"><span data-stu-id="c14dd-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="c14dd-296">Jednak następnie wszędzie gdzie klasa nosi, który nie jest dostępny w ramach domyślnej przestrzeni nazw XAML, nazwa tej klasy musi być poprzedzona z prefiks przestrzeni nazw XAML jako mapowany do odpowiedniego przestrzeń nazw środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="c14dd-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="c14dd-297">Na przykład `<custom:Example/>` jest składnia elementu obiektu do utworzenia wystąpienia wystąpienie `Example` klasy, w którym przestrzeń nazw środowiska CLR zawierający klasy (i prawdopodobnie informacje zestawu zewnętrznego, które zawiera typy zapasowy) został poprzednio zamapowany na `custom` prefiks.</span><span class="sxs-lookup"><span data-stu-id="c14dd-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="c14dd-298">Aby uzyskać więcej informacji na temat przestrzeni nazw XAML, zobacz [przestrzeni nazw XAML i Namespace mapowania dla WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="c14dd-299">Rozszerzenia znaczników</span><span class="sxs-lookup"><span data-stu-id="c14dd-299">Markup Extensions</span></span>  
 <span data-ttu-id="c14dd-300">XAML definiuje programowania jednostka, która umożliwia znaku ucieczki z normalnym XAML procesora obsługi ciąg wartości atrybutów lub elementów obiektu i odracza przetwarzania do klasy zapasowy rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="c14dd-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="c14dd-301">Znak, który identyfikuje rozszerzenie znaczników w XAML procesor, gdy za pomocą składni atrybutów jest otwierający nawias klamrowy ({}), następuje dowolny znak inny niż zamykający nawias klamrowy (}).</span><span class="sxs-lookup"><span data-stu-id="c14dd-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="c14dd-302">Pierwszy ciąg po otwierającym nawiasie klamrowym musi odwoływać się klasę, która zapewnia zachowanie określonego rozszerzenia, w których odwołanie może pominąć podciąg "Rozszerzenia", jeśli podciąg jest częścią nazwy klasy wartość true.</span><span class="sxs-lookup"><span data-stu-id="c14dd-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="c14dd-303">Dzięki temu pojedyncza spacja może pojawić się, a następnie każdego następnego znaku jest używany jako dane wejściowe przez implementację rozszerzenia aż do napotkania zamykający nawias klamrowy.</span><span class="sxs-lookup"><span data-stu-id="c14dd-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="c14dd-304">Implementacja XAML .NET używa <xref:System.Windows.Markup.MarkupExtension> abstrakcyjna klasa jako podstawa dla rozszerzenia znaczników, obsługiwane przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] oraz innych platform lub technologii.</span><span class="sxs-lookup"><span data-stu-id="c14dd-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="c14dd-305">Rozszerzenia znaczników, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specjalnie implementuje często mają stanowić sposób odwoływać się do innych istniejących obiektów lub odroczone odwołuje się do obiektów, które będą oceniane w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="c14dd-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="c14dd-306">Na przykład proste powiązanie danych WPF odbywa się przez określenie `{Binding}` — rozszerzenie znaczników zamiast wartość, która normalnie zajęłoby określonej właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="c14dd-307">Włącz wiele rozszerzeń struktury znaczników WPF Składnia atrybutu dla właściwości, w którym składni atrybutów nie byłoby to możliwe.</span><span class="sxs-lookup"><span data-stu-id="c14dd-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="c14dd-308">Na przykład <xref:System.Windows.Style> obiekt jest dość złożone typu, który zawiera zagnieżdżony szeregu obiektów i właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="c14dd-309">Style na platformie WPF są zazwyczaj definiowane jako zasób w <xref:System.Windows.ResourceDictionary>i następnie odwoływać się za pomocą jednego z dwóch rozszerzenia znaczników WPF, wysyłających żądanie dotyczące zasobów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="c14dd-310">Rozszerzenie znaczników odracza obliczanie wartości właściwości do wyszukiwania zasobów i umożliwia zapewnienie wartość <xref:System.Windows.FrameworkElement.Style%2A> właściwość, biorąc typu <xref:System.Windows.Style>w atrybutu składni, jak w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="c14dd-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="c14dd-311">W tym miejscu `StaticResource` identyfikuje <xref:System.Windows.StaticResourceExtension> klasy dostarcza implementację rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="c14dd-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="c14dd-312">Ciąg dalej `MyStyle` jest używany jako dane wejściowe dla innych niż domyślne <xref:System.Windows.StaticResourceExtension> konstruktora, gdzie parametr pobrane z parametrów rozszerzenia deklaruje żądany <xref:System.Windows.ResourceKey>.</span><span class="sxs-lookup"><span data-stu-id="c14dd-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="c14dd-313">`MyStyle` oczekuje się [x: Key](../../../../docs/framework/xaml-services/x-key-directive.md) wartość <xref:System.Windows.Style> definiowany jako zasób.</span><span class="sxs-lookup"><span data-stu-id="c14dd-313">`MyStyle` is expected to be the [x:Key](../../../../docs/framework/xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="c14dd-314">[Staticresource — rozszerzenie znaczników](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) użycia żądań, że zasób służyć do zapewnienia <xref:System.Windows.Style> wartość właściwości przy użyciu logiki wyszukiwania zasobów statycznych w czasie ładowania.</span><span class="sxs-lookup"><span data-stu-id="c14dd-314">The [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="c14dd-315">Aby uzyskać więcej informacji na temat rozszerzenia znaczników, zobacz [rozszerzenia znacznikowania i WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="c14dd-316">Aby uzyskać odwołanie rozszerzenia znaczników i innych XAML programowania funkcje dostępne w ogólne implementacji .NET, XAML, zobacz [Namespace XAML (x:) Funkcje języka](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).</span></span> <span data-ttu-id="c14dd-317">Rozszerzenia znaczników charakterystyczne dla WPF, zobacz [WPF XAML rozszerzenia](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-317">For WPF-specific markup extensions, see [WPF XAML Extensions](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="c14dd-318">Dołączone właściwości</span><span class="sxs-lookup"><span data-stu-id="c14dd-318">Attached Properties</span></span>  
 <span data-ttu-id="c14dd-319">Właściwości dołączone są koncepcji programowania, wprowadzona w XAML, zgodnie z którą właściwości może być właścicielem i zdefiniowane przez określonego typu, ale ustawiony jako atrybutów lub elementów właściwości dowolnego elementu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="c14dd-320">Podstawowy scenariusz, dołączone właściwości są przeznaczone do jest umożliwienie elementy podrzędne w strukturze znaczników do informacji w raporcie na element nadrzędny bez konieczności model obiektowy szerokim zakresie udostępnionym dla wszystkich elementów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="c14dd-321">Z drugiej strony dołączone właściwości mogą być używane przez elementy nadrzędne informacji raportu, aby elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="c14dd-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="c14dd-322">Aby uzyskać więcej informacji na temat celem dołączone właściwości oraz tworzyć własne dołączonych właściwości, zobacz [Przegląd właściwości dołączonych](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="c14dd-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="c14dd-323">Dołączone właściwości użyj składni, która przypomina pozornie składni elementu właściwości, w tym również określić *typeName*. *propertyName* kombinacji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="c14dd-324">Istnieją dwie ważne różnice:</span><span class="sxs-lookup"><span data-stu-id="c14dd-324">There are two important differences:</span></span>  
  
-   <span data-ttu-id="c14dd-325">Możesz użyć *typeName*. *propertyName* kombinacji nawet wtedy, gdy ustawienie dołączoną właściwość za pomocą składni atrybutów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="c14dd-326">Właściwości dołączone są tylko wówczas, gdy kwalifikowania nazwy właściwości jest wymagany w składni atrybutów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
-   <span data-ttu-id="c14dd-327">Umożliwia także składni elementu właściwości przypadku dołączonych właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="c14dd-328">Jednak w przypadku składni elementu typowe właściwości *typeName* określasz, jest elementem obiektu, który zawiera element właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="c14dd-329">Jeśli odwołujesz się do dołączoną właściwość, a następnie *typeName* jest klasa, która definiuje dołączona właściwość nie zawierającego element obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="c14dd-330">Dołączone zdarzenia</span><span class="sxs-lookup"><span data-stu-id="c14dd-330">Attached Events</span></span>  
 <span data-ttu-id="c14dd-331">Zdarzenia dołączone są innego koncepcji programowania, wprowadzona w XAML, gdzie zdarzenia można zdefiniować w określonym typie, ale obsługi może być podłączona w dowolnym elemencie obiektu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="c14dd-332">W implementacji WOF często typ, który definiuje dołączone zdarzenie jest typem statycznych, który definiuje usługę, a czasami te dołączone zdarzenia są uwidocznione przez alias zdarzenie trasowane, typy, które udostępniają usługi.</span><span class="sxs-lookup"><span data-stu-id="c14dd-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="c14dd-333">Programy obsługi dla zdarzenia dołączone są określane za pomocą składni atrybutów.</span><span class="sxs-lookup"><span data-stu-id="c14dd-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="c14dd-334">Zgodnie z z dołączone zdarzenia składni atrybutów podzielonego dla dołączone zdarzenia umożliwić *typeName*. *eventName* użycia, gdzie *typeName* jest klasa, która zapewnia `Add` i `Remove` metod dostępu programu obsługi zdarzeń dla infrastruktury dołączone zdarzenie i *eventName* jest nazwa zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="c14dd-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="c14dd-335">Anatomia Element główny XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="c14dd-336">W poniższej tabeli przedstawiono typowe XAML element główny podzielone, przedstawiający określone atrybuty elementu głównego:</span><span class="sxs-lookup"><span data-stu-id="c14dd-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="c14dd-337">Otwieranie elementu obiektu głównego</span><span class="sxs-lookup"><span data-stu-id="c14dd-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="c14dd-338">Wartość domyślna ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) przestrzeń nazw XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="c14dd-339">Przestrzeń nazw XAML dla języka XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="c14dd-340">Deklaracja klasy częściowej, która łączy znaczników wszelkie związane z kodem zdefiniowane dla klasy częściowej</span><span class="sxs-lookup"><span data-stu-id="c14dd-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="c14dd-341">Końcowy element obiektu głównego.</span><span class="sxs-lookup"><span data-stu-id="c14dd-341">End of object element for the root.</span></span> <span data-ttu-id="c14dd-342">Obiekt nie jest jeszcze zamknięty, ponieważ element zawiera elementy podrzędne</span><span class="sxs-lookup"><span data-stu-id="c14dd-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="c14dd-343">Opcjonalne i Nonrecommended XAML użycia</span><span class="sxs-lookup"><span data-stu-id="c14dd-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="c14dd-344">W poniższych sekcjach opisano użycia XAML z technicznego punktu widzenia obsługiwane przez procesory XAML, ale który produkcji poziom szczegółowości lub inne estetycznych problemy, które zakłócają pozostałe czytelny dla człowieka, gdy pliki XAML swoje opracowywania aplikacji, które zawierają źródła XAML .</span><span class="sxs-lookup"><span data-stu-id="c14dd-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when your develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="c14dd-345">Opcjonalna właściwość elementu użycia</span><span class="sxs-lookup"><span data-stu-id="c14dd-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="c14dd-346">Opcjonalna właściwość elementu użycia obejmują jawnie wypisywanie zawartości właściwości elementu czy procesor XAML uwzględnia niejawne.</span><span class="sxs-lookup"><span data-stu-id="c14dd-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="c14dd-347">Na przykład, kiedy Deklarujesz zawartość <xref:System.Windows.Controls.Menu>, można jawnie deklarować <xref:System.Windows.Controls.ItemsControl.Items%2A> zbiór <xref:System.Windows.Controls.Menu> jako `<Menu.Items>` tagu elementu właściwości, a miejsce każdego <xref:System.Windows.Controls.MenuItem> w ramach `<Menu.Items>`, a niż użycie niejawnej zachowanie procesora XAML, wszystkie elementy podrzędne elementu <xref:System.Windows.Controls.Menu> musi być <xref:System.Windows.Controls.MenuItem> i są umieszczane w <xref:System.Windows.Controls.ItemsControl.Items%2A> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="c14dd-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="c14dd-348">Czasami opcjonalne użycia może pomóc wizualnie wyjaśnienie struktury obiektu reprezentowane w znaczniku.</span><span class="sxs-lookup"><span data-stu-id="c14dd-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="c14dd-349">Lub czasami użycie elementu właściwości jawne można uniknąć znaczników, który jest technicznie funkcjonalności, ale wizualnie mylące, takie jak rozszerzenia znaczników zagnieżdżone w obrębie wartość atrybutu.</span><span class="sxs-lookup"><span data-stu-id="c14dd-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="c14dd-350">Pełna typeName.memberName kwalifikowana atrybutów</span><span class="sxs-lookup"><span data-stu-id="c14dd-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="c14dd-351">*TypeName*. *memberName* tworzą dla atrybutu faktycznie działa więcej niż tylko wielkością liter zdarzenia trasowanego powszechnie.</span><span class="sxs-lookup"><span data-stu-id="c14dd-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="c14dd-352">Ale w innych sytuacjach formularza jest zbędny, a nie należy go, jeśli tylko do celów styl znaczników i czytelności.</span><span class="sxs-lookup"><span data-stu-id="c14dd-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="c14dd-353">W poniższym przykładzie odwołania do każdego z trzech <xref:System.Windows.Controls.Control.Background%2A> atrybutu są całkowicie równoważne:</span><span class="sxs-lookup"><span data-stu-id="c14dd-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="c14dd-354">`Button.Background` działa, ponieważ kwalifikowaną wyszukiwania dla tej właściwości na <xref:System.Windows.Controls.Button> zakończy się pomyślnie (<xref:System.Windows.Controls.Control.Background%2A> został odziedziczony z kontrolki) i <xref:System.Windows.Controls.Button> jest klasa elementu obiekt lub klasa bazowa.</span><span class="sxs-lookup"><span data-stu-id="c14dd-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="c14dd-355">`Control.Background` działa, ponieważ <xref:System.Windows.Controls.Control> klasa faktycznie definiuje <xref:System.Windows.Controls.Control.Background%2A> i <xref:System.Windows.Controls.Control> jest <xref:System.Windows.Controls.Button> klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="c14dd-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="c14dd-356">Jednak następujące *typeName*. *memberName* przykład użycia elementu form nie działa i jest wyświetlany związku z tym komentarzem:</span><span class="sxs-lookup"><span data-stu-id="c14dd-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="c14dd-357"><xref:System.Windows.Controls.Label> jest innej klasy pochodnej z <xref:System.Windows.Controls.Control>, a jeśli Gdybyśmy ustawili `Label.Background` w ramach <xref:System.Windows.Controls.Label> element obiektu to użycie będą działały.</span><span class="sxs-lookup"><span data-stu-id="c14dd-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="c14dd-358">Jednak ponieważ <xref:System.Windows.Controls.Label> nie jest klasa lub klasa bazowa <xref:System.Windows.Controls.Button>, określonego zachowania procesora XAML jest następnie przetwarzanie `Label.Background` jako dołączona właściwość.</span><span class="sxs-lookup"><span data-stu-id="c14dd-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="c14dd-359">`Label.Background` nie jest dostępna dołączoną właściwość, a to użycie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="c14dd-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="c14dd-360">baseTypeName.memberName właściwości elementów</span><span class="sxs-lookup"><span data-stu-id="c14dd-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="c14dd-361">W analogiczny sposób jak *typeName*. *memberName* formularz działa w przypadku składni atrybutów *baseTypeName*. *memberName* składni działa w przypadku składni elementu właściwości.</span><span class="sxs-lookup"><span data-stu-id="c14dd-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="c14dd-362">Na przykład działa w następującej składni:</span><span class="sxs-lookup"><span data-stu-id="c14dd-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="c14dd-363">W tym miejscu podano element właściwości jako `Control.Background` mimo, że element właściwości zawarte w `Button`.</span><span class="sxs-lookup"><span data-stu-id="c14dd-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="c14dd-364">Podobnie jak w przypadku, ale *typeName*. *memberName* formularz dla atrybutów, *baseTypeName*. *memberName* jest niska stylu w znacznikach i należy jej unikać.</span><span class="sxs-lookup"><span data-stu-id="c14dd-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c14dd-365">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="c14dd-365">See Also</span></span>  
 [<span data-ttu-id="c14dd-366">Przegląd XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="c14dd-366">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="c14dd-367">Przestrzeń nazw XAML (x:) — funkcje językowe</span><span class="sxs-lookup"><span data-stu-id="c14dd-367">XAML Namespace (x:) Language Features</span></span>](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)  
 [<span data-ttu-id="c14dd-368">Rozszerzenia WPF XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-368">WPF XAML Extensions</span></span>](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)  
 [<span data-ttu-id="c14dd-369">Przegląd właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="c14dd-369">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="c14dd-370">TypeConverters i XAML</span><span class="sxs-lookup"><span data-stu-id="c14dd-370">TypeConverters and XAML</span></span>](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md)  
 [<span data-ttu-id="c14dd-371">Klasy XAML i niestandardowe dla WPF</span><span class="sxs-lookup"><span data-stu-id="c14dd-371">XAML and Custom Classes for WPF</span></span>](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)
