---
title: Drzewa w WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 0dfae3a601a07c68b2dfe029f061dcf838e98af7
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459497"
---
# <a name="trees-in-wpf"></a>Drzewa w WPF
W wielu technologiach elementy i składniki są zorganizowane w strukturze drzewa, gdzie deweloperzy mogą bezpośrednio manipulować węzłami obiektów w drzewie, aby wpływać na renderowanie lub zachowanie aplikacji. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] używa także kilku struktur drzewa metafory do definiowania relacji między elementami programu. W przypadku większości programistów deweloperzy mogą tworzyć aplikacje w kodzie lub definiować fragmenty aplikacji w języku XAML, a jednocześnie zastanawiać się o metaphor drzewa obiektów, ale będą wywoływały określony interfejs API lub przy użyciu określonego znacznika, aby to zrobić, a nie ogólnie Interfejs API manipulowania drzewem obiektów, taki jak można użyć w modelu XML DOM. WPF uwidacznia dwie klasy pomocników, które udostępniają widok metaphor drzewa, <xref:System.Windows.LogicalTreeHelper> i <xref:System.Windows.Media.VisualTreeHelper>. Warunki drzewa wizualnego i drzewa logicznego są również używane w dokumentacji WPF, ponieważ te same drzewa są przydatne do poznania zachowań niektórych kluczowych funkcji WPF. W tym temacie opisano, co reprezentuje drzewo wizualne i Drzewo logiczne, omówiono, jak te drzewa odnoszą się do ogólnej koncepcji drzewa obiektów i wprowadza <xref:System.Windows.LogicalTreeHelper> i <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Drzewa w WPF  
 Najbardziej kompletna struktura drzewa w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] jest drzewem obiektów. W przypadku zdefiniowania strony aplikacji w [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], a następnie załadowania [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], struktura drzewa zostanie utworzona na podstawie zagnieżdżenia relacji elementów w znaczniku. Jeśli zdefiniujesz aplikację lub część aplikacji w kodzie, struktura drzewa jest tworzona w oparciu o sposób przypisywania wartości właściwości dla właściwości implementujących model zawartości dla danego obiektu. W [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]istnieją dwa sposoby koncepcyjnego tworzenia całego drzewa obiektów i mogą być zgłaszane do jego publicznego interfejsu API: jako Drzewo logiczne i jako drzewo wizualne. Różnice między drzewem logicznym a drzewem wizualnym nie zawsze muszą być ważne, ale mogą sporadycznie powodować problemy z pewnymi podsystemami [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] i wpływać na wybory wprowadzane w znacznikach lub kodzie.  
  
 Mimo że nie zawsze manipuluj bezpośrednio drzewa logiczne lub drzewa wizualnego, zrozumienie koncepcji współdziałania drzew jest przydatne do poznania WPF jako technologii. Zastanawiasz się, że WPF jako metaphor drzewa niektórych rodzajów jest również decydujący, aby zrozumieć sposób działania dziedziczenia właściwości i routingu zdarzeń w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
> Ponieważ drzewo obiektów jest bardziej koncepcją niż rzeczywisty interfejs API, inny sposób, aby myśleć o koncepcji, jest obiektem grafu obiektów. W programie istnieją relacje między obiektami w czasie wykonywania, gdzie drzewo metaphor zostanie zerwane. Niemniej jednak, szczególnie w przypadku interfejsu użytkownika zdefiniowanego w języku XAML, drzewo metaphor jest wystarczające, aby większość dokumentacji WPF korzystała z terminu drzewa obiektów podczas odwoływania się do tej koncepcji ogólnej.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Drzewo logiczne  
 W [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]należy dodać zawartość do elementów interfejsu użytkownika przez ustawienie właściwości obiektów, które odnoszą się do tych elementów. Można na przykład dodać elementy do kontrolki <xref:System.Windows.Controls.ListBox> przez manipulowanie jej właściwością <xref:System.Windows.Controls.ItemsControl.Items%2A>. Dzięki temu umieszczasz elementy w <xref:System.Windows.Controls.ItemCollection>, która jest <xref:System.Windows.Controls.ItemsControl.Items%2A> wartością właściwości. Podobnie aby dodać obiekty do <xref:System.Windows.Controls.DockPanel>, można manipulować jej <xref:System.Windows.Controls.Panel.Children%2A> wartością właściwości. Tutaj dodajesz obiekty do <xref:System.Windows.Controls.UIElementCollection>. Aby zapoznać się z przykładem kodu, zobacz [jak: Dodawanie elementu dynamicznie](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 W [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], gdy umieścisz elementy listy w <xref:System.Windows.Controls.ListBox> lub kontrolkach lub innych elementach interfejsu użytkownika w <xref:System.Windows.Controls.DockPanel>, użyjesz także właściwości <xref:System.Windows.Controls.ItemsControl.Items%2A> i <xref:System.Windows.Controls.Panel.Children%2A>, jawnie lub niejawnie, jak w poniższym przykładzie.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Jeśli chcesz przetworzyć ten kod XAML jako kod XML w modelu obiektów dokumentu, a w przypadku dołączenia tagów jako niejawnych (które byłyby dozwolone), w utworzonym drzewie XML DOM będzie zawierały elementy `<ListBox.Items>` i innych elementów niejawnych. Chociaż język XAML nie przetworzy się w ten sposób podczas odczytywania znaczników i zapisu w obiektach, powstaje wykres obiektów, który nie zawiera `ListBox.Items`. Ma ona jednak Właściwość <xref:System.Windows.Controls.ListBox> o nazwie `Items`, która zawiera <xref:System.Windows.Controls.ItemCollection>, a <xref:System.Windows.Controls.ItemCollection> jest inicjowana, ale pusta, gdy zostanie przetworzony <xref:System.Windows.Controls.ListBox> XAML. Następnie każdy element podrzędny obiektu, który istnieje jako zawartość dla <xref:System.Windows.Controls.ListBox> zostanie dodany do <xref:System.Windows.Controls.ItemCollection> przez wywołania analizatora do `ItemCollection.Add`. Ten przykład przetwarzania kodu XAML do drzewa obiektów jest w tej chwili prawdopodobnie przykładem, gdzie utworzone drzewo obiektów jest zasadniczo drzewem logicznym.  
  
 Jednak Drzewo logiczne to nie cały Graf obiektów, który istnieje dla interfejsu użytkownika aplikacji w czasie wykonywania, nawet z niejawnymi elementami składni XAML. Główną przyczyną tego są wizualizacje i szablony. Rozważmy na przykład <xref:System.Windows.Controls.Button>. Drzewo logiczne raportuje obiekt <xref:System.Windows.Controls.Button> a także jego ciąg `Content`. Jednak więcej informacji na ten temat znajduje się w drzewie obiektów czasu wykonywania. W szczególności przycisk pojawia się tylko na ekranie w taki sposób, że został zastosowany określony szablon kontrolki <xref:System.Windows.Controls.Button>. Wizualizacje, które pochodzą z zastosowanego szablonu (na przykład <xref:System.Windows.Controls.Border> zdefiniowanego przez szablon ciemnego szarego wokół przycisku wizualizacji) nie są zgłaszane w drzewie logicznym, nawet jeśli przeglądasz Drzewo logiczne w czasie wykonywania (na przykład obsługujące Zdarzenie wejściowe z widoczny interfejs użytkownika, a następnie odczytywanie drzewa logicznego). Aby znaleźć wizualizacje szablonu, należy przeanalizować drzewo wizualne.  
  
 Aby uzyskać więcej informacji na temat sposobu mapowania składni [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] na wykres utworzonego obiektu i niejawna składnia w języku XAML, zobacz [składnia języka XAML w temacie szczegóły](xaml-syntax-in-detail.md) lub [XAML — Omówienie (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Cel drzewa logicznego  
 Drzewo logiczne istnieje, dzięki czemu modele zawartości mogą łatwo wykonywać iteracje na możliwych obiektach podrzędnych, dzięki czemu modele zawartości mogą być rozszerzalne. Ponadto Drzewo logiczne udostępnia strukturę dla pewnych powiadomień, na przykład w przypadku załadowania wszystkich obiektów w drzewie logicznym. Zasadniczo logiczne drzewo to przybliżenie grafu obiektu czasu wykonywania na poziomie struktury, który wyklucza wizualizacje, ale jest odpowiednie dla wielu operacji wykonywania zapytań w odniesieniu do własnej kompozycji aplikacji czasu wykonywania.  
  
 Ponadto zarówno statyczne, jak i dynamiczne odwołania do zasobów są rozwiązywane przez wyszukanie w górę drzewa logicznego dla kolekcji <xref:System.Windows.FrameworkElement.Resources%2A> w początkowym obiekcie żądającym, a następnie kontynuowanie drzewa logicznego i sprawdzanie każdego <xref:System.Windows.FrameworkElement> (lub <xref:System.Windows.FrameworkContentElement>) dla inna `Resources` wartość zawierająca <xref:System.Windows.ResourceDictionary>, która może zawierać ten klucz. Drzewo logiczne służy do wyszukiwania zasobów, gdy są obecne zarówno Drzewo logiczne, jak i drzewo wizualne. Aby uzyskać więcej informacji na temat słowników zasobów i wyszukiwania, zobacz [zasoby XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Kompozycja drzewa logicznego  
 Drzewo logiczne jest zdefiniowane na poziomie platformy WPF, co oznacza, że element bazy WPF, który jest najbardziej odpowiedni dla operacji drzewa logicznego, jest <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>. Jednak w miarę jak można sprawdzić, czy w rzeczywistości używasz interfejsu API <xref:System.Windows.LogicalTreeHelper>, Drzewo logiczne czasami zawiera węzły, które nie są <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>. Na przykład, Drzewo logiczne raportuje <xref:System.Windows.Controls.TextBlock.Text%2A> wartość <xref:System.Windows.Controls.TextBlock>, która jest ciągiem.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Zastępowanie drzewa logicznego  
 Autorzy zaawansowanej kontroli mogą przesłonić Drzewo logiczne przez zastępowanie kilku interfejsów API, które definiują, jak obiekt ogólny lub model zawartości dodaje lub usuwa obiekty w drzewie logicznym. Aby zapoznać się z przykładem sposobu przesłonięcia drzewa logicznego, zobacz [przesłanianie drzewa logicznego](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Przejęcie wartości właściwości  
 Dziedziczenie wartości właściwości działa przez drzewo hybrydowe. Rzeczywiste metadane zawierające Właściwość <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>, która umożliwia dziedziczenie właściwości, jest klasą <xref:System.Windows.FrameworkPropertyMetadata> na poziomie platformy WPF. W związku z tym zarówno element nadrzędny, który posiada oryginalną wartość, jak i obiekt podrzędny, który dziedziczy tę wartość, muszą być <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>, i oba muszą być częścią drzewa logicznego. Jednak dla istniejących właściwości WPF, które obsługują dziedziczenie właściwości, dziedziczenie wartości właściwości jest możliwe perpetuate przez obiekt, który nie znajduje się w drzewie logicznym. Głównie ma to zastosowanie w przypadku, gdy elementy szablonu używają wszelkich dziedziczonych wartości właściwości ustawionych w przypadku wystąpienia, które jest szablonem lub na jeszcze wyższym poziomie kompozycji na poziomie strony i w związku z tym wyższe w drzewie logicznym. Aby dziedziczenie wartości właściwości działało spójnie między takimi granicami, właściwość dziedziczenia musi być zarejestrowana jako dołączona właściwość i należy przestrzegać tego wzorca, jeśli zamierzasz zdefiniować niestandardową właściwość zależności z właściwością zachowanie dziedziczenia. Dokładne drzewo używane do dziedziczenia właściwości nie może być całkowicie przewidziane przez metodę narzędzia klasy pomocnika, nawet w czasie wykonywania. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Drzewo wizualne  
 Oprócz koncepcji drzewa logicznego istnieje również koncepcja drzewa wizualnego w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. W drzewie wizualnym opisano strukturę obiektów wizualizacji, reprezentowanych przez klasę bazową <xref:System.Windows.Media.Visual>. Podczas pisania szablonu dla kontrolki definiujesz lub ponownie zdefiniujesz drzewo wizualne, które ma zastosowanie do tej kontrolki. Drzewo wizualne jest również przydatne dla deweloperów, którzy chcą mieć niższy poziom kontroli nad rysowaniem ze względu na wydajność i optymalizację. Jedno narażenie na drzewo wizualne jako część konwencjonalnego programowania aplikacji [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] polega na tym, że trasy zdarzeń dla zdarzenia kierowanego przeważnie podróżują do drzewa wizualnego, a nie drzewa logicznego. Subtlety zachowanie zdarzeń kierowanych może nie być od razu widoczne, chyba że jesteś autorem kontrolki. Zdarzenia routingu za pomocą drzewa wizualnego umożliwiają kontrolom implementującym kompozycję na poziomie wizualizacji do obsługi zdarzeń lub tworzenia metod ustawiających zdarzenia.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Drzewa, elementy zawartości i hosty zawartości  
 Elementy zawartości (klasy, które pochodzą z <xref:System.Windows.ContentElement>) nie są częścią drzewa wizualnego; nie dziedziczą po <xref:System.Windows.Media.Visual> i nie mają wizualnej reprezentacji. Aby w interfejsie użytkownika pojawił się w dowolnym miejscu, <xref:System.Windows.ContentElement> musi być hostowana na hoście zawartości, który jest zarówno <xref:System.Windows.Media.Visual>, jak i uczestnikiem drzewa logicznego. Zwykle taki obiekt jest <xref:System.Windows.FrameworkElement>. Można konceptualizacji, że host zawartości jest nieco podobny do "przeglądarki" dla zawartości i wybiera sposób wyświetlania tej zawartości w obszarze ekranu, który kontroluje hosta. Gdy zawartość jest hostowana, zawartość może zostać wykonana w pewnych procesach drzewa, które są zwykle skojarzone z drzewem wizualnym. Ogólnie rzecz biorąc, Klasa hosta <xref:System.Windows.FrameworkElement> zawiera kod implementacji, który dodaje wszystkie hostowane <xref:System.Windows.ContentElement> do trasy zdarzenia za pośrednictwem podwęzłów drzewa logicznego zawartości, nawet jeśli hostowana zawartość nie jest częścią rzeczywistego drzewa wizualnego. Jest to konieczne, aby <xref:System.Windows.ContentElement> można było zarejestrować zdarzenia kierowanego, które kieruje do dowolnego elementu innego niż sam.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Przechodzenie drzewa  
 Klasa <xref:System.Windows.LogicalTreeHelper> udostępnia metody <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>i <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> na potrzeby przechodzenia drzewa logicznego. W większości przypadków nie powinno być konieczne przechodzenie przez Drzewo logiczne istniejących kontrolek, ponieważ te kontrolki prawie zawsze uwidaczniają swoje logiczne elementy podrzędne jako właściwość dedykowanej kolekcji, która obsługuje dostęp do kolekcji, taki jak `Add`, indeksator i tak dalej. . Przechodzenie drzewa jest głównie scenariuszem, który jest używany przez autorów kontroli, którzy nie muszą dziedziczyć z zamierzonych wzorców kontrolek, takich jak <xref:System.Windows.Controls.ItemsControl> lub <xref:System.Windows.Controls.Panel>, gdzie właściwości kolekcji są już zdefiniowane, i które mają na celu dostarczenie własnej właściwości kolekcji pomocy.  
  
 Drzewo wizualne obsługuje również klasę pomocnika na potrzeby przechodzenia do drzewa wizualnego, <xref:System.Windows.Media.VisualTreeHelper>. Drzewo wizualne nie jest widoczne jako wygodnie za pomocą właściwości specyficznych dla kontroli, więc Klasa <xref:System.Windows.Media.VisualTreeHelper> jest zalecanym sposobem przechodzenia do drzewa wizualnego, jeśli jest to niezbędne dla scenariusza programowania. Aby uzyskać więcej informacji, zobacz [Omówienie renderowania grafiki WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Czasami konieczne jest przeanalizowanie drzewa wizualnego zastosowanego szablonu. Należy zachować ostrożność podczas korzystania z tej techniki. Nawet jeśli przejdziesz do drzewa wizualnego dla kontrolki, w której definiujesz szablon, odbiorcy kontrolki zawsze mogą zmienić szablon, ustawiając właściwość <xref:System.Windows.Controls.Control.Template%2A> w wystąpieniach, a nawet użytkownik końcowy może mieć wpływ na zastosowany szablon, zmieniając system tematów.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Trasy dla zdarzeń kierowanych jako "drzewo"  
 Jak wspomniano wcześniej, trasa danego zdarzenia kierowanego jest transmitowana wzdłuż jednej i wstępnie określonej ścieżki drzewa, która jest hybrydową reprezentacją drzewa wizualnego i logicznego. Trasa zdarzenia może poruszać się w kierunku w górę lub w dół w drzewie, w zależności od tego, czy jest to zdarzenie tunelowania czy propagacji. Koncepcja trasy zdarzenia nie ma bezpośredniej pomocniczej klasy pomocniczej, która może służyć do "przeszukiwania" trasy zdarzenia niezależnie od podniesienia zdarzenia, które faktycznie kieruje trasy. Istnieje Klasa, która reprezentuje trasę, <xref:System.Windows.EventRoute>, ale metody tej klasy są zwykle wyłącznie do użytku wewnętrznego.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Słowniki zasobów i drzewa  
 Wyszukiwanie słowników zasobów dla wszystkich `Resources` zdefiniowanych na stronie przechodzą w dół drzewa logicznego. Obiekty, które nie znajdują się w drzewie logicznym, mogą odwoływać się do zasobów z ograniczeniami, ale sekwencja wyszukiwania zasobów rozpoczyna się w punkcie, w którym ten obiekt jest podłączony do drzewa logicznego. W WPF tylko logiczne węzły drzewa mogą mieć Właściwość `Resources`, która zawiera <xref:System.Windows.ResourceDictionary>, dlatego nie ma żadnych korzyści w przypadku przechodzenia przez drzewo wizualne szukanych zasobów z <xref:System.Windows.ResourceDictionary>.  
  
 Jednak wyszukiwanie zasobów może również wykraczać poza bezpośrednie Drzewo logiczne. W przypadku znaczników aplikacji Wyszukiwanie zasobów może potem przejść dalej do słowników zasobów na poziomie aplikacji, a następnie do obsługi motywów i wartości systemowych, do których odwołują się jako właściwości statyczne lub klucze. Same motywy mogą również odwoływać się do wartości systemowych poza drzewem logicznym motywu, jeśli odwołania do zasobów są dynamiczne. Aby uzyskać więcej informacji na temat słowników zasobów i logiki wyszukiwania, zobacz [zasoby XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>Zobacz także

- [Przegląd danych wejściowych](input-overview.md)
- [Renderowanie grafiki WPF — przegląd](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Przegląd zdarzeń trasowanych](routed-events-overview.md)
- [Inicjowanie elementów obiektu poza drzewem obiektu](initialization-for-object-elements-not-in-an-object-tree.md)
- [Architektura WPF](wpf-architecture.md)
