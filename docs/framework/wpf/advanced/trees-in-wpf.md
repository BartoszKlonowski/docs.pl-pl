---
title: Drzew
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 696772da1ebee405493f2ff0e1481daf93d08ec7
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187018"
---
# <a name="trees-in-wpf"></a>Drzewa w WPF
W wielu technologiach elementy i składniki są zorganizowane w strukturze drzewa, gdzie deweloperzy bezpośrednio manipulować węzłami obiektów w drzewie, aby wpłynąć na renderowanie lub zachowanie aplikacji. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]używa również kilku metafor struktury drzewa do definiowania relacji między elementami programu. W przeważającej części deweloperzy WPF mogą tworzyć aplikację w kodzie lub definiować części aplikacji w języku XAML, myśląc koncepcyjnie o metaforze drzewa obiektów, ale będą wywoływać określony interfejs API lub używać określonych znaczników, aby to zrobić, a nie niektóre ogólne interfejs API manipulowania drzewami obiektów, taki jak w XML DOM. WPF WPF udostępnia dwie klasy pomocnika, <xref:System.Windows.LogicalTreeHelper> które <xref:System.Windows.Media.VisualTreeHelper>zapewniają widok metafory drzewa i . Terminy drzewa wizualnego i drzewa logicznego są również używane w dokumentacji WPF, ponieważ te same drzewa są przydatne do zrozumienia zachowania niektórych kluczowych funkcji WPF. W tym temacie definiuje, co reprezentuje drzewo wizualne i drzewo logiczne, omówiono, <xref:System.Windows.LogicalTreeHelper> <xref:System.Windows.Media.VisualTreeHelper>jak takie drzewa odnoszą się do ogólnej koncepcji drzewa obiektów i wprowadza i s.  

<a name="element_tree"></a>
## <a name="trees-in-wpf"></a>Drzewa w WPF  
 Najbardziej kompletna struktura [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] drzewa w jest drzewo obiektów. Jeśli zdefiniujesz [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] stronę aplikacji, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]a następnie załadujesz strukturę drzewa, zostanie utworzona na podstawie relacji zagnieżdżania elementów w znacznikach. Jeśli zdefiniujesz aplikację lub część aplikacji w kodzie, struktura drzewa jest tworzona na podstawie sposobu przypisywania wartości właściwości dla właściwości, które implementują model zawartości dla danego obiektu. W [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]programie istnieją dwa sposoby, że pełne drzewo obiektów jest konceptualizowane i mogą być zgłaszane do jego publicznego interfejsu API: jako drzewo logiczne i jako drzewo wizualne. Różnice między drzewem logicznym a drzewem wizualnym nie zawsze są [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ważne, ale czasami mogą powodować problemy z niektórymi podsystemami i wpływać na wybory dokonywane w znacznikach lub kodzie.  
  
 Mimo że nie zawsze manipulować albo drzewa logicznego lub drzewa wizualnego bezpośrednio, zrozumienie pojęcia, jak drzewa interakcji jest przydatne do zrozumienia WPF jako technologii. Myślenie o WPF jako metafora drzewa pewnego rodzaju ma również kluczowe [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]znaczenie dla zrozumienia, jak dziedziczenie własności i routing zdarzeń pracy w .  
  
> [!NOTE]
> Ponieważ drzewo obiektów jest bardziej koncepcji niż rzeczywistego interfejsu API, innym sposobem, aby myśleć o koncepcji jest jako wykres obiektu. W praktyce istnieją relacje między obiektami w czasie wykonywania, gdzie metafora drzewa zostanie przerwana. Niemniej jednak, szczególnie w przypadku interfejsu użytkownika zdefiniowanego przez XAML, metafora drzewa jest na tyle istotna, że większość dokumentacji WPF będzie używać terminu drzewo obiektów podczas odwoływania się do tej ogólnej koncepcji.  
  
<a name="logical_tree"></a>
## <a name="the-logical-tree"></a>Drzewo logiczne  
 W [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]programie można dodać zawartość do elementów interfejsu użytkownika, ustawiając właściwości obiektów, które tworzą te elementy. Na przykład można dodać <xref:System.Windows.Controls.ListBox> elementy do formantu, manipulując jego <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwości. W ten sposób umieszczasz elementy <xref:System.Windows.Controls.ItemCollection> w <xref:System.Windows.Controls.ItemsControl.Items%2A> wartości właściwości. Podobnie, aby dodać obiekty <xref:System.Windows.Controls.DockPanel>do , <xref:System.Windows.Controls.Panel.Children%2A> można manipulować jego wartości właściwości. W tym miejscu dodajesz <xref:System.Windows.Controls.UIElementCollection>obiekty do pliku . Przykładowy kod można znaleźć [w trybie: Dynamiczne dodawanie elementu](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 W [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], podczas umieszczania <xref:System.Windows.Controls.ListBox> elementów listy w lub <xref:System.Windows.Controls.DockPanel>formantów lub <xref:System.Windows.Controls.ItemsControl.Items%2A> <xref:System.Windows.Controls.Panel.Children%2A> innych elementów interfejsu użytkownika w , można również użyć i właściwości, jawnie lub niejawnie, jak w poniższym przykładzie.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Jeśli miałbyś przetworzyć ten kod XAML jako XML w modelu obiektu dokumentu i jeśli zostały uwzględnione tagi skomentowane jako niejawne (co `<ListBox.Items>` byłoby legalne), wynikowe drzewo XML DOM zawierałoby elementy dla i inne elementy niejawne. Ale XAML nie przetwarza w ten sposób podczas odczytywania znaczników i zapisu `ListBox.Items`do obiektów, wynikowy wykres obiektu nie zawiera dosłownie . Ma jednak <xref:System.Windows.Controls.ListBox> właściwość `Items` o <xref:System.Windows.Controls.ItemCollection>nazwie, która <xref:System.Windows.Controls.ItemCollection> zawiera , i <xref:System.Windows.Controls.ListBox> który jest inicjowany, ale puste, gdy XAML jest przetwarzany. Następnie każdy element obiektu podrzędnego, który <xref:System.Windows.Controls.ListBox> istnieje jako <xref:System.Windows.Controls.ItemCollection> zawartość jest dodawany do przez parser wywołania `ItemCollection.Add`. Ten przykład przetwarzania XAML w drzewie obiektów jest do tej pory pozornie przykładem, w którym drzewo obiektów utworzonych jest w zasadzie drzewem logicznym.  
  
 Jednak drzewo logiczne nie jest cały wykres obiektu, który istnieje dla interfejsu użytkownika aplikacji w czasie wykonywania, nawet z elementów składni niejawnych XAML uwzględnione. Głównym powodem tego są wizualizacje i szablony. Rozważmy na <xref:System.Windows.Controls.Button>przykład . Drzewo logiczne <xref:System.Windows.Controls.Button> zgłasza obiekt, `Content`a także jego ciąg . Ale jest więcej do tego przycisku w drzewie obiektów w czasie wykonywania. W szczególności przycisk pojawia się tylko na ekranie, tak jak to robi, ponieważ zastosowano określony <xref:System.Windows.Controls.Button> szablon formantu. Wizualizacje pochodzące z zastosowanego szablonu (na <xref:System.Windows.Controls.Border> przykład zdefiniowane przez szablon ciemnoszarego wokół przycisku wizualnego) nie są zgłaszane w drzewie logicznym, nawet jeśli patrzysz na drzewo logiczne w czasie wykonywania (na przykład obsługa zdarzenia wejściowego z widocznego interfejsu użytkownika, a następnie odczytywanie drzewa logicznego). Aby znaleźć wizualizacje szablonu, należy zamiast tego zbadać drzewa wizualnego.  
  
 Aby uzyskać więcej [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] informacji o tym, jak składnia jest mapowana na utworzony wykres obiektów i składnia niejawna w języku XAML, zobacz [Składnia XAML w szczegółach](xaml-syntax-in-detail.md) lub [Przegląd XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>
### <a name="the-purpose-of-the-logical-tree"></a>Cel drzewa logicznego  
 Drzewo logiczne istnieje, dzięki czemu modele zawartości mogą łatwo iterować nad ich możliwych obiektów podrzędnych i tak, aby modele zawartości mogą być rozszerzalne. Ponadto drzewo logiczne zapewnia strukturę dla niektórych powiadomień, takich jak podczas ładowania wszystkich obiektów w drzewie logicznym. Zasadniczo drzewo logiczne jest przybliżeniem wykresu obiektu czasu wykonywania na poziomie struktury, który wyklucza wizualizacje, ale jest odpowiedni dla wielu operacji zapytań względem kompozycji własnej aplikacji czasu wykonywania.  
  
 Ponadto odwołania do zasobów statycznych i dynamicznych są rozpoznawane przez patrząc <xref:System.Windows.FrameworkElement.Resources%2A> w górę przez drzewo logiczne dla kolekcji na początkowym żądającym `Resources` obiekcie, <xref:System.Windows.ResourceDictionary>a następnie kontynuując drzewo logiczne i sprawdzając każdą <xref:System.Windows.FrameworkElement> (lub) <xref:System.Windows.FrameworkContentElement>inną wartość zawierającą , prawdopodobnie zawierającą ten klucz. Drzewo logiczne jest używane do wyszukiwania zasobów, gdy zarówno drzewo logiczne, jak i drzewo wizualne są obecne. Aby uzyskać więcej informacji na temat słowników zasobów i wyszukiwania, zobacz [Zasoby XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>
### <a name="composition-of-the-logical-tree"></a>Skład drzewa logicznego  
 Drzewo logiczne jest zdefiniowane na poziomie struktury WPF, co oznacza, że element bazowy <xref:System.Windows.FrameworkElement> WPF, który jest najbardziej odpowiedni dla operacji drzewa logicznego, jest albo lub <xref:System.Windows.FrameworkContentElement>. Jednak, jak widać, jeśli rzeczywiście <xref:System.Windows.LogicalTreeHelper> używasz interfejsu API, drzewo logiczne <xref:System.Windows.FrameworkElement> czasami <xref:System.Windows.FrameworkContentElement>zawiera węzły, które nie są albo lub . Na przykład drzewo logiczne <xref:System.Windows.Controls.TextBlock.Text%2A> raportuje <xref:System.Windows.Controls.TextBlock>wartość , który jest ciągiem.  
  
<a name="override_logical_tree"></a>
### <a name="overriding-the-logical-tree"></a>Zastępowanie drzewa logicznego  
 Zaawansowani autorzy formantów mogą zastąpić drzewo logiczne, zastępując kilka interfejsów API, które definiują sposób, w jaki ogólny obiekt lub model zawartości dodaje lub usuwa obiekty w drzewie logicznym. Aby uzyskać przykład zastępowania drzewa logicznego, zobacz [Zastępowanie drzewa logicznego](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>
### <a name="property-value-inheritance"></a>Przejęcie wartości właściwości  
 Dziedziczenie wartości właściwości działa za pośrednictwem drzewa hybrydowego. Rzeczywiste metadane, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> który zawiera właściwość, która umożliwia <xref:System.Windows.FrameworkPropertyMetadata> dziedziczenie właściwości jest klasą na poziomie struktury WPF. W związku z tym zarówno element nadrzędny, który przechowuje oryginalną <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>wartość i obiekt podrzędny, który dziedziczy tę wartość musi być zarówno lub , i muszą one być częścią niektórych drzew logicznych. Jednak dla istniejących właściwości WPF, które obsługują dziedziczenie właściwości, dziedziczenie wartości właściwości jest w stanie utrwalić za pośrednictwem interweniującego obiektu, który nie znajduje się w drzewie logicznym. Głównie jest to istotne dla posiadania elementów szablonu używać żadnych wartości właściwości dziedziczone ustawione w wystąpieniu, które jest szablonem lub na jeszcze wyższych poziomach kompozycji na poziomie strony i dlatego wyższe w drzewie logicznym. Aby dziedziczenie wartości właściwości działało konsekwentnie w takiej granicy, właściwość dziedzicząca musi być zarejestrowana jako dołączona właściwość i należy postępować zgodnie z tym wzorcem, jeśli zamierzasz zdefiniować właściwość zależności niestandardowej z właściwością zachowanie dziedziczenia. Dokładne drzewo używane do dziedziczenia właściwości nie można całkowicie przewidzieć przez metodę narzędzia klasy pomocnika, nawet w czasie wykonywania. Aby uzyskać więcej informacji, zobacz [Dziedziczenie wartości właściwości](property-value-inheritance.md).  
  
<a name="two_trees"></a>
## <a name="the-visual-tree"></a>Drzewo wizualne  
 Oprócz koncepcji drzewa logicznego, istnieje również koncepcja drzewa wizualnego [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]w . Drzewo wizualne opisuje strukturę obiektów wizualnych, <xref:System.Windows.Media.Visual> reprezentowane przez klasę podstawową. Podczas pisania szablonu formantu, definiujesz lub redefinicji drzewa wizualnego, który ma zastosowanie do tego formantu. Drzewo wizualne jest również interesujące dla deweloperów, którzy chcą niższego poziomu kontroli nad rysunkiem ze względu na wydajność i optymalizację. Jedną z ekspozycji drzewa wizualnego w ramach programowania konwencjonalnych [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacji jest to, że trasy zdarzeń dla kierowanego zdarzenia głównie podróżują wzdłuż drzewa wizualnego, a nie drzewa logicznego. Ta subtelność kierowanego zachowania zdarzenia może nie być natychmiast widoczne, chyba że jesteś autorem formantu. Routing zdarzeń za pośrednictwem drzewa wizualnego umożliwia formanty, które implementują kompozycję na poziomie wizualnym do obsługi zdarzeń lub tworzenia ustawiających zdarzenia.  
  
<a name="trees_content"></a>
## <a name="trees-content-elements-and-content-hosts"></a>Drzewa, elementy zawartości i hosty zawartości  
 Elementy zawartości (klasy, <xref:System.Windows.ContentElement>które wynikają z ) nie są częścią drzewa wizualnego; nie dziedziczą <xref:System.Windows.Media.Visual> po i nie mają wizualnej reprezentacji. Aby w ogóle pojawić się w <xref:System.Windows.ContentElement> interfejsie użytkownika, musi być hostowany <xref:System.Windows.Media.Visual> w hoście zawartości, który jest uczestnikiem drzewa logicznego i logicznym. Zazwyczaj taki obiekt <xref:System.Windows.FrameworkElement>jest . Można konceptualizować, że host zawartości jest nieco jak "przeglądarka" dla zawartości i wybiera sposób wyświetlania tej zawartości w regionie ekranu, który kontroluje hosta. Gdy zawartość jest hostowana, zawartość może być uczestnikiem niektórych procesów drzewa, które są zwykle skojarzone z drzewem wizualnym. Ogólnie rzecz <xref:System.Windows.FrameworkElement> biorąc klasa hosta zawiera kod <xref:System.Windows.ContentElement> implementacji, który dodaje dowolny hostowany do trasy zdarzenia za pośrednictwem podwęzłów drzewa logicznego zawartości, nawet jeśli hostowana zawartość nie jest częścią prawdziwego drzewa wizualnego. Jest to konieczne, <xref:System.Windows.ContentElement> aby można zaopatrywać się w kierowane zdarzenie, które kieruje do dowolnego elementu innego niż on sam.  
  
<a name="tree_traversal"></a>
## <a name="tree-traversal"></a>Przemierzanie drzewa  
 Klasa <xref:System.Windows.LogicalTreeHelper> zawiera <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>i <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metody przechodzenia drzewa logicznego. W większości przypadków nie należy przechodzić przez drzewo logiczne istniejących formantów, ponieważ te formanty prawie zawsze `Add`uwidaczniają ich logiczne elementy podrzędne jako dedykowaną właściwość kolekcji, która obsługuje dostęp do kolekcji, taki jak indeksator i tak dalej. Przechodzenie przez drzewo jest głównie scenariusz, który jest używany przez autorów kontroli, którzy nie zdecydują się pochodzić z zamierzonych wzorców kontroli, takich jak <xref:System.Windows.Controls.ItemsControl> lub <xref:System.Windows.Controls.Panel> gdzie właściwości kolekcji są już zdefiniowane i którzy zamierzają zapewnić własne obsługi właściwości kolekcji.  
  
 Drzewo wizualne obsługuje również klasę pomocnika dla <xref:System.Windows.Media.VisualTreeHelper>wizualnego przechodzenia drzewa, . Drzewo wizualne nie jest udostępniane tak wygodnie za pośrednictwem <xref:System.Windows.Media.VisualTreeHelper> właściwości specyficzne dla kontroli, więc klasa jest zalecany sposób przechodzenia przez drzewa wizualnego, jeśli jest to konieczne dla scenariusza programowania. Aby uzyskać więcej informacji, zobacz [Omówienie renderowania grafiki WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Czasami konieczne jest zbadanie drzewa wizualnego zastosowanego szablonu. Należy zachować ostrożność podczas korzystania z tej techniki. Nawet w przypadku przechodzenia przez drzewo wizualne dla formantu, w którym definiujesz szablon, konsumenci formantu zawsze mogą zmienić szablon, ustawiając <xref:System.Windows.Controls.Control.Template%2A> właściwość na wystąpieniach, a nawet użytkownik końcowy może wpływać na zastosowany szablon, zmieniając motyw systemowy.  
  
<a name="routes"></a>
## <a name="routes-for-routed-events-as-a-tree"></a>Trasy dla kierowanych zdarzeń jako "Drzewo"  
 Jak wspomniano wcześniej, trasa danego kierowanego zdarzenia przemieszcza się wzdłuż jednej i wstępnie określonej ścieżki drzewa, która jest hybrydą wizualnych i logicznych reprezentacji drzewa. Trasa zdarzenia może podróżować w górę lub w dół kierunków w obrębie drzewa w zależności od tego, czy jest to tunelowanie lub propagowanie kierowane zdarzenie. Koncepcja trasy zdarzenia nie ma bezpośrednio obsługujących klasy pomocnika, które mogą służyć do "spacer" trasy zdarzenia niezależnie od wywoływania zdarzenia, które faktycznie trasy. Istnieje klasa, która reprezentuje <xref:System.Windows.EventRoute>trasę, ale metody tej klasy są zazwyczaj tylko do użytku wewnętrznego.  
  
<a name="resourcesandtrees"></a>
## <a name="resource-dictionaries-and-trees"></a>Słowniki zasobów i drzewa  
 Wyszukiwanie słownika zasobów `Resources` dla wszystkich zdefiniowanych na stronie przechodzi zasadniczo drzewa logicznego. Obiekty, które nie znajdują się w drzewie logicznym, mogą odwoływać się do zasobów z kluczem, ale sekwencja wyszukiwania zasobów rozpoczyna się w punkcie, w którym ten obiekt jest połączony z drzewem logicznym. W WPF TYLKO węzły drzewa `Resources` logicznego może <xref:System.Windows.ResourceDictionary>mieć właściwość, która zawiera , w związku z tym <xref:System.Windows.ResourceDictionary>nie ma żadnych korzyści w przechodzenie przez drzewa wizualnego szuka klucza zasobów z .  
  
 Jednak wyszukiwanie zasobów może również wykraczać poza natychmiastowe drzewo logiczne. W przypadku znaczników aplikacji wyszukiwanie zasobów można następnie kontynuować do słowników zasobów na poziomie aplikacji, a następnie do obsługi motywu i wartości systemowych, które są przywoływać jako właściwości statyczne lub klucze. Same motywy mogą również odwoływać się do wartości systemowych poza drzewem logicznym motywu, jeśli odwołania do zasobów są dynamiczne. Aby uzyskać więcej informacji na temat słowników zasobów i logiki wyszukiwania, zobacz [Zasoby XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>Zobacz też

- [Przegląd Dane wejściowe](input-overview.md)
- [Przegląd Renderowanie grafiki WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Przegląd Zdarzenia trasowane](routed-events-overview.md)
- [Inicjowanie elementów obiektu poza drzewem obiektu](initialization-for-object-elements-not-in-an-object-tree.md)
- [Architektura WPF](wpf-architecture.md)
