---
title: Drzewa w WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 1b1763f2fcad60da757a3d6ff23dc289e7506ead
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/22/2019
ms.locfileid: "69966093"
---
# <a name="trees-in-wpf"></a>Drzewa w WPF
W wielu technologiach elementy i składniki są zorganizowane w strukturze drzewa, gdzie deweloperzy mogą bezpośrednio manipulować węzłami obiektów w drzewie, aby wpływać na renderowanie lub zachowanie aplikacji. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]używa także kilku metafory struktury drzewa do definiowania relacji między elementami programu. W przypadku większości programistów deweloperzy mogą tworzyć aplikacje w kodzie lub definiować fragmenty aplikacji w języku XAML, a jednocześnie zastanawiać się o metaphor drzewa obiektów, ale będą wywoływały określony interfejs API lub przy użyciu określonego znacznika, aby to zrobić, a nie ogólnie Interfejs API manipulowania drzewem obiektów, taki jak można użyć w modelu XML DOM. WPF uwidacznia dwie klasy pomocników, które udostępniają widok <xref:System.Windows.LogicalTreeHelper> metaphor drzewa i. <xref:System.Windows.Media.VisualTreeHelper> Warunki drzewa wizualnego i drzewa logicznego są również używane w dokumentacji WPF, ponieważ te same drzewa są przydatne do poznania zachowań niektórych kluczowych funkcji WPF. W tym temacie opisano, co reprezentuje drzewo wizualne i logiczne drzewo, omówiono sposób, w jaki te drzewa odnoszą się do ogólnej koncepcji <xref:System.Windows.LogicalTreeHelper> drzewa <xref:System.Windows.Media.VisualTreeHelper>obiektów i wprowadza i s.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Drzewa w WPF  
 Najbardziej kompletna struktura drzewa w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] programie to drzewo obiektów. W przypadku zdefiniowania strony aplikacji w [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] programie [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], a następnie załadowania, struktura drzewa jest tworzona na podstawie zagnieżdżenia relacji elementów w znaczniku. Jeśli zdefiniujesz aplikację lub część aplikacji w kodzie, struktura drzewa jest tworzona w oparciu o sposób przypisywania wartości właściwości dla właściwości implementujących model zawartości dla danego obiektu. W [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]programie istnieją dwa sposoby koncepcyjnego tworzenia całego drzewa obiektów i mogą być zgłaszane do jego publicznego interfejsu API: jako Drzewo logiczne i jako drzewo wizualne. Różnice między drzewem logicznym a drzewem wizualnym nie zawsze muszą być ważne, ale mogą sporadycznie powodować problemy [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] z pewnymi podsystemami i wpływać na wybory wprowadzane w znacznikach lub kodzie.  
  
 Mimo że nie zawsze manipuluj bezpośrednio drzewa logiczne lub drzewa wizualnego, zrozumienie koncepcji współdziałania drzew jest przydatne do poznania WPF jako technologii. Zastanawiasz się, że WPF jako metaphor drzewa niektórych rodzajów jest również decydujący, aby zrozumieć sposób działania [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]dziedziczenia właściwości i routingu zdarzeń.  
  
> [!NOTE]
> Ponieważ drzewo obiektów jest bardziej koncepcją niż rzeczywisty interfejs API, inny sposób, aby myśleć o koncepcji, jest obiektem grafu obiektów. W programie istnieją relacje między obiektami w czasie wykonywania, gdzie drzewo metaphor zostanie zerwane. Niemniej jednak, szczególnie w przypadku interfejsu użytkownika zdefiniowanego w języku XAML, drzewo metaphor jest wystarczające, aby większość dokumentacji WPF korzystała z terminu drzewa obiektów podczas odwoływania się do tej koncepcji ogólnej.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Drzewo logiczne  
 W [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]programie należy dodać zawartość do elementów interfejsu użytkownika przez ustawienie właściwości obiektów, które wykonują te elementy. Można na przykład dodać elementy do <xref:System.Windows.Controls.ListBox> kontrolki przez manipulowanie jej <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwością. Dzięki temu umieszczasz elementy w <xref:System.Windows.Controls.ItemCollection> <xref:System.Windows.Controls.ItemsControl.Items%2A> wartości właściwości. Podobnie, aby dodać obiekty do <xref:System.Windows.Controls.DockPanel>, można manipulować jej <xref:System.Windows.Controls.Panel.Children%2A> wartością właściwości. Tutaj dodajesz obiekty do <xref:System.Windows.Controls.UIElementCollection>. Aby uzyskać przykład kodu, zobacz [How to: Dodaj element dynamicznie](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 W [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]programie, gdy umieszczasz elementy listy <xref:System.Windows.Controls.ListBox> w kontrolkach lub <xref:System.Windows.Controls.DockPanel>innych elementach interfejsu użytkownika w programie, możesz również <xref:System.Windows.Controls.ItemsControl.Items%2A> użyć <xref:System.Windows.Controls.Panel.Children%2A> właściwości i albo jawnie lub niejawnie, jak w poniższym przykładzie.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Jeśli chcesz przetworzyć ten kod XAML jako kod XML w modelu obiektów dokumentu, a w przypadku dołączenia tagów oznaczonych jako niejawne (które byłyby dozwolone), utworzone drzewo XML dom będzie zawierało elementy dla `<ListBox.Items>` i inne niejawne elementy. Chociaż język XAML nie przetworzy się w ten sposób podczas odczytywania znaczników i zapisu do obiektów, powstaje wykres obiektów, który nie `ListBox.Items`jest dosłownie. Istnieje <xref:System.Windows.Controls.ListBox> jednak właściwość o nazwie <xref:System.Windows.Controls.ItemCollection> `Items` , która zawiera, <xref:System.Windows.Controls.ListBox> i która <xref:System.Windows.Controls.ItemCollection> została zainicjowana, ale pusta, gdy jest przetwarzany kod XAML. Następnie każdy element podrzędny obiektu, który istnieje jako zawartość dla programu <xref:System.Windows.Controls.ListBox> , jest dodawany <xref:System.Windows.Controls.ItemCollection> do wywołania `ItemCollection.Add`przez analizator składni. Ten przykład przetwarzania kodu XAML do drzewa obiektów jest w tej chwili prawdopodobnie przykładem, gdzie utworzone drzewo obiektów jest zasadniczo drzewem logicznym.  
  
 Jednak Drzewo logiczne to nie cały Graf obiektów, który istnieje dla interfejsu użytkownika aplikacji w czasie wykonywania, nawet z niejawnymi elementami składni XAML. Główną przyczyną tego są wizualizacje i szablony. Rozważmy na przykład <xref:System.Windows.Controls.Button>. Drzewo logiczne raportuje <xref:System.Windows.Controls.Button> obiekt, a także jego ciąg `Content`. Jednak więcej informacji na ten temat znajduje się w drzewie obiektów czasu wykonywania. W szczególności przycisk pojawia się tylko na ekranie w taki sposób, że został zastosowany <xref:System.Windows.Controls.Button> określony szablon formantu. Wizualizacje, które pochodzą z zastosowanego szablonu (takie jak zdefiniowane <xref:System.Windows.Controls.Border> przez szablon ciemnego koloru dookoła przycisku wizualizacji), nie są zgłaszane w drzewie logicznym, nawet jeśli przeglądasz Drzewo logiczne w czasie wykonywania (na przykład obsługujące Zdarzenie wejściowe z widoczny interfejs użytkownika, a następnie odczytywanie drzewa logicznego). Aby znaleźć wizualizacje szablonu, należy przeanalizować drzewo wizualne.  
  
 Aby uzyskać więcej informacji na [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] temat sposobu mapowania składni na wykres utworzonego obiektu i niejawnej składni w języku XAML, zobacz [składnia języka XAML w temacie szczegóły](xaml-syntax-in-detail.md) lub [XAML — Omówienie (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Cel drzewa logicznego  
 Drzewo logiczne istnieje, dzięki czemu modele zawartości mogą łatwo wykonywać iteracje na możliwych obiektach podrzędnych, dzięki czemu modele zawartości mogą być rozszerzalne. Ponadto Drzewo logiczne udostępnia strukturę dla pewnych powiadomień, na przykład w przypadku załadowania wszystkich obiektów w drzewie logicznym. Zasadniczo logiczne drzewo to przybliżenie grafu obiektu czasu wykonywania na poziomie struktury, który wyklucza wizualizacje, ale jest odpowiednie dla wielu operacji wykonywania zapytań w odniesieniu do własnej kompozycji aplikacji czasu wykonywania.  
  
 Ponadto zarówno statyczne, jak i dynamiczne odwołania do zasobów są rozwiązywane przez przeglądanie w górę drzewa logicznego <xref:System.Windows.FrameworkElement.Resources%2A> dla kolekcji w początkowym obiekcie żądającym, a następnie kontynuowanie drzewa logicznego i sprawdzanie <xref:System.Windows.FrameworkElement> każdego (lub <xref:System.Windows.FrameworkContentElement>) dla innej `Resources` wartości, która <xref:System.Windows.ResourceDictionary>zawiera, może zawierać ten klucz. Drzewo logiczne służy do wyszukiwania zasobów, gdy są obecne zarówno Drzewo logiczne, jak i drzewo wizualne. Aby uzyskać więcej informacji na temat słowników zasobów i wyszukiwania, zobacz [zasoby XAML](xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Kompozycja drzewa logicznego  
 Drzewo logiczne jest zdefiniowane na poziomie platformy WPF, co oznacza, że element bazy WPF, który jest najbardziej istotny dla operacji drzewa logicznego, to <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>. Jednak w miarę jak można sprawdzić, czy w <xref:System.Windows.LogicalTreeHelper> rzeczywistości używasz interfejsu API, Drzewo logiczne czasami zawiera węzły, które <xref:System.Windows.FrameworkElement> nie <xref:System.Windows.FrameworkContentElement>są albo. Na przykład, Drzewo logiczne raportuje <xref:System.Windows.Controls.TextBlock.Text%2A> wartość a <xref:System.Windows.Controls.TextBlock>, która jest ciągiem.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Zastępowanie drzewa logicznego  
 Autorzy zaawansowanej kontroli mogą przesłonić Drzewo logiczne przez zastępowanie kilku interfejsów API, które definiują, jak obiekt ogólny lub model zawartości dodaje lub usuwa obiekty w drzewie logicznym. Aby zapoznać się z przykładem sposobu przesłonięcia drzewa logicznego, zobacz [przesłanianie drzewa logicznego](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Przejęcie wartości właściwości  
 Dziedziczenie wartości właściwości działa przez drzewo hybrydowe. Rzeczywista wartość metadanych, która <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> zawiera właściwość, która umożliwia dziedziczenie właściwości, jest klasą na poziomie <xref:System.Windows.FrameworkPropertyMetadata> platformy WPF. W związku z tym zarówno element nadrzędny, który posiada oryginalną wartość, jak i obiekt podrzędny, który dziedziczy <xref:System.Windows.FrameworkElement> tę <xref:System.Windows.FrameworkContentElement>wartość, musi być lub, i oba muszą być częścią drzewa logicznego. Jednak dla istniejących właściwości WPF, które obsługują dziedziczenie właściwości, dziedziczenie wartości właściwości jest możliwe perpetuate przez obiekt, który nie znajduje się w drzewie logicznym. Głównie ma to zastosowanie w przypadku, gdy elementy szablonu używają wszelkich dziedziczonych wartości właściwości ustawionych w przypadku wystąpienia, które jest szablonem lub na jeszcze wyższym poziomie kompozycji na poziomie strony i w związku z tym wyższe w drzewie logicznym. Aby dziedziczenie wartości właściwości działało spójnie między takimi granicami, właściwość dziedziczenia musi być zarejestrowana jako dołączona właściwość i należy przestrzegać tego wzorca, jeśli zamierzasz zdefiniować niestandardową właściwość zależności z właściwością zachowanie dziedziczenia. Dokładne drzewo używane do dziedziczenia właściwości nie może być całkowicie przewidziane przez metodę narzędzia klasy pomocnika, nawet w czasie wykonywania. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Drzewo wizualne  
 Oprócz koncepcji drzewa logicznego istnieje również koncepcja drzewa wizualnego w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. W drzewie wizualnym opisano strukturę obiektów wizualizacji, które są reprezentowane przez <xref:System.Windows.Media.Visual> klasę bazową. Podczas pisania szablonu dla kontrolki definiujesz lub ponownie zdefiniujesz drzewo wizualne, które ma zastosowanie do tej kontrolki. Drzewo wizualne jest również przydatne dla deweloperów, którzy chcą mieć niższy poziom kontroli nad rysowaniem ze względu na wydajność i optymalizację. Jedno narażenie na drzewo wizualne jako część konwencjonalnego [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] programowania aplikacji polega na tym, że trasy zdarzeń dla zdarzenia kierowanego przeważnie podróżują do drzewa wizualnego, a nie drzewa logicznego. Subtlety zachowanie zdarzeń kierowanych może nie być od razu widoczne, chyba że jesteś autorem kontrolki. Zdarzenia routingu za pomocą drzewa wizualnego umożliwiają kontrolom implementującym kompozycję na poziomie wizualizacji do obsługi zdarzeń lub tworzenia metod ustawiających zdarzenia.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Drzewa, elementy zawartości i hosty zawartości  
 Elementy zawartości (klasy, które pochodzą <xref:System.Windows.ContentElement>z) nie są częścią drzewa wizualnego; nie dziedziczą po <xref:System.Windows.Media.Visual> i nie mają reprezentacji wizualnej. Aby w interfejsie użytkownika w ogóle znajdować się, <xref:System.Windows.ContentElement> musi on być hostowany na hoście zawartości, który jest <xref:System.Windows.Media.Visual> i jest uczestnikiem drzewa logicznego. Zwykle jest <xref:System.Windows.FrameworkElement>to obiekt. Można konceptualizacji, że host zawartości jest nieco podobny do "przeglądarki" dla zawartości i wybiera sposób wyświetlania tej zawartości w obszarze ekranu, który kontroluje hosta. Gdy zawartość jest hostowana, zawartość może zostać wykonana w pewnych procesach drzewa, które są zwykle skojarzone z drzewem wizualnym. Ogólnie rzecz biorąc <xref:System.Windows.FrameworkElement> , Klasa hosta zawiera kod implementacji, który dodaje <xref:System.Windows.ContentElement> wszystkie hosty do trasy zdarzeń za pośrednictwem podwęzłów drzewa logicznego zawartości, nawet jeśli hostowana zawartość nie jest częścią rzeczywistego drzewa wizualnego. Jest to konieczne, aby <xref:System.Windows.ContentElement> możliwe było Źródło zdarzenia kierowanego, które kieruje do dowolnego elementu innego niż sam.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Przechodzenie drzewa  
 Klasa zawiera metody<xref:System.Windows.LogicalTreeHelper.GetParent%2A>,, i<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> dla przechodzenia drzewa logicznego. <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> <xref:System.Windows.LogicalTreeHelper> W większości przypadków nie powinno być konieczne przechodzenie między logicznym drzewem istniejących kontrolek, ponieważ te kontrolki prawie zawsze uwidaczniają swoje logiczne elementy podrzędne jako dedykowaną Właściwość kolekcji, która obsługuje dostęp `Add`do kolekcji, taki jak indeksator, i tak dalej. Przechodzenie drzewa jest głównie scenariuszem, który jest używany przez autorów kontroli, którzy nie muszą dziedziczyć z zamierzonych <xref:System.Windows.Controls.Panel> wzorców kontrolek, takich jak <xref:System.Windows.Controls.ItemsControl> lub gdzie właściwości kolekcji są już zdefiniowane, i którzy chcą zapewnić własną kolekcję Obsługa właściwości.  
  
 Drzewo wizualne obsługuje również klasę pomocnika na potrzeby przechodzenia <xref:System.Windows.Media.VisualTreeHelper>do drzewa wizualnego. Drzewo wizualizacji nie jest widoczne jako wygodnie za pomocą właściwości specyficznych dla kontroli <xref:System.Windows.Media.VisualTreeHelper> , więc Klasa jest zalecanym sposobem przechodzenia do drzewa wizualnego, jeśli jest to konieczne w scenariuszu programowania. Aby uzyskać więcej informacji, zobacz [Omówienie renderowania grafiki WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Czasami konieczne jest przeanalizowanie drzewa wizualnego zastosowanego szablonu. Należy zachować ostrożność podczas korzystania z tej techniki. Nawet jeśli przejdziesz do drzewa wizualnego dla kontrolki, w której definiujesz szablon, odbiorcy kontrolki zawsze mogą zmienić szablon, ustawiając <xref:System.Windows.Controls.Control.Template%2A> właściwość w wystąpieniach, a nawet użytkownik końcowy może mieć wpływ na zastosowany szablon, zmieniając motyw systemowy.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Trasy dla zdarzeń kierowanych jako "drzewo"  
 Jak wspomniano wcześniej, trasa danego zdarzenia kierowanego jest transmitowana wzdłuż jednej i wstępnie określonej ścieżki drzewa, która jest hybrydową reprezentacją drzewa wizualnego i logicznego. Trasa zdarzenia może poruszać się w kierunku w górę lub w dół w drzewie, w zależności od tego, czy jest to zdarzenie tunelowania czy propagacji. Koncepcja trasy zdarzenia nie ma bezpośredniej pomocniczej klasy pomocniczej, która może służyć do "przeszukiwania" trasy zdarzenia niezależnie od podniesienia zdarzenia, które faktycznie kieruje trasy. Istnieje Klasa, która reprezentuje trasę, <xref:System.Windows.EventRoute>ale metody tej klasy są zwykle wyłącznie do użytku wewnętrznego.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Słowniki zasobów i drzewa  
 Funkcja wyszukiwania słowników zasobów `Resources` dla wszystkich zdefiniowanych na stronie przechodzi w zasadzie do drzewa logicznego. Obiekty, które nie znajdują się w drzewie logicznym, mogą odwoływać się do zasobów z ograniczeniami, ale sekwencja wyszukiwania zasobów rozpoczyna się w punkcie, w którym ten obiekt jest podłączony do drzewa logicznego. W WPF tylko logiczne węzły drzewa mogą mieć `Resources` właściwość, która zawiera a <xref:System.Windows.ResourceDictionary>, dlatego nie ma żadnych korzyści w przechodzeniu drzewa wizualnego w <xref:System.Windows.ResourceDictionary>poszukiwaniu zasobów z.  
  
 Jednak wyszukiwanie zasobów może również wykraczać poza bezpośrednie Drzewo logiczne. W przypadku znaczników aplikacji Wyszukiwanie zasobów może potem przejść dalej do słowników zasobów na poziomie aplikacji, a następnie do obsługi motywów i wartości systemowych, do których odwołują się jako właściwości statyczne lub klucze. Same motywy mogą również odwoływać się do wartości systemowych poza drzewem logicznym motywu, jeśli odwołania do zasobów są dynamiczne. Aby uzyskać więcej informacji na temat słowników zasobów i logiki wyszukiwania, zobacz [zasoby XAML](xaml-resources.md).  
  
## <a name="see-also"></a>Zobacz także

- [Przegląd danych wejściowych](input-overview.md)
- [Renderowanie grafiki WPF — przegląd](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Przegląd zdarzeń trasowanych](routed-events-overview.md)
- [Inicjowanie elementów obiektu poza drzewem obiektu](initialization-for-object-elements-not-in-an-object-tree.md)
- [Architektura WPF](wpf-architecture.md)
