---
title: TypeConverters i XAML
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
caps.latest.revision: "13"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 073730382f98a6c3d61ebdadf4f1f74411ba4e63
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2017
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="08a1c-102">TypeConverters i XAML</span><span class="sxs-lookup"><span data-stu-id="08a1c-102">TypeConverters and XAML</span></span>
<span data-ttu-id="08a1c-103">W tym temacie przedstawiono celem konwersji typu z ciągu jako ogólne funkcji języka XAML.</span><span class="sxs-lookup"><span data-stu-id="08a1c-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="08a1c-104">W programie .NET Framework <xref:System.ComponentModel.TypeConverter> klasy służy określonego celu jako część wdrożenia dla zarządzanej klasy niestandardowych, które mogą być używane jako wartości właściwości w języku XAML, użycie atrybutu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="08a1c-105">Jeśli zapisu niestandardowej klasy, a ma wystąpień klasy może być używany jako wartości można ustawić atrybutów pliku XAML, może być konieczne zastosowanie <xref:System.ComponentModel.TypeConverterAttribute> do własnej klasy zapisu niestandardowego <xref:System.ComponentModel.TypeConverter> lub klasę.</span><span class="sxs-lookup"><span data-stu-id="08a1c-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  
  

  
## <a name="type-conversion-concepts"></a><span data-ttu-id="08a1c-106">Pojęcia dotyczące konwersji typu</span><span class="sxs-lookup"><span data-stu-id="08a1c-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="08a1c-107">XAML i wartości ciągu</span><span class="sxs-lookup"><span data-stu-id="08a1c-107">XAML and String Values</span></span>  
 <span data-ttu-id="08a1c-108">Gdy wartość atrybutu jest ustawiona w pliku XAML, typ początkowej wartości to ciąg w formie czystego tekstu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="08a1c-109">Nawet w przypadku innych podstawowych, takich jak <xref:System.Double> są początkowo ciągów tekstowych procesora XAML.</span><span class="sxs-lookup"><span data-stu-id="08a1c-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="08a1c-110">Procesor XAML wymaga dwóch rodzajów informacji, aby przetworzyć wartości atrybutu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="08a1c-111">Pierwszy element danych jest typ wartości właściwości, która jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="08a1c-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="08a1c-112">Dowolny ciąg, który definiuje wartość atrybutu i przetworzony w języku XAML ostatecznie muszą być konwertowane lub został rozpoznany jako wartość tego typu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="08a1c-113">Jeśli wartość jest typu pierwotnego, który jest rozpoznawany przez parser XAML (na przykład wartość liczbowa), próbą bezpośredniego Konwersja ciągu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="08a1c-114">Jeśli wartość to wyliczanie, ten ciąg jest używany do sprawdzenia pod kątem dopasowania nazwy do nazwanej stałej w tym wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="08a1c-115">Jeśli wartość jest ani typu pierwotnego zrozumiał analizator ani wyliczeniem, a następnie danego typu musi mieć możliwość zapewnienia wystąpienia typu lub wartości, w oparciu o skonwertowany ciąg.</span><span class="sxs-lookup"><span data-stu-id="08a1c-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="08a1c-116">Jest to realizowane wskazując klasa konwertera typu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="08a1c-117">Konwerter typów jest klasa pomocy dla zapewniający wartości z innej klasy, zarówno w przypadku scenariusza XAML i również potencjalnie kod wywołuje w kodu platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="08a1c-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="08a1c-118">Przy użyciu istniejących zachowanie konwersji typu w XAML</span><span class="sxs-lookup"><span data-stu-id="08a1c-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="08a1c-119">W zależności od użytkownika znajomości podstawowe pojęcia języka XAML już używasz zachowanie konwersji typu w aplikacji w warstwie podstawowa XAML bez wiedzy.</span><span class="sxs-lookup"><span data-stu-id="08a1c-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="08a1c-120">Na przykład WPF definiuje dosłownie setki właściwości, które przyjmują wartości typu <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="08a1c-121">A <xref:System.Windows.Point> to wartość, która opisuje współrzędnych w dwuwymiarowa przestrzeni współrzędnych i naprawdę właśnie ma dwie ważne właściwości: <xref:System.Windows.Point.X%2A> i <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="08a1c-122">Po określeniu punktu w języku XAML, możesz podać go jako ciąg ogranicznikiem (zazwyczaj przecinkami) między <xref:System.Windows.Point.X%2A> i <xref:System.Windows.Point.Y%2A> podanie wartości.</span><span class="sxs-lookup"><span data-stu-id="08a1c-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="08a1c-123">Na przykład: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span><span class="sxs-lookup"><span data-stu-id="08a1c-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span></span>  
  
 <span data-ttu-id="08a1c-124">Nawet tego prostego typu <xref:System.Windows.Point> i jego prosty sposób użycia w języku XAML może dotyczyć konwertera typów.</span><span class="sxs-lookup"><span data-stu-id="08a1c-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="08a1c-125">W tym przypadku jest to klasa <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="08a1c-126">Konwerter typu dla <xref:System.Windows.Point> zdefiniowana w klasie poziomu usprawnia użycia znaczników wszystkich właściwości, które przyjmują <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="08a1c-127">Bez konwertera typów w tym miejscu, będzie potrzebny następujące pełniejsze znaczników o tym samym przykładzie pokazano wcześniej:</span><span class="sxs-lookup"><span data-stu-id="08a1c-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  
  
 `<LinearGradientBrush>`  
  
 `<LinearGradientBrush.StartPoint>`  
  
 `<Point X="0" Y="0"/>`  
  
 `</LinearGradientBrush.StartPoint>`  
  
 `<LinearGradientBrush.EndPoint>`  
  
 `<Point X="1" Y="1"/>`  
  
 `</LinearGradientBrush.EndPoint>`  
  
 `<LinearGradientBrush>`  
  
 <span data-ttu-id="08a1c-128">Ogólnie jest typu string konwersji lub więcej Pełna składnia równoważne wybór styl kodowania.</span><span class="sxs-lookup"><span data-stu-id="08a1c-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="08a1c-129">Narzędzia XAML przepływu pracy mogą również mieć wpływ jak wartości są ustawiane.</span><span class="sxs-lookup"><span data-stu-id="08a1c-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="08a1c-130">Niektóre narzędzia XAML zazwyczaj Emituj najpełniejszych formę kod znaczników, ponieważ ułatwia przesłania danych do projektanta widoków lub mechanizm serializacji.</span><span class="sxs-lookup"><span data-stu-id="08a1c-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="08a1c-131">Istniejące typy konwerterów zazwyczaj mogły być odnajdowane w typach WPF i .NET Framework przez sprawdzanie obecności zastosowane klasy (lub właściwości) <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="08a1c-132">Ten atrybut zostanie nazwę klasy, która jest obsługi konwerter typów dla wartości tego typu, dla celów XAML oraz potencjalnie innych celów.</span><span class="sxs-lookup"><span data-stu-id="08a1c-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="08a1c-133">Typy konwerterów i rozszerzeń znaczników</span><span class="sxs-lookup"><span data-stu-id="08a1c-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="08a1c-134">Konwertery rozszerzenia i typ znaczników pełnienia ról prostopadły pod względem zachowanie procesora XAML i scenariusze, które są stosowane do.</span><span class="sxs-lookup"><span data-stu-id="08a1c-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="08a1c-135">Mimo że kontekst jest dostępny do użycia rozszerzenia znaczników, zachowanie konwersji typu właściwości, gdy rozszerzenie znaczników zapewnia wartość jest zazwyczaj nie zostanie zaznaczona w implementacji rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="08a1c-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="08a1c-136">Innymi słowy nawet wtedy, gdy rozszerzenie znaczników zwraca ciąg tekstowy jako jego `ProvideValue` output, zachowanie konwersji typu dla tego ciągu jako dotyczą określoną właściwość lub typ wartości właściwości nie jest wywoływany, ogólnie rzecz biorąc, rozszerzeniem znacznika ma na celu procesu ciąg i zwracać obiekt bez żadnych konwerter typów związane.</span><span class="sxs-lookup"><span data-stu-id="08a1c-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="08a1c-137">Jeden sytuacja rozszerzenie znaczników w przypadku potrzeby zamiast konwertera typów jest odwołanie do obiektu, który już istnieje.</span><span class="sxs-lookup"><span data-stu-id="08a1c-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="08a1c-138">W najlepszym konwertera typów bezstanowych można generować tylko nowe wystąpienie nie może być pożądane.</span><span class="sxs-lookup"><span data-stu-id="08a1c-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="08a1c-139">Aby uzyskać więcej informacji na rozszerzenia znaczników, zobacz [rozszerzenia znaczników i WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="08a1c-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="08a1c-140">Konwertery typu macierzystego</span><span class="sxs-lookup"><span data-stu-id="08a1c-140">Native Type Converters</span></span>  
 <span data-ttu-id="08a1c-141">W implementacji WPF i .NET Framework analizatora języka XAML Brak niektórych typów, które mają Obsługa konwersji typu macierzystego, jeszcze nie są typy, które tradycyjnie mogą być uważane za nim elementów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="08a1c-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="08a1c-142">Przykładem takiego typu <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="08a1c-143">Przyczyną tego jest oparta na działanie architektury .NET Framework: typ <xref:System.DateTime> jest zdefiniowany w mscorlib, najbardziej podstawowa Biblioteka programu .NET.</span><span class="sxs-lookup"><span data-stu-id="08a1c-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="08a1c-144"><xref:System.DateTime>nie może mieć atrybut atrybut, który pochodzi z innego zestawu, który wprowadzono zależność (<xref:System.ComponentModel.TypeConverterAttribute> z System), mechanizmu odnajdywania konwertera typu zwykle poprzez przypisywanie nie może być obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="08a1c-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="08a1c-145">Zamiast tego analizatora XAML zawiera listę typów, które wymagają natywnego przetwarzania i przetwarza je podobnie do sposobu przetwarzania podstawowych wartość true.</span><span class="sxs-lookup"><span data-stu-id="08a1c-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="08a1c-146">(W przypadku liczby <xref:System.DateTime> obejmuje to wywołanie <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="08a1c-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="08a1c-147">Implementowanie konwertera typów</span><span class="sxs-lookup"><span data-stu-id="08a1c-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="08a1c-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="08a1c-148">TypeConverter</span></span>  
 <span data-ttu-id="08a1c-149">W <xref:System.Windows.Point> przykładzie wcześniej, klasa <xref:System.Windows.PointConverter> wspomniano.</span><span class="sxs-lookup"><span data-stu-id="08a1c-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="08a1c-150">W przypadku implementacji .NET XAML, wszystkie typy konwerterów, które są używane do celów XAML są klasy, które pochodzi od klasy podstawowej <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="08a1c-151"><xref:System.ComponentModel.TypeConverter> Klasy istniał w wersji programu .NET Framework, które należy poprzedzić istnienie XAML; jeden z jego oryginalnej użycia jest zapewnienie Konwersja ciągu w oknach dialogowych właściwości w wizualnych projektantów.</span><span class="sxs-lookup"><span data-stu-id="08a1c-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="08a1c-152">Dla języka XAML, rola <xref:System.ComponentModel.TypeConverter> jest rozszerzona w celu uwzględnienia jest klasą bazową dla konwersji do ciągu i z ciągu, które umożliwiają analizowanie wartość ciągu atrybutu i prawdopodobnie przetwarzania wartość czasu wykonywania właściwości określonego obiektu na ciąg w celu Serializacja jako atrybut.</span><span class="sxs-lookup"><span data-stu-id="08a1c-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="08a1c-153"><xref:System.ComponentModel.TypeConverter>definiuje cztery elementów członkowskich, które mają zastosowanie do konwertowania do i z ciągów w celu przetwarzania XAML:</span><span class="sxs-lookup"><span data-stu-id="08a1c-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="08a1c-154">Z powyższych najważniejszych metoda jest <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="08a1c-155">Ta metoda konwertuje ciągu wejściowego z typem wymaganego obiektu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="08a1c-156">Mówiąc ściślej <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementacji konwertować znacznie większej liczby typów konwertera typu przeznaczenia i w związku z tym służyć do celów, które wykraczają poza XAML, takich jak obsługa konwersje czasu wykonywania, ale dla celów XAML — metoda jest to ścieżka kodu, który może przetwarzać <xref:System.String> danych wejściowych, który ma znaczenie.</span><span class="sxs-lookup"><span data-stu-id="08a1c-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="08a1c-157">Metoda najważniejszych dalej jest <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="08a1c-158">Jeśli aplikacja jest konwertowana na reprezentacji znacznika (na przykład, jeśli plik jest zapisywany w języku XAML jako plik), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> jest odpowiedzialny za tworzenie reprezentacji znacznika.</span><span class="sxs-lookup"><span data-stu-id="08a1c-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="08a1c-159">W takim przypadku ścieżkę kodu, który ma znaczenie dla XAML jest podczas przekazywania `destinationType` z <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="08a1c-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="08a1c-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>i <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> metod obsługi, które są używane, gdy usługa wysyła zapytanie do możliwości <xref:System.ComponentModel.TypeConverter> implementacji.</span><span class="sxs-lookup"><span data-stu-id="08a1c-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="08a1c-161">Musisz zaimplementować tych metod, aby zwrócić `true` dla określonego typu przypadków, które obsługują metody konwersji w równoważnych z konwertera.</span><span class="sxs-lookup"><span data-stu-id="08a1c-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="08a1c-162">Do celów XAML, zwykle oznacza to <xref:System.String> typu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="08a1c-163">Informacje o ustawieniach kulturowych i typy konwerterów dla XAML</span><span class="sxs-lookup"><span data-stu-id="08a1c-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="08a1c-164">Każdy <xref:System.ComponentModel.TypeConverter> implementacji ma własną interpretacji, co stanowi prawidłowy ciąg dla konwersji i można również użyć lub Ignoruj opisu typu przekazywane jako parametry.</span><span class="sxs-lookup"><span data-stu-id="08a1c-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="08a1c-165">Brak ważną kwestią w odniesieniu do kultury i konwersji typu XAML.</span><span class="sxs-lookup"><span data-stu-id="08a1c-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="08a1c-166">Przy użyciu Lokalizowalny ciągi jako wartości atrybutu jest całkowicie obsługiwana przez XAML.</span><span class="sxs-lookup"><span data-stu-id="08a1c-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="08a1c-167">Jednak przy użyciu tego ciągu Lokalizowalny jako dane wejściowe konwertera typu wymagania określoną kulturę, nie jest obsługiwana, ponieważ typy konwerterów dla XAML wartości atrybutów wymagają zachowania podczas analizowania niekoniecznie stałe języka, używając `en-US` kultury.</span><span class="sxs-lookup"><span data-stu-id="08a1c-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="08a1c-168">Aby uzyskać więcej informacji na projekt powody to ograniczenie, należy skonsultować się specyfikacja języka XAML ([\[MS XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525)).</span><span class="sxs-lookup"><span data-stu-id="08a1c-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="08a1c-169">Na przykład gdy kultura może być problem niektórych kultur użyć przecinka jako ich separator dziesiętny liczb.</span><span class="sxs-lookup"><span data-stu-id="08a1c-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="08a1c-170">Spowoduje to kolidują z ma wiele konwertery typu WPF XAML, który jest zastosowanie spacji, jak ogranicznik zachowanie (w oparciu o historycznych poprzedników, takich jak wspólne X, Y formularza lub przecinkami przecinkami listy).</span><span class="sxs-lookup"><span data-stu-id="08a1c-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="08a1c-171">Nawet przekazując kultury otaczającego XAML (ustawienie `Language` lub `xml:lang` do `sl-SI` kultury przykład kultura, która używa przecinek miejsc dziesiętnych w ten sposób) nie rozwiązuje problemu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="08a1c-172">Implementowanie ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="08a1c-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="08a1c-173">Może być używany jako <xref:System.ComponentModel.TypeConverter> implementacja obsługuje XAML, <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> metody dla tego konwertera, musisz zaakceptować ciąg jako `value` parametru.</span><span class="sxs-lookup"><span data-stu-id="08a1c-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="08a1c-174">Jeśli ciąg został nieprawidłowe formatowanie i może zostać skonwertowana za <xref:System.ComponentModel.TypeConverter> wdrożenia, a następnie zwrócony obiekt musi obsługiwać Rzutowanie na typ oczekiwany przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="08a1c-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="08a1c-175">W przeciwnym razie <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> musi zwracać implementację `null`.</span><span class="sxs-lookup"><span data-stu-id="08a1c-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="08a1c-176">Każdy <xref:System.ComponentModel.TypeConverter> implementacji ma własną interpretacji, co stanowi prawidłowy ciąg dla konwersji i można również użyć lub Ignoruj kontekstów opis lub kultury typu przekazywane jako parametry.</span><span class="sxs-lookup"><span data-stu-id="08a1c-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="08a1c-177">Jednak nie może przekazać wartości w kontekście opisu typu we wszystkich przypadkach WPF XAML przetwarzania, a także nie może przekazać opartą na `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="08a1c-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08a1c-178">Nie używaj znaków nawias klamrowy, szczególnie {, jako element możliwe formatu ciągu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="08a1c-179">Następujące znaki są zastrzeżone dla wejścia i wyjścia sekwencji rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="08a1c-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="08a1c-180">Implementowanie ConvertTo</span><span class="sxs-lookup"><span data-stu-id="08a1c-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="08a1c-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A>potencjalnie jest używana do obsługi serializacji.</span><span class="sxs-lookup"><span data-stu-id="08a1c-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="08a1c-182">Obsługa serializacji za pośrednictwem <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> dla danego typu niestandardowego i jej typ konwertera nie jest bezwzględnie spełniony.</span><span class="sxs-lookup"><span data-stu-id="08a1c-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="08a1c-183">Jednak jeśli implementacja formantu, lub za pomocą serializacji jako część funkcji lub projekt klasy, należy zaimplementować <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="08a1c-184">Może być używany jako <xref:System.ComponentModel.TypeConverter> implementacja obsługuje XAML, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> metody dla tego konwertera, musisz zaakceptować wystąpienia typu (lub wartość) są obsługiwane jako `value` parametru.</span><span class="sxs-lookup"><span data-stu-id="08a1c-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="08a1c-185">Gdy `destinationType` parametr jest typu <xref:System.String>, a następnie zwrócony obiekt musi mieć możliwość można rzutować jako <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="08a1c-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="08a1c-186">Zwracany ciąg musi reprezentować serializacji wartości `value`.</span><span class="sxs-lookup"><span data-stu-id="08a1c-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="08a1c-187">W idealnym przypadku powinien być może generować taką samą wartość, jeśli ten ciąg zostały przekazane do formatu serializacji, możesz wybrać <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementacji konwertera tego samego, bez znaczny poziom utraty danych.</span><span class="sxs-lookup"><span data-stu-id="08a1c-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="08a1c-188">Jeśli wartość nie może być serializowany lub konwerter nie obsługuje serializacji, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> musi zwracać implementację `null`i może zgłosić wyjątek, w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="08a1c-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="08a1c-189">Ale jeśli zgłaszają wyjątki, zgłoś używaniem tej konwersji w ramach Twojej <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementacji, aby najlepsze rozwiązanie polegające na sprawdzanie z <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> najpierw w celu uniknięcia wyjątków jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="08a1c-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="08a1c-190">Jeśli `destinationType` parametru nie jest typu <xref:System.String>, możesz wybrać własne Obsługa konwertera.</span><span class="sxs-lookup"><span data-stu-id="08a1c-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="08a1c-191">Zazwyczaj powodują implementacji podstawowej obsługi, które w basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08a1c-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="08a1c-192">Implementowanie CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="08a1c-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="08a1c-193">Twoje <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementacji powinien zwrócić `true` dla `destinationType` typu <xref:System.String>, a w przeciwnym razie odroczenie do podstawowej implementacji.</span><span class="sxs-lookup"><span data-stu-id="08a1c-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="08a1c-194">Implementowanie CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="08a1c-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="08a1c-195">Twoje <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementacji powinien zwrócić `true` dla `sourceType` typu <xref:System.String>, a w przeciwnym razie odroczenie do podstawowej implementacji.</span><span class="sxs-lookup"><span data-stu-id="08a1c-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="08a1c-196">Stosowanie TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="08a1c-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="08a1c-197">Aby Twoje konwertera typu niestandardowego ma być używany jako działający konwerter typów dla niestandardowej klasy przez procesor XAML, należy najpierw zastosować [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> do definicji klasy.</span><span class="sxs-lookup"><span data-stu-id="08a1c-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="08a1c-198"><xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> Użytkownika za pomocą atrybutu musi być nazwą typu z konwertera typu niestandardowego.</span><span class="sxs-lookup"><span data-stu-id="08a1c-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="08a1c-199">Z tym atrybutem stosowane gdy procesor XAML obsługi wartości, których typ właściwości używa danego typu klasy niestandardowej, można wejściowych ciągów i zwrócić wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="08a1c-200">Można też podać konwertera typów, na podstawie poszczególnych właściwości.</span><span class="sxs-lookup"><span data-stu-id="08a1c-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="08a1c-201">Zamiast stosowania [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> do definicji klasy zastosować je do definicji właściwości (główny definicji nie `get` / `set` implementacji w niej).</span><span class="sxs-lookup"><span data-stu-id="08a1c-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="08a1c-202">Typ właściwości musi odpowiadać typowi przetwarzanego przez użytkownika konwertera typu niestandardowego.</span><span class="sxs-lookup"><span data-stu-id="08a1c-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="08a1c-203">Z tym atrybutem zastosowane XAMLprocessor, obsługując wartości właściwości, można przetwarzać ciągów wejściowych i zwrócić wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="08a1c-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="08a1c-204">Dla właściwości typu konwertera technika jest szczególnie przydatne, jeśli chcesz użyć typu właściwości z [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] lub z niektórych biblioteki, której nie można kontrolować definicji klasy i nie można zastosować <xref:System.ComponentModel.TypeConverterAttribute> istnieje.</span><span class="sxs-lookup"><span data-stu-id="08a1c-204">The per-property type converter technique is particularly useful if you choose to use a property type from [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="08a1c-205">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="08a1c-205">See Also</span></span>  
 <xref:System.ComponentModel.TypeConverter>  
 [<span data-ttu-id="08a1c-206">Omówienie XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="08a1c-206">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="08a1c-207">Rozszerzenia znaczników i WPF XAML</span><span class="sxs-lookup"><span data-stu-id="08a1c-207">Markup Extensions and WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)  
 [<span data-ttu-id="08a1c-208">Składnia języka XAML szczegółowo</span><span class="sxs-lookup"><span data-stu-id="08a1c-208">XAML Syntax In Detail</span></span>](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)
