---
title: Udostępnianie pętli komunikatów pomiędzy Win32 i WPF
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 74055ec3facb7db9145c4c0e969d57da24eccbc8
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/08/2019
ms.locfileid: "59115079"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="feb5b-102">Udostępnianie pętli komunikatów pomiędzy Win32 i WPF</span><span class="sxs-lookup"><span data-stu-id="feb5b-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="feb5b-103">W tym temacie opisano sposób implementacji pętlę komunikatów do współpracy z [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], przy użyciu istniejących komunikatów narażenia pętli w <xref:System.Windows.Threading.Dispatcher> lub poprzez utworzenie pętli oddzielną wiadomość na [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] obok współdziałanie kodu.</span><span class="sxs-lookup"><span data-stu-id="feb5b-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="feb5b-104">ComponentDispatcher i pętli komunikatów</span><span class="sxs-lookup"><span data-stu-id="feb5b-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="feb5b-105">Scenariusz normalnej obsługi zdarzeń klawiatury i współdziałanie jest zaimplementowanie <xref:System.Windows.Interop.IKeyboardInputSink>, lub do podklasy z klas, które zawierają już implementację <xref:System.Windows.Interop.IKeyboardInputSink>, takich jak <xref:System.Windows.Interop.HwndSource> lub <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="feb5b-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="feb5b-106">Jednak obsługa ujścia klawiatury nie opisano kwestii możliwe komunikat pętli wszystkiego, które mogą wystąpić podczas wysyłania i odbierania wiadomości granice współdziałanie.</span><span class="sxs-lookup"><span data-stu-id="feb5b-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="feb5b-107">Celu formalnego pętli komunikatów architektura [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] zapewnia <xref:System.Windows.Interop.ComponentDispatcher> klasy, która definiuje prosty protokół pętlę komunikatów do wykonania.</span><span class="sxs-lookup"><span data-stu-id="feb5b-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <xref:System.Windows.Interop.ComponentDispatcher> <span data-ttu-id="feb5b-108">jest klasą statyczną, która udostępnia kilka elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="feb5b-108">is a static class that exposes several members.</span></span> <span data-ttu-id="feb5b-109">Zakres każdej metody niejawnie jest powiązany do wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="feb5b-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="feb5b-110">Pętla wiadomości musi wywołać niektóre z nich [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] czasami krytyczne (zgodnie z definicją w następnej sekcji).</span><span class="sxs-lookup"><span data-stu-id="feb5b-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <xref:System.Windows.Interop.ComponentDispatcher> <span data-ttu-id="feb5b-111">dostępne są zdarzenia, które mogą nasłuchiwać inne składniki (takie jak klawiatury ujścia).</span><span class="sxs-lookup"><span data-stu-id="feb5b-111">provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="feb5b-112"><xref:System.Windows.Threading.Dispatcher> Klasy wywołania wszystkich odpowiednich <xref:System.Windows.Interop.ComponentDispatcher> metod w odpowiedniej kolejności.</span><span class="sxs-lookup"><span data-stu-id="feb5b-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="feb5b-113">W przypadku wdrażania własnych pętli komunikatów, Twój kod jest odpowiedzialny za wywołanie <xref:System.Windows.Interop.ComponentDispatcher> metod w podobny sposób.</span><span class="sxs-lookup"><span data-stu-id="feb5b-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="feb5b-114">Wywoływanie <xref:System.Windows.Interop.ComponentDispatcher> metod w wątku, tylko będzie wywoływać procedury obsługi zdarzeń, które zostały zarejestrowane na tym wątku.</span><span class="sxs-lookup"><span data-stu-id="feb5b-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="feb5b-115">Zapisywanie pętli komunikatów</span><span class="sxs-lookup"><span data-stu-id="feb5b-115">Writing Message Loops</span></span>  
 <span data-ttu-id="feb5b-116">Oto lista kontrolna <xref:System.Windows.Interop.ComponentDispatcher> składowe, które będą używane, jeśli piszesz własnego pętli komunikatów:</span><span class="sxs-lookup"><span data-stu-id="feb5b-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A><span data-ttu-id="feb5b-117">: wywołać ten element, aby wskazać, że wątek modalne pętli komunikatów dla usługi.</span><span class="sxs-lookup"><span data-stu-id="feb5b-117">: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A><span data-ttu-id="feb5b-118">: ten element, aby wskazać, że wątek został przywrócony na nonmodal wywołać pętli komunikatów dla usługi.</span><span class="sxs-lookup"><span data-stu-id="feb5b-118">:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A><span data-ttu-id="feb5b-119">: Twoje pętli komunikatów powinna wywołać ten element, aby wskazać, że <xref:System.Windows.Interop.ComponentDispatcher> powinny wywoływać <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="feb5b-119">: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <xref:System.Windows.Interop.ComponentDispatcher> <span data-ttu-id="feb5b-120">nie zgłosi <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> Jeśli <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> jest `true`, ale pętli komunikatów może wywołać <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> nawet wtedy, gdy <xref:System.Windows.Interop.ComponentDispatcher> nie może odpowiadać na znajduje się w stan modalny.</span><span class="sxs-lookup"><span data-stu-id="feb5b-120">will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A><span data-ttu-id="feb5b-121">: Twoje pętli komunikatów powinna wywołać ten element, aby wskazać, że nowa wiadomość jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="feb5b-121">: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="feb5b-122">Zwracana wartość wskazuje, czy odbiornik do <xref:System.Windows.Interop.ComponentDispatcher> zdarzenie obsługi wiadomości.</span><span class="sxs-lookup"><span data-stu-id="feb5b-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="feb5b-123">Jeśli <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> zwraca `true` (obsługiwane) Dyspozytor nie powinny nic robić dalej z komunikatem.</span><span class="sxs-lookup"><span data-stu-id="feb5b-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="feb5b-124">Jeśli wartość zwracana jest `false`, Dyspozytor oczekuje się, aby wywołać [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] funkcja `TranslateMessage`, następnie wywołać `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="feb5b-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="feb5b-125">Za pomocą ComponentDispatcher oraz istniejące Obsługa komunikatów</span><span class="sxs-lookup"><span data-stu-id="feb5b-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="feb5b-126">Oto lista kontrolna <xref:System.Windows.Interop.ComponentDispatcher> elementów członkowskich będzie używać, jeśli użytkownik korzysta z używaniem [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] pętli komunikatów.</span><span class="sxs-lookup"><span data-stu-id="feb5b-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A><span data-ttu-id="feb5b-127">: zwraca, czy aplikacja stała się modalne (np. pętli komunikatów modalnych zostało wypchnięte).</span><span class="sxs-lookup"><span data-stu-id="feb5b-127">: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <xref:System.Windows.Interop.ComponentDispatcher> <span data-ttu-id="feb5b-128">można śledzić ten stan, ponieważ klasa przechowuje liczbę <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> i <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> wywołania z pętli komunikatów.</span><span class="sxs-lookup"><span data-stu-id="feb5b-128">can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> <span data-ttu-id="feb5b-129">i <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> zdarzenia obowiązują standardowe reguły delegowanie wywołań.</span><span class="sxs-lookup"><span data-stu-id="feb5b-129">and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="feb5b-130">Delegaty są wywoływane w nieokreślonej kolejności, a wszystkie obiekty delegowane są wywoływane, nawet wtedy, gdy pierwszy z nich oznacza komunikat jako obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="feb5b-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle><span data-ttu-id="feb5b-131">: wskazuje odpowiednie i efektywne czas bezczynności (%) przetwarzania (nie ma żadnych oczekujących komunikatów dla wątku).</span><span class="sxs-lookup"><span data-stu-id="feb5b-131">: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> <span data-ttu-id="feb5b-132">nie zostaną wywołane Jeśli wątek jest modalnych.</span><span class="sxs-lookup"><span data-stu-id="feb5b-132">will not be raised if the thread is modal.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage><span data-ttu-id="feb5b-133">: wywoływane dla wszystkich wiadomości, które przetwarza "pompy komunikatów".</span><span class="sxs-lookup"><span data-stu-id="feb5b-133">: raised for all messages that the message pump processes.</span></span>  
  
-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage><span data-ttu-id="feb5b-134">: wywoływane dla wszystkich wiadomości, które nie były obsługiwane podczas <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="feb5b-134">: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="feb5b-135">Komunikat jest uznawany za obsługiwany Jeżeli po <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> zdarzeń lub <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> zdarzeń, `handled` parametr przekazywany przez odwołanie w danych zdarzenia jest `true`.</span><span class="sxs-lookup"><span data-stu-id="feb5b-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="feb5b-136">Programy obsługi zdarzeń należy zignorować ten komunikat, jeśli `handled` jest `true`, ponieważ oznacza to, że najpierw obsługiwane innego programu obsługi wiadomości.</span><span class="sxs-lookup"><span data-stu-id="feb5b-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="feb5b-137">Programy obsługi zdarzeń do obu zdarzeń może modyfikować komunikat.</span><span class="sxs-lookup"><span data-stu-id="feb5b-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="feb5b-138">Dyspozytor powinien wysyłać komunikat zmodyfikowany i nie oryginalnej wiadomości bez zmian.</span><span class="sxs-lookup"><span data-stu-id="feb5b-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> <span data-ttu-id="feb5b-139">jest dostarczane do wszystkich obiektów nasłuchujących, ale zamiar architektury jest to, że tylko najwyższego poziomu okna zawierającego HWND, jaką komunikaty docelowych należy wywołać kod w odpowiedzi na wiadomość.</span><span class="sxs-lookup"><span data-stu-id="feb5b-139">is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="feb5b-140">Jak HwndSource traktuje ComponentDispatcher zdarzenia</span><span class="sxs-lookup"><span data-stu-id="feb5b-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="feb5b-141">Jeśli <xref:System.Windows.Interop.HwndSource> jest oknem najwyższego poziomu (nie nadrzędnego HWND), będą rejestrować się za pomocą <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="feb5b-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="feb5b-142">Jeśli <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> jest wywoływane, i jeśli komunikat jest przeznaczony dla <xref:System.Windows.Interop.HwndSource> lub okien podrzędnych <xref:System.Windows.Interop.HwndSource> wywołuje jego <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> klawiatury sekwencji ujścia.</span><span class="sxs-lookup"><span data-stu-id="feb5b-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="feb5b-143">Jeśli <xref:System.Windows.Interop.HwndSource> nie jest oknem najwyższego poziomu (ma element nadrzędny HWND), będzie nie obsługi.</span><span class="sxs-lookup"><span data-stu-id="feb5b-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="feb5b-144">Oknem najwyższego poziomu jest oczekiwana w celu obsługi i powinien być oknem najwyższego poziomu z obsługą ujścia klawiatury w ramach dowolnego scenariusza współdziałanie.</span><span class="sxs-lookup"><span data-stu-id="feb5b-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="feb5b-145">Jeśli <xref:System.Windows.Interop.HwndHost.WndProc%2A> na <xref:System.Windows.Interop.HwndSource> nosi nazwę otrzyma bez konieczności odpowiednie skróty ujścia wywołania metody najpierw, aplikacji wyższej zdarzenia klawiatury poziomu takich jak <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="feb5b-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="feb5b-146">Jednak żadnych metod ujścia klawiatury będzie miała nazwę, która zmierzone pożądane klawiatury modelu wejściowym funkcje, takie jak Obsługa kluczy dostępu.</span><span class="sxs-lookup"><span data-stu-id="feb5b-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="feb5b-147">Może się to zdarzyć, ponieważ pętli komunikatów nie prawidłowo powiadomienia odpowiednie wątku na <xref:System.Windows.Interop.ComponentDispatcher>, lub ponieważ nadrzędny HWND nie wywołała odpowiedzi ujścia odpowiednie klawiatury.</span><span class="sxs-lookup"><span data-stu-id="feb5b-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="feb5b-148">Komunikat, który prowadzi do ujścia klawiatury nie mogą być wysyłane do HWND, jeśli dodano punkty zaczepienia dla tego komunikatu przy użyciu <xref:System.Windows.Interop.HwndSource.AddHook%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="feb5b-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="feb5b-149">Komunikat może być obsługiwany na poziomie pompy komunikatów bezpośrednio i nie są przesyłane do `DispatchMessage` funkcji.</span><span class="sxs-lookup"><span data-stu-id="feb5b-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="feb5b-150">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="feb5b-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="feb5b-151">WPF i Win32 — Współdziałanie</span><span class="sxs-lookup"><span data-stu-id="feb5b-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="feb5b-152">Model wątkowości</span><span class="sxs-lookup"><span data-stu-id="feb5b-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="feb5b-153">Przegląd Dane wejściowe</span><span class="sxs-lookup"><span data-stu-id="feb5b-153">Input Overview</span></span>](input-overview.md)
