---
title: Klasy XAML i niestandardowe dla WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: aa2dd7a5c30894f85ed1d4aae0228b76ece3c005
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/31/2019
ms.locfileid: "75559875"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="08565-102">Klasy XAML i niestandardowe dla WPF</span><span class="sxs-lookup"><span data-stu-id="08565-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="08565-103">Język XAML zgodnie z implementacją w strukturach środowiska uruchomieniowego języka wspólnego (CLR) obsługuje możliwość definiowania niestandardowej klasy lub struktury w dowolnym języku środowiska uruchomieniowego języka wspólnego (CLR), a następnie uzyskiwania dostępu do tej klasy przy użyciu znacznika XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="08565-104">Można użyć mieszanki typów zdefiniowanych przez [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]i typów niestandardowych w tym samym pliku znaczników, zazwyczaj przez mapowanie typów niestandardowych na prefiks przestrzeni nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="08565-105">W tym temacie omówiono wymagania, które Klasa niestandardowa musi spełniać, aby można było używać ich jako elementu XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="08565-106">Klasy niestandardowe w aplikacjach lub zestawach</span><span class="sxs-lookup"><span data-stu-id="08565-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="08565-107">Klasy niestandardowe, które są używane w języku XAML, można definiować na dwa różne sposoby: w ramach kodu lub innego kodu, który tworzy podstawową aplikację [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], lub jako klasę w osobnym zestawie, na przykład plik wykonywalny lub DLL używany jako Biblioteka klas.</span><span class="sxs-lookup"><span data-stu-id="08565-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="08565-108">Każdy z tych podejścia ma szczególne zalety i wady.</span><span class="sxs-lookup"><span data-stu-id="08565-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="08565-109">Zaletą tworzenia biblioteki klas jest to, że wszystkie takie klasy niestandardowe mogą być współużytkowane przez wiele różnych możliwych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="08565-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="08565-110">Oddzielna Biblioteka sprawia również, że problemy z przechowywaniem wersji aplikacji są łatwiejsze do kontroli i upraszczają tworzenie klasy, w której zamierzone użycie klasy jest elementem głównym na stronie XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="08565-111">Zaletą definiowania klas niestandardowych w aplikacji jest to, że ta technika jest stosunkowo lekkim i minimalizuje problemy związane z wdrażaniem i testowaniem, które są wykonywane po wprowadzeniu oddzielnych zestawów wykraczających poza główny plik wykonywalny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="08565-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="08565-112">Niezależnie od tego, czy zdefiniowano w tym samym lub innym zestawie, klasy niestandardowe muszą być mapowane między przestrzenią nazw CLR i przestrzenią nazw XML, aby można było ich używać w języku XAML jako elementy.</span><span class="sxs-lookup"><span data-stu-id="08565-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="08565-113">Zobacz [przestrzenie nazw XAML i mapowanie przestrzeni nazw dla języka XAML WPF](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="08565-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="08565-114">Wymagania dotyczące klasy niestandardowej jako elementu XAML</span><span class="sxs-lookup"><span data-stu-id="08565-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="08565-115">Aby można było utworzyć wystąpienie jako element obiektu, Klasa musi spełniać następujące wymagania:</span><span class="sxs-lookup"><span data-stu-id="08565-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="08565-116">Klasa niestandardowa musi być publiczna i obsługiwać domyślnego (bezparametrowego) konstruktora publicznego.</span><span class="sxs-lookup"><span data-stu-id="08565-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="08565-117">(Zobacz poniższą sekcję, aby poznać informacje o strukturach).</span><span class="sxs-lookup"><span data-stu-id="08565-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="08565-118">Klasa niestandardowa nie może być klasą zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="08565-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="08565-119">Klasy zagnieżdżone i "kropka" w ich ogólnej składni użycia środowiska CLR zakłócają inne funkcje [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] i/lub XAML, takie jak dołączone właściwości.</span><span class="sxs-lookup"><span data-stu-id="08565-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="08565-120">Oprócz włączenia składni elementu obiektu, definicja obiektu również umożliwia składnię elementu właściwości dla wszystkich innych właściwości publicznych, które pobierają ten obiekt jako typ wartości.</span><span class="sxs-lookup"><span data-stu-id="08565-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="08565-121">Jest to spowodowane tym, że obiekt może teraz być skonkretyzowany jako element obiektu i może wypełniać wartość właściwości, takiej właściwości.</span><span class="sxs-lookup"><span data-stu-id="08565-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="08565-122">Struktury</span><span class="sxs-lookup"><span data-stu-id="08565-122">Structures</span></span>  
 <span data-ttu-id="08565-123">Struktury zdefiniowane jako typy niestandardowe są zawsze w języku XAML w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Wynika to z faktu, że kompilatory CLR niejawnie tworzą Konstruktor bez parametrów dla struktury, która inicjuje wszystkie wartości właściwości do ich wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="08565-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="08565-124">W niektórych przypadkach domyślne zachowanie konstrukcji i/lub użycie elementu obiektu dla struktury nie jest pożądane.</span><span class="sxs-lookup"><span data-stu-id="08565-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="08565-125">Może to być spowodowane tym, że struktura jest przeznaczona do wypełniania wartości i funkcji koncepcyjnie jako Unia, gdzie zawarte wartości mogą mieć wzajemnie wykluczające się interpretacje i dlatego żadna z jej właściwości nie jest w trakcie.</span><span class="sxs-lookup"><span data-stu-id="08565-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="08565-126">Przykładem [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] takiej struktury jest <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="08565-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="08565-127">Ogólnie rzecz biorąc, takie struktury powinny implementować konwerter typów, aby wartości mogły być wyrażone w postaci atrybutu, przy użyciu konwencji ciągów, które tworzą różne interpretacje lub tryby wartości struktury.</span><span class="sxs-lookup"><span data-stu-id="08565-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="08565-128">Struktura powinna również ujawniać podobne zachowanie konstrukcji kodu za pomocą konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="08565-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="08565-129">Wymagania dotyczące właściwości niestandardowej klasy jako atrybutów XAML</span><span class="sxs-lookup"><span data-stu-id="08565-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="08565-130">Właściwości muszą odwoływać się do typu przez wartość (na przykład podstawowy) lub użyć klasy dla typu, który ma Konstruktor bez parametrów lub dedykowany konwerter typów, do którego może uzyskać dostęp procesor XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="08565-131">W implementacji języka XAML CLR procesory języka XAML mogą znaleźć takie konwertery za pomocą natywnej obsługi dla elementów podstawowych języka lub przez zastosowanie <xref:System.ComponentModel.TypeConverterAttribute> do typu lub składowej w definicjach typów zapasowych</span><span class="sxs-lookup"><span data-stu-id="08565-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="08565-132">Alternatywnie właściwość może odwoływać się do typu klasy abstrakcyjnej lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="08565-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="08565-133">Dla klas abstrakcyjnych lub interfejsów oczekiwana jest analiza XAML, ponieważ wartość właściwości musi być uzupełniona wystąpieniami klasy praktycznej, które implementują interfejs, lub wystąpień typów, które pochodzą od klasy abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="08565-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="08565-134">Właściwości można zadeklarować w klasie abstrakcyjnej, ale można ją ustawić tylko dla praktycznych klas, które pochodzą z klasy abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="08565-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="08565-135">Wynika to z faktu, że utworzenie elementu obiektu dla klasy w ogóle wymaga publicznego konstruktora bez parametrów w klasie.</span><span class="sxs-lookup"><span data-stu-id="08565-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="08565-136">Składnia atrybutu enabled z funkcją TypeConverter</span><span class="sxs-lookup"><span data-stu-id="08565-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="08565-137">Jeśli podajesz dedykowany konwerter typu z atrybutami na poziomie klasy, zastosowana konwersja typu włącza składnię atrybutu dla każdej właściwości, która musi utworzyć wystąpienie tego typu.</span><span class="sxs-lookup"><span data-stu-id="08565-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="08565-138">Konwerter typów nie pozwala na użycie elementu obiektu dla typu; tylko obecność konstruktora bez parametrów dla tego typu umożliwia użycie elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="08565-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="08565-139">W związku z tym właściwości, które są włączone dla konwertera typów, zazwyczaj nie mogą być używane w składni właściwości, chyba że sam typ obsługuje składnię elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="08565-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="08565-140">Wyjątkiem jest to, że można określić składnię elementu właściwości, ale element właściwości zawiera ciąg.</span><span class="sxs-lookup"><span data-stu-id="08565-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="08565-141">To użycie jest naprawdę równoważne z użyciem składni atrybutów, a takie użycie nie jest wspólne, chyba że istnieje potrzeba bardziej niezawodnej obsługi białej przestrzeni wartości atrybutu.</span><span class="sxs-lookup"><span data-stu-id="08565-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="08565-142">Na przykład, poniżej przedstawiono użycie elementu właściwości, które przyjmuje ciąg, i równoważne użycie atrybutu:</span><span class="sxs-lookup"><span data-stu-id="08565-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="08565-143">Przykłady właściwości, w których składnia atrybutu jest dozwolona, ale składnia elementu właściwości, która zawiera element obiektu, jest niedozwolona w języku XAML, są różne właściwości, które przyjmują typ <xref:System.Windows.Input.Cursor>.</span><span class="sxs-lookup"><span data-stu-id="08565-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="08565-144">Klasa <xref:System.Windows.Input.Cursor> ma dedykowany konwerter typów <xref:System.Windows.Input.CursorConverter>, ale nie uwidacznia konstruktora bez parametrów, więc Właściwość <xref:System.Windows.FrameworkElement.Cursor%2A> może być ustawiana tylko za pośrednictwem składni atrybutu, mimo że rzeczywisty typ <xref:System.Windows.Input.Cursor> jest typem referencyjnym.</span><span class="sxs-lookup"><span data-stu-id="08565-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="08565-145">Konwertery typu dla właściwości</span><span class="sxs-lookup"><span data-stu-id="08565-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="08565-146">Alternatywnie właściwość może deklarować konwerter typów na poziomie właściwości.</span><span class="sxs-lookup"><span data-stu-id="08565-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="08565-147">Umożliwia to "język mini", który tworzy wystąpienia obiektów typu właściwości w tekście, przez przetwarzanie przychodzących wartości ciągu atrybutu jako danych wejściowych dla operacji <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> na podstawie odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="08565-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="08565-148">Zwykle jest to konieczne, aby zapewnić wygodną metodę dostępu, a nie jako jedyne środki umożliwiające ustawienie właściwości w języku XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="08565-149">Można jednak używać konwerterów typów dla atrybutów, w których mają być używane istniejące typy CLR, które nie dostarczają konstruktora bez parametrów lub konwertera typu z atrybutami.</span><span class="sxs-lookup"><span data-stu-id="08565-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="08565-150">Przykłady z interfejsu API [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] to pewne właściwości, które pobierają typ <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="08565-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="08565-151">W takim przypadku [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] używać istniejących Microsoft .NET Framework <xref:System.Globalization.CultureInfo> typu, aby lepiej spełnić wymagania dotyczące zgodności i migracji, które były używane we wcześniejszych wersjach platform, ale typ <xref:System.Globalization.CultureInfo> nie obsługiwał wymaganych konstruktorów lub konwersji typu na poziomie typu, aby można było używać ich bezpośrednio jako wartość właściwości XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="08565-152">Za każdym razem, gdy użytkownik uwidacznia właściwość, która ma użycie języka XAML, szczególnie jeśli jesteś autorem kontrolki, należy zdecydowanie rozważyć wykonanie kopii zapasowej tej właściwości przy użyciu właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="08565-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="08565-153">Jest to szczególnie istotne, jeśli używasz istniejącej implementacji [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] procesora XAML, ponieważ można poprawić wydajność przy użyciu <xref:System.Windows.DependencyProperty> kopii zapasowej.</span><span class="sxs-lookup"><span data-stu-id="08565-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="08565-154">Właściwość zależności będzie uwidaczniać funkcje systemu właściwości właściwości, które użytkownicy będą oczekiwać na Właściwość dostępne dla języka XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="08565-155">Obejmuje to takie funkcje jak animacja, powiązanie danych i obsługa stylów.</span><span class="sxs-lookup"><span data-stu-id="08565-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="08565-156">Aby uzyskać więcej informacji, zobacz [niestandardowe właściwości zależności](custom-dependency-properties.md) i [ładowanie XAML i właściwości zależności](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="08565-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="08565-157">Pisanie i przypisywanie konwertera typów</span><span class="sxs-lookup"><span data-stu-id="08565-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="08565-158">Czasami trzeba będzie napisać niestandardową klasę pochodną <xref:System.ComponentModel.TypeConverter>, aby zapewnić konwersję typu dla typu właściwości.</span><span class="sxs-lookup"><span data-stu-id="08565-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="08565-159">Aby uzyskać instrukcje dotyczące sposobu, w jaki można utworzyć konwerter typu, który może obsługiwać użycie kodu XAML i jak zastosować <xref:System.ComponentModel.TypeConverterAttribute>, zobacz [TypeConverters and XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="08565-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="08565-160">Wymagania dotyczące składni atrybutu programu obsługi zdarzeń XAML w zdarzeniach klasy niestandardowej</span><span class="sxs-lookup"><span data-stu-id="08565-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="08565-161">Aby można było używać go jako zdarzenia CLR, zdarzenie musi być uwidocznione jako zdarzenie publiczne dla klasy, która obsługuje Konstruktor bez parametrów lub klasy abstrakcyjnej, w której można uzyskać dostęp do tego zdarzenia w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="08565-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="08565-162">Aby można było używać wygodnie jako zdarzenia trasowanego, zdarzenie CLR powinno implementować jawne `add` i `remove` metod, które dodają i usuwają programy obsługi dla sygnatury zdarzeń środowiska CLR i przekazują te procedury obsługi do metod <xref:System.Windows.UIElement.AddHandler%2A> i <xref:System.Windows.UIElement.RemoveHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="08565-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="08565-163">Te metody umożliwiają dodanie lub usunięcie programów obsługi do magazynu obsługi zdarzeń kierowanych na wystąpienie, do którego jest dołączone zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="08565-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="08565-164">Można zarejestrować programy obsługi bezpośrednio dla zdarzeń kierowanych przy użyciu <xref:System.Windows.UIElement.AddHandler%2A>i celowo nie definiować zdarzenia CLR, które ujawnia zdarzenie kierowane.</span><span class="sxs-lookup"><span data-stu-id="08565-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="08565-165">Nie jest to ogólnie zalecane, ponieważ zdarzenie nie będzie włączać składni atrybutu XAML w celu dołączania obsługi, a klasa będąca wynikiem będzie oferować mniej przezroczysty widok XAML możliwości tego typu.</span><span class="sxs-lookup"><span data-stu-id="08565-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="08565-166">Zapisywanie właściwości kolekcji</span><span class="sxs-lookup"><span data-stu-id="08565-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="08565-167">Właściwości, które pobierają typ kolekcji, mają składnię XAML, która umożliwia określenie obiektów, które są dodawane do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="08565-168">Ta składnia ma dwie istotne funkcje.</span><span class="sxs-lookup"><span data-stu-id="08565-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="08565-169">Obiekt, który jest obiektem kolekcji, nie musi być określony w składni elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="08565-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="08565-170">Obecność tego typu kolekcji jest niejawna za każdym razem, gdy określisz właściwość w języku XAML, która przyjmuje typ kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="08565-171">Elementy podrzędne właściwości kolekcji w znacznikach są przetwarzane, aby stać się elementami członkowskimi kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="08565-172">Zwykle dostęp do kodu do elementów członkowskich kolekcji odbywa się za pomocą metod list/dictionary, takich jak `Add`, lub za pomocą indeksatora.</span><span class="sxs-lookup"><span data-stu-id="08565-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="08565-173">Chociaż składnia języka XAML nie obsługuje metod ani indeksatorów (wyjątek: XAML 2009 może obsługiwać metody, ale użycie języka XAML 2009 ogranicza możliwe użycie platformy WPF; zobacz [xaml 2009 Language Features](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="08565-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="08565-174">Kolekcje są oczywiście bardzo typowym wymaganiem do tworzenia drzewa elementów i potrzebujesz pewnego sposobu wypełniania tych kolekcji w deklaratywnym języku XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="08565-175">W związku z tym elementy podrzędne właściwości kolekcji są przetwarzane przez dodanie ich do kolekcji, która jest wartością typu właściwości kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="08565-176">Implementacja usług .NET Framework XAML i w ten sposób procesor WPF XAML używa następującej definicji dla co stanowi Właściwość kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="08565-177">Typ właściwości właściwości musi implementować jedną z następujących wartości:</span><span class="sxs-lookup"><span data-stu-id="08565-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="08565-178">Implementuje <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="08565-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="08565-179">Implementuje <xref:System.Collections.IDictionary> lub odpowiednik ogólny (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="08565-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="08565-180">Wynika z <xref:System.Array> (Aby uzyskać więcej informacji na temat tablic w języku XAML, zobacz [X:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)).</span><span class="sxs-lookup"><span data-stu-id="08565-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="08565-181">Implementuje <xref:System.Windows.Markup.IAddChild> (interfejs zdefiniowany przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="08565-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="08565-182">Każdy z tych typów w środowisku CLR ma metodę `Add`, która jest używana przez procesor XAML do dodawania elementów do kolekcji bazowej podczas tworzenia grafu obiektów.</span><span class="sxs-lookup"><span data-stu-id="08565-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="08565-183">Ogólne interfejsy `List` i `Dictionary` (<xref:System.Collections.Generic.IList%601> i <xref:System.Collections.Generic.IDictionary%602>) nie są obsługiwane na potrzeby wykrywania kolekcji przez procesor [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="08565-184">Można jednak użyć klasy <xref:System.Collections.Generic.List%601> jako klasy bazowej, ponieważ implementuje ona <xref:System.Collections.IList> bezpośrednio lub <xref:System.Collections.Generic.Dictionary%602> jako klasę bazową, ponieważ implementuje <xref:System.Collections.IDictionary> bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="08565-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="08565-185">Podczas deklarowania właściwości pobierającej kolekcję należy zachować ostrożność, jak ta wartość właściwości jest inicjowana w nowych wystąpieniach typu.</span><span class="sxs-lookup"><span data-stu-id="08565-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="08565-186">Jeśli właściwość nie jest wdrażana jako właściwość zależności, właściwość Użyj pola zapasowego, które wywołuje Konstruktor typów kolekcji, jest odpowiedni.</span><span class="sxs-lookup"><span data-stu-id="08565-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="08565-187">Jeśli właściwość jest właściwością zależności, może być konieczne zainicjowanie właściwości kolekcji jako części domyślnego konstruktora typów.</span><span class="sxs-lookup"><span data-stu-id="08565-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="08565-188">Wynika to z faktu, że właściwość dependency przyjmuje swoją wartość domyślną z metadanych, a zwykle nie chcesz, aby początkowa wartość właściwości kolekcji była statyczną, udostępnioną kolekcją.</span><span class="sxs-lookup"><span data-stu-id="08565-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="08565-189">Dla każdego wystąpienia typu zawierającego istnieje wystąpienie kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="08565-190">Aby uzyskać więcej informacji, zobacz [niestandardowe właściwości zależności](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="08565-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="08565-191">Można zaimplementować niestandardowy typ kolekcji dla właściwości kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="08565-192">Ze względu na niejawne traktowanie właściwości kolekcji niestandardowa typ kolekcji nie musi podawać konstruktora bez parametrów, aby można go było używać w języku XAML niejawnie.</span><span class="sxs-lookup"><span data-stu-id="08565-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="08565-193">Można jednak opcjonalnie dostarczyć Konstruktor bez parametrów dla typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="08565-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="08565-194">Może to być wartościowaa.</span><span class="sxs-lookup"><span data-stu-id="08565-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="08565-195">Jeśli nie podasz konstruktora bez parametrów, nie można jawnie zadeklarować kolekcji jako elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="08565-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="08565-196">Niektórzy autorzy znaczników mogą chcieć zobaczyć jawną kolekcję jako temat stylu znaczników.</span><span class="sxs-lookup"><span data-stu-id="08565-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="08565-197">Ponadto Konstruktor bez parametrów może uprościć wymagania inicjalizacyjne podczas tworzenia nowych obiektów, które używają typu kolekcji jako wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="08565-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="08565-198">Deklarowanie właściwości zawartości XAML</span><span class="sxs-lookup"><span data-stu-id="08565-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="08565-199">Język XAML definiuje koncepcję właściwości zawartości [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="08565-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="08565-200">Każda klasa, która jest użyteczna w składni obiektu, może mieć dokładnie jedną właściwość zawartości XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="08565-201">Aby zadeklarować właściwość jako właściwość zawartości XAML dla klasy, Zastosuj <xref:System.Windows.Markup.ContentPropertyAttribute> w ramach definicji klasy.</span><span class="sxs-lookup"><span data-stu-id="08565-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="08565-202">Określ nazwę zamierzonej właściwości zawartości XAML jako <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> w atrybucie.</span><span class="sxs-lookup"><span data-stu-id="08565-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="08565-203">Właściwość jest określana jako ciąg o nazwie, nie jako konstrukcja odbicia, taka jak <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="08565-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="08565-204">Możesz określić właściwość kolekcji jako właściwość zawartości XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="08565-205">Powoduje to użycie tej właściwości, według której element object może mieć co najmniej jeden element podrzędny, bez żadnych elementów obiektu kolekcji lub tagów elementów właściwości.</span><span class="sxs-lookup"><span data-stu-id="08565-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="08565-206">Te elementy są następnie traktowane jako wartość właściwości zawartości XAML i dodawane do wystąpienia kolekcji zapasowej.</span><span class="sxs-lookup"><span data-stu-id="08565-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="08565-207">Niektóre istniejące właściwości zawartości XAML używają typu właściwości `Object`.</span><span class="sxs-lookup"><span data-stu-id="08565-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="08565-208">Pozwala to na Właściwość zawartości XAML, która może przyjmować wartości pierwotne, takie jak <xref:System.String>, a także pobieranie pojedynczej wartości obiektu odniesienia.</span><span class="sxs-lookup"><span data-stu-id="08565-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="08565-209">W przypadku korzystania z tego modelu typ jest odpowiedzialny za określenie typu, a także obsługę możliwych typów.</span><span class="sxs-lookup"><span data-stu-id="08565-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="08565-210">Typową przyczyną <xref:System.Object> typu zawartości jest obsługa prostej metody dodawania zawartości obiektu jako ciągu (która otrzymuje domyślne podejście do prezentacji) lub zaawansowanego sposobu dodawania zawartości obiektu, która określa niedomyślną prezentację lub dodatkowe dane.</span><span class="sxs-lookup"><span data-stu-id="08565-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="08565-211">Serializowanie XAML</span><span class="sxs-lookup"><span data-stu-id="08565-211">Serializing XAML</span></span>  
 <span data-ttu-id="08565-212">W przypadku niektórych scenariuszy, takich jak Jeśli jesteś autorem kontrolki, możesz również upewnić się, że wszelkie reprezentacje obiektów, które można utworzyć w kodzie XAML, można również serializować z powrotem do odpowiadającego znacznika XAML.</span><span class="sxs-lookup"><span data-stu-id="08565-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="08565-213">Wymagania serializacji nie zostały opisane w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="08565-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="08565-214">Zobacz [Omówienie tworzenia](../controls/control-authoring-overview.md) i [drzewa elementów i serializacji](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="08565-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="08565-215">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="08565-215">See also</span></span>

- [<span data-ttu-id="08565-216">Przegląd XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="08565-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="08565-217">Niestandardowe właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="08565-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="08565-218">Tworzenie kontrolek — omówienie</span><span class="sxs-lookup"><span data-stu-id="08565-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="08565-219">Przegląd elementów podstawowych</span><span class="sxs-lookup"><span data-stu-id="08565-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="08565-220">Ładowanie XAML i właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="08565-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
