---
title: Klasy XAML i niestandardowe dla WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: e71946ec06eb1b4c75f30084dfdb863d8e3b093e
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/08/2019
ms.locfileid: "59122359"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="5cb74-102">Klasy XAML i niestandardowe dla WPF</span><span class="sxs-lookup"><span data-stu-id="5cb74-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="5cb74-103">XAML zaimplementowanego w [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] struktury obsługuje możliwość definiowania niestandardowej klasy lub struktury w dowolnym [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] języka, a następnie dostęp przy użyciu znaczników XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="5cb74-104">Możesz użyć kombinacji [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]— określone typy i swoje niestandardowe w ramach tego samego pliku znaczników, zwykle przez mapowanie typów niestandardowych do prefiksu przestrzeni nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="5cb74-105">W tym temacie omówiono wymagania które muszą spełniać klasę niestandardową, może być używany jako XAML element.</span><span class="sxs-lookup"><span data-stu-id="5cb74-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="5cb74-106">Klasy niestandardowe w aplikacji lub zespołów</span><span class="sxs-lookup"><span data-stu-id="5cb74-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="5cb74-107">Klasy niestandardowe, które są używane w XAML można zdefiniować na dwa różne sposoby: w związanym z kodem lub innego kodu, który tworzy podstawowy [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] aplikacji lub jako klasy w oddzielnych zestawu, na przykład pliku wykonywalnego lub biblioteki DLL używane jako bibliotekę klas.</span><span class="sxs-lookup"><span data-stu-id="5cb74-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="5cb74-108">Każda z tych metod ma określoną zalety i wady.</span><span class="sxs-lookup"><span data-stu-id="5cb74-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
-   <span data-ttu-id="5cb74-109">Zaletą tworzenia biblioteki klas jest, że niestandardowych klas mogą być współużytkowane przez wiele aplikacji możliwe.</span><span class="sxs-lookup"><span data-stu-id="5cb74-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="5cb74-110">Odrębnych bibliotek również sprawia, że problemy z wersjonowaniem aplikacji jest łatwiejsze do kontroli i upraszcza tworzenie klasy, gdzie jest użycie klasy zamierzony jako element główny strony XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
-   <span data-ttu-id="5cb74-111">Zaletą definiowania niestandardowych klas w aplikacji jest, że ta technika jest stosunkowo lekkie i minimalizuje wdrażania i testowania problemy występujące podczas wprowadzania oddzielne zestawy poza głównym plik wykonywalny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="5cb74-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
-   <span data-ttu-id="5cb74-112">Czy zdefiniowane w tej samej lub różnych zestawów, niestandardowych klas należy zamapować między przestrzeń nazw środowiska CLR i przestrzeni nazw XML aby możliwe było użycie w XAML jako elementy.</span><span class="sxs-lookup"><span data-stu-id="5cb74-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="5cb74-113">Zobacz [przestrzeń nazw XAML i mapowanie Namespace dla WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="5cb74-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="5cb74-114">Wymagania dotyczące niestandardowych klas jako XAML Element</span><span class="sxs-lookup"><span data-stu-id="5cb74-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="5cb74-115">Aby móc można utworzyć wystąpienia jako elementu obiektu klasy musi spełniać następujące wymagania:</span><span class="sxs-lookup"><span data-stu-id="5cb74-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="5cb74-116">Klasę niestandardową muszą być publiczne i obsługuje domyślnego (bezparametrowego) konstruktora publicznego.</span><span class="sxs-lookup"><span data-stu-id="5cb74-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="5cb74-117">(Zobacz następujące sekcji uwag dotyczących struktury).</span><span class="sxs-lookup"><span data-stu-id="5cb74-117">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="5cb74-118">Niestandardowe klasy nie może być klasą zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="5cb74-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="5cb74-119">Zagnieżdżonych klasach i "dot" w ich ogólne składni CLR kolidują z innymi [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] i/lub XAML funkcje, takie jak dołączone właściwości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="5cb74-120">Oprócz włączenia składnia elementu obiektu, definicji obiektu umożliwia także składni elementu właściwości dla innych publicznych właściwości, które przyjmują tego obiektu jako typ wartości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="5cb74-121">Jest to spowodowane teraz można tworzyć wystąpienia jako elementu obiektu i wpisać wartość elementu właściwości takiej właściwości obiektu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="5cb74-122">Struktury</span><span class="sxs-lookup"><span data-stu-id="5cb74-122">Structures</span></span>  
 <span data-ttu-id="5cb74-123">Struktury, które definiują, ponieważ zawsze mogą być zbudowane w XAML w niestandardowych typów [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] . Jest to spowodowane [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] kompilatory tworzyć niejawnie domyślnego konstruktora dla struktury, która inicjuje wszystkie wartości właściwości do wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="5cb74-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a default constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="5cb74-124">W niektórych przypadkach domyślna konstrukcji zachowanie i/lub obiekt użycie elementu dla struktury nie jest pożądane.</span><span class="sxs-lookup"><span data-stu-id="5cb74-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="5cb74-125">Może to być, ponieważ struktura jest przeznaczone do wypełnienia wartości i funkcji z koncepcyjnie jako Unii, w której wartości zawartych może mieć interpretacji wzajemnie się wykluczają, a więc żaden z jej właściwości do ustawienia.</span><span class="sxs-lookup"><span data-stu-id="5cb74-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="5cb74-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] jest przykładem takiej struktury <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="5cb74-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="5cb74-127">Ogólnie rzecz biorąc te struktury powinny implementować konwertera typów w taki sposób, że wartości mogą być wyrażone w formie atrybutu, za pomocą Konwencji ciągu, tworzone różne interpretacji lub tryby struktury wartości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="5cb74-128">Struktura również powinny ujawniać zachowanie podobne do tworzenia kodu za pośrednictwem konstruktora innych niż domyślne.</span><span class="sxs-lookup"><span data-stu-id="5cb74-128">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="5cb74-129">Wymagania dotyczące właściwości klasy niestandardowej jako atrybuty XAML</span><span class="sxs-lookup"><span data-stu-id="5cb74-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="5cb74-130">Właściwości, należy odwołać się do typu i wartości (na przykład podstawowy) lub używanie klasy dla typu, który ma domyślny konstruktor lub konwertera typów dedykowane, dostępnej dla procesora XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a default constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="5cb74-131">W implementacji XAML CLR procesorów XAML albo znaleźć takie konwertery dzięki natywnej obsłudze elementów podstawowych języka lub poprzez zastosowanie <xref:System.ComponentModel.TypeConverterAttribute> do typu lub elementu członkowskiego w kopii definicji typu</span><span class="sxs-lookup"><span data-stu-id="5cb74-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="5cb74-132">Alternatywnie właściwość może odwoływać się typem klasy abstrakcyjnej lub interfejs.</span><span class="sxs-lookup"><span data-stu-id="5cb74-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="5cb74-133">Dla abstrakcyjnych klas lub interfejsów oczekiwania do analizowania XAML jest, że wartość właściwości musi być wypełniona przy użyciu wystąpienia klasy praktycznych, które implementują interfejs lub wystąpień typów wyprowadzonych z klasy abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="5cb74-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="5cb74-134">Właściwości mogą być deklarowane dla klasy abstrakcyjnej, ale można ustawić tylko w klasach praktycznych, które pochodzą z klasy abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="5cb74-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="5cb74-135">Jest to spowodowane tworzenie element obiektu dla tej klasy w ogóle wymaga publicznego konstruktora domyślnego w klasie.</span><span class="sxs-lookup"><span data-stu-id="5cb74-135">This is because creating the object element for the class at all requires a public default constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="5cb74-136">TypeConverter włączone składni atrybutów</span><span class="sxs-lookup"><span data-stu-id="5cb74-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="5cb74-137">Jeśli podasz konwertera typów dedykowaną, opartego na atrybutach na poziomie klasy, konwersja typu zastosowane umożliwia składni atrybutów dla dowolnej właściwości, która potrzebuje do tworzenia wystąpienia tego typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="5cb74-138">Konwertera typów nie umożliwia użycie elementu obiektu tego typu; obecność domyślnego konstruktora dla tego typu umożliwia użycie elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-138">A type converter does not enable object element usage of the type; only the presence of a default constructor for that type enables object element usage.</span></span> <span data-ttu-id="5cb74-139">W związku z tym właściwości, które są włączone konwertera typów ogólnie rzecz biorąc nie są użyteczne w składni właściwości, chyba że samego typu obsługuje również składnia elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="5cb74-140">Wyjątkiem jest określenie składni elementu właściwości, ale ma element właściwości zawierają ciąg.</span><span class="sxs-lookup"><span data-stu-id="5cb74-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="5cb74-141">To użycie jest naprawdę zasadniczo równoważne użycie składni atrybutu, a takie użycie nie jest powszechne, chyba że istnieje na potrzeby bardziej niezawodna obsługa białych wartości atrybutu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="5cb74-142">Na przykład Oto użycie elementu właściwości, która przyjmuje ciąg, a użycie atrybutu równoważne:</span><span class="sxs-lookup"><span data-stu-id="5cb74-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="5cb74-143">Przykładem właściwości, gdy atrybut składnia jest dozwolona, ale składni elementu właściwości, który zawiera element z obiektu jest niedozwolona przy użyciu XAML są różne właściwości, które przyjmują <xref:System.Windows.Input.Cursor> typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="5cb74-144"><xref:System.Windows.Input.Cursor> Klasa ma konwertera typów dedykowanych <xref:System.Windows.Input.CursorConverter>, ale nie udostępnia domyślnego konstruktora, więc <xref:System.Windows.FrameworkElement.Cursor%2A> właściwość można ustawić tylko przy użyciu składni atrybutów nawet jeśli rzeczywiste <xref:System.Windows.Input.Cursor> typ jest typem referencyjnym.</span><span class="sxs-lookup"><span data-stu-id="5cb74-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a default constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="5cb74-145">Konwertery typu dla właściwości</span><span class="sxs-lookup"><span data-stu-id="5cb74-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="5cb74-146">Alternatywnie samej właściwości może deklarować konwertera typów na poziomie właściwości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="5cb74-147">Dzięki temu "mini język", który tworzy obiekty typu właściwości w tekście, od przetwarzania przychodzących wartości ciągu atrybutu jako dane wejściowe dla <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operacji na podstawie odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="5cb74-148">Zwykle jest to realizowane w celu zapewnienia dostępu wygody, a nie, jak jedyny oznacza umożliwiające ustawienie właściwości w XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="5cb74-149">Jednak istnieje również możliwość użycia konwerterów typów dla atrybutów, w której chcesz użyć istniejącej [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] typy, które nie zostanie podany, domyślny konstruktor lub konwertera typów opartego na atrybutach.</span><span class="sxs-lookup"><span data-stu-id="5cb74-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a default constructor or an attributed type converter.</span></span> <span data-ttu-id="5cb74-150">Przykłady z [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] interfejsu API są określone właściwości, które przyjmują <xref:System.Globalization.CultureInfo> typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="5cb74-151">W tym przypadku [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] używane istniejące Microsoft .NET Framework <xref:System.Globalization.CultureInfo> typ, aby lepiej scenariuszy zgodności i migracji, które były używane w starszych wersjach struktur, ale <xref:System.Globalization.CultureInfo> typ nie obsługuje niezbędnych Konstruktory lub konwersja typu poziomie typu, może być używany jako wartość właściwości XAML w bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="5cb74-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="5cb74-152">Zawsze, gdy udostępnisz właściwość, która ma użycie XAML, szczególnie, jeśli jesteś autorem formantu, należy zdecydowanie rozważyć kopii tej właściwości przy użyciu właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="5cb74-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="5cb74-153">Jest to szczególnie istotne, jeśli używasz istniejącego [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementacji procesora XAML, ponieważ może zwiększyć wydajność przy użyciu <xref:System.Windows.DependencyProperty> kopii.</span><span class="sxs-lookup"><span data-stu-id="5cb74-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="5cb74-154">Właściwości zależności udostępni właściwości funkcji systemu dla usługi właściwości nadchodzące użytkowników można oczekiwać dla właściwości dostępne XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="5cb74-155">W tym funkcje, takie jak animacji, powiązanie danych oraz obsługę stylów.</span><span class="sxs-lookup"><span data-stu-id="5cb74-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="5cb74-156">Aby uzyskać więcej informacji, zobacz [niestandardowe właściwości zależności](custom-dependency-properties.md) i [właściwości zależności i ładowania XAML](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="5cb74-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="5cb74-157">Pisanie i przypisywanie konwertera typów</span><span class="sxs-lookup"><span data-stu-id="5cb74-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="5cb74-158">Czasami musisz napisać niestandardowy <xref:System.ComponentModel.TypeConverter> klasy, aby zapewnić konwersja typu dla danego typu właściwości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="5cb74-159">Aby uzyskać instrukcje na temat dziedziczyć i utworzyć konwertera typów, który może obsługiwać użycia XAML i jak stosować <xref:System.ComponentModel.TypeConverterAttribute>, zobacz [TypeConverters i XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="5cb74-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="5cb74-160">Wymagania dotyczące Składnia atrybutu XAML zdarzenia programu obsługi zdarzeń klasę niestandardową</span><span class="sxs-lookup"><span data-stu-id="5cb74-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="5cb74-161">Może być używany jako [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] zdarzeń, zdarzenia muszą być widoczne jako publiczne zdarzenie w klasie, która obsługuje domyślnego konstruktora, lub na abstrakcyjną klasę, której możliwy zdarzenia w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="5cb74-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a default constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="5cb74-162">Aby możliwe było użycie wygodnie jako zdarzenia trasowane, Twoje [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] zdarzeń powinny implementować jawne `add` i `remove` metody, które Dodawanie i usuwanie programów obsługi dla [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] podpisu zdarzenia i przekazuje te programy obsługi, aby <xref:System.Windows.UIElement.AddHandler%2A>i <xref:System.Windows.UIElement.RemoveHandler%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="5cb74-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="5cb74-163">Te metody Dodaj lub usuń programy obsługi do magazynu program obsługi zdarzenia trasowanego w wystąpieniu, które zdarzenie jest dołączony do.</span><span class="sxs-lookup"><span data-stu-id="5cb74-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5cb74-164">Można zarejestrować programy obsługi bezpośrednio za pomocą zdarzenia trasowane <xref:System.Windows.UIElement.AddHandler%2A>oraz do definiowania celowo nie [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] zdarzeń, który przedstawia zdarzenia trasowanego.</span><span class="sxs-lookup"><span data-stu-id="5cb74-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="5cb74-165">To jest zwykle niezalecane, ponieważ zdarzenie nie umożliwi XAML Składnia atrybutu Dołączanie programów obsługi i klasa wynikowy będzie oferować mniej przejrzystego widoku XAML możliwości tego typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="5cb74-166">Zapisywanie właściwości kolekcji</span><span class="sxs-lookup"><span data-stu-id="5cb74-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="5cb74-167">Właściwości, które przyjmują typ kolekcji mają składnia XAML, która pozwala na określenie obiektów, które są dodawane do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="5cb74-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="5cb74-168">Ta składnia ma dwie ważne funkcje.</span><span class="sxs-lookup"><span data-stu-id="5cb74-168">This syntax has two notable features.</span></span>  
  
-   <span data-ttu-id="5cb74-169">Obiekt, który jest obiektem kolekcji nie musi być określona w składni obiektów.</span><span class="sxs-lookup"><span data-stu-id="5cb74-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="5cb74-170">Obecności tego typu kolekcji jest niejawne, gdy właściwość zostanie określona w XAML, która przyjmuje typ kolekcji.</span><span class="sxs-lookup"><span data-stu-id="5cb74-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
-   <span data-ttu-id="5cb74-171">Elementy podrzędne kolekcji właściwości kod znaczników, są przetwarzane stawali się członkami kolekcji.</span><span class="sxs-lookup"><span data-stu-id="5cb74-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="5cb74-172">Normalnie, kodu dostępu do elementów członkowskich kolekcji odbywa się za pośrednictwem listy/słownik metody takie jak `Add`, lub za pośrednictwem indeksatora.</span><span class="sxs-lookup"><span data-stu-id="5cb74-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="5cb74-173">Ale składnia XAML nie obsługuje metody lub indeksatorów (wyjątek: XAML 2009 może obsługiwać metody, ale przy użyciu XAML 2009 ogranicza możliwości użycia WPF; zobacz [XAML 2009 — funkcje językowe](../../xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="5cb74-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="5cb74-174">Kolekcje oczywiście są bardzo typowym wymogiem dla tworzenia drzewa elementów i potrzebujesz jakiś sposób, aby wypełnić te kolekcje w programie XAML deklaratywnego.</span><span class="sxs-lookup"><span data-stu-id="5cb74-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="5cb74-175">W związku z tym elementy podrzędne elementu właściwości kolekcji są przetwarzane przez dodanie ich do kolekcji, która jest wartością typu właściwości kolekcji.</span><span class="sxs-lookup"><span data-stu-id="5cb74-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="5cb74-176">Implementacji .NET Framework XAML Services, a tym samym procesora WPF XAML używa następującej definicji dla co stanowi właściwości kolekcji.</span><span class="sxs-lookup"><span data-stu-id="5cb74-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="5cb74-177">Właściwość typu właściwości musi implementować jeden z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="5cb74-177">The property type of the property must implement one of the following:</span></span>  
  
-   <span data-ttu-id="5cb74-178">Implementuje <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="5cb74-178">Implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="5cb74-179">Implementuje <xref:System.Collections.IDictionary> lub odpowiednika rodzajowego (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="5cb74-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
-   <span data-ttu-id="5cb74-180">Pochodzi od klasy <xref:System.Array> (Aby uzyskać więcej informacji na temat tablic w XAML, zobacz [x: Array — rozszerzenie znaczników](../../xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="5cb74-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
-   <span data-ttu-id="5cb74-181">Implementuje <xref:System.Windows.Markup.IAddChild> (interfejs zdefiniowany przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="5cb74-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="5cb74-182">Każdy z tych typów w środowisku CLR ma `Add` metody, która jest używana przez procesor XAML do dodawania elementów do kolekcji źródłowej, podczas tworzenia wykresu obiektu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5cb74-183">Ogólny `List` i `Dictionary` interfejsów (<xref:System.Collections.Generic.IList%601> i <xref:System.Collections.Generic.IDictionary%602>) nie są obsługiwane w przypadku kolekcji wykrywania przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] procesora XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="5cb74-184">Można jednak użyć <xref:System.Collections.Generic.List%601> klasy jako klasę bazową, ponieważ implementuje <xref:System.Collections.IList> bezpośrednio lub <xref:System.Collections.Generic.Dictionary%602> jako klasa bazowa, ponieważ implementuje <xref:System.Collections.IDictionary> bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="5cb74-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="5cb74-185">Kiedy Deklarujesz właściwość z kolekcji, należy zachować ostrożność, jak wartość tej właściwości jest inicjowana w nowych wystąpień tego typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="5cb74-186">Przed zaimplementowaniem nie właściwość jako właściwość zależności, następnie właściwość korzystać z polem zapasowym, który wywołuje konstruktora typu kolekcji jest odpowiednie.</span><span class="sxs-lookup"><span data-stu-id="5cb74-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="5cb74-187">Jeśli Twoja własność jest właściwość zależności, może być potrzebne do zainicjowania właściwości kolekcji jako część domyślnego konstruktora typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="5cb74-188">Jest to spowodowane właściwości zależności przyjmuje wartość domyślną z metadanych i zwykle nie chcesz początkowa wartość właściwości kolekcji jako kolekcji statyczne, udostępniony.</span><span class="sxs-lookup"><span data-stu-id="5cb74-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="5cb74-189">Powinna istnieć wystąpienie kolekcji, dla każdego zawierające wystąpienie typu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="5cb74-190">Aby uzyskać więcej informacji, zobacz [niestandardowe właściwości zależności](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="5cb74-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="5cb74-191">Dla właściwości z kolekcji, można zaimplementować niestandardowej kolekcji typów.</span><span class="sxs-lookup"><span data-stu-id="5cb74-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="5cb74-192">Ze względu na traktowanie właściwość niejawnej kolekcji niestandardowej kolekcji typów konieczne nie udostępnia domyślnego konstruktora, aby możliwe było użycie niejawnie w XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-192">Because of implicit collection property treatment, the custom collection type does not need to provide a default constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="5cb74-193">Opcjonalnie może jednak zapewniać domyślnego konstruktora dla typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="5cb74-193">However, you can optionally provide a default constructor for the collection type.</span></span> <span data-ttu-id="5cb74-194">Może to być rozwiązaniem cenna.</span><span class="sxs-lookup"><span data-stu-id="5cb74-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="5cb74-195">O ile nie udostępnia domyślnego konstruktora, nie można jawnie zadeklarować kolekcji jako elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="5cb74-195">Unless you do provide a default constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="5cb74-196">Niektóre autorzy znaczników może preferować jawne kolekcji jako styl znaczników.</span><span class="sxs-lookup"><span data-stu-id="5cb74-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="5cb74-197">Ponadto Konstruktor domyślny może uprościć wymagania inicjowania podczas tworzenia nowych obiektów używających typu kolekcji jako wartość właściwości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-197">Also, a default constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="5cb74-198">Deklarowanie właściwości zawartości XAML</span><span class="sxs-lookup"><span data-stu-id="5cb74-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="5cb74-199">Język XAML definiuje pojęcie [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] zawartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="5cb74-200">Każda klasa, którego można używać w składni obiekt może mieć dokładnie jedną właściwość zawartości XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="5cb74-201">Aby zadeklarować właściwość, która ma być właściwość zawartości XAML dla swojej klasy, należy zastosować <xref:System.Windows.Markup.ContentPropertyAttribute> jako część definicji klasy.</span><span class="sxs-lookup"><span data-stu-id="5cb74-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="5cb74-202">Określ nazwę zamierzony właściwość zawartości XAML, jako <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> w atrybucie.</span><span class="sxs-lookup"><span data-stu-id="5cb74-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="5cb74-203">Właściwość jest określony jako ciąg według nazwy, a nie jako konstrukcję odbicia takich jak <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="5cb74-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="5cb74-204">Można określić właściwości kolekcji właściwość zawartości XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="5cb74-205">Powoduje to wykorzystania dla tej właściwości, według której object element może mieć jeden lub więcej elementów podrzędnych, bez żadnych pośredniczące elementów obiektu kolekcji ani tagów elementu właściwości.</span><span class="sxs-lookup"><span data-stu-id="5cb74-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="5cb74-206">Elementy te są następnie traktowane jako wartość właściwości zawartości XAML i dodane do wystąpienia kolekcji zapasowy.</span><span class="sxs-lookup"><span data-stu-id="5cb74-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="5cb74-207">Niektóre istniejące właściwości zawartości XAML używają tego typu właściwości `Object`.</span><span class="sxs-lookup"><span data-stu-id="5cb74-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="5cb74-208">Dzięki temu zawartości, takie jak wartości właściwości, która może przyjąć pierwotne XAML <xref:System.String> oraz biorąc wartość obiektu jedno odwołanie.</span><span class="sxs-lookup"><span data-stu-id="5cb74-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="5cb74-209">Wykonanie tego modelu typu jest odpowiedzialny za określenie typu, a także obsługę możliwych typów.</span><span class="sxs-lookup"><span data-stu-id="5cb74-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="5cb74-210">Typową przyczyną <xref:System.Object> zawartości, typ służy do obsługi zarówno prostym sposobem dodawania zawartości obiektu jako ciąg (który odbiera traktowania prezentacji domyślne) lub zaawansowanych oznacza dodawanie obiektów zawartości, która określa prezentacji innych niż domyślne lub dodatkowe dane.</span><span class="sxs-lookup"><span data-stu-id="5cb74-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="5cb74-211">Serializacja XAML</span><span class="sxs-lookup"><span data-stu-id="5cb74-211">Serializing XAML</span></span>  
 <span data-ttu-id="5cb74-212">W przypadku niektórych scenariuszy, na przykład jeśli jesteś autorem formantu, możesz również chcieć zapewnić, że wszelkie reprezentację obiektu, który może być utworzone w XAML może również być Zserializowany do równoważne znaczników XAML.</span><span class="sxs-lookup"><span data-stu-id="5cb74-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="5cb74-213">Serializacja wymagania nie zostały opisane w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="5cb74-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="5cb74-214">Zobacz [kontrolować Przegląd autorstwa](../controls/control-authoring-overview.md) i [drzewo elementów i serializacja](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="5cb74-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5cb74-215">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="5cb74-215">See also</span></span>

- [<span data-ttu-id="5cb74-216">Omówienie XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="5cb74-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="5cb74-217">Niestandardowe właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="5cb74-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="5cb74-218">Przegląd Autorstwo formantów</span><span class="sxs-lookup"><span data-stu-id="5cb74-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="5cb74-219">Przegląd Elementy bazy</span><span class="sxs-lookup"><span data-stu-id="5cb74-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="5cb74-220">Właściwości zależności i ładowania XAML</span><span class="sxs-lookup"><span data-stu-id="5cb74-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
