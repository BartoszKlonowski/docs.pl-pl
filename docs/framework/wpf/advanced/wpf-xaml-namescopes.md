---
title: Zakresy nazw WPF XAML
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: a46942188fd417b46ba4feb44d436800e1362098
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "61764650"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="4a733-102">Zakresy nazw WPF XAML</span><span class="sxs-lookup"><span data-stu-id="4a733-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="4a733-103">Zakresy nazw XAML to pojęcie, który identyfikuje obiekty, które są definiowane w XAML.</span><span class="sxs-lookup"><span data-stu-id="4a733-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="4a733-104">Nazwy w XAML namescope może służyć do ustanawiania relacji między nazwami zdefiniowane XAML, obiektów i ich odpowiedniki wystąpienia drzewem obiektu.</span><span class="sxs-lookup"><span data-stu-id="4a733-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="4a733-105">Zazwyczaj zakresy XAML nazw w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] zarządzanego kodu są tworzone podczas ładowania strony XAML poszczególnych obiektów głównych dla aplikacji XAML.</span><span class="sxs-lookup"><span data-stu-id="4a733-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="4a733-106">Zakresy nazw XAML, co obiekt programowania są definiowane przez <xref:System.Windows.Markup.INameScope> interfejsu, a także są implementowane przez klasy praktyczne <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="4a733-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="4a733-107">Zakresy nazw w aplikacjach XAML załadowane</span><span class="sxs-lookup"><span data-stu-id="4a733-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="4a733-108">W szerszym programowania lub komputera do nauki o kontekście pojęcia dotyczące programowania często zawierają zasady unikatowego identyfikatora lub nazwy, która może służyć do dostępu do obiektu.</span><span class="sxs-lookup"><span data-stu-id="4a733-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="4a733-109">W systemach używających nazwy lub identyfikatory namescope definiuje granic w ramach procesu lub techniki wyszuka, jeśli wymagana jest obiekt o tej nazwie lub granice, w którym unikatowość nazwy identyfikowania jest wymuszany.</span><span class="sxs-lookup"><span data-stu-id="4a733-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="4a733-110">Te zasady ogólne są względem niego spełnione zakresy nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="4a733-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="4a733-111">W środowisku WPF zakresy nazw XAML są tworzone dla elementu głównego dla strony XAML podczas ładowania strony.</span><span class="sxs-lookup"><span data-stu-id="4a733-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="4a733-112">Każda nazwa określona w obrębie strony XAML, począwszy od głównego strony jest dodawany do odpowiednich namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="4a733-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="4a733-113">W WPF XAML, elementy, które są wspólne elementy katalogu głównego (takie jak <xref:System.Windows.Controls.Page>, i <xref:System.Windows.Window>) zawsze kontrolować XAML namescope.</span><span class="sxs-lookup"><span data-stu-id="4a733-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="4a733-114">Jeśli element, takie jak <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement> jest głównym elementem strony w znaczniku, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] procesor dodaje <xref:System.Windows.Controls.Page> główny niejawnie tak, aby <xref:System.Windows.Controls.Page> może zapewnić namescope XAML pracy.</span><span class="sxs-lookup"><span data-stu-id="4a733-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4a733-115">Akcje kompilacji WPF tworzenie namescope XAML w celach produkcyjnych XAML nawet, jeśli nie `Name` lub `x:Name` na dowolnych elementów zdefiniowanych atrybutów [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] znaczników.</span><span class="sxs-lookup"><span data-stu-id="4a733-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="4a733-116">Jeśli spróbujesz użyć takiej samej nazwie dwa razy w dowolnym namescope XAML, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4a733-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="4a733-117">Dla WPF XAML, ma związanym z kodem, który jest częścią skompilowanej aplikacji zgłaszany jest wyjątek w czasie kompilacji przez akcje kompilacji WPF, tworząc wygenerowanej klasy dla strony podczas kompilacji znaczników początkowej.</span><span class="sxs-lookup"><span data-stu-id="4a733-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="4a733-118">Dla XAML, który nie jest kompilowana do znaczników przez dowolną akcję kompilacji wyjątków związanych z emisją namescope XAML może zostać wywołane, gdy XAML jest ładowany.</span><span class="sxs-lookup"><span data-stu-id="4a733-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="4a733-119">Projektantów XAML może również przewidywać problemy namescope XAML w czasie projektowania.</span><span class="sxs-lookup"><span data-stu-id="4a733-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="4a733-120">Dodawanie obiektów do drzewa w obiekcie środowiska wykonawczego</span><span class="sxs-lookup"><span data-stu-id="4a733-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="4a733-121">Obecnie, który jest analizowany XAML reprezentuje moment w czasie, który namescope WPF XAML jest utworzone i zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="4a733-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="4a733-122">Jeśli obiekt jest dodawany do drzewa obiektów w punkcie w czasie po XAML, który tree był analizowany, `Name` lub `x:Name` wartość dla nowego obiektu nie jest aktualizowane automatycznie informacje zawarte w XAML namescope.</span><span class="sxs-lookup"><span data-stu-id="4a733-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="4a733-123">Aby dodać nazwę obiektu do namescope WPF XAML, po załadowaniu XAML, należy wywołać wprowadzenia <xref:System.Windows.Markup.INameScope.RegisterName%2A> na obiekt, który definiuje XAML namescope, który jest zazwyczaj główny strony XAML.</span><span class="sxs-lookup"><span data-stu-id="4a733-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="4a733-124">Jeśli nazwa nie jest zarejestrowany, dodany obiekt nie może odwoływać się nazwy za pomocą metody takie jak <xref:System.Windows.FrameworkElement.FindName%2A>, i nie możesz użyć tej nazwy języka animacji.</span><span class="sxs-lookup"><span data-stu-id="4a733-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="4a733-125">Najbardziej typowym scenariuszem dla deweloperów aplikacji jest, że używany jest program <xref:System.Windows.FrameworkElement.RegisterName%2A> do rejestracji nazw na namescope XAML w katalogu głównym bieżącej strony.</span><span class="sxs-lookup"><span data-stu-id="4a733-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="4a733-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> jest to ważne scenorysów tego obiektów docelowych dla animacji.</span><span class="sxs-lookup"><span data-stu-id="4a733-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="4a733-127">Aby uzyskać więcej informacji, zobacz [Przegląd Scenorysy](../graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4a733-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="4a733-128">Jeśli wywołasz <xref:System.Windows.FrameworkElement.RegisterName%2A> do obiektu innego niż obiekt, który definiuje XAML namescope, nazwa jest nadal zarejestrowany namescope XAML, przechowywanych w ramach, obiekt wywołujący tak, jakby były nazywane <xref:System.Windows.FrameworkElement.RegisterName%2A> na namescope XAML, definiując obiektu.</span><span class="sxs-lookup"><span data-stu-id="4a733-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="4a733-129">Zakresy nazw XAML, w kodzie</span><span class="sxs-lookup"><span data-stu-id="4a733-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="4a733-130">Można tworzyć i następnie użyć XAML zakresy nazw w kodzie.</span><span class="sxs-lookup"><span data-stu-id="4a733-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="4a733-131">Interfejsy API i pojęcia związane z XAML namescope tworzenia są takie same, nawet w przypadku użycia czystym kodzie, ponieważ procesor XAML dla [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] używa tych interfejsów API i pojęcia, podczas przetwarzania XAML sam.</span><span class="sxs-lookup"><span data-stu-id="4a733-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="4a733-132">Pojęcia i interfejsu API istnieją głównie na potrzeby z brakiem obiektów według nazwy w obrębie drzewa obiektów, które zwykle definiuje się częściowo lub całkowicie w XAML.</span><span class="sxs-lookup"><span data-stu-id="4a733-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="4a733-133">Dla aplikacji, które są tworzone programowo, a nie z XAML załadowane, obiekt, który definiuje XAML namescope musi implementować <xref:System.Windows.Markup.INameScope>, lub być <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement> pochodne klasy, w celu obsługi tworzenia XAML namescope na jego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4a733-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="4a733-134">Ponadto dla każdego elementu, który nie jest załadowane i przetworzone przez procesor XAML namescope XAML dla tego obiektu nie utworzeniu lub zainicjowana domyślnie.</span><span class="sxs-lookup"><span data-stu-id="4a733-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="4a733-135">Należy jawnie utworzyć nowe namescope XAML dla dowolnego obiektu, który ma zostać następnie zarejestruj nazwy do.</span><span class="sxs-lookup"><span data-stu-id="4a733-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="4a733-136">Aby utworzyć XAML namescope, wywołaj statyczną <xref:System.Windows.NameScope.SetNameScope%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4a733-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="4a733-137">Określ obiekt, który jest właścicielem go jako `dependencyObject` parametr i nową <xref:System.Windows.NameScope.%23ctor%2A> wywołanie konstruktora jako `value` parametru.</span><span class="sxs-lookup"><span data-stu-id="4a733-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="4a733-138">Jeśli obiekt jest przewidziana `dependencyObject` dla <xref:System.Windows.NameScope.SetNameScope%2A> nie jest <xref:System.Windows.Markup.INameScope> implementacji <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>, wywoływania <xref:System.Windows.FrameworkElement.RegisterName%2A> na wszystkie podrzędne elementy będą miały żadnego wpływu.</span><span class="sxs-lookup"><span data-stu-id="4a733-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="4a733-139">Jeśli nie zostanie jawnie tworzyć nowe namescope XAML, następnie wywołuje metodę do <xref:System.Windows.FrameworkElement.RegisterName%2A> zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4a733-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="4a733-140">Aby uzyskać przykład użycia XAML namescope interfejsów API w kodzie, zobacz [Definiuj zakres nazw](../graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="4a733-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="4a733-141">Zakresy nazw XAML, style i szablony</span><span class="sxs-lookup"><span data-stu-id="4a733-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="4a733-142">Style i szablony w [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] zapewniają możliwość ponownego użycia i ponownie zastosować zawartość w prosty sposób.</span><span class="sxs-lookup"><span data-stu-id="4a733-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="4a733-143">Jednak — style i szablony mogą również obejmować elementy o nazwach XAML zdefiniowane na poziomie szablonu.</span><span class="sxs-lookup"><span data-stu-id="4a733-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="4a733-144">Na stronie tego samego szablonu mogą być używane wielokrotnie.</span><span class="sxs-lookup"><span data-stu-id="4a733-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="4a733-145">Z tego powodu — style i szablony zdefiniować własne zakresy nazw XAML, niezależnie od lokalizacji, niezależnie od drzewa obiektów, w której stosowana jest stylem lub szablonem.</span><span class="sxs-lookup"><span data-stu-id="4a733-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="4a733-146">Rozważmy następujący przykład:</span><span class="sxs-lookup"><span data-stu-id="4a733-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="4a733-147">W tym miejscu tego samego szablonu jest stosowane do dwóch różnych przycisków.</span><span class="sxs-lookup"><span data-stu-id="4a733-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="4a733-148">Jeśli szablony nie miał kolumną dyskretną XAML zakresy nazw, `TheBorder` nazwa używana w szablonie spowodowałoby kolizję nazw w XAML namescope.</span><span class="sxs-lookup"><span data-stu-id="4a733-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="4a733-149">Każdego wystąpienia szablonu ma swój własny namescope XAML, więc w tym przykładzie namescope XAML każdego wystąpień szablonu będzie zawierać dokładnie jedną nazwę.</span><span class="sxs-lookup"><span data-stu-id="4a733-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="4a733-150">Style również definiować własne namescope XAML, przede wszystkim, dzięki czemu w części scenorysów mają szczególne nazwy przypisane.</span><span class="sxs-lookup"><span data-stu-id="4a733-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="4a733-151">Te nazwy Włącz kontroli zachowań określonych przeznaczonych elementów tej samej nazwie, nawet jeśli ponownie zdefiniowano szablon jako część niestandardowe Dostosowywanie formantu.</span><span class="sxs-lookup"><span data-stu-id="4a733-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="4a733-152">Ze względu na oddzielnych XAML zakresy nazw, wyszukiwanie elementów o nazwie w szablonie jest bardziej trudniejsze niż wyszukiwanie bez szablonu o nazwie elementu na stronie.</span><span class="sxs-lookup"><span data-stu-id="4a733-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="4a733-153">Najpierw musisz określić zastosowany szablon, uzyskując <xref:System.Windows.Controls.Control.Template%2A> wartość właściwości kontrolki, w której jest stosowany szablon.</span><span class="sxs-lookup"><span data-stu-id="4a733-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="4a733-154">Następnie należy wywołać wersję szablonu <xref:System.Windows.FrameworkTemplate.FindName%2A>, przekazując kontrolę, gdy szablon został zastosowany jako drugi parametr.</span><span class="sxs-lookup"><span data-stu-id="4a733-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="4a733-155">Jeśli jesteś autorem formantu i generują Konwencję, w której określonego o nazwie elementu w szablonie stosowane jest elementem docelowym, do zachowania w zakresie, który jest definiowany przez sam formant, możesz użyć <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> metody z kodu realizacji kontroli.</span><span class="sxs-lookup"><span data-stu-id="4a733-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="4a733-156"><xref:System.Windows.FrameworkElement.GetTemplateChild%2A> Jest chroniony, tylko autor kontrolka ma do niego dostęp.</span><span class="sxs-lookup"><span data-stu-id="4a733-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="4a733-157">Jeśli pracujesz z w ramach szablonu i trzeba przejść do XAML namescope, w którym szablon jest stosowany, należy uzyskać wartość <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, a następnie wywołaj <xref:System.Windows.FrameworkElement.FindName%2A> istnieje.</span><span class="sxs-lookup"><span data-stu-id="4a733-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="4a733-158">Przykładem pracy w ramach szablonu będzie, jeśli piszesz implementacja programu obsługi zdarzeń gdy zdarzenie zostanie wygenerowany z elementu w szablonie zastosowane.</span><span class="sxs-lookup"><span data-stu-id="4a733-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="4a733-159">Zakresy nazw XAML i powiązane z nazwą interfejsy API</span><span class="sxs-lookup"><span data-stu-id="4a733-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="4a733-160"><xref:System.Windows.FrameworkElement> ma <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> i <xref:System.Windows.FrameworkElement.UnregisterName%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4a733-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="4a733-161">Jeśli obiekt, który chcesz wywołać tych metod w uznaje XAML namescope, metody wywołania do metod odpowiednich namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="4a733-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="4a733-162">W przeciwnym razie elementu nadrzędnego jest sprawdzenie, jeśli jest ona właścicielem XAML namescope, a ten proces jest kontynuowany cyklicznie, aż do znalezienia XAML namescope (ze względu na zachowanie procesora XAML, może być namescope XAML, w katalogu głównym).</span><span class="sxs-lookup"><span data-stu-id="4a733-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="4a733-163"><xref:System.Windows.FrameworkContentElement> ma analogiczne zachowania, z wyjątkiem tego, który nie <xref:System.Windows.FrameworkContentElement> nigdy nie będą właścicielami XAML namescope.</span><span class="sxs-lookup"><span data-stu-id="4a733-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="4a733-164">Metody istnieje na <xref:System.Windows.FrameworkContentElement> tak, aby wywołania, które mogą być przekazywane ostatecznie do <xref:System.Windows.FrameworkElement> elementu nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="4a733-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="4a733-165"><xref:System.Windows.NameScope.SetNameScope%2A> Służy do mapowania nowych namescope XAML do istniejącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="4a733-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="4a733-166">Możesz wywołać <xref:System.Windows.NameScope.SetNameScope%2A> więcej niż jeden raz w celu resetowania lub wyczyść XAML namescope, ale nie jest wspólne użycie.</span><span class="sxs-lookup"><span data-stu-id="4a733-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="4a733-167">Ponadto <xref:System.Windows.NameScope.GetNameScope%2A> nie jest zazwyczaj używana w kodzie.</span><span class="sxs-lookup"><span data-stu-id="4a733-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="4a733-168">Implementacje Namescope XAML</span><span class="sxs-lookup"><span data-stu-id="4a733-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="4a733-169">Następujące klasy implementacji <xref:System.Windows.Markup.INameScope> bezpośrednio:</span><span class="sxs-lookup"><span data-stu-id="4a733-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="4a733-170"><xref:System.Windows.ResourceDictionary> nie korzysta z nazw XAML lub zakresy nazw; korzysta z kluczy zamiast tego, ponieważ jest on implementacji słownika.</span><span class="sxs-lookup"><span data-stu-id="4a733-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="4a733-171">Tylko przyczyny <xref:System.Windows.ResourceDictionary> implementuje <xref:System.Windows.Markup.INameScope> jest, dzięki czemu można podnieść, wyjątki, aby kod użytkownika, które pomóc w wyjaśnianiu rozróżnienie między true XAML namescope oraz w jaki sposób <xref:System.Windows.ResourceDictionary> obsługuje kluczy, a także po to, aby mieć pewność, że zakresy nazw XAML nie są stosowane do <xref:System.Windows.ResourceDictionary> przez elementy nadrzędne.</span><span class="sxs-lookup"><span data-stu-id="4a733-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="4a733-172"><xref:System.Windows.FrameworkTemplate> i <xref:System.Windows.Style> zaimplementować <xref:System.Windows.Markup.INameScope> za pomocą definicji interfejsu jawnego.</span><span class="sxs-lookup"><span data-stu-id="4a733-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="4a733-173">Jawne implementacje zezwolić na te zakresy nazw XAML, powszechnie zachowanie, gdy są dostępne za pośrednictwem <xref:System.Windows.Markup.INameScope> interfejs, który jest jak zakresy nazw XAML są przekazywane przez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] procesów wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="4a733-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="4a733-174">Definicje interfejsu jawnego nie są częścią konwencjonalne powierzchni interfejsu API, ale <xref:System.Windows.FrameworkTemplate> i <xref:System.Windows.Style>, ponieważ rzadko występuje konieczność wywołania <xref:System.Windows.Markup.INameScope> metod <xref:System.Windows.FrameworkTemplate> i <xref:System.Windows.Style> bezpośrednio, a zamiast tego użyć innego interfejsu API takie jak <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="4a733-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="4a733-175">Poniższe klasy definiują własne namescope XAML przy użyciu <xref:System.Windows.NameScope?displayProperty=nameWithType> klasy pomocnika oraz połączenie z jego implementacja namescope XAML za pośrednictwem <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> dołączona właściwość:</span><span class="sxs-lookup"><span data-stu-id="4a733-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="4a733-176">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="4a733-176">See also</span></span>

- [<span data-ttu-id="4a733-177">Przestrzeń nazw XAML i mapowanie przestrzeni nazw dla WPF XAML</span><span class="sxs-lookup"><span data-stu-id="4a733-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="4a733-178">x:Name, dyrektywa</span><span class="sxs-lookup"><span data-stu-id="4a733-178">x:Name Directive</span></span>](../../xaml-services/x-name-directive.md)
