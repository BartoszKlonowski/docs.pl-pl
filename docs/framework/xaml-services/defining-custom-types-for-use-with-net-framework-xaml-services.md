---
title: Definiowanie typów niestandardowych do użytku z usługami .NET Framework XAML
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/08/2019
ms.locfileid: "59164440"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="48f64-102">Definiowanie typów niestandardowych do użytku z usługami .NET Framework XAML</span><span class="sxs-lookup"><span data-stu-id="48f64-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="48f64-103">Definiowanie typów niestandardowych, które są obiektami biznesowych lub typów, które nie są zależne od określonych platform, istnieją niektóre najlepsze rozwiązania dotyczące XAML, które możesz wykonać.</span><span class="sxs-lookup"><span data-stu-id="48f64-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="48f64-104">Jeśli wykonujesz tych rozwiązań, usług programu .NET Framework XAML, a jego XAML czytników i składników zapisywania XAML może odnajdywać właściwości XAML danego typu i nadaj mu odpowiednią reprezentację w postaci strumienia węzłów XAML w systemie typu XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="48f64-105">W tym temacie opisano najlepsze rozwiązania dotyczące definicji typu, definicje elementów członkowskich i przypisywanie CLR, typy lub członków.</span><span class="sxs-lookup"><span data-stu-id="48f64-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="48f64-106">Wzorce konstruktora i definicji typu dla XAML</span><span class="sxs-lookup"><span data-stu-id="48f64-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="48f64-107">Z myślą o uruchamianiu jako elementu obiektu w XAML, niestandardowej klasy musi spełniać następujące wymagania:</span><span class="sxs-lookup"><span data-stu-id="48f64-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="48f64-108">Klasa niestandardowa musi być publiczna i musi uwidaczniać domyślnego (bezparametrowego) konstruktora publicznego.</span><span class="sxs-lookup"><span data-stu-id="48f64-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="48f64-109">(Zobacz następujące sekcji uwag dotyczących struktury).</span><span class="sxs-lookup"><span data-stu-id="48f64-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="48f64-110">Klasa niestandardowa nie może być klasą zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="48f64-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="48f64-111">Dodatkowy "dot" w ścieżce pełnej nazwy sprawia, że dzielenie przestrzeń nazw klasy jest niejednoznaczne i zakłóca działanie innych funkcji XAML, takich jak dołączone właściwości.</span><span class="sxs-lookup"><span data-stu-id="48f64-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="48f64-112">Jeśli obiekt może być utworzone jako elementu obiektu, utworzony obiekt wypełnić formularz elementu właściwości wszystkich właściwości, które przyjmują obiektu jako ich typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="48f64-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="48f64-113">Nadal można podać obiekt wartości dla typów, które nie spełniają tych kryteriów, po włączeniu konwertera wartości.</span><span class="sxs-lookup"><span data-stu-id="48f64-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="48f64-114">Aby uzyskać więcej informacji, zobacz [typy konwerterów i rozszerzenia znaczników dla XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="48f64-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="48f64-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="48f64-115">Structures</span></span>  
 <span data-ttu-id="48f64-116">Struktury mogą zawsze być zbudowane w XAML, zgodnie z definicją CLR.</span><span class="sxs-lookup"><span data-stu-id="48f64-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="48f64-117">Jest to spowodowane kompilatora CLR niejawnie tworzy domyślny konstruktor dla struktury.</span><span class="sxs-lookup"><span data-stu-id="48f64-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="48f64-118">Ten konstruktor inicjuje wszystkie wartości właściwości do wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="48f64-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="48f64-119">W niektórych przypadkach domyślne zachowanie konstrukcji dla struktury nie jest pożądane.</span><span class="sxs-lookup"><span data-stu-id="48f64-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="48f64-120">Być może struktura ma pod względem koncepcyjnym jako złożenie wypełnij wartości i funkcji.</span><span class="sxs-lookup"><span data-stu-id="48f64-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="48f64-121">Jako Unii zawarte wartości mogą być interpretacji wzajemnie się wykluczają, a w związku z tym, czy żaden z jej właściwości można ustawić.</span><span class="sxs-lookup"><span data-stu-id="48f64-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="48f64-122">Na przykład struktury w słownictwa WPF <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="48f64-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="48f64-123">Te struktury powinny implementować konwertera typów, tak, aby wartości mogą być wyrażone w formie atrybutu przy użyciu konwencji ciągu, tworzone różne interpretacji lub tryby wartości struktury.</span><span class="sxs-lookup"><span data-stu-id="48f64-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="48f64-124">Struktura również powinny ujawniać zachowanie podobne do tworzenia kodu za pośrednictwem konstruktora innych niż domyślne.</span><span class="sxs-lookup"><span data-stu-id="48f64-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="48f64-125">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="48f64-125">Interfaces</span></span>  
 <span data-ttu-id="48f64-126">Interfejsy mogą służyć jako typów podstawowych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="48f64-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="48f64-127">System typów XAML sprawdza listy można przypisać i oczekuje, że obiekt, który jest dostarczana jako wartości można przypisać do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="48f64-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="48f64-128">Nie ma koncepcji jak interfejsu muszą być przedstawione jako typ XAML tak długo, jak odpowiedni typ można przypisać obsługuje wymagania konstrukcji XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="48f64-129">Metodami Factory</span><span class="sxs-lookup"><span data-stu-id="48f64-129">Factory Methods</span></span>  
 <span data-ttu-id="48f64-130">Metodami Factory są funkcją XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="48f64-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="48f64-131">Zasada XAML, że obiekty muszą mieć konstruktory domyślne mogą modyfikować.</span><span class="sxs-lookup"><span data-stu-id="48f64-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="48f64-132">W tym temacie nie opisano metodach fabryki.</span><span class="sxs-lookup"><span data-stu-id="48f64-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="48f64-133">Zobacz [x: FactoryMethod — dyrektywa](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="48f64-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="48f64-134">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="48f64-134">Enumerations</span></span>  
 <span data-ttu-id="48f64-135">Wyliczenia mają zachowanie konwersji typu natywnego XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="48f64-136">Nazwy stałe wyliczeń, określone w XAML zostaną rozwiązane przed podstawowym typem wyliczenia, a następnie wróć na wartość wyliczenia do zapisywania obiektu XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="48f64-137">XAML obsługuje użycie flagi stylu dla wyliczeń ze <xref:System.FlagsAttribute> stosowane.</span><span class="sxs-lookup"><span data-stu-id="48f64-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="48f64-138">Aby uzyskać więcej informacji, zobacz [składnia XAML w szczegółów](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="48f64-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="48f64-139">([Szczegółów w składni XAML](../wpf/advanced/xaml-syntax-in-detail.md) jest przeznaczony dla odbiorców WPF, ale większość informacji w tym temacie jest odpowiednie dla XAML, które nie są specyficzne dla określonej struktury implementującej.)</span><span class="sxs-lookup"><span data-stu-id="48f64-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="48f64-140">Definicje elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="48f64-140">Member Definitions</span></span>  
 <span data-ttu-id="48f64-141">Typy można zdefiniować elementy członkowskie do użycia XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="48f64-142">Istnieje możliwość dla typów, które definiują elementy członkowskie, które są użyteczne XAML, nawet jeśli nie jest XAML można używać tego konkretnego typu.</span><span class="sxs-lookup"><span data-stu-id="48f64-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="48f64-143">Jest to możliwe z powodu dziedziczenia CLR.</span><span class="sxs-lookup"><span data-stu-id="48f64-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="48f64-144">Tak długo, jak pewnego typu, który dziedziczy element członkowski obsługuje XAML użycia jako typ, a element członkowski obsługuje użycia XAML dla jego typu podstawowego lub ma dostępne natywnej składni XAML, ten element członkowski jest użyteczne XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="48f64-145">Właściwości</span><span class="sxs-lookup"><span data-stu-id="48f64-145">Properties</span></span>  
 <span data-ttu-id="48f64-146">Możesz zdefiniować właściwości jako właściwość publiczna CLR przy użyciu typowego CLR `get` i `set` wzorce dostępu i odpowiednim języku temat zgłosić właściwość jako element członkowski o odpowiednie informacje przewidziane systemie typu XAML <xref:System.Xaml.XamlMember> właściwości, takie jak <xref:System.Xaml.XamlMember.IsReadPublic%2A> i <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="48f64-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="48f64-147">Określone właściwości, można włączyć składni tekstu, stosując <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="48f64-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="48f64-148">Aby uzyskać więcej informacji, zobacz [typy konwerterów i rozszerzenia znaczników dla XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="48f64-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="48f64-149">W przypadku braku składni tekstu lub natywnych konwersji XAML i w przypadku braku dalszych pośredniego, takich jak użycie rozszerzenia znaczników, typ właściwości (<xref:System.Xaml.XamlMember.TargetType%2A> system typów XAML) musi mieć możliwość zwrócenia wystąpienia do zapisywania obiektów XAML, traktując t Typ docelowy jako typ CLR.</span><span class="sxs-lookup"><span data-stu-id="48f64-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="48f64-150">Jeśli przy użyciu XAML 2009 r. [x: Reference — rozszerzenie znaczników](x-reference-markup-extension.md) może służyć do Podaj wartości, jeśli poprzednie zagadnienia nie są spełnione; dotyczy to jednak jeden problem użycia, niż problem definicji typu.</span><span class="sxs-lookup"><span data-stu-id="48f64-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="48f64-151">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="48f64-151">Events</span></span>  
 <span data-ttu-id="48f64-152">Jeśli zdefiniujesz zdarzenia jako publiczne zdarzenie środowiska CLR, systemie typu XAML zgłosić zdarzenia jako element członkowski o <xref:System.Xaml.XamlMember.IsEvent%2A> jako `true`.</span><span class="sxs-lookup"><span data-stu-id="48f64-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="48f64-153">Dołączenie procedury obsługi zdarzeń nie jest w zakresie możliwości usług programu .NET Framework XAML; To pole pozostanie do określonej struktury i implementacji.</span><span class="sxs-lookup"><span data-stu-id="48f64-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="48f64-154">Metody</span><span class="sxs-lookup"><span data-stu-id="48f64-154">Methods</span></span>  
 <span data-ttu-id="48f64-155">Wbudowany kod dla metody nie jest to domyślna funkcja XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="48f64-156">W większości przypadków użytkownik nie należy bezpośrednio odwoływać członkowie metody z XAML, a rola metod w XAML jest tylko do zapewnienia obsługi określonych wzorców XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="48f64-157">[x: FactoryMethod — dyrektywa](x-factorymethod-directive.md) jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="48f64-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="48f64-158">Pola</span><span class="sxs-lookup"><span data-stu-id="48f64-158">Fields</span></span>  
 <span data-ttu-id="48f64-159">Wytyczne dotyczące projektowania CLR zniechęcić niestatycznego pola.</span><span class="sxs-lookup"><span data-stu-id="48f64-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="48f64-160">W przypadku pól statycznych, można uzyskać dostęp wartości pól statycznych tylko za pośrednictwem [x: Static — rozszerzenie znaczników](x-static-markup-extension.md); w takim przypadku nie wykonujesz jakieś szczególne w definicji CLR, aby ujawnić pola dla [x: Static](x-static-markup-extension.md) użycia.</span><span class="sxs-lookup"><span data-stu-id="48f64-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="48f64-161">Można dołączyć elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="48f64-161">Attachable Members</span></span>  
 <span data-ttu-id="48f64-162">Można dołączyć elementy członkowskie są ujawniane XAML przy użyciu wzorca metody dostępu na typ definiujący.</span><span class="sxs-lookup"><span data-stu-id="48f64-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="48f64-163">Typ definiujący sam nie trzeba XAML mogą być używane jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="48f64-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="48f64-164">W rzeczywistości jest wspólny wzorzec do deklarowania klasy usługi, którego rola jest właścicielem można dołączyć elementu członkowskiego i zaimplementować zachowania powiązane, ale obsługiwać żadnych innych funkcji, takich jak reprezentacja interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="48f64-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="48f64-165">Dla następujących sekcji, a symbol zastępczy *PropertyName* reprezentuje nazwę usługi można dołączyć elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="48f64-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="48f64-166">Tej nazwy muszą być prawidłowe w [xamlname — gramatyka](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="48f64-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="48f64-167">Należy zachować ostrożność kolizji nazw między te wzorce i innych metod typu.</span><span class="sxs-lookup"><span data-stu-id="48f64-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="48f64-168">Jeśli istnieje element członkowski, który jest zgodny z jednym z wzorców, jego może być interpretowana jako ścieżki użycie można dołączyć elementu członkowskiego przez procesor XAML nawet wtedy, gdy nie było zamiaru.</span><span class="sxs-lookup"><span data-stu-id="48f64-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="48f64-169">Akcesor GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="48f64-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="48f64-170">Podpis dla `Get` *PropertyName* metody dostępu muszą być:</span><span class="sxs-lookup"><span data-stu-id="48f64-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 `public static object Get` *<span data-ttu-id="48f64-171">PropertyName</span><span class="sxs-lookup"><span data-stu-id="48f64-171">PropertyName</span></span>* `(object`  `target` `)`  
  
-   <span data-ttu-id="48f64-172">`target` Obiektu może być określony jako bardziej specyficznego typu w danej implementacji.</span><span class="sxs-lookup"><span data-stu-id="48f64-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="48f64-173">Umożliwia to zakres użycia usługi można dołączyć elementu członkowskiego; użycia spoza zakresu zamierzony zgłosi Nieprawidłowe rzutowanie wyjątki, które następnie są udostępniane przez błąd analizy XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="48f64-174">Nazwa parametru `target` nie jest to wymagane, ale nosi nazwę `target` zgodnie z Konwencją w większości implementacji.</span><span class="sxs-lookup"><span data-stu-id="48f64-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="48f64-175">Zwracana wartość można określić jako bardziej określonego typu w danej implementacji.</span><span class="sxs-lookup"><span data-stu-id="48f64-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="48f64-176">Do obsługi <xref:System.ComponentModel.TypeConverter> składnia tekstu włączone użycie atrybutu można dołączyć elementu członkowskiego, zastosuj <xref:System.ComponentModel.TypeConverterAttribute> do `Get` *PropertyName* metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="48f64-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="48f64-177">Stosowanie do `get` zamiast `set` może wydawać się nonintuitive; jednak ta Konwencja obsługuje pojęcie tylko do odczytu można dołączyć elementy członkowskie, które można serializować, która jest przydatne w scenariuszach projektanta.</span><span class="sxs-lookup"><span data-stu-id="48f64-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="48f64-178">Akcesor SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="48f64-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="48f64-179">Podpis dla zestawu*PropertyName* metody dostępu muszą być:</span><span class="sxs-lookup"><span data-stu-id="48f64-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 `public static void Set` *<span data-ttu-id="48f64-180">PropertyName</span><span class="sxs-lookup"><span data-stu-id="48f64-180">PropertyName</span></span>* `(object`  `target` `, object`  `value` `)`  
  
-   <span data-ttu-id="48f64-181">`target` Obiektu można określić jako bardziej specyficznego typu w danej implementacji, z tej samej logiki i konsekwencje zgodnie z opisem w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="48f64-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="48f64-182">`value` Obiektu może być określony jako bardziej specyficznego typu w danej implementacji.</span><span class="sxs-lookup"><span data-stu-id="48f64-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="48f64-183">Pamiętaj, że wartość ta metoda ma dane wejściowe, pochodzące z użycia XAML, zwykle w formie atrybutu.</span><span class="sxs-lookup"><span data-stu-id="48f64-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="48f64-184">Za pomocą formularza atrybutu musi być konwertera wartości obsługę składni tekstu i atrybutu na `Get` *PropertyName* metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="48f64-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="48f64-185">Można dołączyć magazynów elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="48f64-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="48f64-186">Metody dostępu zwykle nie są wystarczająco, aby stanowić sposób, aby umieścić wartości można dołączyć elementu członkowskiego grafu obiektów lub pobrać wartości z wykresu obiektu i serializacji je poprawnie.</span><span class="sxs-lookup"><span data-stu-id="48f64-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="48f64-187">Do tej funkcji `target` obiektów w poprzednich podpisach dostępu musi być zdolny do przechowywania wartości.</span><span class="sxs-lookup"><span data-stu-id="48f64-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="48f64-188">Mechanizm magazynu powinny być zgodne z zasadą można dołączyć elementu członkowskiego, który można dołączyć do celów, gdzie można dołączyć elementu członkowskiego nie jest na liście elementów członkowskich jest element członkowski.</span><span class="sxs-lookup"><span data-stu-id="48f64-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="48f64-189">.NET framework XAML Services zapewnia techniki implementacji można dołączyć elementu członkowskiego są przechowywane przy użyciu interfejsów API <xref:System.Xaml.IAttachedPropertyStore> i <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="48f64-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <xref:System.Xaml.IAttachedPropertyStore> <span data-ttu-id="48f64-190">jest używana przez autorów XAML do wykrywania Implementacja magazynu i powinny zostać wdrożone na typ, który jest `target` z metod dostępu.</span><span class="sxs-lookup"><span data-stu-id="48f64-190">is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="48f64-191">Statyczne <xref:System.Xaml.AttachablePropertyServices> interfejsy API są używane w treści metody dostępu i dotyczą można dołączyć elementu członkowskiego przez jego <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="48f64-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="48f64-192">Atrybuty CLR związane z XAML</span><span class="sxs-lookup"><span data-stu-id="48f64-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="48f64-193">Poprawnie przypisywanie swoje typy, członków i zestawy ważne jest, aby raport informacje o systemie typu XAML do usług programu .NET Framework XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="48f64-194">Może to być istotne, jeśli zamierzasz typów do użycia w systemach XAML, które opierają się bezpośrednio na .NET Framework XAML Services XAML czytników i składników zapisywania XAML lub zdefiniuj, lub użyj framework przy użyciu XAML, który jest oparty na tych XAML czytników i składników zapisywania XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="48f64-195">Lista każdego atrybutu związane z XAML, odpowiednią obsługę XAML typów niestandardowych, zobacz [XAML-Related atrybuty CLR dla niestandardowych typów i bibliotek](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="48f64-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="48f64-196">Użycie</span><span class="sxs-lookup"><span data-stu-id="48f64-196">Usage</span></span>  
 <span data-ttu-id="48f64-197">Użycie niestandardowych typów wymaga, że autor znaczników musi być mapowane prefiks dla zestawu i przestrzeń nazw środowiska CLR, które zawierają typ niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="48f64-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="48f64-198">Ta procedura nie jest opisane w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="48f64-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="48f64-199">Poziom dostępu</span><span class="sxs-lookup"><span data-stu-id="48f64-199">Access Level</span></span>  
 <span data-ttu-id="48f64-200">XAML udostępnia środki do obciążenia i tworzenie wystąpień typów, które mają `internal` poziom dostępu.</span><span class="sxs-lookup"><span data-stu-id="48f64-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="48f64-201">Ta funkcja jest dostępna, dzięki czemu kod użytkownika mogą definiować własne typy i, tworzy tych klas z kod znaczników, który jest również częścią tego samego zakresu kodu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="48f64-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="48f64-202">Przykładem z WPF jest zawsze wtedy, gdy kod użytkownika definiuje <xref:System.Windows.Controls.UserControl> służy jako sposób Refaktoryzuj zachowania interfejsu użytkownika, ale nie w ramach dowolnego mechanizmu możliwe rozszerzenia, który może wynikać z od zadeklarowania klasy pomocnicze z `public` poziom dostępu.</span><span class="sxs-lookup"><span data-stu-id="48f64-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="48f64-203">Takie <xref:System.Windows.Controls.UserControl> mogą być deklarowane przy użyciu `internal` dostęp, jeśli kod zapasowy jest kompilowany do tego samego zestawu, z którego odwołuje się do pisania XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="48f64-204">Dla aplikacji, która ładuje XAML w trybie pełnego zaufania i używa <xref:System.Xaml.XamlObjectWriter>, trwa ładowanie klas `internal` poziom dostępu jest zawsze włączona.</span><span class="sxs-lookup"><span data-stu-id="48f64-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="48f64-205">Właściwości poziomu dostępu dla aplikacji, która ładuje XAML w częściowej relacji zaufania, można kontrolować za pomocą <xref:System.Xaml.Permissions.XamlAccessLevel> interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="48f64-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="48f64-206">Ponadto mechanizmów opóźnienia (np. system szablonu WPF) musi mieć możliwość Propagacja żadnych uprawnień na poziomie dostępu i zachowanie ich do ostatecznej wykonywania ocen. jest to obsługiwane wewnętrznie przez przekazanie <xref:System.Xaml.Permissions.XamlAccessLevel> informacji.</span><span class="sxs-lookup"><span data-stu-id="48f64-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="48f64-207">Implementacji WPF</span><span class="sxs-lookup"><span data-stu-id="48f64-207">WPF Implementation</span></span>  
 <span data-ttu-id="48f64-208">WPF XAML korzysta z modelu dostępu częściowego zaufania, w którym Jeśli BAML jest ładowany w częściowej relacji zaufania, dostęp jest ograniczony do <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> dla zestawu, który jest źródłem BAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="48f64-209">W przypadku opóźnienia, używa WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> jako mechanizm przekazywania informacje o poziomie dostępu.</span><span class="sxs-lookup"><span data-stu-id="48f64-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="48f64-210">W terminologii WPF XAML *wewnętrzny typ* to typ, który jest definiowany przez tego samego zestawu, który również uwzględnia odwołujący się XAML.</span><span class="sxs-lookup"><span data-stu-id="48f64-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="48f64-211">Za pomocą przestrzeni nazw XAML, które celowo pomija zestawu można zamapować taki typ = fragment mapowania, na przykład `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="48f64-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="48f64-212">Jeśli BAML odwołuje się do typu wewnętrznego i typ ma `internal` uzyskać dostęp do poziomu, spowoduje to wygenerowanie `GeneratedInternalTypeHelper` klasy dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="48f64-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="48f64-213">Jeśli chcesz uniknąć `GeneratedInternalTypeHelper`, należy albo użyć `public` uzyskać dostęp do poziomu, lub należy wziąć pod uwagę odpowiednich klas w osobnym zestawie i udostępnić tego zestawu zależnego.</span><span class="sxs-lookup"><span data-stu-id="48f64-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="48f64-214">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="48f64-214">See also</span></span>

- [<span data-ttu-id="48f64-215">Atrybuty CLR związane z XAML dla niestandardowych typów i bibliotek</span><span class="sxs-lookup"><span data-stu-id="48f64-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="48f64-216">Usługi XAML</span><span class="sxs-lookup"><span data-stu-id="48f64-216">XAML Services</span></span>](index.md)
