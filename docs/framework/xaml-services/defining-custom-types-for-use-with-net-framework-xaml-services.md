---
title: Definiowanie typów niestandardowych do użytku z usługami .NET Framework XAML
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: e563c0d7e5113d55d4b942fb1d175a64f5b71abc
ms.sourcegitcommit: 30a83efb57c468da74e9e218de26cf88d3254597
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/20/2019
ms.locfileid: "68364294"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="7ae14-102">Definiowanie typów niestandardowych do użytku z usługami .NET Framework XAML</span><span class="sxs-lookup"><span data-stu-id="7ae14-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="7ae14-103">Podczas definiowania typów niestandardowych, które są obiektami biznesowymi lub typy, które nie mają zależności od określonych platform, istnieją pewne najlepsze rozwiązania dotyczące języka XAML, które można wykonać.</span><span class="sxs-lookup"><span data-stu-id="7ae14-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="7ae14-104">Jeśli przestrzegasz tych rozwiązań, .NET Framework usług XAML i ich czytników XAML i autorzy języka XAML mogą wykrywać cechy języka XAML typu i dawać odpowiednie reprezentację w strumieniu węzłów XAML przy użyciu systemu typów XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="7ae14-105">W tym temacie opisano najlepsze rozwiązania dotyczące definicji typów, definicji elementów członkowskich i przypisywania typów lub elementów członkowskich przez środowisko CLR.</span><span class="sxs-lookup"><span data-stu-id="7ae14-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="7ae14-106">Wzorce konstruktora i definicje typów dla języka XAML</span><span class="sxs-lookup"><span data-stu-id="7ae14-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="7ae14-107">Aby można było utworzyć wystąpienie jako element obiektu w języku XAML, Klasa niestandardowa musi spełniać następujące wymagania:</span><span class="sxs-lookup"><span data-stu-id="7ae14-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="7ae14-108">Klasa niestandardowa musi być publiczna i musi uwidaczniać domyślny konstruktor publiczny (bez parametrów).</span><span class="sxs-lookup"><span data-stu-id="7ae14-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="7ae14-109">(Zobacz poniższą sekcję, aby poznać informacje o strukturach).</span><span class="sxs-lookup"><span data-stu-id="7ae14-109">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="7ae14-110">Klasa niestandardowa nie może być klasą zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="7ae14-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="7ae14-111">Dodatkowy "kropka" w ścieżce pełnej nazwy sprawia, że podział przestrzeni nazw klasy jest niejednoznaczny i zakłóca inne funkcje języka XAML, takie jak dołączone właściwości.</span><span class="sxs-lookup"><span data-stu-id="7ae14-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="7ae14-112">Jeśli obiekt może być skonkretyzowany jako element obiektu, utworzony obiekt może wypełnić formularz elementu właściwości właściwości, które przyjmują obiekt jako ich typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="7ae14-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="7ae14-113">Można nadal podawać wartości obiektów dla typów, które nie spełniają tych kryteriów, w przypadku włączenia konwertera wartości.</span><span class="sxs-lookup"><span data-stu-id="7ae14-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="7ae14-114">Aby uzyskać więcej informacji, zobacz [Typy konwerterów i rozszerzenia znaczników dla języka XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="7ae14-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="7ae14-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="7ae14-115">Structures</span></span>  
 <span data-ttu-id="7ae14-116">Struktury są zawsze możliwe do skonstruowania w języku XAML według definicji środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="7ae14-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="7ae14-117">Wynika to z faktu, że kompilator CLR niejawnie tworzy Konstruktor bez parametrów dla struktury.</span><span class="sxs-lookup"><span data-stu-id="7ae14-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="7ae14-118">Ten konstruktor inicjuje wszystkie wartości właściwości do ich wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="7ae14-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="7ae14-119">W niektórych przypadkach domyślne zachowanie konstrukcji dla struktury nie jest pożądane.</span><span class="sxs-lookup"><span data-stu-id="7ae14-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="7ae14-120">Może to być spowodowane tym, że struktura jest przeznaczona do wypełnienia wartości i funkcji koncepcyjnie jako Unia.</span><span class="sxs-lookup"><span data-stu-id="7ae14-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="7ae14-121">W związku z tym zawarte wartości mogą mieć wzajemnie wykluczające się interpretacje i dlatego żadna z jej właściwości nie jest settable.</span><span class="sxs-lookup"><span data-stu-id="7ae14-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="7ae14-122">Przykładem takiej struktury w słownictwie WPF jest <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="7ae14-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="7ae14-123">Struktury te powinny implementować konwerter typów, aby wartości można wyrazić w postaci atrybutu, przy użyciu konwencji ciągów, które tworzą różne interpretacje lub tryby wartości struktury.</span><span class="sxs-lookup"><span data-stu-id="7ae14-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="7ae14-124">Struktura powinna również ujawniać podobne zachowanie konstrukcji kodu za pomocą konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ae14-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="7ae14-125">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="7ae14-125">Interfaces</span></span>  
 <span data-ttu-id="7ae14-126">Interfejsy mogą być używane jako podstawowe typy elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="7ae14-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="7ae14-127">System typu XAML sprawdza listę umożliwiającą przypisanie i oczekuje, że obiekt, który jest dostarczony jako wartość, może być przypisany do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="7ae14-128">Nie ma koncepcji, w jaki sposób interfejs musi być przedstawiony jako typ XAML, o ile odpowiedni typ możliwy do przypisania obsługuje wymagania konstrukcyjne języka XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="7ae14-129">Metody fabryki</span><span class="sxs-lookup"><span data-stu-id="7ae14-129">Factory Methods</span></span>  
 <span data-ttu-id="7ae14-130">Metody fabryki są funkcją języka XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="7ae14-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="7ae14-131">Modyfikują zasady języka XAML, które obiekty muszą mieć konstruktory bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="7ae14-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="7ae14-132">Metody fabryki nie są udokumentowane w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="7ae14-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="7ae14-133">Zobacz [X:FactoryMethod dyrektywy](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="7ae14-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="7ae14-134">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="7ae14-134">Enumerations</span></span>  
 <span data-ttu-id="7ae14-135">Wyliczenia mają zachowanie konwersji typu natywnego XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="7ae14-136">Stałe wyliczenia określone w języku XAML są rozpoznawane względem bazowego typu wyliczenia i zwracają wartość wyliczenia do składnika zapisywania obiektów XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="7ae14-137">Język XAML obsługuje użycie stylu flag dla wyliczeń z <xref:System.FlagsAttribute> zastosowaniem.</span><span class="sxs-lookup"><span data-stu-id="7ae14-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="7ae14-138">Aby uzyskać więcej informacji, zobacz [Szczegóły składni języka XAML](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="7ae14-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="7ae14-139">([Szczegółowe informacje o składni języka XAML](../wpf/advanced/xaml-syntax-in-detail.md) są zapisywane dla odbiorców WPF, ale większość informacji w tym temacie dotyczy języka XAML, który nie jest specyficzny dla konkretnej struktury implementującej).</span><span class="sxs-lookup"><span data-stu-id="7ae14-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="7ae14-140">Definicje elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="7ae14-140">Member Definitions</span></span>  
 <span data-ttu-id="7ae14-141">Typy mogą definiować członków do użycia XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="7ae14-142">Jest możliwe dla typów, które definiują elementy członkowskie, które są użyteczne do użycia w języku XAML, nawet jeśli dany typ nie jest do użycia w języku XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="7ae14-143">Jest to możliwe z powodu dziedziczenia CLR.</span><span class="sxs-lookup"><span data-stu-id="7ae14-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="7ae14-144">Tak długo, jak jakiś typ, który dziedziczy składową, obsługuje użycie języka XAML jako typ, a element członkowski obsługuje użycie języka XAML dla jego typu podstawowego lub ma dostępną natywną składnię XAML, ten element członkowski jest używany do użycia w języku XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="7ae14-145">Właściwości</span><span class="sxs-lookup"><span data-stu-id="7ae14-145">Properties</span></span>  
 <span data-ttu-id="7ae14-146">Jeśli zdefiniujesz właściwości jako publiczną właściwość środowiska CLR przy użyciu typowych `get` wzorców `set` CLR i akcesora oraz odpowiednie sformułowanie dotyczące języka, system typu XAML może zgłosić właściwość jako element członkowski z odpowiednimi informacjami podanymi dla Właściwości, takie jak <xref:System.Xaml.XamlMember.IsReadPublic%2A> i <xref:System.Xaml.XamlMember.IsWritePublic%2A>. <xref:System.Xaml.XamlMember></span><span class="sxs-lookup"><span data-stu-id="7ae14-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="7ae14-147">Określone właściwości mogą umożliwić składnię tekstu przez zastosowanie <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="7ae14-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="7ae14-148">Aby uzyskać więcej informacji, zobacz [Typy konwerterów i rozszerzenia znaczników dla języka XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="7ae14-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="7ae14-149">W przypadku braku składni tekstowej lub natywnej konwersji XAML i braku dalszych pośrednich, takich jak użycie rozszerzenia znaczników, typ właściwości (<xref:System.Xaml.XamlMember.TargetType%2A> w systemie typu XAML) musi być w stanie zwracać wystąpienie do modułu zapisywania obiektów XAML przez podtraktowanie t Typ Arget jako typ CLR.</span><span class="sxs-lookup"><span data-stu-id="7ae14-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="7ae14-150">W przypadku korzystania z języka XAML 2009, [rozszerzenie znacznika x:Reference —](x-reference-markup-extension.md) może służyć do zapewnienia wartości, jeśli poprzednie zagadnienia nie są spełnione; Jednak jest to większa liczba problemów z użyciem niż w przypadku błędu definicji typu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="7ae14-151">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="7ae14-151">Events</span></span>  
 <span data-ttu-id="7ae14-152">W przypadku definiowania zdarzeń jako publicznego zdarzenia środowiska CLR System typu XAML może zgłosić zdarzenie jako element członkowski za pomocą <xref:System.Xaml.XamlMember.IsEvent%2A> jako. `true`</span><span class="sxs-lookup"><span data-stu-id="7ae14-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="7ae14-153">Obsługa zdarzeń nie należy do zakresu .NET Framework możliwości usług XAML. jest to pozostało do określonych platform i implementacji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="7ae14-154">Metody</span><span class="sxs-lookup"><span data-stu-id="7ae14-154">Methods</span></span>  
 <span data-ttu-id="7ae14-155">Kod wbudowany dla metod nie jest domyślną funkcją języka XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="7ae14-156">W większości przypadków nie można bezpośrednio odwoływać się do elementów członkowskich metody z XAML, a rola metod w języku XAML ma tylko zapewnić obsługę określonych wzorców XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="7ae14-157">[X:FactoryMethod dyrektywa](x-factorymethod-directive.md) to wyjątek.</span><span class="sxs-lookup"><span data-stu-id="7ae14-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="7ae14-158">Pola</span><span class="sxs-lookup"><span data-stu-id="7ae14-158">Fields</span></span>  
 <span data-ttu-id="7ae14-159">Wskazówki dotyczące projektowania środowiska CLR uniemożliwiają Niestatyczne pola.</span><span class="sxs-lookup"><span data-stu-id="7ae14-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="7ae14-160">W przypadku pól statycznych można uzyskać dostęp do wartości pól statycznych tylko za poorednictwem [rozszerzenia znacznika x:static —](x-static-markup-extension.md). w takim przypadku nie są wykonywane żadne specjalne definicje środowiska CLR w celu udostępnienia pola do użycia [x:static —](x-static-markup-extension.md) .</span><span class="sxs-lookup"><span data-stu-id="7ae14-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="7ae14-161">Możliwe do dołączenia elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="7ae14-161">Attachable Members</span></span>  
 <span data-ttu-id="7ae14-162">Możliwe do dołączenia elementy członkowskie są ujawniane w języku XAML za pomocą wzorca metody dostępu w typie definiującym.</span><span class="sxs-lookup"><span data-stu-id="7ae14-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="7ae14-163">Sam typ definiujący nie musi być używany w języku XAML jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="7ae14-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="7ae14-164">W rzeczywistości typowym wzorcem jest zadeklarowanie klasy usług, której rola jest własnością dołączonego elementu członkowskiego i implementuje powiązane zachowania, ale nie obsługuje żadnej innej funkcji, takiej jak reprezentacja interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="7ae14-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="7ae14-165">W poniższych sekcjach, funkcja *PropertyName* zastępuje nazwę dołączonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="7ae14-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="7ae14-166">Ta nazwa musi być prawidłowa w [gramatycename języka XAML](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="7ae14-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="7ae14-167">Należy zachować ostrożność w przypadku kolizji nazw między tymi wzorcami a innymi metodami typu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="7ae14-168">Jeśli element członkowski istnieje, który jest zgodny z jednym z wzorców, może być interpretowany jako możliwe do dołączenia użycie składowej przez procesor XAML nawet wtedy, gdy nie było to zamierzone.</span><span class="sxs-lookup"><span data-stu-id="7ae14-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="7ae14-169">Metoda dostępu GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="7ae14-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="7ae14-170">Sygnaturą `Get`metody dostępu *PropertyName* musi być:</span><span class="sxs-lookup"><span data-stu-id="7ae14-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="7ae14-171">`public static object Get`Funkcja *PropertyName* `(object``target`  `)`</span><span class="sxs-lookup"><span data-stu-id="7ae14-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
- <span data-ttu-id="7ae14-172">`target` Obiekt może być określony jako bardziej konkretny typ w implementacji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="7ae14-173">Służy do określania zakresu użycia dołączalnego elementu członkowskiego; użycie poza zamierzonym zakresem spowoduje zgłoszenie nieprawidłowych wyjątków rzutowania, które są następnie nadane przez błąd analizy XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="7ae14-174">Nazwa `target` parametru nie jest wymagana, ale jest nazywana `target` Konwencją w większości implementacji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
- <span data-ttu-id="7ae14-175">Wartość zwracana może być określona jako bardziej konkretny typ w implementacji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="7ae14-176">Aby zapewnić obsługę <xref:System.ComponentModel.TypeConverter> składni tekstu włączonego dla atrybutu użycie elementu członkowskiego, który można dołączyć <xref:System.ComponentModel.TypeConverterAttribute> , Zastosuj `Get`do metody dostępu *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="7ae14-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="7ae14-177">Zastosowanie do `get` nie `set` może wydawać się Nieintuicyjny; Jednakże ta konwencja może obsługiwać koncepcję możliwych do dołączalnych elementów członkowskich, które są możliwe do serializacji, co jest przydatne w scenariuszach projektanta.</span><span class="sxs-lookup"><span data-stu-id="7ae14-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="7ae14-178">Metoda dostępu setPropertyName</span><span class="sxs-lookup"><span data-stu-id="7ae14-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="7ae14-179">Sygnaturą dla zestawu metody dostępu*PropertyName* musi być:</span><span class="sxs-lookup"><span data-stu-id="7ae14-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="7ae14-180">`public static void Set`Funkcja *PropertyName* `(object``target` `, object``value`    `)`</span><span class="sxs-lookup"><span data-stu-id="7ae14-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
- <span data-ttu-id="7ae14-181">`target` Obiekt może być określony jako bardziej konkretny typ w implementacji, z tą samą logiką i konsekwencjami, zgodnie z opisem w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
- <span data-ttu-id="7ae14-182">`value` Obiekt może być określony jako bardziej konkretny typ w implementacji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="7ae14-183">Należy pamiętać, że wartość tej metody jest wartością wejściową pochodzącą z użycia XAML, zazwyczaj w formie atrybutu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="7ae14-184">Z poziomu formularza atrybutu musi być obsługa konwertera wartości dla składni tekstu i atrybut `Get`metody dostępu *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="7ae14-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="7ae14-185">Możliwe do dołączenia magazyny elementów członkowskich</span><span class="sxs-lookup"><span data-stu-id="7ae14-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="7ae14-186">Metody dostępu są zwykle zbyt małe, aby zapewnić sposób umieszczania wartości elementów członkowskich do dołączenia do grafu obiektów lub pobierania wartości z grafu obiektów i prawidłowego serializacji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="7ae14-187">Aby zapewnić tę funkcjonalność, `target` obiekty w poprzednich sygnaturach dostępu muszą mieć możliwość przechowywania wartości.</span><span class="sxs-lookup"><span data-stu-id="7ae14-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="7ae14-188">Mechanizm magazynu powinien być zgodny z zasadą dołączalną składową, która jest dołączana do elementów docelowych, gdzie Dołączalny element członkowski nie znajduje się na liście elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="7ae14-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="7ae14-189">.NET Framework usługi XAML udostępniają technikę implementacji dla dołączanych magazynów elementów <xref:System.Xaml.IAttachedPropertyStore> członkowskich <xref:System.Xaml.AttachablePropertyServices>za pomocą interfejsów API i.</span><span class="sxs-lookup"><span data-stu-id="7ae14-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="7ae14-190"><xref:System.Xaml.IAttachedPropertyStore>jest używana przez moduły zapisujące XAML do odnajdywania implementacji sklepu i powinna zostać wdrożona na typ, który jest `target` obiektem metod dostępu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="7ae14-191">Statyczne <xref:System.Xaml.AttachablePropertyServices> interfejsy API są używane w treści metod dostępu i odwołują się do dołączonego elementu członkowskiego <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="7ae14-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="7ae14-192">Atrybuty CLR związane z XAML</span><span class="sxs-lookup"><span data-stu-id="7ae14-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="7ae14-193">Prawidłowe przypisanie typów, elementów członkowskich i zestawów jest ważne w celu raportowania informacji o systemie typu XAML do .NET Framework usług XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="7ae14-194">Jest to istotne w przypadku, gdy zamierzasz korzystać z typów używanych z systemami XAML, które są bezpośrednio oparte na .NET Framework czytnikach XAML usług XAML i autorzy języka XAML, lub jeśli zdefiniujesz platformę wykorzystującą XAML lub korzystającą z nich, która jest oparta na tych czytnikach XAML i autorzy języka XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="7ae14-195">Aby zapoznać się z listą każdego atrybutu związanego z XAML, który jest istotny dla obsługi języka XAML dla typów niestandardowych, zobacz atrybuty CLR związane z językiem XAML [dla niestandardowych typów i bibliotek](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="7ae14-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="7ae14-196">Użycie</span><span class="sxs-lookup"><span data-stu-id="7ae14-196">Usage</span></span>  
 <span data-ttu-id="7ae14-197">Użycie typów niestandardowych wymaga, aby autor znacznika musiał zmapować prefiks dla przestrzeni nazw zestawu i środowiska CLR, który zawiera typ niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="7ae14-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="7ae14-198">Ta procedura nie jest udokumentowana w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="7ae14-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="7ae14-199">Poziom dostępu</span><span class="sxs-lookup"><span data-stu-id="7ae14-199">Access Level</span></span>  
 <span data-ttu-id="7ae14-200">Język XAML zapewnia metodę ładowania i tworzenia wystąpienia typów, które mają `internal` poziom dostępu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="7ae14-201">Ta funkcja jest dostarczana, aby kod użytkownika mógł definiować własne typy, a następnie tworzyć wystąpienia tych klas z znaczników, które są również częścią tego samego zakresu kodu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="7ae14-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="7ae14-202">Przykładem z platformy WPF jest każdy kod <xref:System.Windows.Controls.UserControl> użytkownika, który jest przeznaczony do refaktoryzacji zachowania interfejsu użytkownika, ale nie jako część dowolnego możliwego mechanizmu rozszerzenia, który może być implikowany przez zadeklarowanie klasy pomocniczej z `public` poziomem dostępu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="7ae14-203">Taka a <xref:System.Windows.Controls.UserControl> może być zadeklarowana `internal` z dostępem, jeśli kod zapasowy jest kompilowany do tego samego zestawu, z którego jest przywoływany jako typ XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="7ae14-204">W przypadku aplikacji ładującej kod XAML w ramach pełnego zaufania <xref:System.Xaml.XamlObjectWriter>i używania, ładowanie `internal` klas z poziomem dostępu jest zawsze włączone.</span><span class="sxs-lookup"><span data-stu-id="7ae14-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="7ae14-205">W przypadku aplikacji ładującej kod XAML w obszarze częściowej relacji zaufania można kontrolować charakterystykę poziomu dostępu za <xref:System.Xaml.Permissions.XamlAccessLevel> pomocą interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="7ae14-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="7ae14-206">Ponadto mechanizmy odroczenia (takie jak system szablonów WPF) muszą być w stanie propagować wszelkie uprawnienia poziomu dostępu i zachować je na potrzeby oceny czasu wykonywania. jest to obsługiwane wewnętrznie przez przekazanie <xref:System.Xaml.Permissions.XamlAccessLevel> informacji.</span><span class="sxs-lookup"><span data-stu-id="7ae14-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="7ae14-207">Implementacja WPF</span><span class="sxs-lookup"><span data-stu-id="7ae14-207">WPF Implementation</span></span>  
 <span data-ttu-id="7ae14-208">W języku XAML WPF jest stosowany model dostępu częściowego zaufania, w którym w przypadku załadowania BAML w ramach częściowej relacji zaufania dostęp jest ograniczony do <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> zestawu, który jest źródłem BAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="7ae14-209">W przypadku odroczenia, <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> WPF używa jako mechanizmu przekazywania informacji o poziomie dostępu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="7ae14-210">W terminologii języka XAML WPF, *Typ wewnętrzny* jest typem, który jest zdefiniowany przez ten sam zestaw, który zawiera również odwołanie XAML.</span><span class="sxs-lookup"><span data-stu-id="7ae14-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="7ae14-211">Taki typ może być mapowany za pomocą przestrzeni nazw XAML, która celowo pomija zestaw = część mapowania, na przykład `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="7ae14-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="7ae14-212">Jeśli BAML odwołuje się do typu wewnętrznego i ten `internal` typ ma poziom dostępu, `GeneratedInternalTypeHelper` generuje klasę dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="7ae14-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="7ae14-213">Jeśli chcesz uniknąć `GeneratedInternalTypeHelper`, musisz użyć poziomu dostępu lub w `public` miarę jak należy zastosować odpowiednią klasę do oddzielnego zestawu i uczynić ten zestaw zależny.</span><span class="sxs-lookup"><span data-stu-id="7ae14-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7ae14-214">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="7ae14-214">See also</span></span>

- [<span data-ttu-id="7ae14-215">Atrybuty CLR związane z XAML dla niestandardowych typów i bibliotek</span><span class="sxs-lookup"><span data-stu-id="7ae14-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="7ae14-216">Usługi XAML</span><span class="sxs-lookup"><span data-stu-id="7ae14-216">XAML Services</span></span>](index.md)
