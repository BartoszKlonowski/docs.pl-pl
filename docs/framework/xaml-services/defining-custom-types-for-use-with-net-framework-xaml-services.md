---
title: "Definiowanie typów niestandardowych do użytku z usługami .NET Framework XAML"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
caps.latest.revision: "11"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: c7cce479c7c7a5f6c7112f08f1e15f3bc7e4d366
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/22/2017
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="2fcda-102">Definiowanie typów niestandardowych do użytku z usługami .NET Framework XAML</span><span class="sxs-lookup"><span data-stu-id="2fcda-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="2fcda-103">Zdefiniuj niestandardowe typy obiektów biznesowych lub typów, które nie mają zależności na określonych platformach, brak niektórych najlepszych rozwiązań dotyczących XAML, możesz wykonać.</span><span class="sxs-lookup"><span data-stu-id="2fcda-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="2fcda-104">Po wykonaniu tych rozwiązań usług .NET Framework XAML i jego czytników XAML i zapisywania XAML może odnajdywanie właściwości XAML danego typu i nadaj odpowiednie reprezentacja w strumień węzłów XAML, przy użyciu systemu typu XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="2fcda-105">W tym temacie opisano najlepsze rozwiązania dotyczące definicji typu, elementu członkowskiego definicje i przypisywanie CLR typów lub elementy członkowskie.</span><span class="sxs-lookup"><span data-stu-id="2fcda-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="2fcda-106">Konstruktor wzorców i definicji typu dla XAML</span><span class="sxs-lookup"><span data-stu-id="2fcda-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="2fcda-107">Aby można utworzyć wystąpienia jako elementu obiektu w języku XAML, niestandardowe klasy musi spełniać następujące wymagania:</span><span class="sxs-lookup"><span data-stu-id="2fcda-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="2fcda-108">Niestandardowej klasy muszą być publiczne i musi uwidaczniać domyślnego (bezparametrowego) konstruktora publicznego.</span><span class="sxs-lookup"><span data-stu-id="2fcda-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="2fcda-109">(Patrz poniżej sekcji, aby uzyskać informacje dotyczące struktury).</span><span class="sxs-lookup"><span data-stu-id="2fcda-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="2fcda-110">Niestandardowej klasy nie może być klasą zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="2fcda-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="2fcda-111">Nadmiarowe "kropka" w ścieżce pełnej nazwy sprawia, że dzielenia obszaru nazw klasy jest niejednoznaczne i koliduje z innymi funkcjami języka XAML, takie jak dołączone właściwości.</span><span class="sxs-lookup"><span data-stu-id="2fcda-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="2fcda-112">Jeśli obiekt można wdrożyć jako elementu obiektu, utworzony obiekt wypełnić formularzu elementu właściwości właściwości przyjmujących obiektu jako jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="2fcda-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="2fcda-113">Nadal można podać wartości obiektu dla typów, które nie spełniają tych kryteriów, jeśli włączysz konwertera wartości.</span><span class="sxs-lookup"><span data-stu-id="2fcda-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="2fcda-114">Aby uzyskać więcej informacji, zobacz [typy konwerterów i rozszerzenia znaczników dla XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="2fcda-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="2fcda-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="2fcda-115">Structures</span></span>  
 <span data-ttu-id="2fcda-116">Struktury mogą zawsze być skonstruowany w XAML, zgodnie z definicją CLR.</span><span class="sxs-lookup"><span data-stu-id="2fcda-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="2fcda-117">Jest to spowodowane kompilatora CLR niejawnie tworzy konstruktora domyślnego dla struktury.</span><span class="sxs-lookup"><span data-stu-id="2fcda-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="2fcda-118">Ten konstruktor inicjuje wszystkich wartości właściwości do wartości domyślnych.</span><span class="sxs-lookup"><span data-stu-id="2fcda-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="2fcda-119">W niektórych przypadkach konstrukcji domyślne zachowanie dla struktury nie jest pożądane.</span><span class="sxs-lookup"><span data-stu-id="2fcda-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="2fcda-120">Może to być spowodowane struktury jest przeznaczony do wypełniania wartościami oraz funkcja koncepcyjnie jako Unii.</span><span class="sxs-lookup"><span data-stu-id="2fcda-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="2fcda-121">Jako Unii wartości zawartych w niej mogą być interpretacje wykluczają się wzajemnie, a w związku z tym żaden z jego właściwości nie jest do ustawienia.</span><span class="sxs-lookup"><span data-stu-id="2fcda-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="2fcda-122">Na przykład struktury w słownictwa WPF <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="2fcda-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="2fcda-123">Te struktury powinien implementować konwertera typów, aby wartości może zostać wyrażona w formie atrybutu, za pomocą Konwencji ciągu utworzyć inną interpretacje lub tryby wartości struktury.</span><span class="sxs-lookup"><span data-stu-id="2fcda-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="2fcda-124">Struktura również powinny ujawniać podobne zachowanie dla konstrukcji kodu za pomocą konstruktora domyślnego z systemem innym niż.</span><span class="sxs-lookup"><span data-stu-id="2fcda-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="2fcda-125">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="2fcda-125">Interfaces</span></span>  
 <span data-ttu-id="2fcda-126">Interfejsy może służyć jako typów podstawowych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="2fcda-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="2fcda-127">System typów języka XAML sprawdza listy można przypisać i oczekuje, że obiekt, który został dostarczony jako wartość można przypisać do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="2fcda-128">Nie ma żadnych koncepcji jak interfejsu muszą być przedstawione jako typu XAML tak długo, jak można przypisać typu odpowiednich spełnia wymagania dotyczące konstrukcji języka XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="2fcda-129">Metody fabryki</span><span class="sxs-lookup"><span data-stu-id="2fcda-129">Factory Methods</span></span>  
 <span data-ttu-id="2fcda-130">Fabryka metody są funkcją języka XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="2fcda-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="2fcda-131">Modyfikują zasady XAML, że obiekty muszą mieć domyślnych konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="2fcda-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="2fcda-132">W tym temacie nie opisano metody fabryki.</span><span class="sxs-lookup"><span data-stu-id="2fcda-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="2fcda-133">Zobacz [x: factorymethod — dyrektywa](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="2fcda-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="2fcda-134">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="2fcda-134">Enumerations</span></span>  
 <span data-ttu-id="2fcda-135">Wyliczenia mają zachowanie konwersji typu macierzystego języka XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="2fcda-136">Wyliczenie nazwy stałej określone w języku XAML są nazwy zostały rozstrzygnięte na typ podstawowy wyliczenia i zwracać wartość wyliczenia do zapisywania obiektów języka XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="2fcda-137">XAML obsługuje użycie flagi stylu dla wyliczeń o <xref:System.FlagsAttribute> zastosowane.</span><span class="sxs-lookup"><span data-stu-id="2fcda-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="2fcda-138">Aby uzyskać więcej informacji, zobacz [szczegółów w składni języka XAML](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="2fcda-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="2fcda-139">([Szczegółów w składni języka XAML](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) jest przeznaczony dla odbiorców WPF, ale większość informacji w tym temacie ma zastosowanie w przypadku XAML, który nie jest specyficzne dla konkretnego framework implementującej.)</span><span class="sxs-lookup"><span data-stu-id="2fcda-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="2fcda-140">Definicje elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="2fcda-140">Member Definitions</span></span>  
 <span data-ttu-id="2fcda-141">Typów można zdefiniować elementów członkowskich do użycia w języku XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="2fcda-142">Istnieje możliwość dla typów, które definiują elementy członkowskie, które są użyteczne XAML, nawet jeśli tego typu nie jest używany XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="2fcda-143">Jest to możliwe z powodu dziedziczenia CLR.</span><span class="sxs-lookup"><span data-stu-id="2fcda-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="2fcda-144">Tak długo, jak pewien typ, który dziedziczy element członkowski obsługuje XAML użycia jako typ, a element członkowski obsługuje użycie języka XAML dla jego typem podstawowym lub ma dostępne natywnej składni języka XAML, ten element członkowski jest użyteczne XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="2fcda-145">Właściwości</span><span class="sxs-lookup"><span data-stu-id="2fcda-145">Properties</span></span>  
 <span data-ttu-id="2fcda-146">Jeśli jako publiczny właściwość CLR za pomocą typowych CLR można zdefiniować właściwości `get` i `set` wzorce dostępu i odpowiednim języku temat zgłosić właściwość jako element członkowski o odpowiednie informacje przewidziane system typów języka XAML <xref:System.Xaml.XamlMember> właściwości, takie jak <xref:System.Xaml.XamlMember.IsReadPublic%2A> i <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fcda-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="2fcda-147">Właściwości specyficzne dla można włączyć składni tekstu, stosując <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="2fcda-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="2fcda-148">Aby uzyskać więcej informacji, zobacz [typy konwerterów i rozszerzenia znaczników dla XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="2fcda-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="2fcda-149">W przypadku braku składni tekstu lub natywnego konwersji XAML i w przypadku braku dalszych pośredni, takie jak użycie rozszerzenia znaczników, typ właściwości (<xref:System.Xaml.XamlMember.TargetType%2A> system typów XAML) musi mieć możliwość zwrócenia wystąpienia do zapisywania obiektów XAML, traktując t Typ docelowy jako typ CLR.</span><span class="sxs-lookup"><span data-stu-id="2fcda-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="2fcda-150">Jeśli przy użyciu języka XAML 2009, [x: Reference — rozszerzenie znaczników](../../../docs/framework/xaml-services/x-reference-markup-extension.md) można używać do Podaj wartości, jeśli wcześniejsze rozważania nie są spełnione, to jednak jeden z problemem użycia niż problem definicji typu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="2fcda-151">Zdarzenia</span><span class="sxs-lookup"><span data-stu-id="2fcda-151">Events</span></span>  
 <span data-ttu-id="2fcda-152">Po zdefiniowaniu zdarzenia jako publiczne zdarzenie CLR system typów języka XAML zgłosić zdarzenie jako element członkowski o <xref:System.Xaml.XamlMember.IsEvent%2A> jako `true`.</span><span class="sxs-lookup"><span data-stu-id="2fcda-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="2fcda-153">Dołączenie obsługi zdarzeń nie jest w zakresie funkcji usług .NET Framework XAML; To pole pozostanie do implementacji i określonej struktury.</span><span class="sxs-lookup"><span data-stu-id="2fcda-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="2fcda-154">Metody</span><span class="sxs-lookup"><span data-stu-id="2fcda-154">Methods</span></span>  
 <span data-ttu-id="2fcda-155">Kodu wbudowanego dla metod nie jest możliwość XAML domyślna.</span><span class="sxs-lookup"><span data-stu-id="2fcda-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="2fcda-156">W większości przypadków użytkownik nie należy bezpośrednio odwoływać metody członków z XAML i rolą metod w języku XAML jest tylko do zapewnienia obsługi określonych wzorców XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="2fcda-157">[x: factorymethod — dyrektywa](../../../docs/framework/xaml-services/x-factorymethod-directive.md) wyjątek.</span><span class="sxs-lookup"><span data-stu-id="2fcda-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="2fcda-158">Pola</span><span class="sxs-lookup"><span data-stu-id="2fcda-158">Fields</span></span>  
 <span data-ttu-id="2fcda-159">Wytyczne dotyczące projektowania CLR zniechęcić niestatycznego pola.</span><span class="sxs-lookup"><span data-stu-id="2fcda-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="2fcda-160">Dla pola statyczne, można uzyskać dostępu do wartości pola statycznego tylko za pomocą [x: Static — rozszerzenie znaczników](../../../docs/framework/xaml-services/x-static-markup-extension.md); w takim przypadku nie przeprowadzasz jakieś szczególne w definicji CLR do udostępnienia polem [x: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) użycia.</span><span class="sxs-lookup"><span data-stu-id="2fcda-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="2fcda-161">Możliwe do dołączenia elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="2fcda-161">Attachable Members</span></span>  
 <span data-ttu-id="2fcda-162">Możliwe do dołączenia elementy członkowskie są widoczne w języku XAML za pomocą wzorca metody dostępu na typ definiujący.</span><span class="sxs-lookup"><span data-stu-id="2fcda-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="2fcda-163">Definiowanie samego typu nie trzeba XAML w można używać jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="2fcda-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="2fcda-164">W rzeczywistości jest wspólnego wzorca do zadeklarowania klasy usługi, którego rola jest właścicielem dołączalny element członkowski i zaimplementować powiązane zachowania, ale obsługiwać żadnych innych funkcji, takich jak reprezentacja interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="2fcda-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="2fcda-165">Dla następujących sekcji, symbol zastępczy *PropertyName* reprezentuje nazwę Twojej dołączalny element członkowski.</span><span class="sxs-lookup"><span data-stu-id="2fcda-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="2fcda-166">Ta nazwa musi być prawidłowa w [xamlname — gramatyka](../../../docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="2fcda-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="2fcda-167">Należy zachować ostrożność kolizji nazw od tych wzorców i innych metod typu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="2fcda-168">Jeśli istnieje element członkowski, który jest zgodny z wzorców, jego mogą być interpretowane jako ścieżka użycia dołączalny element członkowski przez procesor XAML nawet wtedy, gdy nie była z zamiarem.</span><span class="sxs-lookup"><span data-stu-id="2fcda-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="2fcda-169">Metoda dostępu GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="2fcda-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="2fcda-170">Podpis dla `Get` *PropertyName* akcesora musi być:</span><span class="sxs-lookup"><span data-stu-id="2fcda-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="2fcda-171">`public static object Get`*PropertyName* `(object` `target`  `)`</span><span class="sxs-lookup"><span data-stu-id="2fcda-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="2fcda-172">`target` Obiektu można określić jako bardziej określonego typu w implementacji.</span><span class="sxs-lookup"><span data-stu-id="2fcda-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="2fcda-173">Umożliwia to zakres użycia dołączalny element członkowski; użycia poza zakres zamierzone zgłosi Nieprawidłowe rzutowanie wyjątki, które są następnie udostępniane przez błąd analizy języka XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="2fcda-174">Nazwa parametru `target` nie jest wymagane, ale ma nazwę `target` przez Konwencję w większości wdrożeń.</span><span class="sxs-lookup"><span data-stu-id="2fcda-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="2fcda-175">Wartość zwracana można określić jako bardziej określonego typu w implementacji.</span><span class="sxs-lookup"><span data-stu-id="2fcda-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="2fcda-176">Do obsługi <xref:System.ComponentModel.TypeConverter> składnię tekst włączone użycie atrybutu dołączalny element członkowski, zastosuj <xref:System.ComponentModel.TypeConverterAttribute> do `Get` *PropertyName* metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="2fcda-177">Stosowanie do `get` zamiast `set` może wydawać się nonintuitive; jednak tę Konwencję może obsługiwać pojęcie o tylko do odczytu możliwe do dołączenia elementy członkowskie, które są do serializacji, co jest przydatne w scenariuszach projektanta.</span><span class="sxs-lookup"><span data-stu-id="2fcda-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="2fcda-178">Metoda dostępu SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="2fcda-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="2fcda-179">Podpis dla zestawu*PropertyName* akcesora musi być:</span><span class="sxs-lookup"><span data-stu-id="2fcda-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="2fcda-180">`public static void Set`*PropertyName* `(object` `target` `, object` `value`    `)`</span><span class="sxs-lookup"><span data-stu-id="2fcda-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="2fcda-181">`target` Obiektu można określić jako bardziej określonego typu w implementacji, z tej samej logiki i konsekwencje zgodnie z opisem w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="2fcda-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="2fcda-182">`value` Obiektu można określić jako bardziej określonego typu w implementacji.</span><span class="sxs-lookup"><span data-stu-id="2fcda-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="2fcda-183">Należy pamiętać, że wartość ta metoda jest danych wejściowych przesyłanych przez użycie języka XAML, zwykle w formie atrybutu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="2fcda-184">W formie atrybutu musi być konwertera wartości obsługę składni tekstu, a atrybut na `Get` *PropertyName* metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="2fcda-185">Dołączalny element członkowski magazynów</span><span class="sxs-lookup"><span data-stu-id="2fcda-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="2fcda-186">Metody dostępu nie są zwykle wystarczająco, aby podać sposób umieszcza wartości dołączalny element członkowski w wykres obiektu lub pobrać wartości z wykres obiektu i serializacji je poprawnie.</span><span class="sxs-lookup"><span data-stu-id="2fcda-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="2fcda-187">Do tej funkcji `target` obiektów w poprzednim sygnatur dostępu musi być zdolny do przechowywania wartości.</span><span class="sxs-lookup"><span data-stu-id="2fcda-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="2fcda-188">Mechanizm magazynu powinien być zgodny z zasadą dołączalny element członkowski, który jest możliwy do dołączenia do obiektów docelowych, gdzie dołączalny element członkowski nie jest na liście elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="2fcda-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="2fcda-189">Usługi XAML .NET framework zapewnia technikę implementacji dołączalny element członkowski przechowuje za pośrednictwem interfejsów API <xref:System.Xaml.IAttachedPropertyStore> i <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="2fcda-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="2fcda-190"><xref:System.Xaml.IAttachedPropertyStore>jest używana przez autorów XAML do wykrywania Implementacja magazynu i powinny być implementowane w typie, który jest `target` z metod dostępu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="2fcda-191">Statycznych <xref:System.Xaml.AttachablePropertyServices> interfejsów API są używane w treści metody dostępu i odwoływać się do dołączalny element członkowski przez jego <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="2fcda-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="2fcda-192">Atrybuty CLR związane z XAML</span><span class="sxs-lookup"><span data-stu-id="2fcda-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="2fcda-193">Przypisywanie poprawnie z typów, elementy członkowskie i zestawy ważne jest, aby raport informacji o systemie typu XAML do usług .NET Framework XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="2fcda-194">Ma to zastosowanie, jeśli zamierzasz typy sieci do użycia z systemami XAML, które bezpośrednio na podstawie czytników .NET Framework XAML Services XAML i zapisywania XAML lub zdefiniuj lub użyj przy użyciu języka XAML platforma, która jest oparta na tych czytników XAML i zapisywania XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="2fcda-195">Lista każdego atrybutu związane z XAML, odpowiedniego dla pomocy technicznej XAML dla niestandardowych typów, zobacz [XAML-Related atrybuty CLR dotyczące niestandardowych typów i bibliotek](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="2fcda-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="2fcda-196">Użycie</span><span class="sxs-lookup"><span data-stu-id="2fcda-196">Usage</span></span>  
 <span data-ttu-id="2fcda-197">Użycie niestandardowych typów wymaga, że autor znacznika musi być zamapowany prefiks dla zestawu i przestrzeń nazw środowiska CLR, które zawierają typu niestandardowego.</span><span class="sxs-lookup"><span data-stu-id="2fcda-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="2fcda-198">Ta procedura nie jest opisane w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="2fcda-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="2fcda-199">Poziom dostępu</span><span class="sxs-lookup"><span data-stu-id="2fcda-199">Access Level</span></span>  
 <span data-ttu-id="2fcda-200">XAML umożliwia ładowanie i utworzenia wystąpienia typów, które mają `internal` poziom dostępu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="2fcda-201">Ta funkcja jest dostępne, aby kod użytkownika Definiowanie własnych typów, a następnie utworzyć wystąpienia klas z kod znaczników, który jest również częścią tego samego zakresu kodu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="2fcda-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="2fcda-202">Przykład z WPF jest zawsze, gdy kod użytkownika definiuje <xref:System.Windows.Controls.UserControl> służy jako sposób Refaktoryzuj zachowania interfejsu użytkownika, ale nie jako część wszystkie możliwe rozszerzenia mechanizm, który może być niejawnego od zadeklarowania klasy pomocnicze z `public` poziom dostępu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="2fcda-203">Takie <xref:System.Windows.Controls.UserControl> mogą być deklarowane z `internal` dostępu, jeśli kod zapasowego jest skompilowany w tym samym zestawie, z którego jest przywoływany jako typu XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="2fcda-204">Dla aplikacji, która ładuje XAML w trybie pełnego zaufania i używa <xref:System.Xaml.XamlObjectWriter>, ładowania klas z `internal` poziom dostępu jest zawsze włączona.</span><span class="sxs-lookup"><span data-stu-id="2fcda-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="2fcda-205">Właściwości poziomu dostępu dla aplikacji, która ładuje XAML w częściowej relacji zaufania, można kontrolować przy użyciu <xref:System.Xaml.Permissions.XamlAccessLevel> interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="2fcda-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="2fcda-206">Ponadto mechanizmów opóźnienia (np. system szablonu WPF) musi mieć możliwość propagację poziomu uprawnień dostępu i zachowanie ich do ocen ostatecznego czasie wykonywania. jest obsługiwany wewnętrznie przez przekazanie <xref:System.Xaml.Permissions.XamlAccessLevel> informacji.</span><span class="sxs-lookup"><span data-stu-id="2fcda-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="2fcda-207">Implementacja WPF</span><span class="sxs-lookup"><span data-stu-id="2fcda-207">WPF Implementation</span></span>  
 <span data-ttu-id="2fcda-208">WPF XAML korzysta z modelu dostępu częściowego zaufania, której Jeśli BAML został załadowany w częściowej relacji zaufania, dostęp jest ograniczony do <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> dla zestawu, który jest źródłem BAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="2fcda-209">W przypadku opóźnienia, używa WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> jako mechanizm przekazywania informacji poziomu dostępu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="2fcda-210">W terminologii WPF XAML *wewnętrzny typ* jest typem, który jest definiowana za pomocą tego samego zestawu, który obejmuje również odwołujący się XAML.</span><span class="sxs-lookup"><span data-stu-id="2fcda-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="2fcda-211">Takiego typu mogą być mapowane za pośrednictwem przestrzeni nazw XAML, które celowo pomija zestawu = część mapowaniem, na przykład `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="2fcda-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="2fcda-212">Jeśli BAML odwołuje się do wewnętrznego typu i że typ ma `internal` dostęp do poziomu, spowoduje to wygenerowanie `GeneratedInternalTypeHelper` klasy dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="2fcda-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="2fcda-213">Jeśli chcesz uniknąć `GeneratedInternalTypeHelper`, należy albo użyć `public` poziom, dostępu lub należy uwzględnić odpowiednich klas osobny zestaw i udostępnić tego zestawu zależnego.</span><span class="sxs-lookup"><span data-stu-id="2fcda-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2fcda-214">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="2fcda-214">See Also</span></span>  
 [<span data-ttu-id="2fcda-215">Atrybuty CLR związane z XAML dla niestandardowych typów i bibliotek</span><span class="sxs-lookup"><span data-stu-id="2fcda-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="2fcda-216">Usługi XAML</span><span class="sxs-lookup"><span data-stu-id="2fcda-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)
