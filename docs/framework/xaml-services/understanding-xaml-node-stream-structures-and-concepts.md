---
title: "Zapoznanie się ze strukturami i koncepcjami strumienia węzłów XAML"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
caps.latest.revision: "14"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.openlocfilehash: ae5cfd6cdb557aff4910f38ea0fb7f4b54afbbb0
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2017
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="f4411-102">Zapoznanie się ze strukturami i koncepcjami strumienia węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-102">Understanding XAML Node Stream Structures and Concepts</span></span>
<span data-ttu-id="f4411-103">Czytniki XAML i zapisywania XAML zgodnie z implementacją w .NET Framework XAML Services są oparte na koncepcję projektu strumienia węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="f4411-104">Strumień węzłów XAML jest conceptualization zestawu węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="f4411-105">W tym conceptualization procesora XAML przedstawiono struktury relacje węzła w języku XAML, co w czasie.</span><span class="sxs-lookup"><span data-stu-id="f4411-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="f4411-106">W dowolnym momencie istnieje tylko jeden rekord bieżący lub bieżącą pozycję w otwartych strumień węzłów XAML, a wiele aspektów interfejsu API zgłaszać tylko te informacje dostępne w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="f4411-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="f4411-107">Bieżący węzeł w strumień węzłów XAML można przedstawić jako obiekt, element członkowski lub wartość.</span><span class="sxs-lookup"><span data-stu-id="f4411-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="f4411-108">Traktując XAML jako strumień węzłów XAML, czytników XAML można komunikować się z autorów XAML i włączyć program do wyświetlania, interakcji z i zmienić zawartość strumienia węzłów XAML podczas ładowania ścieżki lub Zapisz operacji ścieżki, która obejmuje XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="f4411-109">Projekt interfejsu API składników zapisywania i odczytywania XAML i koncepcji strumienia węzłów XAML są takie jak podobne do poprzedniego czytnika pokrewne i zapisywania projektów i pojęcia [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] i <xref:System.Xml.XmlReader> i <xref:System.Xml.XmlWriter> klasy.</span><span class="sxs-lookup"><span data-stu-id="f4411-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="f4411-110">W tym temacie omówiono pojęcia strumienia węzłów XAML i zawiera opis sposobu pisania procedury wchodzące w interakcje z reprezentacji XAML na poziomie węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>  
  
<a name="loading_into_a_xaml_reader"></a>   
## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="f4411-111">Ładowania kodu XAML do czytnika XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-111">Loading XAML into a XAML Reader</span></span>  
 <span data-ttu-id="f4411-112">Podstawowym <xref:System.Xaml.XamlReader> klasy nie deklaruje określonego technika ładowania początkowego XAML do czytnika XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="f4411-113">Zamiast tego klasy pochodnej deklaruje i implementuje technika ładowania, łącznie z właściwości ogólne i ograniczenia jego źródło danych wejściowych dla języka XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="f4411-114">Na przykład <xref:System.Xaml.XamlObjectReader> odczytuje wykres obiektu, począwszy od źródło pojedynczy obiekt, który reprezentuje katalog główny lub bazy danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="f4411-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="f4411-115"><xref:System.Xaml.XamlObjectReader> Następnie tworzy strumień węzłów XAML z wykresu obiektu.</span><span class="sxs-lookup"><span data-stu-id="f4411-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>  
  
 <span data-ttu-id="f4411-116">Najbardziej widocznym usług .NET Framework XAML — definicja <xref:System.Xaml.XamlReader> jest podklasą <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f4411-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="f4411-117"><xref:System.Xaml.XamlXmlReader>ładuje XAML początkowej, albo przez załadowanie pliku tekstowego bezpośrednio za pomocą ścieżki strumienia lub pliku lub pośrednio za pośrednictwem klasy pokrewne czytnika takich jak <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="f4411-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="f4411-118"><xref:System.Xaml.XamlReader> Mogą być uważane za zawierające całości źródło danych wejściowych XAML po załadowaniu.</span><span class="sxs-lookup"><span data-stu-id="f4411-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="f4411-119">Jednak <xref:System.Xaml.XamlReader> podstawowy interfejs API zaprojektowano tak, aby czytnik prowadzi interakcję z jednego węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="f4411-120">Po raz pierwszy załadowano pierwszy jednego węzła, które wystąpią jest elementem głównym pliku XAML, a jego początkowy obiekt.</span><span class="sxs-lookup"><span data-stu-id="f4411-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>  
  
### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="f4411-121">Pojęcie strumienia węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-121">The XAML Node Stream Concept</span></span>  
 <span data-ttu-id="f4411-122">Jeśli znasz zazwyczaj bardziej modelu DOM, metaphor drzewa lub oparte na zapytaniach podejście do uzyskiwania dostępu do technologii opartych na języku XML, pomocny sposób conceptualize strumień węzłów XAML ma następującą składnię.</span><span class="sxs-lookup"><span data-stu-id="f4411-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="f4411-123">Załóżmy, że załadować XAML jest modelu DOM lub drzewa, w którym rozwinięty aż co węzłów, a następnie udostępniana liniowo.</span><span class="sxs-lookup"><span data-stu-id="f4411-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="f4411-124">Jak możesz przechodzić przez węzły, możesz może być przechodzenie "in" lub "out" poziomów, które są istotne dla modelu DOM, ale strumień węzłów XAML nie jawnie śledzić ponieważ tych pojęć poziomu nie są odpowiednie do strumienia węzłów.</span><span class="sxs-lookup"><span data-stu-id="f4411-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="f4411-125">Strumień węzłów ma pozycji "bieżący", ale chyba, że są przechowywane inne części strumienia samodzielnie jako odniesienie, każdego aspektu strumieniu węzłów, innej niż bieżąca pozycja węzła niewidocznymi.</span><span class="sxs-lookup"><span data-stu-id="f4411-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>  
  
 <span data-ttu-id="f4411-126">Pojęcie strumienia węzłów XAML ma tę zaletę zauważalne, że przejście do strumienia całego węzła zapewni przetworzyły całej reprezentacji XAML; nie trzeba się martwić się, że zapytanie, operacja modelu DOM lub innych rożne podejście do przetwarzania informacji brakuje część pełną reprezentacja XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="f4411-127">Z tego powodu reprezentacja strumienia węzłów XAML jest idealny zarówno w przypadku łączenia czytników XAML i zapisywania XAML i udostępnia system gdzie wstawić własnego procesu działającego między etapami odczytu i zapisu operacji przetwarzania XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="f4411-128">W wielu przypadkach kolejność węzłów w strumieniu węzłów XAML jest celowo zoptymalizowanych pod kątem lub zmienić kolejności przez czytelników XAML i jak kolejność może pojawiać się tekst źródłowy, binary lub wykres obiektu.</span><span class="sxs-lookup"><span data-stu-id="f4411-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="f4411-129">To zachowanie jest przeznaczony do wymuszania Architektura przetwarzania XAML, zgodnie z którymi autorów XAML znajdują się nigdy w pozycji, które mają Wróć "" w strumieniu węzłów.</span><span class="sxs-lookup"><span data-stu-id="f4411-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="f4411-130">W idealnym przypadku XAML wszystkie operacje zapisu powinny być możliwość działania oparte na kontekst schematu oraz bieżącą pozycję w strumieniu węzłów.</span><span class="sxs-lookup"><span data-stu-id="f4411-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>  
  
<a name="a_basic_reading_node_loop"></a>   
## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="f4411-131">Pętla węzła podstawowego odczytu</span><span class="sxs-lookup"><span data-stu-id="f4411-131">A Basic Reading Node Loop</span></span>  
 <span data-ttu-id="f4411-132">Podstawowy odczytywania węzła pętli badania strumień węzłów XAML składa się z następujące pojęcia.</span><span class="sxs-lookup"><span data-stu-id="f4411-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="f4411-133">Dla celów węzła pętle zgodnie z opisem w tym temacie założono, czytają XAML tekstu, czytelny dla człowieka plików przy użyciu <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f4411-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="f4411-134">Łącza w tej sekcji odnoszą się do określonego węzła XAML pętli API zaimplementowano przez <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f4411-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>  
  
-   <span data-ttu-id="f4411-135">Upewnij się, że firma nie jest końcem strumienia węzłów XAML (Sprawdź <xref:System.Xaml.XamlXmlReader.IsEof%2A>, lub użyj <xref:System.Xaml.XamlXmlReader.Read%2A> wartość zwracana).</span><span class="sxs-lookup"><span data-stu-id="f4411-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="f4411-136">Jeśli na końcu strumienia, nie nie bieżącego węzła a powinny być kończone.</span><span class="sxs-lookup"><span data-stu-id="f4411-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>  
  
-   <span data-ttu-id="f4411-137">Sprawdź, jakiego typu węzła strumień węzłów XAML obecnie udostępnia przez wywołanie metody <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>  
  
-   <span data-ttu-id="f4411-138">Jeśli masz skojarzone Edytor obiektu XAML, który jest podłączony bezpośrednio, zazwyczaj wywołania <xref:System.Xaml.XamlWriter.WriteNode%2A> w tym momencie.</span><span class="sxs-lookup"><span data-stu-id="f4411-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>  
  
-   <span data-ttu-id="f4411-139">Na podstawie którego <xref:System.Xaml.XamlNodeType> jest zgłaszana jako bieżący węzeł lub bieżącego rekordu, wywołaj jedną z następujących czynności, aby uzyskać informacje o zawartości węzła:</span><span class="sxs-lookup"><span data-stu-id="f4411-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>  
  
    -   <span data-ttu-id="f4411-140">Dla <xref:System.Xaml.XamlXmlReader.NodeType%2A> z <xref:System.Xaml.XamlNodeType.StartMember> lub <xref:System.Xaml.XamlNodeType.EndMember>, wywołaj <xref:System.Xaml.XamlXmlReader.Member%2A> uzyskanie <xref:System.Xaml.XamlMember> informacje o składniku.</span><span class="sxs-lookup"><span data-stu-id="f4411-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="f4411-141">Należy pamiętać, że element członkowski może być <xref:System.Xaml.XamlDirective>, i w związku z tym może nie musi należeć do konwencjonalnych zdefiniowany typ poprzedniego obiektu.</span><span class="sxs-lookup"><span data-stu-id="f4411-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="f4411-142">Na przykład `x:Name` dotyczą obiekt pojawia się jako członek XAML gdzie <xref:System.Xaml.XamlMember.IsDirective%2A> ma wartość true i <xref:System.Xaml.XamlMember.Name%2A> elementu członkowskiego jest `Name`, z innymi właściwościami, co oznacza, że ta dyrektywa w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>  
  
    -   <span data-ttu-id="f4411-143">Dla <xref:System.Xaml.XamlXmlReader.NodeType%2A> z <xref:System.Xaml.XamlNodeType.StartObject> lub <xref:System.Xaml.XamlNodeType.EndObject>, wywołaj <xref:System.Xaml.XamlXmlReader.Type%2A> uzyskanie <xref:System.Xaml.XamlType> informacji o obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f4411-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>  
  
    -   <span data-ttu-id="f4411-144">Aby uzyskać <xref:System.Xaml.XamlXmlReader.NodeType%2A> z <xref:System.Xaml.XamlNodeType.Value>, wywołaj <xref:System.Xaml.XamlXmlReader.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="f4411-145">Węzeł jest wartością tylko wtedy, gdy jest najprostsza wyrażenie wartości dla elementu członkowskiego lub tekst inicjowania dla obiekt (jednak należy pamiętać o zachowanie konwersji typu zgodnie z opisem w następnej sekcji tego tematu).</span><span class="sxs-lookup"><span data-stu-id="f4411-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>  
  
    -   <span data-ttu-id="f4411-146">Dla <xref:System.Xaml.XamlXmlReader.NodeType%2A> z <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, wywołaj <xref:System.Xaml.XamlXmlReader.Namespace%2A> można uzyskać informacji dotyczących przestrzeni nazw dla węzła przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="f4411-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>  
  
-   <span data-ttu-id="f4411-147">Wywołanie <xref:System.Xaml.XamlXmlReader.Read%2A> przejść do następnego węzła w strumieniu węzłów XAML czytnika XAML i powtórz kroki ponownie.</span><span class="sxs-lookup"><span data-stu-id="f4411-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>  
  
 <span data-ttu-id="f4411-148">Strumień węzłów XAML, które są udostępniane przez .NET Framework XAML Services XAML czytniki zawsze zapewnia pełne, głębokie przejście przez wszystkie węzły możliwych.</span><span class="sxs-lookup"><span data-stu-id="f4411-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="f4411-149">Sterowanie przepływem typowe techniki pętli węzła XAML obejmują definiowanie treści w `while (reader.Read())`i włączenie <xref:System.Xaml.XamlXmlReader.NodeType%2A> w każdym węźle punktu w pętli węzła.</span><span class="sxs-lookup"><span data-stu-id="f4411-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>  
  
 <span data-ttu-id="f4411-150">Jeśli na końcu pliku strumieniu węzłów, bieżący węzeł ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="f4411-150">If the node stream is at end of file, the current node is null.</span></span>  
  
 <span data-ttu-id="f4411-151">Najprostsza pętli, które używa składników zapisywania i odczytywania podobnego do następującego.</span><span class="sxs-lookup"><span data-stu-id="f4411-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>  
  
```  
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));  
//where xamlStringToLoad is a string of well formed XAML  
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);  
while (xxr.Read()) {  
  xow.WriteNode(xxr);  
}  
```  
  
 <span data-ttu-id="f4411-152">Ten prosty przykład pętli węzła XAML ścieżki obciążenia niewidocznie łączy XAML zapisywania i odczytywania XAML, czynności nic innego niż w przypadku korzystania <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4411-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4411-153">Jednak to podstawowa struktura jest rozszerzana do zastosowania do odczytu lub zapisu scenariusza.</span><span class="sxs-lookup"><span data-stu-id="f4411-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="f4411-154">Niektóre możliwe scenariusze są następujące:</span><span class="sxs-lookup"><span data-stu-id="f4411-154">Some possible scenarios are as follows:</span></span>  
  
-   <span data-ttu-id="f4411-155">Przełącz <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="f4411-156">Wykonaj różne akcje, w zależności od tego, który węzeł odczyt typu.</span><span class="sxs-lookup"><span data-stu-id="f4411-156">Perform different actions depending on which node type is being read.</span></span>  
  
-   <span data-ttu-id="f4411-157">Nie wywołuj <xref:System.Xaml.XamlWriter.WriteNode%2A> we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="f4411-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="f4411-158">Wywoływać tylko <xref:System.Xaml.XamlWriter.WriteNode%2A> w niektórych <xref:System.Xaml.XamlXmlReader.NodeType%2A> przypadkach.</span><span class="sxs-lookup"><span data-stu-id="f4411-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>  
  
-   <span data-ttu-id="f4411-159">W ramach logikę typu określonego węzła analizować szczegółowe informacje na temat tego węzła i działają na nich.</span><span class="sxs-lookup"><span data-stu-id="f4411-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="f4411-160">Na przykład można zapisać tylko te obiekty, które pochodzą z określonego obszaru nazw XAML, a następnie upuść lub odroczenie żadne obiekty nie z tej przestrzeni nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="f4411-161">Lub może porzucić lub w przeciwnym razie ponownie przetworzyć wszystkie dyrektyw XAML, które nie obsługuje systemu XAML w ramach przetwarzania elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="f4411-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>  
  
-   <span data-ttu-id="f4411-162">Definiowanie niestandardowego <xref:System.Xaml.XamlObjectWriter> który zastępuje `Write*` metod, prawdopodobnie wykonywania mapowanie typu, które pomija kontekst schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>  
  
-   <span data-ttu-id="f4411-163">Utworzyć <xref:System.Xaml.XamlXmlReader> do użycia inny niż domyślny kontekst schematu XAML, aby dostosowane różnice w zachowaniu XAML są używane zarówno przez składnik zapisywania i odczytywania.</span><span class="sxs-lookup"><span data-stu-id="f4411-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>  
  
### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="f4411-164">Uzyskiwanie dostępu do XAML poza węzeł koncepcji pętli</span><span class="sxs-lookup"><span data-stu-id="f4411-164">Accessing XAML Beyond the Node Loop Concept</span></span>  
 <span data-ttu-id="f4411-165">Istnieją inne sposoby pracy z reprezentacji XAML innych niż jako pętli węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="f4411-166">Na przykład mogą istnieć czytnika XAML, który może odczytywać indeksowanego węzła lub w szczególności uzyskuje dostęp do węzłów bezpośrednio przez `x:Name`, przez `x:Uid`, lub za pośrednictwem innych identyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="f4411-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="f4411-167">Usługi XAML .NET framework nie zapewnia pełnej implementacji, ale zapewnia sugerowane wzorzec za pośrednictwem typów usług i pomocy technicznej.</span><span class="sxs-lookup"><span data-stu-id="f4411-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="f4411-168">Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.IXamlIndexingReader> i <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="f4411-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="f4411-169">Firma Microsoft tworzy również wydania poza pasmem, znane jako Microsoft XAML Toolkit.</span><span class="sxs-lookup"><span data-stu-id="f4411-169">Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit.</span></span> <span data-ttu-id="f4411-170">Ta wersja poza pasmem jest nadal w jego etapów wersji wstępnej.</span><span class="sxs-lookup"><span data-stu-id="f4411-170">This out-of-band release is still in its pre-release stages.</span></span> <span data-ttu-id="f4411-171">Jeśli jest gotowa do pracy ze składnikami wersji wstępnej, XAML zestawu narzędzi firmy Microsoft zapewnia jednak niektóre ciekawe zasoby dla języka XAML narzędzi i analizy statycznej XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-171">However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML.</span></span> <span data-ttu-id="f4411-172">XAML zestawu narzędzi firmy Microsoft obejmuje interfejs API modelu DOM języka XAML, obsługują analizy programu FxCop i kontekst schematu XAML dla programu Silverlight.</span><span class="sxs-lookup"><span data-stu-id="f4411-172">The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight.</span></span> <span data-ttu-id="f4411-173">Aby uzyskać więcej informacji, zobacz [zestaw narzędzi firmy Microsoft XAML](http://code.msdn.microsoft.com/XAML).</span><span class="sxs-lookup"><span data-stu-id="f4411-173">For more information, see [Microsoft XAML Toolkit](http://code.msdn.microsoft.com/XAML).</span></span>  
  
<a name="working_with_the_current_node"></a>   
## <a name="working-with-the-current-node"></a><span data-ttu-id="f4411-174">Praca z bieżącego węzła</span><span class="sxs-lookup"><span data-stu-id="f4411-174">Working with the Current Node</span></span>  
 <span data-ttu-id="f4411-175">Większość scenariuszy, które korzystają z pętli węzła XAML nie tylko odczytać węzłów.</span><span class="sxs-lookup"><span data-stu-id="f4411-175">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="f4411-176">Większości scenariuszy przetwarzania bieżącego węzłów i przekaż każdego węzła, co w czasie do wykonania <xref:System.Xaml.XamlWriter>.</span><span class="sxs-lookup"><span data-stu-id="f4411-176">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>  
  
 <span data-ttu-id="f4411-177">W tym scenariuszu ścieżki typowego obciążenia <xref:System.Xaml.XamlXmlReader> tworzy strumień węzłów XAML; węzłów XAML są przetwarzane zgodnie z sieci logiczne i kontekst schematu XAML i węzły są przekazywane do <xref:System.Xaml.XamlObjectWriter>.</span><span class="sxs-lookup"><span data-stu-id="f4411-177">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="f4411-178">Następnie można zintegrować wynikowy wykres obiektu do aplikacji lub framework.</span><span class="sxs-lookup"><span data-stu-id="f4411-178">You then integrate the resulting object graph into your application or framework.</span></span>  
  
 <span data-ttu-id="f4411-179">W typowym Zapisz scenariusz ścieżki <xref:System.Xaml.XamlObjectReader> odczytuje wykres obiektu, poszczególne węzły XAML są przetwarzane i <xref:System.Xaml.XamlXmlWriter> generuje serializacji wynik w postaci pliku tekstowego XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-179">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="f4411-180">Klucz jest, że zarówno ścieżki, jak i scenariusze obejmują pracy z dokładnie jednego węzła XAML w czasie i węzłów XAML są dostępne do przetwarzania w sposób Zestandaryzowany zdefiniowanego przez system typów języka XAML i środowiska.NET Framework XAML Services API.</span><span class="sxs-lookup"><span data-stu-id="f4411-180">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>  
  
### <a name="frames-and-scope"></a><span data-ttu-id="f4411-181">Ramek i zakresu</span><span class="sxs-lookup"><span data-stu-id="f4411-181">Frames and Scope</span></span>  
 <span data-ttu-id="f4411-182">Pętla węzła XAML przeprowadzi Cię przez strumień węzłów XAML w sposób liniowej.</span><span class="sxs-lookup"><span data-stu-id="f4411-182">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="f4411-183">Strumień węzłów jest przesyłany do obiektów, do elementów członkowskich, które zawierają inne obiekty i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="f4411-183">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="f4411-184">Często jest przydatne do śledzenia zakresie w strumieniu węzłów XAML zaimplementowanie koncepcji ramki i stosu.</span><span class="sxs-lookup"><span data-stu-id="f4411-184">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="f4411-185">Jest to szczególnie istotne, jeśli są aktywnie dostosowywania strumieniu węzłów, gdy są w nim.</span><span class="sxs-lookup"><span data-stu-id="f4411-185">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="f4411-186">Ramki i stosu obsługuje, można zaimplementować jako część logiki pętli węzeł może liczba `StartObject` (lub `GetObject`) i `EndObject` zakresów jako malejąca w strukturze węzła XAML, jeśli struktura jest traktować z punktu widzenia DOM.</span><span class="sxs-lookup"><span data-stu-id="f4411-186">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>  
  
<a name="traversing_and_entering_object_nodes"></a>   
## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="f4411-187">Przeglądanie i wprowadzając węzłów obiektowych</span><span class="sxs-lookup"><span data-stu-id="f4411-187">Traversing and Entering Object Nodes</span></span>  
 <span data-ttu-id="f4411-188">Pierwszy węzeł w strumieniu węzła, gdy jest otwarty przez czytnik XAML jest węzeł początkowy obiekt obiektu głównego.</span><span class="sxs-lookup"><span data-stu-id="f4411-188">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="f4411-189">Zgodnie z definicją tego obiektu jest zawsze pojedynczy obiekt węzła i ma nie elementów równorzędnych.</span><span class="sxs-lookup"><span data-stu-id="f4411-189">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="f4411-190">W przykładzie XAML żadnych rzeczywistych zdefiniowano główny obiekt ma co najmniej jednej właściwości zawierających więcej obiektów, a te właściwości mają węzły elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f4411-190">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="f4411-191">Węzły element członkowski ma co najmniej jeden węzeł obiektu lub może być zamknięcie w węźle wartości zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="f4411-191">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="f4411-192">Obiekt główny zwykle definiuje namescopes XAML, składniowo są przypisane jako atrybuty tekstu w kodzie XAML, ale mapowania `Namescope` typ węzła w reprezentacji strumienia węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-192">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>  
  
 <span data-ttu-id="f4411-193">Należy wziąć pod uwagę w poniższym przykładzie XAML (jest to dowolnego języka XAML, nie jest obsługiwana przez istniejące typy w programie .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="f4411-193">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="f4411-194">Przyjęto założenie, że w tym modelu obiektu `FavorCollection` jest `List<T>` z `Favor`, `Balloon` i `NoiseMaker` są można przypisać do `Favor`, `Balloon.Color` właściwość nie jest obsługiwana przez `Color` obiektu podobny do sposobu definiuje WPF kolory jako nazwy kolorów znane, i `Color` obsługuje konwertera typów programu Składnia atrybutu.</span><span class="sxs-lookup"><span data-stu-id="f4411-194">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>  
  
|<span data-ttu-id="f4411-195">Kod znaczników XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-195">XAML markup</span></span>|<span data-ttu-id="f4411-196">Wynikowa strumień węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-196">Resulting XAML node stream</span></span>|  
|-----------------|--------------------------------|  
|`<Party`|<span data-ttu-id="f4411-197">`Namespace`węzeł`Party`</span><span class="sxs-lookup"><span data-stu-id="f4411-197">`Namespace` node for `Party`</span></span>|  
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="f4411-198">`StartObject`węzeł`Party`</span><span class="sxs-lookup"><span data-stu-id="f4411-198">`StartObject` node for `Party`</span></span>|  
|`<Party.Favors>`|<span data-ttu-id="f4411-199">`StartMember`węzeł`Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="f4411-199">`StartMember` node for `Party.Favors`</span></span>|  
||<span data-ttu-id="f4411-200">`StartObject`węzeł niejawne`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="f4411-200">`StartObject` node for implicit `FavorCollection`</span></span>|  
||<span data-ttu-id="f4411-201">`StartMember`węzeł niejawne `FavorCollection` elementów właściwości.</span><span class="sxs-lookup"><span data-stu-id="f4411-201">`StartMember` node for implicit `FavorCollection` items property.</span></span>|  
|`<Balloon`|<span data-ttu-id="f4411-202">`StartObject`węzeł`Balloon`</span><span class="sxs-lookup"><span data-stu-id="f4411-202">`StartObject` node for `Balloon`</span></span>|  
|`Color="Red"`|<span data-ttu-id="f4411-203">`StartMember`węzeł`Color`</span><span class="sxs-lookup"><span data-stu-id="f4411-203">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="f4411-204">`Value`węzeł ciągu wartości atrybutu`"Red"`</span><span class="sxs-lookup"><span data-stu-id="f4411-204">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="f4411-205">`EndMember`dla`Color`</span><span class="sxs-lookup"><span data-stu-id="f4411-205">`EndMember` for `Color`</span></span>|  
|`HasHelium="True"`|<span data-ttu-id="f4411-206">`StartMember`węzeł`HasHelium`</span><span class="sxs-lookup"><span data-stu-id="f4411-206">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="f4411-207">`Value`węzeł ciągu wartości atrybutu`"True"`</span><span class="sxs-lookup"><span data-stu-id="f4411-207">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="f4411-208">`EndMember`dla`HasHelium`</span><span class="sxs-lookup"><span data-stu-id="f4411-208">`EndMember` for `HasHelium`</span></span>|  
|`>`|<span data-ttu-id="f4411-209">`EndObject`dla`Balloon`</span><span class="sxs-lookup"><span data-stu-id="f4411-209">`EndObject` for `Balloon`</span></span>|  
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="f4411-210">`StartObject`węzeł`NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="f4411-210">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="f4411-211">`StartMember`węzeł`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="f4411-211">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="f4411-212">`Value`węzeł wartość ciągu inicjowania`"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="f4411-212">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="f4411-213">`EndMember`węzeł`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="f4411-213">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="f4411-214">`EndObject`dla`NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="f4411-214">`EndObject` for `NoiseMaker`</span></span>|  
||<span data-ttu-id="f4411-215">`EndMember`węzeł niejawne `FavorCollection` elementów właściwości.</span><span class="sxs-lookup"><span data-stu-id="f4411-215">`EndMember` node for implicit `FavorCollection` items property.</span></span>|  
||<span data-ttu-id="f4411-216">`EndObject`węzeł niejawne`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="f4411-216">`EndObject` node for implicit `FavorCollection`</span></span>|  
|`</Party.Favors>`|<span data-ttu-id="f4411-217">`EndMember`dla`Favors`</span><span class="sxs-lookup"><span data-stu-id="f4411-217">`EndMember` for `Favors`</span></span>|  
|`</Party>`|<span data-ttu-id="f4411-218">`EndObject`dla`Party`</span><span class="sxs-lookup"><span data-stu-id="f4411-218">`EndObject` for `Party`</span></span>|  
  
 <span data-ttu-id="f4411-219">W strumieniu węzłów XAML może polegać na następujące zachowanie:</span><span class="sxs-lookup"><span data-stu-id="f4411-219">In the XAML node stream, you can rely on the following behavior:</span></span>  
  
-   <span data-ttu-id="f4411-220">Jeśli `Namespace` węzeł istnieje, jest ona dodawana do strumienia bezpośrednio przed `StartObject` który zadeklarowana w przestrzeni nazw XAML z `xmlns`.</span><span class="sxs-lookup"><span data-stu-id="f4411-220">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="f4411-221">Szukaj w poprzedniej tabeli z strumień węzłów XAML i przykładowe ponownie.</span><span class="sxs-lookup"><span data-stu-id="f4411-221">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="f4411-222">Powiadomienie jak `StartObject` i `Namespace` węzły wydają się być niepotrzebnemu i ich położenia deklaracji w znacznikach tekstu.</span><span class="sxs-lookup"><span data-stu-id="f4411-222">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="f4411-223">To jest reprezentatywna zachowania, gdzie węzły nazw zawsze były wyświetlane przed węzeł dotyczą one w strumieniu węzłów.</span><span class="sxs-lookup"><span data-stu-id="f4411-223">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="f4411-224">Celem tego projektu jest czy informacji dotyczących przestrzeni nazw jest niezbędne do zapisywania obiektów i musi być znane, aby obiekt składnika zapisywania próby wykonania typu mapowania lub w inny sposób przetwarzania obiektu.</span><span class="sxs-lookup"><span data-stu-id="f4411-224">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="f4411-225">Wprowadzenie do informacji dotyczących przestrzeni nazw XAML przed jego zakres aplikacji w strumieniu uproszczono zawsze przetworzyć strumieniu węzłów w jego przedstawioną kolejności.</span><span class="sxs-lookup"><span data-stu-id="f4411-225">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>  
  
-   <span data-ttu-id="f4411-226">Z powodu powyżej brany pod uwagę jest co najmniej jeden `Namespace` węzłów, które można odczytać najpierw w większości przypadków rzeczywistych znaczników podczas przechodzących przez węzły od początku, nie `StartObject` głównego.</span><span class="sxs-lookup"><span data-stu-id="f4411-226">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>  
  
-   <span data-ttu-id="f4411-227">A `StartObject` następuje węzła `StartMember`, `Value`, lub natychmiastowe `EndObject`.</span><span class="sxs-lookup"><span data-stu-id="f4411-227">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="f4411-228">To nigdy a bezpośrednio przez inną `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="f4411-228">It is never followed immediately by another `StartObject`.</span></span>  
  
-   <span data-ttu-id="f4411-229">A `StartMember` może następować `StartObject`, `Value`, lub natychmiastowe `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="f4411-229">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="f4411-230">Może występować przez `GetObject`, dla członków, gdzie wartość powinien pochodzić z istniejącej wartości w obiekcie nadrzędnym zamiast `StartObject` który spowoduje utworzenie wystąpienia nową wartość.</span><span class="sxs-lookup"><span data-stu-id="f4411-230">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="f4411-231">Może również wystąpić przez `Namespace` węzła, który ma zastosowanie do przyszłych `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="f4411-231">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="f4411-232">To nigdy a bezpośrednio przez inną `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="f4411-232">It is never followed immediately by another `StartMember`.</span></span>  
  
-   <span data-ttu-id="f4411-233">A `Value` reprezentuje węzeł samą wartość; nie istnieje żadne "wartość końcowa panelu".</span><span class="sxs-lookup"><span data-stu-id="f4411-233">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="f4411-234">Może być stosowana tylko przez `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="f4411-234">It can be followed only by an `EndMember`.</span></span>  
  
    -   <span data-ttu-id="f4411-235">W strukturze wartość obiektu nie powoduje tekstu XAML inicjowania obiektu, ponieważ może być używany przez konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="f4411-235">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="f4411-236">Zamiast tego węzła dedykowanych elementu członkowskiego dla elementu członkowskiego o nazwie `_Initialization` jest tworzony.</span><span class="sxs-lookup"><span data-stu-id="f4411-236">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="f4411-237">i ten węzeł elementu członkowskiego zawiera wartość ciągu inicjowania.</span><span class="sxs-lookup"><span data-stu-id="f4411-237">and that member node contains the initialization value string.</span></span> <span data-ttu-id="f4411-238">Jeśli istnieje, `_Initialization` jest zawsze pierwszy `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="f4411-238">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="f4411-239">`_Initialization`może być kwalifikowany w niektórych reprezentacje usług XAML z namescope XAML języka XAML, wyjaśnienia, że `_Initialization` nie jest właściwością zdefiniowanych w tworzeniu kopii typów.</span><span class="sxs-lookup"><span data-stu-id="f4411-239">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>  
  
    -   <span data-ttu-id="f4411-240">Kombinacja wartości elementu członkowskiego reprezentuje ustawienia wartości atrybutów.</span><span class="sxs-lookup"><span data-stu-id="f4411-240">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="f4411-241">Po pewnym czasie prawdopodobnie konwerter wartości objętego przetwarzania tej wartości, a wartość to zwykły ciąg.</span><span class="sxs-lookup"><span data-stu-id="f4411-241">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="f4411-242">Jednakże, który nie jest oceniany, aż do zapisywania obiektów XAML przetwarza strumień węzła.</span><span class="sxs-lookup"><span data-stu-id="f4411-242">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="f4411-243">Moduł zapisywania obiektów XAML posiada niezbędne kontekst schematu XAML, mapowanie typu systemu i innych obsługi potrzebne do konwersji wartości.</span><span class="sxs-lookup"><span data-stu-id="f4411-243">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>  
  
-   <span data-ttu-id="f4411-244">`EndMember` Następuje węzła `StartMember` węzła dla kolejnych elementów członkowskich lub przez `EndObject` węzła właściciela elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f4411-244">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>  
  
-   <span data-ttu-id="f4411-245">`EndObject` Następuje węzła `EndMember` węzła.</span><span class="sxs-lookup"><span data-stu-id="f4411-245">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="f4411-246">Może również wystąpić przez `StartObject` węzła w przypadkach, w których obiekty są równorzędne w kolekcji elementów.</span><span class="sxs-lookup"><span data-stu-id="f4411-246">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="f4411-247">Lub może występować przez `Namespace` węzła, który ma zastosowanie do przyszłych `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="f4411-247">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>  
  
    -   <span data-ttu-id="f4411-248">W przypadku unikatowy zamknięcie strumienia całego węzła `EndObject` z katalogu głównego nie następuje niczego; czytnik jest teraz końca pliku i <xref:System.Xaml.XamlReader.Read%2A> zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="f4411-248">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>  
  
<a name="value_converters_and_the_xaml_node_stream"></a>   
## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="f4411-249">Konwertery wartości i strumień węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-249">Value Converters and the XAML Node Stream</span></span>  
 <span data-ttu-id="f4411-250">Konwerter wartości to ogólny termin dla rozszerzenia znacznika, konwertera typów (w tym serializatorów wartość) lub innej dedykowanych klasy, która jest raportowana jako konwertera wartości przez system typów języka XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-250">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="f4411-251">W strumieniu węzłów XAML użycie konwertera typu i użycie rozszerzenia znaczników mają bardzo różne reprezentacje.</span><span class="sxs-lookup"><span data-stu-id="f4411-251">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>  
  
### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="f4411-252">Konwertery typu w strumieniu węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-252">Type Converters in the XAML Node Stream</span></span>  
 <span data-ttu-id="f4411-253">Atrybut ustawiony, że ostatecznie powoduje użycie konwertera typu jest zgłaszany w strumieniu węzłów XAML jako wartość elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f4411-253">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="f4411-254">Strumień węzłów XAML nie próbuje utworzyć wystąpienie obiektu konwertera typu i wartość należy przekazać do niego.</span><span class="sxs-lookup"><span data-stu-id="f4411-254">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="f4411-255">Przy użyciu konwertera typów implementacji konwersja wymaga wywoływania kontekst schematu XAML i używa go dla mapowania typu.</span><span class="sxs-lookup"><span data-stu-id="f4411-255">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="f4411-256">Nawet określanie, która klasa konwertera typu powinny być używane do przetwarzania wartość wymaga pośrednio kontekst schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-256">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="f4411-257">Gdy używany jest domyślny kontekst schematu XAML, te informacje są dostępne w systemie typów języka XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-257">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="f4411-258">Jeśli potrzebujesz informacji o klasie konwertera typu na poziomie strumienia węzła XAML przed połączenia do modułu zapisującego XAML, możesz uzyskać je od <xref:System.Xaml.XamlMember> informacji jest zestaw elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="f4411-258">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="f4411-259">Ale w przeciwnym razie dane wejściowe konwertera typu powinna zostać zachowana w strumieniu węzłów XAML jako wartość zwykły aż do końca operacji, które wymagają systemu mapowania typów i kontekst schematu XAML są wykonywane, na przykład tworzenie obiektu przez XAML obiekt składnika zapisywania.</span><span class="sxs-lookup"><span data-stu-id="f4411-259">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>  
  
 <span data-ttu-id="f4411-260">Na przykład należy wziąć pod uwagę następujące konspekt definicji klasy i użycie języka XAML go:</span><span class="sxs-lookup"><span data-stu-id="f4411-260">For example, consider the following class definition outline and XAML usage for it:</span></span>  
  
```  
public class BoardSizeConverter : TypeConverter {  
  //converts from string to an int[2] by splitting on an "x" char  
}  
public class GameBoard {  
  [TypeConverter(typeof(BoardSizeConverter))]  
  public int[] BoardSize; //2x2 array, initialization not shown  
}  
```  
  
```xaml  
<GameBoard BoardSize="8x8"/>  
```  
  
 <span data-ttu-id="f4411-261">Tekstowa reprezentacja strumień węzłów XAML dla tego użycia mogą być wyrażone w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="f4411-261">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>  
  
 <span data-ttu-id="f4411-262">`StartObject`z <xref:System.Xaml.XamlType> reprezentujący`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="f4411-262">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>  
  
 <span data-ttu-id="f4411-263">`StartMember`z <xref:System.Xaml.XamlMember> reprezentujący`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="f4411-263">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>  
  
 <span data-ttu-id="f4411-264">`Value`węzeł, z ciągu tekstowego "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="f4411-264">`Value` node, with text string "`8x8`"</span></span>  
  
 <span data-ttu-id="f4411-265">`EndMember`dopasowań`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="f4411-265">`EndMember` matches `BoardSize`</span></span>  
  
 <span data-ttu-id="f4411-266">`EndObject`dopasowań`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="f4411-266">`EndObject` matches `GameBoard`</span></span>  
  
 <span data-ttu-id="f4411-267">Zwróć uwagę, nie jest żadne wystąpienie konwertera typu strumienia tego węzła.</span><span class="sxs-lookup"><span data-stu-id="f4411-267">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="f4411-268">Ale można uzyskać informacji o typie konwertera wywołując <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> na <xref:System.Xaml.XamlMember> dla `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="f4411-268">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="f4411-269">Jeśli masz prawidłowy kontekst schematu XAML, można także wywoływać metody konwertera uzyskując wystąpienia z <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-269">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>  
  
### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="f4411-270">Rozszerzenia znaczników w strumieniu węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-270">Markup Extensions in the XAML Node Stream</span></span>  
 <span data-ttu-id="f4411-271">Użycie rozszerzenia znaczników jest zgłaszane w strumieniu węzłów XAML jako obiekt węzła w ramach elementu członkowskiego, w którym obiekt reprezentuje wystąpienie rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="f4411-271">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="f4411-272">W związku z tym użycie rozszerzenia znaczników jest podana więcej jawnie w reprezentacji strumienia węzłów niż użycie konwertera typu jest i zawiera więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="f4411-272">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="f4411-273"><xref:System.Xaml.XamlMember>informacji może nie mieć polecił niczego o rozszerzeniu znaczników ponieważ użycia jest oparty na analizie sytuacji i zmienia się w każdym przypadku możliwe znaczników; nie jest dedykowany i niejawne według typu lub elementu członkowskiego jak w przypadku konwertery typu.</span><span class="sxs-lookup"><span data-stu-id="f4411-273"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>  
  
 <span data-ttu-id="f4411-274">Reprezentacja strumienia węzeł rozszerzenia znaczników jako węzły obiektu jest to możliwe nawet wtedy, gdy użycie rozszerzenia znaczników została wprowadzona w formie atrybutu tekstowego w kodzie XAML (która jest często wielkość liter).</span><span class="sxs-lookup"><span data-stu-id="f4411-274">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="f4411-275">Użycia rozszerzenia znaczników, używane w postaci elementu jawne obiektu są traktowane tak samo.</span><span class="sxs-lookup"><span data-stu-id="f4411-275">Markup extension usages that used an explicit object element form are treated the same way.</span></span>  
  
 <span data-ttu-id="f4411-276">W węźle obiektu rozszerzenia znaczników mogą być członkami tego rozszerzenia znacznika.</span><span class="sxs-lookup"><span data-stu-id="f4411-276">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="f4411-277">Reprezentacja strumienia węzłów XAML zachowuje użycia tego rozszerzenia znacznika, czy to być użycia parametrów pozycyjnych lub użycia z jawne parametry nazwane.</span><span class="sxs-lookup"><span data-stu-id="f4411-277">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>  
  
 <span data-ttu-id="f4411-278">W przypadku użycia parametrów pozycyjnych, strumień węzłów XAML zawiera właściwości zdefiniowane w języku XAML `_PositionalParameters` zawierające rekordy użycia.</span><span class="sxs-lookup"><span data-stu-id="f4411-278">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="f4411-279">Ta właściwość jest rodzajowy <xref:System.Collections.Generic.List%601> z <xref:System.Object> ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="f4411-279">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="f4411-280">Ograniczenie jest obiektu i nie ciągu, ponieważ powrotne użycia parametrów pozycyjnych mogą zawierać użycia rozszerzenia znaczników zagnieżdżonych w niej.</span><span class="sxs-lookup"><span data-stu-id="f4411-280">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="f4411-281">Dostęp do parametrów pozycyjnych z użycia, można wykonać iterację listy i użyj indeksatorów dla poszczególnych wartości.</span><span class="sxs-lookup"><span data-stu-id="f4411-281">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>  
  
 <span data-ttu-id="f4411-282">Nazwany parametr użytkowania każdy nazwany parametr jest reprezentowany jako węzeł elementu członkowskiego o tej nazwie w strumieniu węzłów.</span><span class="sxs-lookup"><span data-stu-id="f4411-282">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="f4411-283">Wartości elementów członkowskich niekoniecznie ciągów, ponieważ może być użycie rozszerzenia znaczników zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="f4411-283">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>  
  
 <span data-ttu-id="f4411-284">`ProvideValue`z poziomu znacznika rozszerzenia nie jest jeszcze wywołana.</span><span class="sxs-lookup"><span data-stu-id="f4411-284">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="f4411-285">Jednak jest wywoływana, jeśli Podłącz czytnik XAML i składnika zapisywania języka XAML, aby `WriteEndObject` jest wywoływana w węźle rozszerzenia znaczników, gdy należy zbadać w strumieniu węzłów.</span><span class="sxs-lookup"><span data-stu-id="f4411-285">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="f4411-286">Z tego powodu konieczne są zwykle tym samym kontekście schematu XAML dostępne, ponieważ mają być używane w celu utworzenia wykresu obiektu na ścieżce obciążenia.</span><span class="sxs-lookup"><span data-stu-id="f4411-286">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="f4411-287">W przeciwnym razie `ProvideValue` z żadnych znaczników rozszerzenia można zgłaszają wyjątki, w tym miejscu, ponieważ nie ma oczekiwanego dostępność usług.</span><span class="sxs-lookup"><span data-stu-id="f4411-287">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>  
  
<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>   
## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="f4411-288">XAML i XML język elementów członkowskich zdefiniowanych w strumieniu węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-288">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>  
 <span data-ttu-id="f4411-289">Niektóre elementy członkowskie są wprowadzane do strumień węzłów XAML z powodu interpretacje i konwencje czytnik XAML, zamiast za pośrednictwem jawnego <xref:System.Xaml.XamlMember> wyszukiwania lub konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="f4411-289">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="f4411-290">Te elementy członkowskie są często dyrektywy XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-290">Often, these members are XAML directives.</span></span> <span data-ttu-id="f4411-291">W niektórych przypadkach jest czynnością odczytywania XAML, przedstawiający dyrektywy do strumienia węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-291">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="f4411-292">Innymi słowy, oryginalny tekst XAML wejściowy został explictly nie określać dyrektywę elementu członkowskiego, ale czytnik XAML wstawia dyrektywy w celu spełnienia strukturalnych XAML Konwencji i przekazuje informacje w strumieniu węzłów XAML, aby te informacje zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="f4411-292">In other words, the original input XAML text did not explictly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>  
  
 <span data-ttu-id="f4411-293">Poniższe uwagi listy wszystkich przypadkach, których można oczekiwać czytnik XAML wprowadzenie dyrektywy węzeł elementu członkowskiego XAML i jak ten węzeł elementu członkowskiego jest identyfikowane we wdrożeniach usług .NET Framework XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-293">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>  
  
-   <span data-ttu-id="f4411-294">**Tekst inicjowania dla obiekt węzła:** jest nazwa węzła tego elementu członkowskiego `_Initialization`reprezentuje dyrektywy XAML i jest on zdefiniowany w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-294">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="f4411-295">Statyczne jednostki można uzyskać z poziomu <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-295">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>  
  
-   <span data-ttu-id="f4411-296">**Parametry pozycyjne dla rozszerzenia znacznika:** nazwa tego węzła elementu członkowskiego jest `_PositionalParameters`, i jest on zdefiniowany w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-296">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="f4411-297">Zawsze zawiera ogólne listę obiektów, z których każdy jest parametrów pozycyjnych wstępnie oddzielone dzielenie na `,` znak ogranicznika zgodnie z podanym w danych wejściowych XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-297">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="f4411-298">Możesz też uzyskać statycznych jednostki dyrektywy parametrów pozycyjnych z <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-298">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>  
  
-   <span data-ttu-id="f4411-299">**Nieznany zawartości:** jest nazwa węzła tego elementu członkowskiego `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="f4411-299">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="f4411-300">Mówiąc ściślej, jest <xref:System.Xaml.XamlDirective>, i jest on zdefiniowany w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-300">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="f4411-301">Ta dyrektywa jest używana jako wskaźnikowych w przypadkach, gdy XAML object element zawiera zawartość w źródle XAML, ale można ustalić ma właściwości zawartości w obszarze obecnie kontekst schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-301">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="f4411-302">Ten przypadek może wykryć w strumień węzłów XAML, sprawdzając dla elementów członkowskich o nazwie `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="f4411-302">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="f4411-303">Jeśli nie podjęto żadnych innych akcji w obciążenia ścieżki strumień węzłów XAML, wartość domyślna <xref:System.Xaml.XamlObjectWriter> zgłoszenie próba `WriteEndObject` po napotkaniu `_UnknownContent` Członkowskie dowolnego obiektu.</span><span class="sxs-lookup"><span data-stu-id="f4411-303">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="f4411-304">Wartość domyślna <xref:System.Xaml.XamlXmlWriter> nie zgłasza i traktuje jako niejawne elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f4411-304">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="f4411-305">Możesz uzyskać statycznych jednostki dla `_UnknownContent` z <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-305">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>  
  
-   <span data-ttu-id="f4411-306">**Właściwości kolekcji kolekcji:**chociaż zapasowy typ CLR kolekcji klasy, która jest zwykle używany dla XAML zawiera dedykowany nazwane właściwości, która przechowuje elementy kolekcji, tej właściwości jest nieznany system typów języka XAML, przed wykonaniem kopii typu rozdzielczość.</span><span class="sxs-lookup"><span data-stu-id="f4411-306">**Collection property of a collection:**Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="f4411-307">Zamiast tego strumień węzłów XAML wprowadzono `Items` symbol zastępczy jest członkiem kolekcji typu XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-307">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="f4411-308">W implementacji usług .NET Framework XAML nazwę tej dyrektywy / element członkowski w strumieniu węzłów jest `_Items`.</span><span class="sxs-lookup"><span data-stu-id="f4411-308">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="f4411-309">Stała dla tej dyrektywy można uzyskać z <xref:System.Xaml.XamlLanguage.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="f4411-309">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>  
  
     <span data-ttu-id="f4411-310">Należy pamiętać, że strumień węzłów XAML może zawierać właściwości elementów z elementów, które stają się nie być parseable na podstawie rozpoznawania typu zapasowy i kontekst schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-310">Note that a XAML node stream might contain an Items property with items that turn out to not be parseable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="f4411-311">Na przykład</span><span class="sxs-lookup"><span data-stu-id="f4411-311">For example,</span></span>  
  
-   <span data-ttu-id="f4411-312">**Elementy członkowskie zdefiniowane XML:** zdefiniowane XML `xml:base`, `xml:lang` i `xml:space` elementy członkowskie są raportowane klientowi jako XAML dyrektywy o nazwie `base`, `lang`, i `space` w usług .NET Framework XAML implementacje.</span><span class="sxs-lookup"><span data-stu-id="f4411-312">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="f4411-313">Przestrzeń nazw dla tych jest przestrzeń nazw XML `http://www.w3.org/XML/1998/namespace`.</span><span class="sxs-lookup"><span data-stu-id="f4411-313">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="f4411-314">Stałe dla każdego z nich można uzyskać z <xref:System.Xaml.XamlLanguage>.</span><span class="sxs-lookup"><span data-stu-id="f4411-314">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>  
  
## <a name="node-order"></a><span data-ttu-id="f4411-315">Kolejność węzłów</span><span class="sxs-lookup"><span data-stu-id="f4411-315">Node Order</span></span>  
 <span data-ttu-id="f4411-316">W niektórych przypadkach <xref:System.Xaml.XamlXmlReader> zmienia kolejność węzłów XAML w strumieniu węzłów XAML, a kolejność węzły wyświetlane w znaczniku lub przetwarzane w formacie XML.</span><span class="sxs-lookup"><span data-stu-id="f4411-316">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="f4411-317">Jest to realizowane aby uporządkowane węzły tak, aby <xref:System.Xaml.XamlObjectWriter> może przetwarzać strumieniu węzłów w sposób tylko do przodu.</span><span class="sxs-lookup"><span data-stu-id="f4411-317">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="f4411-318">W programie .NET Framework XAML Services czytnika XAML zmienia kolejność węzłów zamiast pozostawiając to zadanie optymalizacji wydajności dla XAML obiektu składnika zapisywania konsumentów strumienia węzła twórcę XAML.</span><span class="sxs-lookup"><span data-stu-id="f4411-318">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>  
  
 <span data-ttu-id="f4411-319">Niektórych dyrektyw są przeznaczone specjalnie, o podanie dodatkowych informacji w celu utworzenia obiektu z elementu object.</span><span class="sxs-lookup"><span data-stu-id="f4411-319">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="f4411-320">Te dyrektywy: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span><span class="sxs-lookup"><span data-stu-id="f4411-320">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="f4411-321">Czytniki .NET Framework XAML Services XAML próbować umieścić te dyrektywy jako pierwszy elementów członkowskich w strumieniu węzłów następującego obiektu `StartObject`, przyczyn, które opisano szczegółowo w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="f4411-321">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>  
  
### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="f4411-322">Zachowanie XamlObjectWriter i kolejność węzłów</span><span class="sxs-lookup"><span data-stu-id="f4411-322">XamlObjectWriter Behavior and Node Order</span></span>  
 <span data-ttu-id="f4411-323">`StartObject`Aby <xref:System.Xaml.XamlObjectWriter> niekoniecznie sygnał do zapisywania obiektów XAML od razu utworzyć wystąpienie obiektu.</span><span class="sxs-lookup"><span data-stu-id="f4411-323">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="f4411-324">XAML zawiera kilka funkcji języka, które umożliwiają można zainicjować obiektu przy użyciu dodatkowych danych wejściowych, a nie polegać wyłącznie na wywołania konstruktora domyślnego do tworzenia obiektu początkowej i następnie ustawienie właściwości.</span><span class="sxs-lookup"><span data-stu-id="f4411-324">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a default constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="f4411-325">Te funkcje obejmują: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; inicjowania tekstu. [x: typearguments —](../../../docs/framework/xaml-services/x-typearguments-directive.md); pozycyjnych Parametry rozszerzenia znacznika; metodami factory i skojarzone [x: Arguments](../../../docs/framework/xaml-services/x-arguments-directive.md) węzłów (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="f4411-325">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](../../../docs/framework/xaml-services/x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](../../../docs/framework/xaml-services/x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="f4411-326">Każdy z tych przypadkach opóźnienie konstruowania rzeczywistego obiektu, a ponieważ ponownie sortowane strumień węzłów XAML zapisywania obiektu może polegać na zachowanie faktycznie konstruowanie wystąpienie napotkaniu członka start, które nie jest specjalnie konstrukcji dyrektywa dla tego typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="f4411-326">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>  
  
### <a name="getobject"></a><span data-ttu-id="f4411-327">GetObject</span><span class="sxs-lookup"><span data-stu-id="f4411-327">GetObject</span></span>  
 <span data-ttu-id="f4411-328">`GetObject`reprezentuje węzeł XAML, gdzie zamiast tworzenia nowego obiektu, Edytor obiektu XAML powinien zamiast tego Pobierz wartość obiektu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="f4411-328">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="f4411-329">Typowy przypadek gdzie `GetObject` napotkano węzła do węzła XAML strumień jest dla obiektu kolekcji lub słownika, gdy zawierająca go właściwość jest celowo tylko do odczytu w modelu obiektu zapasowego typu.</span><span class="sxs-lookup"><span data-stu-id="f4411-329">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="f4411-330">W tym scenariuszu kolekcji lub słownika często jest tworzony i inicjowany (zazwyczaj puste) przez logikę inicjowania typu będący właścicielem.</span><span class="sxs-lookup"><span data-stu-id="f4411-330">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f4411-331">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f4411-331">See Also</span></span>  
 <xref:System.Xaml.XamlObjectReader>  
 [<span data-ttu-id="f4411-332">Usługi XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-332">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)  
 [<span data-ttu-id="f4411-333">Przestrzeń nazw XAML</span><span class="sxs-lookup"><span data-stu-id="f4411-333">XAML Namespaces</span></span>](../../../docs/framework/xaml-services/xaml-namespaces-for-net-framework-xaml-services.md)
