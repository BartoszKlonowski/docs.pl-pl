---
title: Zapoznanie się ze strukturami i koncepcjami strumienia węzłów XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: c873961982cd1642d8b354e5d77b06105c0b7a1e
ms.sourcegitcommit: 30a83efb57c468da74e9e218de26cf88d3254597
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/20/2019
ms.locfileid: "68364309"
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="d32a2-102">Zapoznanie się ze strukturami i koncepcjami strumienia węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-102">Understanding XAML Node Stream Structures and Concepts</span></span>

<span data-ttu-id="d32a2-103">Czytelnicy XAML i autorzy języka XAML zaimplementowani w .NET Framework usługach XAML opierają się na koncepcji projektowej strumienia węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="d32a2-104">Strumień węzłów XAML to conceptualization zestawu węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="d32a2-105">W tym conceptualization procesor XAML przeprowadzi przez strukturę relacji między węzłami w kodzie XAML po jednym naraz.</span><span class="sxs-lookup"><span data-stu-id="d32a2-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="d32a2-106">W dowolnym momencie tylko jeden bieżący rekord lub bieżąca pozycja istnieje w otwartym strumieniu węzła XAML i wiele aspektów interfejsu API raportuje tylko te informacje, które są dostępne w tej pozycji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="d32a2-107">Bieżący węzeł w strumieniu węzła XAML można opisać jako obiekt, element członkowski lub wartość.</span><span class="sxs-lookup"><span data-stu-id="d32a2-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="d32a2-108">Traktując kod XAML jako strumień węzłów XAML, czytelnicy XAML mogą komunikować się z modułami zapisujących XAML i umożliwiają programowi wyświetlanie, współdziałanie z lub zmienianie zawartości strumienia węzłów XAML podczas ścieżki ładowania lub operacji zapisywania ścieżki, która obejmuje kod XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="d32a2-109">Projektowanie i tworzenie interfejsów API modułu zapisywania języka XAML oraz koncepcja strumienia węzłów XAML są podobne do wcześniejszych powiązanych projektów i koncepcji składnika zapisywania, takich jak [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] <xref:System.Xml.XmlReader> i <xref:System.Xml.XmlWriter> klasy.</span><span class="sxs-lookup"><span data-stu-id="d32a2-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="d32a2-110">W tym temacie omówiono koncepcje strumienia węzłów XAML i opisano, jak można pisać procedury, które współdziałają z reprezentacjami XAML na poziomie węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

<a name="loading_into_a_xaml_reader"></a>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="d32a2-111">Ładowanie języka XAML do czytnika XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="d32a2-112">Klasa bazowa <xref:System.Xaml.XamlReader> nie deklaruje konkretnej techniki ładowania początkowego kodu XAML do czytnika XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="d32a2-113">Zamiast tego Klasa pochodna deklaruje i implementuje technikę ładowania, łącznie z ogólnymi właściwościami i ograniczeniami źródła danych wejściowych języka XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="d32a2-114">Na przykład program <xref:System.Xaml.XamlObjectReader> odczytuje Graf obiektu, rozpoczynając od źródła danych wejściowych pojedynczego obiektu, który reprezentuje element główny lub podstawowy.</span><span class="sxs-lookup"><span data-stu-id="d32a2-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="d32a2-115"><xref:System.Xaml.XamlObjectReader> Następnie tworzy strumień węzłów XAML z grafu obiektów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="d32a2-116">Najbardziej widocznymi <xref:System.Xaml.XamlReader> <xref:System.Xaml.XamlXmlReader>podklasami .NET Framework XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="d32a2-117"><xref:System.Xaml.XamlXmlReader>ładuje początkowy kod XAML, ładując plik tekstowy bezpośrednio za pomocą strumienia lub ścieżki pliku lub pośrednio za pomocą powiązanej klasy czytnika, takiej jak <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="d32a2-118"><xref:System.Xaml.XamlReader> Może być uważany za zawierający całość źródła danych wejściowych XAML po jego załadowaniu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="d32a2-119"><xref:System.Xaml.XamlReader> Jednak podstawowy interfejs API jest zaprojektowana tak, aby czytelnik pracowali z pojedynczym węzłem XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="d32a2-120">Po pierwszym załadowaniu pierwszy pojedynczy węzeł jest katalogiem głównym XAML i jego obiektem początkowym.</span><span class="sxs-lookup"><span data-stu-id="d32a2-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="d32a2-121">Koncepcja strumienia węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="d32a2-122">Jeśli zazwyczaj znasz metody DOM, Tree metaphor lub oparte na zapytaniach na potrzeby uzyskiwania dostępu do technologii opartych na języku XML, przydatny sposób konceptualizacji strumienia węzłów XAML jest następujący.</span><span class="sxs-lookup"><span data-stu-id="d32a2-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="d32a2-123">Załóżmy, że załadowany kod XAML jest modelem DOM lub drzewem, gdzie każdy możliwy węzeł jest rozwinięty, a następnie prezentowany liniowo.</span><span class="sxs-lookup"><span data-stu-id="d32a2-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="d32a2-124">Po przejściu między węzłami można przejść do obszaru "in" lub "out", które byłyby odpowiednie dla modelu DOM, ale strumień węzłów XAML nie jest jawnie śledzony, ponieważ te koncepcje poziomu nie mają zastosowania do strumienia węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="d32a2-125">Strumień węzła ma wartość "Current", ale chyba że przechowujesz inne części strumienia samodzielnie jako odwołania, każdy aspekt strumienia węzła poza bieżącą pozycją węzła jest poza widokiem.</span><span class="sxs-lookup"><span data-stu-id="d32a2-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="d32a2-126">Koncepcja strumienia węzłów XAML ma istotną korzyść, która w przypadku przechodzenia przez cały strumień węzła ma pewność, że przetworzono całą reprezentację XAML; nie trzeba martwić się, że zapytanie, operacja modelu DOM lub inne nieliniowe podejście do przetwarzania informacji nie pozostałej części kompletnej reprezentacji XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="d32a2-127">Z tego powodu Reprezentacja strumienia węzłów XAML jest idealnym rozwiązaniem do łączenia czytników XAML i autorów XAML oraz do zapewnienia systemu, w którym można wstawić własny proces, który działa między fazami odczytu i zapisu operacji przetwarzania XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="d32a2-128">W wielu przypadkach kolejność węzłów w strumieniu węzła XAML jest świadomie zoptymalizowana lub zmieniana według czytelników, a w zależności od tego, w jaki sposób kolejność może być wyświetlana w postaci tekstu źródłowego, binarnego lub grafu obiektów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="d32a2-129">To zachowanie służy do wymuszania architektury przetwarzania XAML, w której moduły zapisujące XAML nigdy nie znajdują się w pozycji, w której muszą przejść "Wstecz" w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="d32a2-130">W idealnym przypadku wszystkie operacje zapisu XAML powinny być w stanie działać na podstawie kontekstu schematu oraz bieżącego położenia strumienia węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

<a name="a_basic_reading_node_loop"></a>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="d32a2-131">Podstawowa pętla do odczytu węzła</span><span class="sxs-lookup"><span data-stu-id="d32a2-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="d32a2-132">Podstawowa pętla do odczytu między węzłami do badania strumienia węzłów XAML składa się z następujących pojęć.</span><span class="sxs-lookup"><span data-stu-id="d32a2-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="d32a2-133">Na potrzeby pętli węzłów zgodnie z opisem w tym temacie Załóżmy, że odczytywany jest tekst tekstowy, czytelny dla człowieka przy użyciu <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="d32a2-134">Linki w tej sekcji odnoszą się do określonego interfejsu API pętli węzła XAML zaimplementowanego przez <xref:System.Xaml.XamlXmlReader>program.</span><span class="sxs-lookup"><span data-stu-id="d32a2-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="d32a2-135">Upewnij się, że nie znajdujesz się na końcu strumienia węzła XAML (Sprawdź <xref:System.Xaml.XamlXmlReader.IsEof%2A>lub <xref:System.Xaml.XamlXmlReader.Read%2A> Użyj wartości zwracanej).</span><span class="sxs-lookup"><span data-stu-id="d32a2-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="d32a2-136">Jeśli znajdujesz się na końcu strumienia, nie ma bieżącego węzła i nie należy go zamykać.</span><span class="sxs-lookup"><span data-stu-id="d32a2-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="d32a2-137">Sprawdź, jakiego typu węzeł strumień węzłów XAML jest obecnie ujawniany przez <xref:System.Xaml.XamlXmlReader.NodeType%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="d32a2-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="d32a2-138">Jeśli masz skojarzony moduł zapisujący obiektów XAML, który jest połączony bezpośrednio, na tym <xref:System.Xaml.XamlWriter.WriteNode%2A> etapie zwykle jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="d32a2-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="d32a2-139">Na podstawie tego <xref:System.Xaml.XamlNodeType> , który jest raportowany jako bieżący węzeł lub bieżący rekord, wywołaj jedną z następujących czynności, aby uzyskać informacje o zawartości węzła:</span><span class="sxs-lookup"><span data-stu-id="d32a2-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="d32a2-140"><xref:System.Xaml.XamlXmlReader.NodeType%2A> Dla lub ,wywołać<xref:System.Xaml.XamlXmlReader.Member%2A> , aby uzyskać<xref:System.Xaml.XamlMember> informacje na temat elementu członkowskiego. <xref:System.Xaml.XamlNodeType.EndMember> <xref:System.Xaml.XamlNodeType.StartMember></span><span class="sxs-lookup"><span data-stu-id="d32a2-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="d32a2-141">Należy zauważyć <xref:System.Xaml.XamlDirective>, że element członkowski może być, a tym samym nie musi być konwencjonalnym, zdefiniowanym typem elementu członkowskiego poprzedzającego obiektu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="d32a2-142">Na przykład `x:Name` zastosowana do obiektu jest wyświetlana jako element członkowski języka XAML <xref:System.Xaml.XamlMember.IsDirective%2A> , gdzie ma wartość <xref:System.Xaml.XamlMember.Name%2A> true, a element `Name`członkowski to, z innymi właściwościami wskazującymi, że ta dyrektywa znajduje się w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="d32a2-143"><xref:System.Xaml.XamlXmlReader.NodeType%2A> Dla lub ,wywołać<xref:System.Xaml.XamlXmlReader.Type%2A> , aby uzyskać<xref:System.Xaml.XamlType> informacje na temat obiektu. <xref:System.Xaml.XamlNodeType.EndObject> <xref:System.Xaml.XamlNodeType.StartObject></span><span class="sxs-lookup"><span data-stu-id="d32a2-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="d32a2-144"><xref:System.Xaml.XamlXmlReader.NodeType%2A> Dla wywołania<xref:System.Xaml.XamlXmlReader.Value%2A>. <xref:System.Xaml.XamlNodeType.Value></span><span class="sxs-lookup"><span data-stu-id="d32a2-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="d32a2-145">Węzeł jest wartością tylko wtedy, gdy jest to najprostsze wyrażenie wartości elementu członkowskiego lub tekst inicjujący dla obiektu (jednak należy pamiętać o zachowaniu konwersji typu zgodnie z opisem w dalszej części tego tematu).</span><span class="sxs-lookup"><span data-stu-id="d32a2-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="d32a2-146">Dla elementu <xref:System.Xaml.XamlXmlReader.NodeType%2A> z <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>należy wywołać <xref:System.Xaml.XamlXmlReader.Namespace%2A> , aby uzyskać informacje o przestrzeni nazw dla węzła przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="d32a2-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="d32a2-147">Wywołaj <xref:System.Xaml.XamlXmlReader.Read%2A> , aby przejść do następnego węzła w strumieniu węzła XAML i powtórz te kroki ponownie.</span><span class="sxs-lookup"><span data-stu-id="d32a2-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="d32a2-148">Strumień węzłów XAML dostarczany przez czytniki XAML usług XAML .NET Framework zawsze zapewnia pełne, głębokie przechodzenie wszystkich możliwych węzłów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="d32a2-149">Typowe techniki kontroli przepływu dla pętli węzła XAML obejmują Definiowanie treści w ramach `while (reader.Read())`i <xref:System.Xaml.XamlXmlReader.NodeType%2A> przełączanie się w każdym punkcie węzła w pętli węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="d32a2-150">Jeśli strumień węzłów znajduje się na końcu pliku, bieżący węzeł ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="d32a2-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="d32a2-151">Najprostsza pętla korzystająca z czytnika i składnika zapisywania jest podobna do poniższego przykładu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="d32a2-152">Ten podstawowy przykład pętli węzła XAML ścieżki ładowania w sposób przezroczysty łączy czytniki XAML i składnik zapisywania XAML, co nie działa inaczej niż w przypadku użycia <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d32a2-153">Jednak ta podstawowa struktura jest następnie rozwinięta w celu zastosowania do scenariusza odczytu lub zapisu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="d32a2-154">Poniżej przedstawiono niektóre możliwe scenariusze:</span><span class="sxs-lookup"><span data-stu-id="d32a2-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="d32a2-155"><xref:System.Xaml.XamlXmlReader.NodeType%2A>Włącz.</span><span class="sxs-lookup"><span data-stu-id="d32a2-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="d32a2-156">Wykonaj różne akcje w zależności od tego, który typ węzła jest odczytywany.</span><span class="sxs-lookup"><span data-stu-id="d32a2-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="d32a2-157">Nie wywołuj <xref:System.Xaml.XamlWriter.WriteNode%2A> we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="d32a2-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="d32a2-158">Tylko w niektórych <xref:System.Xaml.XamlXmlReader.NodeType%2A>przypadkach. <xref:System.Xaml.XamlWriter.WriteNode%2A></span><span class="sxs-lookup"><span data-stu-id="d32a2-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="d32a2-159">W ramach logiki dla określonego typu węzła analizowanie określonych elementów tego węzła i wykonywanie na nich działań.</span><span class="sxs-lookup"><span data-stu-id="d32a2-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="d32a2-160">Można na przykład napisać tylko te obiekty, które pochodzą z określonej przestrzeni nazw XAML, a następnie porzucić lub odłożyć wszystkie obiekty, które nie pochodzą z tej przestrzeni nazw XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="d32a2-161">Można też porzucić lub w inny sposób ponownie przetworzyć wszystkie dyrektywy XAML, które nie są obsługiwane przez system XAML w ramach przetwarzania elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="d32a2-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="d32a2-162">Zdefiniuj niestandardową <xref:System.Xaml.XamlObjectWriter> , `Write*` która zastąpi metody, prawdopodobnie wykonując mapowanie typu, które pomija kontekst schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="d32a2-163">Utwórz, <xref:System.Xaml.XamlXmlReader> aby użyć niedomyślnego kontekstu schematu XAML, tak aby dostosowane różnice w zachowaniu XAML były używane zarówno przez czytnik, jak i moduł zapisujący.</span><span class="sxs-lookup"><span data-stu-id="d32a2-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="d32a2-164">Uzyskiwanie dostępu do języka XAML poza koncepcją pętli węzłów</span><span class="sxs-lookup"><span data-stu-id="d32a2-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="d32a2-165">Istnieją inne sposoby pracy z reprezentacją XAML inną niż pętla węzła XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="d32a2-166">Na przykład może istnieć czytnik XAML, który może odczytać indeksowany węzeł lub w szczególności uzyskuje dostęp do węzłów bezpośrednio przez `x:Name`, przez `x:Uid`lub innych identyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="d32a2-167">Usługi .NET Framework XAML nie zapewniają pełnej implementacji, ale udostępniają sugerowany wzorzec za pomocą usług i typów pomocy technicznej.</span><span class="sxs-lookup"><span data-stu-id="d32a2-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="d32a2-168">Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.IXamlIndexingReader> i <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

> [!TIP]
> <span data-ttu-id="d32a2-169">Firma Microsoft tworzy również wydanie poza pasmem znane jako zestaw narzędzi Microsoft XAML Toolkit.</span><span class="sxs-lookup"><span data-stu-id="d32a2-169">Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit.</span></span> <span data-ttu-id="d32a2-170">Ta wersja poza pasmem nadal jest w fazie wstępnej wersji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-170">This out-of-band release is still in its pre-release stages.</span></span> <span data-ttu-id="d32a2-171">Jeśli jednak chcesz korzystać z składników wersji wstępnej, zestaw narzędzi Microsoft XAML Toolkit udostępnia interesujące zasoby dla narzędzi XAML i analizy statycznej XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-171">However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML.</span></span> <span data-ttu-id="d32a2-172">Zestaw narzędzi Microsoft XAML Toolkit zawiera interfejs API DOM języka XAML, obsługę analizy FxCop oraz kontekst schematu XAML dla technologii Silverlight.</span><span class="sxs-lookup"><span data-stu-id="d32a2-172">The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight.</span></span> <span data-ttu-id="d32a2-173">Aby uzyskać więcej informacji, zobacz [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).</span><span class="sxs-lookup"><span data-stu-id="d32a2-173">For more information, see [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).</span></span>

<a name="working_with_the_current_node"></a>

## <a name="working-with-the-current-node"></a><span data-ttu-id="d32a2-174">Praca z bieżącym węzłem</span><span class="sxs-lookup"><span data-stu-id="d32a2-174">Working with the Current Node</span></span>

<span data-ttu-id="d32a2-175">Większość scenariuszy korzystających z pętli węzłów XAML nie tylko odczytuje węzły.</span><span class="sxs-lookup"><span data-stu-id="d32a2-175">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="d32a2-176">Większość scenariuszy przetwarza bieżące węzły i przekazuj każdy węzeł pojedynczo do wdrożenia <xref:System.Xaml.XamlWriter>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-176">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="d32a2-177">W scenariuszu <xref:System.Xaml.XamlXmlReader> typowej ścieżki ładowania powstaje strumień węzłów XAML; węzły XAML są przetwarzane zgodnie z kontekstem schematu logiki i języka XAML, a węzły są przekazane <xref:System.Xaml.XamlObjectWriter>do.</span><span class="sxs-lookup"><span data-stu-id="d32a2-177">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="d32a2-178">Następnie można zintegrować otrzymany Graf obiektów z aplikacją lub strukturą.</span><span class="sxs-lookup"><span data-stu-id="d32a2-178">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="d32a2-179">W typowym scenariuszu zapisywania ścieżki, <xref:System.Xaml.XamlObjectReader> odczytuje wykres obiektów, poszczególne węzły XAML są przetwarzane, <xref:System.Xaml.XamlXmlWriter> a następnie generuje Zserializowany wynik jako plik tekstowy XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-179">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="d32a2-180">Klucz polega na tym, że zarówno ścieżki, jak i scenariusze obejmują pracę z dokładnie jednym węzłem XAML w danym momencie, a węzły XAML są dostępne do zastosowania w ustandaryzowany sposób, który jest definiowany przez system typów XAML i interfejsów API usług the.NET Framework XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-180">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="d32a2-181">Ramki i zakres</span><span class="sxs-lookup"><span data-stu-id="d32a2-181">Frames and Scope</span></span>

<span data-ttu-id="d32a2-182">Pętla węzła XAML przeprowadzi przez strumień węzłów XAML w liniowy sposób.</span><span class="sxs-lookup"><span data-stu-id="d32a2-182">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="d32a2-183">Strumień węzłów przechodzi do obiektów, do elementów członkowskich, które zawierają inne obiekty itd.</span><span class="sxs-lookup"><span data-stu-id="d32a2-183">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="d32a2-184">Często warto śledzić zakres w strumieniu węzła XAML przez implementację koncepcji ramki i stosu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-184">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="d32a2-185">Jest to szczególnie istotne, jeśli aktywnie dostosowujesz strumień węzłów w trakcie jego pracy.</span><span class="sxs-lookup"><span data-stu-id="d32a2-185">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="d32a2-186">Obsługa ramek i stosu zaimplementowana w ramach logiki pętli węzłów może liczyć `StartObject` (lub `GetObject`) i `EndObject` zakresy w miarę jak najczęociej w strukturze węzłów XAML, jeśli struktura jest uważana z perspektywy modelu DOM.</span><span class="sxs-lookup"><span data-stu-id="d32a2-186">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

<a name="traversing_and_entering_object_nodes"></a>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="d32a2-187">Przechodzenie i wprowadzanie węzłów obiektów</span><span class="sxs-lookup"><span data-stu-id="d32a2-187">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="d32a2-188">Pierwszy węzeł w strumieniu węzła, gdy jest otwarty przez czytnik XAML, jest węzłem startowym obiektu głównego.</span><span class="sxs-lookup"><span data-stu-id="d32a2-188">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="d32a2-189">Według definicji ten obiekt jest zawsze pojedynczym węzłem obiektu i nie ma elementów równorzędnych.</span><span class="sxs-lookup"><span data-stu-id="d32a2-189">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="d32a2-190">W dowolnym rzeczywistym przykładzie XAML, obiekt główny jest zdefiniowany, aby mieć co najmniej jedną właściwość, która zawiera więcej obiektów, i te właściwości mają węzły członkowskie.</span><span class="sxs-lookup"><span data-stu-id="d32a2-190">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="d32a2-191">Węzły elementu członkowskiego mają co najmniej jeden węzeł obiektu lub mogą również kończyć się w węźle wartości.</span><span class="sxs-lookup"><span data-stu-id="d32a2-191">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="d32a2-192">Obiekt główny zwykle definiuje Zakresy nazw WPF XAML, które są składniowo przypisane jako atrybuty w znaczniku tekstowym XAML, ale mapuje do `Namescope` typu węzła w reprezentacji strumienia węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-192">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="d32a2-193">Rozważmy następujący przykład kodu XAML (jest to dowolny kod XAML, ale nie jest on obsługiwany przez istniejące typy w .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="d32a2-193">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="d32a2-194">Załóżmy, że w tym modelu obiektów `FavorCollection` , `List<T>` `Balloon` `Color` i można je przypisać do `Favor`, `Balloon.Color` właściwość jest obsługiwana przez obiekt podobny do definicji WPF `NoiseMaker` `Favor` kolory jako znane nazwy kolorów i `Color` obsługują konwerter typów dla składni atrybutów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-194">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="d32a2-195">Znacznik XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-195">XAML markup</span></span>|<span data-ttu-id="d32a2-196">Otrzymany strumień węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-196">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="d32a2-197">`Namespace`węzeł dla`Party`</span><span class="sxs-lookup"><span data-stu-id="d32a2-197">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="d32a2-198">`StartObject`węzeł dla`Party`</span><span class="sxs-lookup"><span data-stu-id="d32a2-198">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="d32a2-199">`StartMember`węzeł dla`Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="d32a2-199">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="d32a2-200">`StartObject`węzeł dla niejawnego`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="d32a2-200">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="d32a2-201">`StartMember`węzeł właściwości elementów `FavorCollection` niejawnych.</span><span class="sxs-lookup"><span data-stu-id="d32a2-201">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="d32a2-202">`StartObject`węzeł dla`Balloon`</span><span class="sxs-lookup"><span data-stu-id="d32a2-202">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="d32a2-203">`StartMember`węzeł dla`Color`</span><span class="sxs-lookup"><span data-stu-id="d32a2-203">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="d32a2-204">`Value`węzeł dla ciągu wartości atrybutu`"Red"`</span><span class="sxs-lookup"><span data-stu-id="d32a2-204">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="d32a2-205">`EndMember` Aby uzyskać `Color`</span><span class="sxs-lookup"><span data-stu-id="d32a2-205">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="d32a2-206">`StartMember`węzeł dla`HasHelium`</span><span class="sxs-lookup"><span data-stu-id="d32a2-206">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="d32a2-207">`Value`węzeł dla ciągu wartości atrybutu`"True"`</span><span class="sxs-lookup"><span data-stu-id="d32a2-207">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="d32a2-208">`EndMember` Aby uzyskać `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="d32a2-208">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="d32a2-209">`EndObject` Aby uzyskać `Balloon`</span><span class="sxs-lookup"><span data-stu-id="d32a2-209">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="d32a2-210">`StartObject`węzeł dla`NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="d32a2-210">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="d32a2-211">`StartMember`węzeł dla`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="d32a2-211">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="d32a2-212">`Value`węzeł dla ciągu wartości inicjującej`"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="d32a2-212">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="d32a2-213">`EndMember`węzeł dla`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="d32a2-213">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="d32a2-214">`EndObject` Aby uzyskać `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="d32a2-214">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="d32a2-215">`EndMember`węzeł właściwości elementów `FavorCollection` niejawnych.</span><span class="sxs-lookup"><span data-stu-id="d32a2-215">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="d32a2-216">`EndObject`węzeł dla niejawnego`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="d32a2-216">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="d32a2-217">`EndMember` Aby uzyskać `Favors`</span><span class="sxs-lookup"><span data-stu-id="d32a2-217">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="d32a2-218">`EndObject` Aby uzyskać `Party`</span><span class="sxs-lookup"><span data-stu-id="d32a2-218">`EndObject` for `Party`</span></span>|

<span data-ttu-id="d32a2-219">W strumieniu węzła XAML można polegać na następujących zasadach:</span><span class="sxs-lookup"><span data-stu-id="d32a2-219">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="d32a2-220">Jeśli węzeł istnieje, jest dodawany do strumienia bezpośrednio `StartObject` przed zadeklarowaną przestrzenią nazw XAML przy użyciu `xmlns`. `Namespace`</span><span class="sxs-lookup"><span data-stu-id="d32a2-220">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="d32a2-221">Zapoznaj się z poprzednią tabelą i ponownie strumieniem węzła XAML i przykładu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-221">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="d32a2-222">Zwróć uwagę, `StartObject` jak `Namespace` węzły i są wytransponowane w porównaniu z ich pozycjami deklaracji w znacznikach tekstowych.</span><span class="sxs-lookup"><span data-stu-id="d32a2-222">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="d32a2-223">Jest to przedstawiciel zachowania, w którym węzły przestrzeni nazw zawsze pojawiają się przed węzłem, do którego stosują się w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-223">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="d32a2-224">Celem tego projektu jest to, że informacje o przestrzeni nazw są istotne dla autorów obiektów i muszą być znane przed próbą wykonania mapowania obiektów przez moduł zapisujący, a w przeciwnym razie przetworzyć obiekt.</span><span class="sxs-lookup"><span data-stu-id="d32a2-224">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="d32a2-225">Umieszczenie informacji o przestrzeni nazw XAML przed jej zakresem aplikacji w strumieniu sprawia, że jest to prostsze, aby zawsze przetwarzać strumień węzłów w jego przedstawionej kolejności.</span><span class="sxs-lookup"><span data-stu-id="d32a2-225">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="d32a2-226">Ze względu na powyższym zagadnieniem jest co `Namespace` najmniej jeden węzeł, który jest najpierw odczytywany w najbardziej rzeczywistych przypadkach znaczników w przypadku przechodzenia między węzłami od `StartObject` początku, a nie z katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="d32a2-226">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="d32a2-227">Po węźle może następować `Value` `EndObject`,,lubnatychmiast. `StartMember` `StartObject`</span><span class="sxs-lookup"><span data-stu-id="d32a2-227">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="d32a2-228">Nigdy nie następuje od `StartObject`razu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-228">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="d32a2-229">Może następować `StartObject` `EndMember`, `Value`, lub natychmiast. `StartMember`</span><span class="sxs-lookup"><span data-stu-id="d32a2-229">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="d32a2-230">W przypadku elementów członkowskich `GetObject`, w których wartość powinna pochodzić z istniejącej wartości obiektu nadrzędnego, a nie do tworzenia `StartObject` wystąpienia nowej wartości, może wystąpić po nim.</span><span class="sxs-lookup"><span data-stu-id="d32a2-230">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="d32a2-231">Może również następować `Namespace` węzeł, który ma zastosowanie do nadchodzącego `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-231">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="d32a2-232">Nigdy nie następuje od `StartMember`razu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-232">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="d32a2-233">`Value` Węzeł reprezentuje samą wartość. nie ma "wartość końcowa".</span><span class="sxs-lookup"><span data-stu-id="d32a2-233">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="d32a2-234">Może ono następować tylko przez `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-234">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="d32a2-235">Tekst inicjalizacji XAML obiektu, który może być używany przez konstrukcję, nie powoduje, że jest to struktura wartości obiektu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-235">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="d32a2-236">Zamiast tego tworzony jest dedykowany węzeł członkowski dla elementu `_Initialization` Członkowskiego o nazwie.</span><span class="sxs-lookup"><span data-stu-id="d32a2-236">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="d32a2-237">i ten węzeł członkowski zawiera ciąg wartości inicjującej.</span><span class="sxs-lookup"><span data-stu-id="d32a2-237">and that member node contains the initialization value string.</span></span> <span data-ttu-id="d32a2-238">Jeśli istnieje, `_Initialization` jest zawsze pierwszym `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-238">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="d32a2-239">`_Initialization`może być kwalifikowana w niektórych usługach XAML z namescope XAML języka XAML, aby wyjaśnić, że `_Initialization` nie jest właściwością zdefiniowaną w typach zapasowych.</span><span class="sxs-lookup"><span data-stu-id="d32a2-239">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="d32a2-240">Kombinacja elementu członkowskiego reprezentuje ustawienie atrybutu wartości.</span><span class="sxs-lookup"><span data-stu-id="d32a2-240">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="d32a2-241">W efekcie przetwarzania tej wartości może być używany konwerter wartości, a wartość jest zwykłym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="d32a2-241">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="d32a2-242">Nie jest to jednak oceniane do momentu, gdy moduł zapisujący obiektów XAML przetwarza ten strumień węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-242">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="d32a2-243">Moduł zapisujący obiektów XAML posiada wymagany kontekst schematu XAML, mapowanie systemu typów i inne wsparcie wymagane do konwersji wartości.</span><span class="sxs-lookup"><span data-stu-id="d32a2-243">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="d32a2-244">Po węźle może następować `StartMember` węzeł dla kolejnego `EndObject` elementu członkowskiego lub przez węzeł właściciela elementu członkowskiego. `EndMember`</span><span class="sxs-lookup"><span data-stu-id="d32a2-244">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="d32a2-245">Po węźle może następować `EndMember`węzeł. `EndObject`</span><span class="sxs-lookup"><span data-stu-id="d32a2-245">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="d32a2-246">Może również następować `StartObject` węzeł w przypadkach, gdy obiekty są równorzędne w elementach kolekcji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-246">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="d32a2-247">Lub może następować `Namespace` węzeł, który ma zastosowanie do nadchodzącego `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-247">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="d32a2-248">W przypadku unikatowego przypadku zamykającego cały strumień `EndObject` węzła element główny nie następuje po nim; czytnik jest teraz końcem pliku i <xref:System.Xaml.XamlReader.Read%2A> zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-248">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

<a name="value_converters_and_the_xaml_node_stream"></a>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="d32a2-249">Konwertery wartości i strumień węzłów XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-249">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="d32a2-250">Konwerter wartości jest ogólnym terminem dla rozszerzenia znacznika, konwertera typów (w tym serializacji wartości) lub innej dedykowanej klasy, która jest raportowana jako konwerter wartości za pomocą systemu typów XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-250">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="d32a2-251">W strumieniu węzła XAML użycie konwertera typów i użycie rozszerzenia znacznika ma bardzo różne reprezentacje.</span><span class="sxs-lookup"><span data-stu-id="d32a2-251">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="d32a2-252">Konwertery typów w strumieniu węzła XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-252">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="d32a2-253">Ustawiony atrybut, który ostatecznie powoduje użycie konwertera typów, jest raportowany w strumieniu węzła XAML jako wartość elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="d32a2-253">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="d32a2-254">Strumień węzłów XAML nie próbuje utworzyć obiektu wystąpienia konwertera typów i przekazać do niego wartości.</span><span class="sxs-lookup"><span data-stu-id="d32a2-254">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="d32a2-255">Użycie implementacji konwersji konwertera typów wymaga wywołania kontekstu schematu XAML i użycia go do mapowania typów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-255">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="d32a2-256">Nawet określenie, która Klasa konwertera typów powinna być używana do przetwarzania wartości, wymaga pośredniego kontekstu schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-256">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="d32a2-257">W przypadku użycia domyślnego kontekstu schematu języka XAML te informacje są dostępne w systemie typów XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-257">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="d32a2-258">Jeśli potrzebujesz informacji o klasie konwerterów typów na poziomie strumienia węzła XAML przed połączeniem z modułem zapisywania języka XAML, możesz uzyskać go z <xref:System.Xaml.XamlMember> informacji o ustawionym elemencie członkowskim.</span><span class="sxs-lookup"><span data-stu-id="d32a2-258">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="d32a2-259">Ale w przeciwnym razie wprowadzanie konwertera typów powinno być zachowywane w strumieniu węzła XAML jako wartość zwykła, dopóki nie zostaną wykonane pozostałe operacje, które wymagają systemu mapowania typów i kontekstu schematu języka XAML, na przykład utworzenie obiektu przez moduł zapisujący obiektów XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-259">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="d32a2-260">Rozważmy na przykład poniższy konspekt definicji klasy i użycie języka XAML:</span><span class="sxs-lookup"><span data-stu-id="d32a2-260">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="d32a2-261">Tekstowa reprezentacja strumienia węzłów XAML dla tego użycia może być wyrażona w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="d32a2-261">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="d32a2-262">`StartObject`z <xref:System.Xaml.XamlType> reprezentują`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="d32a2-262">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="d32a2-263">`StartMember`z <xref:System.Xaml.XamlMember> reprezentują`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="d32a2-263">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="d32a2-264">`Value`węzeł, z ciągiem tekstowym "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="d32a2-264">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="d32a2-265">`EndMember`prawdopodobny`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="d32a2-265">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="d32a2-266">`EndObject`prawdopodobny`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="d32a2-266">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="d32a2-267">Zwróć uwagę, że w tym strumieniu węzła nie ma wystąpienia konwertera typów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-267">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="d32a2-268">Można jednak uzyskać informacje dotyczące konwertera typów, <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> wywołując <xref:System.Xaml.XamlMember> na `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-268">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="d32a2-269">Jeśli masz prawidłowy kontekst schematu XAML, możesz również wywołać metody konwertera, uzyskując wystąpienie z <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-269">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="d32a2-270">Rozszerzenia znaczników w strumieniu węzła XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-270">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="d32a2-271">Użycie rozszerzenia znacznika jest zgłaszane w strumieniu węzła XAML jako węzeł obiektu w obrębie elementu członkowskiego, gdzie obiekt reprezentuje wystąpienie rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="d32a2-271">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="d32a2-272">W rezultacie użycie rozszerzenia znacznika jest bardziej jawne w reprezentacji strumienia węzłów niż użycie konwertera typów i zawiera więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-272">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="d32a2-273"><xref:System.Xaml.XamlMember>Informacje o rozszerzeniu znacznika mogą nie być dostępne, ponieważ użycie jest sytuacje i różni się w zależności od możliwego przypadku adiustacji; Ta wartość nie jest dedykowana i niejawna dla typu lub elementu członkowskiego, tak jak w przypadku konwerterów typów.</span><span class="sxs-lookup"><span data-stu-id="d32a2-273"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="d32a2-274">Strumień węzłów jest reprezentacją rozszerzeń znaczników jako węzłów obiektów, nawet jeśli użycie rozszerzenia znacznika zostało wykonane w postaci atrybutu w znaczniku tekstu XAML (co jest często w przypadku).</span><span class="sxs-lookup"><span data-stu-id="d32a2-274">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="d32a2-275">Użycie rozszerzeń znaczników, które używały jawnego formularza elementu obiektu, jest traktowane w taki sam sposób.</span><span class="sxs-lookup"><span data-stu-id="d32a2-275">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="d32a2-276">W węźle obiektu rozszerzenia znacznika mogą istnieć elementy należące do tego rozszerzenia znacznika.</span><span class="sxs-lookup"><span data-stu-id="d32a2-276">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="d32a2-277">Reprezentacja strumienia węzłów XAML zachowuje użycie tego rozszerzenia znacznika, niezależnie od tego, czy jest to użycie parametru pozycyjnego, czy użycie z jawnymi nazwanymi parametrami.</span><span class="sxs-lookup"><span data-stu-id="d32a2-277">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="d32a2-278">W przypadku użycia parametru pozycyjnego strumień węzłów XAML zawiera właściwość `_PositionalParameters` zdefiniowaną w języku XAML, która rejestruje użycie.</span><span class="sxs-lookup"><span data-stu-id="d32a2-278">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="d32a2-279">Ta właściwość jest ogólnym <xref:System.Collections.Generic.List%601> z <xref:System.Object> ograniczeniem.</span><span class="sxs-lookup"><span data-stu-id="d32a2-279">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="d32a2-280">Ograniczenie jest obiektem, a nie ciągiem, ponieważ w tym czasie użycie parametru pozycyjnego może zawierać zagnieżdżone użycie rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="d32a2-280">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="d32a2-281">Aby uzyskać dostęp do parametrów pozycyjnych z użycia, można przejść przez listę i użyć indeksatorów dla poszczególnych wartości listy.</span><span class="sxs-lookup"><span data-stu-id="d32a2-281">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="d32a2-282">W przypadku użycia nazwanego parametru każdy nazwany parametr jest reprezentowany jako węzeł elementu członkowskiego tej nazwy w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-282">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="d32a2-283">Wartości elementów członkowskich nie muszą być ciągami, ponieważ może istnieć użycie zagnieżdżonego rozszerzenia znaczników.</span><span class="sxs-lookup"><span data-stu-id="d32a2-283">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="d32a2-284">`ProvideValue`z rozszerzenia znaczników nie jest jeszcze wywoływana.</span><span class="sxs-lookup"><span data-stu-id="d32a2-284">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="d32a2-285">Jest on jednak wywoływany w przypadku podłączenia czytnika XAML i składnika zapisywania XAML, tak `WriteEndObject` że jest wywoływana w węźle rozszerzenia znacznika podczas badania w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-285">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="d32a2-286">Z tego powodu zwykle potrzebny jest ten sam kontekst schematu XAML, który będzie używany w celu utworzenia grafu obiektów na ścieżce ładowania.</span><span class="sxs-lookup"><span data-stu-id="d32a2-286">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="d32a2-287">W przeciwnym razie z dowolnego rozszerzenia znacznika mogą zgłosić wyjątki w tym miejscu, ponieważ nie ma oczekiwanych usług dostępnych. `ProvideValue`</span><span class="sxs-lookup"><span data-stu-id="d32a2-287">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="d32a2-288">Elementy członkowskie zdefiniowane w języku XAML i XML w strumieniu węzła XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-288">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="d32a2-289">Niektóre elementy członkowskie są wprowadzane do strumienia węzłów XAML ze względu na interpretacje i konwencje czytnika XAML, a nie za pomocą <xref:System.Xaml.XamlMember> jawnego wyszukiwania lub konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-289">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="d32a2-290">Często te elementy członkowskie są dyrektywami XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-290">Often, these members are XAML directives.</span></span> <span data-ttu-id="d32a2-291">W niektórych przypadkach jest to czynność odczytywania kodu XAML, który wprowadza dyrektywę do strumienia węzłów XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-291">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="d32a2-292">Inaczej mówiąc, pierwotny wejściowy tekst języka XAML nie określa jawnie dyrektywy member, ale czytnik XAML wstawia dyrektywę w celu spełnienia strukturalnej Konwencji XAML i raportów informacji w strumieniu węzła XAML przed utratą tych informacji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-292">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="d32a2-293">Poniższa lista zawiera informacje o wszystkich przypadkach, w których czytnik XAML powinien wprowadzić dyrektywę elementu członkowskiego języka XAML i jak ten węzeł jest identyfikowany w .NET Framework implementacjach usług XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-293">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>

- <span data-ttu-id="d32a2-294">**Tekst inicjujący dla węzła obiektu:** Nazwa tego węzła `_Initialization`elementu członkowskiego reprezentuje dyrektywę XAML i jest zdefiniowana w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-294">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="d32a2-295">Możesz uzyskać statyczną jednostkę dla tego <xref:System.Xaml.XamlLanguage.Initialization%2A>elementu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-295">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="d32a2-296">**Parametry pozycyjne dla rozszerzenia znacznika:** Nazwa tego węzła elementu członkowskiego jest `_PositionalParameters`zdefiniowana w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-296">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="d32a2-297">Zawsze zawiera ogólną listę obiektów, z których każdy jest parametrem pozycyjnym wstępnie oddzielonym przez dzielenie `,` znaku ograniczającego, jak to podano w wejściowym języku XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-297">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="d32a2-298">Można uzyskać element statyczny dla dyrektywy Position Parameters z <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-298">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="d32a2-299">**Nieznana zawartość:** Nazwa tego węzła elementu członkowskiego to `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-299">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="d32a2-300">Dokładnie mówiąc, to jest <xref:System.Xaml.XamlDirective>i jest zdefiniowany w przestrzeni nazw XAML języka XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-300">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="d32a2-301">Ta dyrektywa jest używana jako wskaźnik kontrolny dla przypadków, gdy element obiektu XAML zawiera zawartość w źródłowym kodzie XAML, ale nie można określić żadnej właściwości zawartości w ramach obecnie dostępnego kontekstu schematu języka XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-301">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="d32a2-302">Ten przypadek można wykryć w strumieniu węzła XAML, sprawdzając elementy członkowskie o nazwie `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-302">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="d32a2-303">Jeśli żadna inna akcja nie zostanie podjęta w strumieniu węzła XAML ścieżki ładowania, <xref:System.Xaml.XamlObjectWriter> domyślnie zostanie `WriteEndObject` podjęta próba `_UnknownContent` podczas napotkania elementu członkowskiego dla dowolnego obiektu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-303">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="d32a2-304">Wartość domyślna <xref:System.Xaml.XamlXmlWriter> nie zgłasza ani nie traktuje elementu członkowskiego jako niejawnego.</span><span class="sxs-lookup"><span data-stu-id="d32a2-304">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="d32a2-305">Można uzyskać statyczną jednostkę dla elementu `_UnknownContent`. <xref:System.Xaml.XamlLanguage.UnknownContent%2A></span><span class="sxs-lookup"><span data-stu-id="d32a2-305">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="d32a2-306">**Właściwość kolekcji kolekcji:** Chociaż typ CLR tworzenia kopii zapasowej klasy kolekcji, która jest używana na potrzeby języka XAML zazwyczaj ma dedykowaną, nazwaną właściwość, która przechowuje elementy kolekcji, ta właściwość nie jest znana systemowi typu XAML przed rozpoczęciem rozpoznawania typów zapasowych.</span><span class="sxs-lookup"><span data-stu-id="d32a2-306">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="d32a2-307">Zamiast tego strumień węzłów XAML wprowadza `Items` symbol zastępczy jako element członkowski typu XAML kolekcji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-307">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="d32a2-308">W .NET Framework, implementacja usług XAML nazwa tej dyrektywy/elementu członkowskiego w strumieniu węzła to `_Items`.</span><span class="sxs-lookup"><span data-stu-id="d32a2-308">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="d32a2-309">Stałą dla tej dyrektywy można uzyskać z <xref:System.Xaml.XamlLanguage.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-309">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="d32a2-310">Należy zauważyć, że strumień węzłów XAML może zawierać Właściwość Items z elementami, które nie są możliwe do przeanalizowania w oparciu o rozpoznawanie typów i kontekst schematu XAML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-310">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="d32a2-311">Na przykład</span><span class="sxs-lookup"><span data-stu-id="d32a2-311">For example,</span></span>

- <span data-ttu-id="d32a2-312">**Elementy członkowskie zdefiniowane w kodzie XML:** Zdefiniowane `xml:base` `base` `space` `lang`przez XML elementyczłonkowskiesąraportowanejakodyrektywyXAMLonazwach,iw.NETFrameworkimplementacjachusługXAML.`xml:space` `xml:lang`</span><span class="sxs-lookup"><span data-stu-id="d32a2-312">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="d32a2-313">Przestrzeń nazw dla tych jest przestrzenią nazw `http://www.w3.org/XML/1998/namespace`XML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-313">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="d32a2-314">Stałe dla każdej z nich można uzyskać od <xref:System.Xaml.XamlLanguage>.</span><span class="sxs-lookup"><span data-stu-id="d32a2-314">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="d32a2-315">Kolejność węzłów</span><span class="sxs-lookup"><span data-stu-id="d32a2-315">Node Order</span></span>

<span data-ttu-id="d32a2-316">W niektórych przypadkach <xref:System.Xaml.XamlXmlReader> zmienia kolejność węzłów XAML w strumieniu węzła XAML, a następnie kolejność wyświetlania węzłów, jeśli są one wyświetlane w znaczniku lub w przypadku przetworzenia jako XML.</span><span class="sxs-lookup"><span data-stu-id="d32a2-316">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="d32a2-317">Jest to realizowane w kolejności, w której <xref:System.Xaml.XamlObjectWriter> węzły mogą przetwarzać strumień węzłów w sposób tylko do przesyłania dalej.</span><span class="sxs-lookup"><span data-stu-id="d32a2-317">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="d32a2-318">W .NET Framework usługach XAML czytnik XAML zmienia kolejność węzłów zamiast opuszczania tego zadania do składnika zapisywania XAML, jako Optymalizacja wydajności dla odbiorców składnika zapisywania obiektów XAML w strumieniu węzła.</span><span class="sxs-lookup"><span data-stu-id="d32a2-318">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="d32a2-319">Niektóre dyrektywy mają na celu dostarczenie większej ilości informacji na potrzeby tworzenia obiektów z elementu obiektu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-319">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="d32a2-320">Dyrektywy te są następujące `Initialization`: `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`,.</span><span class="sxs-lookup"><span data-stu-id="d32a2-320">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="d32a2-321">Czytelnicy XAML usług .NET Framework XAML próbują umieścić te dyrektywy jako pierwsze elementy członkowskie w strumieniu węzła po obiekcie `StartObject`, z powodów opisanych w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="d32a2-321">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="d32a2-322">Zachowanie XamlObjectWriter i kolejność węzłów</span><span class="sxs-lookup"><span data-stu-id="d32a2-322">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="d32a2-323">`StartObject`do elementu <xref:System.Xaml.XamlObjectWriter> nie musi być sygnałem do modułu zapisywania obiektów XAML, aby natychmiast skonstruować wystąpienie obiektu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-323">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="d32a2-324">Język XAML zawiera kilka funkcji języka, które umożliwiają inicjowanie obiektu z dodatkowymi danymi wejściowymi i nie polegają wyłącznie na wywołaniu konstruktora bez parametrów, aby utworzyć obiekt początkowy, a dopiero potem ustawić właściwości.</span><span class="sxs-lookup"><span data-stu-id="d32a2-324">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="d32a2-325">Do tych funkcji należą <xref:System.Windows.Markup.XamlDeferLoadAttribute>:; tekst inicjujący; [x:TypeArguments —](x-typearguments-directive.md); parametry pozycyjne rozszerzenia znaczników; Metody fabryki i skojarzone węzły [x:arguments —](x-arguments-directive.md) (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="d32a2-325">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="d32a2-326">Każdy z tych przypadków opóźnia rzeczywistą konstrukcję obiektu i ze względu na to, że strumień węzłów jest zmieniany, moduł zapisujący obiektów XAML może polegać na zachowaniu rzeczywistego konstruowania wystąpienia, gdy napotkany jest początkowy element członkowski, który nie jest konkretnie konstrukcja Dyrektywa dla tego typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="d32a2-326">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="d32a2-327">GetObject</span><span class="sxs-lookup"><span data-stu-id="d32a2-327">GetObject</span></span>

<span data-ttu-id="d32a2-328">`GetObject`reprezentuje węzeł XAML, gdzie zamiast konstruowania nowego obiektu moduł zapisujący obiektów XAML powinien zamiast niego pobrać wartość właściwości zawierającego obiekt.</span><span class="sxs-lookup"><span data-stu-id="d32a2-328">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="d32a2-329">Typowy przypadek, w którym `GetObject` węzeł jest napotkany w strumieniu węzła XAML jest dla obiektu kolekcji lub obiektu słownika, gdy Właściwość zawierająca jest świadomie tylko do odczytu w modelu obiektów typu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="d32a2-329">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="d32a2-330">W tym scenariuszu kolekcja lub słownik często są tworzone i inicjowane (zwykle puste) przez logikę inicjującą typu będącego właścicielem.</span><span class="sxs-lookup"><span data-stu-id="d32a2-330">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="d32a2-331">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="d32a2-331">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="d32a2-332">Usługi XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-332">XAML Services</span></span>](index.md)
- [<span data-ttu-id="d32a2-333">Przestrzeń nazw XAML</span><span class="sxs-lookup"><span data-stu-id="d32a2-333">XAML Namespaces</span></span>](xaml-namespaces-for-net-framework-xaml-services.md)
