---
title: Omówienie profilowania
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: cf29260c36437aaf679498f648d0fcac5d65f321
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/15/2020
ms.locfileid: "90558332"
---
# <a name="profiling-overview"></a><span data-ttu-id="054f6-102">Omówienie profilowania</span><span class="sxs-lookup"><span data-stu-id="054f6-102">Profiling Overview</span></span>

<span data-ttu-id="054f6-103">Profiler to narzędzie monitorujące wykonywanie innej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="054f6-104">Profiler środowiska uruchomieniowego języka wspólnego (CLR) jest biblioteką dołączaną dynamicznie (DLL), która składa się z funkcji, które odbierają komunikaty i wysyłają komunikaty do programu przy użyciu interfejsu API profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="054f6-105">Profiler DLL jest ładowany przez środowisko CLR w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="054f6-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="054f6-106">Tradycyjne narzędzia profilowania koncentrują się na mierze wykonywania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="054f6-107">Oznacza to, że mierzą czas spędzony na każdej funkcji lub użycie pamięci przez aplikację w czasie.</span><span class="sxs-lookup"><span data-stu-id="054f6-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="054f6-108">Profilowania API jest przeznaczona dla szerszej klasy narzędzi diagnostycznych, takich jak narzędzia do pokrycia kodu, a nawet zaawansowane pomoce debugowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="054f6-109">Te zastosowania mają charakter diagnostyczny.</span><span class="sxs-lookup"><span data-stu-id="054f6-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="054f6-110">Profilowanie API nie tylko mierzy, ale również monitoruje wykonywanie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="054f6-111">Z tego powodu interfejs API profilowania nigdy nie powinien być używany przez samą aplikację, a wykonywanie aplikacji nie powinno zależeć od (lub mieć wpływ) na program profilujący.</span><span class="sxs-lookup"><span data-stu-id="054f6-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="054f6-112">Profilowanie aplikacji CLR wymaga większego wsparcia niż profilowanie skompilowanego kodu maszynowego.</span><span class="sxs-lookup"><span data-stu-id="054f6-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="054f6-113">Wynika to z faktu, że środowisko CLR wprowadza koncepcje, takie jak domeny aplikacji, wyrzucanie elementów bezużytecznych, obsługa wyjątków w trybie just-in-Time (JIT), a także podobne funkcje.</span><span class="sxs-lookup"><span data-stu-id="054f6-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="054f6-114">Konwencjonalne mechanizmy profilowania nie mogą identyfikować i dostarczać użytecznych informacji o tych funkcjach.</span><span class="sxs-lookup"><span data-stu-id="054f6-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="054f6-115">Profiling API nie zapewnia wydajnej informacji przy minimalnym wpływie na wydajność środowiska CLR i profilowanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="054f6-116">Kompilacja JIT w czasie wykonywania zapewnia dobrą możliwość profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="054f6-117">Profilowanie API umożliwia profilerowi zmianę strumienia kodu MSIL w pamięci dla procedury przed skompilowaniem JIT.</span><span class="sxs-lookup"><span data-stu-id="054f6-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="054f6-118">W ten sposób profiler może dynamicznie dodawać kod instrumentacji do określonych procedur, które wymagają dokładniejszego zbadania.</span><span class="sxs-lookup"><span data-stu-id="054f6-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="054f6-119">Chociaż takie podejście jest możliwe w scenariuszach konwencjonalnych, znacznie łatwiej jest zaimplementować środowisko CLR przy użyciu interfejsu API profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="054f6-120">Profilowanie API</span><span class="sxs-lookup"><span data-stu-id="054f6-120">The Profiling API</span></span>

<span data-ttu-id="054f6-121">Zwykle Profiling API jest używany do pisania *profilera kodu*, który jest programem monitorującym wykonywanie zarządzanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-121">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="054f6-122">Profilowania API jest używany przez profiler DLL, który jest ładowany do tego samego procesu co aplikacja, która jest profilowana.</span><span class="sxs-lookup"><span data-stu-id="054f6-122">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="054f6-123">Biblioteka DLL profilera implementuje interfejs wywołania zwrotnego ([ICorProfilerCallback](icorprofilercallback-interface.md) w .NET Framework w wersji 1,0 i 1,1 [ICorProfilerCallback2](icorprofilercallback2-interface.md) w wersji 2,0 i nowszych).</span><span class="sxs-lookup"><span data-stu-id="054f6-123">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="054f6-124">Środowisko CLR wywołuje metody z tego interfejsu w celu powiadomienia profilera zdarzeń w profilowanym procesie.</span><span class="sxs-lookup"><span data-stu-id="054f6-124">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="054f6-125">Profiler może odwoływać się do środowiska uruchomieniowego przy użyciu metod w interfejsach [ICorProfilerInfo](icorprofilerinfo-interface.md) i [ICorProfilerInfo2](icorprofilerinfo2-interface.md) w celu uzyskania informacji o stanie profilowanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-125">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="054f6-126">Tylko część zbierania danych w ramach rozwiązania profilera powinna być uruchomiona w tym samym procesie co profilowana aplikacja.</span><span class="sxs-lookup"><span data-stu-id="054f6-126">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="054f6-127">Wszystkie interfejsy użytkownika i analizy danych należy wykonać w osobnym procesie.</span><span class="sxs-lookup"><span data-stu-id="054f6-127">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="054f6-128">Na poniższej ilustracji pokazano, jak Profiler DLL współdziała z aplikacją, która jest profilowana, oraz środowiskiem CLR.</span><span class="sxs-lookup"><span data-stu-id="054f6-128">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![Zrzut ekranu przedstawiający architekturę profilowania.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="054f6-130">Interfejsy powiadomień</span><span class="sxs-lookup"><span data-stu-id="054f6-130">The Notification Interfaces</span></span>

<span data-ttu-id="054f6-131">[ICorProfilerCallback](icorprofilercallback-interface.md) i [ICorProfilerCallback2](icorprofilercallback2-interface.md) mogą być uznawane za Interfejsy powiadomień.</span><span class="sxs-lookup"><span data-stu-id="054f6-131">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="054f6-132">Te interfejsy składają się z metod takich jak [ClassLoadStarted —](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished —](icorprofilercallback-classloadfinished-method.md)i [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="054f6-132">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="054f6-133">Za każdym razem, gdy środowisko CLR ładuje lub zwalnia klasę, kompiluje funkcję i tak dalej, wywołuje odpowiednią metodę w `ICorProfilerCallback` `ICorProfilerCallback2` interfejsie profilera lub.</span><span class="sxs-lookup"><span data-stu-id="054f6-133">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="054f6-134">Na przykład profiler może mierzyć wydajność kodu przez dwie funkcje powiadomień: [FunctionEnter2](functionenter2-function.md) i [FunctionLeave2](functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="054f6-134">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="054f6-135">Tylko sygnatura czasowa oznacza każde powiadomienie, sumuje wyniki i wyprowadza listę, która wskazuje, które funkcje zużywają najwięcej czasu procesora lub zegarka podczas wykonywania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-135">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="054f6-136">Interfejsy pobierania informacji</span><span class="sxs-lookup"><span data-stu-id="054f6-136">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="054f6-137">Inne główne interfejsy, które są wykorzystywane do profilowania, to [ICorProfilerInfo](icorprofilerinfo-interface.md) i [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="054f6-137">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="054f6-138">Profiler wywołuje te interfejsy zgodnie z potrzebami, aby uzyskać więcej informacji ułatwiających jego analizę.</span><span class="sxs-lookup"><span data-stu-id="054f6-138">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="054f6-139">Na przykład za każdym razem, gdy środowisko CLR wywołuje funkcję [FunctionEnter2](functionenter2-function.md) , dostarcza identyfikator funkcji.</span><span class="sxs-lookup"><span data-stu-id="054f6-139">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="054f6-140">Profiler może uzyskać więcej informacji na temat tej funkcji, wywołując metodę [ICorProfilerInfo2:: GetFunctionInfo2 —](icorprofilerinfo2-getfunctioninfo2-method.md) w celu odnalezienia klasy nadrzędnej funkcji, jej nazwy i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="054f6-140">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="054f6-141">Obsługiwane funkcje</span><span class="sxs-lookup"><span data-stu-id="054f6-141">Supported Features</span></span>

<span data-ttu-id="054f6-142">Profilowanie API zawiera informacje o różnych zdarzeniach i akcjach, które występują w środowisku uruchomieniowym języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="054f6-142">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="054f6-143">Te informacje służą do monitorowania wewnętrznych działań procesów i analizowania wydajności aplikacji .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="054f6-143">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="054f6-144">Interfejs API profilowania pobiera informacje o następujących akcjach i zdarzeniach, które występują w środowisku CLR:</span><span class="sxs-lookup"><span data-stu-id="054f6-144">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="054f6-145">Zdarzenia uruchamiania i zamykania środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="054f6-145">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="054f6-146">Zdarzenia tworzenia i zamykania domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-146">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="054f6-147">Ładowanie i zwalnianie zestawów zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="054f6-147">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="054f6-148">Zdarzenia ładowania i zwalniania modułu.</span><span class="sxs-lookup"><span data-stu-id="054f6-148">Module loading and unloading events.</span></span>

- <span data-ttu-id="054f6-149">Zdarzenia tworzenia i niszczenia tablic wirtualnych COM.</span><span class="sxs-lookup"><span data-stu-id="054f6-149">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="054f6-150">Kompilacja just-in-Time (JIT) i zdarzenia o pochyleniach kodu.</span><span class="sxs-lookup"><span data-stu-id="054f6-150">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="054f6-151">Ładowanie i zwalnianie klas zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="054f6-151">Class loading and unloading events.</span></span>

- <span data-ttu-id="054f6-152">Zdarzenia tworzenia i niszczenia wątków.</span><span class="sxs-lookup"><span data-stu-id="054f6-152">Thread creation and destruction events.</span></span>

- <span data-ttu-id="054f6-153">Zdarzenia wejścia i wyjścia funkcji.</span><span class="sxs-lookup"><span data-stu-id="054f6-153">Function entry and exit events.</span></span>

- <span data-ttu-id="054f6-154">Wyłączenia.</span><span class="sxs-lookup"><span data-stu-id="054f6-154">Exceptions.</span></span>

- <span data-ttu-id="054f6-155">Przejścia między zarządzanym i niezarządzanym wykonaniem kodu.</span><span class="sxs-lookup"><span data-stu-id="054f6-155">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="054f6-156">Przejścia między różnymi kontekstami środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="054f6-156">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="054f6-157">Informacje o zawieszeniu środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="054f6-157">Information about runtime suspensions.</span></span>

- <span data-ttu-id="054f6-158">Informacje na temat sterty pamięci środowiska uruchomieniowego i działania odzyskiwania pamięci.</span><span class="sxs-lookup"><span data-stu-id="054f6-158">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="054f6-159">Profilowanie interfejsu API można wywoływać z dowolnego języka zgodnego z modelem COM (niezarządzanego).</span><span class="sxs-lookup"><span data-stu-id="054f6-159">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="054f6-160">Interfejs API jest wydajny w odniesieniu do zużycia procesora i pamięci.</span><span class="sxs-lookup"><span data-stu-id="054f6-160">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="054f6-161">Profilowanie nie obejmuje zmian profilowanej aplikacji, które są wystarczająco duże, aby powodować błędne wyniki.</span><span class="sxs-lookup"><span data-stu-id="054f6-161">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="054f6-162">Profilowanie interfejsu API jest przydatne zarówno do próbkowania, jak i do prepobierających plików.</span><span class="sxs-lookup"><span data-stu-id="054f6-162">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="054f6-163">*Profiler próbkowania* sprawdza profil przy zwykłych taktach zegara, powiedzmy, co 5 milisekund.</span><span class="sxs-lookup"><span data-stu-id="054f6-163">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="054f6-164">*Profiler bez próbkowania* jest informowany o zdarzeniu synchronicznie z wątkiem powodującym zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="054f6-164">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="054f6-165">Nieobsługiwana funkcja</span><span class="sxs-lookup"><span data-stu-id="054f6-165">Unsupported Functionality</span></span>

<span data-ttu-id="054f6-166">Profilowanie API nie obsługuje następujących funkcji:</span><span class="sxs-lookup"><span data-stu-id="054f6-166">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="054f6-167">Kod niezarządzany, który musi być profilowany przy użyciu konwencjonalnych metod Win32.</span><span class="sxs-lookup"><span data-stu-id="054f6-167">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="054f6-168">Profiler CLR zawiera jednak zdarzenia przejścia, aby określić granice między zarządzanym i niezarządzanym kodem.</span><span class="sxs-lookup"><span data-stu-id="054f6-168">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="054f6-169">Samomodyfikujące się aplikacje, które modyfikują własny kod do celów, takich jak programowanie zorientowane obiektowo.</span><span class="sxs-lookup"><span data-stu-id="054f6-169">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="054f6-170">Sprawdzanie granic, ponieważ interfejs API profilowania nie dostarcza tych informacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-170">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="054f6-171">Środowisko CLR zapewnia wewnętrzną obsługę kontroli granic dla całego kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="054f6-171">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="054f6-172">Zdalne profilowanie, które nie jest obsługiwane z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="054f6-172">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="054f6-173">Zdalne profilowanie rozszerza czas wykonywania.</span><span class="sxs-lookup"><span data-stu-id="054f6-173">Remote profiling extends execution time.</span></span> <span data-ttu-id="054f6-174">W przypadku korzystania z interfejsów profilowania należy zminimalizować czas wykonywania, tak aby nie miały negatywnego wpływ na wyniki profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-174">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="054f6-175">Jest to szczególnie prawdziwe, gdy wydajność wykonywania jest monitorowana.</span><span class="sxs-lookup"><span data-stu-id="054f6-175">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="054f6-176">Jednak profilowanie zdalne nie jest ograniczeniem, gdy interfejsy profilowania są używane do monitorowania użycia pamięci lub do uzyskiwania informacji w czasie wykonywania dotyczących ramek stosu, obiektów i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="054f6-176">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="054f6-177">Profiler kodu CLR musi zarejestrować jeden lub więcej interfejsów wywołania zwrotnego w środowisku uruchomieniowym na komputerze lokalnym, na którym jest uruchomiona profilowana aplikacja.</span><span class="sxs-lookup"><span data-stu-id="054f6-177">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="054f6-178">Pozwala to ograniczyć możliwość tworzenia zdalnego profilera kodu.</span><span class="sxs-lookup"><span data-stu-id="054f6-178">This limits the ability to create a remote code profiler.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="054f6-179">Wątki powiadomień</span><span class="sxs-lookup"><span data-stu-id="054f6-179">Notification Threads</span></span>

<span data-ttu-id="054f6-180">W większości przypadków wątek generujący zdarzenie również wykonuje powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="054f6-180">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="054f6-181">Takie powiadomienia (na przykład [FunctionEnter —](functionenter-function.md) i [FunctionLeave —](functionleave-function.md)) nie muszą podawać jawnych `ThreadID` .</span><span class="sxs-lookup"><span data-stu-id="054f6-181">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="054f6-182">Ponadto profiler może zdecydować się na użycie magazynu lokalnego wątków do przechowywania i aktualizowania jego bloków analitycznych zamiast indeksowania bloków analizy w magazynie globalnym na podstawie wątku, którego to `ThreadID` dotyczy.</span><span class="sxs-lookup"><span data-stu-id="054f6-182">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="054f6-183">Należy zauważyć, że te wywołania zwrotne nie są serializowane.</span><span class="sxs-lookup"><span data-stu-id="054f6-183">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="054f6-184">Użytkownicy muszą chronić swój kod, tworząc bezpieczne dla wątków struktury danych i blokując kod profilera, gdy jest to konieczne, aby uniemożliwić dostęp równoległy z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="054f6-184">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="054f6-185">Z tego względu w niektórych przypadkach można uzyskać nietypową sekwencję wywołań zwrotnych.</span><span class="sxs-lookup"><span data-stu-id="054f6-185">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="054f6-186">Załóżmy na przykład, że aplikacja zarządzana duplikuje dwa wątki wykonujące identyczny kod.</span><span class="sxs-lookup"><span data-stu-id="054f6-186">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="054f6-187">W takim przypadku można odbierać zdarzenie [ICorProfilerCallback:: JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) dla niektórych funkcji z jednego wątku i `FunctionEnter` wywołania zwrotnego z innego wątku przed odebraniem wywołania zwrotnego [ICorProfilerCallback:: JITCompilationFinished —](icorprofilercallback-jitcompilationfinished-method.md) .</span><span class="sxs-lookup"><span data-stu-id="054f6-187">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="054f6-188">W takim przypadku użytkownik otrzyma `FunctionEnter` wywołanie zwrotne dla funkcji, która nie została jeszcze w pełni skompilowana (JIT).</span><span class="sxs-lookup"><span data-stu-id="054f6-188">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="054f6-189">Zabezpieczenia</span><span class="sxs-lookup"><span data-stu-id="054f6-189">Security</span></span>

<span data-ttu-id="054f6-190">Profiler DLL jest niezarządzaną biblioteką DLL, która działa w ramach aparatu wykonywania środowiska uruchomieniowego języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="054f6-190">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="054f6-191">W związku z tym kod w pliku DLL profilera nie podlega ograniczeniom zabezpieczeń dostępu do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="054f6-191">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="054f6-192">Jedyne ograniczenia dotyczące programu Profiler DLL są nakładane przez system operacyjny na użytkownika, który korzysta z profilowanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-192">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="054f6-193">Autorzy profilera powinni podjąć odpowiednie środki ostrożności, aby uniknąć problemów związanych z zabezpieczeniami.</span><span class="sxs-lookup"><span data-stu-id="054f6-193">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="054f6-194">Na przykład podczas instalacji należy dodać do listy kontroli dostępu (ACL) plik DLL programu Profiler, aby złośliwy użytkownik nie mógł go zmodyfikować.</span><span class="sxs-lookup"><span data-stu-id="054f6-194">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="054f6-195">Łączenie kodu zarządzanego i niezarządzanego w profilerze kodu</span><span class="sxs-lookup"><span data-stu-id="054f6-195">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="054f6-196">Niepoprawnie zapisany profiler może spowodować odwołania cykliczne do samego siebie, co skutkuje nieprzewidywalnym zachowaniem.</span><span class="sxs-lookup"><span data-stu-id="054f6-196">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="054f6-197">Przegląd interfejsu API profilowania środowiska CLR może stworzyć wrażenie, że można napisać Profiler zawierający składniki zarządzane i niezarządzane, które wzajemnie się wywołują, za pomocą międzyoperacyjności modelu COM lub wywołań pośrednich.</span><span class="sxs-lookup"><span data-stu-id="054f6-197">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="054f6-198">Chociaż jest to możliwe z perspektywy projektowania, interfejs API profilowania nie obsługuje składników zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="054f6-198">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="054f6-199">Profiler CLR musi być całkowicie niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="054f6-199">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="054f6-200">Próby połączenia kodu zarządzanego i niezarządzanego w profilerze CLR mogą spowodować naruszenie zasad dostępu, niepowodzenia programu lub zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="054f6-200">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="054f6-201">Zarządzane składniki profilera będą wyzwalać zdarzenia z powrotem do niezarządzanych składników, które następnie ponownie wywołają zarządzane składniki, co spowoduje powstanie odwołań cyklicznych.</span><span class="sxs-lookup"><span data-stu-id="054f6-201">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="054f6-202">Jedyna lokalizacja, w której Profiler CLR może bezpiecznie wywoływać kod zarządzany, jest w treści języka pośredniego (MSIL) firmy Microsoft.</span><span class="sxs-lookup"><span data-stu-id="054f6-202">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="054f6-203">Zalecanym sposobem modyfikacji treści MSIL jest użycie metod ponownej kompilacji JIT w interfejsie [ICorProfilerCallback4](icorprofilercallback4-interface.md) .</span><span class="sxs-lookup"><span data-stu-id="054f6-203">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="054f6-204">Aby zmodyfikować MSIL, można również użyć starszych metod Instrumentacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-204">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="054f6-205">Przed ukończeniem kompilacji funkcji just-in-Time (JIT) dla programu profiler może wstawiać wywołania zarządzane w treści MSIL metody, a następnie kompilować ją w trybie JIT (patrz metoda [ICorProfilerInfo:: GetILFunctionBody —](icorprofilerinfo-getilfunctionbody-method.md) ).</span><span class="sxs-lookup"><span data-stu-id="054f6-205">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="054f6-206">Ta technika może zostać pomyślnie użyta w przypadku selektywnego oprzyrządowania kodu zarządzanego lub zbierania danych statystycznych i wydajności dotyczących JIT.</span><span class="sxs-lookup"><span data-stu-id="054f6-206">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="054f6-207">Alternatywnie Profiler kodu może wstawiać natywne haki w treści MSIL każdej funkcji zarządzanej, która wywołuje kod niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="054f6-207">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="054f6-208">Ta technika może służyć do Instrumentacji i pokrycia.</span><span class="sxs-lookup"><span data-stu-id="054f6-208">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="054f6-209">Na przykład Profiler kodu może wstawić punkty zaczepienia Instrumentacji po każdym bloku MSIL, aby upewnić się, że blok został wykonany.</span><span class="sxs-lookup"><span data-stu-id="054f6-209">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="054f6-210">Modyfikacja treści MSIL metody jest bardzo delikatną operacją i istnieje wiele czynników, które należy wziąć pod uwagę.</span><span class="sxs-lookup"><span data-stu-id="054f6-210">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="054f6-211">Profilowanie kodu niezarządzanego</span><span class="sxs-lookup"><span data-stu-id="054f6-211">Profiling Unmanaged Code</span></span>

<span data-ttu-id="054f6-212">Interfejs API profilowania środowiska uruchomieniowego języka wspólnego (CLR) zapewnia minimalną obsługę profilowania kodu niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="054f6-212">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="054f6-213">Dostępne są następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="054f6-213">The following functionality is provided:</span></span>

- <span data-ttu-id="054f6-214">Wyliczanie łańcuchów stosu.</span><span class="sxs-lookup"><span data-stu-id="054f6-214">Enumeration of stack chains.</span></span> <span data-ttu-id="054f6-215">Ta funkcja umożliwia profilerowi kodu określenie granicy między kodem zarządzanym i niezarządzanym kodem.</span><span class="sxs-lookup"><span data-stu-id="054f6-215">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="054f6-216">Określanie, czy łańcuch stosu odpowiada kodowi zarządzanemu czy kodowi natywnemu.</span><span class="sxs-lookup"><span data-stu-id="054f6-216">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="054f6-217">W .NET Framework wersje 1,0 i 1,1 te metody są dostępne za pomocą podzestawu w procesie interfejsu API debugowania środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="054f6-217">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="054f6-218">Są one zdefiniowane w pliku CorDebug. idl.</span><span class="sxs-lookup"><span data-stu-id="054f6-218">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="054f6-219">W .NET Framework 2,0 i nowszych można użyć metody [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) dla tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="054f6-219">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="054f6-220">Przy użyciu modelu COM</span><span class="sxs-lookup"><span data-stu-id="054f6-220">Using COM</span></span>

<span data-ttu-id="054f6-221">Chociaż interfejsy profilowania są zdefiniowane jako interfejsy COM, środowisko uruchomieniowe języka wspólnego (CLR) nie inicjuje w rzeczywistości modelu COM, aby używać tych interfejsów.</span><span class="sxs-lookup"><span data-stu-id="054f6-221">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="054f6-222">Przyczyną jest uniknięcie konieczności ustawiania modelu wątkowości przy użyciu funkcji [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) , zanim aplikacja zarządzana będzie mogła określić odpowiedni model wątkowości.</span><span class="sxs-lookup"><span data-stu-id="054f6-222">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="054f6-223">Podobnie Profiler nie powinien wywołać `CoInitialize` , ponieważ może wybrać model wątkowości, który jest niezgodny z profilowaną aplikacją i może spowodować niepowodzenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="054f6-223">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="054f6-224">Stosy wywołań</span><span class="sxs-lookup"><span data-stu-id="054f6-224">Call Stacks</span></span>

<span data-ttu-id="054f6-225">Profilowanie interfejsu API zapewnia dwa sposoby uzyskiwania stosów wywołań: metodę migawki stosu, która umożliwia zbieranie rozrzedzonych stosów wywołań i metodę stosu w tle, która śledzi stos wywołań w każdym momencie.</span><span class="sxs-lookup"><span data-stu-id="054f6-225">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="054f6-226">Migawka stosu</span><span class="sxs-lookup"><span data-stu-id="054f6-226">Stack Snapshot</span></span>

<span data-ttu-id="054f6-227">Migawka stosu jest śladem stosu wątku na chwilę.</span><span class="sxs-lookup"><span data-stu-id="054f6-227">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="054f6-228">Profiling API obsługuje śledzenie funkcji zarządzanych na stosie, ale pozostawia śledzenie niezarządzanych funkcji do analizatora stosu modułu profilera.</span><span class="sxs-lookup"><span data-stu-id="054f6-228">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="054f6-229">Aby uzyskać więcej informacji na temat sposobu programowania profilera w celu przechodzenia do zarządzanych stosów, zobacz metodę [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) w tym zestawie dokumentacji i [stosu profilera w .NET Framework 2,0: podstawy i więcej](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="054f6-229">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="054f6-230">Stos cieni</span><span class="sxs-lookup"><span data-stu-id="054f6-230">Shadow Stack</span></span>

<span data-ttu-id="054f6-231">Użycie metody Snapshot jest zbyt często możliwe, aby szybko utworzyć problem z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="054f6-231">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="054f6-232">Jeśli chcesz, aby ślady stosu były często wykonywane, profiler powinien zamiast tego kompilować stos w tle za pomocą wywołań zwrotnych wyjątków [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md)i [ICorProfilerCallback2](icorprofilercallback2-interface.md) .</span><span class="sxs-lookup"><span data-stu-id="054f6-232">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="054f6-233">Stos cieni jest zawsze aktualny i może być szybko kopiowany do magazynu, gdy wymagana jest migawka stosu.</span><span class="sxs-lookup"><span data-stu-id="054f6-233">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="054f6-234">Stos cienia może uzyskać argumenty funkcji, wartości zwracane i informacje o ogólnych wystąpieniach.</span><span class="sxs-lookup"><span data-stu-id="054f6-234">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="054f6-235">Te informacje są dostępne tylko za pomocą stosu w tle i mogą być uzyskiwane, gdy sterowanie jest przekazywane do funkcji.</span><span class="sxs-lookup"><span data-stu-id="054f6-235">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="054f6-236">Jednak te informacje mogą być niedostępne w przyszłości podczas uruchamiania funkcji.</span><span class="sxs-lookup"><span data-stu-id="054f6-236">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="054f6-237">Wywołania zwrotne i głębokość stosu</span><span class="sxs-lookup"><span data-stu-id="054f6-237">Callbacks and Stack Depth</span></span>

<span data-ttu-id="054f6-238">Wywołania zwrotne profilera mogą być emitowane w bardzo ograniczonych warunkach stosu, a przepełnienie stosu w wywołaniu wywołania zwrotnego profilera będzie prowadzić do natychmiastowego zakończenia procesu.</span><span class="sxs-lookup"><span data-stu-id="054f6-238">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="054f6-239">Profiler powinien w odpowiedzi na wywołania zwrotne używać możliwie najmniejszego stosu.</span><span class="sxs-lookup"><span data-stu-id="054f6-239">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="054f6-240">Jeśli profiler jest przeznaczony do użycia w przypadku procesów, które są niezawodne przed przepełnieniem stosu, profiler powinien również unikać wyzwalania przepełnienia stosu.</span><span class="sxs-lookup"><span data-stu-id="054f6-240">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="054f6-241">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="054f6-241">Related Topics</span></span>

|<span data-ttu-id="054f6-242">Tytuł</span><span class="sxs-lookup"><span data-stu-id="054f6-242">Title</span></span>|<span data-ttu-id="054f6-243">Opis</span><span class="sxs-lookup"><span data-stu-id="054f6-243">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="054f6-244">Konfigurowanie środowiska profilowania</span><span class="sxs-lookup"><span data-stu-id="054f6-244">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="054f6-245">Wyjaśnia, jak zainicjować profiler, ustawić powiadomienia o zdarzeniach i profilować usługę systemu Windows.</span><span class="sxs-lookup"><span data-stu-id="054f6-245">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="054f6-246">Interfejsy profilowania</span><span class="sxs-lookup"><span data-stu-id="054f6-246">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="054f6-247">Opisuje interfejsy niezarządzane używane przez interfejs API profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-247">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="054f6-248">Profilowanie statycznych funkcji globalnych</span><span class="sxs-lookup"><span data-stu-id="054f6-248">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="054f6-249">Opisuje niezarządzane globalne funkcje statyczne, które są używane przez interfejs API profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-249">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="054f6-250">Profilowanie — Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="054f6-250">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="054f6-251">Opisuje niezarządzane wyliczenia, które są używane przez interfejs API profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-251">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="054f6-252">Profiling — Struktury</span><span class="sxs-lookup"><span data-stu-id="054f6-252">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="054f6-253">Opisuje struktury niezarządzane używane przez interfejs API profilowania.</span><span class="sxs-lookup"><span data-stu-id="054f6-253">Describes the unmanaged structures that the profiling API uses.</span></span>|
