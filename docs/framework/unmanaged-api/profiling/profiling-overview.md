---
title: Omówienie profilowania
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 6dbf36cec1bcd2ec1e96d57a889ddd9d9baef269
ms.sourcegitcommit: d6e27023aeaffc4b5a3cb4b88685018d6284ada4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/09/2019
ms.locfileid: "67663890"
---
# <a name="profiling-overview"></a><span data-ttu-id="3a371-102">Omówienie profilowania</span><span class="sxs-lookup"><span data-stu-id="3a371-102">Profiling Overview</span></span>

<a name="top"></a> <span data-ttu-id="3a371-103">Program profilujący to narzędzie, które monitoruje wykonanie innej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="3a371-104">Typowe profiler środowiska uruchomieniowego (języka wspólnego CLR) języka jest biblioteki dołączanej dynamicznie (DLL), która składa się z funkcji, które odbierają wiadomości ze i wysyłanie komunikatów do środowiska CLR przy użyciu profilowania interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="3a371-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="3a371-105">Program profilujący DLL jest ładowany przez środowisko CLR w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="3a371-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="3a371-106">Tradycyjne narzędzie profilowania skupia się na pomiarze wykonania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="3a371-107">To znaczy służą do pomiaru czasu spędzonego w każdej funkcji lub użycia pamięci przez aplikację wraz z upływem czasu.</span><span class="sxs-lookup"><span data-stu-id="3a371-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="3a371-108">Profilowania API jest przeznaczone dla szerszej klasy narzędzi diagnostycznych, takich jak narzędzia pokrycia kodu i nawet zaawansowane debugowanie pomocne.</span><span class="sxs-lookup"><span data-stu-id="3a371-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="3a371-109">Te zastosowania są wszystkie diagnostyczne w naturze.</span><span class="sxs-lookup"><span data-stu-id="3a371-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="3a371-110">Profilowanie API nie tylko mierzy, ale również monitoruje wykonywanie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="3a371-111">Z tego powodu, profilowanie API nie mogą być używane przez samą aplikację, a wykonywanie aplikacji nie powinna zależeć od (lub doświadczyć działania) programu profilującego.</span><span class="sxs-lookup"><span data-stu-id="3a371-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="3a371-112">Profilowanie aplikacji CLR wymaga obsługi więcej obsługi niż profilowanie konwencjonalnie skompilowanego kodu maszynowego.</span><span class="sxs-lookup"><span data-stu-id="3a371-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="3a371-113">Jest to spowodowane CLR wprowadza takie pojęcia jak domeny aplikacji, wyrzucanie elementów bezużytecznych zarządzane obsługę wyjątków, just-in-time (JIT) kompilacja kodu (Konwersja języka Microsoft intermediate language lub MSIL kod do kodu macierzystego komputera) i podobnych zastosowaniach funkcje.</span><span class="sxs-lookup"><span data-stu-id="3a371-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="3a371-114">Mechanizmy konwencjonalnego profilowania nie można zidentyfikować lub dostarczyć przydatnych informacji o tych funkcjach.</span><span class="sxs-lookup"><span data-stu-id="3a371-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="3a371-115">Profilowanie API dostarcza brakujących informacji skutecznie, z minimalnym wpływem na wydajność środowiska CLR i profilowanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="3a371-116">Kompilacja JIT w czasie wykonywania zapewnia dobre możliwości profilowania.</span><span class="sxs-lookup"><span data-stu-id="3a371-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="3a371-117">Profilowania API umożliwia programowi profilującemu zmianę strumienia kodu MSIL w pamięci dla procedury, zanim zostanie skompilowany JIT.</span><span class="sxs-lookup"><span data-stu-id="3a371-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="3a371-118">W ten sposób program profilujący może dynamicznie dodawać kod Instrumentacji do szczególnych procedur, które wymagają głębszego zbadania.</span><span class="sxs-lookup"><span data-stu-id="3a371-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="3a371-119">Chociaż to podejście jest możliwe w scenariuszach konwencjonalnych, jest znacznie łatwiejsze do wdrożenia dla środowiska CLR przy użyciu profilowania interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="3a371-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

<span data-ttu-id="3a371-120">To omówienie składa się z następujących sekcji:</span><span class="sxs-lookup"><span data-stu-id="3a371-120">This overview consists of the following sections:</span></span>

- [<span data-ttu-id="3a371-121">API profilowania</span><span class="sxs-lookup"><span data-stu-id="3a371-121">The Profiling API</span></span>](#profiling_api)

- [<span data-ttu-id="3a371-122">Obsługiwane funkcje</span><span class="sxs-lookup"><span data-stu-id="3a371-122">Supported Features</span></span>](#support)

- [<span data-ttu-id="3a371-123">Wątki powiadomień</span><span class="sxs-lookup"><span data-stu-id="3a371-123">Notification Threads</span></span>](#notification_threads)

- [<span data-ttu-id="3a371-124">Zabezpieczenia</span><span class="sxs-lookup"><span data-stu-id="3a371-124">Security</span></span>](#security)

- [<span data-ttu-id="3a371-125">Łączenie kodu zarządzanego i niezarządzanego w Profiler kodu</span><span class="sxs-lookup"><span data-stu-id="3a371-125">Combining Managed and Unmanaged Code in a Code Profiler</span></span>](#combining_managed_unmanaged)

- [<span data-ttu-id="3a371-126">Profilowanie niezarządzanego kodu</span><span class="sxs-lookup"><span data-stu-id="3a371-126">Profiling Unmanaged Code</span></span>](#unmanaged)

- [<span data-ttu-id="3a371-127">Korzystając z modelu COM</span><span class="sxs-lookup"><span data-stu-id="3a371-127">Using COM</span></span>](#com)

- [<span data-ttu-id="3a371-128">Stosy wywołań</span><span class="sxs-lookup"><span data-stu-id="3a371-128">Call stacks</span></span>](#call_stacks)

- [<span data-ttu-id="3a371-129">Wywołania zwrotne i głębokość stosu</span><span class="sxs-lookup"><span data-stu-id="3a371-129">Callbacks and Stack Depth</span></span>](#callbacks)

- [<span data-ttu-id="3a371-130">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="3a371-130">Related Topics</span></span>](#related_topics)

<a name="profiling_api"></a>

## <a name="the-profiling-api"></a><span data-ttu-id="3a371-131">API profilowania</span><span class="sxs-lookup"><span data-stu-id="3a371-131">The Profiling API</span></span>

<span data-ttu-id="3a371-132">Zazwyczaj profilowania API jest używany do zapisywania *program profilujący*, czyli program, który monitoruje wykonanie zarządzanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-132">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="3a371-133">Profilowania API jest używany przez program profilujący DLL, który jest ładowany do tego samego procesu co aplikacja, która jest profilowana.</span><span class="sxs-lookup"><span data-stu-id="3a371-133">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="3a371-134">Program profilujący biblioteki DLL implementuje interfejs wywołania zwrotnego ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) w .NET Framework w wersji 1.0 i 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) w wersji 2.0 lub nowszej).</span><span class="sxs-lookup"><span data-stu-id="3a371-134">The profiler DLL implements a callback interface ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="3a371-135">Środowisko CLR wywołania metody, w tym interfejsie powiadomić profiler wydarzeń w profilowanym procesie.</span><span class="sxs-lookup"><span data-stu-id="3a371-135">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="3a371-136">Program profilujący wywołania zwrotnego w czasie wykonywania przy przy użyciu metod w [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) i [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfejsy w celu uzyskania informacji na temat stanu profilowanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-136">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="3a371-137">Tylko część gromadzenia danych rozwiązania profilera powinna być uruchomiona w tym samym procesie co profilowana aplikacja.</span><span class="sxs-lookup"><span data-stu-id="3a371-137">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="3a371-138">Wszystkich użytkowników interfejsu i przeprowadzać analizę danych powinno być przeprowadzone w oddzielnym procesie.</span><span class="sxs-lookup"><span data-stu-id="3a371-138">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="3a371-139">Poniższa ilustracja przedstawia, jak profiler DLL współdziała z aplikacji, która jest profilowana i środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="3a371-139">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![Zrzut ekranu pokazujący architekturę profilowania.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="3a371-141">Interfejsy powiadomień</span><span class="sxs-lookup"><span data-stu-id="3a371-141">The Notification Interfaces</span></span>

<span data-ttu-id="3a371-142">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) i [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) jest uznawana za interfejsy powiadomień.</span><span class="sxs-lookup"><span data-stu-id="3a371-142">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="3a371-143">Interfejsy te składają się z metody takie jak [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), i [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a371-143">These interfaces consist of methods such as [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="3a371-144">Każdorazowo CLR ładuje i zwalnia klasy, kompiluje funkcję i itd., wywołuje odpowiedniej metody w profilerze `ICorProfilerCallback` lub `ICorProfilerCallback2` interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3a371-144">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="3a371-145">Na przykład program profilujący może zmierzyć wydajność kodu przez dwie funkcje powiadomień: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) i [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="3a371-145">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) and [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span></span> <span data-ttu-id="3a371-146">Aplikacja sygnatury czasowe Każde powiadomienie, gromadzi wyniki i wyświetla listę, która wskazuje, które funkcje używane najwięcej procesora CPU lub zgodnie z zegarem czasu podczas wykonywania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-146">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="3a371-147">Interfejsy wyszukiwania informacji</span><span class="sxs-lookup"><span data-stu-id="3a371-147">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="3a371-148">Inne główny interfejsy, zaangażowany w profilowanie to [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) i [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="3a371-148">The other main interfaces involved in profiling are [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="3a371-149">Program profilujący wywołuje te interfejsy zgodnie z wymaganiami, aby uzyskać więcej informacji na temat ich analizy.</span><span class="sxs-lookup"><span data-stu-id="3a371-149">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="3a371-150">Na przykład, gdy środowisko CLR wywołuje [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) funkcji, dostarcza mu identyfikator funkcji.</span><span class="sxs-lookup"><span data-stu-id="3a371-150">For example, whenever the CLR calls the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="3a371-151">Program profilujący może uzyskać więcej informacji na temat tej funkcji przez wywołanie metody [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) metody umożliwiającej odnajdowanie funkcji klasy nadrzędnej, jej nazwa i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="3a371-151">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

[<span data-ttu-id="3a371-152">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-152">Back to top</span></span>](#top)

<a name="support"></a>

## <a name="supported-features"></a><span data-ttu-id="3a371-153">Obsługiwane funkcje</span><span class="sxs-lookup"><span data-stu-id="3a371-153">Supported Features</span></span>

<span data-ttu-id="3a371-154">Profilowania API zawiera informacje o różnych zdarzeniach i działaniach, które występują w środowisko uruchomieniowe języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="3a371-154">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="3a371-155">Te informacje służą do monitorowania wewnętrznego działania procesów i analizowania wydajność aplikacji .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3a371-155">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="3a371-156">API profilowania pobiera informacje o następujących działaniach i zdarzeniach, które wystąpiły w CLR:</span><span class="sxs-lookup"><span data-stu-id="3a371-156">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="3a371-157">Zdarzenia uruchamiania i zamykania CLR.</span><span class="sxs-lookup"><span data-stu-id="3a371-157">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="3a371-158">Zdarzenia tworzenia i zamykania aplikacji domeny.</span><span class="sxs-lookup"><span data-stu-id="3a371-158">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="3a371-159">Ładowanie zestawów i wyładowywanie zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="3a371-159">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="3a371-160">Ładowanie modułów i wyładowywanie zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="3a371-160">Module loading and unloading events.</span></span>

- <span data-ttu-id="3a371-161">Zdarzenia tworzenia i niszczenia COM vtable.</span><span class="sxs-lookup"><span data-stu-id="3a371-161">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="3a371-162">Just-in-time (JIT) kompilacja i zdarzenia poziomowania kodu.</span><span class="sxs-lookup"><span data-stu-id="3a371-162">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="3a371-163">Klasa ładowania i wyładowywanie zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="3a371-163">Class loading and unloading events.</span></span>

- <span data-ttu-id="3a371-164">Wątek zdarzenia tworzenia i niszczenia.</span><span class="sxs-lookup"><span data-stu-id="3a371-164">Thread creation and destruction events.</span></span>

- <span data-ttu-id="3a371-165">Zdarzenia wejścia i wyjścia funkcji.</span><span class="sxs-lookup"><span data-stu-id="3a371-165">Function entry and exit events.</span></span>

- <span data-ttu-id="3a371-166">Liczba wyjątków.</span><span class="sxs-lookup"><span data-stu-id="3a371-166">Exceptions.</span></span>

- <span data-ttu-id="3a371-167">Przejścia między wykonywaniem kodu zarządzanego i niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="3a371-167">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="3a371-168">Przejścia między środowiskiem uruchomieniowym w różnych kontekstach.</span><span class="sxs-lookup"><span data-stu-id="3a371-168">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="3a371-169">Informacje o zawieszeniach środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="3a371-169">Information about runtime suspensions.</span></span>

- <span data-ttu-id="3a371-170">Informacje na temat środowiska uruchomieniowego pamięci sterty i wyrzucania elementów kolekcji działania.</span><span class="sxs-lookup"><span data-stu-id="3a371-170">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="3a371-171">Profilowania API można wywołać z dowolnego języka zgodnego z COM. (niezarządzany).</span><span class="sxs-lookup"><span data-stu-id="3a371-171">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="3a371-172">Interfejs API jest skuteczny w odniesieniu do zużycia procesora CPU i pamięci.</span><span class="sxs-lookup"><span data-stu-id="3a371-172">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="3a371-173">Profilowania może obejmować zmian profilowanej aplikacji, które są na tyle znaczące spowodować wyświetlenie nieprawdziwych wyników.</span><span class="sxs-lookup"><span data-stu-id="3a371-173">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="3a371-174">Profilowania API jest przydatne do pobierania próbek i -pobierania próbek profilowania.</span><span class="sxs-lookup"><span data-stu-id="3a371-174">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="3a371-175">A *próbkowania profilera* przeprowadza inspekcję profilu przy regularnych taktach zegara, powiedz, co 5 milisekund.</span><span class="sxs-lookup"><span data-stu-id="3a371-175">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="3a371-176">A *profilujący niezwiązany* jest informowany o zdarzeniu synchronicznie z wątkiem, który powoduje to zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="3a371-176">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="3a371-177">Nieobsługiwana funkcja</span><span class="sxs-lookup"><span data-stu-id="3a371-177">Unsupported Functionality</span></span>

<span data-ttu-id="3a371-178">Profilowanie API nie obsługuje następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="3a371-178">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="3a371-179">Niezarządzany kod, który musi być profilowany za pomocą konwencjonalnych metod Win32.</span><span class="sxs-lookup"><span data-stu-id="3a371-179">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="3a371-180">Jednakże program profilujący CLR zawiera zdarzenia przejścia do określenia granic między kodem zarządzanym i niezarządzanym.</span><span class="sxs-lookup"><span data-stu-id="3a371-180">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="3a371-181">Własne modyfikowanie aplikacji, które modyfikują swój własny kod do celów takich jak programowanie zorientowanego na aspekt.</span><span class="sxs-lookup"><span data-stu-id="3a371-181">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="3a371-182">Sprawdzanie granic, ponieważ profilowanie API nie dostarcza tych informacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-182">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="3a371-183">Środowisko CLR zapewnia wsparcie wewnętrznej sprawdzanie wszystkich zarządzanych kodów granic.</span><span class="sxs-lookup"><span data-stu-id="3a371-183">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="3a371-184">Zdalne profilowanie, który nie jest obsługiwany w następujących sytuacjach:</span><span class="sxs-lookup"><span data-stu-id="3a371-184">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="3a371-185">Zdalne profilowanie rozszerza czas wykonania.</span><span class="sxs-lookup"><span data-stu-id="3a371-185">Remote profiling extends execution time.</span></span> <span data-ttu-id="3a371-186">Korzystając z interfejsów profilowania, można zminimalizować czas wykonywania, aby wyniki profilowania nie będą nadmiernie zmieniane.</span><span class="sxs-lookup"><span data-stu-id="3a371-186">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="3a371-187">Jest to szczególnie istotne w przypadku, gdy wykonanie wydajności jest monitorowane.</span><span class="sxs-lookup"><span data-stu-id="3a371-187">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="3a371-188">Jednakże, zdalne profilowanie nie jest to ograniczenie, gdy interfejsy profilujące są używane do monitorowania wykorzystania pamięci lub uzyskać informacje czasu wykonywania ramki stosu, obiektów i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="3a371-188">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="3a371-189">Profiler kodu CLR musi zarejestrować jeden lub więcej interfejsów wywołania zwrotnego do aparatu plików wykonywalnych na komputerze lokalnym, na którym jest uruchomiona profilowana aplikacja.</span><span class="sxs-lookup"><span data-stu-id="3a371-189">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="3a371-190">Ogranicza to możliwość tworzenia profilerów kodu zdalnego.</span><span class="sxs-lookup"><span data-stu-id="3a371-190">This limits the ability to create a remote code profiler.</span></span>

- <span data-ttu-id="3a371-191">Profilowanie w środowiskach produkcyjnych z wymogami wysokiej dostępności.</span><span class="sxs-lookup"><span data-stu-id="3a371-191">Profiling in production environments with high-availability requirements.</span></span> <span data-ttu-id="3a371-192">API profilowania zostało utworzone do obsługi rozwoju diagnostycznego.</span><span class="sxs-lookup"><span data-stu-id="3a371-192">The profiling API was created to support development-time diagnostics.</span></span> <span data-ttu-id="3a371-193">Nie przeszedł rygorystycznych testów wymaganych do obsługi środowisk produkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="3a371-193">It has not undergone the rigorous testing required to support production environments.</span></span>

[<span data-ttu-id="3a371-194">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-194">Back to top</span></span>](#top)

<a name="notification_threads"></a>

## <a name="notification-threads"></a><span data-ttu-id="3a371-195">Wątki powiadomień</span><span class="sxs-lookup"><span data-stu-id="3a371-195">Notification Threads</span></span>

<span data-ttu-id="3a371-196">W większości przypadków wątek, który generuje zdarzenie także wykonuje powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="3a371-196">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="3a371-197">Takie powiadomienia (na przykład [functionenter —](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) i [functionleave —](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) nie muszą podawać jawnie `ThreadID`.</span><span class="sxs-lookup"><span data-stu-id="3a371-197">Such notifications (for example, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) and [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="3a371-198">Program profilujący może też użyć magazynu wątków lokalnych do przechowywania i aktualizowania swoich bloków analizy zamiast indeksowania bloków analizy w globalnej pamięci masowej, na podstawie `ThreadID` wątku, do których to dotyczy.</span><span class="sxs-lookup"><span data-stu-id="3a371-198">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="3a371-199">Należy pamiętać, że te wywołania zwrotne nie są serializowane.</span><span class="sxs-lookup"><span data-stu-id="3a371-199">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="3a371-200">Dlatego też należy chronić swój kod poprzez tworzenie struktur danych wątków oraz blokowanie kodu profilera, gdy jest to konieczne w celu zapobieżenia dostępowi równolegle z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="3a371-200">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="3a371-201">W związku z tym w niektórych przypadkach można otrzymać nietypowe sekwencję wywołań zwrotnych.</span><span class="sxs-lookup"><span data-stu-id="3a371-201">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="3a371-202">Na przykład załóżmy, że aplikację zarządzaną namnaża dwa wątki, które realizują ten sam kod.</span><span class="sxs-lookup"><span data-stu-id="3a371-202">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="3a371-203">W tym przypadku jest możliwe, aby otrzymać [icorprofilercallback::jitcompilationstarted —](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) zdarzeń dla niektórych funkcji z jednego wątku i `FunctionEnter` wywołania zwrotnego z innego wątku przed otrzymaniem [ Icorprofilercallback::jitcompilationfinished —](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="3a371-203">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="3a371-204">W takim przypadku użytkownik otrzyma `FunctionEnter` wywołania zwrotnego dla funkcji, która może nie zostać w pełni just-in-time (JIT) jeszcze skompilowany.</span><span class="sxs-lookup"><span data-stu-id="3a371-204">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

[<span data-ttu-id="3a371-205">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-205">Back to top</span></span>](#top)

<a name="security"></a>

## <a name="security"></a><span data-ttu-id="3a371-206">Zabezpieczenia</span><span class="sxs-lookup"><span data-stu-id="3a371-206">Security</span></span>

<span data-ttu-id="3a371-207">Program profilujący DLL jest niezarządzaną biblioteką DLL, która działa jako część aparat wykonywania środowiska uruchomieniowego języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="3a371-207">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="3a371-208">W rezultacie kodu w programie profilującym DLL nie jest przedmiotem ograniczeń zarządzanego zabezpieczenia dostępu kodu.</span><span class="sxs-lookup"><span data-stu-id="3a371-208">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="3a371-209">Jedynymi ograniczeniami profilera biblioteki DLL są ograniczenia nałożone przez system operacyjny na użytkownika, który uruchomił profilowaną aplikację.</span><span class="sxs-lookup"><span data-stu-id="3a371-209">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="3a371-210">Autorzy Profiler należy podjąć odpowiednie środki ostrożności, aby uniknąć problemów związanych z zabezpieczeniami.</span><span class="sxs-lookup"><span data-stu-id="3a371-210">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="3a371-211">Na przykład podczas instalacji, program profilujący DLL powinien można dodać do listy kontroli dostępu (ACL), aby złośliwy użytkownik nie mógł go modyfikować.</span><span class="sxs-lookup"><span data-stu-id="3a371-211">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

[<span data-ttu-id="3a371-212">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-212">Back to top</span></span>](#top)

<a name="combining_managed_unmanaged"></a>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="3a371-213">Łączenie kodu zarządzanego i niezarządzanego w Profiler kodu</span><span class="sxs-lookup"><span data-stu-id="3a371-213">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="3a371-214">Nieprawidłowo napisany program profilujący może powodować własne odwołania cykliczne, powodując nieprzewidywalne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="3a371-214">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="3a371-215">Przegląd środowiska CLR profilowania API może stworzyć wrażenie, że piszesz program profilujący, który zawiera zarządzane i niezarządzane komponenty, wywołujące siebie wzajemnie za pośrednictwem wywołania COM interop lub pośredniego.</span><span class="sxs-lookup"><span data-stu-id="3a371-215">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="3a371-216">Mimo że jest to możliwe z technicznego punktu widzenia, API profilowania nie obsługuje składników zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="3a371-216">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="3a371-217">Program profilujący CLR musi być całkowicie niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="3a371-217">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="3a371-218">Próby połączenia kodu zarządzanego i niezarządzanego w programie profilującym CLR mogą spowodować naruszenia zasad dostępu, awarię programu lub zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="3a371-218">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="3a371-219">Składniki zarządzane profilera nastąpi ich elementów niezarządzanych, które wywołają składniki zarządzane ponownie, wynikiem odwołań cyklicznych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="3a371-219">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="3a371-220">Jedyną lokalizacją, gdzie CLR profiler może wywoływać kod zarządzany bezpiecznie jest w treści firmy Microsoft intermediate language (MSIL) metody.</span><span class="sxs-lookup"><span data-stu-id="3a371-220">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="3a371-221">Zalecana praktyka modyfikacji ciała MSIL jest użycie metod rekompilacji JIT w [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3a371-221">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="3a371-222">Istnieje również możliwość użycia starszych metod oprzyrządowania do modyfikowania MSIL.</span><span class="sxs-lookup"><span data-stu-id="3a371-222">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="3a371-223">Przed zakończeniem kompilacji just-in-time (JIT) funkcji, program profilujący może wstawić zarządzane wywołania w treści MSIL metody, a następnie skompilować wg JIT go (zobacz [icorprofilerinfo::getilfunctionbody —](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) metody).</span><span class="sxs-lookup"><span data-stu-id="3a371-223">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="3a371-224">Ta technika może pomyślnie służyć do selektywnej Instrumentacji kodu zarządzanego lub do zbierania statystyk i wydajności danych dotyczących JIT.</span><span class="sxs-lookup"><span data-stu-id="3a371-224">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="3a371-225">Alternatywnie program profilujący kodu może wstawiać haki macierzyste w ciele MSIL każdej funkcji zarządzanej, która wywołuje kod niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="3a371-225">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="3a371-226">Ta technika może zostać użyta do Instrumentacji i zasięgu.</span><span class="sxs-lookup"><span data-stu-id="3a371-226">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="3a371-227">Na przykład program profilujący kodu może wstawiać zaczepy Instrumentacji po każdym bloku MSIL, aby upewnić się, że blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="3a371-227">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="3a371-228">Modyfikacja treści MSIL metody to bardzo delikatna operacja, a istnieje wiele czynników, które należy wziąć pod uwagę.</span><span class="sxs-lookup"><span data-stu-id="3a371-228">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

[<span data-ttu-id="3a371-229">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-229">Back to top</span></span>](#top)

<a name="unmanaged"></a>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="3a371-230">Profilowanie niezarządzanego kodu</span><span class="sxs-lookup"><span data-stu-id="3a371-230">Profiling Unmanaged Code</span></span>

<span data-ttu-id="3a371-231">Środowisko uruchomieniowe języka wspólnego (CLR) profilowania API zapewnia minimalną obsługę dla profilowania kodu niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="3a371-231">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="3a371-232">Następująca funkcjonalność została zapewniona:</span><span class="sxs-lookup"><span data-stu-id="3a371-232">The following functionality is provided:</span></span>

- <span data-ttu-id="3a371-233">Wyliczenie łańcuchów stosu.</span><span class="sxs-lookup"><span data-stu-id="3a371-233">Enumeration of stack chains.</span></span> <span data-ttu-id="3a371-234">Ta funkcja umożliwia programowi profilującemu kodu określenie granic między kodem zarządzanym i niezarządzanym kodzie.</span><span class="sxs-lookup"><span data-stu-id="3a371-234">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="3a371-235">Określenie tego, czy łańcuch stosu odnosi się do kodu zarządzanego lub kodu natywnego.</span><span class="sxs-lookup"><span data-stu-id="3a371-235">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="3a371-236">W wersjach programu .NET Framework 1.0 i 1.1 metody te są dostępne poprzez wewnątrzprocesowy podzbiór debugowania CLR interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="3a371-236">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="3a371-237">Są one zdefiniowane w pliku CorDebug.idl.</span><span class="sxs-lookup"><span data-stu-id="3a371-237">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="3a371-238">W programie .NET Framework 2.0 i nowszych możesz użyć [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) metody dla tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="3a371-238">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

[<span data-ttu-id="3a371-239">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-239">Back to top</span></span>](#top)

<a name="com"></a>

## <a name="using-com"></a><span data-ttu-id="3a371-240">Korzystając z modelu COM</span><span class="sxs-lookup"><span data-stu-id="3a371-240">Using COM</span></span>

<span data-ttu-id="3a371-241">Chociaż interfejsy profilowania są zdefiniowane jako interfejsy COM, środowisko uruchomieniowe języka wspólnego (CLR) nie inicjuje w rzeczywistości COM do użycia tych interfejsów.</span><span class="sxs-lookup"><span data-stu-id="3a371-241">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="3a371-242">Przyczyną jest, aby uniknąć konieczności ustawiania modelu wątku za pomocą [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) funkcja zarządzaną aplikacją miała szansę, aby określić swój żądany model wątku.</span><span class="sxs-lookup"><span data-stu-id="3a371-242">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="3a371-243">Podobnie, sam program profilujący nie powinien wywoływać `CoInitialize`, ponieważ może wybrać model wątku, który jest niezgodny z profilowaną aplikacją i może spowodować awarię aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3a371-243">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

[<span data-ttu-id="3a371-244">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-244">Back to top</span></span>](#top)

<a name="call_stacks"></a>

## <a name="call-stacks"></a><span data-ttu-id="3a371-245">Stosy wywołań</span><span class="sxs-lookup"><span data-stu-id="3a371-245">Call Stacks</span></span>

<span data-ttu-id="3a371-246">Profilowania API umożliwia uzyskanie stosów wywołań na dwa sposoby: metoda migawki stosu, która umożliwia gromadzenie rzadkich stosów wywołań, oraz metodę stosu w tle, która śledzi stos wywołań w każdej chwili.</span><span class="sxs-lookup"><span data-stu-id="3a371-246">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="3a371-247">Migawka stosu</span><span class="sxs-lookup"><span data-stu-id="3a371-247">Stack Snapshot</span></span>

<span data-ttu-id="3a371-248">Migawka stosu jest śladem stosu wątku na moment w czasie.</span><span class="sxs-lookup"><span data-stu-id="3a371-248">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="3a371-249">Profilowania API obsługuje śledzenie zarządzanej funkcji na stosie, ale pozostawia śledzenia funkcji niezarządzanych do własnego profiler walker stosu.</span><span class="sxs-lookup"><span data-stu-id="3a371-249">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="3a371-250">Aby uzyskać więcej informacji na temat sposobu programowania programu profilującego do przejścia przez stosy zarządzane, zobacz [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) metody, w tym zestawie dokumentacji i [Profiler stosu zalet w programie .NET Framework 2.0: Podstawy i](https://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="3a371-250">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="3a371-251">Stos cieni</span><span class="sxs-lookup"><span data-stu-id="3a371-251">Shadow Stack</span></span>

<span data-ttu-id="3a371-252">Przy użyciu metody migawki zbyt często można szybko utworzyć problemu z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="3a371-252">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="3a371-253">Jeśli chcesz śledzić stos często Twój program profilujący w zamian powinien skompilować cień stosu za pomocą [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), i [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) wywołań zwrotnych wyjątków.</span><span class="sxs-lookup"><span data-stu-id="3a371-253">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="3a371-254">Stos cienia jest zawsze aktualny i szybko może być kopiowany do magazynu, ilekroć migawka stosu jest potrzebna.</span><span class="sxs-lookup"><span data-stu-id="3a371-254">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="3a371-255">Stos cieni może uzyskać argumenty funkcji, wartości zwracane i informacje dotyczące ogólnych instancji.</span><span class="sxs-lookup"><span data-stu-id="3a371-255">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="3a371-256">Te informacje są dostępne tylko za pośrednictwem stosu w tle i można ją uzyskać podczas przekazywania kontroli do funkcji.</span><span class="sxs-lookup"><span data-stu-id="3a371-256">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="3a371-257">Jednak te informacje mogą nie być dostępne później podczas wykonywania funkcji.</span><span class="sxs-lookup"><span data-stu-id="3a371-257">However, this information may not be available later during the run of the function.</span></span>

[<span data-ttu-id="3a371-258">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-258">Back to top</span></span>](#top)

<a name="callbacks"></a>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="3a371-259">Wywołania zwrotne i głębokość stosu</span><span class="sxs-lookup"><span data-stu-id="3a371-259">Callbacks and Stack Depth</span></span>

<span data-ttu-id="3a371-260">Wywołania zwrotne Profiler mogą być wydawane w okolicznościach bardzo ograniczonych stosu a przepełnienie stosu w wywołaniu zwrotnym profilera doprowadzi do natychmiastowego wyjścia procesu.</span><span class="sxs-lookup"><span data-stu-id="3a371-260">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="3a371-261">Program profilujący powinien upewnij się, że używa tak mały stos, jak to możliwe w odpowiedzi na wywołania zwrotne.</span><span class="sxs-lookup"><span data-stu-id="3a371-261">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="3a371-262">Jeśli program profilujący jest przeznaczony do użycia wobec procesów, które są odporne na przepełnienie stosu, sam program profilujący powinien również unikać wyzwolenia przepełnienia stosu.</span><span class="sxs-lookup"><span data-stu-id="3a371-262">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

[<span data-ttu-id="3a371-263">Powrót do początku</span><span class="sxs-lookup"><span data-stu-id="3a371-263">Back to top</span></span>](#top)

<a name="related_topics"></a>

## <a name="related-topics"></a><span data-ttu-id="3a371-264">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="3a371-264">Related Topics</span></span>

|<span data-ttu-id="3a371-265">Tytuł</span><span class="sxs-lookup"><span data-stu-id="3a371-265">Title</span></span>|<span data-ttu-id="3a371-266">Opis</span><span class="sxs-lookup"><span data-stu-id="3a371-266">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="3a371-267">Konfigurowanie środowiska profilowania</span><span class="sxs-lookup"><span data-stu-id="3a371-267">Setting Up a Profiling Environment</span></span>](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)|<span data-ttu-id="3a371-268">Wyjaśnia sposób inicjowania programu profilującego, ustawiania powiadomień zdarzeń i profilowania usługi Windows.</span><span class="sxs-lookup"><span data-stu-id="3a371-268">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="3a371-269">Interfejsy profilowania</span><span class="sxs-lookup"><span data-stu-id="3a371-269">Profiling Interfaces</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)|<span data-ttu-id="3a371-270">W tym artykule opisano niezarządzane interfejsy, których używa interfejs profilowania API.</span><span class="sxs-lookup"><span data-stu-id="3a371-270">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="3a371-271">Profilowanie statycznych funkcji globalnych</span><span class="sxs-lookup"><span data-stu-id="3a371-271">Profiling Global Static Functions</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)|<span data-ttu-id="3a371-272">Opisuje niezarządzane globalne funkcje statyczne, których używa interfejs profilowania API.</span><span class="sxs-lookup"><span data-stu-id="3a371-272">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="3a371-273">Profilowanie — wyliczenia</span><span class="sxs-lookup"><span data-stu-id="3a371-273">Profiling Enumerations</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)|<span data-ttu-id="3a371-274">Opisuje niezarządzane wyliczenia, których używa interfejs profilowania API.</span><span class="sxs-lookup"><span data-stu-id="3a371-274">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="3a371-275">Profiling — struktury</span><span class="sxs-lookup"><span data-stu-id="3a371-275">Profiling Structures</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)|<span data-ttu-id="3a371-276">Opisuje niezarządzane struktury, których używa interfejs profilowania API.</span><span class="sxs-lookup"><span data-stu-id="3a371-276">Describes the unmanaged structures that the profiling API uses.</span></span>|
