---
title: Kontrakty kodu
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 721693166c561babb9d7825f480e92d14a5f347c
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/10/2018
ms.locfileid: "53154440"
---
# <a name="code-contracts"></a><span data-ttu-id="fda7a-102">Kontrakty kodu</span><span class="sxs-lookup"><span data-stu-id="fda7a-102">Code Contracts</span></span>
<span data-ttu-id="fda7a-103">Kontrakty kodu zapewniają możliwość określenia warunków wstępnych, warunków końcowych i invariants obiektu w kodzie.</span><span class="sxs-lookup"><span data-stu-id="fda7a-103">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="fda7a-104">Są one wymagania, które muszą zostać spełnione, podczas wprowadzania metodę lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="fda7a-104">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="fda7a-105">Warunków końcowych opisują oczekiwania w czasie, który zamyka kodu metody lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="fda7a-105">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="fda7a-106">Obiekt invariants opisują oczekiwany stan dla klasy, która jest w dobrym stanie.</span><span class="sxs-lookup"><span data-stu-id="fda7a-106">Object invariants describe the expected state for a class that is in a good state.</span></span>  
  
 <span data-ttu-id="fda7a-107">Kontrakty kodu zawierają klasy służące do oznaczania kodu, statycznej Analizator do analizy w czasie kompilacji i analizatora środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="fda7a-107">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="fda7a-108">Klasy dla kontraktów kodu można znaleźć w <xref:System.Diagnostics.Contracts> przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="fda7a-108">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>  
  
 <span data-ttu-id="fda7a-109">Kontrakty kodu zalety następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="fda7a-109">The benefits of code contracts include the following:</span></span>  
  
-   <span data-ttu-id="fda7a-110">Ulepszone testowania: Kontrakty kodu zapewniają weryfikacji statyczne kontraktu, sprawdzanie w czasie wykonywania i generowanie dokumentacji.</span><span class="sxs-lookup"><span data-stu-id="fda7a-110">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>  
  
-   <span data-ttu-id="fda7a-111">Automatyczne narzędzia do testowania: Kontrakty kodu można użyć, aby wygenerować bardziej zrozumiały testy jednostkowe odfiltrowując argumenty znaczenia testów, które nie spełniają warunków wstępnych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-111">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>  
  
-   <span data-ttu-id="fda7a-112">Weryfikacja statyczne. Sprawdzanie statycznego można zdecydować, czy istnieją wszelkie naruszenia Umowy, bez konieczności uruchamiania programu.</span><span class="sxs-lookup"><span data-stu-id="fda7a-112">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="fda7a-113">Sprawdza niejawne zamówień, takie jak wartości null wyłuskań i tablicy granice i jawne umów.</span><span class="sxs-lookup"><span data-stu-id="fda7a-113">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>  
  
-   <span data-ttu-id="fda7a-114">Dokumentacja: Generator dokumentacji rozszerza istniejące pliki dokumentacji XML przy użyciu informacje na temat umowy.</span><span class="sxs-lookup"><span data-stu-id="fda7a-114">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="fda7a-115">Dostępne są także arkuszy stylów, które mogą być używane z [Sandcastle](https://github.com/EWSoftware/SHFB) tak, aby strony wygenerowaną dokumentację zawierają sekcje kontraktu.</span><span class="sxs-lookup"><span data-stu-id="fda7a-115">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>  
  
 <span data-ttu-id="fda7a-116">Wszystkie języki .NET Framework od razu korzystać z zalet umów. nie trzeba napisać specjalny analizator lub kompilatora.</span><span class="sxs-lookup"><span data-stu-id="fda7a-116">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="fda7a-117">Dodatek programu Visual Studio pozwala określić poziom analizy kontraktu kodu do wykonania.</span><span class="sxs-lookup"><span data-stu-id="fda7a-117">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="fda7a-118">Analizatorów można potwierdzić, że kontrakty te są poprawnie sformułowane (kontrola typów i rozpoznawanie nazw) i może wywoływać skompilowanej formy kontraktów w formacie języka intermediate language (MSIL) firmy Microsoft.</span><span class="sxs-lookup"><span data-stu-id="fda7a-118">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="fda7a-119">Tworzenie umów w programie Visual Studio pozwala korzystać ze standardowych funkcji IntelliSense są udostępniane przez narzędzie.</span><span class="sxs-lookup"><span data-stu-id="fda7a-119">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>  
  
 <span data-ttu-id="fda7a-120">Większość metod w klasie umowy są warunkowo skompilowany; oznacza to, kompilator generuje wywołania tych metod tylko wtedy, gdy zdefiniować symbol specjalny CONTRACTS_FULL, za pomocą `#define` dyrektywy.</span><span class="sxs-lookup"><span data-stu-id="fda7a-120">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="fda7a-121">CONTRACTS_FULL umożliwia zapisanie kontraktów w kodzie, bez użycia `#ifdef` dyrektyw; można tworzyć różne kompilacje, niektóre z kontraktami i niektóre bez.</span><span class="sxs-lookup"><span data-stu-id="fda7a-121">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>  
  
 <span data-ttu-id="fda7a-122">Narzędzia i szczegółowe instrukcje dotyczące korzystania z kontraktów kodu, zobacz [kontrakty kodu](https://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs w sieci Web.</span><span class="sxs-lookup"><span data-stu-id="fda7a-122">For tools and detailed instructions for using code contracts, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
## <a name="preconditions"></a><span data-ttu-id="fda7a-123">Warunki wstępne</span><span class="sxs-lookup"><span data-stu-id="fda7a-123">Preconditions</span></span>  
 <span data-ttu-id="fda7a-124">Warunki wstępne można wyrazić za pomocą <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-124">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="fda7a-125">Warunki wstępne Określ stan przypadku wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-125">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="fda7a-126">Zwykle służą one do określenia prawidłowymi wartościami parametrów.</span><span class="sxs-lookup"><span data-stu-id="fda7a-126">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="fda7a-127">Wszystkie elementy członkowskie, które są wymienione w warunkach wstępnych musi być co najmniej tak samo dostępna jak metoda. w przeciwnym razie warunek wstępny może nie być zrozumiała dla wszystkich obiektów wywołujących metodę.</span><span class="sxs-lookup"><span data-stu-id="fda7a-127">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="fda7a-128">Warunek musi mieć nie efektów ubocznych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-128">The condition must have no side-effects.</span></span> <span data-ttu-id="fda7a-129">Zachowania w czasie wykonywania nie powiodło się warunki wstępne jest określany przez analizator środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="fda7a-129">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>  
  
 <span data-ttu-id="fda7a-130">Na przykład, następujący warunek wstępny wyraża tego parametru `x` musi być równa null.</span><span class="sxs-lookup"><span data-stu-id="fda7a-130">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>  
  
 ```csharp
 Contract.Requires(x != null);
 ```
  
 <span data-ttu-id="fda7a-131">Jeśli Twój kod musi zgłosić określony wyjątek na niepowodzenie warunku wstępnego, możesz użyć przeciążenia ogólne <xref:System.Diagnostics.Contracts.Contract.Requires%2A> w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="fda7a-131">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>  
  
 ```csharp
 Contract.Requires<ArgumentNullException>(x != null, "x");
 ```
  
### <a name="legacy-requires-statements"></a><span data-ttu-id="fda7a-132">Instrukcji #requires starszej wersji</span><span class="sxs-lookup"><span data-stu-id="fda7a-132">Legacy Requires Statements</span></span>  
 <span data-ttu-id="fda7a-133">Większość kodu zawiera niektóre poprawność parametrów w formie `if` - `then` - `throw` kodu.</span><span class="sxs-lookup"><span data-stu-id="fda7a-133">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="fda7a-134">Narzędzia kontraktu rozpoznać te instrukcje jako warunki wstępne w następujących przypadkach:</span><span class="sxs-lookup"><span data-stu-id="fda7a-134">The contract tools recognize these statements as preconditions in the following cases:</span></span>  
  
-   <span data-ttu-id="fda7a-135">Instrukcje są wyświetlane przed wszystkimi innymi instrukcjami w metodzie.</span><span class="sxs-lookup"><span data-stu-id="fda7a-135">The statements appear before any other statements in a method.</span></span>  
  
-   <span data-ttu-id="fda7a-136">Cały zestaw instrukcji takich następuje jawnego <xref:System.Diagnostics.Contracts.Contract> wywołania metody, takie jak wywołanie <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, lub <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-136">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>  
  
 <span data-ttu-id="fda7a-137">Gdy `if` - `then` - `throw` instrukcje pojawiają się w tym formularzu narzędzia rozpoznaje je jako starszy `requires` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="fda7a-137">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="fda7a-138">Jeśli nie ma innych umów `if` - `then` - `throw` sekwencji, end kodu za pomocą <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-138">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>  
  
```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```
  
 <span data-ttu-id="fda7a-139">Należy pamiętać, że warunek w poprzednim teście zanegowanych warunku wstępnego.</span><span class="sxs-lookup"><span data-stu-id="fda7a-139">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="fda7a-140">(Będzie rzeczywiste wstępnym `x != null`.) Warunkiem wstępnym zanegowanych jest o dużych ograniczeniach: Musi być napisana, jak pokazano w poprzednim przykładzie; oznacza to, że powinien on zawierać nie `else` klauzule i treści `then` klauzula musi mieć pojedynczy `throw` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="fda7a-140">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="fda7a-141">`if` Testu podlega reguł czystości i widoczności (zobacz [wytyczne dotyczące użycia](#usage_guidelines)), ale `throw` wyrażenie podlega wyłącznie czystości reguły.</span><span class="sxs-lookup"><span data-stu-id="fda7a-141">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="fda7a-142">Jednak typem wyjątku musi być jako widoczny jako metody, w której występuje umowy.</span><span class="sxs-lookup"><span data-stu-id="fda7a-142">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>  
  
## <a name="postconditions"></a><span data-ttu-id="fda7a-143">Warunków końcowych</span><span class="sxs-lookup"><span data-stu-id="fda7a-143">Postconditions</span></span>  
 <span data-ttu-id="fda7a-144">Warunków końcowych są kontrakty dla stanu metody, kończąc działanie.</span><span class="sxs-lookup"><span data-stu-id="fda7a-144">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="fda7a-145">Postcondition jest sprawdzany tuż przed Kończenie wykonywania metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-145">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="fda7a-146">Zachowania w czasie wykonywania nie powiodło się warunków końcowych jest określany przez analizator środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="fda7a-146">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>  
  
 <span data-ttu-id="fda7a-147">W odróżnieniu od warunków wstępnych warunków końcowych mogą odwoływać się do elementów członkowskich z mniejszą widoczność.</span><span class="sxs-lookup"><span data-stu-id="fda7a-147">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="fda7a-148">Klient nie może być można zrozumieć, lub wprowadzić korzystanie z niektórych informacji wyrażona postcondition, przy użyciu prywatnego stanu, ale nie ma to wpływu na możliwość klienta przy użyciu metody poprawnie.</span><span class="sxs-lookup"><span data-stu-id="fda7a-148">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>  
  
### <a name="standard-postconditions"></a><span data-ttu-id="fda7a-149">Standardowa warunków końcowych</span><span class="sxs-lookup"><span data-stu-id="fda7a-149">Standard Postconditions</span></span>  
 <span data-ttu-id="fda7a-150">Standardowa warunków końcowych można wyrazić za pomocą <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-150">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="fda7a-151">Warunków końcowych express warunek, który musi być `true` na normalne zakończenie metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-151">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>  
  
 ```csharp
 Contract.Ensures(this.F > 0);
 ```
  
### <a name="exceptional-postconditions"></a><span data-ttu-id="fda7a-152">Wyjątkowych warunków końcowych</span><span class="sxs-lookup"><span data-stu-id="fda7a-152">Exceptional Postconditions</span></span>  
 <span data-ttu-id="fda7a-153">Wyjątkowych warunków końcowych są warunków końcowych, które powinny być `true` gdy określony wyjątek jest zgłaszany przez metodę.</span><span class="sxs-lookup"><span data-stu-id="fda7a-153">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="fda7a-154">Należy określić tych warunków końcowych, za pomocą <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> metody, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="fda7a-154">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>  
  
 ```csharp
 Contract.EnsuresOnThrow<T>(this.F > 0);
 ```
  
 <span data-ttu-id="fda7a-155">Argument jest warunek, który musi być `true` zawsze wtedy, gdy wyjątek, który jest podtypem `T` zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="fda7a-155">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>  
  
 <span data-ttu-id="fda7a-156">Brak niektórych typów wyjątków, które są trudne do użycia w wyjątkowych postcondition.</span><span class="sxs-lookup"><span data-stu-id="fda7a-156">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="fda7a-157">Na przykład przy użyciu typu <xref:System.Exception> dla `T` wymaga metody w celu zagwarantowania warunku, bez względu na typ wyjątku, który jest zgłaszany, nawet jeśli jest on przepełnienie stosu lub innych wyjątków niemożliwe do sterowania.</span><span class="sxs-lookup"><span data-stu-id="fda7a-157">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="fda7a-158">Tylko dla określonych wyjątków, które mogą być zgłaszany, gdy członek jest wywoływany, na przykład, kiedy należy używać wyjątkowych warunków końcowych <xref:System.InvalidTimeZoneException> jest generowany dla <xref:System.TimeZoneInfo> wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-158">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>  
  
### <a name="special-postconditions"></a><span data-ttu-id="fda7a-159">Specjalne warunków końcowych</span><span class="sxs-lookup"><span data-stu-id="fda7a-159">Special Postconditions</span></span>  
 <span data-ttu-id="fda7a-160">Poniższych metod można stosować tylko w ramach warunków końcowych:</span><span class="sxs-lookup"><span data-stu-id="fda7a-160">The following methods may be used only within postconditions:</span></span>  
  
-   <span data-ttu-id="fda7a-161">Mogą odwoływać się do wartości zwracane metody w warunków końcowych przy użyciu wyrażenia `Contract.Result<T>()`, gdzie `T` jest zastępowany przez zwracany typ metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-161">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="fda7a-162">Gdy kompilator nie może wywnioskować typ, należy je jawnie określić.</span><span class="sxs-lookup"><span data-stu-id="fda7a-162">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="fda7a-163">Na przykład C# kompilator nie może wywnioskować typów, metod, które nie przyjmują żadnych argumentów, dzięki czemu wymaga następujących postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Metody z typem zwrotnym `void` nie może odwoływać się do `Contract.Result<T>()` w swoich warunków końcowych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-163">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>  
  
-   <span data-ttu-id="fda7a-164">Wartość prestate postcondition odnosi się do wartości wyrażenia na początku metody lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="fda7a-164">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="fda7a-165">Używa wyrażenia `Contract.OldValue<T>(e)`, gdzie `T` jest typem `e`.</span><span class="sxs-lookup"><span data-stu-id="fda7a-165">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="fda7a-166">Można pominąć argument typu ogólnego, zawsze wtedy, gdy kompilator może wywnioskować jej typu.</span><span class="sxs-lookup"><span data-stu-id="fda7a-166">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="fda7a-167">(Na przykład, kompilator języka C# zawsze wnioskuje typ z powodu argumentu.) Ma kilka ograniczeń dotyczących co może mieć miejsce w `e` i konteksty, w których może występować wyrażenie stary.</span><span class="sxs-lookup"><span data-stu-id="fda7a-167">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="fda7a-168">Stare wyrażenie nie może zawierać innego wyrażenia stary.</span><span class="sxs-lookup"><span data-stu-id="fda7a-168">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="fda7a-169">Co najważniejsze stare wyrażenie musi odwoływać się do wartości, które istniały w stanie wstępnym metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-169">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="fda7a-170">Innymi słowy, musi być wyrażenie, które mogą być obliczane tak długo, jak jest warunkiem wstępnym metody `true`.</span><span class="sxs-lookup"><span data-stu-id="fda7a-170">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="fda7a-171">Poniżej przedstawiono kilka wystąpień tej reguły.</span><span class="sxs-lookup"><span data-stu-id="fda7a-171">Here are several instances of that rule.</span></span>  
  
    -   <span data-ttu-id="fda7a-172">Wartość musi istnieć w stanie wstępnym metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-172">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="fda7a-173">Aby można było odwoływać się do pola w obiekcie warunki wstępne musi gwarantować, że obiekt zawsze jest różna od null.</span><span class="sxs-lookup"><span data-stu-id="fda7a-173">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>  
  
    -   <span data-ttu-id="fda7a-174">Nie można odwołać się do wartości zwracanej metody w wyrażeniu stare:</span><span class="sxs-lookup"><span data-stu-id="fda7a-174">You cannot refer to the method's return value in an old expression:</span></span>  
  
        ```csharp
        Contract.OldValue(Contract.Result<int>() + x) // ERROR  
        ```  
  
    -   <span data-ttu-id="fda7a-175">Nie można odwołać się `out` parametrów w wyrażeniu stary.</span><span class="sxs-lookup"><span data-stu-id="fda7a-175">You cannot refer to `out` parameters in an old expression.</span></span>  
  
    -   <span data-ttu-id="fda7a-176">Stare wyrażenie nie może zależeć od zmiennej powiązanej kwantyfikator, jeśli wartość zwracaną metody zależy od zakresu kwantyfikator:</span><span class="sxs-lookup"><span data-stu-id="fda7a-176">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>  
  
        ```csharp
        Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
        ```  
  
    -   <span data-ttu-id="fda7a-177">Stare wyrażenie nie może odwoływać się do parametru delegata anonimowego w <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> lub <xref:System.Diagnostics.Contracts.Contract.Exists%2A> wywołania, chyba że jest ona używana jako indeksatora lub argument wywołania metody:</span><span class="sxs-lookup"><span data-stu-id="fda7a-177">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>  
  
        ```csharp
        Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
        Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
        ```  
  
    -   <span data-ttu-id="fda7a-178">Stare wyrażenie nie może wystąpić w treści delegata anonimowego Jeśli wartość wyrażenia stare jest zależna od dowolny z parametrów delegata anonimowego, chyba że argument do delegata anonimowego <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> lub <xref:System.Diagnostics.Contracts.Contract.Exists%2A> metody:</span><span class="sxs-lookup"><span data-stu-id="fda7a-178">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>  
  
        ```csharp
        Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
        ```  
  
    -   <span data-ttu-id="fda7a-179">`Out` Parametry powodują problemu, ponieważ kontrakty następować przed elementem treści metody, a większość kompilatorów zezwala na odwołania do `out` parametry warunków końcowych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-179">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="fda7a-180">Aby rozwiązać ten problem, <xref:System.Diagnostics.Contracts.Contract> klasa udostępnia <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> metody, która umożliwia postcondition, na podstawie `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="fda7a-180">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>  
  
        ```csharp
        public void OutParam(out int x)
        {
            Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
            x = 3;
        }
        ```  
  
         <span data-ttu-id="fda7a-181">Podobnie jak w przypadku <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metody, można pominąć parametr typu ogólnego zawsze wtedy, gdy kompilator może wywnioskować jej typu.</span><span class="sxs-lookup"><span data-stu-id="fda7a-181">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="fda7a-182">Dysków kontraktu zastępuje wywołanie metody z wartością `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="fda7a-182">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="fda7a-183"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> Metoda może występować tylko w warunków końcowych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-183">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="fda7a-184">Argument do metody musi być `out` parametru lub pola struktury `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="fda7a-184">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="fda7a-185">Drugim jest również przydatne przy odwoływaniu się do pól w postcondition konstruktora struktury.</span><span class="sxs-lookup"><span data-stu-id="fda7a-185">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
        > [!NOTE]
        >  <span data-ttu-id="fda7a-186">Obecnie narzędzi analizy kodu kontraktu sprawdza, czy `out` parametry są inicjowane poprawnie i pominąć ich wzmiankę w postcondition.</span><span class="sxs-lookup"><span data-stu-id="fda7a-186">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="fda7a-187">W związku z tym, w poprzednim przykładzie, jeśli wiersza po kontrakt gdyby użyto wartości `x` zamiast przypisywać całkowitą do niego, kompilatora nie będzie wystawiać usunąć błąd.</span><span class="sxs-lookup"><span data-stu-id="fda7a-187">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="fda7a-188">Jednakże w przypadku kompilacji, w której symbol preprocesora CONTRACTS_FULL jest niezdefiniowana (takie kompilacji wydania asa), kompilator zgłosi błąd.</span><span class="sxs-lookup"><span data-stu-id="fda7a-188">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>  
  
## <a name="invariants"></a><span data-ttu-id="fda7a-189">Invariants</span><span class="sxs-lookup"><span data-stu-id="fda7a-189">Invariants</span></span>  
 <span data-ttu-id="fda7a-190">Obiekt invariants są warunki, które powinny być prawdziwe dla każdego wystąpienia klasy, zawsze wtedy, gdy ten obiekt jest widoczny dla klienta.</span><span class="sxs-lookup"><span data-stu-id="fda7a-190">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="fda7a-191">Warunki, w których obiekt jest uważany za prawidłowy one express.</span><span class="sxs-lookup"><span data-stu-id="fda7a-191">They express the conditions under which the object is considered to be correct.</span></span>  
  
 <span data-ttu-id="fda7a-192">Niezmienna metody są identyfikowane za pomocą oznaczony za pomocą <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="fda7a-192">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="fda7a-193">Niezmienna metody muszą zawierać żadnego kodu, z wyjątkiem sekwencję wywołań <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> metody, z których każdy określa poszczególnych niezmiennej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="fda7a-193">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>  
  
```csharp
[ContractInvariantMethod]  
protected void ObjectInvariant ()   
{  
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```  
  
 <span data-ttu-id="fda7a-194">Invariants warunkowo są definiowane przez symbol preprocesora CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="fda7a-194">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="fda7a-195">Podczas sprawdzania czasu wykonywania, invariants są sprawdzane na końcu każdej metody publiczne.</span><span class="sxs-lookup"><span data-stu-id="fda7a-195">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="fda7a-196">Jeśli niezmiennej nazwa publicznej metody z tej samej klasy, niezmienna Sprawdź, czy zwykle sytuacja może mieć miejsce na końcu metody publicznej jest wyłączona.</span><span class="sxs-lookup"><span data-stu-id="fda7a-196">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="fda7a-197">Zamiast tego sprawdzanie jest wykonywane tylko na końcu wywołania metody prowadzące do tej klasy.</span><span class="sxs-lookup"><span data-stu-id="fda7a-197">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="fda7a-198">Dzieje się również, jeśli klasa jest ponowne wprowadzenie ze względu na wywołanie metody w innej klasy.</span><span class="sxs-lookup"><span data-stu-id="fda7a-198">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="fda7a-199">Invariants nie są sprawdzane pod kątem finalizatora obiektu i <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji.</span><span class="sxs-lookup"><span data-stu-id="fda7a-199">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
<a name="usage_guidelines"></a>   
## <a name="usage-guidelines"></a><span data-ttu-id="fda7a-200">Wytyczne dotyczące użycia</span><span class="sxs-lookup"><span data-stu-id="fda7a-200">Usage Guidelines</span></span>  
  
### <a name="contract-ordering"></a><span data-ttu-id="fda7a-201">Kolejność kontraktu</span><span class="sxs-lookup"><span data-stu-id="fda7a-201">Contract Ordering</span></span>  
 <span data-ttu-id="fda7a-202">W poniższej tabeli przedstawiono kolejność elementów, którego należy używać podczas pisania metoda umów.</span><span class="sxs-lookup"><span data-stu-id="fda7a-202">The following table shows the order of elements you should use when you write method contracts.</span></span>  
  
|`If-then-throw statements`|<span data-ttu-id="fda7a-203">Warunki wstępne publicznych zgodne z poprzednimi wersjami</span><span class="sxs-lookup"><span data-stu-id="fda7a-203">Backward-compatible public preconditions</span></span>|  
|-|-|  
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="fda7a-204">Wszystkie warunki wstępne publicznych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-204">All public preconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="fda7a-205">Wszystkich warunków końcowych publiczny (normalne).</span><span class="sxs-lookup"><span data-stu-id="fda7a-205">All public (normal) postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="fda7a-206">Wszystkich warunków końcowych publicznych wyjątkowych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-206">All public exceptional postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="fda7a-207">Wszystkich warunków końcowych prywatne/wewnętrzny (normalne).</span><span class="sxs-lookup"><span data-stu-id="fda7a-207">All private/internal (normal) postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="fda7a-208">Wszystkich warunków końcowych prywatne/wewnętrzny wyjątkowych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-208">All private/internal exceptional postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="fda7a-209">Jeśli przy użyciu `if` - `then` - `throw` stylu warunki wstępne bez żadnych innych umów, Umieść wywołanie <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> z informacją, że wszystkie poprzednie, w przypadku sprawdzania warunków wstępnych.</span><span class="sxs-lookup"><span data-stu-id="fda7a-209">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|  
  
<a name="purity"></a>   
### <a name="purity"></a><span data-ttu-id="fda7a-210">Czystość</span><span class="sxs-lookup"><span data-stu-id="fda7a-210">Purity</span></span>  
 <span data-ttu-id="fda7a-211">Wszystkie metody, które są wywoływane w ramach kontraktu musi być czysty; oznacza to nie muszą zaktualizować dowolny stan przeniosła istniejące wcześniej.</span><span class="sxs-lookup"><span data-stu-id="fda7a-211">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="fda7a-212">Czystej metody może modyfikować obiekty, które zostały utworzone po wejściu w czystej metody.</span><span class="sxs-lookup"><span data-stu-id="fda7a-212">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>  
  
 <span data-ttu-id="fda7a-213">Obecnie narzędzia kontraktu kodu założono, czy czystego następujących elementów kodu:</span><span class="sxs-lookup"><span data-stu-id="fda7a-213">Code contract tools currently assume that the following code elements are pure:</span></span>  
  
-   <span data-ttu-id="fda7a-214">Metody, które są oznaczone <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="fda7a-214">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>  
  
-   <span data-ttu-id="fda7a-215">Typy, które są oznaczone <xref:System.Diagnostics.Contracts.PureAttribute> (atrybut ma zastosowanie do wszystkich typów, metod).</span><span class="sxs-lookup"><span data-stu-id="fda7a-215">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>  
  
-   <span data-ttu-id="fda7a-216">Właściwość metody dostępu get.</span><span class="sxs-lookup"><span data-stu-id="fda7a-216">Property get accessors.</span></span>  
  
-   <span data-ttu-id="fda7a-217">Operatory (metody statyczne, których nazwy rozpoczynają się od "op" oraz że masz jeden lub dwa parametry oraz zwracany typ inny niż void).</span><span class="sxs-lookup"><span data-stu-id="fda7a-217">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>  
  
-   <span data-ttu-id="fda7a-218">Każda metoda, której w pełni kwalifikowana nazwa zaczyna się od "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path" lub "System.Type".</span><span class="sxs-lookup"><span data-stu-id="fda7a-218">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>  
  
-   <span data-ttu-id="fda7a-219">Dowolny wywoływany delegat, pod warunkiem, że sam typ delegata jest związana z <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="fda7a-219">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="fda7a-220">Typy delegatów <xref:System.Predicate%601?displayProperty=nameWithType> i <xref:System.Comparison%601?displayProperty=nameWithType> są traktowane jako czysty.</span><span class="sxs-lookup"><span data-stu-id="fda7a-220">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>  
  
<a name="visibility"></a>   
### <a name="visibility"></a><span data-ttu-id="fda7a-221">Widoczność</span><span class="sxs-lookup"><span data-stu-id="fda7a-221">Visibility</span></span>  
 <span data-ttu-id="fda7a-222">Wszystkie elementy członkowskie wymienione w kontraktu musi być co najmniej jako widoczny jako metody, w jakiej są wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="fda7a-222">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="fda7a-223">Na przykład pola prywatnego nie może być wymienione w wstępnym publiczną metodę; Klienci nie można zweryfikować takie umowy, zanim wywołują metodę.</span><span class="sxs-lookup"><span data-stu-id="fda7a-223">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="fda7a-224">Jednakże jeśli pole jest oznaczona atrybutem <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, jest wykluczony z tych reguł.</span><span class="sxs-lookup"><span data-stu-id="fda7a-224">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>  
  
## <a name="example"></a><span data-ttu-id="fda7a-225">Przykład</span><span class="sxs-lookup"><span data-stu-id="fda7a-225">Example</span></span>  
 <span data-ttu-id="fda7a-226">Poniższy przykład pokazuje użycie kontrakty kodu.</span><span class="sxs-lookup"><span data-stu-id="fda7a-226">The following example shows the use of code contracts.</span></span>  
  
 [!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
 [!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
