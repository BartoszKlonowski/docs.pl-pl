---
title: releaseHandleFailed MDA
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: 265344cb100a41cde5443cd0914dc66271aabf93
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/14/2020
ms.locfileid: "77216112"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="1a85e-102">releaseHandleFailed MDA</span><span class="sxs-lookup"><span data-stu-id="1a85e-102">releaseHandleFailed MDA</span></span>
<span data-ttu-id="1a85e-103">`releaseHandleFailed` zarządzanego asystenta debugowania (MDA) polega na powiadamianiu deweloperów, gdy metoda <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> klasy pochodnej <xref:System.Runtime.InteropServices.SafeHandle> lub <xref:System.Runtime.InteropServices.CriticalHandle> zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="1a85e-103">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="1a85e-104">Objawy</span><span class="sxs-lookup"><span data-stu-id="1a85e-104">Symptoms</span></span>  
 <span data-ttu-id="1a85e-105">Przecieki zasobów lub pamięci.</span><span class="sxs-lookup"><span data-stu-id="1a85e-105">Resource or memory leaks.</span></span>  <span data-ttu-id="1a85e-106">Jeśli metoda <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> klasy pochodzącej od <xref:System.Runtime.InteropServices.SafeHandle> lub <xref:System.Runtime.InteropServices.CriticalHandle> kończy się niepowodzeniem, zasób hermetyzowany przez klasę może nie zostać wystawiony lub oczyszczony.</span><span class="sxs-lookup"><span data-stu-id="1a85e-106">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="1a85e-107">Przyczyna</span><span class="sxs-lookup"><span data-stu-id="1a85e-107">Cause</span></span>  
 <span data-ttu-id="1a85e-108">Użytkownicy muszą podać implementację metody <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, jeśli tworzą klasy, które pochodzą od <xref:System.Runtime.InteropServices.SafeHandle> lub <xref:System.Runtime.InteropServices.CriticalHandle>; z tego względu okoliczności są specyficzne dla poszczególnych zasobów.</span><span class="sxs-lookup"><span data-stu-id="1a85e-108">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="1a85e-109">Wymagania są jednak następujące:</span><span class="sxs-lookup"><span data-stu-id="1a85e-109">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="1a85e-110">typy <xref:System.Runtime.InteropServices.SafeHandle> i <xref:System.Runtime.InteropServices.CriticalHandle> reprezentują otoki wokół ważnych zasobów procesów.</span><span class="sxs-lookup"><span data-stu-id="1a85e-110"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="1a85e-111">Przeciek pamięci mógłby uniemożliwić korzystanie z tego procesu z upływem czasu.</span><span class="sxs-lookup"><span data-stu-id="1a85e-111">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="1a85e-112">Metoda <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nie może wykonać tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="1a85e-112">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="1a85e-113">Gdy proces uzyska taki zasób, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> jest jedynym sposobem jego zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="1a85e-113">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="1a85e-114">W związku z tym niepowodzenie oznacza przecieki zasobów.</span><span class="sxs-lookup"><span data-stu-id="1a85e-114">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="1a85e-115">Wszelkie błędy, które wystąpią podczas wykonywania <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, utrudniają wydanie zasobu, są usterką w implementacji samej metody <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a85e-115">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="1a85e-116">Jest odpowiedzialny programista, aby upewnić się, że kontrakt jest spełniony, nawet jeśli ten kod wywołuje kod utworzony przez kogoś innego do wykonywania swojej funkcji.</span><span class="sxs-lookup"><span data-stu-id="1a85e-116">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="1a85e-117">Rozwiązanie</span><span class="sxs-lookup"><span data-stu-id="1a85e-117">Resolution</span></span>  
 <span data-ttu-id="1a85e-118">Kod, który używa określonego typu <xref:System.Runtime.InteropServices.SafeHandle> (lub <xref:System.Runtime.InteropServices.CriticalHandle>), który wywołał powiadomienie MDA, powinien zostać sprawdzony, szukając miejsc, w których wartość pierwotnego dojścia jest wyodrębniana z <xref:System.Runtime.InteropServices.SafeHandle> i kopiowana w innym miejscu.</span><span class="sxs-lookup"><span data-stu-id="1a85e-118">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="1a85e-119">Jest to typowa przyczyna błędów w ramach implementacji <xref:System.Runtime.InteropServices.SafeHandle> lub <xref:System.Runtime.InteropServices.CriticalHandle>, ponieważ użycie nieprzetworzonej wartości nie jest już śledzone przez środowisko uruchomieniowe.</span><span class="sxs-lookup"><span data-stu-id="1a85e-119">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="1a85e-120">Jeśli kopia nieprzetworzonych dojść zostanie ZAMKNIĘTA, może to spowodować, że późniejsze <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> wywołanie zakończyło się niepowodzeniem, ponieważ próba zamknięcia w tym samym dojściem jest nieprawidłowa.</span><span class="sxs-lookup"><span data-stu-id="1a85e-120">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="1a85e-121">Istnieje kilka sposobów, w których może wystąpić nieprawidłowe duplikowanie obsługi:</span><span class="sxs-lookup"><span data-stu-id="1a85e-121">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="1a85e-122">Poszukaj wywołań metody <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a85e-122">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="1a85e-123">Wywołania tej metody powinny być przewyższane sporadycznie, a wszystkie znalezione należy ująć w wywołania metod <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> i <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a85e-123">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="1a85e-124">Te ostatnie metody określają region kodu, w którym wartość nieprzetworzonego dojścia może być bezpiecznie używana.</span><span class="sxs-lookup"><span data-stu-id="1a85e-124">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="1a85e-125">Poza tym regionem lub jeśli liczba odwołań nigdy nie rośnie w pierwszym miejscu, wartość dojścia może być unieważniona w dowolnym momencie przez wywołanie do <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> w innym wątku.</span><span class="sxs-lookup"><span data-stu-id="1a85e-125">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="1a85e-126">Gdy wszystkie zastosowania <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> zostały śledzone, należy postępować zgodnie z ścieżką, która jest wykonywana przez nieprzetworzony uchwyt, aby upewnić się, że nie jest on przekazywany do jakiegoś składnika, który ostatecznie wywoła `CloseHandle` lub inną metodę natywną niskiego poziomu, która zwolni uchwyt.</span><span class="sxs-lookup"><span data-stu-id="1a85e-126">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="1a85e-127">Upewnij się, że kod, który jest używany do inicjowania <xref:System.Runtime.InteropServices.SafeHandle> z prawidłową wartością nieprzetworzonego dojścia, jest właścicielem dojścia.</span><span class="sxs-lookup"><span data-stu-id="1a85e-127">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="1a85e-128">W przypadku tworzenia <xref:System.Runtime.InteropServices.SafeHandle> wokół uchwytu kod nie jest właścicielem bez ustawienia parametru `ownsHandle` do `false` w konstruktorze podstawowym, a następnie zarówno <xref:System.Runtime.InteropServices.SafeHandle>, jak i właściciel rzeczywistego uchwytu mogą próbować zamknąć uchwyt, prowadząc do błędu w <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, jeśli <xref:System.Runtime.InteropServices.SafeHandle> utraci rasę.</span><span class="sxs-lookup"><span data-stu-id="1a85e-128">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="1a85e-129">Gdy <xref:System.Runtime.InteropServices.SafeHandle> jest zorganizowany między domenami aplikacji, upewnij się, że używane dane pochodne <xref:System.Runtime.InteropServices.SafeHandle> zostały oznaczone jako możliwe do serializacji.</span><span class="sxs-lookup"><span data-stu-id="1a85e-129">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="1a85e-130">W rzadkich przypadkach, gdy Klasa pochodna <xref:System.Runtime.InteropServices.SafeHandle> została przeprowadzona do serializacji, należy zaimplementować interfejs <xref:System.Runtime.Serialization.ISerializable> lub użyć jednej z innych technik do ręcznego sterowania procesem serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="1a85e-130">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="1a85e-131">Jest to wymagane, ponieważ domyślna akcja serializacji polega na utworzeniu bitowego klonu pozostałej nieprzetworzonej wartości dojścia, co spowoduje, że dwa <xref:System.Runtime.InteropServices.SafeHandle> wystąpienia zastanawiają się, że są one własnością tego samego uchwytu.</span><span class="sxs-lookup"><span data-stu-id="1a85e-131">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="1a85e-132">Oba będą podejmować próby wywołania <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> w ramach tego samego uchwytu w pewnym momencie.</span><span class="sxs-lookup"><span data-stu-id="1a85e-132">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="1a85e-133">Druga <xref:System.Runtime.InteropServices.SafeHandle>, aby to zrobić, zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="1a85e-133">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="1a85e-134">Prawidłowym sposobem działania podczas serializowania <xref:System.Runtime.InteropServices.SafeHandle> jest wywołanie funkcji `DuplicateHandle` lub podobnej funkcji dla typu uchwytu natywnego w celu dokonania odrębnej kopii dojścia prawnego.</span><span class="sxs-lookup"><span data-stu-id="1a85e-134">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="1a85e-135">Jeśli typ uchwytu nie obsługuje tego typu, <xref:System.Runtime.InteropServices.SafeHandle> zawijania, nie można go serializować.</span><span class="sxs-lookup"><span data-stu-id="1a85e-135">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="1a85e-136">Może być możliwe śledzenie miejsca, w którym dojście jest zamykane wcześnie, co prowadzi do błędu, gdy metoda <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> jest ostatecznie wywoływana, przez umieszczenie punktu przerwania debugera w procedurze natywnej używanej do zwolnienia dojścia, na przykład funkcji `CloseHandle`.</span><span class="sxs-lookup"><span data-stu-id="1a85e-136">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="1a85e-137">Może to nie być możliwe w przypadku scenariuszy obciążeniowych, a nawet średnich testów funkcjonalnych spowodowanych dużym ruchem, które często omawiają te procedury.</span><span class="sxs-lookup"><span data-stu-id="1a85e-137">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="1a85e-138">Może ona ułatwić instrumentację kodu, który wywołuje natywną metodę wydania, aby przechwycić tożsamość obiektu wywołującego lub być może pełny ślad stosu i wartość zwalnianego dojścia.</span><span class="sxs-lookup"><span data-stu-id="1a85e-138">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="1a85e-139">Wartość dojścia można porównać z wartością raportowaną przez to zdarzenie MDA.</span><span class="sxs-lookup"><span data-stu-id="1a85e-139">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="1a85e-140">Należy zauważyć, że niektóre typy uchwytów natywnych, takie jak wszystkie uchwyty Win32, które mogą być wydane za pośrednictwem funkcji `CloseHandle`, współdzielą tę samą przestrzeń nazw uchwytu.</span><span class="sxs-lookup"><span data-stu-id="1a85e-140">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="1a85e-141">Błędne wydanie jednego typu dojścia może spowodować problemy z innym.</span><span class="sxs-lookup"><span data-stu-id="1a85e-141">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="1a85e-142">Na przykład przypadkowe zamknięcie dojścia zdarzenia Win32 dwa razy może prowadzić do przedwczesnego zamknięcia niepowiązanego dojścia do pliku.</span><span class="sxs-lookup"><span data-stu-id="1a85e-142">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="1a85e-143">Dzieje się tak, gdy dojście zostanie wydane, a wartość uchwytu będzie dostępna do śledzenia innego zasobu, a potencjalnie innego typu.</span><span class="sxs-lookup"><span data-stu-id="1a85e-143">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="1a85e-144">W takim przypadku i następuje błędne drugie wydanie, dojście niepowiązanego wątku może być unieważnione.</span><span class="sxs-lookup"><span data-stu-id="1a85e-144">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="1a85e-145">Wpływ na środowisko uruchomieniowe</span><span class="sxs-lookup"><span data-stu-id="1a85e-145">Effect on the Runtime</span></span>  
 <span data-ttu-id="1a85e-146">To zdarzenie MDA nie ma wpływu na środowisko CLR.</span><span class="sxs-lookup"><span data-stu-id="1a85e-146">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="1a85e-147">Dane wyjściowe</span><span class="sxs-lookup"><span data-stu-id="1a85e-147">Output</span></span>  
 <span data-ttu-id="1a85e-148">Komunikat informujący o tym, że <xref:System.Runtime.InteropServices.SafeHandle> lub <xref:System.Runtime.InteropServices.CriticalHandle> nie powiodło się prawidłowe wydanie dojścia.</span><span class="sxs-lookup"><span data-stu-id="1a85e-148">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="1a85e-149">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="1a85e-149">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'   
failed to properly release the handle with value 0x0000BEEF. This   
usually indicates that the handle was released incorrectly via   
another means (such as extracting the handle using DangerousGetHandle   
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="1a85e-150">Konfiguracja</span><span class="sxs-lookup"><span data-stu-id="1a85e-150">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="1a85e-151">Przykład</span><span class="sxs-lookup"><span data-stu-id="1a85e-151">Example</span></span>  
 <span data-ttu-id="1a85e-152">Poniżej znajduje się przykładowy kod, który umożliwia aktywowanie `releaseHandleFailed` MDA.</span><span class="sxs-lookup"><span data-stu-id="1a85e-152">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the   
    // native handle wrapped by this SafeHandle. This method returns   
    // false on failure, but should only fail if the input is invalid   
    // (which should not happen here). The method specifically must not   
    // fail simply because of lack of resources or other transient   
    // failures beyond the user’s control. That would make it unacceptable   
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="1a85e-153">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="1a85e-153">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="1a85e-154">Diagnozowanie błędów przy użyciu asystentów zarządzanego debugowania</span><span class="sxs-lookup"><span data-stu-id="1a85e-154">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="1a85e-155">Marshaling międzyoperacyjny</span><span class="sxs-lookup"><span data-stu-id="1a85e-155">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
