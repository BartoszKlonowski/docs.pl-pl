---
title: Zagadnienia dotyczące zabezpieczeń internetowych i zdalnego dostępu
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 7a56c9894da88382f40dcd475e89776a83a59322
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215779"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="939eb-102">Zagadnienia dotyczące zabezpieczeń internetowych i zdalnego dostępu</span><span class="sxs-lookup"><span data-stu-id="939eb-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="939eb-103">Komunikacja zdalna umożliwia skonfigurowanie przezroczystego wywoływania między domenami aplikacji, procesami lub komputerami.</span><span class="sxs-lookup"><span data-stu-id="939eb-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="939eb-104">Jednak przechodzenie przez stos zabezpieczeń dostępu kodu nie może przekroczyć procesu ani granic maszyn (stosuje się między domenami aplikacji tego samego procesu).</span><span class="sxs-lookup"><span data-stu-id="939eb-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="939eb-105">Każda klasa, która jest zdalna (pochodząca z klasy <xref:System.MarshalByRefObject>) musi podejmować odpowiedzialność za zabezpieczenia.</span><span class="sxs-lookup"><span data-stu-id="939eb-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="939eb-106">Kod powinien być używany tylko w środowiskach zamkniętych, w których kod wywołujący może być niejawnie zaufany lub wywołania komunikacji zdalnej powinny być zaprojektowane tak, aby nie podlegać chronionemu kodowi, który mógłby być użyty złośliwie.</span><span class="sxs-lookup"><span data-stu-id="939eb-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="939eb-107">Ogólnie rzecz biorąc nie należy ujawniać metod, właściwości ani zdarzeń chronionych przez deklaracyjne [LinkDemand](link-demands.md) i <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> sprawdzenia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="939eb-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="939eb-108">W przypadku komunikacji zdalnej te sprawdzenia nie są wymuszane.</span><span class="sxs-lookup"><span data-stu-id="939eb-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="939eb-109">Inne sprawdzenia zabezpieczeń, takie jak <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md)i tak dalej, działają między domenami aplikacji w ramach procesu, ale nie działają w scenariuszach obejmujących wiele procesów lub międzymaszynowo.</span><span class="sxs-lookup"><span data-stu-id="939eb-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="939eb-110">Chronione obiekty</span><span class="sxs-lookup"><span data-stu-id="939eb-110">Protected objects</span></span>  
 <span data-ttu-id="939eb-111">Niektóre obiekty przechowują stan zabezpieczeń we własnym zakresie.</span><span class="sxs-lookup"><span data-stu-id="939eb-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="939eb-112">Tych obiektów nie należy przekazywać do niezaufanego kodu, który następnie uzyskuje autoryzację zabezpieczeń poza jej własnymi uprawnieniami.</span><span class="sxs-lookup"><span data-stu-id="939eb-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="939eb-113">Przykładem jest tworzenie obiektu <xref:System.IO.FileStream>.</span><span class="sxs-lookup"><span data-stu-id="939eb-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="939eb-114"><xref:System.Security.Permissions.FileIOPermission> jest zapotrzebowanie w momencie tworzenia i, jeśli zakończy się pomyślnie, zostanie zwrócony obiekt pliku.</span><span class="sxs-lookup"><span data-stu-id="939eb-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="939eb-115">Jeśli jednak odwołanie do obiektu zostanie przesłane do kodu bez uprawnień do pliku, obiekt będzie mógł odczytywać i zapisywać dane w tym pliku.</span><span class="sxs-lookup"><span data-stu-id="939eb-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="939eb-116">Najprostszą obroną takiego obiektu jest zażądanie tego samego **FileIOPermission** dowolnego kodu, który poszukuje odwołania do obiektu za pomocą publicznego elementu interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="939eb-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="939eb-117">Problemy z przekroczeniem domeny aplikacji</span><span class="sxs-lookup"><span data-stu-id="939eb-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="939eb-118">Aby izolować kod w zarządzanych środowiskach hostingu, często generowane są wiele podrzędnych domen aplikacji z jawnymi zasadami zmniejszającymi poziomy uprawnień dla różnych zestawów.</span><span class="sxs-lookup"><span data-stu-id="939eb-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="939eb-119">Jednak zasady dla tych zestawów pozostaną niezmienione w domyślnej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="939eb-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="939eb-120">Jeśli jedna z domen aplikacji podrzędnych może wymusić załadowanie zestawu przez domyślną domenę aplikacji, efekt izolacji kodu zostanie utracony, a typy w załadowanym zestawie będzie można uruchamiać kod na wyższym poziomie zaufania.</span><span class="sxs-lookup"><span data-stu-id="939eb-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="939eb-121">Domena aplikacji może zmusić inną domenę aplikacji do załadowania zestawu i uruchomienia kodu zawartego w nim przez wywołanie serwera proxy do obiektu hostowanego w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="939eb-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="939eb-122">Aby uzyskać serwer proxy domeny między aplikacjami, domena aplikacji hostującym obiekt musi być dystrybuowana przez parametr wywołania metody lub wartość zwracaną.</span><span class="sxs-lookup"><span data-stu-id="939eb-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="939eb-123">Lub, jeśli domena aplikacji została właśnie utworzona, twórca ma domyślnie serwer proxy obiektu <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="939eb-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="939eb-124">W ten sposób, aby uniknąć przerywania izolacji kodu, domena aplikacji o wyższym poziomie zaufania nie powinna rozpowszechniać odwołań do obiektów zorganizowanych przez odwołanie (wystąpienia klas pochodzących z <xref:System.MarshalByRefObject>) w swojej domenie do domen aplikacji o niższych poziomach zaufania.</span><span class="sxs-lookup"><span data-stu-id="939eb-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="939eb-125">Zwykle domyślna domena aplikacji tworzy podrzędne domeny aplikacji z obiektem kontrolnym w każdym z nich.</span><span class="sxs-lookup"><span data-stu-id="939eb-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="939eb-126">Obiekt Control zarządza nową domeną aplikacji i okresowo przyjmuje zamówienia z domyślnej domeny aplikacji, ale nie może fizycznie skontaktować się bezpośrednio z domeną.</span><span class="sxs-lookup"><span data-stu-id="939eb-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="939eb-127">Czasami domyślna domena aplikacji wywołuje swój serwer proxy do obiektu Control.</span><span class="sxs-lookup"><span data-stu-id="939eb-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="939eb-128">Mogą jednak wystąpić sytuacje, w których obiekt sterowania może wywoływać z powrotem do domyślnej domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="939eb-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="939eb-129">W takich przypadkach domyślna domena aplikacji przekazuje obiekt wywołania zwrotnego marshal-by-reference do konstruktora obiektu Control.</span><span class="sxs-lookup"><span data-stu-id="939eb-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="939eb-130">Jest odpowiedzialny za obiekt sterowania do ochrony tego serwera proxy.</span><span class="sxs-lookup"><span data-stu-id="939eb-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="939eb-131">Jeśli obiekt sterowania miał umieścić serwer proxy w publicznym polu statycznym klasy publicznej lub w inny sposób ujawnia serwer proxy, spowoduje to otwarcie niebezpiecznego mechanizmu dla innego kodu w celu wywołania z powrotem do domyślnej domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="939eb-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="939eb-132">Z tego powodu obiekty sterujące są zawsze niejawnie zaufane, aby zachować prywatny serwer proxy.</span><span class="sxs-lookup"><span data-stu-id="939eb-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="939eb-133">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="939eb-133">See also</span></span>

- [<span data-ttu-id="939eb-134">Wytyczne dotyczące bezpiecznego programowania</span><span class="sxs-lookup"><span data-stu-id="939eb-134">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
