---
title: Przykład serializacji kodu JSON ze słabą kontrolą typów
ms.date: 03/30/2017
ms.assetid: 0b30e501-4ef5-474d-9fad-a9d559cf9c52
ms.openlocfilehash: bdeaffe31ba9bced28eebcfe294fc9944e5d05d0
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "79143593"
---
# <a name="weakly-typed-json-serialization-sample"></a><span data-ttu-id="826bf-102">Przykład serializacji kodu JSON ze słabą kontrolą typów</span><span class="sxs-lookup"><span data-stu-id="826bf-102">Weakly-typed JSON Serialization Sample</span></span>
<span data-ttu-id="826bf-103">Podczas serializacji typu zdefiniowanego przez użytkownika do danego formatu przewodowego lub deserializacji formatu przewodowego z powrotem do typu zdefiniowanego przez użytkownika, dany typ zdefiniowany przez użytkownika musi być dostępny zarówno dla usługi, jak i klienta.</span><span class="sxs-lookup"><span data-stu-id="826bf-103">When serializing a user-defined type to a given wire format, or deserializing a wire format back into a user-defined type, the given user-defined type must be available on both the service and the client.</span></span> <span data-ttu-id="826bf-104">Zwykle w tym <xref:System.Runtime.Serialization.DataContractAttribute> celu atrybut jest stosowany do tych typów <xref:System.Runtime.Serialization.DataMemberAttribute> zdefiniowanych przez użytkownika i atrybut jest stosowany do ich członków.</span><span class="sxs-lookup"><span data-stu-id="826bf-104">Usually to accomplish this, the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to these user-defined types and the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute is applied to their members.</span></span> <span data-ttu-id="826bf-105">Mechanizm ten ma również zastosowanie podczas pracy z obiektami Notacji obiektów JavaScript (JSON), zgodnie z opisem w temacie [Jak: Serialize i Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="826bf-105">This mechanism also applies when working with JavaScript Object Notation (JSON) objects, as described in the topic [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="826bf-106">W niektórych scenariuszach usługi lub klienta Programu Windows Communication Foundation (WCF) musi uzyskiwać dostęp do obiektów JSON generowanych przez usługę lub klienta, który znajduje się poza kontrolą dewelopera.</span><span class="sxs-lookup"><span data-stu-id="826bf-106">In some scenarios, a Windows Communication Foundation (WCF) service or client must access JSON objects generated by a service or client that is outside of the control of the developer.</span></span> <span data-ttu-id="826bf-107">Ponieważ więcej usług sieci Web publicznie uwidaczniać interfejsy API JSON, może stać się niepraktyczne dla dewelopera WCF do konstruowania typów lokalnych zdefiniowanych przez użytkownika, do których do deserializacji dowolnych obiektów JSON.</span><span class="sxs-lookup"><span data-stu-id="826bf-107">As more Web services publicly expose JSON APIs, it can become impractical for the WCF developer to construct local user-defined types into which to deserialize arbitrary JSON objects.</span></span> <span data-ttu-id="826bf-108">Ten przykład zawiera mechanizm, który umożliwia deweloperom WCF do pracy z deserializacji, dowolnych obiektów JSON, bez tworzenia typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="826bf-108">This sample provides a mechanism that enables WCF developers to work with deserialized, arbitrary JSON objects, without creating user-defined types.</span></span> <span data-ttu-id="826bf-109">Jest to znane jako *słabo typizowane serializacji* obiektów JSON, ponieważ typ, do którego obiekt JSON deserializes nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="826bf-109">This is known as *weakly-typed serialization* of JSON objects, because the type into which a JSON object deserializes is not known at compile time.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="826bf-110">Procedura konfiguracji i instrukcje kompilacji dla tego przykładu znajdują się na końcu tego tematu.</span><span class="sxs-lookup"><span data-stu-id="826bf-110">The setup procedure and build instructions for this sample are located at the end of this topic.</span></span>  
  
 <span data-ttu-id="826bf-111">Na przykład publiczny interfejs API usługi sieci Web zwraca następujący obiekt JSON, który opisuje niektóre informacje o użytkowniku usługi.</span><span class="sxs-lookup"><span data-stu-id="826bf-111">For example, a public Web service API returns the following JSON object, which describes some information about a user of the service.</span></span>  
  
```json  
{"personal": {"name": "Paul", "age": 23, "height": 1.7, "isSingle": true, "luckyNumbers": [5,17,21]}, "favoriteBands": ["Band ABC", "Band XYZ"]}  
```  
  
 <span data-ttu-id="826bf-112">Aby zdesializować ten obiekt, klient WCF musi zaimplementować następujące typy zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="826bf-112">To deserialize this object, a WCF client must implement the following user-defined types.</span></span>  
  
```csharp  
[DataContract]  
 public class MemberProfile  
 {  
     [DataMember]  
     public PersonalInfo personal;  
  
     [DataMember]  
     public string[] favoriteBands;  
 }  
  
 [DataContract]  
 public class PersonalInfo  
 {  
     [DataMember]  
     public string name;  
  
     [DataMember]  
     public int age;  
  
     [DataMember]  
     public double height;  
  
     [DataMember]  
     public bool isSingle;  
  
     [DataMember]  
     public int[] luckyNumbers;  
 }  
```  
  
 <span data-ttu-id="826bf-113">Może to być uciążliwe, zwłaszcza jeśli klient ma do obsługi więcej niż jeden typ obiektu JSON.</span><span class="sxs-lookup"><span data-stu-id="826bf-113">This can be cumbersome, especially if the client has to handle more than one type of JSON object.</span></span>  
  
 <span data-ttu-id="826bf-114">Typ `JsonObject` dostarczony przez ten przykład wprowadza słabo typizowane reprezentacji deserialized JSON obiektu.</span><span class="sxs-lookup"><span data-stu-id="826bf-114">The `JsonObject` type provided by this sample introduces a weakly-typed representation of the deserialized JSON object.</span></span> <span data-ttu-id="826bf-115">`JsonObject`opiera się na mapowaniu naturalnym między obiektami JSON i słownikami .NET Framework oraz mapowaniem między tablicami JSON i tablicami .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="826bf-115">`JsonObject` relies on the natural mapping between JSON objects and .NET Framework dictionaries, and the mapping between JSON arrays and .NET Framework arrays.</span></span> <span data-ttu-id="826bf-116">Poniższy kod `JsonObject` pokazuje typ.</span><span class="sxs-lookup"><span data-stu-id="826bf-116">The following code shows the `JsonObject` type.</span></span>  
  
```csharp  
// Instantiation of JsonObject json omitted  
  
string name = json["root"]["personal"]["name"];  
int age = json["root"]["personal"]["age"];  
double height = json["root"]["personal"]["height"];  
bool isSingle = json["root"]["personal"]["isSingle"];  
int[] luckyNumbers = {  
                                     json["root"]["personal"]["luckyNumbers"][0],  
                                     json["root"]["personal"]["luckyNumbers"][1],  
                                     json["root"]["personal"]["luckyNumbers"][2]
                                 };  
string[] favoriteBands = {  
                                        json["root"]["favoriteBands"][0],  
                                        json["root"]["favoriteBands"][1]  
                                    };  
```  
  
 <span data-ttu-id="826bf-117">Należy zauważyć, że można "przeglądać" JSON obiektów i tablic bez konieczności deklarowania ich typu w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="826bf-117">Note that you can "browse" JSON objects and arrays without the need to declare their type at compile time.</span></span> <span data-ttu-id="826bf-118">Aby uzyskać wyjaśnienie wymagań dla obiektu `["root"]` najwyższego poziomu, zobacz temat [Mapowanie między JSON i XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="826bf-118">For an explanation of the requirement for the top-level `["root"]` object, see the topic [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="826bf-119">Klasa `JsonObject` jest podana tylko jako przykład.</span><span class="sxs-lookup"><span data-stu-id="826bf-119">The `JsonObject` class is provided as an example only.</span></span> <span data-ttu-id="826bf-120">Nie został dokładnie przetestowany i nie powinien być stosowany w środowiskach produkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="826bf-120">It has not been thoroughly tested, and should not be used in production environments.</span></span> <span data-ttu-id="826bf-121">Oczywistym implikacją słabo typizowanej serializacji JSON jest brak bezpieczeństwa typu podczas pracy z programem `JsonObject`.</span><span class="sxs-lookup"><span data-stu-id="826bf-121">An obvious implication of weakly-typed JSON serialization is the lack of type-safety when working with `JsonObject`.</span></span>  
  
 <span data-ttu-id="826bf-122">Aby użyć `JsonObject` tego typu, kontrakt <xref:System.ServiceModel.Channels.Message> operacji klienta musi używać jako jego typu zwracania.</span><span class="sxs-lookup"><span data-stu-id="826bf-122">To use the `JsonObject` type, the client operation contract must use <xref:System.ServiceModel.Channels.Message> as its return type.</span></span>  
  
```csharp  
[ServiceContract]  
    interface IClientSideProfileService  
    {  
        // There is no need to write a DataContract for the complex type returned by the service.  
        // The client will use a JsonObject to browse the JSON in the received message.  
  
        [OperationContract]  
        [WebGet(ResponseFormat = WebMessageFormat.Json)]  
        Message GetMemberProfile();  
    }  
```  
  
 <span data-ttu-id="826bf-123">Następnie `JsonObject` jest tworzone, jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="826bf-123">The `JsonObject` is then instantiated as shown in the following code.</span></span>  
  
```csharp  
// Code to instantiate IClientSideProfileService channel omitted…  
  
// Make a request to the service and obtain the Json response  
XmlDictionaryReader reader = channel.GetMemberProfile().GetReaderAtBodyContents();  
  
// Go through the Json as though it is a dictionary. There is no need to map it to a .NET CLR type.  
JsonObject json = new JsonObject(reader);  
```  
  
 <span data-ttu-id="826bf-124">Konstruktor `JsonObject` przyjmuje <xref:System.Xml.XmlDictionaryReader>, który jest <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> uzyskiwany za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="826bf-124">The `JsonObject` constructor takes a <xref:System.Xml.XmlDictionaryReader>, which is obtained through the <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> method.</span></span> <span data-ttu-id="826bf-125">Czytnik zawiera reprezentację XML wiadomości JSON odebranej przez klienta.</span><span class="sxs-lookup"><span data-stu-id="826bf-125">The reader contains an XML representation of the JSON message received by the client.</span></span> <span data-ttu-id="826bf-126">Aby uzyskać więcej informacji, zobacz temat [Mapowanie między JSON i XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="826bf-126">For more information, see the topic [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
 <span data-ttu-id="826bf-127">Program generuje następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="826bf-127">The program produces the following output:</span></span>  
  
```console  
Service listening at http://localhost:8000/.  
To view the JSON output from the sample, navigate to http://localhost:8000/GetMemberProfile  
This is Paul's page. I am 23 years old and I am 1.7 meters tall.  
I am single.  
My lucky numbers are 5, 17, and 21.  
My favorite bands are Band ABC and Band XYZ.  
```  
  
### <a name="to-set-up-build-and-run-the-sample"></a><span data-ttu-id="826bf-128">Aby skonfigurować, skompilować i uruchomić próbkę</span><span class="sxs-lookup"><span data-stu-id="826bf-128">To set up, build, and run the sample</span></span>  
  
1. <span data-ttu-id="826bf-129">Upewnij się, że wykonano [procedurę jednorazowej instalacji dla przykładów fundacji komunikacji systemu Windows](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).</span><span class="sxs-lookup"><span data-stu-id="826bf-129">Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).</span></span>  
  
2. <span data-ttu-id="826bf-130">Tworzenie rozwiązania WeaklyTypedJson.sln zgodnie z opisem w [tworzenie przykładów fundacji komunikacji systemu Windows](../../../../docs/framework/wcf/samples/building-the-samples.md).</span><span class="sxs-lookup"><span data-stu-id="826bf-130">Build the solution WeaklyTypedJson.sln as described in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).</span></span>  
  
3. <span data-ttu-id="826bf-131">Uruchom rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="826bf-131">Run the solution.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="826bf-132">Próbki mogą być już zainstalowane na komputerze.</span><span class="sxs-lookup"><span data-stu-id="826bf-132">The samples may already be installed on your machine.</span></span> <span data-ttu-id="826bf-133">Przed kontynuowaniem sprawdź następujący (domyślny) katalog.</span><span class="sxs-lookup"><span data-stu-id="826bf-133">Check for the following (default) directory before continuing.</span></span>  
>
> `<InstallDrive>:\WF_WCF_Samples`  
>
> <span data-ttu-id="826bf-134">Jeśli ten katalog nie istnieje, przejdź do [Windows Communication Foundation (WCF) i Windows Workflow Foundation (WF) Przykłady dla platformy .NET Framework 4,](https://www.microsoft.com/download/details.aspx?id=21459) aby pobrać wszystkie Windows Communication Foundation (WCF) i [!INCLUDE[wf1](../../../../includes/wf1-md.md)] przykłady.</span><span class="sxs-lookup"><span data-stu-id="826bf-134">If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=21459) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples.</span></span> <span data-ttu-id="826bf-135">Ten przykład znajduje się w następującym katalogu.</span><span class="sxs-lookup"><span data-stu-id="826bf-135">This sample is located in the following directory.</span></span>  
>
> `<InstallDrive>:\WF_WCF_Samples\WCF\Scenario\Ajax\WeaklyTypedJson`  
