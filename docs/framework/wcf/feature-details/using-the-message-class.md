---
title: Używanie klasy Message
description: Dowiedz się więcej o klasie komunikatów, która jest podstawowa dla WCF. Musisz używać klasy wiadomości bezpośrednio tylko w niektórych zaawansowanych scenariuszach.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
ms.openlocfilehash: f806e257cfd3ccc5118a5783e2eda48eef4ba0bf
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246496"
---
# <a name="using-the-message-class"></a><span data-ttu-id="bcf6e-104">Używanie klasy Message</span><span class="sxs-lookup"><span data-stu-id="bcf6e-104">Using the Message Class</span></span>
<span data-ttu-id="bcf6e-105"><xref:System.ServiceModel.Channels.Message>Klasa ma podstawowe znaczenie dla Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-105">The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="bcf6e-106">Cała komunikacja między klientami i usługami ostatecznie powoduje <xref:System.ServiceModel.Channels.Message> , że wystąpienia są wysyłane i odbierane.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-106">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="bcf6e-107">Zazwyczaj nie można bezpośrednio korzystać z <xref:System.ServiceModel.Channels.Message> klasy.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-107">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="bcf6e-108">Zamiast tego konstrukcje modelu usługi WCF, takie jak kontrakty danych, kontrakty komunikatów i kontrakty operacji, służą do opisywania komunikatów przychodzących i wychodzących.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-108">Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="bcf6e-109">Jednak w niektórych zaawansowanych scenariuszach można bezpośrednio korzystać z <xref:System.ServiceModel.Channels.Message> klasy.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-109">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="bcf6e-110">Na przykład możesz chcieć użyć <xref:System.ServiceModel.Channels.Message> klasy:</span><span class="sxs-lookup"><span data-stu-id="bcf6e-110">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
- <span data-ttu-id="bcf6e-111">Jeśli potrzebujesz alternatywnej metody tworzenia wychodzącej zawartości wiadomości (na przykład podczas tworzenia komunikatu bezpośrednio z pliku na dysku), zamiast serializacji obiektów .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-111">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing .NET Framework objects.</span></span>  
  
- <span data-ttu-id="bcf6e-112">Gdy potrzebujesz alternatywnej metody używania przychodzącej zawartości wiadomości (na przykład, gdy chcesz zastosować transformację XSLT do nieprzetworzonej zawartości XML) zamiast deserializacji do .NET Framework obiektów.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-112">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into .NET Framework objects.</span></span>  
  
- <span data-ttu-id="bcf6e-113">Gdy konieczne jest zaradzenie sobie z komunikatami w ogólny sposób, niezależnie od zawartości komunikatu (na przykład podczas routingu lub przekazywania komunikatów podczas kompilowania routera, równoważenia obciążenia lub systemu publikowania/subskrybowania).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-113">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="bcf6e-114">Przed rozpoczęciem korzystania z <xref:System.ServiceModel.Channels.Message> klasy zapoznaj się z architekturą transferu danych w programie WCF w temacie [omówienie architektury transfer danych](data-transfer-architectural-overview.md).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-114">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="bcf6e-115">A <xref:System.ServiceModel.Channels.Message> to kontener ogólnego przeznaczenia dla danych, ale jego konstrukcja jest ściśle zgodna z projektem komunikatu w protokole SOAP.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-115">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="bcf6e-116">Podobnie jak w przypadku protokołu SOAP komunikat ma zarówno treść wiadomości, jak i nagłówki.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-116">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="bcf6e-117">Treść wiadomości zawiera rzeczywiste dane ładunku, podczas gdy nagłówki zawierają dodatkowe nazwane kontenery danych.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-117">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="bcf6e-118">Reguły odczytu i zapisu treści i nagłówki są różne, na przykład nagłówki są zawsze buforowane w pamięci i mogą być dostępne w dowolnej kolejności, a treść może być odczytana tylko raz i mogą być przesyłane strumieniowo.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-118">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="bcf6e-119">Zwykle w przypadku korzystania z protokołu SOAP treść komunikatu jest mapowana na treść protokołu SOAP, a nagłówki komunikatów są mapowane na nagłówki protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-119">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="bcf6e-120">Korzystanie z klasy Message w operacjach</span><span class="sxs-lookup"><span data-stu-id="bcf6e-120">Using the Message Class in Operations</span></span>  
 <span data-ttu-id="bcf6e-121">Klasy można użyć <xref:System.ServiceModel.Channels.Message> jako parametru wejściowego operacji, wartości zwracanej operacji lub obu tych elementów.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-121">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="bcf6e-122">Jeśli <xref:System.ServiceModel.Channels.Message> jest używany w dowolnym miejscu operacji, obowiązują następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="bcf6e-122">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
- <span data-ttu-id="bcf6e-123">Operacja nie może mieć żadnych `out` `ref` parametrów ani.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-123">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
- <span data-ttu-id="bcf6e-124">Nie może istnieć więcej niż jeden `input` parametr.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-124">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="bcf6e-125">Jeśli parametr jest obecny, musi być komunikatem lub typem kontraktu komunikatu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-125">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
- <span data-ttu-id="bcf6e-126">Typem zwracanym musi być albo `void` `Message` lub typ kontraktu komunikatu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-126">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="bcf6e-127">Poniższy przykład kodu zawiera prawidłowy kontrakt operacji.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-127">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="bcf6e-128">Tworzenie podstawowych komunikatów</span><span class="sxs-lookup"><span data-stu-id="bcf6e-128">Creating Basic Messages</span></span>  
 <span data-ttu-id="bcf6e-129"><xref:System.ServiceModel.Channels.Message>Klasa zawiera statyczne `CreateMessage` metody fabryki, których można użyć do tworzenia podstawowych komunikatów.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-129">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="bcf6e-130">Wszystkie `CreateMessage` przeciążenia pobierają parametr wersji typu <xref:System.ServiceModel.Channels.MessageVersion> , który wskazuje wersje protokołu SOAP i WS-Addressing do użycia w wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-130">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="bcf6e-131">Jeśli chcesz używać tych samych wersji protokołu co komunikat przychodzący, możesz użyć <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> właściwości w <xref:System.ServiceModel.OperationContext> wystąpieniu uzyskanym we <xref:System.ServiceModel.OperationContext.Current%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-131">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="bcf6e-132">Większość `CreateMessage` przeciążenia ma również parametr ciągu, który wskazuje akcję protokołu SOAP, która ma być używana dla wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-132">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="bcf6e-133">Aby `None` wyłączyć generowanie kopert protokołu SOAP, można ustawić wersję programu. komunikat składa się tylko z treści.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-133">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="bcf6e-134">Tworzenie komunikatów z obiektów</span><span class="sxs-lookup"><span data-stu-id="bcf6e-134">Creating Messages from Objects</span></span>  
 <span data-ttu-id="bcf6e-135">Najbardziej podstawowe `CreateMessage` Przeciążenie, które pobiera tylko wersję i akcję, tworzy komunikat z pustą treścią.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-135">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="bcf6e-136">Inne Przeciążenie pobiera dodatkowy <xref:System.Object> parametr; spowoduje to utworzenie komunikatu, którego treść jest serializowaną reprezentacją danego obiektu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-136">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="bcf6e-137">Użyj <xref:System.Runtime.Serialization.DataContractSerializer> domyślnych ustawień serializacji.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-137">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="bcf6e-138">Jeśli chcesz użyć innego serializatora lub chcesz `DataContractSerializer` skonfigurować inaczej, użyj `CreateMessage` przeciążenia, które również pobiera `XmlObjectSerializer` parametr.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-138">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="bcf6e-139">Na przykład, aby zwrócić obiekt w komunikacie, można użyć poniższego kodu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-139">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="bcf6e-140">Tworzenie komunikatów z poziomu czytników XML</span><span class="sxs-lookup"><span data-stu-id="bcf6e-140">Creating Messages from XML Readers</span></span>  
 <span data-ttu-id="bcf6e-141">Istnieją `CreateMessage` przeciążenia, które pobierają <xref:System.Xml.XmlReader> lub <xref:System.Xml.XmlDictionaryReader> dla treści zamiast do obiektu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-141">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="bcf6e-142">W takim przypadku treść wiadomości zawiera kod XML, który wynika z odczytu z przekazaną wartość czytnika XML.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-142">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="bcf6e-143">Na przykład poniższy kod zwraca komunikat z zawartością treści odczytaną z pliku XML.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-143">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="bcf6e-144">Ponadto istnieją `CreateMessage` przeciążenia, które pobierają <xref:System.Xml.XmlReader> lub <xref:System.Xml.XmlDictionaryReader> reprezentują cały komunikat, a nie tylko treść.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-144">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="bcf6e-145">Te przeciążenia również pobierają parametr liczby całkowitej `maxSizeOfHeaders` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-145">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="bcf6e-146">Nagłówki są zawsze buforowane w pamięci, gdy tylko zostanie utworzony komunikat, a ten parametr ogranicza ilość buforu, który ma miejsce.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-146">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="bcf6e-147">Ważne jest, aby ustawić ten parametr na wartość bezpieczną, jeśli plik XML pochodzi z niezaufanego źródła, aby zmniejszyć prawdopodobieństwo ataku typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="bcf6e-147">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="bcf6e-148">Wersja protokołu SOAP i WS-Addressing wiadomości, która reprezentuje czytnik XML, musi być zgodna z wersjami wskazanymi przy użyciu parametru Version.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-148">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="bcf6e-149">Tworzenie komunikatów za pomocą BodyWriter</span><span class="sxs-lookup"><span data-stu-id="bcf6e-149">Creating Messages with BodyWriter</span></span>  
 <span data-ttu-id="bcf6e-150">Jedno `CreateMessage` Przeciążenie pobiera `BodyWriter` wystąpienie opisujące treść wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-150">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="bcf6e-151">A `BodyWriter` jest klasą abstrakcyjną, która może być pochodną, aby dostosować sposób tworzenia treści wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-151">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="bcf6e-152">Można utworzyć własną `BodyWriter` klasę pochodną do opisywania treści wiadomości w niestandardowy sposób.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-152">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="bcf6e-153">Należy zastąpić `BodyWriter.OnWriteBodyContents` metodę, która przyjmuje <xref:System.Xml.XmlDictionaryWriter> ; Ta metoda jest odpowiedzialna za napisanie treści.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-153">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="bcf6e-154">Moduły zapisujące treści mogą być buforowane lub niebuforowane (przesyłane strumieniowo).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-154">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="bcf6e-155">Elementy zapisujące buforowanej treści mogą dowolnie wypełniać zawartość dowolnej liczby razy, podczas gdy strumieniowo mogą zapisywać zawartość tylko raz.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-155">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="bcf6e-156">`IsBuffered`Właściwość wskazuje, czy moduł zapisujący treści jest buforowany, czy nie.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-156">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="bcf6e-157">Można ustawić tę wartość dla składnika zapisywania treści przez wywołanie chronionego `BodyWriter` konstruktora, który przyjmuje `isBuffered` parametr Boolean.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-157">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="bcf6e-158">Moduł zapisywania treści obsługuje tworzenie zbuforowanego składnika zapisywania treści z niebuforowanego składnika zapisywania treści.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-158">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="bcf6e-159">Można zastąpić metodę, `OnCreateBufferedCopy` Aby dostosować ten proces.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-159">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="bcf6e-160">Domyślnie bufor w pamięci, który zawiera kod XML zwracany przez `OnWriteBodyContents` jest używany.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-160">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="bcf6e-161">`OnCreateBufferedCopy`przyjmuje `maxBufferSize` parametr liczby całkowitej; w przypadku zastąpienia tej metody nie należy tworzyć buforów o rozmiarze większym niż ten maksymalny rozmiar.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-161">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="bcf6e-162">`BodyWriter`Klasa zawiera `WriteBodyContents` `CreateBufferedCopy` metody i, które są zasadniczo cienkimi otokami `OnWriteBodyContents` i `OnCreateBufferedCopy` metodami, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-162">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="bcf6e-163">Te metody wykonują sprawdzanie stanu, aby upewnić się, że nie można uzyskać dostępu do niebuforowanego składnika zapisywania treści więcej niż raz.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-163">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="bcf6e-164">Te metody są wywoływane bezpośrednio tylko podczas tworzenia niestandardowych `Message` klas pochodnych opartych na `BodyWriters` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-164">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="bcf6e-165">Tworzenie komunikatów o błędach</span><span class="sxs-lookup"><span data-stu-id="bcf6e-165">Creating Fault Messages</span></span>  
 <span data-ttu-id="bcf6e-166">`CreateMessage`Do tworzenia komunikatów o błędach SOAP można użyć pewnych przeciążeń.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-166">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="bcf6e-167">Najbardziej podstawowe z nich to <xref:System.ServiceModel.Channels.MessageFault> obiekt, który opisuje błąd.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-167">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="bcf6e-168">Inne przeciążenia są udostępniane dla wygody.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-168">Other overloads are provided for convenience.</span></span> <span data-ttu-id="bcf6e-169">Pierwsze takie Przeciążenie pobiera `FaultCode` ciąg i przyczynę i tworzy `MessageFault` przy użyciu `MessageFault.CreateFault` tych informacji.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-169">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="bcf6e-170">Inne Przeciążenie pobiera obiekt szczegółowy, a także przekazuje go `CreateFault` wraz z kodem błędu i przyczynie.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-170">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="bcf6e-171">Na przykład następująca operacja zwraca błąd.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-171">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="bcf6e-172">Wyodrębnianie danych treści wiadomości</span><span class="sxs-lookup"><span data-stu-id="bcf6e-172">Extracting Message Body Data</span></span>  
 <span data-ttu-id="bcf6e-173">`Message`Klasa obsługuje wiele sposobów wyodrębniania informacji z jej treści.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-173">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="bcf6e-174">Mogą one być klasyfikowane do następujących kategorii:</span><span class="sxs-lookup"><span data-stu-id="bcf6e-174">These can be classified into the following categories:</span></span>  
  
- <span data-ttu-id="bcf6e-175">Pobieranie całej treści komunikatu w jednym miejscu do składnika zapisywania XML.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-175">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="bcf6e-176">Jest to nazywane *pisaniem wiadomości*.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-176">This is referred to as *writing a message*.</span></span>  
  
- <span data-ttu-id="bcf6e-177">Pobieranie czytnika XML przez treść wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-177">Getting an XML reader over the message body.</span></span> <span data-ttu-id="bcf6e-178">Dzięki temu można później uzyskać dostęp do treści wiadomości, jeśli jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-178">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="bcf6e-179">Jest to nazywane *odczytywaniem wiadomości*.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-179">This is referred to as *reading a message*.</span></span>  
  
- <span data-ttu-id="bcf6e-180">Cała wiadomość, łącznie z jej treścią, może zostać skopiowana do buforu w pamięci <xref:System.ServiceModel.Channels.MessageBuffer> typu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-180">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="bcf6e-181">Jest to nazywane *kopiowaniem wiadomości*.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-181">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="bcf6e-182">Możesz uzyskać dostęp do treści `Message` tylko raz, niezależnie od tego, w jaki sposób jest on dostępny.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-182">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="bcf6e-183">Obiekt komunikatu ma `State` Właściwość, która początkowo została ustawiona jako utworzona.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-183">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="bcf6e-184">Trzy metody dostępu opisane na powyższej liście ustawiają stan do zapisu, odczytu i kopiowania odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-184">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="bcf6e-185">Ponadto `Close` Metoda może ustawić stan na zamknięty, gdy treść wiadomości nie jest już wymagana.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-185">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="bcf6e-186">Treść komunikatu może być dostępna tylko w stanie utworzonym i nie ma możliwości powrotu do stanu utworzonego po zmianie stanu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-186">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="bcf6e-187">Pisanie wiadomości</span><span class="sxs-lookup"><span data-stu-id="bcf6e-187">Writing Messages</span></span>  
 <span data-ttu-id="bcf6e-188"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>Metoda zapisuje zawartość treści danego `Message` wystąpienia do danego składnika zapisywania XML.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-188">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="bcf6e-189">Metoda ta jest <xref:System.ServiceModel.Channels.Message.WriteBody%2A> taka sama, z tą różnicą, że zawartość treści jest umieszczona w odpowiednim elemencie otoki (na przykład <`soap:body`>).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-189">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="bcf6e-190">Na koniec <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> zapisuje cały komunikat, włącznie z zapakowaniem koperty protokołu SOAP i nagłówkami.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-190">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="bcf6e-191">Jeśli protokół SOAP jest wyłączony ( <xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> ), wszystkie trzy metody wykonują te same czynności: zapisuje zawartość treści komunikatu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-191">If SOAP is turned off (<xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="bcf6e-192">Na przykład poniższy kod zapisuje treść wiadomości przychodzącej do pliku.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-192">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="bcf6e-193">Dwie dodatkowe metody pomocnika zapisują niektóre Tagi elementu początkowego protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-193">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="bcf6e-194">Te metody nie uzyskują dostępu do treści wiadomości, dlatego nie zmieniają stanu komunikatu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-194">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="bcf6e-195">Należą do nich następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="bcf6e-195">These include:</span></span>  
  
- <span data-ttu-id="bcf6e-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A>zapisuje element start body, na przykład `<soap:Body>` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
- <span data-ttu-id="bcf6e-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A>zapisuje element Start Envelope, na przykład `<soap:Envelope>` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="bcf6e-198">Aby zapisać odpowiednie Tagi elementu końcowego, wywołaj `WriteEndElement` dla odpowiedniego składnika zapisywania XML.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-198">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="bcf6e-199">Te metody są rzadko wywoływane bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-199">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="bcf6e-200">Odczytywanie wiadomości</span><span class="sxs-lookup"><span data-stu-id="bcf6e-200">Reading Messages</span></span>  
 <span data-ttu-id="bcf6e-201">Podstawowym sposobem odczytywania treści wiadomości jest wywołanie <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-201">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="bcf6e-202">Możesz użyć kopii zapasowej <xref:System.Xml.XmlDictionaryReader> , która pozwala odczytać treść wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-202">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="bcf6e-203">Należy zauważyć, że <xref:System.ServiceModel.Channels.Message> przejścia do stanu odczytu zaraz po <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> wywołaniu jest wywoływany, a nie w przypadku używania zwróconego czytnika XML.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-203">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="bcf6e-204"><xref:System.ServiceModel.Channels.Message.GetBody%2A>Metoda ta umożliwia również dostęp do treści wiadomości jako obiekt z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-204">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="bcf6e-205">Wewnętrznie, ta metoda używa `GetReaderAtBodyContents` i dlatego przechodzi stan komunikatu do <xref:System.ServiceModel.Channels.MessageState.Read> stanu (zobacz <xref:System.ServiceModel.Channels.Message.State%2A> Właściwość).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-205">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="bcf6e-206">Dobrym sposobem jest sprawdzenie <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> właściwości, w tym przypadku treść komunikatu jest pusta i <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> zgłasza <xref:System.InvalidOperationException> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-206">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="bcf6e-207">Ponadto, jeśli jest to odebrana wiadomość (na przykład odpowiedź), można również sprawdzić <xref:System.ServiceModel.Channels.Message.IsFault%2A> , która wskazuje, czy komunikat zawiera błąd.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-207">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="bcf6e-208">Najbardziej podstawowe Przeciążenie <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializacji treści komunikatu do wystąpienia typu (wskazywanego przez parametr ogólny) przy użyciu <xref:System.Runtime.Serialization.DataContractSerializer> skonfigurowanych ustawień domyślnych i z <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> wyłączonym limitem przydziału.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-208">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="bcf6e-209">Jeśli chcesz użyć innego aparatu serializacji lub skonfigurować program `DataContractSerializer` w sposób inny niż domyślny, użyj <xref:System.ServiceModel.Channels.Message.GetBody%2A> przeciążenia, które przyjmuje <xref:System.Runtime.Serialization.XmlObjectSerializer> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-209">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="bcf6e-210">Na przykład poniższy kod wyodrębnia dane z treści wiadomości zawierającej serializowany `Person` obiekt i drukuje nazwisko osoby.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-210">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="bcf6e-211">Kopiowanie wiadomości do buforu</span><span class="sxs-lookup"><span data-stu-id="bcf6e-211">Copying a Message into a Buffer</span></span>  
 <span data-ttu-id="bcf6e-212">Czasami konieczne jest uzyskanie dostępu do treści wiadomości więcej niż jeden raz, na przykład w celu przekazania tego samego komunikatu do wielu miejsc docelowych w ramach systemu subskrybenta wydawcy.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-212">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="bcf6e-213">W takim przypadku konieczne jest buforowanie całego komunikatu (w tym treści) w pamięci.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-213">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="bcf6e-214">Można to zrobić przez wywołanie metody <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-214">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="bcf6e-215">Ta metoda przyjmuje parametr liczby całkowitej, który reprezentuje maksymalny rozmiar buforu i tworzy bufor nie większy niż ten rozmiar.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-215">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="bcf6e-216">Ważne jest, aby ustawić tę wartość na bezpieczną, jeśli wiadomość pochodzi z niezaufanego źródła.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-216">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="bcf6e-217">Bufor jest zwracany jako <xref:System.ServiceModel.Channels.MessageBuffer> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-217">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="bcf6e-218">Dostęp do danych w buforze można uzyskać na kilka sposobów.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-218">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="bcf6e-219">Podstawowym sposobem jest wywołanie <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> do tworzenia `Message` wystąpień z bufora.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-219">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="bcf6e-220">Innym sposobem, aby uzyskać dostęp do danych w buforze, jest implementacja <xref:System.Xml.XPath.IXPathNavigable> interfejsu, który <xref:System.ServiceModel.Channels.MessageBuffer> implementuje Klasa w celu bezpośredniego dostępu do bazowego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-220">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="bcf6e-221">Niektóre <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> przeciążenia umożliwiają tworzenie <xref:System.Xml.XPath> nawigatorów chronionych przez limit przydziału węzłów, ograniczając liczbę węzłów XML, które można odwiedzać.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-221">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="bcf6e-222">Pozwala to zapobiec atakom typu "odmowa usługi" na podstawie długiego czasu przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-222">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="bcf6e-223">Ta oferta jest domyślnie wyłączona.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-223">This quote is disabled by default.</span></span> <span data-ttu-id="bcf6e-224">Niektóre `CreateNavigator` przeciążenia umożliwiają określenie, jak biały znak ma być obsługiwany w kodzie XML przy użyciu <xref:System.Xml.XmlSpace> wyliczenia, z wartością domyślną `XmlSpace.None` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-224">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="bcf6e-225">Końcowym sposobem uzyskiwania dostępu do zawartości bufora komunikatów jest zapisanie jej zawartości w strumieniu przy użyciu <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-225">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="bcf6e-226">Poniższy przykład demonstruje proces pracy z `MessageBuffer` : komunikat przychodzący jest przekazywany do wielu adresatów, a następnie rejestrowany do pliku.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-226">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="bcf6e-227">Bez buforowania nie jest to możliwe, ponieważ treść komunikatu może być następnie dostępna tylko raz.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-227">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="bcf6e-228">`MessageBuffer`Klasa ma inne składowe.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-228">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="bcf6e-229"><xref:System.ServiceModel.Channels.MessageBuffer.Close%2A>Metodę można wywołać, aby zwolnić zasoby, gdy zawartość buforu nie jest już wymagana.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-229">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="bcf6e-230"><xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A>Właściwość zwraca rozmiar przydzieloną bufora.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-230">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="bcf6e-231"><xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A>Właściwość zwraca typ zawartości MIME wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-231">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="bcf6e-232">Uzyskiwanie dostępu do treści wiadomości na potrzeby debugowania</span><span class="sxs-lookup"><span data-stu-id="bcf6e-232">Accessing the Message Body for Debugging</span></span>  
 <span data-ttu-id="bcf6e-233">Na potrzeby debugowania można wywołać <xref:System.ServiceModel.Channels.Message.ToString%2A> metodę, aby otrzymać reprezentację wiadomości jako ciąg.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-233">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="bcf6e-234">Ta reprezentacja jest zwykle zgodna ze sposobem, w jaki komunikat będzie wyglądał w sieci, jeśli został zakodowany za pomocą kodera tekstu, z tą różnicą, że kod XML będzie lepiej sformatowany do czytelności.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-234">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="bcf6e-235">Jedynym wyjątkiem jest treść wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-235">The one exception to this is the message body.</span></span> <span data-ttu-id="bcf6e-236">Treść można odczytać tylko raz i nie `ToString` zmienia stanu komunikatu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-236">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="bcf6e-237">W związku z tym `ToString` Metoda może nie być w stanie uzyskać dostępu do treści i może zastąpić symbol zastępczy (na przykład "..." lub trzy kropki) zamiast treści wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-237">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="bcf6e-238">W związku z tym nie należy używać `ToString` do rejestrowania komunikatów, jeśli treść wiadomości jest ważna.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-238">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="bcf6e-239">Uzyskiwanie dostępu do innych części komunikatów</span><span class="sxs-lookup"><span data-stu-id="bcf6e-239">Accessing Other Message Parts</span></span>  
 <span data-ttu-id="bcf6e-240">W celu uzyskania dostępu do informacji o komunikacie innym niż zawartość treści są udostępniane różne właściwości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-240">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="bcf6e-241">Jednak tych nie można wywołać po zamknięciu wiadomości:</span><span class="sxs-lookup"><span data-stu-id="bcf6e-241">However, these cannot be called once the message has been closed:</span></span>  
  
- <span data-ttu-id="bcf6e-242"><xref:System.ServiceModel.Channels.Message.Headers%2A>Właściwość reprezentuje nagłówki komunikatów.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-242">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="bcf6e-243">Zapoznaj się z sekcją "Praca z nagłówkami" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-243">See the section on "Working with Headers" later in this topic.</span></span>  
  
- <span data-ttu-id="bcf6e-244"><xref:System.ServiceModel.Channels.Message.Properties%2A>Właściwość reprezentuje właściwości komunikatu, które są fragmentami nazwanych danych dołączonymi do wiadomości, które zazwyczaj nie są emitowane podczas wysyłania komunikatu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-244">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="bcf6e-245">Zapoznaj się z sekcją "Praca z właściwościami" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-245">See the section on "Working with Properties" later in this topic.</span></span>  
  
- <span data-ttu-id="bcf6e-246"><xref:System.ServiceModel.Channels.Message.Version%2A>Właściwość wskazuje wersję protokołu SOAP i WS-Addressing skojarzoną z wiadomością lub `None` Jeśli protokół SOAP jest wyłączony.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-246">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
- <span data-ttu-id="bcf6e-247">Ta <xref:System.ServiceModel.Channels.Message.IsFault%2A> Właściwość zwraca wartość, `true` Jeśli komunikat jest komunikatem o błędzie protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-247">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
- <span data-ttu-id="bcf6e-248"><xref:System.ServiceModel.Channels.Message.IsEmpty%2A>Właściwość zwraca, `true` Jeśli komunikat jest pusty.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-248">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="bcf6e-249">Można użyć metody, <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> Aby uzyskać dostęp do określonego atrybutu w elemencie otoki treści (na przykład `<soap:Body>` ) identyfikowanego przez określoną nazwę i przestrzeń nazw.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-249">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="bcf6e-250">Jeśli taki atrybut nie zostanie znaleziony, `null` jest zwracany.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-250">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="bcf6e-251">Tę metodę można wywołać tylko wtedy, gdy `Message` jest w stanie Created (gdy treść komunikatu nie została jeszcze uzyskana).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-251">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="bcf6e-252">Praca z nagłówkami</span><span class="sxs-lookup"><span data-stu-id="bcf6e-252">Working with Headers</span></span>  
 <span data-ttu-id="bcf6e-253">`Message`Może zawierać dowolną liczbę nazwanych fragmentów XML o nazwie *Headers*.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-253">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="bcf6e-254">Każdy fragment zwykle jest mapowany do nagłówka SOAP.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-254">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="bcf6e-255">Nagłówki są dostępne przez `Headers` Właściwość typu <xref:System.ServiceModel.Channels.MessageHeaders> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-255">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="bcf6e-256"><xref:System.ServiceModel.Channels.MessageHeaders>jest kolekcją <xref:System.ServiceModel.Channels.MessageHeaderInfo> obiektów i dostęp do poszczególnych nagłówków można uzyskać za pomocą jego <xref:System.Collections.IEnumerable> interfejsu lub indeksatora.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-256"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="bcf6e-257">Na przykład poniższy kod wyświetla listę nazw wszystkich nagłówków w `Message` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-257">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="bcf6e-258">Dodawanie, usuwanie i znajdowanie nagłówków</span><span class="sxs-lookup"><span data-stu-id="bcf6e-258">Adding, Removing, Finding Headers</span></span>  
 <span data-ttu-id="bcf6e-259">Można dodać nowy nagłówek na końcu wszystkich istniejących nagłówków przy użyciu <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-259">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="bcf6e-260">Możesz użyć metody, <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> Aby wstawić nagłówek w określonym indeksie.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-260">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="bcf6e-261">Istniejące nagłówki są przesuwane dla wstawionego elementu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-261">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="bcf6e-262">Nagłówki są uporządkowane według ich indeksu, a pierwszy dostępny indeks to 0.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-262">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="bcf6e-263">Różnych <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> przeciążeń metod można użyć do dodawania nagłówków z innego `Message` `MessageHeaders` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-263">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="bcf6e-264">Niektóre przeciążenia kopiowania jednego pojedynczego nagłówka, podczas gdy inne kopiują wszystkie z nich.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-264">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="bcf6e-265"><xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A>Metoda usuwa wszystkie nagłówki.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-265">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="bcf6e-266"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A>Metoda usuwa nagłówek w określonym indeksie (przesunięcie wszystkich nagłówków po nim).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-266">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="bcf6e-267"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A>Metoda usuwa wszystkie nagłówki z określoną nazwą i przestrzenią nazw.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-267">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="bcf6e-268">Pobierz konkretny nagłówek przy użyciu <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-268">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="bcf6e-269">Ta metoda przyjmuje nazwę i przestrzeń nazw nagłówka do znalezienia i zwraca jego indeks.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-269">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="bcf6e-270">Jeśli nagłówek występuje więcej niż jeden raz, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-270">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="bcf6e-271">Jeśli nagłówek nie zostanie znaleziony, zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-271">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="bcf6e-272">W modelu nagłówka SOAP nagłówki mogą mieć wartość określającą `Actor` zamierzony odbiorcę nagłówka.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-272">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="bcf6e-273">Najbardziej podstawowe `FindHeader` Przeciążenie przeszukiwane są tylko nagłówki przeznaczone dla końcowego odbiorcy wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-273">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="bcf6e-274">Jednak inne Przeciążenie pozwala określić, które `Actor` wartości są uwzględniane w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-274">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> <span data-ttu-id="bcf6e-275">Aby uzyskać więcej informacji, zobacz specyfikację protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-275">For more information, see the SOAP specification.</span></span>  
  
 <span data-ttu-id="bcf6e-276"><xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29>Podano metodę kopiowania nagłówków z <xref:System.ServiceModel.Channels.MessageHeaders> kolekcji do tablicy <xref:System.ServiceModel.Channels.MessageHeaderInfo> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-276">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="bcf6e-277">Aby uzyskać dostęp do danych XML w nagłówku, można wywołać <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> i zwrócić czytnik XML dla określonego indeksu nagłówka.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-277">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="bcf6e-278">Jeśli chcesz zdeserializować zawartość nagłówka do obiektu, użyj <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> lub jeden z innych przeciążeń.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-278">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="bcf6e-279">Najbardziej podstawowe przeciążenia deserializacji nagłówków przy użyciu <xref:System.Runtime.Serialization.DataContractSerializer> skonfigurowane w sposób domyślny.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-279">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="bcf6e-280">Jeśli chcesz użyć innego serializatora lub innej konfiguracji `DataContractSerializer` , użyj jednego z przeciążeń, które zajmie `XmlObjectSerializer` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-280">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="bcf6e-281">Istnieją również przeciążenia, które pobierają nazwę nagłówka, przestrzeń nazw i opcjonalnie listę `Actor` wartości zamiast indeksu; jest to kombinacja `FindHeader` i `GetHeader` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-281">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="bcf6e-282">Praca z właściwościami</span><span class="sxs-lookup"><span data-stu-id="bcf6e-282">Working with Properties</span></span>  
 <span data-ttu-id="bcf6e-283">`Message`Wystąpienie może zawierać dowolną liczbę nazwanych obiektów dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-283">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="bcf6e-284">Dostęp do tej kolekcji uzyskuje się za pomocą `Properties` właściwości typu `MessageProperties` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-284">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="bcf6e-285">Kolekcja implementuje <xref:System.Collections.Generic.IDictionary%602> interfejs i działa jako mapowanie z <xref:System.String> do <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-285">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="bcf6e-286">Zwykle wartości właściwości nie są mapowane bezpośrednio do żadnej części wiadomości w sieci, ale zamiast tego udostępniają różne wskazówki przetwarzania komunikatów do różnych kanałów w stosie kanału WCF lub w <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> środowisku usługi.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-286">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="bcf6e-287">Aby zapoznać się z przykładem, zobacz [Omówienie architektury transfer danych](data-transfer-architectural-overview.md).</span><span class="sxs-lookup"><span data-stu-id="bcf6e-287">For an example, see [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="bcf6e-288">Dziedziczenie z klasy Message</span><span class="sxs-lookup"><span data-stu-id="bcf6e-288">Inheriting from the Message Class</span></span>  
 <span data-ttu-id="bcf6e-289">Jeśli wbudowane typy komunikatów utworzone za pomocą nie `CreateMessage` spełniają wymagań, Utwórz klasę pochodzącą od `Message` klasy.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-289">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="bcf6e-290">Definiowanie zawartości treści wiadomości</span><span class="sxs-lookup"><span data-stu-id="bcf6e-290">Defining the Message Body Contents</span></span>  
 <span data-ttu-id="bcf6e-291">Istnieją trzy podstawowe metody uzyskiwania dostępu do danych w treści wiadomości: zapisywanie, odczytywanie i kopiowanie do buforu.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-291">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="bcf6e-292">Te operacje ostatecznie powodują, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A> i <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> metody są wywoływane odpowiednio, w klasie pochodnej `Message` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-292">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="bcf6e-293">Klasa bazowa `Message` gwarantuje, że tylko jedna z tych metod jest wywoływana dla każdego `Message` wystąpienia i nie jest wywoływana więcej niż raz.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-293">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="bcf6e-294">Klasa bazowa gwarantuje również, że metody nie są wywoływane na zamkniętej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-294">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="bcf6e-295">Nie ma potrzeby śledzenia stanu komunikatu w implementacji.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-295">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="bcf6e-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>jest metodą abstrakcyjną i musi być zaimplementowana.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="bcf6e-297">Najbardziej podstawowym sposobem zdefiniowania zawartości treści wiadomości jest zapisanie przy użyciu tej metody.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-297">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="bcf6e-298">Na przykład następujący komunikat zawiera liczbę losową 100 000 od 1 do 20.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-298">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="bcf6e-299"><xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents>Metody i <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> mają domyślne implementacje, które działają w większości przypadków.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-299">The <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods have default implementations that work for most cases.</span></span> <span data-ttu-id="bcf6e-300">Domyślne wywołanie implementacji <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> , buforowanie wyników i pracy z wynikowym buforem.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-300">The default implementations call <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="bcf6e-301">Jednak w niektórych przypadkach może to być niewystarczające.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-301">However, in some cases this may not be enough.</span></span> <span data-ttu-id="bcf6e-302">W poprzednim przykładzie odczytywanie komunikatu powoduje, że elementy XML w formacie 100 000 są buforowane, co może nie być pożądane.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-302">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="bcf6e-303">Możesz chcieć przesłonić, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> aby zwracać niestandardową <xref:System.Xml.XmlDictionaryReader> klasę pochodną, która obsługuje liczby losowe.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-303">You might want to override <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> to return a custom <xref:System.Xml.XmlDictionaryReader> derived class that serves up random numbers.</span></span> <span data-ttu-id="bcf6e-304">Następnie można przesłonić, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> Aby użyć czytnika <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> zwracanego przez metodę, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-304">You can then override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> to use the reader that the <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> method returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="bcf6e-305">Analogicznie, możesz chcieć przesłonić, `OnCreateBufferedCopy` Aby zwrócić własną `MessageBuffer` klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-305">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="bcf6e-306">Oprócz udostępniania treści wiadomości, Klasa pochodna komunikatu musi również przesłaniać `Version` `Headers` właściwości, i `Properties` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-306">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="bcf6e-307">Należy pamiętać, że w przypadku utworzenia kopii komunikatu kopia będzie używać nagłówków wiadomości z oryginału.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-307">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="bcf6e-308">Inne elementy członkowskie, które mogą zostać zastąpione</span><span class="sxs-lookup"><span data-stu-id="bcf6e-308">Other Members that Can Be Overridden</span></span>  
 <span data-ttu-id="bcf6e-309">Można zastąpić <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A> <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> metody,, i, <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> Aby określić sposób, w jaki koperty protokołu SOAP, nagłówki protokołu SOAP i Tagi początkowe elementu treści protokołu SOAP są zapisywane. Zwykle są one zgodne z `<soap:Envelope>` , `<soap:Header>` i `<soap:Body>` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-309">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="bcf6e-310">Te metody nie powinny zwykle zapisywać niczego w przypadku, gdy <xref:System.ServiceModel.Channels.Message.Version> Właściwość zwraca <xref:System.ServiceModel.Channels.MessageVersion.None> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-310">These methods should normally not write anything out if the <xref:System.ServiceModel.Channels.Message.Version> property returns <xref:System.ServiceModel.Channels.MessageVersion.None>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bcf6e-311">Domyślna implementacja `OnGetReaderAtBodyContents` wywołań `OnWriteStartEnvelope` i `OnWriteStartBody` przed wywołaniem `OnWriteBodyContents` i buforowaniem wyników.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-311">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="bcf6e-312">Nagłówki nie są zapisywane.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-312">Headers are not written out.</span></span>  
  
 <span data-ttu-id="bcf6e-313">Zastąp <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> metodę, aby zmienić sposób, w jaki cały komunikat jest zbudowany z różnych elementów.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-313">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="bcf6e-314">`OnWriteMessage`Metoda jest wywoływana z <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> i z <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementacji domyślnej.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-314">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="bcf6e-315">Należy zauważyć, że zastąpienie <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> nie jest najlepszym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-315">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="bcf6e-316">Lepszym rozwiązaniem jest przesłonięcie odpowiednich `On` metod (na przykład,, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A> <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> i <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-316">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="bcf6e-317">Przesłoń, aby przesłonić <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> sposób reprezentowania treści wiadomości podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-317">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="bcf6e-318">Wartość domyślna to reprezentujący trzy kropki ("...").</span><span class="sxs-lookup"><span data-stu-id="bcf6e-318">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="bcf6e-319">Należy zauważyć, że ta metoda może być wywoływana wiele razy, gdy stan wiadomości jest inny niż zamknięty.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-319">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="bcf6e-320">Implementacja tej metody nigdy nie powinna spowodować żadnej akcji, która musi zostać wykonana tylko raz (na przykład odczyt z strumienia "tylko do przodu").</span><span class="sxs-lookup"><span data-stu-id="bcf6e-320">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="bcf6e-321">Zastąp <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> metodę, aby zezwolić na dostęp do atrybutów w elemencie treści protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-321">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="bcf6e-322">Ta metoda może być wywoływana dowolną liczbę razy, ale `Message` Typ podstawowy gwarantuje, że jest wywoływana tylko wtedy, gdy komunikat jest w stanie created.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-322">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="bcf6e-323">Nie jest wymagane sprawdzanie stanu w implementacji.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-323">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="bcf6e-324">Domyślna implementacja zawsze zwraca wartość `null` , która wskazuje, że nie ma żadnych atrybutów elementu body.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-324">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="bcf6e-325">Jeśli `Message` obiekt musi wykonać jakiekolwiek specjalne czyszczenie, gdy treść komunikatu nie jest już wymagana, można przesłonić <xref:System.ServiceModel.Channels.Message.OnClose%2A> .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-325">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="bcf6e-326">Domyślna implementacja nie robi nic.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-326">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="bcf6e-327">`IsEmpty`Właściwości i `IsFault` można przesłonić.</span><span class="sxs-lookup"><span data-stu-id="bcf6e-327">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="bcf6e-328">Domyślnie obie zwracają `false` .</span><span class="sxs-lookup"><span data-stu-id="bcf6e-328">By default, both return `false`.</span></span>
