---
title: Zagadnienia związane z zabezpieczeniami danych
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
author: BrucePerlerMS
manager: mbaldwin
ms.openlocfilehash: 077d6b3527119f00ecec3014778fecf0dd1a4bde
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
ms.locfileid: "33509082"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="a0bda-102">Zagadnienia związane z zabezpieczeniami danych</span><span class="sxs-lookup"><span data-stu-id="a0bda-102">Security Considerations for Data</span></span>
<span data-ttu-id="a0bda-103">Podczas pracy z danymi w systemie Windows Communication Foundation (WCF), należy wziąć pod uwagę liczbę kategorii zagrożeń.</span><span class="sxs-lookup"><span data-stu-id="a0bda-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="a0bda-104">W poniższej tabeli wymieniono najważniejsze klasy zagrożenia, które odnoszą się do przetwarzania danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="a0bda-105">Usługi WCF udostępnia narzędzia, aby ograniczyć te zagrożenia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-105">WCF provides tools to mitigate these threats.</span></span>  
  
 <span data-ttu-id="a0bda-106">Odmowa usługi</span><span class="sxs-lookup"><span data-stu-id="a0bda-106">Denial of service</span></span>  
 <span data-ttu-id="a0bda-107">Podczas odbierania danych niezaufanych, danych może spowodować po stronie odbierającej dostęp do różnych zasobów, takich jak pamięci, wątki, dostępne połączenia lub cyklów procesora nieproporcjonalnie dużego przy powodują długie obliczenia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-107">When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="a0bda-108">Atak typu "odmowa usługi" na serwerze może spowodować jej awarii i nie można przetworzyć wiadomości od innych, oryginalnych klientów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-108">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>  
  
 <span data-ttu-id="a0bda-109">Wykonanie złośliwego kodu</span><span class="sxs-lookup"><span data-stu-id="a0bda-109">Malicious code execution</span></span>  
 <span data-ttu-id="a0bda-110">Przychodzące niezaufanych danych powoduje, że po stronie odbierającej do uruchomienia kodu, który go nie chcesz.</span><span class="sxs-lookup"><span data-stu-id="a0bda-110">Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>  
  
 <span data-ttu-id="a0bda-111">Ujawnienie informacji</span><span class="sxs-lookup"><span data-stu-id="a0bda-111">Information disclosure</span></span>  
 <span data-ttu-id="a0bda-112">Zdalnej osobie atakującej wymusza otrzymującej odpowiadać na żądania jej w taki sposób, aby ujawnić informacji więcej niż zamierza.</span><span class="sxs-lookup"><span data-stu-id="a0bda-112">The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>  
  
## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="a0bda-113">Kod użytkownika i zabezpieczenia dostępu kodu</span><span class="sxs-lookup"><span data-stu-id="a0bda-113">User-Provided Code and Code Access Security</span></span>  
 <span data-ttu-id="a0bda-114">Liczba miejsc w infrastrukturze Windows Communication Foundation (WCF) uruchamianie kodu dostarczonego przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-114">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="a0bda-115">Na przykład <xref:System.Runtime.Serialization.DataContractSerializer> mechanizm serializacji może wywołać dostarczane przez użytkownika właściwości `set` metody dostępu i `get` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-115">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="a0bda-116">Infrastruktura kanału WCF może również wywołują dostarczane przez użytkownika klas pochodnych <xref:System.ServiceModel.Channels.Message> klasy.</span><span class="sxs-lookup"><span data-stu-id="a0bda-116">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>  
  
 <span data-ttu-id="a0bda-117">Jest odpowiedzialny za autora kod, aby upewnić się, że luk w zabezpieczeniach nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="a0bda-117">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="a0bda-118">Na przykład w przypadku utworzenia typu kontraktu danych z właściwością elementu członkowskiego danych typu integer, a w `set` implementacja metody dostępu przydzielić tablicy na podstawie wartości właściwości, udostępnianie możliwości ataku typu "odmowa usługi", jeśli złośliwe komunikat zawiera bardzo dużą wartość dla tego elementu członkowskiego danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-118">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="a0bda-119">Ogólnie rzecz biorąc należy unikać alokacje na podstawie danych przychodzących lub długie przetwarzanie w kodzie użytkownika (zwłaszcza, jeśli długich przetwarzania może być spowodowany niewielką ilość przychodzących danych).</span><span class="sxs-lookup"><span data-stu-id="a0bda-119">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="a0bda-120">Podczas przeprowadzania analizy zabezpieczeń kodu użytkownika, upewnij się, że należy również rozważyć wszystkich przypadkach niepowodzenia (oznacza to, że wszystkie kodu gałęzie gdzie są zgłaszane wyjątki).</span><span class="sxs-lookup"><span data-stu-id="a0bda-120">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>  
  
 <span data-ttu-id="a0bda-121">Ultimate przykładem kodu dostarczonego przez użytkownika jest kodu wewnątrz implementacji usługi dla każdej operacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-121">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="a0bda-122">Zabezpieczenia implementacji usługi odpowiada użytkownik.</span><span class="sxs-lookup"><span data-stu-id="a0bda-122">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="a0bda-123">Jest łatwo tworzyć przypadkowo implementacji niezabezpieczonych operacji, które mogą skutkować luk w zabezpieczeniach typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="a0bda-123">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="a0bda-124">Na przykład operację, która przyjmuje ciągiem i zwraca listę klientów z bazy danych, których nazwa rozpoczyna się od tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-124">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="a0bda-125">Jeśli pracujesz z dużej bazy danych, a ciąg przekazywany jest tylko pojedyncze litery, kodu mogą próbować utworzyć wiadomości większych niż dostępnej pamięci, co powoduje awarię całej usługi.</span><span class="sxs-lookup"><span data-stu-id="a0bda-125">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="a0bda-126">( <xref:System.OutOfMemoryException> Nie jest możliwe do odzyskania w [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] i zawsze powoduje zablokowanie dostępu do aplikacji.)</span><span class="sxs-lookup"><span data-stu-id="a0bda-126">(An <xref:System.OutOfMemoryException> is not recoverable in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] and always results in the termination of your application.)</span></span>  
  
 <span data-ttu-id="a0bda-127">Należy upewnić się, że nie złośliwy kod jest podłączony do różnych punktów rozszerzalności.</span><span class="sxs-lookup"><span data-stu-id="a0bda-127">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="a0bda-128">Jest to szczególnie istotne w przypadku, gdy jest używany w częściowej relacji zaufania, dotyczących typów z częściowo zaufanych zestawów lub tworzenie składników można używać przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="a0bda-128">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="a0bda-129">Aby uzyskać więcej informacji zobacz "Częściowego zaufania zagrożeń" w dalszej części artykułu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-129">For more information, see "Partial Trust Threats" in a later section.</span></span>  
  
 <span data-ttu-id="a0bda-130">Może uruchomionej w częściowej relacji zaufania, infrastruktury serializacji kontraktu danych obsługuje tylko ograniczone podzbiór danych kontraktu modelu programowania — na przykład dane prywatne elementy Członkowskie lub typów przy użyciu <xref:System.SerializableAttribute> atrybutów nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="a0bda-130">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="a0bda-131">Aby uzyskać więcej informacji, zobacz [zaufania częściowego](../../../../docs/framework/wcf/feature-details/partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-131">For more information, see [Partial Trust](../../../../docs/framework/wcf/feature-details/partial-trust.md).</span></span>  
  
## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="a0bda-132">Unikanie przypadkowe ujawnienie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-132">Avoiding Unintentional Information Disclosure</span></span>  
 <span data-ttu-id="a0bda-133">Podczas projektowania typów możliwych do serializacji z myślą o bezpieczeństwie, ujawnienie informacji jest możliwy problem.</span><span class="sxs-lookup"><span data-stu-id="a0bda-133">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>  
  
 <span data-ttu-id="a0bda-134">Należy rozważyć następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="a0bda-134">Consider the following points:</span></span>  
  
-   <span data-ttu-id="a0bda-135"><xref:System.Runtime.Serialization.DataContractSerializer> Model programowania umożliwia narażenia prywatne i wewnętrzne danych poza typu lub zestawu podczas serializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-135">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="a0bda-136">Ponadto kształtu typu mogą być narażone podczas eksportowania schematu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-136">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="a0bda-137">Pamiętaj zrozumieć danego typu serializacji projekcji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-137">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="a0bda-138">Jeśli nie mają żadnych widoczne, wyłącz, szeregując go (na przykład stosując nie <xref:System.Runtime.Serialization.DataMemberAttribute> atrybutu w przypadku kontraktu danych).</span><span class="sxs-lookup"><span data-stu-id="a0bda-138">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>  
  
-   <span data-ttu-id="a0bda-139">Należy pamiętać, że ten sam typ może mieć wielu serializacji projekcji, w zależności od elementu serializującego w użyciu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-139">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="a0bda-140">Ten sam typ może narazić jeden zestaw danych, gdy jest używany z <xref:System.Runtime.Serialization.DataContractSerializer> i inny zestaw danych, gdy jest używany z <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-140">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="a0bda-141">Przypadkowemu użyciu niewłaściwy serializator może spowodować ujawnienie informacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-141">Accidentally using the wrong serializer may lead to information disclosure.</span></span>  
  
-   <span data-ttu-id="a0bda-142">Przy użyciu <xref:System.Xml.Serialization.XmlSerializer> w starszej wersji procedur zdalnych wywołań (procedur RPC) / zakodowanego tryb przypadkowo może narazić kształtu Wykres obiektu po stronie wysyłającej do po stronie odbierającej.</span><span class="sxs-lookup"><span data-stu-id="a0bda-142">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>  
  
## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="a0bda-143">Zapobieganie atakom typu "odmowa usługi"</span><span class="sxs-lookup"><span data-stu-id="a0bda-143">Preventing Denial-of-Service Attacks</span></span>  
  
### <a name="quotas"></a><span data-ttu-id="a0bda-144">Przydziały</span><span class="sxs-lookup"><span data-stu-id="a0bda-144">Quotas</span></span>  
 <span data-ttu-id="a0bda-145">Powoduje po stronie odbierającej można przydzielić znaczną ilość pamięci jest potencjalny atak typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="a0bda-145">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="a0bda-146">Gdy w tej sekcji koncentruje się na problemy z użyciem pamięci wynikających z dużych wiadomości, może wystąpić inne ataki.</span><span class="sxs-lookup"><span data-stu-id="a0bda-146">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="a0bda-147">Na przykład wiadomości posłużyć nieproporcjonalnie dużego czas przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-147">For example, messages may use a disproportionate amount of processing time.</span></span>  
  
 <span data-ttu-id="a0bda-148">Ataki typu "odmowa usługi" są zazwyczaj skorygowane przy użyciu przydziałów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-148">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="a0bda-149">Po przekroczeniu przydziału <xref:System.ServiceModel.QuotaExceededException> jest zazwyczaj zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a0bda-149">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="a0bda-150">Bez przydziału, niebezpieczną wiadomość może spowodować całą dostępną pamięć można było uzyskać dostęp, co powoduje <xref:System.OutOfMemoryException> wyjątku lub wszystkie dostępne stosy można uzyskać dostęp, wynikowe w <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-150">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>  
  
 <span data-ttu-id="a0bda-151">Przekroczono przydział scenariusza są możliwe do odzyskania; Jeśli w działającej usłudze, aktualnie przetwarzanego komunikatu jest odrzucany i kontynuowanie działania i przetwarza dalsze komunikaty.</span><span class="sxs-lookup"><span data-stu-id="a0bda-151">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="a0bda-152">Scenariusze przepełnienie braku pamięci i stosu, jednak nie są możliwe do odzyskania w dowolnym miejscu [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]; zakończenie usługi, jeśli wykryje takie wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a0bda-152">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]; the service terminates if it encounters such exceptions.</span></span>  
  
 <span data-ttu-id="a0bda-153">Przydziały w programie WCF nie wymagają żadnych wstępnej alokacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-153">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="a0bda-154">Na przykład jeśli <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> przydziału (znajdujący się na różnych klas) jest ustawiona na 128 KB, nie oznacza to, że 128 KB automatycznie przypisany do każdego komunikatu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-154">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="a0bda-155">Wartość rzeczywistego przydzielone zależy od rzeczywisty rozmiar wiadomości przychodzącej.</span><span class="sxs-lookup"><span data-stu-id="a0bda-155">The actual amount allocated depends on the actual incoming message size.</span></span>  
  
 <span data-ttu-id="a0bda-156">Wiele przydziały są dostępne w warstwie transportowej.</span><span class="sxs-lookup"><span data-stu-id="a0bda-156">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="a0bda-157">Są to limitami przez kanał transportu określonych w użyciu (HTTP, TCP i tak dalej).</span><span class="sxs-lookup"><span data-stu-id="a0bda-157">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="a0bda-158">Gdy w tym temacie omówiono niektóre z tych przydziałów, te przydziały opisano szczegółowo w [przydziały dla transportu](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-158">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span></span>  
  
### <a name="hashtable-vulnerability"></a><span data-ttu-id="a0bda-159">HashTable luki w zabezpieczeniach</span><span class="sxs-lookup"><span data-stu-id="a0bda-159">Hashtable Vulnerability</span></span>  
 <span data-ttu-id="a0bda-160">Usterka gdy kontraktów danych zawierają obiektach HashTable lub kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-160">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="a0bda-161">Problem występuje, jeśli wiele wartości są wstawiane do obiektu hashtable gdzie dużą liczbę tych wartości Generowanie taką samą wartość skrótu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-161">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="a0bda-162">Może być używany jako atak DOS.</span><span class="sxs-lookup"><span data-stu-id="a0bda-162">This can be used as a DOS attack.</span></span>  <span data-ttu-id="a0bda-163">Ta luka w zabezpieczeniach można zminimalizować przez ustawienie limitu przydziału powiązania MaxRecievedMessageSize.</span><span class="sxs-lookup"><span data-stu-id="a0bda-163">This vulnerability can be mitigated by setting the MaxRecievedMessageSize binding quota.</span></span> <span data-ttu-id="a0bda-164">Należy zachować ostrożność podczas ustawiania ten limit przydziału, aby zapobiec takim atakom.</span><span class="sxs-lookup"><span data-stu-id="a0bda-164">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="a0bda-165">Ten limit przydziału umieszcza górny limit rozmiaru wiadomości WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-165">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="a0bda-166">Ponadto należy unikać obiektach HashTable lub kolekcji w kontraktach sieci danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-166">Additionally, avoid using hashtables or collections in your data contracts.</span></span>  
  
## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="a0bda-167">Ograniczanie zużycia pamięci bez przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="a0bda-167">Limiting Memory Consumption Without Streaming</span></span>  
 <span data-ttu-id="a0bda-168">Model zabezpieczeń wokół dużych wiadomości zależy od tego, czy przesyłanie strumieniowe jest używana.</span><span class="sxs-lookup"><span data-stu-id="a0bda-168">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="a0bda-169">W przypadku podstawowych, z systemem innym niż strumieniowo komunikaty są buforowane do pamięci.</span><span class="sxs-lookup"><span data-stu-id="a0bda-169">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="a0bda-170">W takim przypadku należy użyć <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> przydziału na <xref:System.ServiceModel.Channels.TransportBindingElement> lub na wiązania dostarczane przez system, aby zapewnić ochronę przed dużych wiadomości przez ograniczenie maksymalny rozmiar wiadomości dostępu do.</span><span class="sxs-lookup"><span data-stu-id="a0bda-170">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="a0bda-171">Należy pamiętać, że usługi może przetwarzać wiele komunikatów w tym samym czasie, w którym to przypadku są w pamięci.</span><span class="sxs-lookup"><span data-stu-id="a0bda-171">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="a0bda-172">Funkcja ograniczania przepustowości umożliwia uniknięcie tego zagrożenia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-172">Use the throttling feature to mitigate this threat.</span></span>  
  
 <span data-ttu-id="a0bda-173">Należy również zauważyć, że `MaxReceivedMessageSize` nie umieścić górna granica na wiadomości zużycie pamięci, ale ogranicza ją do wewnątrz stały wskaźnik.</span><span class="sxs-lookup"><span data-stu-id="a0bda-173">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="a0bda-174">Na przykład jeśli `MaxReceivedMessageSize` to 1 MB i 1 MB wiadomość zostanie odebrana, a następnie zdeserializowany, dodatkowe pamięci jest muszą zawierać wykres obiektu po deserializacji, co spowoduje także zużycie całkowitej ilości pamięci ponad 1 MB.</span><span class="sxs-lookup"><span data-stu-id="a0bda-174">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="a0bda-175">Z tego powodu Unikaj tworzenia typów możliwych do serializacji, które może spowodować zmniejszenie zużycia pamięci znaczących bez dużą ilość przychodzących danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-175">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="a0bda-176">Na przykład kontraktu danych "MyContract" z polami elementu członkowskiego 50 opcjonalnymi danymi i dodatkowe 100 pól prywatnych mogła zostać utworzona z konstrukcji XML "\<MyContract / >".</span><span class="sxs-lookup"><span data-stu-id="a0bda-176">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="a0bda-177">Powoduje to XML w pamięci, do której uzyskuje dostęp do pola 150.</span><span class="sxs-lookup"><span data-stu-id="a0bda-177">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="a0bda-178">Należy pamiętać, że elementy członkowskie danych są opcjonalne domyślnie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-178">Note that data members are optional by default.</span></span> <span data-ttu-id="a0bda-179">Problem jest rozliczana, jeśli taki typ jest częścią tablicy.</span><span class="sxs-lookup"><span data-stu-id="a0bda-179">The problem is compounded when such a type is part of an array.</span></span>  
  
 <span data-ttu-id="a0bda-180">`MaxReceivedMessageSize` samodzielnie nie jest wystarczająco przed atakami typu "odmowa usługi" wszystkie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-180">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="a0bda-181">Na przykład Deserializator może wymusić rozszeregować wykresu obiektu głęboko zagnieżdżone (obiekt, który zawiera inny obiekt, który zawiera jeszcze inną i tak dalej) komunikatu przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-181">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="a0bda-182">Zarówno <xref:System.Runtime.Serialization.DataContractSerializer> i <xref:System.Xml.Serialization.XmlSerializer> wywoływać metod w sposób zagnieżdżony do deserializacji takie wykresy.</span><span class="sxs-lookup"><span data-stu-id="a0bda-182">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="a0bda-183">Głębokiego zagnieżdżenia wywołań metody mogą spowodować nieodwracalny <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-183">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="a0bda-184">To zagrożenie jest skorygowane przez ustawienie <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> przydziału, aby ograniczyć poziom zagnieżdżenia XML, zgodnie z opisem w sekcji "Przy użyciu bezpiecznie XML" w dalszej części tematu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-184">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>  
  
 <span data-ttu-id="a0bda-185">Ustawianie przydziałów dodatkowe `MaxReceivedMessageSize` jest szczególnie ważne w przypadku przy użyciu kodowania binarnego XML.</span><span class="sxs-lookup"><span data-stu-id="a0bda-185">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="a0bda-186">Przy użyciu kodowania binarnego odpowiada nieco kompresji: dla niewielkiej liczby bajtów w komunikacie przychodzącym może reprezentować dużą ilość danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-186">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="a0bda-187">W związku z tym nawet komunikat dopasowane do `MaxReceivedMessageSize` limit może trwać znacznie większej ilości pamięci w postaci rozwinięty.</span><span class="sxs-lookup"><span data-stu-id="a0bda-187">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="a0bda-188">Ograniczających zagrożenia takie specyficzne dla XML, wszystkie przydziały czytnika XML muszą być ustawione poprawnie, zgodnie z opisem w sekcji "Przy użyciu bezpiecznie XML" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-188">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>  
  
## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="a0bda-189">Ograniczanie zużycia pamięci z przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="a0bda-189">Limiting Memory Consumption with Streaming</span></span>  
 <span data-ttu-id="a0bda-190">Podczas przesyłania strumieniowego, mogą używać małych `MaxReceivedMessageSize` ustawienie, aby zapewnić ochronę przed atakami typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="a0bda-190">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="a0bda-191">Jednak bardziej złożonych zadań są możliwe w przypadku przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-191">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="a0bda-192">Na przykład usługi przekazywania plików akceptuje pliki o rozmiarze większym niż całą dostępną pamięć.</span><span class="sxs-lookup"><span data-stu-id="a0bda-192">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="a0bda-193">W takim przypadku należy ustawić `MaxReceivedMessageSize` bardzo dużą wartość oczekiwano, że prawie żadne dane są buforowane w pamięci i komunikat strumieni bezpośrednio na dysku.</span><span class="sxs-lookup"><span data-stu-id="a0bda-193">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="a0bda-194">Jeśli niebezpiecznej wiadomości do buforu danych zamiast przesyłania strumieniowego w takim przypadku można wymusić jakiś sposób WCF `MaxReceivedMessageSize` nie chroni przed komunikat podczas uzyskiwania dostępu do całej dostępnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="a0bda-194">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>  
  
 <span data-ttu-id="a0bda-195">Aby osłabić to zagrożenie, ustawień określonych zasobów istnieje w różnych składników przetwarzania danych WCF tego limitu buforowania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-195">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="a0bda-196">Najważniejsze z nich jest `MaxBufferSize` właściwości na różne elementy powiązania transportu i standardowe powiązania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-196">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="a0bda-197">Podczas przesyłania strumieniowego, należy ustawić ten limit przydziału, biorąc pod uwagę maksymalną ilość pamięci, którą można przydzielić na jeden komunikat.</span><span class="sxs-lookup"><span data-stu-id="a0bda-197">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="a0bda-198">Jak `MaxReceivedMessageSize`, ustawienie wstawiają absolutny zużycie pamięci, ale tylko ogranicza ją do wewnątrz stały wskaźnik.</span><span class="sxs-lookup"><span data-stu-id="a0bda-198">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="a0bda-199">Ponadto jako z `MaxReceivedMessageSize`, należy pamiętać o możliwości wiele komunikatów przetwarzanych jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-199">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>  
  
### <a name="maxbuffersize-details"></a><span data-ttu-id="a0bda-200">Szczegóły MaxBufferSize</span><span class="sxs-lookup"><span data-stu-id="a0bda-200">MaxBufferSize Details</span></span>  
 <span data-ttu-id="a0bda-201">`MaxBufferSize` Właściwość ogranicza żadnych zbiorczego jest buforowania WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-201">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="a0bda-202">Na przykład WCF zawsze buforuje nagłówki SOAP i błędach SOAP, a także żadnych części MIME się nie być w kolejności odczytywania fizycznych w komunikat mechanizmu optymalizacji transmisji wiadomości (MTOM).</span><span class="sxs-lookup"><span data-stu-id="a0bda-202">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="a0bda-203">To ustawienie pozwala ograniczyć ilość buforowanie we wszystkich tych przypadkach.</span><span class="sxs-lookup"><span data-stu-id="a0bda-203">This setting limits the amount of buffering in all these cases.</span></span>  
  
 <span data-ttu-id="a0bda-204">Usługi WCF rozwiązanie to przekazywanie `MaxBufferSize` wartość różne składniki, które mogą buforować.</span><span class="sxs-lookup"><span data-stu-id="a0bda-204">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="a0bda-205">Na przykład niektóre <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads z <xref:System.ServiceModel.Channels.Message> podjęcia klasy `maxSizeOfHeaders` parametru.</span><span class="sxs-lookup"><span data-stu-id="a0bda-205">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="a0bda-206">Przekazuje WCF `MaxBufferSize` wartość tego parametru, aby ograniczyć ilość buforowanie nagłówka SOAP.</span><span class="sxs-lookup"><span data-stu-id="a0bda-206">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="a0bda-207">Ważne jest, aby ustawić wartość tego parametru, gdy usługi <xref:System.ServiceModel.Channels.Message> bezpośrednio klasa.</span><span class="sxs-lookup"><span data-stu-id="a0bda-207">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="a0bda-208">Ogólnie rzecz biorąc gdy składnik programu WCF, która przyjmuje parametry przydziału, należy zrozumieć ryzyko związane z tych parametrów i poprawnie ustawiona.</span><span class="sxs-lookup"><span data-stu-id="a0bda-208">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>  
  
 <span data-ttu-id="a0bda-209">Koder komunikatu MTOM ma również `MaxBufferSize` ustawienie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-209">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="a0bda-210">Podczas korzystania z wiązania standardowa, to ma wartość automatycznie na poziomie transportu `MaxBufferSize` wartość.</span><span class="sxs-lookup"><span data-stu-id="a0bda-210">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="a0bda-211">Jednak podczas tworzenia niestandardowego powiązania za pomocą elementu powiązania koder komunikatu MTOM, ważne jest, aby ustawić `MaxBufferSize` jest używana właściwość na wartość bezpieczne podczas przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-211">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>  
  
## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="a0bda-212">Oparte na języku XML ataków przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="a0bda-212">XML-Based Streaming Attacks</span></span>  
 <span data-ttu-id="a0bda-213">`MaxBufferSize` samodzielnie jest niewystarczająca do zapewnienia, że nie można wymusić WCF do buforowania, gdy przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-213">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="a0bda-214">Na przykład czytników WCF XML zawsze bufor całego tagu początkowym elementu XML, podczas uruchamiania odczytać nowego elementu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-214">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="a0bda-215">Można to zrobić, aby poprawnie przetworzyć obszary nazw i atrybuty.</span><span class="sxs-lookup"><span data-stu-id="a0bda-215">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="a0bda-216">Jeśli `MaxReceivedMessageSize` jest skonfigurowana za duży (na przykład, aby włączyć dużego pliku bezpośrednio do dysku przesyłania strumieniowego scenariusz), niebezpiecznej wiadomości mogą być zbudowane z treści cały komunikat w przypadku dużych tagu początkowym elementu XML.</span><span class="sxs-lookup"><span data-stu-id="a0bda-216">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="a0bda-217">Próba odczytu go powoduje <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-217">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="a0bda-218">Jest to jedna z wielu opartych na języku XML typu "odmowa usługi" ataki których wszystkie można zminimalizować przy użyciu przydziały czytnika XML, omówionych w sekcji "Przy użyciu bezpiecznie XML" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-218">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="a0bda-219">Podczas przesyłania strumieniowego, jest szczególnie ważne wszystkie te przydziały.</span><span class="sxs-lookup"><span data-stu-id="a0bda-219">When streaming, it is especially important to set all of these quotas.</span></span>  
  
### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="a0bda-220">Mieszanie przesyłania strumieniowego i buforowanie modele programowania</span><span class="sxs-lookup"><span data-stu-id="a0bda-220">Mixing Streaming and Buffering Programming Models</span></span>  
 <span data-ttu-id="a0bda-221">Wiele możliwych ataków wynikają z mieszanie przesyłania strumieniowego i strumieniowo modele programowania, w tej samej usługi.</span><span class="sxs-lookup"><span data-stu-id="a0bda-221">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="a0bda-222">Załóżmy, że istnieje kontraktu usługi z dwóch operacji: wyższy <xref:System.IO.Stream> i inny pobiera tablicę pewnego typu niestandardowego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-222">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="a0bda-223">Załóżmy również, że `MaxReceivedMessageSize` jest ustawiona na dużą wartość umożliwiające pierwszej operacji przetwarzania dużych strumieni.</span><span class="sxs-lookup"><span data-stu-id="a0bda-223">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="a0bda-224">Niestety oznacza to, że dużych wiadomości mogą teraz być wysyłane do druga operacja również i Deserializator danych buforów w pamięci jako tablica przed wywołaniem operacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-224">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="a0bda-225">Jest to potencjalny atak typu "odmowa usługi": `MaxBufferSize` limitu przydziału nie istnieje limit rozmiaru treści wiadomości, czyli Deserializator współpracuje z.</span><span class="sxs-lookup"><span data-stu-id="a0bda-225">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>  
  
 <span data-ttu-id="a0bda-226">Z tego powodu należy unikać mieszanie operacje na podstawie strumienia i strumieniowo w tym samym kontrakcie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-226">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="a0bda-227">Należy bezwzględnie mieszać dwa modele programowania, należy użyć następujących kroków:</span><span class="sxs-lookup"><span data-stu-id="a0bda-227">If you absolutely must mix the two programming models, use the following precautions:</span></span>  
  
-   <span data-ttu-id="a0bda-228">Wyłącz <xref:System.Runtime.Serialization.IExtensibleDataObject> funkcji przez ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> właściwość <xref:System.ServiceModel.ServiceBehaviorAttribute> do `true`.</span><span class="sxs-lookup"><span data-stu-id="a0bda-228">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="a0bda-229">Dzięki temu, że rozszeregować są tylko elementy członkowskie, które są częścią kontraktu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-229">This ensures that only members that are a part of the contract are deserialized.</span></span>  
  
-   <span data-ttu-id="a0bda-230">Ustaw <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> właściwość <xref:System.Runtime.Serialization.DataContractSerializer> bezpieczne wartości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-230">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="a0bda-231">Ten przydział jest również dostępna w <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu lub przy użyciu konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-231">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="a0bda-232">Ten limit przydziału ogranicza liczbę obiektów, które są rozszeregować w jednym epizodu deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-232">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="a0bda-233">Zwykle każda operacja parametru lub wiadomości część treści kontraktu komunikatu jest rozszeregować w jeden odcinek.</span><span class="sxs-lookup"><span data-stu-id="a0bda-233">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="a0bda-234">Podczas deserializacji tablic, każdego wpisu tablicy jest traktowany jako oddzielny obiekt.</span><span class="sxs-lookup"><span data-stu-id="a0bda-234">When deserializing arrays, each array entry is counted as a separate object.</span></span>  
  
-   <span data-ttu-id="a0bda-235">Ustaw wszystkie przydziały czytnika XML bezpieczne wartości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-235">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="a0bda-236">Należy zwrócić uwagę na <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, i <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> i uniknąć ciągów w operacjach strumieniowo.</span><span class="sxs-lookup"><span data-stu-id="a0bda-236">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>  
  
-   <span data-ttu-id="a0bda-237">Przejrzyj listę znanych typów, z uwzględnieniem, że jeden z nich można wdrożyć w dowolnym momencie (zobacz sekcję "Uniemożliwia niezamierzone typy z ładowany" w dalszej części tego tematu).</span><span class="sxs-lookup"><span data-stu-id="a0bda-237">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>  
  
-   <span data-ttu-id="a0bda-238">Nie używaj żadnych typów, które implementują <xref:System.Xml.Serialization.IXmlSerializable> interfejs, który buforu dużą ilość danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-238">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="a0bda-239">Nie dodawaj takich typów do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-239">Do not add such types to the list of known types.</span></span>  
  
-   <span data-ttu-id="a0bda-240">Nie używaj <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> tablic, <xref:System.Byte> stałych lub typy, które implementują <xref:System.Runtime.Serialization.ISerializable> w umowie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-240">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>  
  
-   <span data-ttu-id="a0bda-241">Nie używaj <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> tablic, <xref:System.Byte> stałych lub typy, które implementują <xref:System.Runtime.Serialization.ISerializable> listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-241">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>  
  
 <span data-ttu-id="a0bda-242">Zastosuj poprzednich kroków, gdy operacja strumieniowo używa <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-242">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="a0bda-243">Nigdy nie łączyć przesyłania strumieniowego i programowania strumieniowo modeli na tej samej usługi, jeśli używasz <xref:System.Xml.Serialization.XmlSerializer>, ponieważ nie ma ochrony <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> przydziału.</span><span class="sxs-lookup"><span data-stu-id="a0bda-243">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>  
  
### <a name="slow-stream-attacks"></a><span data-ttu-id="a0bda-244">Ataki wolne strumienia</span><span class="sxs-lookup"><span data-stu-id="a0bda-244">Slow Stream Attacks</span></span>  
 <span data-ttu-id="a0bda-245">Klasa przesyłania strumieniowego ataków typu "odmowa usługi" nie jest związana zużycie pamięci.</span><span class="sxs-lookup"><span data-stu-id="a0bda-245">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="a0bda-246">Zamiast tego ataku obejmuje powolne nadawcy lub odbiornika danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-246">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="a0bda-247">Podczas oczekiwania na dane do wysłania lub odebrania, wyczerpania zasobów, takich jak dostępnych połączeń i wątków.</span><span class="sxs-lookup"><span data-stu-id="a0bda-247">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="a0bda-248">Taka sytuacja może powstać wyniku złośliwymi atakami lub z wiarygodnego nadawcy/odbiorcy w powolne połączenie sieciowe.</span><span class="sxs-lookup"><span data-stu-id="a0bda-248">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>  
  
 <span data-ttu-id="a0bda-249">Aby uniknąć tego rodzaju ataki, prawidłowo limity czasu transportu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-249">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="a0bda-250">Aby uzyskać więcej informacji, zobacz [przydziały dla transportu](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-250">For more information, see [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span></span> <span data-ttu-id="a0bda-251">Po drugie, nigdy nie używaj synchroniczne `Read` lub `Write` operacje podczas pracy ze strumieni w programie WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-251">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>  
  
## <a name="using-xml-safely"></a><span data-ttu-id="a0bda-252">Bezpiecznie za pomocą XML</span><span class="sxs-lookup"><span data-stu-id="a0bda-252">Using XML Safely</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0bda-253">Mimo że ta sekcja opisuje XML informacje mają zastosowanie również do dokumentów JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="a0bda-253">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="a0bda-254">Przydziały działają podobnie, za pomocą [mapowanie między formatami JSON i XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-254">The quotas work similarly, using [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
### <a name="secure-xml-readers"></a><span data-ttu-id="a0bda-255">Zabezpieczanie czytników XML</span><span class="sxs-lookup"><span data-stu-id="a0bda-255">Secure XML Readers</span></span>  
 <span data-ttu-id="a0bda-256">XML typu infoset sprawdzonych stanowi podstawę przetwarzania wszystkich komunikatów w programie WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-256">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="a0bda-257">Gdy istnieje odbierać dane XML z niezaufanego źródła, kilka możliwości ataku typu "odmowa usługi" który musi skorygowane.</span><span class="sxs-lookup"><span data-stu-id="a0bda-257">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="a0bda-258">Usługi WCF zawiera specjalne, bezpieczne czytników XML.</span><span class="sxs-lookup"><span data-stu-id="a0bda-258">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="a0bda-259">Takie czytniki są tworzone automatycznie podczas przy użyciu jednej kodowań standardowe w programie WCF (tekst, binary lub MTOM).</span><span class="sxs-lookup"><span data-stu-id="a0bda-259">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>  
  
 <span data-ttu-id="a0bda-260">Niektóre z funkcji zabezpieczeń na tych czytników zawsze są aktywne.</span><span class="sxs-lookup"><span data-stu-id="a0bda-260">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="a0bda-261">Na przykład czytników nigdy nie przetworzył definicji typu dokumentu (pliki DTD), które są źródłem potencjalnych ataków typu "odmowa usługi" i nigdy nie powinna być widoczna w uzasadnionych wiadomości SOAP.</span><span class="sxs-lookup"><span data-stu-id="a0bda-261">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="a0bda-262">Inne funkcje zabezpieczeń obejmują przydziały czytnika, które muszą być skonfigurowane, które zostały opisane w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-262">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>  
  
 <span data-ttu-id="a0bda-263">Podczas pracy bezpośrednio z czytników XML (takich jak podczas pisania niestandardowego kodera lub podczas pracy bezpośrednio z <xref:System.ServiceModel.Channels.Message> klasy), zawsze używali czytników bezpiecznego WCF, gdy istnieje ryzyko, pracy z niezaufanych danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-263">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="a0bda-264">Tworzenie bezpiecznej czytników przez wywoływania statycznych fabryki przeciążenia metody <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, lub <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> na <xref:System.Xml.XmlDictionaryReader> klasy.</span><span class="sxs-lookup"><span data-stu-id="a0bda-264">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="a0bda-265">Podczas tworzenia modułu odczytującego, podaj wartości bezpiecznych zasobów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-265">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="a0bda-266">Nie wywołuj `Create` przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="a0bda-266">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="a0bda-267">Nie twórz te czytnik WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-267">These do not create a WCF reader.</span></span> <span data-ttu-id="a0bda-268">Zamiast tego czytnika jest tworzony, który nie jest chroniony przez funkcje zabezpieczeń opisanych w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-268">Instead, a reader is created that is not protected by the security features described in this section.</span></span>  
  
### <a name="reader-quotas"></a><span data-ttu-id="a0bda-269">Przydziały czytnika</span><span class="sxs-lookup"><span data-stu-id="a0bda-269">Reader Quotas</span></span>  
 <span data-ttu-id="a0bda-270">Bezpieczne czytników XML ma pięć można konfigurować przydziały.</span><span class="sxs-lookup"><span data-stu-id="a0bda-270">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="a0bda-271">Te są zwykle konfigurowane za pomocą `ReaderQuotas` właściwości na elementy powiązania kodowania lub standardowe powiązania lub przy użyciu <xref:System.Xml.XmlDictionaryReaderQuotas> podczas tworzenia modułu odczytującego został przekazany pusty obiekt.</span><span class="sxs-lookup"><span data-stu-id="a0bda-271">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>  
  
#### <a name="maxbytesperread"></a><span data-ttu-id="a0bda-272">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="a0bda-272">MaxBytesPerRead</span></span>  
 <span data-ttu-id="a0bda-273">Ten limit przydziału ogranicza liczbę bajtów, które są odczytywane w jednej `Read` operacji podczas odczytywania elementu start tagu i jego atrybuty.</span><span class="sxs-lookup"><span data-stu-id="a0bda-273">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="a0bda-274">(W przypadku strumieniowo, nazwa elementu jest pomijany względem limitu przydziału.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> jest istotne z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="a0bda-274">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>  
  
-   <span data-ttu-id="a0bda-275">Nazwy elementu i jego atrybuty zawsze są buforowane w pamięci, gdy są odczytywane.</span><span class="sxs-lookup"><span data-stu-id="a0bda-275">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="a0bda-276">Dlatego jest ważne, aby ustawić ten limit przydziału prawidłowo w trybie, aby uniknąć nadmiernego buforowania, gdy przesyłania strumieniowego strumieniowym.</span><span class="sxs-lookup"><span data-stu-id="a0bda-276">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="a0bda-277">Zobacz `MaxDepth` przydziału sekcji informacji o rzeczywista ilość buforowanie ma miejsce.</span><span class="sxs-lookup"><span data-stu-id="a0bda-277">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>  
  
-   <span data-ttu-id="a0bda-278">O zbyt wiele atrybutów XML posłużyć nieproporcjonalnie czasu przetwarzania ponieważ nazwy atrybutów muszą być sprawdzane pod kątem unikatowości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-278">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="a0bda-279">`MaxBytesPerRead` zmniejsza zagrożenie tego typu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-279">`MaxBytesPerRead` mitigates this threat.</span></span>  
  
#### <a name="maxdepth"></a><span data-ttu-id="a0bda-280">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="a0bda-280">MaxDepth</span></span>  
 <span data-ttu-id="a0bda-281">Ten limit przydziału ogranicza maksymalną głębokość zagnieżdżenia elementów XML.</span><span class="sxs-lookup"><span data-stu-id="a0bda-281">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="a0bda-282">Na przykład dokument "\<A >\<B >\<C / >\</B >\</A >" głębokość zagnieżdżenia trzech.</span><span class="sxs-lookup"><span data-stu-id="a0bda-282">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="a0bda-283"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> ważne jest, z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="a0bda-283"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>  
  
-   <span data-ttu-id="a0bda-284">`MaxDepth` współdziała z `MaxBytesPerRead`: czytnik zawsze przechowuje dane w pamięci dla bieżącego elementu i wszystkich jego obiektów nadrzędnych, więc zużycie pamięci maksymalnej czytnika danych jest proporcjonalny do wyniku te dwa ustawienia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-284">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>  
  
-   <span data-ttu-id="a0bda-285">Podczas deserializacji wykresu obiektu głęboko zagnieżdżone, Deserializator wymusza na dostęp do całego stosu i zgłosić nieodwracalny <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-285">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="a0bda-286">Bezpośrednie korelacji istnieje między zagnieżdżenia XML i zagnieżdżenia obiektu dla obu <xref:System.Runtime.Serialization.DataContractSerializer> i <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-286">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="a0bda-287">Użyj `MaxDepth` Aby osłabić to zagrożenie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-287">Use `MaxDepth` to mitigate this threat.</span></span>  
  
#### <a name="maxnametablecharcount"></a><span data-ttu-id="a0bda-288">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="a0bda-288">MaxNameTableCharCount</span></span>  
 <span data-ttu-id="a0bda-289">Ten limit przydziału ogranicza rozmiar czytelnika *niepowtarzającymi*.</span><span class="sxs-lookup"><span data-stu-id="a0bda-289">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="a0bda-290">Niepowtarzającymi zawiera niektóre ciągi (takie jak obszary nazw i prefiksy) napotkanych podczas przetwarzania dokumentu XML.</span><span class="sxs-lookup"><span data-stu-id="a0bda-290">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="a0bda-291">Jak te ciągi są buforowane w pamięci, należy ustawić ten limit przydziału, aby uniknąć nadmiernego buforowania, gdy przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-291">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>  
  
#### <a name="maxstringcontentlength"></a><span data-ttu-id="a0bda-292">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="a0bda-292">MaxStringContentLength</span></span>  
 <span data-ttu-id="a0bda-293">Ten limit przydziału ogranicza maksymalny rozmiar ciągu zwracające modułu odczytującego XML.</span><span class="sxs-lookup"><span data-stu-id="a0bda-293">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="a0bda-294">Ten limit przydziału nie ogranicza zużycie pamięci w samej modułu odczytującego XML, ale w składniku korzystający z czytnika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-294">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="a0bda-295">Na przykład, jeśli <xref:System.Runtime.Serialization.DataContractSerializer> używa czytnika zabezpieczone przy użyciu <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, nie wykonać deserializacji ciągów przekracza ten limit przydziału.</span><span class="sxs-lookup"><span data-stu-id="a0bda-295">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="a0bda-296">Korzystając z <xref:System.Xml.XmlDictionaryReader> bezpośrednio, klasa nie wszystkie metody względem ten limit przydziału, ale tylko metody, które są specjalnie zaprojektowane do odczytu ciągów, takich jak <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a0bda-296">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="a0bda-297"><xref:System.Xml.XmlReader.Value%2A> Właściwość czytnik nie ma wpływu na ten limit przydziału i w związku z tym nie należy używać podczas ochrony zawiera ten przydział jest konieczne.</span><span class="sxs-lookup"><span data-stu-id="a0bda-297">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>  
  
#### <a name="maxarraylength"></a><span data-ttu-id="a0bda-298">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="a0bda-298">MaxArrayLength</span></span>  
 <span data-ttu-id="a0bda-299">Ten limit przydziału ogranicza maksymalny rozmiar to tablica wartości pierwotnych, które zwraca modułu odczytującego XML, łącznie z tablic bajtowych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-299">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="a0bda-300">Ten limit przydziału nie ogranicza zużycie pamięci w samej modułu odczytującego XML, ale niezależnie od składnika korzystający z czytnika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-300">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="a0bda-301">Na przykład, jeśli <xref:System.Runtime.Serialization.DataContractSerializer> używa czytnika zabezpieczone przy użyciu <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, nie wykonać deserializacji tablice typu byte przekracza ten limit przydziału.</span><span class="sxs-lookup"><span data-stu-id="a0bda-301">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="a0bda-302">Należy ustawić ten limit przydziału, podczas próby mieszać modele programowania przesyłania strumieniowego i buforowane w jednej umowy.</span><span class="sxs-lookup"><span data-stu-id="a0bda-302">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="a0bda-303">Należy pamiętać, że przy użyciu <xref:System.Xml.XmlDictionaryReader> klas, metod, które są specjalnie zaprojektowane do odczytu tablice dowolnego rozmiar niektórych typów pierwotnych, takich jak <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, przestrzegać tego limitu przydziału.</span><span class="sxs-lookup"><span data-stu-id="a0bda-303">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>  
  
## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="a0bda-304">Zagrożenia specyficzne dla kodowania binarnego</span><span class="sxs-lookup"><span data-stu-id="a0bda-304">Threats Specific to the Binary Encoding</span></span>  
 <span data-ttu-id="a0bda-305">Obejmuje Binarny XML, kodowania obsługuje WCF *słownika ciągów* funkcji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-305">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="a0bda-306">Ciąg dużych może zostać zakodowany przy użyciu tylko kilka bajtów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-306">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="a0bda-307">Włącza znaczący wzrost wydajności, ale wprowadza nowych zagrożeń typu "odmowa usługi", które muszą zostać skorygowane.</span><span class="sxs-lookup"><span data-stu-id="a0bda-307">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>  
  
 <span data-ttu-id="a0bda-308">Istnieją dwa rodzaje słowniki: *statycznych* i *dynamiczne*.</span><span class="sxs-lookup"><span data-stu-id="a0bda-308">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="a0bda-309">Słowniku statycznym przedstawiono listę wbudowanych długich ciągów, które mogą być reprezentowane przy użyciu krótkich kodu przy użyciu kodowania binarnego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-309">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="a0bda-310">Ta lista ciągów zostanie rozwiązany, gdy czytnik jest tworzony i nie może być modyfikowany.</span><span class="sxs-lookup"><span data-stu-id="a0bda-310">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="a0bda-311">Żaden ciągów w słowniku statycznym, która domyślnie używa usług WCF nie jest wystarczająco duży, aby stwarzać poważne zagrożenie typu "odmowa usługi", mimo że nadal mogą ich używać w atak słownikowy rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-311">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="a0bda-312">W zaawansowanych scenariuszach, w którym podać własne słowniku statycznym należy zachować ostrożność, wprowadzając Duży słownik ciągów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-312">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>  
  
 <span data-ttu-id="a0bda-313">Funkcja dynamicznej słowniki pozwala definiować własne ciągów i skojarzyć je z krótkich kodów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-313">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="a0bda-314">Te mapowania kod ciągu są przechowywane w pamięci podczas sesji całej komunikacji kolejne komunikaty nie trzeba ponownie wysłać ciągi i może korzystać z kodów, które zostały już zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="a0bda-314">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="a0bda-315">Te parametry mogą być o dowolnej długości i w związku z tym stanowiących zagrożenie poważniejsze niż w słowniku statycznym.</span><span class="sxs-lookup"><span data-stu-id="a0bda-315">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>  
  
 <span data-ttu-id="a0bda-316">Pierwszy zagrożenie, które muszą zostać skorygowane, jest możliwość dynamiczny słownik (tabeli mapowania kod ciągu) za duży.</span><span class="sxs-lookup"><span data-stu-id="a0bda-316">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="a0bda-317">W ciągu kilku wiadomości, można rozwinąć ten słownik i dlatego element `MaxReceivedMessageSize` przydziału oferuje nie ochrony, ponieważ jest stosowany tylko do każdej wiadomości osobno.</span><span class="sxs-lookup"><span data-stu-id="a0bda-317">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="a0bda-318">W związku z tym oddzielnej <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> właściwość istnieje na <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> , która ogranicza rozmiar słownika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-318">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>  
  
 <span data-ttu-id="a0bda-319">W przeciwieństwie do większości innych przydziały ten przydział ma również zastosowanie podczas zapisywania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-319">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="a0bda-320">Jeśli zostanie przekroczony limit podczas czytania wiadomości, `QuotaExceededException` jest zgłaszany w zwykły sposób.</span><span class="sxs-lookup"><span data-stu-id="a0bda-320">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="a0bda-321">Jeśli zostanie przekroczony limit podczas pisania wiadomości, wszelkie ciągi, które spowodować przekroczenie limitu przydziału są zapisywane jako — jest bez korzystania z funkcji dynamicznego słownika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-321">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>  
  
### <a name="dictionary-expansion-threats"></a><span data-ttu-id="a0bda-322">Słownik rozszerzenia zagrożeń</span><span class="sxs-lookup"><span data-stu-id="a0bda-322">Dictionary Expansion Threats</span></span>  
 <span data-ttu-id="a0bda-323">Znaczące klasy specyficzne dla danych binarnych ataków wynika z rozszerzenia słownika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-323">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="a0bda-324">Mała wiadomości w formacie binarnym może przekształcić w bardzo dużych komunikatów w postaci tekstowej rozwinięty Jeśli zwiększone użycie funkcji słowniki ciągu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-324">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="a0bda-325">Współczynnik rozszerzania dla ciągów dynamiczny słownik jest ograniczona przez <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> przydziału, ponieważ ciąg dynamiczny słownik nie przekracza maksymalny rozmiar całego słownika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-325">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>  
  
 <span data-ttu-id="a0bda-326"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, I `MaxArrayLength` właściwości jedynie ograniczyć zużycie pamięci.</span><span class="sxs-lookup"><span data-stu-id="a0bda-326">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="a0bda-327">Zwykle nie są wymagane ograniczających wszelkie zagrożenia wykorzystania strumieniowo, ponieważ użycie pamięci jest już ograniczone przez `MaxReceivedMessageSize`.</span><span class="sxs-lookup"><span data-stu-id="a0bda-327">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="a0bda-328">Jednak `MaxReceivedMessageSize` liczby bajtów wstępne rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-328">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="a0bda-329">Podczas kodowania binarnego jest używany, użycie pamięci może potencjalnie wykracza poza `MaxReceivedMessageSize`, jest ograniczona tylko przez współczynnik <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-329">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="a0bda-330">Dlatego jest ważne, aby zawsze ustawić wszystkie przydziały czytnika (szczególnie <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) przy użyciu kodowania binarnego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-330">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>  
  
 <span data-ttu-id="a0bda-331">Korzystając z kodowanie binarne razem z <xref:System.Runtime.Serialization.DataContractSerializer>, `IExtensibleDataObject` precyzyjnym interfejsu do zainstalowania na ataki słownikowe rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-331">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="a0bda-332">Ten interfejs zasadniczo zapewnia nieograniczony magazyn dla dowolne dane, które nie jest częścią kontraktu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-332">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="a0bda-333">Jeśli przydziały nie można ustawić na tyle niskie, tak, aby `MaxSessionSize` pomnożona przez `MaxReceivedMessageSize` nie stanowić problem, wyłącz `IExtensibleDataObject` funkcji przy użyciu kodowania binarnego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-333">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="a0bda-334">Ustaw `IgnoreExtensionDataObject` właściwości `true` na `ServiceBehaviorAttribute` atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-334">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="a0bda-335">Możesz też implementuje `IExtensibleDataObject` interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-335">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="a0bda-336">Aby uzyskać więcej informacji, zobacz [kontrakty danych zgodne z nowszymi](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-336">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span>  
  
### <a name="quotas-summary"></a><span data-ttu-id="a0bda-337">Podsumowanie przydziałów</span><span class="sxs-lookup"><span data-stu-id="a0bda-337">Quotas Summary</span></span>  
 <span data-ttu-id="a0bda-338">W poniższej tabeli przedstawiono wskazówki dotyczące przydziałów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-338">The following table summarizes the guidance about quotas.</span></span>  
  
|<span data-ttu-id="a0bda-339">Warunek</span><span class="sxs-lookup"><span data-stu-id="a0bda-339">Condition</span></span>|<span data-ttu-id="a0bda-340">Przydziały ważne, aby ustawić</span><span class="sxs-lookup"><span data-stu-id="a0bda-340">Important quotas to set</span></span>|  
|---------------|-----------------------------|  
|<span data-ttu-id="a0bda-341">Brak przesyłania strumieniowego lub przesyłania strumieniowego małych komunikatów, tekst lub kodowanie MTOM</span><span class="sxs-lookup"><span data-stu-id="a0bda-341">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="a0bda-342">`MaxReceivedMessageSize`, `MaxBytesPerRead`, i `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="a0bda-342">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|  
|<span data-ttu-id="a0bda-343">Kodowanie nie przesyłania strumieniowego lub przesyłania strumieniowego małych komunikatów binarnych</span><span class="sxs-lookup"><span data-stu-id="a0bda-343">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="a0bda-344">`MaxReceivedMessageSize`, `MaxSessionSize`, a wszystkie `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="a0bda-344">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|  
|<span data-ttu-id="a0bda-345">Przesyłanie strumieniowe dużych wiadomości, tekst lub kodowanie MTOM</span><span class="sxs-lookup"><span data-stu-id="a0bda-345">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="a0bda-346">`MaxBufferSize` i wszystkie `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="a0bda-346">`MaxBufferSize` and all `ReaderQuotas`</span></span>|  
|<span data-ttu-id="a0bda-347">Kodowanie transmisji strumieniowej dużych wiadomości, binarne</span><span class="sxs-lookup"><span data-stu-id="a0bda-347">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="a0bda-348">`MaxBufferSize`, `MaxSessionSize`, a wszystkie `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="a0bda-348">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|  
  
-   <span data-ttu-id="a0bda-349">Limity czasu poziomu transportu zawsze musi być ustawiona i nigdy nie używaj synchroniczne odczyt/zapis podczas przesyłania strumieniowego jest w użyciu, niezależnie od tego, czy strumieniowo duże lub małe wiadomości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-349">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>  
  
-   <span data-ttu-id="a0bda-350">W razie wątpliwości dotyczące limit przydziału, należy ustawić na wartość bezpieczne, a nie pozostawić go otwórz.</span><span class="sxs-lookup"><span data-stu-id="a0bda-350">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>  
  
## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="a0bda-351">Uniemożliwia wykonanie złośliwego kodu</span><span class="sxs-lookup"><span data-stu-id="a0bda-351">Preventing Malicious Code Execution</span></span>  
 <span data-ttu-id="a0bda-352">Następujące klasy ogólne zagrożeń można wykonać kod i niezamierzone skutki:</span><span class="sxs-lookup"><span data-stu-id="a0bda-352">The following general classes of threats can execute code and have unintended effects:</span></span>  
  
-   <span data-ttu-id="a0bda-353">Deserializator ładuje typ złośliwego, niebezpieczne lub istotnych dla zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="a0bda-353">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>  
  
-   <span data-ttu-id="a0bda-354">Komunikat przychodzący powoduje deserializacji do utworzenia wystąpienia typu zwykle bezpieczne w taki sposób, który ma niezamierzone skutki.</span><span class="sxs-lookup"><span data-stu-id="a0bda-354">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>  
  
 <span data-ttu-id="a0bda-355">W poniższych sekcjach omówiono te klasy dalsze zagrożeń.</span><span class="sxs-lookup"><span data-stu-id="a0bda-355">The following sections discuss these classes of threats further.</span></span>  
  
## <a name="datacontractserializer"></a><span data-ttu-id="a0bda-356">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="a0bda-356">DataContractSerializer</span></span>  
 <span data-ttu-id="a0bda-357">(Aby uzyskać informacje o zabezpieczeniach <xref:System.Xml.Serialization.XmlSerializer>, zobacz stosowną dokumentację.) Model zabezpieczeń <xref:System.Xml.Serialization.XmlSerializer> jest podobny do <xref:System.Runtime.Serialization.DataContractSerializer>i różni się głównie w szczegółach.</span><span class="sxs-lookup"><span data-stu-id="a0bda-357">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="a0bda-358">Na przykład <xref:System.Xml.Serialization.XmlIncludeAttribute> atrybut służy do włączenia typu zamiast <xref:System.Runtime.Serialization.KnownTypeAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-358">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="a0bda-359">Jednak niektóre zagrożenia unikatowe dla <xref:System.Xml.Serialization.XmlSerializer> zostały omówione w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-359">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>  
  
### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="a0bda-360">Uniemożliwia niezamierzone typów ładowany</span><span class="sxs-lookup"><span data-stu-id="a0bda-360">Preventing Unintended Types from Being Loaded</span></span>  
 <span data-ttu-id="a0bda-361">Podczas ładowania typów niezamierzone może mieć znaczący wpływ, czy typ jest złośliwe lub po prostu ma efekty uboczne istotnych dla zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="a0bda-361">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="a0bda-362">Typem może zawierać luki w zabezpieczeniach kończona, akcje dotyczące zabezpieczeń w jego konstruktora lub konstruktora klasy, ma wpływ dużej ilości pamięci, który ułatwia ataków typu "odmowa usługi" lub może zgłaszać wyjątki nieodwracalny.</span><span class="sxs-lookup"><span data-stu-id="a0bda-362">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="a0bda-363">Typy mogą mieć konstruktorów klas, uruchamiane natychmiast po załadowaniu typ i przed utworzeniem wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-363">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="a0bda-364">Z tego względu należy kontrolować zestaw typów, które mogą ładować deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-364">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>  
  
 <span data-ttu-id="a0bda-365"><xref:System.Runtime.Serialization.DataContractSerializer> Deserializuje w sposób luźno powiązanych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-365">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="a0bda-366">Nigdy nie odczytuje wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR), typ i zestaw nazwy z przychodzących danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-366">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="a0bda-367">Jest to podobne do zachowania <xref:System.Xml.Serialization.XmlSerializer>, ale różni się od zachowania <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>i <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-367">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="a0bda-368">Luźne powiązanie wprowadza bezpieczeństwo, ponieważ zdalnej osobie atakującej nie może wskazywać dowolnego typu do ładowania tylko za pomocą nazw tego typu w komunikacie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-368">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>  
  
 <span data-ttu-id="a0bda-369"><xref:System.Runtime.Serialization.DataContractSerializer> Będzie można załadować typu, który obecnie jest oczekiwany zgodnie z umową.</span><span class="sxs-lookup"><span data-stu-id="a0bda-369">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="a0bda-370">Na przykład, jeśli element członkowski danych typu kontraktu danych `Customer`, <xref:System.Runtime.Serialization.DataContractSerializer> mogą ładować `Customer` typu po jego deserializuje ten element członkowski danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-370">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>  
  
 <span data-ttu-id="a0bda-371">Ponadto <xref:System.Runtime.Serialization.DataContractSerializer> obsługuje polimorfizm.</span><span class="sxs-lookup"><span data-stu-id="a0bda-371">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="a0bda-372">Element członkowski danych może być zadeklarowana jako <xref:System.Object>, ale może zawierać danych przychodzących `Customer` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-372">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="a0bda-373">Jest to możliwe tylko wtedy, gdy `Customer` typu złożonego "znane" do deserializacji za pomocą jednego z tych mechanizmów:</span><span class="sxs-lookup"><span data-stu-id="a0bda-373">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>  
  
-   <span data-ttu-id="a0bda-374"><xref:System.Runtime.Serialization.KnownTypeAttribute> Atrybut zastosowany do typu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-374"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>  
  
-   <span data-ttu-id="a0bda-375">`KnownTypeAttribute` atrybut określający metodę, która zwraca listę typów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-375">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>  
  
-   <span data-ttu-id="a0bda-376">`ServiceKnownTypeAttribute` atrybut.</span><span class="sxs-lookup"><span data-stu-id="a0bda-376">`ServiceKnownTypeAttribute` attribute.</span></span>  
  
-   <span data-ttu-id="a0bda-377">`KnownTypes` Sekcji konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-377">The `KnownTypes` configuration section.</span></span>  
  
-   <span data-ttu-id="a0bda-378">Lista znanych typów jawnie przekazany do <xref:System.Runtime.Serialization.DataContractSerializer> podczas konstruowania, jeśli bezpośrednio przy użyciu serializatora.</span><span class="sxs-lookup"><span data-stu-id="a0bda-378">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>  
  
 <span data-ttu-id="a0bda-379">Każdy z tych mechanizmów zwiększa prawdopodobieństwo dzięki zastosowaniu więcej typów, które można załadować deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-379">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="a0bda-380">Kontrolować każdy z tych mechanizmów, aby upewnić się, że żadne typy złośliwego bądź niepożądanego zostaną dodane do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-380">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>  
  
 <span data-ttu-id="a0bda-381">Po znanego typu w zakresie mogą być ładowane w dowolnym momencie i można było utworzyć wystąpienia typu, nawet wtedy, gdy kontrakt jest zabronione jest używana.</span><span class="sxs-lookup"><span data-stu-id="a0bda-381">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="a0bda-382">Załóżmy na przykład, "MyDangerousType" zostanie dodany do listy znanych typów, za pomocą jednego z powyższych mechanizmów typu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-382">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="a0bda-383">Oznacza to, że:</span><span class="sxs-lookup"><span data-stu-id="a0bda-383">This means that:</span></span>  
  
-   <span data-ttu-id="a0bda-384">`MyDangerousType` jest załadowany i jego uruchomieniem konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="a0bda-384">`MyDangerousType` is loaded and its class constructor runs.</span></span>  
  
-   <span data-ttu-id="a0bda-385">Nawet w przypadku deserializacji kontraktu danych z elementem członkowskim danych ciąg, niebezpiecznej wiadomości mogą spowodować wystąpienie `MyDangerousType` do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-385">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="a0bda-386">Kod w `MyDangerousType`, takich jak metody ustawiające właściwości, może uruchomić.</span><span class="sxs-lookup"><span data-stu-id="a0bda-386">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="a0bda-387">Po zakończeniu Deserializator spróbuje przypisać do elementu członkowskiego danych ciągu tego wystąpienia i zakończyć się niepowodzeniem z powodu wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a0bda-387">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>  
  
 <span data-ttu-id="a0bda-388">Podczas zapisywania metodę, która zwraca listy znanych typów lub podczas przekazywania bezpośrednio do listy <xref:System.Runtime.Serialization.DataContractSerializer> konstruktora, upewnij się, że kod, który przygotowuje listy jest bezpieczna i działa tylko z zaufanych danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-388">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>  
  
 <span data-ttu-id="a0bda-389">Określanie typów znane w konfiguracji, upewnij się, że plik konfiguracji jest bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="a0bda-389">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="a0bda-390">Zawsze używać silnych nazw w konfiguracji (przez określenie podpisem zestawu, w którym znajduje się typ klucza publicznego), ale nie określono wersji typu do załadowania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-390">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="a0bda-391">Moduł ładujący typ wybiera automatycznie najnowszą wersję, jeśli to możliwe.</span><span class="sxs-lookup"><span data-stu-id="a0bda-391">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="a0bda-392">Jeśli określisz określonej wersji w konfiguracji, uruchom następujące ryzyka: typ może mieć luki w zabezpieczeniach mogą rozwiązany w przyszłej wersji, ale wersja nadal ładuje, ponieważ został on jawnie określony w konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-392">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>  
  
 <span data-ttu-id="a0bda-393">O zbyt wiele znanych typów ma inny konsekwencji: <xref:System.Runtime.Serialization.DataContractSerializer> tworzy pamięć podręczną kodu serializacji/deserializacji w domenie aplikacji, wpis dla każdego typu musi serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-393">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="a0bda-394">Ta pamięć podręczna nie jest wyczyszczone, tak długo, jak działa domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-394">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="a0bda-395">W związku z tym osoba atakująca, która rozpoznaje, że aplikacja używa wielu znanych typów może spowodować deserializacji te typy, co powoduje pamięci podręcznej, aby wymagać nieproporcjonalnie dużej ilości pamięci.</span><span class="sxs-lookup"><span data-stu-id="a0bda-395">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>  
  
### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="a0bda-396">Uniemożliwia typy są w stanie niezamierzone</span><span class="sxs-lookup"><span data-stu-id="a0bda-396">Preventing Types from Being in an Unintended State</span></span>  
 <span data-ttu-id="a0bda-397">Typ może mieć ograniczenia wewnętrznego sprawdzania spójności, które muszą zostać wymuszone.</span><span class="sxs-lookup"><span data-stu-id="a0bda-397">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="a0bda-398">Należy uważać, aby uniknąć dzielenia tych warunków ograniczających podczas deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-398">Care must be taken to avoid breaking these constraints during deserialization.</span></span>  
  
 <span data-ttu-id="a0bda-399">Poniższy przykład typu reprezentuje stan śluzę na kosmicznego i wymusza ograniczenia, że zarówno wewnętrzne i zewnętrzne drzwi nie może zostać otwarty w tym samym czasie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-399">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>  
  
 [!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
 [!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]  
  
 <span data-ttu-id="a0bda-400">Osoba atakująca może wysłać złośliwy komunikat podobny do tego, poruszania się ograniczenia i uzyskanie obiektu w nieprawidłowym stanie, który może mieć konsekwencje niepożądanych i nieprzewidywalnych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-400">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>  
  
```xml  
<SpaceStationAirlock>  
    <innerDoorOpen>true</innerDoorOpen>  
    <outerDoorOpen>true</outerDoorOpen>  
</SpaceStationAirlock>  
```  
  
 <span data-ttu-id="a0bda-401">Można uniknąć tej sytuacji jest uwagę na następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="a0bda-401">This situation can be avoided by being aware of the following points:</span></span>  
  
-   <span data-ttu-id="a0bda-402">Gdy <xref:System.Runtime.Serialization.DataContractSerializer> deserializuje większość klas, konstruktory nie uruchamiaj.</span><span class="sxs-lookup"><span data-stu-id="a0bda-402">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="a0bda-403">W związku z tym nie należy polegać na wszelkie zarządzanie stanem wykonane w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="a0bda-403">Therefore, do not rely on any state management done in the constructor.</span></span>  
  
-   <span data-ttu-id="a0bda-404">Wywołania zwrotne umożliwia upewnij się, że obiekt jest w nieprawidłowym stanie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-404">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="a0bda-405">Wywołanie zwrotne oznaczonych <xref:System.Runtime.Serialization.OnDeserializedAttribute> atrybut jest szczególnie przydatne, ponieważ jest uruchamiana po deserializacji została zakończona i możliwością Sprawdź i popraw ogólny stan.</span><span class="sxs-lookup"><span data-stu-id="a0bda-405">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="a0bda-406">Aby uzyskać więcej informacji, zobacz [wywołania zwrotne serializacji z tolerancją dla wersji](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-406">For more information, see [Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).</span></span>  
  
-   <span data-ttu-id="a0bda-407">Typy kontraktu danych zależą od określonej kolejności, w którym właściwość można wywołać metody ustawiające nie projektów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-407">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>  
  
-   <span data-ttu-id="a0bda-408">Zajmie się przy użyciu starsze typy oznaczone <xref:System.SerializableAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-408">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="a0bda-409">Wiele z nich zostały zaprojektowane do pracy z [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] usług zdalnych dla tylko zaufane danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-409">Many of them were designed to work with [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting for use with trusted data only.</span></span> <span data-ttu-id="a0bda-410">Istniejące typy z tym atrybutem może nie zostały zaprojektowane bezpieczeństwa stanu pamiętać.</span><span class="sxs-lookup"><span data-stu-id="a0bda-410">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>  
  
-   <span data-ttu-id="a0bda-411">Nie należy polegać na <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> właściwość `DataMemberAttribute` atrybutu, aby zagwarantować obecności danych w zakresie, w jakim stanie bezpieczeństwa.</span><span class="sxs-lookup"><span data-stu-id="a0bda-411">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the `DataMemberAttribute` attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="a0bda-412">Dane można zawsze być `null`, `zero`, lub `invalid`.</span><span class="sxs-lookup"><span data-stu-id="a0bda-412">Data could always be `null`, `zero`, or `invalid`.</span></span>  
  
-   <span data-ttu-id="a0bda-413">Nigdy nie zaufania wykres obiektu rozszeregować ze źródła danych niezaufanych bez najpierw sprawdzania poprawności.</span><span class="sxs-lookup"><span data-stu-id="a0bda-413">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="a0bda-414">Poszczególnych obiektów może być w stanie spójności, ale wykres obiektu jako całość może nie być.</span><span class="sxs-lookup"><span data-stu-id="a0bda-414">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="a0bda-415">Ponadto nawet po wyłączeniu trybu konserwacji obiektu wykresu zdeserializowany wykresu może mieć wiele odwołań do tego samego obiektu lub zawierać odwołań cyklicznych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-415">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="a0bda-416">Aby uzyskać więcej informacji, zobacz [serializacji i deserializacji](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-416">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="a0bda-417">Bezpieczny sposób za pomocą NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="a0bda-417">Using the NetDataContractSerializer Securely</span></span>  
 <span data-ttu-id="a0bda-418"><xref:System.Runtime.Serialization.NetDataContractSerializer> Jest aparatem serializacji, który używa ścisłej sprzężenia do typów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-418">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="a0bda-419">Jest to podobne do <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> i <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-419">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="a0bda-420">Oznacza to, określa typ do utworzenia wystąpienia odczytując [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] Nazwa zestawu i typu danych przychodzących.</span><span class="sxs-lookup"><span data-stu-id="a0bda-420">That is, it determines which type to instantiate by reading the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] assembly and type name from the incoming data.</span></span> <span data-ttu-id="a0bda-421">Chociaż jest częścią usługi WCF, nie istnieje sposób podany o podłączenie ten mechanizm serializacji; musi być napisana kodu niestandardowego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-421">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="a0bda-422">`NetDataContractSerializer` Podano przede wszystkim do jej obsługi ułatwiają migrację z [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting do programu WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-422">The `NetDataContractSerializer` is provided primarily to ease migration from [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting to WCF.</span></span> <span data-ttu-id="a0bda-423">Aby uzyskać więcej informacji, zobacz sekcję odpowiednie w [serializacji i deserializacji](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="a0bda-423">For more information, see the relevant section in [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
 <span data-ttu-id="a0bda-424">Ponieważ komunikatu może wskazywać, mogą być ładowane dowolnego typu, <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanizm jest z założenia niezabezpieczone i powinien być używany tylko z zaufanych danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-424">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="a0bda-425">Można zabezpieczyć pisząc integratora typu bezpiecznego, ograniczenie typu umożliwiający tylko bezpiecznych typy załadować (przy użyciu <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> właściwości).</span><span class="sxs-lookup"><span data-stu-id="a0bda-425">It is possible to make it secure by writing a secure, type-limiting type binder that allows only safe types to load (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property).</span></span>  
  
 <span data-ttu-id="a0bda-426">Nawet wtedy, gdy jest używany z zaufanych danych, danych przychodzących niewystarczająco może określać typ obciążenia, zwłaszcza, jeśli <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> właściwość jest ustawiona na <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-426">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="a0bda-427">Każda osoba mająca dostęp do katalogu aplikacji lub do globalnej pamięci podręcznej zestawów można zastąpić typu złośliwego zamiast ten, który powinien załadować.</span><span class="sxs-lookup"><span data-stu-id="a0bda-427">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="a0bda-428">Zawsze zapewnienia bezpieczeństwa katalogu aplikacji i Globalna pamięć podręczna zestawów poprawnie ustawiając uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-428">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>  
  
 <span data-ttu-id="a0bda-429">Ogólnie, jeśli zezwolisz na dostęp częściowo zaufany kod do Twojej `NetDataContractSerializer` wystąpienia lub inny sposób kontroluje selektora dwuskładnikowego (<xref:System.Runtime.Serialization.ISurrogateSelector>) lub wiążącego serializacji (<xref:System.Runtime.Serialization.SerializationBinder>), kod może wykonywać wiele kontroli nad proces serializacji/deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-429">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="a0bda-430">Na przykład go może wstrzyknąć arbitralnie wybrane typy, spowodować ujawnienie informacji, manipulowanie wynikowy wykres obiektu lub dane serializowane lub przepełnienie wynikowe strumieniu serializowanym.</span><span class="sxs-lookup"><span data-stu-id="a0bda-430">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>  
  
 <span data-ttu-id="a0bda-431">Inny problem z zabezpieczeniami `NetDataContractSerializer` jest odmowę usługi, nie zagrożenie wykonanie złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-431">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="a0bda-432">Korzystając z `NetDataContractSerializer`zawsze ustaw <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> przydziału do bezpiecznego wartość.</span><span class="sxs-lookup"><span data-stu-id="a0bda-432">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="a0bda-433">Jest łatwy do skonstruowania wiadomość złośliwego małych przydziela tablicę obiektów, którego rozmiar jest ograniczona tylko przez ten limit przydziału.</span><span class="sxs-lookup"><span data-stu-id="a0bda-433">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>  
  
### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="a0bda-434">Zagrożenia specyficzne dla elementu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="a0bda-434">XmlSerializer-Specific Threats</span></span>  
 <span data-ttu-id="a0bda-435"><xref:System.Xml.Serialization.XmlSerializer> Model zabezpieczeń jest podobny do <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-435">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="a0bda-436">Jednak kilka zagrożenia są unikatowe dla <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a0bda-436">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>  
  
 <span data-ttu-id="a0bda-437"><xref:System.Xml.Serialization.XmlSerializer> Generuje *zestawów serializacji* w czasie wykonywania, która zawiera kod, który faktycznie serializuje i deserializuje; te zestawy są tworzone w katalogu plików tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-437">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="a0bda-438">Jeśli inny proces lub użytkownik nie ma praw dostępu do tego katalogu, ich może zastąpić kod serializacji/deserializacji dowolnego kodu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-438">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="a0bda-439"><xref:System.Xml.Serialization.XmlSerializer> Następnie uruchamia ten kod przy użyciu jego kontekstu zabezpieczeń, zamiast kodu serializacji/deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-439">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="a0bda-440">Upewnij się, że uprawnienia zostały poprawnie skonfigurowane w katalogu plików tymczasowych do temu zapobiec.</span><span class="sxs-lookup"><span data-stu-id="a0bda-440">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>  
  
 <span data-ttu-id="a0bda-441"><xref:System.Xml.Serialization.XmlSerializer> Ma również tryb, w którym używa zestawów serializacji wstępnie wygenerowane zamiast generować je w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-441">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="a0bda-442">Ten tryb jest wyzwalane, gdy <xref:System.Xml.Serialization.XmlSerializer> można znaleźć zestawu serializacji odpowiedni.</span><span class="sxs-lookup"><span data-stu-id="a0bda-442">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="a0bda-443"><xref:System.Xml.Serialization.XmlSerializer> Sprawdza, czy zestaw serializacji został podpisany przez tego samego klucza, który został użyty do podpisania zestawu, który zawiera typy serializowana.</span><span class="sxs-lookup"><span data-stu-id="a0bda-443">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="a0bda-444">To zapewnia ochronę z zestawów złośliwego są ukryte jako zestawy serializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-444">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="a0bda-445">Jednak jeśli zestaw, który zawiera typy z możliwością serializowania nie jest podpisany, <xref:System.Xml.Serialization.XmlSerializer> nie sprawdzaj i korzysta z żadnych zestawów z poprawną nazwę.</span><span class="sxs-lookup"><span data-stu-id="a0bda-445">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="a0bda-446">Umożliwia uruchamianie złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-446">This makes running malicious code possible.</span></span> <span data-ttu-id="a0bda-447">Zawsze podpisują zestawy, które zawierają typy z możliwością serializowania lub ściśle kontroli dostępu do katalogu aplikacji i Globalna pamięć podręczna zestawów do zapobiegania wprowadzeniu złośliwego zestawów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-447">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>  
  
 <span data-ttu-id="a0bda-448"><xref:System.Xml.Serialization.XmlSerializer> Mogą podlegać typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="a0bda-448">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="a0bda-449"><xref:System.Xml.Serialization.XmlSerializer> Nie ma `MaxItemsInObjectGraph` przydziału (co jest dostępne na <xref:System.Runtime.Serialization.DataContractSerializer>).</span><span class="sxs-lookup"><span data-stu-id="a0bda-449">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="a0bda-450">W związku z tym go deserializuje dowolnej liczby obiektów ograniczona tylko rozmiar komunikatu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-450">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>  
  
### <a name="partial-trust-threats"></a><span data-ttu-id="a0bda-451">Zagrożenia częściowej relacji zaufania</span><span class="sxs-lookup"><span data-stu-id="a0bda-451">Partial Trust Threats</span></span>  
 <span data-ttu-id="a0bda-452">Należy zwrócić uwagę następujące kwestie dotyczące zagrożenia związane z kodem uruchomiony z częściowa relacja zaufania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-452">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="a0bda-453">Zagrożenia te obejmują złośliwy kod częściowo zaufany, a także złośliwy kod częściowo zaufany w połączeniu z innymi ataki (na przykład częściowo zaufany kod, który tworzy określony ciąg znaków, a następnie podczas deserializacji).</span><span class="sxs-lookup"><span data-stu-id="a0bda-453">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>  
  
-   <span data-ttu-id="a0bda-454">Podczas korzystania z żadnych składników serializacji, nigdy nie assert żadnych uprawnień przed takie użycia, nawet jeśli scenariusz całego serializacji jest w zakresie sieci assert i nie mamy do czynienia z niezaufanych danych lub obiektów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-454">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="a0bda-455">Takie użycie może prowadzić do luk w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="a0bda-455">Such usage may lead to security vulnerabilities.</span></span>  
  
-   <span data-ttu-id="a0bda-456">W przypadkach, gdy częściowo zaufany kod ma kontroli nad procesem serializacji, za pomocą punktów rozszerzalności (surogatów), typy serializowana, lub w inny sposób częściowo zaufany kod może spowodować serializatora do wyjściowego dużą ilość dane w serializowanym strumieniu, co może spowodować przeprowadzenie ataku typu "odmowa usługi" (DoS) do odbiornika tego strumienia.</span><span class="sxs-lookup"><span data-stu-id="a0bda-456">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="a0bda-457">Jeśli są serializacji danych przeznaczonych dla obiektu docelowego, który jest wielkość liter na zagrożenia systemu DoS, nie serializował typów, częściowo zaufanych lub w przeciwnym razie powiadomienie częściowo zaufany kod sterowania serializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-457">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>  
  
-   <span data-ttu-id="a0bda-458">Jeśli zezwolisz na dostęp częściowo zaufany kod do Twojej <xref:System.Runtime.Serialization.DataContractSerializer> wystąpienia lub w inny sposób kontroluje [surogaty kontraktu danych](../../../../docs/framework/wcf/extending/data-contract-surrogates.md), może wykonywać wiele kontroli nad procesem serializacji/deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-458">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="a0bda-459">Na przykład go może wstrzyknąć arbitralnie wybrane typy, spowodować ujawnienie informacji, manipulowanie wynikowy wykres obiektu lub dane serializowane lub przepełnienie wynikowe strumieniu serializowanym.</span><span class="sxs-lookup"><span data-stu-id="a0bda-459">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="a0bda-460">Odpowiednik <xref:System.Runtime.Serialization.NetDataContractSerializer> zagrożenie jest opisany w sekcji "Przy użyciu NetDataContractSerializer bezpiecznie".</span><span class="sxs-lookup"><span data-stu-id="a0bda-460">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>  
  
-   <span data-ttu-id="a0bda-461">Jeśli <xref:System.Runtime.Serialization.DataContractAttribute> atrybut jest stosowany do typu (lub typ jest oznaczony jako `[Serializable]` , ale nie jest `ISerializable`), Deserializator można utworzyć wystąpienia takiego typu, nawet jeśli wszystkie konstruktorów niepublicznego lub chronione przez żądania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-461">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as `[Serializable]` but is not `ISerializable`), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>  
  
-   <span data-ttu-id="a0bda-462">Nigdy nie ufać wyniku deserializacji, chyba że dane do zdeserializowania jest zaufany, a masz pewność, że wszystkie znane typy są typy, którym ufasz.</span><span class="sxs-lookup"><span data-stu-id="a0bda-462">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="a0bda-463">Należy pamiętać, że znanych typów nie są ładowane z pliku konfiguracji aplikacji, (a zostaną załadowane z pliku konfiguracji komputera) podczas uruchamiania w częściowej relacji zaufania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-463">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>  
  
-   <span data-ttu-id="a0bda-464">W przypadku przekazania `DataContractSerializer` wystąpienia z surogatu dodane do częściowo zaufany kod kod można zmienić ustawienia można modyfikować w tym dwuskładnikowego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-464">If you pass a `DataContractSerializer` instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>  
  
-   <span data-ttu-id="a0bda-465">Dla obiektu po deserializacji Jeśli modułu odczytującego XML (lub dane tam) jest dostarczany z częściowo zaufanego kodu zdeserializowany obiekt wynikowy należy traktować jako niezaufanych danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-465">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>  
  
-   <span data-ttu-id="a0bda-466">Fakt który <xref:System.Runtime.Serialization.ExtensionDataObject> typ nie ma publicznych członków oznacza, że dane znajdujące się w nim jest bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="a0bda-466">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="a0bda-467">Na przykład, jeśli zdeserializować źródła danych uprzywilejowanych do obiektu, w której niektóre znajdują się dane, następnie ręcznie, obiektu częściowo zaufany kod częściowo zaufany kod może odczytywać dane w `ExtensionDataObject` przez szeregowania obiektu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-467">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="a0bda-468">Rozważ ustawienie <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> do `true` podczas deserializacji źródła danych uprzywilejowanych do obiektu, który jest nowsza przekazany do częściowo zaufany kod.</span><span class="sxs-lookup"><span data-stu-id="a0bda-468">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>  
  
-   <span data-ttu-id="a0bda-469"><xref:System.Runtime.Serialization.DataContractSerializer> i <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> obsługuje serializacji prywatnych, chronionych wewnętrzne i publiczne elementy członkowskie w trybie pełnego zaufania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-469"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="a0bda-470">Jednak w częściowej relacji zaufania, można serializować tylko publiczne elementy członkowskie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-470">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="a0bda-471">A `SecurityException` jest generowany, jeśli aplikacja próbuje szeregować niepublicznego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-471">A `SecurityException` is thrown if an application attempts to serialize a non-public member.</span></span>  
  
     <span data-ttu-id="a0bda-472">Aby umożliwić wewnętrzny lub chronionych wewnętrznych elementów członkowskich do serializacji w częściowej relacji zaufania, użyj `System.Runtime.CompilerServices.InternalsVisibleTo` atrybutu zestawu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-472">To allow internal or protected internal members to be serialized in partial trust, use the `System.Runtime.CompilerServices.InternalsVisibleTo` assembly attribute.</span></span> <span data-ttu-id="a0bda-473">Ten atrybut umożliwia zestawu zadeklarować, że jego wewnętrzne elementy członkowskie są widoczne dla niektórych innych zestawów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-473">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="a0bda-474">W takim przypadku zestawu, który chce mieć jego wewnętrzne elementy członkowskie serializacji deklaruje, że jego wewnętrzne elementy członkowskie są widoczne dla System.Runtime.Serialization.dll.</span><span class="sxs-lookup"><span data-stu-id="a0bda-474">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>  
  
     <span data-ttu-id="a0bda-475">Zaletą tej metody jest, że nie wymaga ścieżka generowania kodu z podwyższonym poziomem uprawnień.</span><span class="sxs-lookup"><span data-stu-id="a0bda-475">The advantage of this approach is that it does not require an elevated code generation path.</span></span>  
  
     <span data-ttu-id="a0bda-476">W tym samym czasie istnieją dwa główne wady.</span><span class="sxs-lookup"><span data-stu-id="a0bda-476">At the same time, there are two major disadvantages.</span></span>  
  
     <span data-ttu-id="a0bda-477">Pierwszy wadą jest opcjonalnych właściwość `InternalsVisibleTo` atrybut jest całego zestawu.</span><span class="sxs-lookup"><span data-stu-id="a0bda-477">The first disadvantage is that the opt-in property of the `InternalsVisibleTo` attribute is assembly-wide.</span></span> <span data-ttu-id="a0bda-478">Oznacza to, że nie można określić, czy tylko niektóre klasa może mieć wewnętrznego członków serializacji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-478">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="a0bda-479">Oczywiście, nadal możesz nie serializacji określonego elementu członkowskiego wewnętrznego, po prostu dodając nie `DataMember` atrybutu do tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="a0bda-479">Of course, you can still choose not to serialize a specific internal member, by simply not adding a `DataMember` attribute to that member.</span></span> <span data-ttu-id="a0bda-480">Podobnie Deweloper można również dołączyć do wewnętrznego zamiast prywatne lub chronione z widoczność niewielkie problemy.</span><span class="sxs-lookup"><span data-stu-id="a0bda-480">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>  
  
     <span data-ttu-id="a0bda-481">Drugi Wadą jest to, że nadal nie obsługuje prywatnych lub chronionych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="a0bda-481">The second disadvantage is that it still does not support private or protected members.</span></span>  
  
     <span data-ttu-id="a0bda-482">Aby zilustrować stosowania `InternalsVisibleTo` atrybutu w częściowej relacji zaufania, należy rozważyć następujący program:</span><span class="sxs-lookup"><span data-stu-id="a0bda-482">To illustrate the use of the `InternalsVisibleTo` attribute in partial trust, consider the following program:</span></span>  
  
     [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]  
  
     <span data-ttu-id="a0bda-483">W powyższym przykładzie `PermissionsHelper.InternetZone` odpowiada `PermissionSet` dla częściowej relacji zaufania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-483">In the example above, `PermissionsHelper.InternetZone` corresponds to the `PermissionSet` for partial trust.</span></span> <span data-ttu-id="a0bda-484">Teraz, bez `InternalsVisibleToAttribute`, aplikacja zakończy się niepowodzeniem, wyrzucanie `SecurityException` wskazujący, że nie można zserializować niepublicznych elementów członkowskich w częściowej relacji zaufania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-484">Now, without `InternalsVisibleToAttribute`, the application will fail, throwing a `SecurityException` indicating that non-public members cannot be serialized in partial trust.</span></span>  
  
     <span data-ttu-id="a0bda-485">Jednak jeśli mamy Dodaj następujący wiersz do pliku źródłowego, program zostanie uruchomiony pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-485">However, if we add the following line to the source file, the program runs successfully.</span></span>  
  
     [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]  
  
## <a name="other-state-management-concerns"></a><span data-ttu-id="a0bda-486">Inne problemy zarządzania stanem</span><span class="sxs-lookup"><span data-stu-id="a0bda-486">Other State Management Concerns</span></span>  
 <span data-ttu-id="a0bda-487">Kilka problemy dotyczące zarządzania stanem obiektu są warto zauważyć:</span><span class="sxs-lookup"><span data-stu-id="a0bda-487">A few other concerns regarding object state management are worth mentioning:</span></span>  
  
-   <span data-ttu-id="a0bda-488">Używając modelu programowania strumienia z transportem przesyłania strumieniowego, przetwarzanie wiadomości wypada dociera do wiadomości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-488">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="a0bda-489">Nadawcy wiadomości może przerwać operację wysyłania środku strumienia, pozostawiając kodu w nieprzewidywalnym stanie, jeśli oczekiwany więcej zawartości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-489">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="a0bda-490">Ogólnie rzecz biorąc, nie należy polegać na strumienia są kompletne i nie wykonuj pracę w operacji na podstawie strumienia, którego nie można obniżyć ponownie w przypadku, gdy strumień jest przerywana.</span><span class="sxs-lookup"><span data-stu-id="a0bda-490">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="a0bda-491">To samo dotyczy sytuacji, gdy komunikat może być źle sformułowane po jednostkę przesyłania strumieniowego (na przykład go może brakować tagu końcowego dla koperty protokołu SOAP lub mieć drugi treści komunikatu).</span><span class="sxs-lookup"><span data-stu-id="a0bda-491">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>  
  
-   <span data-ttu-id="a0bda-492">Przy użyciu `IExtensibleDataObject` funkcji może spowodować emitować poufnych danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-492">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="a0bda-493">Jeśli użytkownik akceptuje dane z niezaufanego źródła w kontraktach danych z `IExtensibleObjectData` i później ponownie emitowanie go na bezpiecznego kanału, gdy są podpisane wiadomości, można są potencjalnie zagwarantowanie nic nie wiadomo o danych.</span><span class="sxs-lookup"><span data-stu-id="a0bda-493">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="a0bda-494">Ponadto może być nieprawidłowy, jeśli znane i nieznane fragmentów danych należy wziąć pod uwagę ogólny stan wysyłania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-494">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="a0bda-495">Tego uniknąć, ustawiając albo selektywnie właściwość danych rozszerzenia `null` lub selektywnie wyłączając `IExtensibleObjectData` funkcji.</span><span class="sxs-lookup"><span data-stu-id="a0bda-495">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>  
  
## <a name="schema-import"></a><span data-ttu-id="a0bda-496">Importowanie schematu</span><span class="sxs-lookup"><span data-stu-id="a0bda-496">Schema Import</span></span>  
 <span data-ttu-id="a0bda-497">Normalnie, proces importowania schematu do generowania typów występuje tylko w czasie projektowania, na przykład, korzystając z [narzędzie narzędzia metadanych elementu ServiceModel (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) na usługi sieci Web do generowania klasy klienta.</span><span class="sxs-lookup"><span data-stu-id="a0bda-497">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="a0bda-498">Jednak w bardziej zaawansowanych scenariuszy może przetwarzać schematu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-498">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="a0bda-499">Należy pamiętać, że w ten sposób może doprowadzić do ryzyka typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="a0bda-499">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="a0bda-500">Niektóre schematu może zająć dużo czasu do zaimportowania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-500">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="a0bda-501">Nigdy nie używaj <xref:System.Xml.Serialization.XmlSerializer> składnik Importowanie schematu w scenariuszach, jeśli schematy prawdopodobnie pochodzą z niezaufanego źródła.</span><span class="sxs-lookup"><span data-stu-id="a0bda-501">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>  
  
## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="a0bda-502">Zagrożenia specyficzne dla integracji AJAX ASP.NET</span><span class="sxs-lookup"><span data-stu-id="a0bda-502">Threats Specific to ASP.NET AJAX Integration</span></span>  
 <span data-ttu-id="a0bda-503">Gdy użytkownik wykonuje <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> lub <xref:System.ServiceModel.Description.WebHttpBehavior>, usługa WCF umożliwia punktu końcowego, który może zaakceptować wiadomości XML i JSON.</span><span class="sxs-lookup"><span data-stu-id="a0bda-503">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="a0bda-504">Istnieje jednak tylko jeden zestaw przydziały czytnika używane zarówno przez modułu odczytującego XML i czytnika JSON.</span><span class="sxs-lookup"><span data-stu-id="a0bda-504">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="a0bda-505">Niektóre ustawienia limitu przydziału może być odpowiednie dla jeden czytnik lecz za duża dla siebie.</span><span class="sxs-lookup"><span data-stu-id="a0bda-505">Some quota settings may be appropriate for one reader but too large for the other.</span></span>  
  
 <span data-ttu-id="a0bda-506">Podczas implementowania `WebScriptEnablingBehavior`, użytkownik ma możliwość ujawnia pośredniczącą JavaScript w punkcie końcowym.</span><span class="sxs-lookup"><span data-stu-id="a0bda-506">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="a0bda-507">Należy rozważyć następujące zagadnienia dotyczące zabezpieczeń:</span><span class="sxs-lookup"><span data-stu-id="a0bda-507">The following security issues must be considered:</span></span>  
  
-   <span data-ttu-id="a0bda-508">Informacje o usłudze (nazwy operacji, nazwy parametrów itd.) można uzyskać, sprawdzając serwera proxy JavaScript.</span><span class="sxs-lookup"><span data-stu-id="a0bda-508">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>  
  
-   <span data-ttu-id="a0bda-509">Podczas korzystania z punktu końcowego JavaScript, informacje poufne i prywatne mogą być zachowane w pamięci podręcznej przeglądarki sieci Web klienta.</span><span class="sxs-lookup"><span data-stu-id="a0bda-509">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>  
  
## <a name="a-note-on-components"></a><span data-ttu-id="a0bda-510">Uwaga na temat składników</span><span class="sxs-lookup"><span data-stu-id="a0bda-510">A Note on Components</span></span>  
 <span data-ttu-id="a0bda-511">Usługi WCF jest systemem elastyczne i dostosowania.</span><span class="sxs-lookup"><span data-stu-id="a0bda-511">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="a0bda-512">Większość zawartości w tym temacie dotyczą najbardziej typowe scenariusze użycia usług WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-512">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="a0bda-513">Jednak jest możliwe utworzenie składniki, które WCF udostępnia wiele różnych sposobów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-513">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="a0bda-514">Należy zrozumieć implikacje zabezpieczeń przy użyciu każdego składnika.</span><span class="sxs-lookup"><span data-stu-id="a0bda-514">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="a0bda-515">W szczególności:</span><span class="sxs-lookup"><span data-stu-id="a0bda-515">In particular:</span></span>  
  
-   <span data-ttu-id="a0bda-516">Gdy czytniki XML musi być używany, użyj czytników <xref:System.Xml.XmlDictionaryReader> klasa udostępnia w przeciwieństwie do innych czytników.</span><span class="sxs-lookup"><span data-stu-id="a0bda-516">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="a0bda-517">Bezpieczne czytników są tworzone przy użyciu <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, lub <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a0bda-517">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="a0bda-518">Nie używaj <xref:System.Xml.XmlReader.Create%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a0bda-518">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="a0bda-519">Zawsze skonfigurować bezpieczne Przydziały czytników.</span><span class="sxs-lookup"><span data-stu-id="a0bda-519">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="a0bda-520">Aparaty serializacji w programie WCF są bezpieczne, tylko wtedy, gdy jest używany z bezpiecznego czytników XML z WCF.</span><span class="sxs-lookup"><span data-stu-id="a0bda-520">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>  
  
-   <span data-ttu-id="a0bda-521">Korzystając z <xref:System.Runtime.Serialization.DataContractSerializer> można deserializować danych potencjalnie niezaufanych, należy zawsze wartość <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a0bda-521">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>  
  
-   <span data-ttu-id="a0bda-522">Podczas tworzenia komunikat, ustaw `maxSizeOfHeaders` parametru Jeśli `MaxReceivedMessageSize` nie zapewniają wystarczająco dużo ochronę.</span><span class="sxs-lookup"><span data-stu-id="a0bda-522">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>  
  
-   <span data-ttu-id="a0bda-523">Podczas tworzenia kodera, zawsze skonfiguruj odpowiednie przydziały, takich jak `MaxSessionSize` i `MaxBufferSize`.</span><span class="sxs-lookup"><span data-stu-id="a0bda-523">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>  
  
-   <span data-ttu-id="a0bda-524">Korzystając z języka XPath filtr komunikatu, należy ustawić <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> Aby ograniczyć liczbę węzłów XML odwiedza filtru.</span><span class="sxs-lookup"><span data-stu-id="a0bda-524">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="a0bda-525">Nie należy używać wyrażenia XPath, które może zająć dużo czasu obliczeniowe bez konieczności przechodzenia wiele węzłów.</span><span class="sxs-lookup"><span data-stu-id="a0bda-525">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>  
  
-   <span data-ttu-id="a0bda-526">Ogólnie rzecz biorąc korzystając z każdego składnika, który akceptuje limit przydziału, zrozumieć jego wpływ na bezpieczeństwo i ustawioną wartość bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="a0bda-526">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a0bda-527">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="a0bda-527">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.XmlDictionaryReader>  
 <xref:System.Xml.Serialization.XmlSerializer>  
 [<span data-ttu-id="a0bda-528">Znane typy kontraktów danych</span><span class="sxs-lookup"><span data-stu-id="a0bda-528">Data Contract Known Types</span></span>](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)
