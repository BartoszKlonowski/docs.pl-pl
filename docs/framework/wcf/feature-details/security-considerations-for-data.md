---
title: Zagadnienia związane z zabezpieczeniami danych
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 8cb7ee2ea2418602d944c3c08cec2b9279dca3b9
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/09/2020
ms.locfileid: "84601065"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="63c21-102">Zagadnienia związane z zabezpieczeniami danych</span><span class="sxs-lookup"><span data-stu-id="63c21-102">Security Considerations for Data</span></span>

<span data-ttu-id="63c21-103">Podczas pracy z danymi w Windows Communication Foundation (WCF) należy wziąć pod uwagę wiele kategorii zagrożeń.</span><span class="sxs-lookup"><span data-stu-id="63c21-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="63c21-104">W poniższej tabeli wymieniono najważniejsze klasy zagrożeń, które odnoszą się do przetwarzania danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="63c21-105">Funkcja WCF oferuje narzędzia pozwalające ograniczyć te zagrożenia.</span><span class="sxs-lookup"><span data-stu-id="63c21-105">WCF provides tools to mitigate these threats.</span></span>

<span data-ttu-id="63c21-106">Odmowa usługi podczas otrzymywania niezaufanych danych może spowodować, że po stronie odbiorczej dostęp do niewspółmiernej ilości różnych zasobów, takich jak pamięć, wątki, dostępne połączenia lub cykle procesora, jest spowodowany długimi obliczeniami.</span><span class="sxs-lookup"><span data-stu-id="63c21-106">Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="63c21-107">Atak typu "odmowa usługi" na serwer może spowodować awarię i uniemożliwić przetworzenie komunikatów od innych, uprawnionych klientów.</span><span class="sxs-lookup"><span data-stu-id="63c21-107">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

<span data-ttu-id="63c21-108">Złośliwe wykonanie kodu przychodzące dane niezaufane powodują, że Strona otrzymująca może uruchomić kod, którego nie ma.</span><span class="sxs-lookup"><span data-stu-id="63c21-108">Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

<span data-ttu-id="63c21-109">Ujawnienie informacji zdalne osoby atakujące wymuszają reagowanie na żądania w taki sposób, aby ujawnić więcej informacji niż ma to na celu.</span><span class="sxs-lookup"><span data-stu-id="63c21-109">Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="63c21-110">Kod dostarczony przez użytkownika i zabezpieczenia dostępu kodu</span><span class="sxs-lookup"><span data-stu-id="63c21-110">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="63c21-111">Liczba miejsc w infrastrukturze programu Windows Communication Foundation (WCF), która jest dostarczana przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="63c21-111">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="63c21-112">Na przykład <xref:System.Runtime.Serialization.DataContractSerializer> aparat serializacji może wywoływać metody dostępu do właściwości `set` i metod dostępu dostarczonych przez użytkownika `get` .</span><span class="sxs-lookup"><span data-stu-id="63c21-112">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="63c21-113">Infrastruktura kanału WCF może również wywołać klasy pochodne dostarczone przez użytkownika <xref:System.ServiceModel.Channels.Message> klasy.</span><span class="sxs-lookup"><span data-stu-id="63c21-113">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="63c21-114">Jest odpowiedzialny za autora kodu, aby upewnić się, że nie istnieją żadne luki w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="63c21-114">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="63c21-115">Jeśli na przykład utworzysz typ kontraktu danych z właściwością elementu członkowskiego danych typu Integer, a w `set` implementacji metody dostępu zostanie przydzielona tablica oparta na wartości właściwości, zostanie ujawniona możliwość ataku typu "odmowa usługi", Jeśli złośliwy komunikat zawiera bardzo dużą wartość dla tego elementu członkowskiego danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-115">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="63c21-116">Ogólnie rzecz biorąc, unikaj przydziałów w oparciu o dane przychodzące lub długotrwałe przetwarzanie w kodzie dostarczonym przez użytkownika (szczególnie w przypadku, gdy długotrwałe przetwarzanie może być spowodowane przez niewielką ilość danych przychodzących).</span><span class="sxs-lookup"><span data-stu-id="63c21-116">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="63c21-117">Podczas przeprowadzania analizy zabezpieczeń kodu dostarczonego przez użytkownika należy rozważyć również wszystkie przypadki awarii (czyli wszystkie gałęzie kodu, w których są zgłaszane wyjątki).</span><span class="sxs-lookup"><span data-stu-id="63c21-117">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="63c21-118">Najważniejszym przykładem kodu dostarczonego przez użytkownika jest kod wewnątrz implementacji usługi dla każdej operacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-118">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="63c21-119">Obowiązkiem jest bezpieczeństwo implementacji usługi.</span><span class="sxs-lookup"><span data-stu-id="63c21-119">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="63c21-120">W łatwy sposób można przypadkowo utworzyć niezabezpieczone implementacje, które mogą spowodować luki w zabezpieczeniach typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="63c21-120">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="63c21-121">Na przykład operacja pobierająca ciąg i zwraca listę klientów z bazy danych, której nazwa rozpoczyna się od tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="63c21-121">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="63c21-122">Jeśli pracujesz z dużą bazą danych, a przesłany ciąg jest tylko pojedynczą literą, kod może próbować utworzyć komunikat przekraczający całą dostępną pamięć, powodując niepowodzenie całej usługi.</span><span class="sxs-lookup"><span data-stu-id="63c21-122">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="63c21-123">( <xref:System.OutOfMemoryException> Nie jest możliwy do odzyskania w .NET Framework i zawsze powoduje zakończenie działania aplikacji).</span><span class="sxs-lookup"><span data-stu-id="63c21-123">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="63c21-124">Należy upewnić się, że żaden złośliwy kod nie jest podłączony do różnych punktów rozszerzających.</span><span class="sxs-lookup"><span data-stu-id="63c21-124">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="63c21-125">Jest to szczególnie istotne w przypadku uruchamiania w ramach częściowej relacji zaufania, z uwzględnieniem typów z częściowo zaufanych zestawów lub tworzenia składników użytecznych przez częściowo zaufany kod.</span><span class="sxs-lookup"><span data-stu-id="63c21-125">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="63c21-126">Aby uzyskać więcej informacji, zobacz "częściowe zagrożenia zaufania" w dalszej części.</span><span class="sxs-lookup"><span data-stu-id="63c21-126">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="63c21-127">Należy pamiętać, że w przypadku uruchamiania w częściowej relacji zaufania infrastruktura serializacji kontraktu danych obsługuje tylko ograniczony podzbiór modelu programowania kontraktu danych — na przykład prywatne elementy członkowskie danych lub typy używające <xref:System.SerializableAttribute> atrybutu nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="63c21-127">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="63c21-128">Aby uzyskać więcej informacji, zobacz [częściowe zaufanie](partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-128">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="63c21-129">Unikanie przypadkowego ujawnienia informacji</span><span class="sxs-lookup"><span data-stu-id="63c21-129">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="63c21-130">Podczas projektowania typów możliwych do serializacji z uwzględnieniem zabezpieczeń, ujawnienie informacji jest możliwym problemem.</span><span class="sxs-lookup"><span data-stu-id="63c21-130">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="63c21-131">Rozważ następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="63c21-131">Consider the following points:</span></span>

- <span data-ttu-id="63c21-132"><xref:System.Runtime.Serialization.DataContractSerializer>Model programowania umożliwia narażenie danych prywatnych i wewnętrznych poza typem lub zestawem podczas serializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-132">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="63c21-133">Ponadto kształt typu może być narażony podczas eksportowania schematu.</span><span class="sxs-lookup"><span data-stu-id="63c21-133">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="63c21-134">Pamiętaj, aby zrozumieć rzutowanie serializacji typu.</span><span class="sxs-lookup"><span data-stu-id="63c21-134">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="63c21-135">Jeśli nie chcesz niczego ujawniać, wyłącz Serializowanie go (na przykład przez niestosowanie <xref:System.Runtime.Serialization.DataMemberAttribute> atrybutu w przypadku kontraktu danych).</span><span class="sxs-lookup"><span data-stu-id="63c21-135">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="63c21-136">Należy pamiętać, że ten sam typ może mieć wiele prognoz serializacji, w zależności od używanego serializatora.</span><span class="sxs-lookup"><span data-stu-id="63c21-136">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="63c21-137">Ten sam typ może uwidaczniać jeden zestaw danych, gdy jest używany z <xref:System.Runtime.Serialization.DataContractSerializer> i innym zestawem danych, gdy jest używany z <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="63c21-137">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="63c21-138">Przypadkowe użycie niewłaściwego serializatora może prowadzić do ujawnienia informacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-138">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="63c21-139">Użycie <xref:System.Xml.Serialization.XmlSerializer> w trybie/Encoded w starszej wersji zdalnego wywołania procedury (RPC) może przypadkowo uwidocznić kształt grafu obiektów po stronie wysyłającej.</span><span class="sxs-lookup"><span data-stu-id="63c21-139">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="63c21-140">Zapobieganie atakom typu "odmowa usługi"</span><span class="sxs-lookup"><span data-stu-id="63c21-140">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="63c21-141">Przydziały</span><span class="sxs-lookup"><span data-stu-id="63c21-141">Quotas</span></span>

<span data-ttu-id="63c21-142">Spowodowanie przydzielenia przez stronę otrzymującej znacznej ilości pamięci jest potencjalny atak typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="63c21-142">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="63c21-143">Chociaż ta sekcja koncentruje się na problemach z użyciem pamięci, wynikających z dużych komunikatów, mogą wystąpić inne ataki.</span><span class="sxs-lookup"><span data-stu-id="63c21-143">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="63c21-144">Na przykład komunikaty mogą wykorzystywać nieproporcjonalną ilość czasu przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="63c21-144">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="63c21-145">Ataki typu "odmowa usługi" są zazwyczaj zmniejszane za pomocą przydziałów.</span><span class="sxs-lookup"><span data-stu-id="63c21-145">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="63c21-146">W przypadku przekroczenia limitu przydziału <xref:System.ServiceModel.QuotaExceededException> wyjątek jest zgłaszany zwykle.</span><span class="sxs-lookup"><span data-stu-id="63c21-146">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="63c21-147">Bez przydziału złośliwy komunikat może spowodować uzyskanie dostępu do całej dostępnej pamięci, co spowodowało <xref:System.OutOfMemoryException> wyjątek lub dostęp do wszystkich dostępnych stosów, co powoduje wystąpienie <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="63c21-147">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="63c21-148">Scenariusz przekroczony limit przydziału jest możliwy do odzyskania; Jeśli napotkasz w uruchomionej usłudze, komunikat, który jest aktualnie przetwarzany, jest odrzucany, a usługa działa i przetwarza dalsze komunikaty.</span><span class="sxs-lookup"><span data-stu-id="63c21-148">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="63c21-149">Scenariusze braku pamięci i przepełnienia stosu nie są jednak możliwe do odzyskania w dowolnym miejscu .NET Framework; Usługa kończy działanie w przypadku wystąpienia takich wyjątków.</span><span class="sxs-lookup"><span data-stu-id="63c21-149">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="63c21-150">Limity przydziału w programie WCF nie obejmują żadnej alokacji wstępnej.</span><span class="sxs-lookup"><span data-stu-id="63c21-150">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="63c21-151">Na przykład, jeśli <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> limit przydziału (znaleziony w różnych klasach) jest ustawiony na 128 kb, nie oznacza to, że 128 KB jest automatycznie przypisywany dla każdego komunikatu.</span><span class="sxs-lookup"><span data-stu-id="63c21-151">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="63c21-152">Przydzieloną ilość rzeczywistą zależy od rzeczywistego rozmiaru wiadomości przychodzącej.</span><span class="sxs-lookup"><span data-stu-id="63c21-152">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="63c21-153">W warstwie transportowej są dostępne wiele przydziałów.</span><span class="sxs-lookup"><span data-stu-id="63c21-153">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="63c21-154">Są to przydziały wymuszane przez określony kanał transportu w użyciu (HTTP, TCP itd.).</span><span class="sxs-lookup"><span data-stu-id="63c21-154">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="63c21-155">Chociaż w tym temacie omówiono niektóre z tych przydziałów, te limity przydziału są szczegółowo opisane w przystawce [zasoby transportowe](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-155">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="63c21-156">Luka w zabezpieczeniach</span><span class="sxs-lookup"><span data-stu-id="63c21-156">Hashtable Vulnerability</span></span>

<span data-ttu-id="63c21-157">Występuje luka w zabezpieczeniach, gdy Kontrakty danych zawierają Hashtable lub kolekcje.</span><span class="sxs-lookup"><span data-stu-id="63c21-157">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="63c21-158">Ten problem występuje, gdy duża liczba wartości jest wstawiana do tablicy skrótów, w której duża liczba tych wartości generuje tę samą wartość skrótu.</span><span class="sxs-lookup"><span data-stu-id="63c21-158">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="63c21-159">Może to służyć jako atak typu DOS.</span><span class="sxs-lookup"><span data-stu-id="63c21-159">This can be used as a DOS attack.</span></span>  <span data-ttu-id="63c21-160">Tę lukę w zabezpieczeniach można wyeliminować, ustawiając limit przydziału dla powiązania MaxReceivedMessageSize.</span><span class="sxs-lookup"><span data-stu-id="63c21-160">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="63c21-161">Należy zachować ostrożność podczas ustawiania tego przydziału, aby zapobiec takim atakom.</span><span class="sxs-lookup"><span data-stu-id="63c21-161">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="63c21-162">Ten limit przydziału umieszcza górny limit rozmiaru komunikatów WCF.</span><span class="sxs-lookup"><span data-stu-id="63c21-162">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="63c21-163">Ponadto należy unikać używania tablic lub kolekcji w kontraktach danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-163">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="63c21-164">Ograniczanie użycia pamięci bez przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="63c21-164">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="63c21-165">Model zabezpieczeń wokół dużych komunikatów zależy od tego, czy przesyłanie strumieniowe jest w użyciu.</span><span class="sxs-lookup"><span data-stu-id="63c21-165">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="63c21-166">W przypadku podstawowego, niestrumieniowego przypadku, komunikaty są buforowane w pamięci.</span><span class="sxs-lookup"><span data-stu-id="63c21-166">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="63c21-167">W takim przypadku należy użyć <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> przydziału na <xref:System.ServiceModel.Channels.TransportBindingElement> lub w powiązaniach dostarczonych przez system w celu ochrony przed dużymi komunikatami przez ograniczenie maksymalnego rozmiaru komunikatu do dostępu.</span><span class="sxs-lookup"><span data-stu-id="63c21-167">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="63c21-168">Należy zauważyć, że usługa może przetwarzać wiele komunikatów w tym samym czasie, w którym to przypadku wszystkie w pamięci.</span><span class="sxs-lookup"><span data-stu-id="63c21-168">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="63c21-169">Użyj funkcji ograniczania przepustowości, aby zmniejszyć to zagrożenie.</span><span class="sxs-lookup"><span data-stu-id="63c21-169">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="63c21-170">Należy również pamiętać, że nie należy `MaxReceivedMessageSize` górną granicą zużycia pamięci dla poszczególnych komunikatów, ale ogranicza ją do poziomu stałego czynnika.</span><span class="sxs-lookup"><span data-stu-id="63c21-170">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="63c21-171">Na przykład, jeśli `MaxReceivedMessageSize` otrzymasz 1 MB i zostanie wyświetlony komunikat 1-MB, a następnie zostanie on rozszeregowany, wymagana jest dodatkowa pamięć, która będzie zawierać deserializowany wykres obiektu, co spowodowało całkowite zużycie pamięci na 1 MB.</span><span class="sxs-lookup"><span data-stu-id="63c21-171">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="63c21-172">Z tego powodu należy unikać tworzenia możliwych do serializacji typów, które mogłyby spowodować znaczne użycie pamięci bez dużo danych przychodzących.</span><span class="sxs-lookup"><span data-stu-id="63c21-172">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="63c21-173">Na przykład kontrakt danych "Moja Umowa" z 50 opcjonalnymi polami elementu członkowskiego danych i dodatkowymi polami prywatnymi 100 można utworzyć przy użyciu konstrukcji XML " \<MyContract/> ".</span><span class="sxs-lookup"><span data-stu-id="63c21-173">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="63c21-174">Ten kod XML powoduje dostęp do pamięci dla 150 pól.</span><span class="sxs-lookup"><span data-stu-id="63c21-174">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="63c21-175">Należy pamiętać, że elementy członkowskie danych są domyślnie opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="63c21-175">Note that data members are optional by default.</span></span> <span data-ttu-id="63c21-176">Problem jest składany, gdy taki typ jest częścią tablicy.</span><span class="sxs-lookup"><span data-stu-id="63c21-176">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="63c21-177">`MaxReceivedMessageSize`samo nie jest wystarczające, aby zapobiec atakom typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="63c21-177">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="63c21-178">Na przykład Deserializator może być zmuszony do deserializacji wykresu głęboko zagnieżdżonego obiektu (obiektu, który zawiera inny obiekt, który jest jeszcze inny, itd.) przez komunikat przychodzący.</span><span class="sxs-lookup"><span data-stu-id="63c21-178">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="63c21-179"><xref:System.Runtime.Serialization.DataContractSerializer>I <xref:System.Xml.Serialization.XmlSerializer> metody wywołania w zagnieżdżonym sposobie deserializacji takich grafów.</span><span class="sxs-lookup"><span data-stu-id="63c21-179">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="63c21-180">Głębokie zagnieżdżenie wywołań metod może spowodować nieodwracalne odzyskanie <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="63c21-180">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="63c21-181">To zagrożenie jest korygowane przez ustawienie limitu <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> przydziału w celu ograniczenia poziomu zagnieżdżenia XML, jak opisano w sekcji "używanie bezpiecznego kodu XML" w dalszej części tematu.</span><span class="sxs-lookup"><span data-stu-id="63c21-181">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="63c21-182">Ustawienie dodatkowych przydziałów `MaxReceivedMessageSize` jest szczególnie ważne w przypadku korzystania z binarnego kodowania XML.</span><span class="sxs-lookup"><span data-stu-id="63c21-182">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="63c21-183">Użycie kodowania binarnego jest nieco równoważne kompresji: niewielka grupa bajtów w komunikacie przychodzącym może reprezentować wiele danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-183">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="63c21-184">W ten sposób nawet komunikat dopasowywany do `MaxReceivedMessageSize` limitu może zająć dużo więcej pamięci w pełni rozwiniętej postaci.</span><span class="sxs-lookup"><span data-stu-id="63c21-184">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="63c21-185">Aby wyeliminować takie zagrożenia specyficzne dla języka XML, wszystkie przydziały czytnika XML muszą być poprawnie ustawione, jak to opisano w sekcji "Korzystanie z bezpiecznego kodu XML" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="63c21-185">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="63c21-186">Ograniczanie zużycia pamięci przy użyciu przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="63c21-186">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="63c21-187">W przypadku przesyłania strumieniowego można użyć małego `MaxReceivedMessageSize` Ustawienia do ochrony przed atakami typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="63c21-187">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="63c21-188">Jednak bardziej skomplikowane scenariusze są możliwe w przypadku przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="63c21-188">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="63c21-189">Na przykład usługa przekazywania plików akceptuje pliki większe niż cała dostępna pamięć.</span><span class="sxs-lookup"><span data-stu-id="63c21-189">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="63c21-190">W takim przypadku należy ustawić `MaxReceivedMessageSize` do bardzo dużej wartości, co oznacza, że prawie żadne dane nie są buforowane w pamięci i strumienie komunikatów bezpośrednio na dysku.</span><span class="sxs-lookup"><span data-stu-id="63c21-190">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="63c21-191">Jeśli złośliwy komunikat może w jakiś sposób wymusić, aby usługa WCF mogła buforować dane zamiast przesyłania strumieniowego w tym przypadku, `MaxReceivedMessageSize` nie będzie już chronić się przed komunikatem dostępnym do całej dostępnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="63c21-191">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="63c21-192">Aby zmniejszyć to zagrożenie, istnieją określone ustawienia limitu przydziału dla różnych składników przetwarzania danych programu WCF, które ograniczają buforowanie.</span><span class="sxs-lookup"><span data-stu-id="63c21-192">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="63c21-193">Najważniejszym z nich jest `MaxBufferSize` Właściwość różnych elementów powiązania transportu i standardowe powiązania.</span><span class="sxs-lookup"><span data-stu-id="63c21-193">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="63c21-194">W przypadku przesyłania strumieniowego ten limit przydziału powinien zostać ustawiony z uwzględnieniem maksymalnej ilości pamięci, która ma zostać przydzielona na wiadomość.</span><span class="sxs-lookup"><span data-stu-id="63c21-194">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="63c21-195">Podobnie jak w przypadku `MaxReceivedMessageSize` , ustawienie nie ma absolutnej maksymalnej wartości zużycia pamięci, ale ogranicza ją tylko do poziomu stałego czynnika.</span><span class="sxs-lookup"><span data-stu-id="63c21-195">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="63c21-196">Podobnie jak w przypadku programu `MaxReceivedMessageSize` , należy pamiętać o możliwości przetworzenia wielu komunikatów jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="63c21-196">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="63c21-197">Szczegóły MaxBufferSize</span><span class="sxs-lookup"><span data-stu-id="63c21-197">MaxBufferSize Details</span></span>

<span data-ttu-id="63c21-198">`MaxBufferSize`Właściwość ogranicza wszystkie usługi WCF do buforowania zbiorczego.</span><span class="sxs-lookup"><span data-stu-id="63c21-198">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="63c21-199">Na przykład program WCF zawsze buforuje nagłówki protokołu SOAP i błędy SOAP, a także wszystkie części MIME, które nie znajdują się w naturalnym porządku czytania w komunikacie mechanizmu optymalizacji transmisji komunikatów (MTOM).</span><span class="sxs-lookup"><span data-stu-id="63c21-199">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="63c21-200">To ustawienie ogranicza ilość buforowania we wszystkich tych przypadkach.</span><span class="sxs-lookup"><span data-stu-id="63c21-200">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="63c21-201">Platforma WCF osiąga ten element, przekazując `MaxBufferSize` wartość do różnych składników, które mogą buforować.</span><span class="sxs-lookup"><span data-stu-id="63c21-201">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="63c21-202">Na przykład niektóre <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> przeciążenia <xref:System.ServiceModel.Channels.Message> klasy przyjmują `maxSizeOfHeaders` parametr.</span><span class="sxs-lookup"><span data-stu-id="63c21-202">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="63c21-203">Funkcja WCF przekazuje `MaxBufferSize` wartość do tego parametru, aby ograniczyć liczbę buforów nagłówka protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="63c21-203">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="63c21-204">Ważne jest, aby ustawić ten parametr w przypadku używania <xref:System.ServiceModel.Channels.Message> klasy bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="63c21-204">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="63c21-205">Ogólnie rzecz biorąc, w przypadku korzystania z składnika w programie WCF, który pobiera parametry przydziału, ważne jest, aby zrozumieć implikacje zabezpieczeń tych parametrów i ustawić je poprawnie.</span><span class="sxs-lookup"><span data-stu-id="63c21-205">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="63c21-206">Koder komunikatu MTOM również ma `MaxBufferSize` ustawienie.</span><span class="sxs-lookup"><span data-stu-id="63c21-206">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="63c21-207">W przypadku korzystania z powiązań standardowych jest to automatycznie ustawiane na wartość na poziomie transportu `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="63c21-207">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="63c21-208">Jednak w przypadku użycia elementu powiązania kodera komunikatu MTOM do skonstruowania niestandardowego powiązania należy ustawić `MaxBufferSize` Właściwość na wartość bezpieczną, gdy używane jest przesyłanie strumieniowe.</span><span class="sxs-lookup"><span data-stu-id="63c21-208">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="63c21-209">Ataki strumieniowe oparte na języku XML</span><span class="sxs-lookup"><span data-stu-id="63c21-209">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="63c21-210">`MaxBufferSize`sama nie jest wystarczająca, aby zapewnić, że nie można wymusić buforowania usługi WCF w przypadku, gdy jest oczekiwany strumień.</span><span class="sxs-lookup"><span data-stu-id="63c21-210">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="63c21-211">Na przykład czytelnicy XML programu WCF zawsze buforują cały tag początkowy elementu XML przy rozpoczynaniu odczytywania nowego elementu.</span><span class="sxs-lookup"><span data-stu-id="63c21-211">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="63c21-212">Dzięki temu obszary nazw i atrybuty są prawidłowo przetwarzane.</span><span class="sxs-lookup"><span data-stu-id="63c21-212">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="63c21-213">Jeśli `MaxReceivedMessageSize` Konfiguracja jest duża (na przykład w celu włączenia scenariusza dużego przesyłania strumieniowego plików), złośliwy komunikat może być skonstruowany, gdzie cała treść komunikatu jest dużym tagiem początkowym elementu XML.</span><span class="sxs-lookup"><span data-stu-id="63c21-213">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="63c21-214">Próba odczytu powoduje wystąpienie <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="63c21-214">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="63c21-215">Jest to jeden z wielu możliwych ataków typu "odmowa usługi" opartych na języku XML, które można rozwiązać za pomocą przydziałów czytnika XML, omówione w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="63c21-215">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="63c21-216">W przypadku przesyłania strumieniowego jest szczególnie ważne, aby ustawić wszystkie te limity przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-216">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="63c21-217">Mieszanie modeli programowania przesyłania strumieniowego i buforowania</span><span class="sxs-lookup"><span data-stu-id="63c21-217">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="63c21-218">Liczne możliwe ataki powstają w wyniku mieszania modeli programowania przesyłania strumieniowego i niestrumieniowego w ramach tej samej usługi.</span><span class="sxs-lookup"><span data-stu-id="63c21-218">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="63c21-219">Załóżmy, że istnieje kontrakt usługi z dwiema operacjami: jeden z nich przyjmuje <xref:System.IO.Stream> tablicę niektórych typów niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="63c21-219">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="63c21-220">Załóżmy również, że `MaxReceivedMessageSize` ustawiono dużą wartość, aby włączyć pierwszą operację przetwarzania dużych strumieni.</span><span class="sxs-lookup"><span data-stu-id="63c21-220">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="63c21-221">Niestety oznacza to, że można teraz wysyłać duże komunikaty do drugiej operacji, a Deserializator buforuje dane w pamięci jako tablicę przed wywołaniem operacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-221">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="63c21-222">Jest to potencjalny atak typu "odmowa usługi": limit `MaxBufferSize` przydziału nie ogranicza rozmiaru treści komunikatu, który jest używany przez deserializatora.</span><span class="sxs-lookup"><span data-stu-id="63c21-222">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="63c21-223">Z tego powodu należy unikać mieszania operacji w oparciu o strumień i niestrumieniowo w tym samym kontrakcie.</span><span class="sxs-lookup"><span data-stu-id="63c21-223">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="63c21-224">W przypadku absolutnej konieczności mieszania dwóch modeli programowania należy zastosować następujące środki ostrożności:</span><span class="sxs-lookup"><span data-stu-id="63c21-224">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="63c21-225">Wyłącz funkcję, <xref:System.Runtime.Serialization.IExtensibleDataObject> ustawiając <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Właściwość <xref:System.ServiceModel.ServiceBehaviorAttribute> na `true` .</span><span class="sxs-lookup"><span data-stu-id="63c21-225">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="63c21-226">Dzięki temu tylko członkowie, którzy są częścią kontraktu, są deszeregowani.</span><span class="sxs-lookup"><span data-stu-id="63c21-226">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="63c21-227">Ustaw <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> Właściwość <xref:System.Runtime.Serialization.DataContractSerializer> na wartość bezpieczną.</span><span class="sxs-lookup"><span data-stu-id="63c21-227">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="63c21-228">Ten limit przydziału jest również dostępny dla <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu lub za pomocą konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="63c21-228">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="63c21-229">Ten limit przydziału ogranicza liczbę obiektów, które są deserializowane w jednym odcinku deserializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-229">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="63c21-230">Zwykle każdy parametr operacji lub część treści komunikatu w kontrakcie komunikatu jest deserializowana w jednym z epizodów.</span><span class="sxs-lookup"><span data-stu-id="63c21-230">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="63c21-231">Podczas deserializacji tablic każda pozycja tablicy jest traktowana jako oddzielny obiekt.</span><span class="sxs-lookup"><span data-stu-id="63c21-231">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="63c21-232">Ustaw wszystkie przydziały czytnika XML na wartości bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="63c21-232">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="63c21-233">Zwróć uwagę na to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> , <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> i <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> i unikaj ciągów w operacjach nieprzesyłających strumieniowo.</span><span class="sxs-lookup"><span data-stu-id="63c21-233">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="63c21-234">Przejrzyj listę znanych typów, pamiętając, że w dowolnym momencie można utworzyć wystąpienie dowolnego z nich (zobacz sekcję "uniemożliwianie załadowania nieoczekiwanych typów" w dalszej części tego tematu).</span><span class="sxs-lookup"><span data-stu-id="63c21-234">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="63c21-235">Nie należy używać żadnych typów, które implementują <xref:System.Xml.Serialization.IXmlSerializable> interfejs buforujący dużą ilość danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-235">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="63c21-236">Nie należy dodawać takich typów do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="63c21-236">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="63c21-237">Nie należy używać <xref:System.Xml.XmlElement> tablic, <xref:System.Xml.XmlNode> <xref:System.Byte> tablic ani typów, które implementują <xref:System.Runtime.Serialization.ISerializable> kontrakt.</span><span class="sxs-lookup"><span data-stu-id="63c21-237">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="63c21-238">Nie używaj <xref:System.Xml.XmlElement> , tablic, <xref:System.Xml.XmlNode> <xref:System.Byte> tablic ani typów, które implementują <xref:System.Runtime.Serialization.ISerializable> na liście znanych typów.</span><span class="sxs-lookup"><span data-stu-id="63c21-238">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="63c21-239">Powyższe środki ostrożności stosuje się, gdy operacja niestrumieniowa używa <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="63c21-239">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="63c21-240">Nie należy mieszać modeli programistycznych przesyłania strumieniowego i niestrumieniowego w tej samej usłudze, jeśli używasz programu <xref:System.Xml.Serialization.XmlSerializer> , ponieważ nie ma on ochrony <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> limitu przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-240">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="63c21-241">Wolne ataki strumieniowe</span><span class="sxs-lookup"><span data-stu-id="63c21-241">Slow Stream Attacks</span></span>

<span data-ttu-id="63c21-242">Klasa ataków typu "odmowa usługi" przesyłania strumieniowego nie obejmuje zużycia pamięci.</span><span class="sxs-lookup"><span data-stu-id="63c21-242">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="63c21-243">Zamiast tego atak polega na powolnym nadawcy lub odbiorniku danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-243">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="63c21-244">Podczas oczekiwania na wysłanie lub odebranie danych zostaną wyczerpane zasoby, takie jak wątki i dostępne połączenia.</span><span class="sxs-lookup"><span data-stu-id="63c21-244">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="63c21-245">Taka sytuacja może wystąpić w wyniku złośliwego ataku lub z wiarygodnego nadawcy lub odbiornika w przypadku wolnego połączenia sieciowego.</span><span class="sxs-lookup"><span data-stu-id="63c21-245">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="63c21-246">Aby wyeliminować te ataki, Ustaw odpowiednio limity czasu transportu.</span><span class="sxs-lookup"><span data-stu-id="63c21-246">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="63c21-247">Aby uzyskać więcej informacji, zobacz [transport Transports](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-247">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="63c21-248">Na koniec nigdy nie używaj synchronicznych `Read` ani `Write` operacji podczas pracy z strumieniami w programie WCF.</span><span class="sxs-lookup"><span data-stu-id="63c21-248">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="63c21-249">Bezpieczne używanie kodu XML</span><span class="sxs-lookup"><span data-stu-id="63c21-249">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="63c21-250">Chociaż ta sekcja dotyczy języka XML, informacje dotyczą również dokumentów JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="63c21-250">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="63c21-251">Przydziały działają podobnie, przy użyciu [mapowania między JSON i XML](mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-251">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="63c21-252">Zabezpieczanie czytników XML</span><span class="sxs-lookup"><span data-stu-id="63c21-252">Secure XML Readers</span></span>

<span data-ttu-id="63c21-253">Sprawdzonych XML stanowi podstawę całego przetwarzania komunikatów w programie WCF.</span><span class="sxs-lookup"><span data-stu-id="63c21-253">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="63c21-254">Gdy dane XML są akceptowane z niezaufanego źródła, istnieją różne możliwości ataków typu "odmowa usługi", które muszą zostać skorygowane.</span><span class="sxs-lookup"><span data-stu-id="63c21-254">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="63c21-255">Funkcja WCF oferuje specjalne, bezpieczne czytelnicy XML.</span><span class="sxs-lookup"><span data-stu-id="63c21-255">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="63c21-256">Te czytelnicy są tworzone automatycznie podczas korzystania z jednego z standardowych kodowań w WCF (text, binary lub MTOM).</span><span class="sxs-lookup"><span data-stu-id="63c21-256">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="63c21-257">Niektóre funkcje zabezpieczeń na tych czytnikach są zawsze aktywne.</span><span class="sxs-lookup"><span data-stu-id="63c21-257">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="63c21-258">Na przykład czytelnicy nigdy nie przetwarzają definicji typu dokumentu (DTD), które są potencjalnym źródłem ataków typu "odmowa usługi" i nigdy nie powinny występować w prawdziwych komunikatach protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="63c21-258">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="63c21-259">Inne funkcje zabezpieczeń obejmują przydziały czytnika, które należy skonfigurować, które zostały opisane w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="63c21-259">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="63c21-260">Podczas pracy bezpośrednio z czytnikami XML (na przykład podczas pisania własnego kodera niestandardowego lub podczas pracy bezpośrednio z <xref:System.ServiceModel.Channels.Message> klasą), zawsze używaj zabezpieczonych czytników WCF, gdy istnieje prawdopodobieństwo pracy z niezaufanymi danymi.</span><span class="sxs-lookup"><span data-stu-id="63c21-260">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="63c21-261">Utwórz zabezpieczonych czytników, wywołując jedną z przeciążeń metody fabryki statycznej <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A> , <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A> lub <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> <xref:System.Xml.XmlDictionaryReader> klasy.</span><span class="sxs-lookup"><span data-stu-id="63c21-261">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="63c21-262">Podczas tworzenia czytnika należy przekazać bezpieczne wartości przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-262">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="63c21-263">Nie wywołuj `Create` przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="63c21-263">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="63c21-264">Nie tworzą one czytnika WCF.</span><span class="sxs-lookup"><span data-stu-id="63c21-264">These do not create a WCF reader.</span></span> <span data-ttu-id="63c21-265">Zamiast tego tworzony jest czytnik, który nie jest chroniony przez funkcje zabezpieczeń opisane w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="63c21-265">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="63c21-266">Przydziały czytnika</span><span class="sxs-lookup"><span data-stu-id="63c21-266">Reader Quotas</span></span>

<span data-ttu-id="63c21-267">Bezpieczne czytelnicy XML mają pięć konfigurowalnych limitów przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-267">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="63c21-268">Są one zwykle konfigurowane przy użyciu `ReaderQuotas` właściwości elementów powiązania kodowania lub standardowych powiązań lub przy użyciu <xref:System.Xml.XmlDictionaryReaderQuotas> obiektu przesłanego podczas tworzenia czytnika.</span><span class="sxs-lookup"><span data-stu-id="63c21-268">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="63c21-269">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="63c21-269">MaxBytesPerRead</span></span>

<span data-ttu-id="63c21-270">Ten limit przydziału ogranicza liczbę bajtów odczytywanych w ramach jednej `Read` operacji podczas odczytywania znacznika początkowego elementu i jego atrybutów.</span><span class="sxs-lookup"><span data-stu-id="63c21-270">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="63c21-271">(W przypadku niestrumieniowych przypadków sama sama nazwa elementu nie jest naliczana względem limitu przydziału). <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A>jest ważne z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="63c21-271">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="63c21-272">Nazwa elementu i jego atrybuty są zawsze buforowane w pamięci, gdy są odczytywane.</span><span class="sxs-lookup"><span data-stu-id="63c21-272">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="63c21-273">W związku z tym ważne jest, aby poprawnie ustawić ten limit przydziału w trybie przesyłania strumieniowego, aby zapobiec nadmiernemu buforowaniu, gdy jest oczekiwany strumień strumieniowy.</span><span class="sxs-lookup"><span data-stu-id="63c21-273">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="63c21-274">Zapoznaj się z `MaxDepth` sekcją limit przydziału, aby uzyskać informacje na temat rzeczywistej ilości buforowania.</span><span class="sxs-lookup"><span data-stu-id="63c21-274">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="63c21-275">Zbyt wiele atrybutów XML może korzystać z nieproporcjonalnego czasu przetwarzania, ponieważ nazwy atrybutów muszą być sprawdzane pod kątem unikatowości.</span><span class="sxs-lookup"><span data-stu-id="63c21-275">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="63c21-276">`MaxBytesPerRead`ograniczenie tego zagrożenia.</span><span class="sxs-lookup"><span data-stu-id="63c21-276">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="63c21-277">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="63c21-277">MaxDepth</span></span>

<span data-ttu-id="63c21-278">Ten limit przydziału ogranicza maksymalną głębokość zagnieżdżenia elementów XML.</span><span class="sxs-lookup"><span data-stu-id="63c21-278">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="63c21-279">Na przykład dokument " \<A> \<B> \<C/> \</B> \</A> " ma głębokość zagnieżdżenia trzech.</span><span class="sxs-lookup"><span data-stu-id="63c21-279">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="63c21-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>jest ważne z następujących powodów:</span><span class="sxs-lookup"><span data-stu-id="63c21-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="63c21-281">`MaxDepth`Interakcja z `MaxBytesPerRead` : czytnik zawsze przechowuje dane w pamięci dla bieżącego elementu i wszystkich jego elementów nadrzędnych, więc maksymalne użycie pamięci przez czytnik jest proporcjonalne do iloczynu tych dwóch ustawień.</span><span class="sxs-lookup"><span data-stu-id="63c21-281">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="63c21-282">Podczas deserializacji wykresu obiektów głęboko zagnieżdżonych, Deserializator jest zmuszony do uzyskania dostępu do całego stosu i wyrzuca nieodwracalne działania <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="63c21-282">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="63c21-283">Istnieje bezpośrednia korelacja między zagnieżdżeniem XML a zagnieżdżeniem obiektów dla <xref:System.Runtime.Serialization.DataContractSerializer> i <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="63c21-283">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="63c21-284">Służy `MaxDepth` do ograniczania tego zagrożenia.</span><span class="sxs-lookup"><span data-stu-id="63c21-284">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="63c21-285">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="63c21-285">MaxNameTableCharCount</span></span>

<span data-ttu-id="63c21-286">Ten limit przydziału ogranicza rozmiar *NameTable*czytnika.</span><span class="sxs-lookup"><span data-stu-id="63c21-286">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="63c21-287">NameTable zawiera pewne ciągi (takie jak przestrzenie nazw i prefiksy), które są napotkane podczas przetwarzania dokumentu XML.</span><span class="sxs-lookup"><span data-stu-id="63c21-287">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="63c21-288">Ponieważ te ciągi są buforowane w pamięci, należy ustawić ten limit przydziału, aby zapobiec nadmiernemu buforowaniu, gdy jest oczekiwany strumień.</span><span class="sxs-lookup"><span data-stu-id="63c21-288">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="63c21-289">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="63c21-289">MaxStringContentLength</span></span>

<span data-ttu-id="63c21-290">Ten limit przydziału ogranicza maksymalny rozmiar ciągu zwracanego przez czytnik XML.</span><span class="sxs-lookup"><span data-stu-id="63c21-290">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="63c21-291">Ten limit przydziału nie ogranicza zużycia pamięci w samym czytniku XML, ale w składniku, który korzysta z czytnika.</span><span class="sxs-lookup"><span data-stu-id="63c21-291">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="63c21-292">Na przykład gdy program <xref:System.Runtime.Serialization.DataContractSerializer> używa czytnika zabezpieczonego przy użyciu <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> , nie wykonuje deserializacji ciągów większych niż ten przydział.</span><span class="sxs-lookup"><span data-stu-id="63c21-292">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="63c21-293">Korzystając z <xref:System.Xml.XmlDictionaryReader> klasy bezpośrednio, nie wszystkie metody respektują ten przydział, ale tylko metody, które są przeznaczone specjalnie do odczytu ciągów, takich jak <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> Metoda.</span><span class="sxs-lookup"><span data-stu-id="63c21-293">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="63c21-294"><xref:System.Xml.XmlReader.Value%2A>Ten limit przydziału nie ma wpływ na Właściwość czytnika, dlatego nie należy jej używać, gdy wymagana jest Ochrona tego przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-294">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="63c21-295">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="63c21-295">MaxArrayLength</span></span>

<span data-ttu-id="63c21-296">Ten limit przydziału ogranicza maksymalny rozmiar tablicy elementów podstawowych, które zwraca czytnik XML, w tym tablic bajtowych.</span><span class="sxs-lookup"><span data-stu-id="63c21-296">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="63c21-297">Ten limit przydziału nie ogranicza zużycia pamięci w samym czytniku XML, ale w dowolnym składniku, który korzysta z czytnika.</span><span class="sxs-lookup"><span data-stu-id="63c21-297">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="63c21-298">Na przykład gdy program <xref:System.Runtime.Serialization.DataContractSerializer> używa czytnika zabezpieczonego przy użyciu <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> , nie deserializacji tablic bajtowych większych niż ten przydział.</span><span class="sxs-lookup"><span data-stu-id="63c21-298">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="63c21-299">Ważne jest, aby ustawić ten przydział przy próbie miksowania strumieniowych i buforowanych modeli programowania w ramach jednego kontraktu.</span><span class="sxs-lookup"><span data-stu-id="63c21-299">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="63c21-300">Należy pamiętać, że w przypadku używania <xref:System.Xml.XmlDictionaryReader> klasy bezpośrednio, tylko metody, które są specjalnie przeznaczone do odczytywania tablic o dowolnym rozmiarze niektórych typów pierwotnych, na przykład <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A> , przestrzeganie tego limitu przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-300">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="63c21-301">Zagrożenia specyficzne dla kodowania binarnego</span><span class="sxs-lookup"><span data-stu-id="63c21-301">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="63c21-302">Binarne kodowanie XML obsługiwane przez WCF zawiera funkcję *ciągów słownika* .</span><span class="sxs-lookup"><span data-stu-id="63c21-302">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="63c21-303">Duży ciąg może być zakodowany przy użyciu tylko kilku bajtów.</span><span class="sxs-lookup"><span data-stu-id="63c21-303">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="63c21-304">Zapewnia to znaczący wzrost wydajności, ale wprowadza nowe zagrożenia typu "odmowa usługi", które należy wyeliminować.</span><span class="sxs-lookup"><span data-stu-id="63c21-304">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="63c21-305">Istnieją dwa rodzaje słowników: *static* i *Dynamic*.</span><span class="sxs-lookup"><span data-stu-id="63c21-305">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="63c21-306">Statyczny słownik jest wbudowaną listą długich ciągów, które mogą być reprezentowane przy użyciu krótkiego kodu w kodowaniu binarnym.</span><span class="sxs-lookup"><span data-stu-id="63c21-306">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="63c21-307">Ta lista ciągów jest ustalana podczas tworzenia czytnika i nie można jej modyfikować.</span><span class="sxs-lookup"><span data-stu-id="63c21-307">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="63c21-308">Żaden z ciągów w słowniku statycznym, który domyślnie nie używa WCF, jest wystarczająco duży, aby postanowić poważne zagrożenie odmowy usługi, chociaż mogą one być nadal używane w ataku do rozbudowy słownika.</span><span class="sxs-lookup"><span data-stu-id="63c21-308">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="63c21-309">W zaawansowanych scenariuszach, w których dostarczasz własny słownik statyczny, należy zachować ostrożność podczas wprowadzania dużych ciągów słownika.</span><span class="sxs-lookup"><span data-stu-id="63c21-309">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="63c21-310">Funkcja słowniki dynamiczne umożliwia aplikacjom Definiowanie własnych ciągów i kojarzenie ich z krótkimi kodami.</span><span class="sxs-lookup"><span data-stu-id="63c21-310">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="63c21-311">Te mapowania ciągów do kodu są przechowywane w pamięci podczas całej sesji komunikacji, w taki sposób, że kolejne komunikaty nie muszą ponownie wysyłać ciągów i mogą korzystać z kodów, które są już zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="63c21-311">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="63c21-312">Te ciągi mogą mieć dowolną długość i w ten sposób stanowić bardziej poważne zagrożenie niż te w słowniku statycznym.</span><span class="sxs-lookup"><span data-stu-id="63c21-312">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="63c21-313">Pierwszym zagrożeniem, które musi zostać skorygowane, jest możliwość, że słownik dynamiczny (Tabela mapowania ciągu do kodu) staje się zbyt duży.</span><span class="sxs-lookup"><span data-stu-id="63c21-313">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="63c21-314">Ten słownik może być rozwinięty w ciągu kilku komunikatów i dlatego `MaxReceivedMessageSize` limit przydziału nie zapewnia ochrony, ponieważ ma zastosowanie tylko do poszczególnych komunikatów.</span><span class="sxs-lookup"><span data-stu-id="63c21-314">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="63c21-315">W związku z tym istnieje oddzielna <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> Właściwość, <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> która ogranicza rozmiar słownika.</span><span class="sxs-lookup"><span data-stu-id="63c21-315">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="63c21-316">W przeciwieństwie do większości innych przydziałów, ten limit przydziału stosuje się również podczas pisania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="63c21-316">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="63c21-317">Jeśli zostanie przekroczony podczas odczytywania komunikatu, `QuotaExceededException` jest on generowany w zwykły sposób.</span><span class="sxs-lookup"><span data-stu-id="63c21-317">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="63c21-318">Jeśli zostanie przekroczony podczas zapisywania komunikatu, wszelkie ciągi, które powodują przekroczenie limitu przydziału, są zapisywane w postaci, w jakiej są, bez używania funkcji słowniki dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="63c21-318">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="63c21-319">Zagrożenia rozszerzenia słownika</span><span class="sxs-lookup"><span data-stu-id="63c21-319">Dictionary Expansion Threats</span></span>

<span data-ttu-id="63c21-320">Znaczna Klasa ataków specyficznych dla plików binarnych wynika z rozszerzenia słownika.</span><span class="sxs-lookup"><span data-stu-id="63c21-320">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="63c21-321">Niewielki komunikat w postaci binarnej może przełączać się do bardzo dużego komunikatu w w pełni rozwiniętej postaci tekstowej, jeśli jest to szerokie użycie funkcji słowników ciągów.</span><span class="sxs-lookup"><span data-stu-id="63c21-321">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="63c21-322">Współczynnik rozwinięcia dla ciągów słownika dynamicznego jest ograniczony przez <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> limit przydziału, ponieważ żaden ciąg słownika dynamicznego nie przekracza maksymalnego rozmiaru całego słownika.</span><span class="sxs-lookup"><span data-stu-id="63c21-322">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="63c21-323"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>Właściwości, `MaxStringContentLength` i `MaxArrayLength` ograniczają tylko użycie pamięci.</span><span class="sxs-lookup"><span data-stu-id="63c21-323">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="63c21-324">Zwykle nie są one wymagane do ograniczania zagrożeń w przypadku użycia niestrumieniowego, ponieważ użycie pamięci jest już ograniczone przez program `MaxReceivedMessageSize` .</span><span class="sxs-lookup"><span data-stu-id="63c21-324">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="63c21-325">Zlicza natomiast `MaxReceivedMessageSize` bajty sprzed rozbudowy.</span><span class="sxs-lookup"><span data-stu-id="63c21-325">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="63c21-326">Gdy kodowanie binarne jest w użyciu, użycie pamięci może potencjalnie przekroczyć `MaxReceivedMessageSize` , ograniczenie tylko przez współczynnik <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> .</span><span class="sxs-lookup"><span data-stu-id="63c21-326">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="63c21-327">Z tego powodu ważne jest, aby zawsze ustawiać wszystkie przydziały czytnika (zwłaszcza w <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> przypadku używania kodowania binarnego).</span><span class="sxs-lookup"><span data-stu-id="63c21-327">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="63c21-328">W przypadku używania kodowania binarnego razem z <xref:System.Runtime.Serialization.DataContractSerializer> , `IExtensibleDataObject` interfejs może być nieużywany do instalowania ataku do rozszerzenia słownika.</span><span class="sxs-lookup"><span data-stu-id="63c21-328">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="63c21-329">Ten interfejs zasadniczo zapewnia nieograniczony magazyn dla dowolnych danych, które nie są częścią kontraktu.</span><span class="sxs-lookup"><span data-stu-id="63c21-329">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="63c21-330">Jeśli nie można ustawić przydziałów z niską ilością, która została `MaxSessionSize` pomnożona przez nie powoduje `MaxReceivedMessageSize` problemu, należy wyłączyć tę `IExtensibleDataObject` funkcję w przypadku używania kodowania binarnego.</span><span class="sxs-lookup"><span data-stu-id="63c21-330">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="63c21-331">Ustaw `IgnoreExtensionDataObject` Właściwość na wartość `true` `ServiceBehaviorAttribute` atrybutu.</span><span class="sxs-lookup"><span data-stu-id="63c21-331">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="63c21-332">Alternatywnie nie należy implementować `IExtensibleDataObject` interfejsu.</span><span class="sxs-lookup"><span data-stu-id="63c21-332">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="63c21-333">Aby uzyskać więcej informacji, zobacz [Kontrakty danych zgodne z przekazywaniem dalej](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-333">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="63c21-334">Podsumowanie przydziałów</span><span class="sxs-lookup"><span data-stu-id="63c21-334">Quotas Summary</span></span>

<span data-ttu-id="63c21-335">Poniższa tabela zawiera podsumowanie wskazówek dotyczących przydziałów.</span><span class="sxs-lookup"><span data-stu-id="63c21-335">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="63c21-336">Warunek</span><span class="sxs-lookup"><span data-stu-id="63c21-336">Condition</span></span>|<span data-ttu-id="63c21-337">Ważne przydziały do ustawienia</span><span class="sxs-lookup"><span data-stu-id="63c21-337">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="63c21-338">Brak przesyłania strumieniowego lub przesyłania strumieniowego małych komunikatów, tekstu lub kodowania MTOM</span><span class="sxs-lookup"><span data-stu-id="63c21-338">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="63c21-339">`MaxReceivedMessageSize`, `MaxBytesPerRead` i`MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="63c21-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="63c21-340">Brak przesyłania strumieniowego i przesyłania strumieniowego małych komunikatów, kodowanie binarne</span><span class="sxs-lookup"><span data-stu-id="63c21-340">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="63c21-341">`MaxReceivedMessageSize`, `MaxSessionSize` i wszystkie`ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="63c21-341">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="63c21-342">Przesyłanie strumieniowe dużych komunikatów, tekstu lub kodowania MTOM</span><span class="sxs-lookup"><span data-stu-id="63c21-342">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="63c21-343">`MaxBufferSize`i wszystkie`ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="63c21-343">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="63c21-344">Przesyłanie strumieniowe dużych komunikatów, kodowanie binarne</span><span class="sxs-lookup"><span data-stu-id="63c21-344">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="63c21-345">`MaxBufferSize`, `MaxSessionSize` i wszystkie`ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="63c21-345">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="63c21-346">Limity czasu na poziomie transportu muszą zawsze być ustawione i nigdy nie używać synchronicznych operacji odczytu/zapisu, gdy przesyłanie strumieniowe jest w użyciu, niezależnie od tego, czy przesyłasz strumieniowo duże lub małe wiadomości.</span><span class="sxs-lookup"><span data-stu-id="63c21-346">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="63c21-347">W razie wątpliwości dotyczących limitu przydziału Ustaw dla niego wartość bezpieczną, zamiast pozostawić ją otwartą.</span><span class="sxs-lookup"><span data-stu-id="63c21-347">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="63c21-348">Zapobieganie wykonywaniu złośliwego kodu</span><span class="sxs-lookup"><span data-stu-id="63c21-348">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="63c21-349">Następujące ogólne klasy zagrożeń mogą wykonywać kod i mieć niezamierzone efekty:</span><span class="sxs-lookup"><span data-stu-id="63c21-349">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="63c21-350">Deserializator ładuje złośliwy, niebezpieczny lub wrażliwy na zabezpieczenia typ.</span><span class="sxs-lookup"><span data-stu-id="63c21-350">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="63c21-351">Komunikat przychodzący powoduje, że Deserializator Konstruuje wystąpienie zwykle bezpiecznego typu w taki sposób, że ma niezamierzone konsekwencje.</span><span class="sxs-lookup"><span data-stu-id="63c21-351">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="63c21-352">W poniższych sekcjach szczegółowo omówiono te klasy zagrożeń.</span><span class="sxs-lookup"><span data-stu-id="63c21-352">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="63c21-353">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="63c21-353">DataContractSerializer</span></span>

<span data-ttu-id="63c21-354">(Aby uzyskać informacje o zabezpieczeniach w programie <xref:System.Xml.Serialization.XmlSerializer> , zobacz odpowiednią dokumentację). Model zabezpieczeń dla programu <xref:System.Xml.Serialization.XmlSerializer> jest podobny do tego dla programu <xref:System.Runtime.Serialization.DataContractSerializer> i różni się głównie szczegółowo.</span><span class="sxs-lookup"><span data-stu-id="63c21-354">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="63c21-355">Na przykład <xref:System.Xml.Serialization.XmlIncludeAttribute> atrybut jest używany do dołączania typu zamiast <xref:System.Runtime.Serialization.KnownTypeAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="63c21-355">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="63c21-356">Jednak niektóre zagrożenia specyficzne dla programu <xref:System.Xml.Serialization.XmlSerializer> zostały omówione w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="63c21-356">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="63c21-357">Uniemożliwianie ładowania nieplanowanych typów</span><span class="sxs-lookup"><span data-stu-id="63c21-357">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="63c21-358">Ładowanie niezamierzonych typów może mieć znaczące konsekwencje, bez względu na to, czy typ jest złośliwy, czy tylko ma efekty uboczne z uwzględnieniem zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="63c21-358">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="63c21-359">Typ może zawierać luki w zabezpieczeniach, które mogą być używane w konstruktorze lub konstruktorze klasy, mają duże rozmiary pamięci, które ułatwiają ataki typu "odmowa usługi" lub mogą generować nieodzyskiwalne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="63c21-359">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="63c21-360">Typy mogą mieć konstruktory klas, które są uruchamiane natychmiast po załadowaniu typu i przed utworzeniem jakichkolwiek wystąpień.</span><span class="sxs-lookup"><span data-stu-id="63c21-360">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="63c21-361">Z tego powodu ważne jest, aby kontrolować zestaw typów, które może ładować Deserializator.</span><span class="sxs-lookup"><span data-stu-id="63c21-361">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="63c21-362"><xref:System.Runtime.Serialization.DataContractSerializer>Deserializacji w luźno połączony sposób.</span><span class="sxs-lookup"><span data-stu-id="63c21-362">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="63c21-363">Nigdy nie odczytuje typu środowiska uruchomieniowego języka wspólnego (CLR) ani nazw zestawów z danych przychodzących.</span><span class="sxs-lookup"><span data-stu-id="63c21-363">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="63c21-364">Jest to podobne do zachowania <xref:System.Xml.Serialization.XmlSerializer> , ale różni się od zachowania <xref:System.Runtime.Serialization.NetDataContractSerializer> , <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> i <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> .</span><span class="sxs-lookup"><span data-stu-id="63c21-364">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="63c21-365">Luźny sprzężenie wprowadza stopień bezpieczeństwa, ponieważ zdalna osoba atakująca nie może wskazywać dowolnego typu do załadowania tylko przez nadanie tego typu w wiadomości.</span><span class="sxs-lookup"><span data-stu-id="63c21-365">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="63c21-366"><xref:System.Runtime.Serialization.DataContractSerializer>Zawsze można załadować typ, który jest aktualnie oczekiwany zgodnie z umową.</span><span class="sxs-lookup"><span data-stu-id="63c21-366">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="63c21-367">Na przykład jeśli kontrakt danych ma składową danych typu `Customer` , <xref:System.Runtime.Serialization.DataContractSerializer> można załadować `Customer` Typ podczas deserializacji tego elementu członkowskiego danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-367">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="63c21-368">Ponadto <xref:System.Runtime.Serialization.DataContractSerializer> obsługuje polimorfizm.</span><span class="sxs-lookup"><span data-stu-id="63c21-368">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="63c21-369">Element członkowski danych może być zadeklarowany jako <xref:System.Object> , ale dane przychodzące mogą zawierać `Customer` wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="63c21-369">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="63c21-370">Jest to możliwe tylko wtedy, gdy `Customer` Typ został "znany" do deserializacji za pomocą jednego z następujących mechanizmów:</span><span class="sxs-lookup"><span data-stu-id="63c21-370">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="63c21-371"><xref:System.Runtime.Serialization.KnownTypeAttribute>atrybut zastosowany do typu.</span><span class="sxs-lookup"><span data-stu-id="63c21-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="63c21-372">`KnownTypeAttribute`atrybut określający metodę, która zwraca listę typów.</span><span class="sxs-lookup"><span data-stu-id="63c21-372">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="63c21-373">`ServiceKnownTypeAttribute`przypisane.</span><span class="sxs-lookup"><span data-stu-id="63c21-373">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="63c21-374">`KnownTypes`Sekcja konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="63c21-374">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="63c21-375">Lista znanych typów jawnie przenoszona do <xref:System.Runtime.Serialization.DataContractSerializer> podczas konstruowania, jeśli używasz serializatora bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="63c21-375">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="63c21-376">Każdy z tych mechanizmów zwiększa powierzchnię obszaru, wprowadzając więcej typów, które Deserializator może załadować.</span><span class="sxs-lookup"><span data-stu-id="63c21-376">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="63c21-377">Kontroluj każdy z tych mechanizmów, aby upewnić się, że żadne złośliwe lub niezamierzone typy nie są dodawane do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="63c21-377">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="63c21-378">Gdy znany typ znajduje się w zakresie, można go załadować w dowolnym momencie, a wystąpienia typu można utworzyć, nawet jeśli kontrakt zakazuje rzeczywiste użycie.</span><span class="sxs-lookup"><span data-stu-id="63c21-378">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="63c21-379">Na przykład załóżmy, że typ "unniebezpiecznychtype" zostanie dodany do listy znanych typów przy użyciu jednego z powyższych mechanizmów.</span><span class="sxs-lookup"><span data-stu-id="63c21-379">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="63c21-380">Oznacza to, że:</span><span class="sxs-lookup"><span data-stu-id="63c21-380">This means that:</span></span>

- <span data-ttu-id="63c21-381">`MyDangerousType`jest ładowany, a jego Konstruktor klas działa.</span><span class="sxs-lookup"><span data-stu-id="63c21-381">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="63c21-382">Nawet w przypadku deserializacji kontraktu danych za pomocą elementu członkowskiego danych w postaci ciągu złośliwy komunikat może nadal spowodować wystąpienie `MyDangerousType` do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="63c21-382">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="63c21-383">Kod w `MyDangerousType` , taki jak metody ustawiające właściwości, może być uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="63c21-383">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="63c21-384">Po wykonaniu tej czynności Deserializator próbuje przypisać to wystąpienie do elementu członkowskiego danych String i niepowodzeniem z wyjątkiem.</span><span class="sxs-lookup"><span data-stu-id="63c21-384">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="63c21-385">Podczas pisania metody zwracającej listę znanych typów lub przekazywania listy bezpośrednio do <xref:System.Runtime.Serialization.DataContractSerializer> konstruktora upewnij się, że kod, który przygotowuje listę, jest bezpieczny i działa tylko na zaufanych danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-385">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="63c21-386">Jeśli określono znane typy w konfiguracji, upewnij się, że plik konfiguracji jest bezpieczny.</span><span class="sxs-lookup"><span data-stu-id="63c21-386">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="63c21-387">Zawsze Używaj silnych nazw w konfiguracji (poprzez określenie klucza publicznego podpisanego zestawu, w którym znajduje się typ), ale nie określaj wersji typu do załadowania.</span><span class="sxs-lookup"><span data-stu-id="63c21-387">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="63c21-388">Moduł ładujący typ automatycznie wybiera najnowszą wersję, jeśli jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="63c21-388">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="63c21-389">W przypadku określenia konkretnej wersji w konfiguracji, należy uruchomić następujące zagrożenie: typ może mieć lukę w zabezpieczeniach, która może zostać rozwiązana w przyszłej wersji, ale nadal jest ona załadowana, ponieważ jest ona jawnie określona w konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="63c21-389">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="63c21-390">Zbyt wiele znanych typów ma inną sekwencję: <xref:System.Runtime.Serialization.DataContractSerializer> tworzy pamięć podręczną kodu serializacji/deserializacji w domenie aplikacji, z wpisem dla każdego typu, który musi serializować i zdeserializować.</span><span class="sxs-lookup"><span data-stu-id="63c21-390">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="63c21-391">Ta pamięć podręczna nigdy nie jest czyszczona, o ile domena aplikacji jest uruchomiona.</span><span class="sxs-lookup"><span data-stu-id="63c21-391">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="63c21-392">W związku z tym osoba atakująca, która wie, że aplikacja używa wielu znanych typów, może spowodować deserializacja wszystkich tych typów, powodując, że pamięć podręczna zużywa nieproporcjonalnie dużą ilość pamięci.</span><span class="sxs-lookup"><span data-stu-id="63c21-392">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="63c21-393">Zapobieganie, że typy nie są w stanie niezamierzonym</span><span class="sxs-lookup"><span data-stu-id="63c21-393">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="63c21-394">Typ może mieć wewnętrzne ograniczenia spójności, które muszą zostać wymuszone.</span><span class="sxs-lookup"><span data-stu-id="63c21-394">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="63c21-395">Należy zachować ostrożność, aby uniknąć przerywania tych ograniczeń podczas deserializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-395">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="63c21-396">Poniższy przykład typu reprezentuje stan blokady na statku kosmicznym i wymusza ograniczenie, że zarówno drzwi wewnętrzne, jak i zewnętrzne nie mogą być otwarte w tym samym czasie.</span><span class="sxs-lookup"><span data-stu-id="63c21-396">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="63c21-397">Osoba atakująca może wysłać złośliwy komunikat w taki sposób, aby obejść ograniczenia i pobrać obiekt w nieprawidłowym stanie, który może mieć niezamierzone i nieprzewidywalne konsekwencje.</span><span class="sxs-lookup"><span data-stu-id="63c21-397">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="63c21-398">Tę sytuację można uniknąć, wiedząc o następujących kwestiach:</span><span class="sxs-lookup"><span data-stu-id="63c21-398">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="63c21-399">Gdy <xref:System.Runtime.Serialization.DataContractSerializer> deserializacji większość klas, konstruktory nie są uruchamiane.</span><span class="sxs-lookup"><span data-stu-id="63c21-399">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="63c21-400">W związku z tym nie należy polegać na zarządzaniu stanami w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="63c21-400">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="63c21-401">Użyj wywołania zwrotnego, aby upewnić się, że obiekt jest w prawidłowym stanie.</span><span class="sxs-lookup"><span data-stu-id="63c21-401">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="63c21-402">Wywołanie zwrotne oznaczone <xref:System.Runtime.Serialization.OnDeserializedAttribute> atrybutem jest szczególnie przydatne, ponieważ jest uruchamiane po ukończeniu deserializacji i ma szansę na sprawdzenie i poprawienie ogólnego stanu.</span><span class="sxs-lookup"><span data-stu-id="63c21-402">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="63c21-403">Aby uzyskać więcej informacji, zobacz [wywołania zwrotne serializacji odporne na wersje](version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-403">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="63c21-404">Nie należy projektować typów kontraktu danych, aby polegać na każdej określonej kolejności, w której należy wywołać metody ustawiające właściwości.</span><span class="sxs-lookup"><span data-stu-id="63c21-404">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="63c21-405">Należy zachować ostrożność przy użyciu starszych typów oznaczonych <xref:System.SerializableAttribute> atrybutem.</span><span class="sxs-lookup"><span data-stu-id="63c21-405">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="63c21-406">Wiele z nich zostało zaprojektowanych do pracy z .NET Framework usługami zdalnymi do użytku tylko z zaufanymi danymi.</span><span class="sxs-lookup"><span data-stu-id="63c21-406">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="63c21-407">Istniejące typy oznaczone za pomocą tego atrybutu mogą nie zostać zaprojektowane z myślą o bezpieczeństwie stanu.</span><span class="sxs-lookup"><span data-stu-id="63c21-407">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="63c21-408">Nie należy polegać na <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> właściwościach <xref:System.Runtime.Serialization.DataMemberAttribute> atrybutu w celu zagwarantowania obecności danych, o ile dotyczy to bezpieczeństwa stanu.</span><span class="sxs-lookup"><span data-stu-id="63c21-408">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="63c21-409">Dane mogą mieć zawsze `null` , `zero` lub `invalid` .</span><span class="sxs-lookup"><span data-stu-id="63c21-409">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="63c21-410">Nie należy nigdy ufać grafowi obiektu odszeregowanym od niezaufanego źródła danych bez weryfikowania go jako pierwszego.</span><span class="sxs-lookup"><span data-stu-id="63c21-410">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="63c21-411">Każdy pojedynczy obiekt może być w spójnym stanie, ale wykres obiektów jako całość może nie być.</span><span class="sxs-lookup"><span data-stu-id="63c21-411">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="63c21-412">Ponadto nawet jeśli tryb zachowywania grafu obiektów jest wyłączony, deserializowany Wykres może mieć wiele odwołań do tego samego obiektu lub mieć odwołania cykliczne.</span><span class="sxs-lookup"><span data-stu-id="63c21-412">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="63c21-413">Aby uzyskać więcej informacji, zobacz [serializacji i deserializacji](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-413">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="63c21-414">Bezpieczne używanie NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="63c21-414">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="63c21-415"><xref:System.Runtime.Serialization.NetDataContractSerializer>Jest to aparat serializacji, który używa ścisłego sprzężenia do typów.</span><span class="sxs-lookup"><span data-stu-id="63c21-415">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="63c21-416">Jest to podobne do <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> i <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> .</span><span class="sxs-lookup"><span data-stu-id="63c21-416">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="63c21-417">Oznacza to, że określa typ do wystąpienia, odczytując zestaw .NET Framework i nazwę typu z danych przychodzących.</span><span class="sxs-lookup"><span data-stu-id="63c21-417">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="63c21-418">Chociaż jest częścią usługi WCF, nie ma żadnego podanego sposobu podłączania w tym aparacie serializacji; należy napisać kod niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="63c21-418">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="63c21-419">Usługa `NetDataContractSerializer` jest świadczona głównie w celu ułatwienia migracji .NET Framework komunikacji zdalnej do usługi WCF.</span><span class="sxs-lookup"><span data-stu-id="63c21-419">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="63c21-420">Aby uzyskać więcej informacji, zobacz sekcję dotyczącą [serializacji i deserializacji](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="63c21-420">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="63c21-421">Ponieważ sam komunikat może wskazywać, że każdy typ może być ładowany, <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanizm jest z natury niezabezpieczony i powinien być używany tylko z zaufanymi danymi.</span><span class="sxs-lookup"><span data-stu-id="63c21-421">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="63c21-422">Istnieje możliwość zapewnienia bezpieczeństwa przez zapisanie bezpiecznego, nieograniczonego typu, który umożliwia ładowanie tylko bezpiecznych typów (przy użyciu <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> Właściwości).</span><span class="sxs-lookup"><span data-stu-id="63c21-422">It is possible to make it secure by writing a secure, type-limiting type binder that allows only safe types to load (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property).</span></span>

<span data-ttu-id="63c21-423">Nawet w przypadku użycia z zaufanymi danymi dane przychodzące mogą niewystarczająco określić typ do załadowania, zwłaszcza jeśli <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> Właściwość jest ustawiona na <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> .</span><span class="sxs-lookup"><span data-stu-id="63c21-423">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="63c21-424">Każda osoba mająca dostęp do katalogu aplikacji lub globalnej pamięci podręcznej zestawów może zastąpić złośliwy typ zamiast tego, który powinien zostać załadowany.</span><span class="sxs-lookup"><span data-stu-id="63c21-424">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="63c21-425">Zawsze upewnij się, że zabezpieczenia katalogu aplikacji i globalnej pamięci podręcznej zestawów zostały prawidłowo ustawione.</span><span class="sxs-lookup"><span data-stu-id="63c21-425">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="63c21-426">Ogólnie rzecz biorąc, Jeśli zezwolisz na dostęp częściowo zaufanego kodu do Twojego `NetDataContractSerializer` wystąpienia lub w inny sposób kontroluje selektor zastępczy ( <xref:System.Runtime.Serialization.ISurrogateSelector> ) lub spinacz serializacji ( <xref:System.Runtime.Serialization.SerializationBinder> ), kod może nawiązać dużą kontrolę nad procesem serializacji/deserializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-426">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="63c21-427">Na przykład może wstrzyknąć dowolnego typu, prowadzić do ujawnienia informacji, naruszać wynikowy wykres obiektu lub dane serializowane lub przepełnić wynikowy strumień serializowany.</span><span class="sxs-lookup"><span data-stu-id="63c21-427">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="63c21-428">Innym problemem z bezpieczeństwem `NetDataContractSerializer` jest odmowa usługi, a nie złośliwe zagrożenie wykonania kodu.</span><span class="sxs-lookup"><span data-stu-id="63c21-428">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="63c21-429">W przypadku korzystania z programu `NetDataContractSerializer` należy zawsze ustawić <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> bezpieczną wartość przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-429">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="63c21-430">Można łatwo utworzyć małą złośliwą wiadomość, która alokuje tablicę obiektów, których rozmiar jest ograniczony tylko do tego przydziału.</span><span class="sxs-lookup"><span data-stu-id="63c21-430">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="63c21-431">XmlSerializer — zagrożenia specyficzne dla określonych</span><span class="sxs-lookup"><span data-stu-id="63c21-431">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="63c21-432"><xref:System.Xml.Serialization.XmlSerializer>Model zabezpieczeń jest podobny do tego <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="63c21-432">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="63c21-433">Niektóre zagrożenia są jednak unikatowe dla programu <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="63c21-433">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="63c21-434"><xref:System.Xml.Serialization.XmlSerializer>Generuje *zestawy serializacji* w czasie wykonywania, które zawierają kod, który faktycznie serializować i deserializacji; te zestawy są tworzone w katalogu plików tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="63c21-434">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="63c21-435">Jeśli jakiś inny proces lub użytkownik ma prawa dostępu do tego katalogu, mogą zastąpić kod serializacji/deserializacji z dowolnym kodem.</span><span class="sxs-lookup"><span data-stu-id="63c21-435">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="63c21-436"><xref:System.Xml.Serialization.XmlSerializer>Następnie uruchamia ten kod przy użyciu jego kontekstu zabezpieczeń, zamiast kodu serializacji/deserializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-436">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="63c21-437">Upewnij się, że uprawnienia są poprawnie ustawione w katalogu plików tymczasowych, aby zapobiec temu.</span><span class="sxs-lookup"><span data-stu-id="63c21-437">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="63c21-438"><xref:System.Xml.Serialization.XmlSerializer>Ma również tryb, w którym używa wstępnie wygenerowanych zestawów serializacji zamiast generować je w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="63c21-438">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="63c21-439">Ten tryb jest wyzwalany za każdym razem, gdy <xref:System.Xml.Serialization.XmlSerializer> może znaleźć odpowiedni zestaw serializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-439">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="63c21-440"><xref:System.Xml.Serialization.XmlSerializer>Sprawdza, czy zestaw serializacji został podpisany przez ten sam klucz, który został użyty do podpisania zestawu, który zawiera typy, które są serializowane.</span><span class="sxs-lookup"><span data-stu-id="63c21-440">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="63c21-441">Zapewnia to ochronę przed złośliwymi zestawami, które są ukrywane jako zestawy serializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-441">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="63c21-442">Jeśli jednak zestaw, który zawiera typy, które można serializować, nie jest podpisany, <xref:System.Xml.Serialization.XmlSerializer> nie może wykonać tego sprawdzenia i używa dowolnego zestawu o poprawnej nazwie.</span><span class="sxs-lookup"><span data-stu-id="63c21-442">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="63c21-443">Dzięki temu możliwe jest uruchomienie złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="63c21-443">This makes running malicious code possible.</span></span> <span data-ttu-id="63c21-444">Należy zawsze podpisywać zestawy, które zawierają typy możliwe do serializacji, lub ściśle kontrolować dostęp do katalogu aplikacji i globalnej pamięci podręcznej zestawów, aby zapobiec wprowadzaniu złośliwych zestawów.</span><span class="sxs-lookup"><span data-stu-id="63c21-444">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="63c21-445"><xref:System.Xml.Serialization.XmlSerializer>Może być przedmiotem ataku typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="63c21-445">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="63c21-446">Nie <xref:System.Xml.Serialization.XmlSerializer> ma `MaxItemsInObjectGraph` limitu przydziału (jest on dostępny w przypadku <xref:System.Runtime.Serialization.DataContractSerializer> ).</span><span class="sxs-lookup"><span data-stu-id="63c21-446">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="63c21-447">W ten sposób deserializacji arbitralnej ilości obiektów, który jest ograniczony tylko do rozmiaru wiadomości.</span><span class="sxs-lookup"><span data-stu-id="63c21-447">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="63c21-448">Częściowe zagrożenia zaufania</span><span class="sxs-lookup"><span data-stu-id="63c21-448">Partial Trust Threats</span></span>

<span data-ttu-id="63c21-449">Należy zwrócić uwagę na następujące kwestie dotyczące zagrożeń związanych z kodem uruchomionym z częściowym zaufaniem.</span><span class="sxs-lookup"><span data-stu-id="63c21-449">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="63c21-450">Te zagrożenia obejmują złośliwy, częściowo zaufany kod, a także złośliwy, częściowo zaufany kod w połączeniu z innymi scenariuszami ataków (na przykład częściowo zaufany kod, który konstruuje określony ciąg, a następnie deserializacji go).</span><span class="sxs-lookup"><span data-stu-id="63c21-450">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="63c21-451">W przypadku korzystania z dowolnych składników serializacji nigdy nie podawaj żadnych uprawnień przed takim użyciem, nawet jeśli cały scenariusz serializacji znajduje się w zakresie potwierdzenia i nie ma żadnych niezaufanych danych lub obiektów.</span><span class="sxs-lookup"><span data-stu-id="63c21-451">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="63c21-452">Takie użycie może prowadzić do luk w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="63c21-452">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="63c21-453">W przypadkach, gdy częściowo zaufany kod ma kontrolę nad procesem serializacji, za pośrednictwem punktów rozszerzalności (surogatów), typów, które są serializowane lub w inny sposób, kod częściowo zaufany może spowodować, że serializator wyprowadza dużą ilość danych do strumienia serializowanego, co może spowodować odmowę usługi (DoS) do odbiorcy tego strumienia.</span><span class="sxs-lookup"><span data-stu-id="63c21-453">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="63c21-454">W przypadku serializowania danych przeznaczonych dla obiektu docelowego, które są poufne dla zagrożeń systemu DoS, nie należy serializować częściowo zaufanych typów lub w inny sposób umożliwić serializacji z częściowo zaufanymi formantami kodu.</span><span class="sxs-lookup"><span data-stu-id="63c21-454">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="63c21-455">Jeśli zezwolisz na dostęp do wystąpienia częściowo zaufanego kodu <xref:System.Runtime.Serialization.DataContractSerializer> lub w inny sposób kontrolujesz [surogaty kontraktu danych](../extending/data-contract-surrogates.md), może być możliwe uzyskanie doskonałej kontroli nad procesem serializacji/deserializacji.</span><span class="sxs-lookup"><span data-stu-id="63c21-455">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="63c21-456">Na przykład może wstrzyknąć dowolnego typu, prowadzić do ujawnienia informacji, naruszać wynikowy wykres obiektu lub dane serializowane lub przepełnić wynikowy strumień serializowany.</span><span class="sxs-lookup"><span data-stu-id="63c21-456">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="63c21-457">Równoważne <xref:System.Runtime.Serialization.NetDataContractSerializer> zagrożenie zostało opisane w sekcji "Korzystanie z bezpiecznego NetDataContractSerializer".</span><span class="sxs-lookup"><span data-stu-id="63c21-457">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="63c21-458">Jeśli <xref:System.Runtime.Serialization.DataContractAttribute> atrybut jest stosowany do typu (lub typu oznaczonego jako <xref:System.SerializableAttribute> , ale nie <xref:System.Runtime.Serialization.ISerializable> ), Deserializator może utworzyć wystąpienie takiego typu, nawet jeśli wszystkie konstruktory są niepubliczne lub chronione przez żądania.</span><span class="sxs-lookup"><span data-stu-id="63c21-458">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="63c21-459">Nigdy nie ufaj wynikowi deserializacji, chyba że dane, które mają zostać deserializowane, są zaufane, a ty masz pewność, że wszystkie znane typy są zaufaniem.</span><span class="sxs-lookup"><span data-stu-id="63c21-459">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="63c21-460">Należy pamiętać, że znane typy nie są ładowane z pliku konfiguracji aplikacji (ale są ładowane z pliku konfiguracji komputera) podczas uruchamiania w częściowej relacji zaufania.</span><span class="sxs-lookup"><span data-stu-id="63c21-460">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="63c21-461">W przypadku przekazania <xref:System.Runtime.Serialization.DataContractSerializer> wystąpienia z surogatem dodanym do częściowo zaufanego kodu, kod może zmienić wszystkie modyfikowalne ustawienia dla tego surogatu.</span><span class="sxs-lookup"><span data-stu-id="63c21-461">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="63c21-462">W przypadku obiektu deserializowanego, jeśli czytnik XML (lub dane w tym miejscu) pochodzi z częściowo zaufanego kodu, należy traktować ten obiekt jako niezaufany.</span><span class="sxs-lookup"><span data-stu-id="63c21-462">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="63c21-463">Fakt, że <xref:System.Runtime.Serialization.ExtensionDataObject> Typ nie ma publicznych składowych, nie oznacza, że dane w niej są bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="63c21-463">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="63c21-464">Na przykład w przypadku deserializacji z uprzywilejowanego źródła danych do obiektu, w którym znajdują się pewne dane, następnie należy odczytywać ten obiekt do częściowo zaufanego kodu, częściowo zaufany kod może odczytać dane `ExtensionDataObject` przez Serializowanie obiektu.</span><span class="sxs-lookup"><span data-stu-id="63c21-464">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="63c21-465">Rozważ ustawienie <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> do `true` momentu deserializacji z uprzywilejowanego źródła danych do obiektu, który jest później przekazywać do kodu częściowo zaufanego.</span><span class="sxs-lookup"><span data-stu-id="63c21-465">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="63c21-466"><xref:System.Runtime.Serialization.DataContractSerializer>i <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> obsługują serializację prywatnych, chronionych, wewnętrznych i publicznych składowych w trybie pełnego zaufania.</span><span class="sxs-lookup"><span data-stu-id="63c21-466"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="63c21-467">Jednak w częściowej relacji zaufania tylko publiczne składowe mogą być serializowane.</span><span class="sxs-lookup"><span data-stu-id="63c21-467">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="63c21-468"><xref:System.Security.SecurityException>Występuje, gdy aplikacja próbuje serializować niepublicznego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="63c21-468">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="63c21-469">Aby zezwolić na Serializowanie wewnętrznych lub chronionych wewnętrznych elementów członkowskich w częściowej relacji zaufania, użyj <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atrybutu Assembly.</span><span class="sxs-lookup"><span data-stu-id="63c21-469">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="63c21-470">Ten atrybut umożliwia zestawowi zadeklarować, że jego wewnętrzne elementy członkowskie są widoczne dla innego zestawu.</span><span class="sxs-lookup"><span data-stu-id="63c21-470">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="63c21-471">W tym przypadku zestaw, który chce mieć zaszeregowaną wewnętrzną składową, deklaruje, że jego wewnętrzne elementy członkowskie są widoczne dla System. Runtime. Serialization. dll.</span><span class="sxs-lookup"><span data-stu-id="63c21-471">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="63c21-472">Zaletą tego podejścia jest to, że nie wymaga ścieżki generowania kodu z podwyższonym poziomem uprawnień.</span><span class="sxs-lookup"><span data-stu-id="63c21-472">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="63c21-473">W tym samym czasie istnieją dwie istotne wady.</span><span class="sxs-lookup"><span data-stu-id="63c21-473">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="63c21-474">Pierwsza wada polega na tym, że właściwość opt <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atrybutu jest dla całego zestawu.</span><span class="sxs-lookup"><span data-stu-id="63c21-474">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="63c21-475">Oznacza to, że nie można określić, że tylko niektóre klasy mogą mieć serializowane wewnętrzne składowe.</span><span class="sxs-lookup"><span data-stu-id="63c21-475">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="63c21-476">Oczywiście nadal możesz zrezygnować z serializacji określonego wewnętrznego elementu członkowskiego, nie dodając <xref:System.Runtime.Serialization.DataMemberAttribute> atrybutu do tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="63c21-476">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="63c21-477">Podobnie deweloper może również wybrać, aby element członkowski był wewnętrzny, a nie prywatny lub chroniony, z niewielkimi problemami z widocznością.</span><span class="sxs-lookup"><span data-stu-id="63c21-477">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="63c21-478">Druga wada polega na tym, że nadal nie obsługuje prywatnych ani chronionych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="63c21-478">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="63c21-479">Aby zilustrować użycie <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atrybutu w częściowej relacji zaufania, należy wziąć pod uwagę następujący program:</span><span class="sxs-lookup"><span data-stu-id="63c21-479">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="63c21-480">W powyższym przykładzie `PermissionsHelper.InternetZone` odpowiada <xref:System.Security.PermissionSet> za częściowe zaufanie.</span><span class="sxs-lookup"><span data-stu-id="63c21-480">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="63c21-481">Teraz, bez <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atrybutu, aplikacja zakończy się niepowodzeniem, <xref:System.Security.SecurityException> zwracając wskazującą, że niepubliczne składowe nie mogą być serializowane w częściowej relacji zaufania.</span><span class="sxs-lookup"><span data-stu-id="63c21-481">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="63c21-482">Jeśli jednak dodamy następujący wiersz do pliku źródłowego, program zostanie uruchomiony pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="63c21-482">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="63c21-483">Inne problemy związane z zarządzaniem stanem</span><span class="sxs-lookup"><span data-stu-id="63c21-483">Other State Management Concerns</span></span>

<span data-ttu-id="63c21-484">Należy zauważyć kilka innych problemów dotyczących zarządzania stanem obiektów:</span><span class="sxs-lookup"><span data-stu-id="63c21-484">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="63c21-485">W przypadku korzystania z modelu programowania opartego na strumieniach z transportem przesyłania strumieniowego, przetwarzanie komunikatu odbywa się po nadejściu wiadomości.</span><span class="sxs-lookup"><span data-stu-id="63c21-485">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="63c21-486">Nadawca wiadomości może przerwać operację wysyłania w środku strumienia, pozostawiając kod w stanie nieprzewidywalnym, jeśli Oczekiwano większej ilości zawartości.</span><span class="sxs-lookup"><span data-stu-id="63c21-486">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="63c21-487">Ogólnie rzecz biorąc nie należy polegać na zakończeniu przesyłania strumieniowego ani wykonywać żadnych zadań w operacji opartych na strumieniach, których nie można przywrócić w przypadku przerwania strumienia.</span><span class="sxs-lookup"><span data-stu-id="63c21-487">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="63c21-488">Dotyczy to również sytuacji, w której komunikat może być nieprawidłowo sformułowany po treści przesyłania strumieniowego (na przykład może brakować tagu końcowego dla koperty protokołu SOAP lub mieć drugą treść wiadomości).</span><span class="sxs-lookup"><span data-stu-id="63c21-488">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="63c21-489">Korzystanie z `IExtensibleDataObject` funkcji może spowodować emisję poufnych danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-489">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="63c21-490">W przypadku przyjmowania danych z niezaufanego źródła do kontraktów danych z `IExtensibleObjectData` i późniejszymi ponownymi emisjami w bezpiecznym kanale, w którym są podpisane komunikaty, możesz zagwarantowanie, że dane nie są już potrzebne.</span><span class="sxs-lookup"><span data-stu-id="63c21-490">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="63c21-491">Ponadto cały wysyłany stan może być nieprawidłowy, jeśli masz znane i nieznane fragmenty danych.</span><span class="sxs-lookup"><span data-stu-id="63c21-491">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="63c21-492">Unikaj tej sytuacji przez selektywne ustawienie właściwości dane rozszerzenia na `null` lub przez selektywne wyłączenie `IExtensibleObjectData` funkcji.</span><span class="sxs-lookup"><span data-stu-id="63c21-492">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="63c21-493">Importowanie schematu</span><span class="sxs-lookup"><span data-stu-id="63c21-493">Schema Import</span></span>

<span data-ttu-id="63c21-494">Zwykle proces importowania schematu do generowania typów odbywa się tylko w czasie projektowania, na przykład w przypadku korzystania z narzędzia do obsługi [metadanych ServiceModel (Svcutil. exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) w usłudze sieci Web w celu wygenerowania klasy klienta.</span><span class="sxs-lookup"><span data-stu-id="63c21-494">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="63c21-495">Jednak w bardziej zaawansowanych scenariuszach możesz przetwarzać schemat w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="63c21-495">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="63c21-496">Należy pamiętać, że takie działanie może ujawnić ryzyko wystąpienia zagrożeń typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="63c21-496">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="63c21-497">Importowanie niektórych schematów może zająć dużo czasu.</span><span class="sxs-lookup"><span data-stu-id="63c21-497">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="63c21-498">Nie należy używać <xref:System.Xml.Serialization.XmlSerializer> składnika importowania schematu w takich scenariuszach, jeśli schematy są prawdopodobnie pochodzące z niezaufanego źródła.</span><span class="sxs-lookup"><span data-stu-id="63c21-498">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="63c21-499">Zagrożenia związane z integracją ASP.NET AJAX</span><span class="sxs-lookup"><span data-stu-id="63c21-499">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="63c21-500">Gdy użytkownik implementuje <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> lub <xref:System.ServiceModel.Description.WebHttpBehavior> , program WCF uwidacznia punkt końcowy, który może akceptować zarówno wiadomości XML, jak i JSON.</span><span class="sxs-lookup"><span data-stu-id="63c21-500">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="63c21-501">Istnieje jednak tylko jeden zestaw przydziałów czytnika, używany zarówno przez czytnik XML, jak i czytnik JSON.</span><span class="sxs-lookup"><span data-stu-id="63c21-501">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="63c21-502">Niektóre ustawienia przydziału mogą być odpowiednie dla jednego czytnika, ale zbyt duże.</span><span class="sxs-lookup"><span data-stu-id="63c21-502">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="63c21-503">Podczas wdrażania `WebScriptEnablingBehavior` użytkownik ma możliwość uwidocznienia serwera proxy JavaScript w punkcie końcowym.</span><span class="sxs-lookup"><span data-stu-id="63c21-503">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="63c21-504">Należy wziąć pod uwagę następujące zagadnienia dotyczące zabezpieczeń:</span><span class="sxs-lookup"><span data-stu-id="63c21-504">The following security issues must be considered:</span></span>

- <span data-ttu-id="63c21-505">Informacje o usłudze (nazwy operacji, nazwach parametrów itd.) można uzyskać, badając serwer proxy JavaScript.</span><span class="sxs-lookup"><span data-stu-id="63c21-505">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="63c21-506">W przypadku korzystania z punktu końcowego języka JavaScript informacje poufne i prywatne mogą być przechowywane w pamięci podręcznej przeglądarki sieci Web klienta.</span><span class="sxs-lookup"><span data-stu-id="63c21-506">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="63c21-507">Uwaga dotycząca składników</span><span class="sxs-lookup"><span data-stu-id="63c21-507">A Note on Components</span></span>

<span data-ttu-id="63c21-508">WCF to elastyczny i dostosowywalny system.</span><span class="sxs-lookup"><span data-stu-id="63c21-508">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="63c21-509">Większość zawartości tego tematu koncentruje się na typowych scenariuszach użycia programu WCF.</span><span class="sxs-lookup"><span data-stu-id="63c21-509">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="63c21-510">Można jednak tworzyć składniki WCF na wiele różnych sposobów.</span><span class="sxs-lookup"><span data-stu-id="63c21-510">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="63c21-511">Ważne jest, aby zrozumieć implikacje zabezpieczeń związane z używaniem każdego składnika.</span><span class="sxs-lookup"><span data-stu-id="63c21-511">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="63c21-512">W szczególności:</span><span class="sxs-lookup"><span data-stu-id="63c21-512">In particular:</span></span>

- <span data-ttu-id="63c21-513">Jeśli musisz użyć czytników XML, użyj czytników, a w <xref:System.Xml.XmlDictionaryReader> przeciwieństwie do innych czytelników.</span><span class="sxs-lookup"><span data-stu-id="63c21-513">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="63c21-514">Bezpieczne czytelnicy są tworzone przy <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A> użyciu <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A> metod, lub <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> .</span><span class="sxs-lookup"><span data-stu-id="63c21-514">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="63c21-515">Nie należy używać <xref:System.Xml.XmlReader.Create%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="63c21-515">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="63c21-516">Zawsze należy konfigurować czytniki z bezpiecznymi limitami.</span><span class="sxs-lookup"><span data-stu-id="63c21-516">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="63c21-517">Aparaty serializacji w programie WCF są bezpieczne tylko wtedy, gdy są używane z bezpiecznymi czytnikami XML z programu WCF.</span><span class="sxs-lookup"><span data-stu-id="63c21-517">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="63c21-518">W przypadku korzystania z programu <xref:System.Runtime.Serialization.DataContractSerializer> do deserializacji potencjalnie niezaufanych danych zawsze ustawiaj <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> Właściwość.</span><span class="sxs-lookup"><span data-stu-id="63c21-518">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="63c21-519">Podczas tworzenia komunikatu ustaw `maxSizeOfHeaders` parametr, jeśli nie `MaxReceivedMessageSize` oferuje wystarczającej ochrony.</span><span class="sxs-lookup"><span data-stu-id="63c21-519">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="63c21-520">Podczas tworzenia kodera należy zawsze konfigurować odpowiednie przydziały, takie jak `MaxSessionSize` i `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="63c21-520">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="63c21-521">W przypadku korzystania z filtru komunikatów XPath ustaw, <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> Aby ograniczyć liczbę węzłów XML, które są filtrowane.</span><span class="sxs-lookup"><span data-stu-id="63c21-521">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="63c21-522">Nie należy używać wyrażeń XPath, które mogą potrwać dłuższy czas do obliczenia bez odwiedzania wielu węzłów.</span><span class="sxs-lookup"><span data-stu-id="63c21-522">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="63c21-523">Ogólnie rzecz biorąc, w przypadku użycia dowolnego składnika, który akceptuje limit przydziału, należy zapoznać się z jego wpływem na zabezpieczenia i ustawić bezpieczną wartość.</span><span class="sxs-lookup"><span data-stu-id="63c21-523">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="63c21-524">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="63c21-524">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="63c21-525">Znane typy kontraktów danych</span><span class="sxs-lookup"><span data-stu-id="63c21-525">Data Contract Known Types</span></span>](data-contract-known-types.md)
