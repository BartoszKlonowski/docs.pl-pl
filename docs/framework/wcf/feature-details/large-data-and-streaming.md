---
title: Duże ilości danych i przesyłanie strumieniowe
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 25ecc1db8218dfb49f591998140d86f551c5a0d5
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/08/2019
ms.locfileid: "59176335"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="6e70c-102">Duże ilości danych i przesyłanie strumieniowe</span><span class="sxs-lookup"><span data-stu-id="6e70c-102">Large Data and Streaming</span></span>
<span data-ttu-id="6e70c-103">Windows Communication Foundation (WCF) to infrastruktura komunikacji opartych na języku XML.</span><span class="sxs-lookup"><span data-stu-id="6e70c-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="6e70c-104">Ponieważ dane XML zwykle jest zakodowane w formacie tekstu standardowego, zdefiniowane w [Specyfikacja XML 1.0](https://go.microsoft.com/fwlink/?LinkId=94838), połączone systemy, deweloperów i architektów są zazwyczaj zajmującym się ochroną zużycie o komunikacji sieciowej (lub rozmiar) komunikaty wysyłane między sieć i kodowanie oparte na tekście XML stanowi szczególne wyzwanie wydajny transfer danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://go.microsoft.com/fwlink/?LinkId=94838), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="6e70c-105">Podstawowe zagadnienia</span><span class="sxs-lookup"><span data-stu-id="6e70c-105">Basic Considerations</span></span>  
 <span data-ttu-id="6e70c-106">Aby podać ogólne informacje o następujące informacje dotyczące usługi WCF, w tej sekcji opisano niektóre ogólne problemy i zagadnienia dotyczące kodowania i danych binarnych i przesyłania strumieniowego, zazwyczaj dotyczą połączonych systemów infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="6e70c-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="6e70c-107">Kodowanie danych: Vs tekstu. plików binarnych</span><span class="sxs-lookup"><span data-stu-id="6e70c-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="6e70c-108">Problemy najczęściej zaakceptowania developer obejmują wrażenie, że plik XML zawiera znaczne obciążenie w porównaniu do formaty binarne ze względu na charakter powtarzające się znaczniki start i znacznikami końcowymi, czy kodowanie wartości liczbowych jest uważany za znacznie większą ponieważ są wyrażone w wartości tekstowe i danych binarnych nie można wyrazić efektywne, ponieważ muszą być specjalnie kodowane dla osadzania w formacie tekstowym.</span><span class="sxs-lookup"><span data-stu-id="6e70c-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="6e70c-109">Chociaż wiele z nich i podobnych zastosowaniach dotyczy są prawidłowe, rzeczywiste różnica między wiadomości tekstu XML kodowane w środowisku usług XML sieci Web i wiadomości w formacie pliku binarnego w starszej wersji zdalnego wywołania procedury (RPC) środowiska często jest znacznie mniej istotne niż może sugerować początkowej brany pod uwagę.</span><span class="sxs-lookup"><span data-stu-id="6e70c-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="6e70c-110">Podczas tekstu XML zakodowany komunikaty są niewidoczne a "do odczytu", komunikatów binarnych często są dość zasłoniętej porównania i trudne do zdekodowania bez narzędzi.</span><span class="sxs-lookup"><span data-stu-id="6e70c-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="6e70c-111">Różnica w uzyskać jego lepszą czytelność prowadzi do przeoczyć, że komunikatów binarnych przenoszenia często wbudowanych metadanych ładunek, który dodaje obciążenie, podobnie jak w przypadku wiadomości tekstowe XML.</span><span class="sxs-lookup"><span data-stu-id="6e70c-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="6e70c-112">Ta zasada obowiązuje specjalnie dla danych binarnych formaty, w których mają na celu dostarczenie luźno sprzężenia i dynamiczne wywołania funkcji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="6e70c-113">Formaty binarne często zawierają takie informacje opisowe metadanych w "Nagłówek" deklaruje również układ danych dla następujących rekordów danych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="6e70c-114">Ładunek następnie następuje po tej deklaracji wspólnego blok metadanych z minimalnym dodatkowe obciążenie.</span><span class="sxs-lookup"><span data-stu-id="6e70c-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="6e70c-115">Z kolei XML otacza każdy element danych elementu lub atrybutu tak, aby otaczającej metadanych kilkukrotnie uwzględniane dla poszczególnych obiektów w ładunku serializowanych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="6e70c-116">W rezultacie, rozmiar obiektu jednym ładunku serializowanych przypomina podczas porównywania tekst do reprezentacji binarnych, ponieważ niektóre metadane opisowe muszą być wyrażone w obu przypadkach jednak korzyści format binarny z opisu udostępnionych metadanych z każdym dodatkowe Obiekt ładunku, który jest przekazywany z powodu mniejszy narzut ogólną.</span><span class="sxs-lookup"><span data-stu-id="6e70c-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="6e70c-117">Jednak dla niektórych typów danych, takich jak numery, może być niedogodność za pomocą stałym rozmiarze, binarne reprezentacje wartości liczbowych, 128-bitowego typu dziesiętnego zamiast zwykłego tekstu, np. jako zwykły tekst reprezentacji może być kilka mniejszych w bajtach.</span><span class="sxs-lookup"><span data-stu-id="6e70c-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="6e70c-118">Dane tekstowe również może korzystnie wpływać na rozmiar z zazwyczaj bardziej elastyczne tekstu XML, kodowania opcji, podczas gdy niektóre formaty binarne mogą domyślnie 16-bitowych lub nawet 32-bitowy Unicode, które nie ma zastosowania do formatu XML binarne .NET.</span><span class="sxs-lookup"><span data-stu-id="6e70c-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="6e70c-119">W rezultacie podjęciem decyzji o tekstowych lub binarnych nie jest dość łatwe jak zakładając, że komunikatów binarnych zawsze są mniejsze niż wiadomości tekstowe XML.</span><span class="sxs-lookup"><span data-stu-id="6e70c-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="6e70c-120">Wyczyść zalet wiadomości tekstowe XML jest są oparte na standardach i oferują największą wybór opcji współpracy i pomoc techniczna platformy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="6e70c-121">Aby uzyskać więcej informacji zobacz sekcję "Kodowania" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="6e70c-122">Zawartość binarna</span><span class="sxs-lookup"><span data-stu-id="6e70c-122">Binary Content</span></span>  
 <span data-ttu-id="6e70c-123">Jeden obszar, w których są oparte na tekście kodowania pod względem wynikowy rozmiar komunikatu przekracza kodami binarnymi są elementy dużych danych binarnych, takich jak obrazy, wideo, klipów dźwiękowych lub jakąkolwiek inną formę nieprzejrzystych, binarne dane, które muszą być wymieniane między usługami i ich odbiorcy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="6e70c-124">Aby dopasować te typy danych do tekstu XML, typowym podejściem jest kodować je przy użyciu kodowania Base64.</span><span class="sxs-lookup"><span data-stu-id="6e70c-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="6e70c-125">W ciągu zakodowanego algorytmem Base64 każdy znak reprezentuje 6 bitów oryginalnych danych 8-bitową, co skutkuje 4:3 kodowanie obciążenie współczynnik Base64, nie licząc zamykającego dodatkowego formatowania znaków (CR/LF), które są często dodane przez Konwencję.</span><span class="sxs-lookup"><span data-stu-id="6e70c-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="6e70c-126">Gdy znaczenie różnice między XML i kodami binarnymi zwykle zależy od scenariusza, przyrost rozmiaru ponad 33% podczas przesyłania ładunku 500 MB zazwyczaj nie jest dopuszczalne.</span><span class="sxs-lookup"><span data-stu-id="6e70c-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="6e70c-127">Aby uniknąć tego kodowania obciążenie, mechanizmu optymalizacji transmisji wiadomości (MTOM) standard umożliwia oddzielenie elementy dużych ilości danych, które są zawarte w wiadomości i znajdują się komunikatem jako dane binarne bez żadnych kodowania.</span><span class="sxs-lookup"><span data-stu-id="6e70c-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="6e70c-128">Za pomocą MTOM komunikaty są wymieniane w sposób podobny do transferu protokołu SMTP (Simple Mail) wiadomości e-mail z załącznikami lub osadzonej zawartości (obrazy i inną zawartość osadzoną); Komunikaty MTOM są spakowane jako sekwencje MIME multipart/związane z części głównej jest rzeczywista komunikatu protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="6e70c-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="6e70c-129">Komunikat protokołu SOAP MTOM jest modyfikowana z jego usunięcie zakodowanym wersji, tak, aby znaczniki specjalne elementów, które odwołują się do odpowiedniej części MIME odbywać elementów oryginalnej wiadomości, która zawiera dane binarne.</span><span class="sxs-lookup"><span data-stu-id="6e70c-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="6e70c-130">W rezultacie komunikatu protokołu SOAP odwołuje się do zawartości binarnej, wskazując części MIME wysyłane z niego, ale w przeciwnym razie po prostu niesie ze sobą dane tekstowe XML.</span><span class="sxs-lookup"><span data-stu-id="6e70c-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="6e70c-131">Ten model jest ściśle powiązana z dobrze udokumentowana modelu SMTP, nie istnieje szerokie, narzędzia do obsługi do kodowania i dekodowania MTOM wiadomości na wielu platformach, co czyni go bardzo interoperacyjne wybór.</span><span class="sxs-lookup"><span data-stu-id="6e70c-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="6e70c-132">Nadal podobnie jak w formacie Base64, MTOM również jest dostarczany z pewien narzut niezbędne w formacie MIME, aby korzyści wynikające z używania MTOM są tylko widoczne, gdy rozmiar elementu danych binarnych przekracza rozmiar około 1 KB.</span><span class="sxs-lookup"><span data-stu-id="6e70c-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="6e70c-133">Ze względu na obciążenie wiadomości w formacie MTOM może być większa niż wiadomości, które używają kodowania Base64 dla danych binarnych, jeśli ładunek danych binarnych pozostaje poniżej tej wartości progowej.</span><span class="sxs-lookup"><span data-stu-id="6e70c-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="6e70c-134">Aby uzyskać więcej informacji zobacz sekcję "Kodowania" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="6e70c-135">Zawartość dużych ilości danych</span><span class="sxs-lookup"><span data-stu-id="6e70c-135">Large Data Content</span></span>  
 <span data-ttu-id="6e70c-136">O komunikacji sieciowej — zużycie specjalnie, wymienionych wcześniej ładunku 500 MB stanowi również wspaniałe wyzwanie lokalnych, na dla usługi i klienta.</span><span class="sxs-lookup"><span data-stu-id="6e70c-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="6e70c-137">Domyślnie program WCF przetwarza wiadomości w *tryb buforowany*.</span><span class="sxs-lookup"><span data-stu-id="6e70c-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="6e70c-138">Oznacza to, że całą zawartość komunikatu jest obecne w pamięci, przed wysłaniem lub po ich odebraniu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="6e70c-139">Gdy to dobry strategii w przypadku większości scenariuszy i niezbędny do obsługi komunikatów funkcje, takie jak podpisów cyfrowych i niezawodne dostarczanie dużych komunikatów może wyczerpać zasobów systemowych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="6e70c-140">Strategia radzenia sobie z dużych ładunków jest przesyłanie strumieniowe.</span><span class="sxs-lookup"><span data-stu-id="6e70c-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="6e70c-141">Podczas wiadomości zwłaszcza tych, które wyrażone w formacie XML, są często traktowane jako pakiety danych stosunkowo compact, komunikat może mieć rozmiar wielu gigabajtów i przypominają strumienia ciągłego danych, więcej niż pakiet danych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="6e70c-142">Gdy dane są przesyłane w trybie przesyłania strumieniowego zamiast tryb buforowany, nadawca udostępnia zawartość treści wiadomości do odbiorcy w formie strumienia i infrastruktury komunikatów stale przekazuje dane od nadawcy do odbiorcy, ponieważ jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="6e70c-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="6e70c-143">Najbardziej typowym scenariuszem, w którym takiej zawartości dużych ilości danych, które Transfer odbywa się czy opłata za transfery danych binarnych obiekty, które:</span><span class="sxs-lookup"><span data-stu-id="6e70c-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
-   <span data-ttu-id="6e70c-144">Nie można łatwo podzielić na sekwencję wiadomości.</span><span class="sxs-lookup"><span data-stu-id="6e70c-144">Cannot be easily broken up into a message sequence.</span></span>  
  
-   <span data-ttu-id="6e70c-145">Musi być dostarczane w sposób terminowy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-145">Must be delivered in a timely manner.</span></span>  
  
-   <span data-ttu-id="6e70c-146">Nie są dostępne w całości po zainicjowaniu transferu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="6e70c-147">W przypadku danych, który nie ma tych warunków ograniczających zazwyczaj lepiej jest wysyłać sekwencje komunikaty w zakresie sesji niż jeden dużych bloków komunikatów.</span><span class="sxs-lookup"><span data-stu-id="6e70c-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="6e70c-148">Aby uzyskać więcej informacji zobacz sekcję "Przesyłanie strumieniowe danych" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="6e70c-149">Podczas wysyłania dużych ilości danych należy ustawić `maxAllowedContentLength` ustawienie programu IIS (Aby uzyskać więcej informacji, zobacz [Konfigurowanie limity żądań usług IIS](https://go.microsoft.com/fwlink/?LinkId=253165)) i `maxReceivedMessageSize` powiązanie ustawienia (na przykład [ System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) lub <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span><span class="sxs-lookup"><span data-stu-id="6e70c-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://go.microsoft.com/fwlink/?LinkId=253165)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="6e70c-150">`maxAllowedContentLength` Właściwości wartość domyślna to 28.6 M i `maxReceivedMessageSize` właściwości wartość domyślna to 64 KB.</span><span class="sxs-lookup"><span data-stu-id="6e70c-150">The `maxAllowedContentLength` property defaults to 28.6 M and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="6e70c-151">Encodings</span><span class="sxs-lookup"><span data-stu-id="6e70c-151">Encodings</span></span>  
 <span data-ttu-id="6e70c-152">*Kodowanie* definiuje zestaw reguł o tym, jak prezentować wiadomości na łączu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="6e70c-153">*Kodera* implementuje takich kodowania i jest odpowiedzialny za, na stronie nadawcy włączenie w pamięci <xref:System.ServiceModel.Channels.Message> do strumienia bajtów lub buforem bajtów, które mogą być wysyłane przez sieć.</span><span class="sxs-lookup"><span data-stu-id="6e70c-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="6e70c-154">Po stronie odbiorcy kodera włącza sekwencję bajtów do wiadomości w pamięci.</span><span class="sxs-lookup"><span data-stu-id="6e70c-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="6e70c-155">WCF zawiera trzy koderów i pozwala na zapis i dołączyć własnego kodery w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="6e70c-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="6e70c-156">Każda standardowa powiązania obejmuje wstępnie skonfigurowane kodera, według której powiązania z prefiksem Net \* Użyj kodera binarnego (umieszczając <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> klasy) podczas <xref:System.ServiceModel.BasicHttpBinding> i <xref:System.ServiceModel.WSHttpBinding> klasy korzystać koder tekstu komunikatu (przez klasy <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> klasy) domyślnie.</span><span class="sxs-lookup"><span data-stu-id="6e70c-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="6e70c-157">Koder elementu powiązania</span><span class="sxs-lookup"><span data-stu-id="6e70c-157">Encoder binding element</span></span>|<span data-ttu-id="6e70c-158">Opis</span><span class="sxs-lookup"><span data-stu-id="6e70c-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="6e70c-159">Koder komunikatów tekstu jest kodera domyślnego dla wszystkich opartych na protokole HTTP powiązań i odpowiednim wyborem dla wszystkich powiązań niestandardowych, gdzie współdziałanie jest kwestią najwyższy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="6e70c-160">Ten koder odczytuje i zapisuje standardowego protokołu SOAP 1.1 SOAP 1.2 wiadomości SMS za pomocą nie specjalnej obsługi dla danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="6e70c-161">Jeśli <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> wiadomości jest właściwością <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>otoki koperty protokołu SOAP jest pomijane w danych wyjściowych i zawartość treści komunikatu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="6e70c-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="6e70c-162">Koder komunikatów MTOM jest koder tekstu, który implementuje specjalnej obsługi dla danych binarnych i nie jest używany domyślnie we wszystkich standardowych powiązania, ponieważ jest on ściśle narzędzie optymalizacji w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="6e70c-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="6e70c-163">Jeśli komunikat zawiera dane binarne, która przekracza próg, w którym kodowanie MTOM stopa, dane są zewnętrznych do części MIME, zgodnie z koperty wiadomości.</span><span class="sxs-lookup"><span data-stu-id="6e70c-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="6e70c-164">Zobacz Włączanie MTOM w dalszej części tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="6e70c-165">Koder komunikatu binarnego jest kodera domyślnego dla Net \* powiązań i odpowiednim wyborem zawsze wtedy, gdy obie strony komunikujące się opierają się na WCF.</span><span class="sxs-lookup"><span data-stu-id="6e70c-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="6e70c-166">Koder komunikatu binarnego w formacie .NET binarne XML, reprezentacja binarna specyficzne dla firmy Microsoft, dla zestawów informacji XML (Infosets), która jest ogólnie daje mniejszy wyświetlacz niż równoważnych reprezentacji XML 1.0 koduje dane binarne w postaci bajtów strumień.</span><span class="sxs-lookup"><span data-stu-id="6e70c-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="6e70c-167">Kodowanie wiadomości tekstowe jest zwykle najlepszym wyborem dla dowolnej ścieżki komunikacji, wymagającego współdziałania, w trakcie kodowania komunikatu binarnego jest najlepszym wyborem dla dowolnej innej ścieżki komunikacji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="6e70c-168">Zazwyczaj kodowania komunikatu binarnego daje wiadomości mniejszych rozmiarów w porównaniu do tekstu dla pojedynczego stopniowo mniejszych komunikat i rozmiary w czasie trwania sesji komunikacji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="6e70c-169">W przeciwieństwie do kodowania tekstu, kodowanie binarne nie trzeba używać specjalnej obsługi dla danych binarnych, takich jak przy użyciu Base64, ale reprezentuje bajtów jako bajtów.</span><span class="sxs-lookup"><span data-stu-id="6e70c-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="6e70c-170">Jeśli rozwiązanie nie wymaga współdziałania, ale nadal chcesz używać transportu HTTP, można utworzyć <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> do niestandardowego powiązania, który używa <xref:System.ServiceModel.Channels.HttpTransportBindingElement> klasy dla transportu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="6e70c-171">Jeśli wielu klientów w usłudze wymagają współdziałania, zaleca się udostępnieniem równoległe punktów końcowych, że każdy ma odpowiednie transportu i opcji kodowania dla odpowiednich klientów włączone.</span><span class="sxs-lookup"><span data-stu-id="6e70c-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="6e70c-172">Włączanie MTOM</span><span class="sxs-lookup"><span data-stu-id="6e70c-172">Enabling MTOM</span></span>  
 <span data-ttu-id="6e70c-173">Gdy wymagane jest współdziałanie i muszą być wysyłane duże ilości danych binarnych, a następnie Kodowanie komunikatu MTOM jest alternatywą kodowanie strategii, która pozwala na standardzie <xref:System.ServiceModel.BasicHttpBinding> lub <xref:System.ServiceModel.WSHttpBinding> powiązania, ustawiając do odpowiednich `MessageEncoding` Właściwość <xref:System.ServiceModel.WSMessageEncoding.Mtom> lub za pośrednictwem <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> do <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="6e70c-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="6e70c-174">Poniższy przykład kodu, wyodrębnione z [kodowanie MTOM](../../../../docs/framework/wcf/samples/mtom-encoding.md) przykład pokazuje, jak włączyć MTOM w konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="6e70c-175">Jak wspomniano wcześniej, decyzji o użyciu, kodowanie MTOM zależy od ilości danych, które wysyłasz.</span><span class="sxs-lookup"><span data-stu-id="6e70c-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="6e70c-176">Ponadto ponieważ MTOM jest włączana na poziomie powiązania, włączanie MTOM ma wpływ na wszystkie operacje w danym punkcie końcowym.</span><span class="sxs-lookup"><span data-stu-id="6e70c-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="6e70c-177">Koder MTOM zawsze emituje MTOM zakodowane w formacie MIME/wielu-niepełnym komunikat niezależnie od tego, czy dane binarne kończy się on zewnętrznych, więc należy zwykle tylko włączyć MTOM dla punktów końcowych, które wymiana komunikatów z więcej niż 1 KB danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="6e70c-178">Również kontraktów usług przeznaczone do użytku z włączoną obsługą MTOM punktami końcowymi Jeśli to możliwe, można ograniczyć do określenia takich operacji transferu danych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="6e70c-179">Funkcje pokrewnej kontrolki powinien znajdować się w osobnej umowy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="6e70c-180">"Tylko MTOM" stosowana ta reguła tylko komunikaty wysyłane za pośrednictwem punktu końcowego dla komputerów z obsługą MTOM; koder MTOM można dekodować i analizowanie przychodzących wiadomości oraz innych MTOM.</span><span class="sxs-lookup"><span data-stu-id="6e70c-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="6e70c-181">Za pomocą koder MTOM jest zgodny z innymi funkcjami programu WCF.</span><span class="sxs-lookup"><span data-stu-id="6e70c-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="6e70c-182">Należy pamiętać, że może nie być możliwe obserwowania tej reguły we wszystkich przypadkach, takich jak podczas sesji pomocy technicznej jest wymagany.</span><span class="sxs-lookup"><span data-stu-id="6e70c-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="6e70c-183">Model programowania</span><span class="sxs-lookup"><span data-stu-id="6e70c-183">Programming Model</span></span>  
 <span data-ttu-id="6e70c-184">Niezależnie od tego, którego trzy wbudowane koderów, możesz użyć w aplikacji środowiska programowania jest identyczny w odniesieniu do transferowania danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="6e70c-185">Różnica polega na w sposób WCF służy do obsługi danych na podstawie ich typów danych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```  
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}   
```  
  
 <span data-ttu-id="6e70c-186">Korzystając z MTOM, poprzedni kontraktu danych jest serializowana zgodnie z następującymi zasadami:</span><span class="sxs-lookup"><span data-stu-id="6e70c-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
-   <span data-ttu-id="6e70c-187">Jeśli `binaryBuffer` nie `null` i indywidualnie zawiera wystarczającej ilości danych, aby uzasadniać obciążenie o eksternalizację MTOM (nagłówków MIME i tak dalej) w porównaniu do formatu Base64 kodowania, dane są zewnętrznych i przenoszone z komunikatem w ramach MIME binarne.</span><span class="sxs-lookup"><span data-stu-id="6e70c-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="6e70c-188">Jeśli próg nie zostanie przekroczony, dane są zakodowane jako Base64.</span><span class="sxs-lookup"><span data-stu-id="6e70c-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
-   <span data-ttu-id="6e70c-189">Ciąg (i wszystkich innych typów, które nie są binarne) zawsze jest przedstawiana jako ciąg w treści wiadomości, bez względu na rozmiar.</span><span class="sxs-lookup"><span data-stu-id="6e70c-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="6e70c-190">Wpływ na kodowanie MTOM jest taka sama niezależnie od użycia kontrakt danych jawne, jak pokazano w powyższym przykładzie użyj listę parametrów w operacji, mają kontraktów danych zagnieżdżonych lub przeniesienia obiektu kontraktu danych wewnątrz kolekcji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="6e70c-191">Tablice typu byte nadają się zawsze do optymalizacji i są zoptymalizowane pod kątem, jeśli spełnione są progi optymalizacji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e70c-192">Nie powinien być używany <xref:System.IO.Stream?displayProperty=nameWithType> pochodne typy wewnątrz kontraktów danych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="6e70c-193">Stream data powinien być przekazywany przy użyciu modelu przesyłania strumieniowego, szczegółowo opisane w poniższej sekcji "Dane przesyłane strumieniowo".</span><span class="sxs-lookup"><span data-stu-id="6e70c-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="6e70c-194">Dane przesyłane strumieniowo</span><span class="sxs-lookup"><span data-stu-id="6e70c-194">Streaming Data</span></span>  
 <span data-ttu-id="6e70c-195">W przypadku dużych ilości danych do przesłania strumieniowego tryb transferu programu WCF jest możliwe alternatywa domyślne zachowanie buforowania i przetwarzanie komunikatów w pamięci w całości.</span><span class="sxs-lookup"><span data-stu-id="6e70c-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="6e70c-196">Jak wspomniano wcześniej, należy włączyć przesyłania strumieniowego tylko w przypadku dużych komunikatów (z zawartością tekstowych lub binarnych), czy dane nie można podzielić, jeśli wiadomość musi zostać dostarczony w odpowiednim czasie, czy dane nie jest jeszcze w pełni dostępna po rozpoczęciu transferu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="6e70c-197">Ograniczenia</span><span class="sxs-lookup"><span data-stu-id="6e70c-197">Restrictions</span></span>  
 <span data-ttu-id="6e70c-198">Szereg istotnych funkcji WCF nie można użyć podczas przesyłania strumieniowego jest włączona:</span><span class="sxs-lookup"><span data-stu-id="6e70c-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
-   <span data-ttu-id="6e70c-199">Nie można wykonać podpisów cyfrowych dla treści wiadomości, ponieważ wymagają one, obliczanie skrótu za pośrednictwem zawartość cały komunikat.</span><span class="sxs-lookup"><span data-stu-id="6e70c-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="6e70c-200">W przypadku przesyłania strumieniowego zawartość nie jest w pełni dostępne, gdy nagłówki wiadomości są zbudowane i wysyłane i dlatego nie można obliczyć podpisu cyfrowego.</span><span class="sxs-lookup"><span data-stu-id="6e70c-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
-   <span data-ttu-id="6e70c-201">Szyfrowanie jest zależna od podpisów cyfrowych, aby sprawdzić, czy dane zostały odtworzone poprawnie.</span><span class="sxs-lookup"><span data-stu-id="6e70c-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
-   <span data-ttu-id="6e70c-202">Niezawodne sesje musi buforu wysłanych komunikatów na kliencie ponowne dostarczenie pobiera utracony komunikat w przeniesieniu i muszą przechowywać wiadomości w usłudze przed przekazaniem ich do implementacji usługi, aby zachować kolejność komunikatów, w przypadku, gdy komunikaty są odbierane poza sekwencji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="6e70c-203">Ze względu na te ograniczenia funkcjonalności można użyć tylko transportu zabezpieczeń opcje przesyłania strumieniowego i nie można włączyć w sesjach niezawodnych.</span><span class="sxs-lookup"><span data-stu-id="6e70c-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="6e70c-204">Przesyłanie strumieniowe jest dostępna tylko w następujących powiązań zdefiniowanych przez system:</span><span class="sxs-lookup"><span data-stu-id="6e70c-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
-   <xref:System.ServiceModel.BasicHttpBinding>  
  
-   <xref:System.ServiceModel.NetTcpBinding>  
  
-   <xref:System.ServiceModel.NetNamedPipeBinding>  
  
-   <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="6e70c-205">Ponieważ podstawowy transport <xref:System.ServiceModel.NetTcpBinding> i <xref:System.ServiceModel.NetNamedPipeBinding> nieprzerwaną pracę niezawodne dostarczanie i opartego na połączeniach sesji pomocy technicznej, w odróżnieniu od protokołu HTTP, te dwa powiązania tylko minimalny zestaw dotyczy tych warunków ograniczających w praktyce.</span><span class="sxs-lookup"><span data-stu-id="6e70c-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="6e70c-206">Przesyłanie strumieniowe nie jest dostępna za pomocą transportu usługi kolejkowania komunikatów (MSMQ) i dlatego nie może być używany z <xref:System.ServiceModel.NetMsmqBinding> lub <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> klasy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="6e70c-207">Transportu MSMQ tylko obsługuje transfery buforowane dane o rozmiarze ograniczone wiadomości, a wszystkie inne transportu nie mają żadnych limit rozmiaru komunikatu praktyczne większość scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="6e70c-208">Przesyłanie strumieniowe również nie jest dostępna podczas za pomocą transportu kanał elementu równorzędnego, więc nie jest dostępna z <xref:System.ServiceModel.NetPeerTcpBinding>.</span><span class="sxs-lookup"><span data-stu-id="6e70c-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="6e70c-209">Przesyłanie strumieniowe i sesji</span><span class="sxs-lookup"><span data-stu-id="6e70c-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="6e70c-210">Podczas przesyłania strumieniowego wywołania z powiązaniem oparte na sesji, może wystąpić nieoczekiwane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="6e70c-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="6e70c-211">Wszystkie wywołania przesyłania strumieniowego są nawiązywane przy użyciu jednego kanału (kanał datagram), który nie obsługuje sesji, nawet jeśli powiązania, używany jest skonfigurowany do używania sesji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="6e70c-212">Jeśli wielu klientów wywołań przesyłania strumieniowego do tego samego obiektu usługi za pośrednictwem powiązania oparte na sesji i tryb współbieżności obiekt usługi jest ustawiony na jednym i jego wystąpienie kontekstu tryb ustawiono PerSession, wywołania musi przechodzić przez kanał datagram i dlatego tylko jeden wywołania są przetwarzane w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="6e70c-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="6e70c-213">Co najmniej jeden klient może następnie limit czasu. Ten problem można obejść przez ustawienie Tryb kontekstu wystąpienia obiektu usługi PerCall lub współbieżności do wielu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e70c-214">MaxConcurrentSessions nie ma znaczenia w tym przypadku, ponieważ istnieje tylko jeden "sesja".</span><span class="sxs-lookup"><span data-stu-id="6e70c-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="6e70c-215">Włączanie przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="6e70c-215">Enabling Streaming</span></span>  
 <span data-ttu-id="6e70c-216">Aby umożliwić przesyłanie strumieniowe w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="6e70c-216">You can enable streaming in the following ways:</span></span>  
  
-   <span data-ttu-id="6e70c-217">Wysyłanie i umożliwienia akceptowania żądań aplikacji w trybie przesyłania strumieniowego i zaakceptuj i zwracania odpowiedzi w tryb buforowany (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="6e70c-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
-   <span data-ttu-id="6e70c-218">Wysyłanie i umożliwienia akceptowania żądań aplikacji w tryb buforowany i zaakceptuj i zwracania odpowiedzi w trybie przesyłane strumieniowo (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="6e70c-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
-   <span data-ttu-id="6e70c-219">Wysyłanie i odbieranie żądań i odpowiedzi w trybie przesyłanej strumieniowo w obu kierunkach.</span><span class="sxs-lookup"><span data-stu-id="6e70c-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="6e70c-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="6e70c-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="6e70c-221">Można wyłączyć, przesyłanie strumieniowe, ustawiając tryb transferu <xref:System.ServiceModel.TransferMode.Buffered>, co jest ustawieniem domyślnym na wszystkie powiązania.</span><span class="sxs-lookup"><span data-stu-id="6e70c-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="6e70c-222">Poniższy kod pokazuje, jak ustawić tryb transferu w konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="6e70c-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="6e70c-223">Podczas tworzenia wystąpienia usługi powiązania w kodzie, należy ustawić odpowiednie `TransferMode` właściwości powiązania (lub elementu powiązania transportu, jeśli redagowania niestandardowego powiązania) na jedną z wartości wymienionych wcześniej.</span><span class="sxs-lookup"><span data-stu-id="6e70c-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="6e70c-224">Można włączyć strumieniowe przesyłanie żądań i odpowiedzi lub w obu kierunkach niezależnie po obu stronach strony komunikujące się bez wywierania wpływu na funkcjonalność.</span><span class="sxs-lookup"><span data-stu-id="6e70c-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="6e70c-225">Jednak należy zawsze zakładać, że rozmiar przeniesionych danych jest tyle znaczące, że włączenie przesyłania strumieniowego jest uzasadnione dla obu punktów końcowych łącza komunikacyjnego.</span><span class="sxs-lookup"><span data-stu-id="6e70c-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="6e70c-226">Do komunikacji dla wielu platform, gdzie jeden z punktów końcowych, które nie jest zaimplementowana przy użyciu usługi WCF możliwość używania przesyłania strumieniowego zależy od możliwości przesyłania strumieniowego platformy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="6e70c-227">Kolejny wyjątek rzadkich może być oparte na scenariuszu, gdzie klienta lub usługę, należy zminimalizować jej zestawu roboczego i może pozwolić rozmiary małych buforów zużycie pamięci.</span><span class="sxs-lookup"><span data-stu-id="6e70c-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="6e70c-228">Włączanie asynchronicznego przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="6e70c-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="6e70c-229">Aby włączyć, asynchronicznego przesyłania strumieniowego, Dodaj <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> zachowanie punktu końcowego usługi hosta i ustaw jego <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="6e70c-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="6e70c-230">Dodaliśmy również możliwości true asynchronicznego przesyłania strumieniowego po stronie wysyłania.</span><span class="sxs-lookup"><span data-stu-id="6e70c-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="6e70c-231">To zwiększa skalowalność usługi w scenariuszach, gdzie jest strumienia komunikatów do wielu klientów, niektóre z nich są powolne podczas odczytu, prawdopodobnie z powodu przeciążenia sieci lub w ogóle nie czytają.</span><span class="sxs-lookup"><span data-stu-id="6e70c-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="6e70c-232">W tych scenariuszach możemy teraz nie blokują jednym z wątków w usłudze na klienta.</span><span class="sxs-lookup"><span data-stu-id="6e70c-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="6e70c-233">Zapewnia to, że usługa jest w stanie do przetworzenia wiele większej liczby klientów, zwiększając w ten sposób skalowalność usługi.</span><span class="sxs-lookup"><span data-stu-id="6e70c-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="6e70c-234">Model programowania transferów przesyłane strumieniowo</span><span class="sxs-lookup"><span data-stu-id="6e70c-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="6e70c-235">Model programowania do przesyłania strumieniowego jest bardzo proste.</span><span class="sxs-lookup"><span data-stu-id="6e70c-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="6e70c-236">Odbiera dane przesyłane strumieniowo, określ kontrakt operacji, która ma jeden <xref:System.IO.Stream> wpisany parametr wejściowy.</span><span class="sxs-lookup"><span data-stu-id="6e70c-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="6e70c-237">W przypadku zwracający dane przesyłane strumieniowo, zwracają <xref:System.IO.Stream> odwołania.</span><span class="sxs-lookup"><span data-stu-id="6e70c-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```  
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="6e70c-238">Operacja `Echo` w poprzednim przykładzie odbiera i zwraca strumienia i powinna być używana w powiązaniu z <xref:System.ServiceModel.TransferMode.Streamed>.</span><span class="sxs-lookup"><span data-stu-id="6e70c-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="6e70c-239">Dla operacji `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> najlepiej nadaje się, ponieważ zwraca ono tylko wartość <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="6e70c-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="6e70c-240">Operacja jednokierunkowa najlepiej nadaje się dla <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span><span class="sxs-lookup"><span data-stu-id="6e70c-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="6e70c-241">Należy pamiętać, ten drugi parametr dodawanie do następujących `Echo` lub `ProvideInfo` operacje powoduje, że model usług powrócić do buforowanego strategii i używania czasu wykonywania serializacji reprezentacja strumienia.</span><span class="sxs-lookup"><span data-stu-id="6e70c-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="6e70c-242">Tylko operacje z parametrem jednym strumień wejściowy są zgodne z żądaniem end-to-end przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="6e70c-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="6e70c-243">Ta zasada dotyczy podobnie kontrakty komunikatów.</span><span class="sxs-lookup"><span data-stu-id="6e70c-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="6e70c-244">Jak pokazano na poniższym kontraktu komunikatu, może mieć tylko członek jednej jednostki w swojej kontraktu komunikatu, który jest strumień.</span><span class="sxs-lookup"><span data-stu-id="6e70c-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="6e70c-245">Jeśli chcesz przekazać dodatkowe informacje o strumieniu, te informacje muszą być przeprowadzane w nagłówkach wiadomości.</span><span class="sxs-lookup"><span data-stu-id="6e70c-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="6e70c-246">Treść komunikatu jest zastrzeżone wyłącznie dla zawartości strumienia.</span><span class="sxs-lookup"><span data-stu-id="6e70c-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```  
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}   
```  
  
 <span data-ttu-id="6e70c-247">Końcowy transfery przesyłane strumieniowo i komunikat o jest zamknięty, gdy strumień osiągnie koniec pliku (EOF).</span><span class="sxs-lookup"><span data-stu-id="6e70c-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="6e70c-248">Podczas wysyłania komunikatu (zwracanie wartości lub wywołanie operacji), możesz przekazać <xref:System.IO.FileStream> i infrastruktura WCF później ściąga wszystkie dane z tej usługi stream, dopóki strumień całkowicie odczytane i osiągnięcia końca pliku.</span><span class="sxs-lookup"><span data-stu-id="6e70c-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="6e70c-249">Transfer danych przesyłane strumieniowo dla źródła, nie takie wstępnie skompilowanych <xref:System.IO.Stream> istnieje w klasie pochodnej, konstruowania taka klasa, nakładki tej klasy, za pośrednictwem źródła strumienia i używać go jako argument lub wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="6e70c-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="6e70c-250">Podczas odbierania komunikatu, WCF, tworzy strumień przez treść komunikatu algorytmem Base64 (lub odpowiedniego części MIME, jeśli za pomocą MTOM), a strumień osiągnie EOF, gdy zawartość została przeczytana.</span><span class="sxs-lookup"><span data-stu-id="6e70c-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="6e70c-251">Również poziomu transportu przesyłania strumieniowego współdziała z żadnych innych typ kontraktu komunikatu (listy parametrów, argumenty kontraktu danych i kontraktu komunikatu jawne), ale ponieważ serializacji i deserializacji takich typ wiadomości, wymagane jest buforowanie przez serializator , przy użyciu takich wariantów umowy nie jest zalecane.</span><span class="sxs-lookup"><span data-stu-id="6e70c-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="6e70c-252">Zagadnienia dotyczące zabezpieczeń specjalne dla dużych ilości danych</span><span class="sxs-lookup"><span data-stu-id="6e70c-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="6e70c-253">Wszystkie powiązania umożliwiają ograniczenie rozmiaru wiadomości przychodzących, aby zapobiec atakom typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="6e70c-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="6e70c-254"><xref:System.ServiceModel.BasicHttpBinding>, Na przykład udostępnia [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) właściwość, która jest zakresem rozmiaru komunikatu przychodzącego, a więc również granic maksymalną ilość pamięci, która jest dostępna podczas przetwarzania komunikatu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="6e70c-255">Ta jednostka jest ustawiana w bajtach z wartością domyślną 65 536 bajtów.</span><span class="sxs-lookup"><span data-stu-id="6e70c-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="6e70c-256">Zagrożenie bezpieczeństwa, które są specyficzne dla scenariusz transmisji strumieniowej w dużych ilości danych wywołuje typu "odmowa usługi", powodując dane buforowane, gdy odbiornika oczekuje przesyłane strumieniowo.</span><span class="sxs-lookup"><span data-stu-id="6e70c-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="6e70c-257">Na przykład WCF zawsze buforuje nagłówków protokołu SOAP wiadomości, a więc osoba atakująca może konstruować tak dużych niebezpieczną wiadomość, która zawiera tylko nagłówki, aby wymusić dane, które mają być buforowane.</span><span class="sxs-lookup"><span data-stu-id="6e70c-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="6e70c-258">Po włączeniu przesyłania strumieniowego `MaxReceivedMessageSize` może być ustawiona na bardzo dużą wartość, ponieważ odbiornika oczekuje nigdy nie cały komunikat do buforowanych w pamięci na raz.</span><span class="sxs-lookup"><span data-stu-id="6e70c-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="6e70c-259">Jeśli WCF jest zmuszony do buforu komunikatu, wystąpi przepełnienie pamięci.</span><span class="sxs-lookup"><span data-stu-id="6e70c-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="6e70c-260">W związku z tym ograniczanie maksymalny rozmiar wiadomości przychodzącej nie wystarcza w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="6e70c-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="6e70c-261">`MaxBufferSize` Ograniczenie pamięci, który zapewnia buforowanie WCF jest wymagana właściwość.</span><span class="sxs-lookup"><span data-stu-id="6e70c-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="6e70c-262">Ważne jest, aby Ustaw tę opcję na wartość bezpiecznych (lub zachować wartość domyślną) podczas przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="6e70c-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="6e70c-263">Załóżmy, że usługa musi otrzymać bit pliki rozmiarze maksymalnie 4 GB i przechowywać je na dysku lokalnym.</span><span class="sxs-lookup"><span data-stu-id="6e70c-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="6e70c-264">Załóżmy również, że pamięć jest ograniczona w taki sposób, można tylko buforu 64 KB danych w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="6e70c-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="6e70c-265">Następnie należy ustawić `MaxReceivedMessageSize` do 4 GB i `MaxBufferSize` 64 KB.</span><span class="sxs-lookup"><span data-stu-id="6e70c-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="6e70c-266">Ponadto w danej implementacji usługi upewnij się jedynie odczytywać strumień przychodzących we fragmentach o rozmiarze 64 KB, a następnie odczytu nie dalej fragmentów przed poprzedniej została zapisane na dysku i usuwane z pamięci.</span><span class="sxs-lookup"><span data-stu-id="6e70c-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="6e70c-267">Jest również pamiętać, że ten limit przydziału tylko ogranicza ich buforowanie wykonywane przez architekturę WCF i nie można chronić się przed dowolnego buforowania, możesz zrobić w Twojej własnej implementacji usługi lub klienta.</span><span class="sxs-lookup"><span data-stu-id="6e70c-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="6e70c-268">Aby uzyskać więcej informacji dotyczących zabezpieczeń, zobacz [zagadnienia dotyczące zabezpieczeń dla danych](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="6e70c-268">For more information about additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e70c-269">Decyzja dotycząca użycia buforowanego lub przesyłane strumieniowo transferu jest decyzja lokalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="6e70c-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="6e70c-270">Dla transportu HTTP tryb transferu nie propagować przez połączenie lub serwery proxy i innych pośredników.</span><span class="sxs-lookup"><span data-stu-id="6e70c-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="6e70c-271">Ustawianie trybu transferu nie zostaną uwzględnione w opisie interfejsu usługi.</span><span class="sxs-lookup"><span data-stu-id="6e70c-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="6e70c-272">Po wygenerowaniu klienta programu WCF do usługi, możesz edytować plik konfiguracji usługi przeznaczone do użycia w przypadku transferów przesyłane strumieniowo można ustawić trybu.</span><span class="sxs-lookup"><span data-stu-id="6e70c-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="6e70c-273">Dla protokołu TCP i rodzajów transportu nazwanego potoku tryb transferu jest propagowany jako potwierdzenie zasad.</span><span class="sxs-lookup"><span data-stu-id="6e70c-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6e70c-274">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="6e70c-274">See also</span></span>

- [<span data-ttu-id="6e70c-275">Instrukcje: włączanie przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="6e70c-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)
