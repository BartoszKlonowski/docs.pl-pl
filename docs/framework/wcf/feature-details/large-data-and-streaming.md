---
title: Duże ilości danych i przesyłanie strumieniowe
description: Zapoznaj się z zagadnieniami dotyczącymi komunikacji opartej na języku XML WCF, koderów i danych przesyłanych strumieniowo, w tym transferu danych binarnych.
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 2eb57e2f57bebb2e765ea798b3dff27e0187e8c7
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246587"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="0ee1a-103">Duże ilości danych i przesyłanie strumieniowe</span><span class="sxs-lookup"><span data-stu-id="0ee1a-103">Large Data and Streaming</span></span>

<span data-ttu-id="0ee1a-104">Windows Communication Foundation (WCF) to infrastruktura komunikacji oparta na języku XML.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-104">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="0ee1a-105">Ponieważ dane XML są powszechnie zakodowane w standardowym formacie tekstowym zdefiniowanym w [specyfikacji XML 1,0](https://www.w3.org/TR/REC-xml/), połączone systemy deweloperzy i architektów zazwyczaj dotyczą sieci (lub rozmiaru) komunikatów wysyłanych przez sieć, a kodowanie tekstu XML stanowi specjalne wyzwania dotyczące wydajnego transferu danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-105">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="0ee1a-106">Podstawowe zagadnienia</span><span class="sxs-lookup"><span data-stu-id="0ee1a-106">Basic Considerations</span></span>  
 <span data-ttu-id="0ee1a-107">Aby podać informacje w tle dotyczące następujących informacji dotyczących programu WCF, w tej sekcji przedstawiono niektóre ogólne zagadnienia i zagadnienia dotyczące kodowania, danych binarnych i przesyłania strumieniowego, które są ogólnie stosowane do infrastruktury podłączonych systemów.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-107">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="0ee1a-108">Kodowanie danych: tekst a binarny</span><span class="sxs-lookup"><span data-stu-id="0ee1a-108">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="0ee1a-109">Często wyrażane problemy dla deweloperów obejmują postrzeganie, że kod XML ma znaczne obciążenie w porównaniu do formatów binarnych ze względu na powtarzalny charakter tagów początkowych i tagów końcowych, że kodowanie wartości liczbowych jest uznawane za znacznie większe, ponieważ są one wyrażone w postaci wartości tekstowych, a dane binarne nie mogą być wyrażane efektywnie, ponieważ muszą być specjalnie zakodowane w formacie tekstowym.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-109">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="0ee1a-110">Chociaż wiele z tych i podobnych problemów jest prawidłowych, rzeczywista różnica między komunikatami szyfrowanymi w formacie XML w środowisku usług sieci Web XML i kodowanymi binarnie komunikatami w starszym środowisku zdalnego wywołania procedury (RPC) jest często znacznie mniejsza niż w przypadku, gdy zachodzi taka potrzeba.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-110">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="0ee1a-111">Komunikaty zakodowane w formacie XML są przezroczyste i "czytelne", wiadomości binarne są często stosunkowo odczuwalne w porównaniu i trudne do zdekodowania bez narzędzi.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-111">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="0ee1a-112">Ta różnica w czytelności prowadzi do zapomina, że wiadomości binarne często zawierają wbudowane metadane w ładunku, co zwiększa obciążenie tak jak w przypadku wiadomości tekstowych XML.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-112">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="0ee1a-113">Jest to szczególnie prawdziwe w przypadku formatów binarnych, które mają na celu zapewnienie swobodnego sprzężenia i możliwości dynamicznego wywoływania.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-113">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="0ee1a-114">Jednak formaty binarne zwykle zawierają takie opisowe informacje metadanych w "nagłówku", który również deklaruje układ danych dla następujących rekordów danych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-114">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="0ee1a-115">Ładunek następuje po tej wspólnej deklaracji bloku metadanych z minimalnym dodatkowym obciążeniem.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-115">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="0ee1a-116">W przeciwieństwie, kod XML ujmuje każdy element danych w elemencie lub atrybucie, tak aby otaczające metadane były powtarzane dla każdego serializowanego obiektu ładunku.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-116">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="0ee1a-117">W związku z tym rozmiar pojedynczego serializowanego obiektu ładunku jest podobny w przypadku porównywania tekstu z reprezentacją binarną, ponieważ niektóre metadane opisowe muszą być wyrażone w obu przypadkach, ale format binarny ma zalety z uwzględnieniem wszystkich dodatkowych obiektów ładunku, które są przesyłane ze względu na niższe ogólne obciążenie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-117">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="0ee1a-118">W przypadku niektórych typów danych, takich jak liczby, może być niekorzystne użycie stałych, binarnych reprezentacji liczbowych, takich jak 128-bitowy typ dziesiętny zamiast zwykłego tekstu, ponieważ reprezentacja zwykłego tekstu może być mniejsza.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-118">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="0ee1a-119">W przypadku danych tekstowych mogą być również dostępne różne rozmiary z zwykle bardziej elastycznych opcji kodowania tekstu XML, podczas gdy niektóre formaty binarne mogą domyślnie mieć 16-bitową lub nawet 32-bitową wersję Unicode, która nie ma zastosowania do binarnego formatu XML programu .NET.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-119">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="0ee1a-120">W związku z tym wybranie między tekstem a plikiem binarnym nie jest bardzo proste, ponieważ przy założeniu, że komunikaty binarne są zawsze mniejsze niż wiadomości tekstowe XML.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-120">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="0ee1a-121">Oczywistą zaletą komunikatów tekstowych XML jest to, że są one oparte na standardach i oferują najszerszy wybór opcji współdziałania i obsługi platformy.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-121">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="0ee1a-122">Aby uzyskać więcej informacji, zobacz sekcję "kodowania" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-122">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="0ee1a-123">Zawartość binarna</span><span class="sxs-lookup"><span data-stu-id="0ee1a-123">Binary Content</span></span>  
 <span data-ttu-id="0ee1a-124">Jeden obszar, w którym kodowania binarne są przeznaczone do kodowania na podstawie tekstu, pod warunkiem, że wyświetlany rozmiar wiadomości to duże elementy danych binarnych, takie jak obrazy, wideo, klipy dźwiękowe lub jakakolwiek inna forma nieprzezroczystych danych binarnych, które muszą być wymieniane między usługami i ich konsumenci.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-124">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="0ee1a-125">Aby dopasować te typy danych do tekstu XML, typowe podejście polega na zakodowaniu ich przy użyciu kodowania base64.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-125">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="0ee1a-126">W ciągu zakodowanym algorytmem Base64 każdy znak reprezentuje 6-bitów oryginalnych danych 8-bitowych, co skutkuje wskaźnikiem narzutowania kodowania 4:3 dla Base64, a nie zliczaniem dodatkowych znaków formatowania (znak powrotu karetki/wysuwu wiersza), które są powszechnie dodawane przez Konwencję.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-126">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="0ee1a-127">Chociaż istotność różnic między kodowaniem XML i binarnym zwykle zależy od scenariusza, wzrost rozmiaru większy niż 33% podczas przekazywania ładunku 500-MB nie jest zazwyczaj akceptowalny.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-127">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="0ee1a-128">Aby uniknąć tego obciążenia kodowania, w standardzie mechanizm optymalizacji transmisji wiadomości (MTOM) można eksternalizacji duże elementy danych, które znajdują się w komunikacie i przenosząc je do wiadomości jako dane binarne bez żadnego specjalnego kodowania.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-128">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="0ee1a-129">Przy użyciu mechanizmu MTOM komunikaty są wymieniane w podobny sposób do Simple Mail Transfer Protocol (SMTP) wiadomości e-mail z załącznikami lub osadzoną zawartością (obrazy i inne osadzone elementy); Komunikaty mechanizmu MTOM są pakowane jako wieloczęściowe/powiązane sekwencje MIME z główną częścią rzeczywistego komunikatu protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-129">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="0ee1a-130">Komunikat protokołu SOAP MTOM jest modyfikowany z jego niekodowanej wersji tak, aby Tagi elementów specjalnych odwołujące się do odpowiednich części MIME miały miejsce oryginalne elementy w komunikacie zawierającym dane binarne.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-130">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="0ee1a-131">W związku z tym komunikat protokołu SOAP odwołuje się do zawartości binarnej, wskazując do wysłanej z nią części MIME, ale w przeciwnym razie tylko przenosi dane tekstowe XML.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-131">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="0ee1a-132">Ponieważ ten model jest ściśle wyrównany przy użyciu dobrze ustanowionego modelu SMTP, dostępne są szeroką gamę narzędzi do kodowania i dekodowania komunikatów MTOM na wielu platformach, co sprawia, że jest to niezwykle interoperacyjne rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-132">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="0ee1a-133">Nadal, podobnie jak w przypadku protokołu Base64, MTOM jest również niezbędny do użycia w formacie MIME, dzięki czemu zalety używania MTOM są widoczne tylko wtedy, gdy rozmiar elementu danych binarnych przekroczy około 1 KB.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-133">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="0ee1a-134">Ze względu na obciążenie, komunikaty kodowane algorytmem MTOM mogą być większe niż komunikaty, które używają kodowania base64 dla danych binarnych, jeśli ładunek binarny pozostaje poniżej tego progu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-134">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="0ee1a-135">Aby uzyskać więcej informacji, zobacz sekcję "kodowania" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-135">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="0ee1a-136">Duża zawartość danych</span><span class="sxs-lookup"><span data-stu-id="0ee1a-136">Large Data Content</span></span>  
 <span data-ttu-id="0ee1a-137">Poza tym, wspomniany wcześniej ładunek 500-MB stanowi również wspaniałe lokalne wyzwanie na potrzeby usługi i klienta.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-137">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="0ee1a-138">Domyślnie program WCF przetwarza komunikaty w *trybie buforowanym*.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-138">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="0ee1a-139">Oznacza to, że cała zawartość komunikatu jest obecna w pamięci przed wysłaniem lub po odebraniu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-139">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="0ee1a-140">Chociaż jest to dobrą strategią dla większości scenariuszy i są niezbędne do obsługi komunikatów, takich jak podpisy cyfrowe i niezawodne dostarczanie, duże wiadomości mogą wyczerpać zasoby systemu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-140">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="0ee1a-141">Strategia postępowania z dużymi ładunkiem polega na przesyłaniu strumieniowym.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-141">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="0ee1a-142">Komunikaty, szczególnie te wyrażone w formacie XML, są powszechnie uważane za stosunkowo kompaktowe pakiety danych, a komunikat może mieć rozmiar wiele gigabajtów i przypominać strumień danych ciągłych więcej niż pakiet danych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-142">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="0ee1a-143">Gdy dane są przesyłane w trybie przesyłania strumieniowego, a nie w trybie buforowanym, nadawca wysyła zawartość treści wiadomości do odbiorcy w postaci strumienia, a infrastruktura komunikatów stale przekazuje dane od nadawcy do odbiorcy w miarę ich udostępniania.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-143">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="0ee1a-144">Najbardziej typowym scenariuszem, w którym występują takie transfery dużej ilości danych, są transfery obiektów danych binarnych, które:</span><span class="sxs-lookup"><span data-stu-id="0ee1a-144">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="0ee1a-145">Nie można łatwo rozbić do sekwencji komunikatów.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-145">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="0ee1a-146">Muszą być dostarczone w odpowiednim czasie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-146">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="0ee1a-147">Nie są dostępne w całości po zainicjowaniu transferu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-147">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="0ee1a-148">W przypadku danych, które nie mają tych ograniczeń, zazwyczaj lepiej jest wysyłać sekwencje komunikatów w zakresie sesji niż w przypadku jednej dużej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-148">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="0ee1a-149">Aby uzyskać więcej informacji, zobacz sekcję "dane przesyłane strumieniowo" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-149">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="0ee1a-150">Podczas wysyłania dużych ilości danych należy ustawić `maxAllowedContentLength` ustawienie usług IIS (Aby uzyskać więcej informacji, zobacz [Konfigurowanie limitów żądań usług IIS](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) i `maxReceivedMessageSize` ustawienie powiązania (na przykład [System. ServiceModel. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) lub <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> ).</span><span class="sxs-lookup"><span data-stu-id="0ee1a-150">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="0ee1a-151">`maxAllowedContentLength`Właściwość domyślna to 28,6 MB, a `maxReceivedMessageSize` Właściwość domyślna to 64 KB.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-151">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="0ee1a-152">Kodowanie</span><span class="sxs-lookup"><span data-stu-id="0ee1a-152">Encodings</span></span>  
 <span data-ttu-id="0ee1a-153">*Kodowanie* definiuje zestaw reguł dotyczących sposobu prezentowania wiadomości w sieci przewodowej.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-153">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="0ee1a-154">*Koder* implementuje takie kodowanie i jest odpowiedzialny na stronie nadawcy w celu wyłączania pamięci <xref:System.ServiceModel.Channels.Message> do strumienia bajtów lub buforu bajtów, który można wysłać w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-154">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="0ee1a-155">Po stronie odbiornika koder zamienia sekwencję bajtów na komunikat w pamięci.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-155">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="0ee1a-156">Program WCF zawiera trzy kodery i umożliwia pisanie i podłączenie własnych koderów, w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-156">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="0ee1a-157">Każde ze standardowych powiązań zawiera wstępnie skonfigurowany koder, według którego powiązania z prefiksem Net \* używają kodera binarnego (poprzez dołączenie <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> klasy), podczas gdy <xref:System.ServiceModel.BasicHttpBinding> <xref:System.ServiceModel.WSHttpBinding> klasy i używają kodera wiadomości tekstowych (według <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> klasy) domyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-157">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="0ee1a-158">Element powiązania kodera</span><span class="sxs-lookup"><span data-stu-id="0ee1a-158">Encoder binding element</span></span>|<span data-ttu-id="0ee1a-159">Opis</span><span class="sxs-lookup"><span data-stu-id="0ee1a-159">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="0ee1a-160">Koder wiadomości tekstowych to domyślny koder dla wszystkich powiązań opartych na protokole HTTP i odpowiedni wybór dla wszystkich powiązań niestandardowych, w których współdziałanie jest najwyższej istotności.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-160">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="0ee1a-161">Ten koder odczytuje i zapisuje standardowe komunikaty tekstowe SOAP 1.1/SOAP 1,2 bez specjalnej obsługi danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-161">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="0ee1a-162">Jeśli <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> Właściwość komunikatu jest ustawiona na <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> , otoka koperty protokołu SOAP zostanie pominięta z danych wyjściowych i tylko zawartość treści komunikatu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-162">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="0ee1a-163">Koder komunikatów MTOM jest koderem tekstowym, który implementuje specjalną obsługę danych binarnych i nie jest domyślnie używany w żadnym ze standardowych powiązań, ponieważ jest to wyłącznie narzędzie do optymalizacji wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-163">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="0ee1a-164">Jeśli komunikat zawiera dane binarne, które przekraczają próg, w którym Kodowanie MTOM zwraca korzyść, dane są zewnętrzne do części MIME po kopercie komunikatu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-164">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="0ee1a-165">Zobacz Włączanie mechanizmu MTOM w dalszej części tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-165">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="0ee1a-166">Koder komunikatów binarnych to domyślny koder powiązań NET \* i odpowiedni wybór, gdy obie strony komunikują się na podstawie WCF.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-166">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="0ee1a-167">Koder komunikatów binarnych używa formatu binarny programu .NET, czyli reprezentacji binarnych dla określonych firmy Microsoft dla zestawów informacyjnych XML (Infosets), która zazwyczaj daje mniejszy wpływ niż odpowiednik reprezentacji XML 1,0 i koduje dane binarne jako strumień bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-167">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="0ee1a-168">Kodowanie wiadomości tekstowych jest zazwyczaj najlepszym wyborem dla każdej ścieżki komunikacji wymagającej współdziałania, podczas gdy kodowanie komunikatów binarnych jest najlepszym wyborem dla każdej innej ścieżki komunikacyjnej.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-168">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="0ee1a-169">Kodowanie wiadomości binarnych zazwyczaj daje mniejsze rozmiary komunikatów w porównaniu do tekstu w przypadku pojedynczego komunikatu i stopniowo zmniejsza mniejsze rozmiary komunikatów w czasie trwania sesji komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-169">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="0ee1a-170">W przeciwieństwie do kodowania tekstu, kodowanie binarne nie musi używać specjalnej obsługi danych binarnych, takich jak użycie Base64, ale reprezentuje bajty jako bajty.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-170">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="0ee1a-171">Jeśli rozwiązanie nie wymaga współdziałania, ale nadal chcesz używać transportu HTTP, możesz złożyć do <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> niestandardowego powiązania, które używa <xref:System.ServiceModel.Channels.HttpTransportBindingElement> klasy do transportu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-171">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="0ee1a-172">Jeśli liczba klientów w usłudze wymaga współdziałania, zaleca się uwidocznienie równoległych punktów końcowych, z których każdy ma odpowiednie opcje transportu i kodowania dla odpowiednich klientów.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-172">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="0ee1a-173">Włączanie mechanizmu MTOM</span><span class="sxs-lookup"><span data-stu-id="0ee1a-173">Enabling MTOM</span></span>  
 <span data-ttu-id="0ee1a-174">Gdy współdziałanie jest wymaganiem i należy wysłać duże dane binarne, kodowanie komunikatów mechanizmu MTOM jest alternatywną strategią kodowania, którą można włączyć na standardowym <xref:System.ServiceModel.BasicHttpBinding> lub <xref:System.ServiceModel.WSHttpBinding> powiązań przez ustawienie odpowiedniej `MessageEncoding` właściwości na <xref:System.ServiceModel.WSMessageEncoding.Mtom> lub przez złożenie <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> do <xref:System.ServiceModel.Channels.CustomBinding> .</span><span class="sxs-lookup"><span data-stu-id="0ee1a-174">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="0ee1a-175">W poniższym przykładowym kodzie wyodrębnionym z przykładu [kodowania MTOM](../samples/mtom-encoding.md) pokazano, jak włączyć MTOM w konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-175">The following example code, extracted from the [MTOM Encoding](../samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="0ee1a-176">Jak wspomniano wcześniej, decyzja o użyciu kodowania MTOM zależy od wysyłanego woluminu danych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-176">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="0ee1a-177">Ponadto, ponieważ MTOM jest włączony na poziomie powiązania, włączenie mechanizmu MTOM wpływa na wszystkie operacje w danym punkcie końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-177">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="0ee1a-178">Ponieważ koder MTOM zawsze emituje komunikat MIME/wieloczęściowy zakodowany przez MTOM, bez względu na to, czy dane binarne kończą się zewnętrznie, należy ogólnie włączyć MTOM dla punktów końcowych, które wymieniają komunikaty zawierające więcej niż 1 KB danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-178">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="0ee1a-179">Ponadto kontrakty usługi przeznaczone do użycia z punktami końcowymi z obsługą mechanizmu MTOM powinny być w miarę możliwości ograniczone do określania takich operacji transferu danych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-179">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="0ee1a-180">Powiązane funkcje kontroli powinny znajdować się w osobnym kontrakcie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-180">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="0ee1a-181">Ta reguła "MTOM-Only" dotyczy tylko komunikatów wysyłanych za poorednictwem punktu końcowego z obsługą mechanizmu MTOM; MTOM-koder może również zdekodować i analizować przychodzące komunikaty inne niż MTOM.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-181">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="0ee1a-182">Używanie kodera MTOM jest zgodne ze wszystkimi innymi funkcjami WCF.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-182">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="0ee1a-183">Należy zauważyć, że może nie być możliwe przestrzeganie tej reguły we wszystkich przypadkach, na przykład gdy wymagana jest obsługa sesji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-183">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="0ee1a-184">Model programowania</span><span class="sxs-lookup"><span data-stu-id="0ee1a-184">Programming Model</span></span>  
 <span data-ttu-id="0ee1a-185">Niezależnie od tego, które z trzech wbudowanych koderów używanych w aplikacji, środowisko programistyczne jest identyczne z uwzględnieniem transferu danych binarnych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-185">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="0ee1a-186">Różnica polega na tym, jak WCF obsługuje dane na podstawie ich typów danych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-186">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="0ee1a-187">W przypadku korzystania z mechanizmu MTOM poprzedni kontrakt danych jest serializowany zgodnie z następującymi regułami:</span><span class="sxs-lookup"><span data-stu-id="0ee1a-187">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="0ee1a-188">Jeśli `binaryBuffer` nie jest `null` i pojedynczo zawiera wystarczającą ilość danych, aby uzasadnić obciążenie externalization MTOM (nagłówki MIME itd.) w porównaniu z kodowaniem Base64, dane są zewnętrzne i przenoszone wraz z komunikatem jako binarną część MIME.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-188">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="0ee1a-189">Jeśli próg nie zostanie przekroczony, dane są kodowane jako Base64.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-189">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="0ee1a-190">Ciąg (i wszystkie inne typy, które nie są binarne) są zawsze reprezentowane jako ciąg wewnątrz treści komunikatu, bez względu na rozmiar.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-190">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="0ee1a-191">Wpływ na Kodowanie MTOM jest taki sam, niezależnie od tego, czy jest używany jawny kontrakt danych, jak pokazano w poprzednim przykładzie, należy użyć listy parametrów w operacji, mieć zagnieżdżone Kontrakty danych lub przenieść obiekt kontraktu danych wewnątrz kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-191">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="0ee1a-192">Tablice bajtowe są zawsze kandydatami do optymalizacji i są optymalizowane, jeśli są spełnione progi optymalizacji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-192">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0ee1a-193">Nie należy używać <xref:System.IO.Stream?displayProperty=nameWithType> typów pochodnych wewnątrz kontraktów danych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-193">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="0ee1a-194">Dane przesyłane strumieniowo powinny być przekazywane przy użyciu modelu przesyłania strumieniowego, wyjaśnione w poniższych sekcjach "dane przesyłane strumieniowo".</span><span class="sxs-lookup"><span data-stu-id="0ee1a-194">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="0ee1a-195">Przesyłanie strumieniowe danych</span><span class="sxs-lookup"><span data-stu-id="0ee1a-195">Streaming Data</span></span>  
 <span data-ttu-id="0ee1a-196">W przypadku transferu dużej ilości danych, tryb transferu przesyłania strumieniowego w programie WCF jest możliwym rozwiązaniem alternatywnym dla domyślnego zachowania buforowania i przetwarzania komunikatów w pamięci.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-196">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="0ee1a-197">Jak wspomniano wcześniej, Włącz przesyłanie strumieniowe tylko dla dużych komunikatów (z zawartością tekstową lub binarną), jeśli nie można podzielić danych na segmenty, jeśli wiadomość musi zostać dostarczona w odpowiednim czasie lub jeśli dane nie są jeszcze w pełni dostępne podczas inicjowania transferu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-197">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="0ee1a-198">Ograniczenia</span><span class="sxs-lookup"><span data-stu-id="0ee1a-198">Restrictions</span></span>  
 <span data-ttu-id="0ee1a-199">W przypadku włączenia przesyłania strumieniowego nie można użyć dużej liczby funkcji WCF:</span><span class="sxs-lookup"><span data-stu-id="0ee1a-199">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="0ee1a-200">Podpisy cyfrowe dla treści wiadomości nie mogą zostać wykonane, ponieważ wymagają przetwarzania skrótu przez całą zawartość wiadomości.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-200">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="0ee1a-201">W przypadku przesyłania strumieniowego zawartość nie jest w pełni dostępna, gdy nagłówki wiadomości są konstruowane i wysyłane i w związku z tym nie można obliczyć podpisu cyfrowego.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-201">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="0ee1a-202">Szyfrowanie zależy od podpisów cyfrowych, aby sprawdzić, czy dane zostały poprawnie skonstruowane.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-202">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="0ee1a-203">Niezawodne sesje muszą buforować wysyłane komunikaty na kliencie w celu ponownego dostarczenia, jeśli komunikat zostanie utracony podczas transferu i musi przechowywać komunikaty w usłudze przed przekazaniem ich do implementacji usługi w celu zachowania kolejności komunikatów w przypadku odebrania komunikatów o wypadek braku sekwencji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-203">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="0ee1a-204">Ze względu na te ograniczenia funkcjonalne można używać tylko opcji zabezpieczeń na poziomie transportu do przesyłania strumieniowego i nie można włączać niezawodnych sesji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-204">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="0ee1a-205">Przesyłanie strumieniowe jest dostępne tylko w przypadku następujących powiązań zdefiniowanych przez system:</span><span class="sxs-lookup"><span data-stu-id="0ee1a-205">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="0ee1a-206">Ze względu na to, że podstawowe transporty <xref:System.ServiceModel.NetTcpBinding> i <xref:System.ServiceModel.NetNamedPipeBinding> obsługują niezawodne dostarczanie i sesję opartą na połączeniach, w przeciwieństwie do protokołu HTTP, te dwa powiązania mają minimalny wpływ na te ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-206">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="0ee1a-207">Transmisja strumieniowa nie jest dostępna w przypadku transportu usługi kolejkowania komunikatów (MSMQ) i dlatego nie można jej używać z <xref:System.ServiceModel.NetMsmqBinding> ani <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> klasą.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-207">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="0ee1a-208">Transport kolejkowania komunikatów obsługuje tylko buforowane transfery danych z ograniczonym rozmiarem komunikatu, podczas gdy wszystkie inne transporty nie mają praktycznego limitu rozmiaru komunikatów dla większości scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-208">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="0ee1a-209">Przesyłanie strumieniowe jest również niedostępne w przypadku korzystania z transportu kanału równorzędnego, więc nie jest dostępne w programie <xref:System.ServiceModel.NetPeerTcpBinding> .</span><span class="sxs-lookup"><span data-stu-id="0ee1a-209">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="0ee1a-210">Przesyłanie strumieniowe i sesje</span><span class="sxs-lookup"><span data-stu-id="0ee1a-210">Streaming and Sessions</span></span>  
 <span data-ttu-id="0ee1a-211">Podczas przesyłania strumieniowego do wywołań opartych na sesji może wystąpić nieoczekiwane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-211">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="0ee1a-212">Wszystkie wywołania przesyłania strumieniowego są realizowane za pośrednictwem pojedynczego kanału (kanału datagramu), który nie obsługuje sesji, nawet jeśli używane powiązanie jest skonfigurowane do korzystania z sesji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-212">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="0ee1a-213">Jeśli wielu klientów przeprowadzi wywołania przesyłania strumieniowego do tego samego obiektu usługi za pośrednictwem powiązań opartych na sesji, a tryb współbieżności obiektu usługi jest ustawiony na wartość Single, a jego tryb kontekstu wystąpienia jest ustawiony na PerSession, wszystkie wywołania muszą przechodzić przez kanał datagramu i dlatego tylko jedno wywołanie jest przetwarzane jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-213">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="0ee1a-214">Co najmniej jeden klient może przekroczyć limit czasu. Ten problem można obejść, konfigurując tryb kontekstu wystąpienia obiektu usługi do PerCall lub współbieżności do wielu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-214">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0ee1a-215">MaxConcurrentSessions nie ma wpływu w tym przypadku, ponieważ jest dostępna tylko jedna "sesja".</span><span class="sxs-lookup"><span data-stu-id="0ee1a-215">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="0ee1a-216">Włączanie przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="0ee1a-216">Enabling Streaming</span></span>  
 <span data-ttu-id="0ee1a-217">Przesyłanie strumieniowe można włączyć w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="0ee1a-217">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="0ee1a-218">Wysyłanie i akceptowanie żądań w trybie przesyłania strumieniowego oraz akceptowanie i zwracanie odpowiedzi w trybie buforowanym ( <xref:System.ServiceModel.TransferMode.StreamedRequest> ).</span><span class="sxs-lookup"><span data-stu-id="0ee1a-218">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="0ee1a-219">Wysyłanie i akceptowanie żądań w trybie buforowanym oraz akceptowanie i zwracanie odpowiedzi w trybie przesyłania strumieniowego ( <xref:System.ServiceModel.TransferMode.StreamedResponse> ).</span><span class="sxs-lookup"><span data-stu-id="0ee1a-219">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="0ee1a-220">Wysyłanie i odbieranie żądań i odpowiedzi w trybie przesyłania strumieniowego w obu kierunkach.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-220">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="0ee1a-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="0ee1a-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="0ee1a-222">Przesyłanie strumieniowe można wyłączyć, ustawiając tryb transferu na <xref:System.ServiceModel.TransferMode.Buffered> , który jest ustawieniem domyślnym dla wszystkich powiązań.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-222">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="0ee1a-223">Poniższy kod pokazuje, jak ustawić tryb transferu w konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-223">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="0ee1a-224">Podczas tworzenia wystąpienia powiązania w kodzie, należy ustawić odpowiednią `TransferMode` właściwość powiązania (lub element powiązania transportu, jeśli tworzysz niestandardowe powiązanie) do jednej z wcześniej wymienionych wartości.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-224">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="0ee1a-225">Można włączyć przesyłanie strumieniowe żądań i odpowiedzi albo w obu kierunkach, niezależnie od ich strony, bez wywierania wpływu na funkcjonalność.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-225">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="0ee1a-226">Należy jednak zawsze założyć, że transferowany rozmiar danych jest tak duży, że włączenie przesyłania strumieniowego jest uzasadnione na obu punktach końcowych łącza komunikacyjnego.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-226">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="0ee1a-227">W przypadku komunikacji między platformami, w której jeden z punktów końcowych nie jest zaimplementowany przy użyciu programu WCF, możliwość korzystania z przesyłania strumieniowego zależy od możliwości przesyłania strumieniowego na platformie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-227">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="0ee1a-228">Innym rzadkim wyjątkiem może być Scenariusz oparty na zużyciu pamięci, w którym klient lub usługa musi zminimalizować swój zestaw roboczy i może zapewnić tylko małe rozmiary buforów.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-228">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="0ee1a-229">Włączanie przesyłania strumieniowego asynchronicznego</span><span class="sxs-lookup"><span data-stu-id="0ee1a-229">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="0ee1a-230">Aby włączyć asynchroniczne przesyłanie strumieniowe, Dodaj <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> zachowanie punktu końcowego do hosta usługi i ustaw jego <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> Właściwość na `true` .</span><span class="sxs-lookup"><span data-stu-id="0ee1a-230">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="0ee1a-231">Dodaliśmy także możliwość wysyłania strumieniowo asynchronicznych danych przesyłanych po stronie wysyłającej.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-231">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="0ee1a-232">Poprawia to skalowalność usługi w scenariuszach, w których przesyła strumieniowo komunikaty do wielu klientów, z których może się zająć wolne odczytywanie z powodu przeciążenia sieci lub nie są w ogóle odczytywane.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-232">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="0ee1a-233">W tych scenariuszach nie blokujemy poszczególnych wątków w usłudze na klienta.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-233">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="0ee1a-234">Dzięki temu usługa może przetwarzać wielu kolejnych klientów w taki sposób, aby zwiększyć skalowalność usługi.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-234">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="0ee1a-235">Model programowania dla transferów przesyłanych strumieniowo</span><span class="sxs-lookup"><span data-stu-id="0ee1a-235">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="0ee1a-236">Model programowania dla przesyłania strumieniowego jest prosty.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-236">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="0ee1a-237">W przypadku otrzymywania przesyłanych strumieniowo danych należy określić kontrakt operacji, który ma <xref:System.IO.Stream> parametr wejściowy z jednym typem.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-237">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="0ee1a-238">Aby można było zwracać dane przesyłane strumieniowo, zwróć <xref:System.IO.Stream> odwołanie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-238">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="0ee1a-239">Operacja `Echo` w powyższym przykładzie odbiera i zwraca strumień i dlatego powinna być używana w powiązaniu z <xref:System.ServiceModel.TransferMode.Streamed> .</span><span class="sxs-lookup"><span data-stu-id="0ee1a-239">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="0ee1a-240">Dla operacji `RequestInfo` <xref:System.ServiceModel.TransferMode.StreamedResponse> jest najlepiej dopasowany, ponieważ zwraca tylko wartość <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="0ee1a-240">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="0ee1a-241">Operacja jednokierunkowa najlepiej nadaje się do <xref:System.ServiceModel.TransferMode.StreamedRequest> .</span><span class="sxs-lookup"><span data-stu-id="0ee1a-241">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="0ee1a-242">Należy zauważyć, że dodanie drugiego parametru do poniższych `Echo` lub `ProvideInfo` operacji powoduje, że model usługi przywraca z powrotem do buforowanej strategii i używa reprezentacji serializacji w czasie wykonywania strumienia.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-242">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="0ee1a-243">Tylko operacje z pojedynczym parametrem strumienia wejściowego są zgodne z żądaniami kompleksowego przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-243">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="0ee1a-244">Ta reguła w podobny sposób dotyczy kontraktów komunikatów.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-244">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="0ee1a-245">Zgodnie z poniższą umową dotyczącą komunikatu można mieć tylko jeden element członkowski treści w ramach kontraktu, który jest strumieniem.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-245">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="0ee1a-246">Jeśli chcesz przekazać dodatkowe informacje ze strumieniem, te informacje muszą być przenoszone w nagłówkach wiadomości.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-246">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="0ee1a-247">Treść komunikatu jest zarezerwowana wyłącznie dla zawartości strumienia.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-247">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="0ee1a-248">Transfer przesyłanych strumieniowo kończy się, a komunikat jest zamykany, gdy strumień osiągnie koniec pliku (EOF).</span><span class="sxs-lookup"><span data-stu-id="0ee1a-248">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="0ee1a-249">W przypadku wysyłania komunikatu (zwracającego wartość lub wywołania operacji) można przekazać <xref:System.IO.FileStream> infrastrukturę usługi WCF, a następnie pobrać wszystkie dane z tego strumienia do momentu całkowitego odczytania strumienia i osiągnięcia EOF.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-249">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="0ee1a-250">Aby przesłać dane przesyłane strumieniowo dla źródła, które nie istnieje wcześniej utworzona <xref:System.IO.Stream> Klasa pochodna, konstrukcja takiej klasy, nałóż ją na źródło strumienia i Użyj tego jako argumentu lub wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-250">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="0ee1a-251">W przypadku otrzymania komunikatu Funkcja WCF konstruuje strumień za pośrednictwem zawartości treści komunikatu kodowanej algorytmem Base64 (lub odpowiedniej części MIME, jeśli jest używany), a strumień osiągnie wartość EOF, gdy zawartość została odczytana.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-251">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="0ee1a-252">Przesyłanie strumieniowe na poziomie transportu działa również z dowolnym innym typem kontraktu komunikatu (listami parametrów, argumentami kontraktu danych i jawnym kontraktem komunikatów), ale ponieważ Serializacja i deserializacja takich komunikatów o określonym typie wymaga buforowania przez serializator, użycie takich wariantów kontraktu nie jest zalecane.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-252">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="0ee1a-253">Specjalne zagadnienia dotyczące zabezpieczeń w przypadku dużych ilości danych</span><span class="sxs-lookup"><span data-stu-id="0ee1a-253">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="0ee1a-254">Wszystkie powiązania umożliwiają ograniczenie rozmiaru komunikatów przychodzących, aby zapobiec atakom typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="0ee1a-254">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="0ee1a-255">Na <xref:System.ServiceModel.BasicHttpBinding> przykład uwidacznia Właściwość [System. ServiceModel. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) , która wiąże się z rozmiarem komunikatu przychodzącego, a także wiąże się z maksymalną ilością pamięci, do której uzyskuje się dostęp podczas przetwarzania komunikatu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-255">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="0ee1a-256">Ta jednostka jest ustawiona w bajtach z wartością domyślną 65 536 bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-256">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="0ee1a-257">Zagrożenie bezpieczeństwa specyficzne dla scenariusza dużego przesyłania strumieniowego danych wywołuje odmowę usługi, powodując, że dane są buforowane, gdy odbiornik oczekuje na przesłanie strumieniowo.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-257">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="0ee1a-258">Na przykład usługa WCF zawsze buforuje nagłówki protokołu SOAP, a więc osoba atakująca może utworzyć dużą złośliwą wiadomość, która składa się w całości z nagłówków, aby wymusić, że dane mają być buforowane.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-258">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="0ee1a-259">Gdy funkcja przesyłania strumieniowego jest włączona, można `MaxReceivedMessageSize` ustawić niezwykle dużą wartość, ponieważ odbiornik nigdy nie oczekuje, że cały komunikat jest buforowany w pamięci jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-259">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="0ee1a-260">Jeśli funkcja WCF jest zmuszona do buforowania komunikatu, wystąpi przepełnienie pamięci.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-260">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="0ee1a-261">W związku z tym ograniczenie maksymalnego rozmiaru komunikatu przychodzącego nie jest wystarczające w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-261">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="0ee1a-262">`MaxBufferSize`Właściwość jest wymagana, aby ograniczyć ilość pamięci buforów WCF.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-262">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="0ee1a-263">Należy pamiętać, aby ustawić wartość bezpieczną (lub zachować wartość domyślną) podczas przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-263">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="0ee1a-264">Załóżmy na przykład, że usługa musi odbierać pliki o rozmiarze do 4 GB i przechowywać je na dysku lokalnym.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-264">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="0ee1a-265">Załóżmy również, że pamięć jest ograniczona w taki sposób, że w danym momencie można buforować tylko 64 KB danych.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-265">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="0ee1a-266">Następnie ustaw wartość `MaxReceivedMessageSize` 4 GB i `MaxBufferSize` na 64 KB.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-266">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="0ee1a-267">Ponadto w implementacji usługi należy upewnić się, że użytkownik ma uprawnienia tylko do odczytu ze strumienia przychodzącego w fragmentach 64-KB i nie odczytuje następnego fragmentu, zanim poprzedni zostanie zapisany na dysku i odrzucony z pamięci.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-267">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="0ee1a-268">Ważne jest również, aby zrozumieć, że ten limit przydziału ogranicza buforowanie wykonywane przez WCF i nie może chronić użytkownika przed żadnym buforowaniem wykonywanym we własnej implementacji usługi lub klienta.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-268">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="0ee1a-269">Aby uzyskać więcej informacji o dodatkowych kwestiach dotyczących zabezpieczeń, zobacz [zagadnienia dotyczące zabezpieczeń danych](security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="0ee1a-269">For more information about additional security considerations, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0ee1a-270">Decyzja o użyciu buforowanych lub przesyłanych strumieniowo jest lokalną decyzją punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-270">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="0ee1a-271">W przypadku transportów HTTP tryb transferu nie jest propagowany przez połączenie lub serwery proxy i innych pośredników.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-271">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="0ee1a-272">Ustawienie trybu transferu nie jest odzwierciedlone w opisie interfejsu usługi.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-272">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="0ee1a-273">Po wygenerowaniu klienta programu WCF do usługi należy edytować plik konfiguracji usług przeznaczonych do użycia z transferem strumieniowym w celu ustawienia trybu.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-273">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="0ee1a-274">W przypadku transportów TCP i nazwanych potoków tryb transferu jest propagowany jako potwierdzenie zasad.</span><span class="sxs-lookup"><span data-stu-id="0ee1a-274">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0ee1a-275">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="0ee1a-275">See also</span></span>

- [<span data-ttu-id="0ee1a-276">Instrukcje: włączanie przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="0ee1a-276">How to: Enable Streaming</span></span>](how-to-enable-streaming.md)
