---
title: Omówienie architektury transferu danych
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: efb6933ba90975d5ba35deb2bf22af12fc7c2cdc
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/26/2020
ms.locfileid: "96291690"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="19b42-102">Omówienie architektury transferu danych</span><span class="sxs-lookup"><span data-stu-id="19b42-102">Data Transfer Architectural Overview</span></span>

<span data-ttu-id="19b42-103">Windows Communication Foundation (WCF) może być uważana za infrastrukturę obsługi komunikatów.</span><span class="sxs-lookup"><span data-stu-id="19b42-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="19b42-104">Może on odbierać komunikaty, przetwarzać je i wysyłać do kodu użytkownika w celu wykonania dalszych działań lub może tworzyć komunikaty z danych podanymi przez kod użytkownika i dostarczać je do miejsca docelowego.</span><span class="sxs-lookup"><span data-stu-id="19b42-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="19b42-105">W tym temacie, który jest przeznaczony dla zaawansowanych deweloperów, opisano architekturę obsługi komunikatów i zawartych danych.</span><span class="sxs-lookup"><span data-stu-id="19b42-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="19b42-106">Aby uprościć widok zorientowany na zadania, jak wysyłać i odbierać dane, zobacz [określanie transfer danych w umowach dotyczących usług](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="19b42-107">W tym temacie omówiono szczegóły implementacji WCF, które nie są widoczne przez badanie modelu obiektów WCF.</span><span class="sxs-lookup"><span data-stu-id="19b42-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="19b42-108">Dwa słowa przestroga są w porządku w odniesieniu do udokumentowanych szczegółów implementacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="19b42-109">Najpierw opisy są uproszczone; Rzeczywista implementacja może być bardziej złożona ze względu na optymalizacje lub inne powody.</span><span class="sxs-lookup"><span data-stu-id="19b42-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="19b42-110">W drugim przypadku nigdy nie należy polegać na określonych szczegółach implementacji, nawet udokumentowanych, ponieważ mogą one ulec zmianie bez powiadomienia z wersji do wersji, a nawet w wersji z obsługą techniczną.</span><span class="sxs-lookup"><span data-stu-id="19b42-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="19b42-111">Podstawowa architektura</span><span class="sxs-lookup"><span data-stu-id="19b42-111">Basic Architecture</span></span>  

 <span data-ttu-id="19b42-112">Na podstawowym poziomie funkcji obsługi komunikatów WCF jest <xref:System.ServiceModel.Channels.Message> Klasa, która jest opisana szczegółowo w temacie using the [Message Class](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="19b42-113">Składniki środowiska uruchomieniowego WCF można podzielić na dwie główne części: stos kanału i środowisko usługi z <xref:System.ServiceModel.Channels.Message> klasą punktu połączenia.</span><span class="sxs-lookup"><span data-stu-id="19b42-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="19b42-114">Stos kanału jest odpowiedzialny za konwersję między prawidłowym <xref:System.ServiceModel.Channels.Message> wystąpieniem a pewną akcją, która odnosi się do wysyłania lub otrzymywania danych komunikatów.</span><span class="sxs-lookup"><span data-stu-id="19b42-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="19b42-115">Po stronie wysyłającej stos kanału jest prawidłowym <xref:System.ServiceModel.Channels.Message> wystąpieniem, a po pewnym przetwarzaniu wykonuje pewne działania, które logicznie odpowiadają na wysłanie komunikatu.</span><span class="sxs-lookup"><span data-stu-id="19b42-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="19b42-116">Akcja może wysyłać pakiety TCP lub HTTP, kolejkować wiadomość w usłudze kolejkowania komunikatów, zapisywać komunikat do bazy danych, zapisywać ją w udziale plików lub dowolną inną akcję, w zależności od implementacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="19b42-117">Najbardziej typowa akcja wysyła komunikat za pośrednictwem protokołu sieciowego.</span><span class="sxs-lookup"><span data-stu-id="19b42-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="19b42-118">Po stronie odbierającej następuje wykrycie działania (które może być pakietem TCP lub HTTP, który dociera lub jakąkolwiek inną akcją), a po przetworzeniu stos kanału konwertuje tę akcję na prawidłowe <xref:System.ServiceModel.Channels.Message> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="19b42-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="19b42-119">Możesz użyć programu WCF, używając <xref:System.ServiceModel.Channels.Message> klasy i stosu kanału bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="19b42-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="19b42-120">Jednak taka operacja jest trudna i czasochłonna.</span><span class="sxs-lookup"><span data-stu-id="19b42-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="19b42-121">Ponadto obiekt nie <xref:System.ServiceModel.Channels.Message> zapewnia obsługi metadanych, dlatego nie można generować klientów WCF o jednoznacznie określonym typie, jeśli używasz WCF w ten sposób.</span><span class="sxs-lookup"><span data-stu-id="19b42-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="19b42-122">W związku z tym WCF zawiera platformę usługi, która zapewnia łatwy w użyciu model programowania, który służy do konstruowania i odbierania `Message` obiektów.</span><span class="sxs-lookup"><span data-stu-id="19b42-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="19b42-123">Struktura usługi mapuje usługi do .NET Framework typów za pomocą koncepcji kontraktów usługi i wysyła komunikaty do operacji użytkownika, które są po prostu .NET Framework metodami oznaczonymi <xref:System.ServiceModel.OperationContractAttribute> atrybutem (Aby uzyskać więcej informacji, zobacz [Projektowanie kontraktów usług](../designing-service-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="19b42-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="19b42-124">Metody te mogą mieć parametry i wartości zwracane.</span><span class="sxs-lookup"><span data-stu-id="19b42-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="19b42-125">Po stronie usługi, struktura usługi konwertuje <xref:System.ServiceModel.Channels.Message> wystąpienia przychodzące na parametry i konwertuje wartości zwracane na wystąpienia wychodzące <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="19b42-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="19b42-126">Po stronie klienta działa odwrotnie.</span><span class="sxs-lookup"><span data-stu-id="19b42-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="19b42-127">Rozważmy na przykład `FindAirfare` operację poniżej.</span><span class="sxs-lookup"><span data-stu-id="19b42-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="19b42-128">Załóżmy `FindAirfare` , że jest wywoływana na kliencie.</span><span class="sxs-lookup"><span data-stu-id="19b42-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="19b42-129">Struktura usługi na kliencie konwertuje `FromCity` `ToCity` Parametry i na wystąpienie wychodzące <xref:System.ServiceModel.Channels.Message> i przekazuje je do stosu kanału do wysłania.</span><span class="sxs-lookup"><span data-stu-id="19b42-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="19b42-130">Po stronie usługi, gdy <xref:System.ServiceModel.Channels.Message> wystąpienie dociera do stosu kanału, struktura usługi wyodrębni odpowiednie dane z komunikatu w celu wypełnienia `FromCity` parametrów i, `ToCity` a następnie wywołuje metodę po stronie usługi `FindAirfare` .</span><span class="sxs-lookup"><span data-stu-id="19b42-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="19b42-131">Gdy metoda zwraca, platforma usług pobiera zwróconą wartość całkowitą i `IsDirectFlight` parametr wyjściowy oraz tworzy <xref:System.ServiceModel.Channels.Message> wystąpienie obiektu, które zawiera te informacje.</span><span class="sxs-lookup"><span data-stu-id="19b42-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="19b42-132">Następnie przekazuje `Message` wystąpienie do stosu kanału w celu wysłania ich z powrotem do klienta.</span><span class="sxs-lookup"><span data-stu-id="19b42-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="19b42-133">Po stronie klienta <xref:System.ServiceModel.Channels.Message> wystąpienie zawierające komunikat odpowiedzi jest wychodzą ze stosu kanału.</span><span class="sxs-lookup"><span data-stu-id="19b42-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="19b42-134">Struktura usługi wyodrębnia wartość zwracaną oraz `IsDirectFlight` wartość i zwraca je do obiektu wywołującego klienta.</span><span class="sxs-lookup"><span data-stu-id="19b42-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="19b42-135">Message, klasa</span><span class="sxs-lookup"><span data-stu-id="19b42-135">Message Class</span></span>  

 <span data-ttu-id="19b42-136"><xref:System.ServiceModel.Channels.Message>Klasa powinna być abstrakcyjną reprezentacją komunikatu, ale jego konstrukcja jest silnie związana z komunikatem protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="19b42-137">A <xref:System.ServiceModel.Channels.Message> zawiera trzy główne elementy informacji: treść komunikatu, nagłówki komunikatów i właściwości wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="19b42-138">Treść komunikatu</span><span class="sxs-lookup"><span data-stu-id="19b42-138">Message Body</span></span>  

 <span data-ttu-id="19b42-139">Treść komunikatu jest przeznaczona do reprezentowania rzeczywistego ładunku danych wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="19b42-140">Treść wiadomości jest zawsze reprezentowana jako sprawdzonych XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="19b42-141">Nie oznacza to, że wszystkie komunikaty utworzone lub odebrane w usłudze WCF muszą być w formacie XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="19b42-142">Na stosie kanałów można zdecydować, jak interpretować treść wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="19b42-143">Może go emitować jako plik XML, przekonwertować go na inny format lub nawet całkowicie pominąć.</span><span class="sxs-lookup"><span data-stu-id="19b42-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="19b42-144">Oczywiście w przypadku większości powiązań WCF treść komunikatu jest reprezentowana jako zawartość XML w sekcji treść koperty protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="19b42-145">Należy pamiętać, że `Message` Klasa nie musi zawierać buforu z danymi XML reprezentującymi treść.</span><span class="sxs-lookup"><span data-stu-id="19b42-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="19b42-146">Logicznie `Message` zawiera sprawdzonych XML, ale ten sprawdzonych może być dynamicznie skonstruowany i może nigdy nie istnieć fizycznie w pamięci.</span><span class="sxs-lookup"><span data-stu-id="19b42-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="19b42-147">Umieszczanie danych w treści wiadomości</span><span class="sxs-lookup"><span data-stu-id="19b42-147">Putting Data into the Message Body</span></span>  

 <span data-ttu-id="19b42-148">Nie istnieje jednolity mechanizm umieszczania danych w treści wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="19b42-149"><xref:System.ServiceModel.Channels.Message>Klasa ma metodę abstrakcyjną, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> która przyjmuje <xref:System.Xml.XmlDictionaryWriter> .</span><span class="sxs-lookup"><span data-stu-id="19b42-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="19b42-150">Każda podklasa <xref:System.ServiceModel.Channels.Message> klasy jest odpowiedzialna za zastąpienie tej metody i zapisanie jej własnej zawartości.</span><span class="sxs-lookup"><span data-stu-id="19b42-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="19b42-151">Treść komunikatu logicznie zawiera sprawdzonych XML, który `OnWriteBodyContent` tworzy.</span><span class="sxs-lookup"><span data-stu-id="19b42-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="19b42-152">Rozważmy na przykład następującą `Message` podklasę.</span><span class="sxs-lookup"><span data-stu-id="19b42-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="19b42-153">Fizycznie `AirfareRequestMessage` wystąpienie zawiera tylko dwa ciągi ("FromCity" i "ToCity").</span><span class="sxs-lookup"><span data-stu-id="19b42-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="19b42-154">Jednak logicznie komunikat zawiera następujący sprawdzonych XML:</span><span class="sxs-lookup"><span data-stu-id="19b42-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="19b42-155">Oczywiście zazwyczaj nie można tworzyć komunikatów w ten sposób, ponieważ można użyć struktury usługi do utworzenia komunikatu tak jak powyżej, z parametrów kontraktu operacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="19b42-156">Ponadto <xref:System.ServiceModel.Channels.Message> Klasa ma `CreateMessage` metody statyczne, których można użyć do tworzenia komunikatów o wspólnych typach zawartości: pusty komunikat, komunikat zawierający obiekt Zserializowany do XML z <xref:System.Runtime.Serialization.DataContractSerializer> , komunikat zawierający błąd protokołu SOAP, komunikat zawierający kod XML reprezentowany przez itd <xref:System.Xml.XmlReader> .</span><span class="sxs-lookup"><span data-stu-id="19b42-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="19b42-157">Pobieranie danych z treści wiadomości</span><span class="sxs-lookup"><span data-stu-id="19b42-157">Getting Data from a Message Body</span></span>  

 <span data-ttu-id="19b42-158">Dane przechowywane w treści wiadomości można wyodrębnić na dwa sposoby:</span><span class="sxs-lookup"><span data-stu-id="19b42-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="19b42-159">Całą treść komunikatu można pobrać jednocześnie przez wywołanie <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> metody i przekazanie do składnika zapisywania XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="19b42-160">Pełna treść komunikatu jest zapisywana dla tego składnika zapisywania.</span><span class="sxs-lookup"><span data-stu-id="19b42-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="19b42-161">Jednoczesne pobranie całej treści wiadomości jest również nazywane *pisaniem wiadomości*.</span><span class="sxs-lookup"><span data-stu-id="19b42-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="19b42-162">Pisanie odbywa się przede wszystkim przez stos kanałów podczas wysyłania komunikatów — część stosu kanału zwykle uzyskuje dostęp do całej treści wiadomości, koduje ją i wysyła.</span><span class="sxs-lookup"><span data-stu-id="19b42-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="19b42-163">Innym sposobem uzyskania informacji z treści wiadomości jest wywołanie <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> i uzyskanie czytnika XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="19b42-164">Treść komunikatu może następnie być dostępna sekwencyjnie, w razie konieczności, wywołując metody z czytnika.</span><span class="sxs-lookup"><span data-stu-id="19b42-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="19b42-165">Pobieranie treści komunikatu przez element jest również nazywane *odczytywaniem wiadomości*.</span><span class="sxs-lookup"><span data-stu-id="19b42-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="19b42-166">Odczytywanie wiadomości jest przede wszystkim używany przez strukturę usługi podczas otrzymywania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="19b42-167">Na przykład gdy <xref:System.Runtime.Serialization.DataContractSerializer> jest używany, środowisko usługi pobierze czytnik XML nad treścią i przekaże go do aparatu deserializacji, który następnie rozpocznie odczytywanie komunikatu po elemencie i konstruowanie odpowiedniego grafu obiektów.</span><span class="sxs-lookup"><span data-stu-id="19b42-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="19b42-168">Treść komunikatu można pobrać tylko raz.</span><span class="sxs-lookup"><span data-stu-id="19b42-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="19b42-169">Dzięki temu można korzystać z strumieni tylko do przesyłania dalej.</span><span class="sxs-lookup"><span data-stu-id="19b42-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="19b42-170">Na przykład można napisać <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> przesłonięcie, które odczytuje z <xref:System.IO.FileStream> i zwraca wyniki jako sprawdzonych XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="19b42-171">Na początku pliku nigdy nie będzie konieczne przewinięcie do tyłu.</span><span class="sxs-lookup"><span data-stu-id="19b42-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="19b42-172">`WriteBodyContents`Metody i `GetReaderAtBodyContents` po prostu sprawdzają, czy treść wiadomości nigdy nie została wcześniej pobrana, a następnie Wywołaj `OnWriteBodyContents` lub `OnGetReaderAtBodyContents` .</span><span class="sxs-lookup"><span data-stu-id="19b42-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="19b42-173">Użycie komunikatów w programie WCF</span><span class="sxs-lookup"><span data-stu-id="19b42-173">Message Usage in WCF</span></span>  

 <span data-ttu-id="19b42-174">Większość komunikatów może być sklasyfikowanych jako *wychodzące* (te, które są tworzone przez strukturę usługi do wysłania przez stos kanałów) lub *przychodzące* (te, które docierają do stosu kanału i są interpretowane przez strukturę usługi).</span><span class="sxs-lookup"><span data-stu-id="19b42-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="19b42-175">Ponadto stos kanału może działać w trybie buforowanym lub przesyłania strumieniowego.</span><span class="sxs-lookup"><span data-stu-id="19b42-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="19b42-176">Platforma usług może również uwidaczniać strumieniowy lub niestrumieniowy model programowania.</span><span class="sxs-lookup"><span data-stu-id="19b42-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="19b42-177">Prowadzi to do przypadków wymienionych w poniższej tabeli wraz z uproszczonymi szczegółami ich implementacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="19b42-178">Typ wiadomości</span><span class="sxs-lookup"><span data-stu-id="19b42-178">Message type</span></span>|<span data-ttu-id="19b42-179">Dane treści w wiadomości</span><span class="sxs-lookup"><span data-stu-id="19b42-179">Body data in message</span></span>|<span data-ttu-id="19b42-180">Implementacja zapisu (OnWriteBodyContents)</span><span class="sxs-lookup"><span data-stu-id="19b42-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="19b42-181">Odczytaj (OnGetReaderAtBodyContents) implementację</span><span class="sxs-lookup"><span data-stu-id="19b42-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="19b42-182">Wychodzące, utworzone na podstawie nieprzesyłanego modelu programowania</span><span class="sxs-lookup"><span data-stu-id="19b42-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="19b42-183">Dane niezbędne do zapisania wiadomości (na przykład obiektu i <xref:System.Runtime.Serialization.DataContractSerializer> wystąpienia niezbędnego do serializacji) \*</span><span class="sxs-lookup"><span data-stu-id="19b42-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="19b42-184">Logika niestandardowa umożliwiająca zapisanie wiadomości na podstawie przechowywanych danych (na przykład wywołania `WriteObject` w `DataContractSerializer` przypadku użycia serializatora) \*</span><span class="sxs-lookup"><span data-stu-id="19b42-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="19b42-185">Wywołaj `OnWriteBodyContents` , przebuforuj wyniki, zwróć czytnik XML na bufor</span><span class="sxs-lookup"><span data-stu-id="19b42-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="19b42-186">Wychodzące, utworzone na podstawie przesyłanego modelu programowania</span><span class="sxs-lookup"><span data-stu-id="19b42-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="19b42-187">`Stream`Z danymi, które mają być zapisywane \*</span><span class="sxs-lookup"><span data-stu-id="19b42-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="19b42-188">Zapisuj dane z zapisanego strumienia przy użyciu <xref:System.Xml.IStreamProvider> mechanizmu \*</span><span class="sxs-lookup"><span data-stu-id="19b42-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="19b42-189">Wywołaj `OnWriteBodyContents` , przebuforuj wyniki, zwróć czytnik XML na bufor</span><span class="sxs-lookup"><span data-stu-id="19b42-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="19b42-190">Przychodzące ze stosu kanału przesyłania strumieniowego</span><span class="sxs-lookup"><span data-stu-id="19b42-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="19b42-191">`Stream`Obiekt, który reprezentuje dane przychodzące za pośrednictwem sieci z <xref:System.Xml.XmlReader></span><span class="sxs-lookup"><span data-stu-id="19b42-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="19b42-192">Zapisz zawartość z przechowywanych `XmlReader` przy użyciu `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="19b42-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="19b42-193">Zwraca przechowywane `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="19b42-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="19b42-194">Przychodzące z niestrumieniowego stosu kanału</span><span class="sxs-lookup"><span data-stu-id="19b42-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="19b42-195">Bufor zawierający dane treści z `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="19b42-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="19b42-196">Zapisuje zawartość z przechowywanych `XmlReader` przy użyciu `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="19b42-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="19b42-197">Zwraca przechowywany plik lang</span><span class="sxs-lookup"><span data-stu-id="19b42-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="19b42-198">\* Te elementy nie są implementowane bezpośrednio w `Message` podklasach, ale w podklasach <xref:System.ServiceModel.Channels.BodyWriter> klasy.</span><span class="sxs-lookup"><span data-stu-id="19b42-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="19b42-199">Aby uzyskać więcej informacji na temat <xref:System.ServiceModel.Channels.BodyWriter> , zobacz [Korzystanie z klasy Message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="19b42-200">Nagłówki komunikatów</span><span class="sxs-lookup"><span data-stu-id="19b42-200">Message Headers</span></span>  

 <span data-ttu-id="19b42-201">Komunikat może zawierać nagłówki.</span><span class="sxs-lookup"><span data-stu-id="19b42-201">A message may contain headers.</span></span> <span data-ttu-id="19b42-202">Nagłówek logicznie składa się z sprawdzonych XML, który jest skojarzony z nazwą, przestrzenią nazw i kilkoma innymi właściwościami.</span><span class="sxs-lookup"><span data-stu-id="19b42-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="19b42-203">Do nagłówków wiadomości uzyskuje się dostęp przy użyciu `Headers` właściwości w <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="19b42-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="19b42-204">Każdy nagłówek jest reprezentowany przez <xref:System.ServiceModel.Channels.MessageHeader> klasę.</span><span class="sxs-lookup"><span data-stu-id="19b42-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="19b42-205">Zwykle nagłówki wiadomości są mapowane na nagłówki wiadomości protokołu SOAP, gdy używany jest stos kanału skonfigurowany do pracy z komunikatami protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="19b42-206">Umieszczenie informacji w nagłówku wiadomości i wyodrębnienie informacji jest podobne do użycia treści komunikatu.</span><span class="sxs-lookup"><span data-stu-id="19b42-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="19b42-207">Proces jest nieco uproszczony, ponieważ przesyłanie strumieniowe nie jest obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="19b42-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="19b42-208">Możliwe jest uzyskanie dostępu do zawartości tego samego nagłówka więcej niż raz, a nagłówki mogą być dostępne w dowolnej kolejności, co wymusza, aby nagłówki były zawsze buforowane.</span><span class="sxs-lookup"><span data-stu-id="19b42-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="19b42-209">Nie istnieje mechanizm ogólnego przeznaczenia, który umożliwia uzyskanie czytnika XML nad nagłówkiem, ale istnieje `MessageHeader` podklasa wewnętrzna dla WCF, która reprezentuje nagłówek z możliwością odczytu.</span><span class="sxs-lookup"><span data-stu-id="19b42-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="19b42-210">Ten typ `MessageHeader` jest tworzony przez stos kanału po pojawieniu się komunikatu z nagłówkami aplikacji niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="19b42-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="19b42-211">Dzięki temu platforma usług może używać aparatu deserializacji, takiego jak <xref:System.Runtime.Serialization.DataContractSerializer> , do interpretacji tych nagłówków.</span><span class="sxs-lookup"><span data-stu-id="19b42-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="19b42-212">Aby uzyskać więcej informacji, zobacz [Korzystanie z klasy Message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-212">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="19b42-213">Właściwości komunikatu</span><span class="sxs-lookup"><span data-stu-id="19b42-213">Message Properties</span></span>  

 <span data-ttu-id="19b42-214">Komunikat może zawierać właściwości.</span><span class="sxs-lookup"><span data-stu-id="19b42-214">A message may contain properties.</span></span> <span data-ttu-id="19b42-215">*Właściwość* jest dowolnym obiektem .NET Framework, który jest skojarzony z nazwą ciągu.</span><span class="sxs-lookup"><span data-stu-id="19b42-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="19b42-216">Właściwości są dostępne za pomocą `Properties` właściwości w `Message` .</span><span class="sxs-lookup"><span data-stu-id="19b42-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="19b42-217">W przeciwieństwie do treści wiadomości i nagłówków wiadomości (które zwykle mapują odpowiednio do treści protokołu SOAP i nagłówków protokołu SOAP), właściwości wiadomości nie są zwykle wysyłane ani odbierane wraz z komunikatami.</span><span class="sxs-lookup"><span data-stu-id="19b42-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="19b42-218">Właściwości wiadomości istnieją głównie jako mechanizm komunikacji do przekazywania danych o wiadomości między różnymi kanałami w stosie kanału oraz między stosem kanału i modelem usługi.</span><span class="sxs-lookup"><span data-stu-id="19b42-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="19b42-219">Na przykład kanał transportu HTTP dołączony jako część WCF ma możliwość tworzenia różnych kodów stanu HTTP, takich jak "404 (nie znaleziono)" i "500 (wewnętrzny błąd serwera)," podczas wysyłania odpowiedzi do klientów.</span><span class="sxs-lookup"><span data-stu-id="19b42-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="19b42-220">Przed wysłaniem komunikatu odpowiedzi sprawdza, czy element `Properties` `Message` zawiera właściwość o nazwie "HttpResponse", która zawiera obiekt typu <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> .</span><span class="sxs-lookup"><span data-stu-id="19b42-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="19b42-221">Jeśli taka właściwość zostanie znaleziona, zobaczy <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> Właściwość i użyje tego kodu stanu.</span><span class="sxs-lookup"><span data-stu-id="19b42-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="19b42-222">Jeśli nie zostanie znaleziona, zostanie użyty domyślny kod "200 (OK)".</span><span class="sxs-lookup"><span data-stu-id="19b42-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="19b42-223">Aby uzyskać więcej informacji, zobacz [Korzystanie z klasy Message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-223">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="19b42-224">Wiadomość jako całość</span><span class="sxs-lookup"><span data-stu-id="19b42-224">The Message as a Whole</span></span>  

 <span data-ttu-id="19b42-225">Do tej pory omawiamy metody uzyskiwania dostępu do różnych części komunikatu w izolacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="19b42-226">Jednak <xref:System.ServiceModel.Channels.Message> Klasa zawiera również metody do pracy z całą wiadomością jako całość.</span><span class="sxs-lookup"><span data-stu-id="19b42-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="19b42-227">Na przykład `WriteMessage` Metoda zapisuje cały komunikat do składnika zapisywania XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="19b42-228">Aby to było możliwe, należy zdefiniować mapowanie między całym `Message` wystąpieniem a sprawdzonych XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="19b42-229">Takie mapowanie, w rzeczywistości, istnieje: WCF używa standardu SOAP do definiowania tego mapowania.</span><span class="sxs-lookup"><span data-stu-id="19b42-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="19b42-230">Gdy `Message` wystąpienie jest zapisywane jako sprawdzonych XML, wynikiem sprawdzonych jest prawidłowa Koperta protokołu SOAP, która zawiera komunikat.</span><span class="sxs-lookup"><span data-stu-id="19b42-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="19b42-231">W ten sposób `WriteMessage` zwykle wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="19b42-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="19b42-232">Napisz tag otwierającego elementu koperty protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="19b42-233">Napisz tag otwierający element nagłówka SOAP, Wypisz wszystkie nagłówki i Zamknij element header.</span><span class="sxs-lookup"><span data-stu-id="19b42-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="19b42-234">Napisz tag otwierającego elementu treści protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="19b42-235">Wywołaj `WriteBodyContents` lub równoważną metodę zapisywania treści.</span><span class="sxs-lookup"><span data-stu-id="19b42-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="19b42-236">Zamknij elementy treści i formy.</span><span class="sxs-lookup"><span data-stu-id="19b42-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="19b42-237">Powyższe kroki są ściśle powiązane ze standardem protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="19b42-238">Jest to skomplikowane przez fakt, że istnieje wiele wersji protokołu SOAP, na przykład nie można zapisać elementu koperty protokołu SOAP prawidłowo, bez znajomości używanej wersji protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="19b42-239">Ponadto w niektórych przypadkach może być pożądane, aby całkowicie wyłączyć złożone mapowanie specyficzne dla protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="19b42-240">W tym celu `Version` Właściwość jest dostępna w `Message` .</span><span class="sxs-lookup"><span data-stu-id="19b42-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="19b42-241">Można ją ustawić na wersję protokołu SOAP, która ma być używana podczas zapisywania wiadomości lub można ją ustawić, aby `None` zapobiec jakimkolwiek mapowaniem specyficznym dla protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="19b42-242">Jeśli `Version` Właściwość jest ustawiona na `None` , metody, które współdziałają z całym komunikatem, działają tak jak wtedy, gdy komunikat składa się tylko z jego treści, na przykład `WriteMessage` po prostu wywołuje `WriteBodyContents` zamiast wykonywania wielu kroków wymienionych powyżej.</span><span class="sxs-lookup"><span data-stu-id="19b42-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="19b42-243">Oczekuje się, że w przypadku wiadomości przychodzących `Version` zostanie on wykryty i poprawnie ustawiony.</span><span class="sxs-lookup"><span data-stu-id="19b42-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="19b42-244">Stos kanału</span><span class="sxs-lookup"><span data-stu-id="19b42-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="19b42-245">Kanały</span><span class="sxs-lookup"><span data-stu-id="19b42-245">Channels</span></span>  

 <span data-ttu-id="19b42-246">Jak wspomniano wcześniej, stos kanału jest odpowiedzialny za konwertowanie <xref:System.ServiceModel.Channels.Message> wystąpień wychodzących na niektóre akcje (takie jak wysyłanie pakietów przez sieć) lub konwertowanie niektórych akcji (takich jak otrzymywanie pakietów sieciowych) na wystąpienia przychodzące `Message` .</span><span class="sxs-lookup"><span data-stu-id="19b42-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="19b42-247">Stos kanału składa się z co najmniej jednego kanału uporządkowanego w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="19b42-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="19b42-248">Wystąpienie wychodzące `Message` jest przekazywane do pierwszego kanału w stosie (nazywanego również *kanałem najwyższego* poziomu), który przekazuje go do następnego kanału w dół w stosie i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="19b42-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="19b42-249">Komunikat kończy się w ostatnim kanale, który jest nazywany *kanałem transportu*.</span><span class="sxs-lookup"><span data-stu-id="19b42-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="19b42-250">Komunikaty przychodzące pochodzą z kanału transportowego i są przesyłane z kanału w celu uzyskania kanału w górę stosu.</span><span class="sxs-lookup"><span data-stu-id="19b42-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="19b42-251">W kanale najwyższego poziomu komunikat jest zwykle przesyłany do struktury usługi.</span><span class="sxs-lookup"><span data-stu-id="19b42-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="19b42-252">Chociaż jest to typowy wzorzec komunikatów aplikacji, niektóre kanały mogą się nieco różnić, na przykład mogą wysyłać własne komunikaty infrastruktury bez przekazywania komunikatu z kanału powyżej.</span><span class="sxs-lookup"><span data-stu-id="19b42-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="19b42-253">Kanały mogą działać na wiadomości na różne sposoby, gdy przechodzi przez stos.</span><span class="sxs-lookup"><span data-stu-id="19b42-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="19b42-254">Najbardziej typową operacją jest dodawanie nagłówka do wiadomości wychodzącej i odczytywanie nagłówków w komunikacie przychodzącym.</span><span class="sxs-lookup"><span data-stu-id="19b42-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="19b42-255">Na przykład kanał może obliczyć podpis cyfrowy wiadomości i dodać go jako nagłówek.</span><span class="sxs-lookup"><span data-stu-id="19b42-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="19b42-256">Kanał może również sprawdzać ten nagłówek podpisu cyfrowego w komunikatach przychodzących i blokować komunikaty, które nie mają prawidłowego podpisu w celu realizacji stosu kanału.</span><span class="sxs-lookup"><span data-stu-id="19b42-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="19b42-257">Kanały często ustawiają lub sprawdzają właściwości komunikatów.</span><span class="sxs-lookup"><span data-stu-id="19b42-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="19b42-258">Treść komunikatu zwykle nie jest modyfikowana, chociaż jest to dozwolone, na przykład kanał zabezpieczeń WCF może zaszyfrować treść wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="19b42-259">Kodery przesyłania kanałów i komunikatów</span><span class="sxs-lookup"><span data-stu-id="19b42-259">Transport Channels and Message Encoders</span></span>  

 <span data-ttu-id="19b42-260">Kanał znajdujący się niżej w stosie jest odpowiedzialny za faktyczne transformacje wychodzące <xref:System.ServiceModel.Channels.Message> , jak zmodyfikowano przez inne kanały, do pewnej akcji.</span><span class="sxs-lookup"><span data-stu-id="19b42-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="19b42-261">Na stronie odbierającej jest to kanał, który konwertuje niektóre akcje na `Message` proces innych kanałów.</span><span class="sxs-lookup"><span data-stu-id="19b42-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="19b42-262">Jak wspomniano wcześniej, działania mogą być różne: wysyłanie lub otrzymywanie pakietów sieciowych przez różne protokoły, odczytywanie lub zapisywanie wiadomości w bazie danych lub kolejkowanie lub dekolejkowanie komunikatu w kolejce usługi kolejkowania komunikatów, aby podać, ale kilka przykładów.</span><span class="sxs-lookup"><span data-stu-id="19b42-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="19b42-263">Wszystkie te akcje są wspólne: wymagają przekształcenia między `Message` wystąpieniem programu WCF i rzeczywistą grupą bajtów, które mogą być wysyłane, odbierane, odczytywane, zapisywane, umieszczane w kolejce lub z kolejki.</span><span class="sxs-lookup"><span data-stu-id="19b42-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="19b42-264">Proces konwersji a `Message` na grupę bajtów nazywa się *kodowaniem*, a proces odwrotny tworzenia z `Message` grupy bajtów nazywa się *dekodowaniem*.</span><span class="sxs-lookup"><span data-stu-id="19b42-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="19b42-265">Większość kanałów transportowych wykorzystuje składniki zwane *koderami komunikatów* w celu wykonania kodowania i dekodowania.</span><span class="sxs-lookup"><span data-stu-id="19b42-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="19b42-266">Koder komunikatów jest podklasą <xref:System.ServiceModel.Channels.MessageEncoder> klasy.</span><span class="sxs-lookup"><span data-stu-id="19b42-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="19b42-267">`MessageEncoder` obejmuje różne `ReadMessage` i `WriteMessage` przeciążenia metod do przekonwertowania między `Message` i grupą bajtów.</span><span class="sxs-lookup"><span data-stu-id="19b42-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="19b42-268">Po stronie wysyłającej kanał transportu buforowania przekazuje `Message` obiekt otrzymany z kanału nad nim `WriteMessage` .</span><span class="sxs-lookup"><span data-stu-id="19b42-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="19b42-269">Pobiera on tablicę bajtów, która następnie używa do wykonywania akcji (takich jak pakowanie tych bajtów jako prawidłowych pakietów TCP i wysyłanie ich do poprawnego miejsca docelowego).</span><span class="sxs-lookup"><span data-stu-id="19b42-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="19b42-270">Kanał transportowy przesyłania strumieniowego najpierw tworzy `Stream` (na przykład za pośrednictwem wychodzącego połączenia TCP), a następnie przekazuje zarówno `Stream` i `Message` musi przesłać do odpowiedniego `WriteMessage` przeciążenia, które zapisuje komunikat.</span><span class="sxs-lookup"><span data-stu-id="19b42-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="19b42-271">Po stronie odbierania bufory przesyłania strumieniowego są wyodrębniane z przychodzących bajtów (na przykład z przychodzących pakietów TCP) do tablicy i wywołań `ReadMessage` w celu uzyskania `Message` obiektu, który może przekazywać więcej informacji stosu kanału.</span><span class="sxs-lookup"><span data-stu-id="19b42-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="19b42-272">Kanał transportu przesyłania strumieniowego tworzy `Stream` obiekt (na przykład strumień sieciowy przez przychodzące połączenie TCP) i przekazuje go do programu `ReadMessage` w celu uzyskania kopii zapasowej `Message` obiektu.</span><span class="sxs-lookup"><span data-stu-id="19b42-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="19b42-273">Separacja kanałów transportowych i kodera komunikatów nie jest obowiązkowa; Istnieje możliwość napisania kanału transportowego, który nie używa kodera komunikatów.</span><span class="sxs-lookup"><span data-stu-id="19b42-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="19b42-274">Zaletą tego rozbarwień jest jednak łatwość tworzenia kompozycji.</span><span class="sxs-lookup"><span data-stu-id="19b42-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="19b42-275">Tak długo, jak kanał transportowy używa tylko podstawy <xref:System.ServiceModel.Channels.MessageEncoder> , może współdziałać z dowolnym koderem usługi WCF lub innej firmy.</span><span class="sxs-lookup"><span data-stu-id="19b42-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="19b42-276">Podobnie ten sam koder może być używany w każdym kanale transportu.</span><span class="sxs-lookup"><span data-stu-id="19b42-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="19b42-277">Operacja kodera komunikatu</span><span class="sxs-lookup"><span data-stu-id="19b42-277">Message Encoder Operation</span></span>  

 <span data-ttu-id="19b42-278">Aby opisać Typowe operacje kodera, warto rozważyć następujące cztery przypadki.</span><span class="sxs-lookup"><span data-stu-id="19b42-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="19b42-279">Operacja</span><span class="sxs-lookup"><span data-stu-id="19b42-279">Operation</span></span>|<span data-ttu-id="19b42-280">Komentarz</span><span class="sxs-lookup"><span data-stu-id="19b42-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="19b42-281">Kodowanie, buforowane</span><span class="sxs-lookup"><span data-stu-id="19b42-281">Encoding, Buffered</span></span>|<span data-ttu-id="19b42-282">W trybie buforowanym koder zazwyczaj tworzy bufor o zmiennym rozmiarze, a następnie tworzy na nim składnik zapisywania XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="19b42-283">Następnie wywołuje on <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> zakodowany komunikat, który zapisuje nagłówki, a następnie treść przy użyciu <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> , jak wyjaśniono w poprzedniej sekcji dotyczącej `Message` tego tematu.</span><span class="sxs-lookup"><span data-stu-id="19b42-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="19b42-284">Zawartość bufora (reprezentowana jako tablica bajtów) jest następnie zwracana do użycia przez kanał transportu.</span><span class="sxs-lookup"><span data-stu-id="19b42-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="19b42-285">Kodowanie, przesyłane strumieniowo</span><span class="sxs-lookup"><span data-stu-id="19b42-285">Encoding, Streamed</span></span>|<span data-ttu-id="19b42-286">W trybie przesyłania strumieniowego operacja jest podobna do powyższego, ale prostsze.</span><span class="sxs-lookup"><span data-stu-id="19b42-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="19b42-287">Bufor nie jest potrzebny.</span><span class="sxs-lookup"><span data-stu-id="19b42-287">There is no need for a buffer.</span></span> <span data-ttu-id="19b42-288">Składnik zapisywania XML jest zwykle tworzony przez strumień i <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> jest wywoływany w `Message` celu zapisania go w ramach tego składnika zapisywania.</span><span class="sxs-lookup"><span data-stu-id="19b42-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="19b42-289">Dekodowanie, buforowane</span><span class="sxs-lookup"><span data-stu-id="19b42-289">Decoding, Buffered</span></span>|<span data-ttu-id="19b42-290">Podczas dekodowania w trybie buforowanym `Message` zwykle tworzona jest specjalna podklasa, która zawiera dane buforowane.</span><span class="sxs-lookup"><span data-stu-id="19b42-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="19b42-291">Nagłówki wiadomości są odczytywane i tworzony jest czytnik XML umieszczony w treści komunikatu.</span><span class="sxs-lookup"><span data-stu-id="19b42-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="19b42-292">To jest czytnik, który zostanie zwrócony z <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> .</span><span class="sxs-lookup"><span data-stu-id="19b42-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="19b42-293">Dekodowanie, przesyłane strumieniowo</span><span class="sxs-lookup"><span data-stu-id="19b42-293">Decoding, Streamed</span></span>|<span data-ttu-id="19b42-294">Podczas dekodowania w trybie przesyłania strumieniowego zwykle tworzona jest specjalna podklasa wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="19b42-295">Strumień jest wystarczająco zaawansowany, aby można było odczytać wszystkie nagłówki i umieścić je w treści wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="19b42-296">Obiekt odczytujący XML jest następnie tworzony w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="19b42-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="19b42-297">To jest czytnik, który zostanie zwrócony z <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> .</span><span class="sxs-lookup"><span data-stu-id="19b42-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="19b42-298">Kodery mogą również wykonywać inne funkcje.</span><span class="sxs-lookup"><span data-stu-id="19b42-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="19b42-299">Na przykład kodery mogą mieć pulę czytelników i autorów XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="19b42-300">Tworzenie nowego czytnika lub składnika zapisywania XML jest droższe, gdy jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="19b42-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="19b42-301">W związku z tym kodery zwykle utrzymują pulę czytników i pulę modułów zapisujących konfigurowalny rozmiar.</span><span class="sxs-lookup"><span data-stu-id="19b42-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="19b42-302">W opisach operacji kodera opisanej wcześniej, za każdym razem, gdy zostanie użyta fraza "Tworzenie czytnika XML/składnik zapisywania", zazwyczaj oznacza to, że jest to jedno z puli lub utwórz je, jeśli nie jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="19b42-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="19b42-303">Koder (i `Message` podklasy tworzone podczas dekodowania) zawierają logikę zwracającą czytelników i autorów do pul, gdy nie są już potrzebne (na przykład gdy `Message` jest zamknięty).</span><span class="sxs-lookup"><span data-stu-id="19b42-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="19b42-304">Funkcja WCF oferuje trzy kodery komunikatów, chociaż istnieje możliwość utworzenia dodatkowych typów niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="19b42-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="19b42-305">Dostarczone typy to mechanizm optymalizacji tekstu, binarny i przesyłania komunikatów (MTOM).</span><span class="sxs-lookup"><span data-stu-id="19b42-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="19b42-306">Są one szczegółowo opisane w temacie [Wybieranie kodera komunikatów](choosing-a-message-encoder.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-306">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="19b42-307">Interfejs element IStreamProvider</span><span class="sxs-lookup"><span data-stu-id="19b42-307">The IStreamProvider Interface</span></span>  

 <span data-ttu-id="19b42-308">Podczas pisania wiadomości wychodzącej zawierającej przesłaną strumieniowo do składnika zapisywania XML, program <xref:System.ServiceModel.Channels.Message> używa sekwencji wywołań podobnej do następującej w jej <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementacji:</span><span class="sxs-lookup"><span data-stu-id="19b42-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="19b42-309">Zapisz wszelkie niezbędne informacje przed strumieniem (na przykład otwierającym tagiem XML).</span><span class="sxs-lookup"><span data-stu-id="19b42-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="19b42-310">Zapisz strumień.</span><span class="sxs-lookup"><span data-stu-id="19b42-310">Write the stream.</span></span>  
  
- <span data-ttu-id="19b42-311">Napisz wszystkie informacje następujące po strumieniu (na przykład zamykając tag XML).</span><span class="sxs-lookup"><span data-stu-id="19b42-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="19b42-312">Dobrze sprawdza się w przypadku kodowań, które są podobne do tekstu kodowania XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="19b42-313">Jednak niektóre kodowania nie umieszczają informacji sprawdzonych XML (na przykład Tagi dla początkowych i końcowych elementów XML) wraz z danymi zawartymi w elementach.</span><span class="sxs-lookup"><span data-stu-id="19b42-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="19b42-314">Na przykład w kodowaniu MTOM komunikat jest podzielony na wiele części.</span><span class="sxs-lookup"><span data-stu-id="19b42-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="19b42-315">Jedna część zawiera sprawdzonych XML, który może zawierać odwołania do innych części dla rzeczywistej zawartości elementu.</span><span class="sxs-lookup"><span data-stu-id="19b42-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="19b42-316">Sprawdzonych XML jest zwykle mały w porównaniu do zawartości przesyłanej strumieniowo, dlatego warto buforować sprawdzonych, zapisywać go, a następnie zapisywać zawartość w sposób przesyłany strumieniowo.</span><span class="sxs-lookup"><span data-stu-id="19b42-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="19b42-317">Oznacza to, że przez czas zapisywania znacznika elementu zamykającego nie należy jeszcze zapisywać strumienia.</span><span class="sxs-lookup"><span data-stu-id="19b42-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="19b42-318">W tym celu <xref:System.Xml.IStreamProvider> używany jest interfejs.</span><span class="sxs-lookup"><span data-stu-id="19b42-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="19b42-319">Interfejs ma <xref:System.Xml.IStreamProvider.GetStream> metodę, która zwraca strumień, który ma zostać zapisany.</span><span class="sxs-lookup"><span data-stu-id="19b42-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="19b42-320">Prawidłowy sposób zapisania przesyłanej strumieniowo treści wiadomości w programie <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> jest następujący:</span><span class="sxs-lookup"><span data-stu-id="19b42-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="19b42-321">Zapisz wszelkie niezbędne informacje przed strumieniem (na przykład otwierającym tagiem XML).</span><span class="sxs-lookup"><span data-stu-id="19b42-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="19b42-322">Wywołaj `WriteValue` Przeciążenie, <xref:System.Xml.XmlDictionaryWriter> które przyjmuje obiekt <xref:System.Xml.IStreamProvider> , z `IStreamProvider` implementacją zwracającą strumień, który ma zostać zapisany.</span><span class="sxs-lookup"><span data-stu-id="19b42-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="19b42-323">Napisz wszystkie informacje następujące po strumieniu (na przykład zamykając tag XML).</span><span class="sxs-lookup"><span data-stu-id="19b42-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="19b42-324">W tym podejściu składnik zapisywania XML ma możliwość wyboru, kiedy należy wywołać <xref:System.Xml.IStreamProvider.GetStream> i napisać dane przesyłane strumieniowo.</span><span class="sxs-lookup"><span data-stu-id="19b42-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="19b42-325">Na przykład tekst i binarne moduły zapisujące XML będą natychmiast je wywoływać i zapisywać przesyłane strumieniowo zawartość między tagami początkowymi i końcowymi.</span><span class="sxs-lookup"><span data-stu-id="19b42-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="19b42-326">Składnik zapisywania MTOM może zdecydować się na <xref:System.Xml.IStreamProvider.GetStream> późniejsze wywołanie, gdy jest gotowy do zapisania odpowiedniej części wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="19b42-327">Reprezentuje dane w środowisku usługi</span><span class="sxs-lookup"><span data-stu-id="19b42-327">Representing Data in the Service Framework</span></span>  

 <span data-ttu-id="19b42-328">Jak określono w sekcji "podstawowa architektura" w tym temacie, struktura usługi jest częścią programu WCF, która między innymi jest odpowiedzialna za konwersję między modelem programowania przyjaznym dla użytkownika a rzeczywistymi `Message` wystąpieniami.</span><span class="sxs-lookup"><span data-stu-id="19b42-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="19b42-329">Zwykle wymiana komunikatów jest reprezentowana w środowisku usługi jako metoda .NET Framework oznaczona <xref:System.ServiceModel.OperationContractAttribute> atrybutem.</span><span class="sxs-lookup"><span data-stu-id="19b42-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="19b42-330">Metoda może przyjmować pewne parametry i może zwracać wartość zwracaną lub parametry out (lub oba).</span><span class="sxs-lookup"><span data-stu-id="19b42-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="19b42-331">Po stronie usługi parametry wejściowe reprezentują komunikat przychodzący, a wartość zwracana i parametry out reprezentują komunikat wychodzący.</span><span class="sxs-lookup"><span data-stu-id="19b42-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="19b42-332">Po stronie klienta odwrotna wartość jest równa true.</span><span class="sxs-lookup"><span data-stu-id="19b42-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="19b42-333">Model programowania służący do opisywania komunikatów przy użyciu parametrów i wartości zwracanej opisano szczegółowo w temacie [określanie transfer danych w kontraktach usług](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="19b42-334">Jednak ta sekcja zawiera krótkie omówienie.</span><span class="sxs-lookup"><span data-stu-id="19b42-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="19b42-335">Modele programowania</span><span class="sxs-lookup"><span data-stu-id="19b42-335">Programming Models</span></span>  

 <span data-ttu-id="19b42-336">Struktura usługi WCF obsługuje pięć różnych modeli programowania do opisywania komunikatów:</span><span class="sxs-lookup"><span data-stu-id="19b42-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="19b42-337">1. pusty komunikat</span><span class="sxs-lookup"><span data-stu-id="19b42-337">1. The Empty Message</span></span>  

 <span data-ttu-id="19b42-338">Jest to najprostszy przypadek.</span><span class="sxs-lookup"><span data-stu-id="19b42-338">This is the simplest case.</span></span> <span data-ttu-id="19b42-339">Aby opisać pusty komunikat przychodzący, nie należy używać żadnych parametrów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="19b42-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="19b42-340">Aby opisać pustą wiadomość wychodzącą, należy użyć wartości zwracanej void i nie używać żadnych parametrów out:</span><span class="sxs-lookup"><span data-stu-id="19b42-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="19b42-341">Należy zauważyć, że różni się to od kontraktu jednokierunkowej operacji:</span><span class="sxs-lookup"><span data-stu-id="19b42-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="19b42-342">W `SetDesiredTemperature` przykładzie opisany jest wzorzec wymiany komunikatów dwukierunkowych.</span><span class="sxs-lookup"><span data-stu-id="19b42-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="19b42-343">Komunikat jest zwracany z operacji, ale jest pusty.</span><span class="sxs-lookup"><span data-stu-id="19b42-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="19b42-344">Możliwe jest zwrócenie błędu z operacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="19b42-345">W przykładzie "Set żarówki" wzorzec wymiany komunikatów jest jednokierunkowy, dlatego nie istnieje komunikat wychodzący do opisania.</span><span class="sxs-lookup"><span data-stu-id="19b42-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="19b42-346">Usługa nie może skomunikować się z klientem w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="19b42-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="19b42-347">2. bezpośrednie Używanie klasy Message</span><span class="sxs-lookup"><span data-stu-id="19b42-347">2. Using the Message Class Directly</span></span>  

 <span data-ttu-id="19b42-348">Można użyć <xref:System.ServiceModel.Channels.Message> klasy (lub jednej z jej podklas) bezpośrednio w kontrakcie operacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="19b42-349">W takim przypadku struktura usługi po prostu przekazuje ją `Message` od operacji do stosu kanału i na odwrót, bez dalszej obróbki.</span><span class="sxs-lookup"><span data-stu-id="19b42-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="19b42-350">Istnieją dwa główne przypadki użycia do bezpośredniego użycia `Message` .</span><span class="sxs-lookup"><span data-stu-id="19b42-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="19b42-351">Można jej użyć w zaawansowanych scenariuszach, gdy żaden z innych modeli programowania nie zapewnia wystarczającej elastyczności opisywania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="19b42-352">Na przykład możesz chcieć użyć plików na dysku do opisania wiadomości, przy czym właściwości pliku stają się nagłówkami wiadomości, a zawartość pliku staje się treścią wiadomości.</span><span class="sxs-lookup"><span data-stu-id="19b42-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="19b42-353">Następnie można utworzyć coś podobnego do poniższego.</span><span class="sxs-lookup"><span data-stu-id="19b42-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="19b42-354">Drugim typowym zastosowaniem `Message` w ramach kontraktu operacji jest to, że usługa nie zajmuje się informacjami o określonej zawartości wiadomości i działa na wiadomości jako czarne pole.</span><span class="sxs-lookup"><span data-stu-id="19b42-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="19b42-355">Na przykład może istnieć usługa, która przesyła dalej komunikaty do wielu innych adresatów.</span><span class="sxs-lookup"><span data-stu-id="19b42-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="19b42-356">Umowę można napisać w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="19b42-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="19b42-357">Linia Action = "\*" skutecznie wyłącza wysyłanie komunikatów i gwarantuje, że wszystkie komunikaty wysyłane do kontraktu przypracują `IForwardingService` do tej `ForwardMessage` operacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="19b42-358">(Zwykle Dyspozytor przeanalizuje nagłówek "Action" komunikatu, aby określić, która operacja jest przeznaczona dla.</span><span class="sxs-lookup"><span data-stu-id="19b42-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="19b42-359">Action = " \* " oznacza "wszystkie możliwe wartości nagłówka akcji".) Kombinacja akcji = " \* " i używania komunikatu jako parametru jest znana jako "Umowa uniwersalna", ponieważ może odbierać wszystkie możliwe komunikaty.</span><span class="sxs-lookup"><span data-stu-id="19b42-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="19b42-360">Aby można było wysyłać wszystkie możliwe komunikaty, należy użyć komunikatu jako wartości zwracanej i ustawić `ReplyAction` na " \* ".</span><span class="sxs-lookup"><span data-stu-id="19b42-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="19b42-361">Uniemożliwi to platformie usługi dodanie własnego nagłówka akcji, co umożliwia kontrolowanie tego nagłówka przy użyciu `Message` zwracanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="19b42-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="19b42-362">3. kontrakty komunikatów</span><span class="sxs-lookup"><span data-stu-id="19b42-362">3. Message Contracts</span></span>  

 <span data-ttu-id="19b42-363">Funkcja WCF oferuje deklaratywny model programowania do opisywania komunikatów, nazywanych *kontraktami komunikatów*.</span><span class="sxs-lookup"><span data-stu-id="19b42-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="19b42-364">Ten model został szczegółowo opisany w artykule [Używanie kontraktów komunikatów](using-message-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-364">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="19b42-365">Zasadniczo cały komunikat jest reprezentowany przez pojedynczy typ .NET Framework, który używa atrybutów, takich jak <xref:System.ServiceModel.MessageBodyMemberAttribute> i, <xref:System.ServiceModel.MessageHeaderAttribute> do opisywania, które części klasy kontraktu wiadomości powinny mapować, która część komunikatu.</span><span class="sxs-lookup"><span data-stu-id="19b42-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="19b42-366">Umowy dotyczące komunikatów zapewniają dużą kontrolę nad wystąpieniami wynikającymi `Message` (choć nie jest to bardzo dużo formantu jako `Message` bezpośredniego użycia klasy).</span><span class="sxs-lookup"><span data-stu-id="19b42-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="19b42-367">Na przykład treści komunikatów często składają się z wielu informacji, z których każdy reprezentuje własny element XML.</span><span class="sxs-lookup"><span data-stu-id="19b42-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="19b42-368">Te elementy mogą wystąpić bezpośrednio w treści (w trybie "*bCzy* ") lub mogą być *opakowane* w element XML obejmujący.</span><span class="sxs-lookup"><span data-stu-id="19b42-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="19b42-369">Korzystając z modelu programowania kontraktu komunikatów, można podejmować decyzje dotyczące zawiniętej i kontrolowania nazwy otoki i przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="19b42-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="19b42-370">W poniższym przykładzie kodu kontraktu komunikatu przedstawiono te funkcje.</span><span class="sxs-lookup"><span data-stu-id="19b42-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="19b42-371">Elementy oznaczone jako serializowane (z <xref:System.ServiceModel.MessageBodyMemberAttribute> , <xref:System.ServiceModel.MessageHeaderAttribute> lub innymi atrybutami powiązanymi) muszą być możliwe do serializacji, aby uczestniczyć w kontrakcie komunikatu.</span><span class="sxs-lookup"><span data-stu-id="19b42-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="19b42-372">Aby uzyskać więcej informacji, zobacz sekcję "serializacji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="19b42-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="19b42-373">4. parametry</span><span class="sxs-lookup"><span data-stu-id="19b42-373">4. Parameters</span></span>  

 <span data-ttu-id="19b42-374">Często deweloperzy, którzy chcą opisać operację, która działa na wielu fragmentach danych, nie potrzebują kontroli nad tym, że umowy o wiadomości zapewniają.</span><span class="sxs-lookup"><span data-stu-id="19b42-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="19b42-375">Na przykład podczas tworzenia nowych usług jeden z nich nie ma zazwyczaj podejmowania decyzji bez systemu operacyjnego i decyduje o nazwie elementu otoki.</span><span class="sxs-lookup"><span data-stu-id="19b42-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="19b42-376">Podejmowanie tych decyzji często wymaga głębokiej znajomości usług sieci Web i protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="19b42-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="19b42-377">Struktura usługi WCF może automatycznie wybierać najlepszą i najbardziej międzyplatformową reprezentację protokołu SOAP do wysyłania lub otrzymywania wielu powiązanych informacji, bez wymuszania tych opcji na użytkowniku.</span><span class="sxs-lookup"><span data-stu-id="19b42-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="19b42-378">Jest to realizowane przez proste opisywanie tych informacji jako parametry lub zwracane wartości kontraktu operacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="19b42-379">Rozważmy na przykład następujący kontrakt operacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="19b42-380">Struktura usługi automatycznie decyduje się umieścić wszystkie trzy informacje ( `customerID` , `item` , i `quantity` ) w treści wiadomości i otoczyć je w elemencie otoki o nazwie `SubmitOrderRequest` .</span><span class="sxs-lookup"><span data-stu-id="19b42-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="19b42-381">Zalecanym podejściem jest opisywanie informacji, które mają być wysyłane lub odbierane jako prosta lista parametrów kontraktu operacji, chyba że istnieją specjalne powody, aby przejść do bardziej złożonej umowy dotyczącej komunikatów lub `Message` modeli programowania opartych na programie.</span><span class="sxs-lookup"><span data-stu-id="19b42-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="19b42-382">5. Stream</span><span class="sxs-lookup"><span data-stu-id="19b42-382">5. Stream</span></span>  

 <span data-ttu-id="19b42-383">Użycie `Stream` lub jedna z jej podklas w kontrakcie operacji lub jako jedyna treść wiadomości w umowie może być traktowana jako oddzielny model programowania od tych opisanych powyżej.</span><span class="sxs-lookup"><span data-stu-id="19b42-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="19b42-384">Użycie `Stream` w ten sposób jest jedynym sposobem na zagwarantowanie, że kontrakt będzie użyteczny w sposób przesyłany strumieniowo, a w sposób krótszy od pisania własnej podklasy zgodnej z przesyłaniem strumieniowym `Message` .</span><span class="sxs-lookup"><span data-stu-id="19b42-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="19b42-385">Aby uzyskać więcej informacji, zobacz [dane dotyczące dużych ilości danych i przesyłania strumieniowego](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-385">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="19b42-386">Kiedy `Stream` lub jedna z jej podklas jest używana w ten sposób, serializator nie jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="19b42-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="19b42-387">W przypadku wiadomości wychodzących tworzona jest specjalna podklasa przesyłania strumieniowego, `Message` a strumień zostaje zapisany zgodnie z opisem w sekcji w <xref:System.Xml.IStreamProvider> interfejsie.</span><span class="sxs-lookup"><span data-stu-id="19b42-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="19b42-388">W przypadku wiadomości przychodzących Usługa Service Framework tworzy `Stream` podklasę przez komunikat przychodzący i udostępnia ją do operacji.</span><span class="sxs-lookup"><span data-stu-id="19b42-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="19b42-389">Ograniczenia modelu programowania</span><span class="sxs-lookup"><span data-stu-id="19b42-389">Programming Model Restrictions</span></span>  

 <span data-ttu-id="19b42-390">Opisane powyżej modele programowania nie mogą być w sposób arbitralny połączone.</span><span class="sxs-lookup"><span data-stu-id="19b42-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="19b42-391">Na przykład jeśli operacja akceptuje typ kontraktu komunikatu, kontrakt wiadomości musi być jedynym parametrem wejściowym.</span><span class="sxs-lookup"><span data-stu-id="19b42-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="19b42-392">Ponadto operacja musi zwrócić pusty komunikat (zwracany typ void) lub inny kontrakt komunikatu.</span><span class="sxs-lookup"><span data-stu-id="19b42-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="19b42-393">Te ograniczenia dotyczące modelu programowania są opisane w tematach dotyczących poszczególnych modeli programowania: [przy użyciu kontraktów komunikatów](using-message-contracts.md), [używania klasy komunikatów](using-the-message-class.md)oraz [dużych ilości danych i przesyłania strumieniowego](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="19b42-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="19b42-394">Elementy formatujące komunikaty</span><span class="sxs-lookup"><span data-stu-id="19b42-394">Message Formatters</span></span>  

 <span data-ttu-id="19b42-395">Opisane powyżej modele programowania są obsługiwane przez Podłączanie w składnikach programu o nazwie programy *formatujące komunikaty* do struktury usługi.</span><span class="sxs-lookup"><span data-stu-id="19b42-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="19b42-396">Elementy formatujące komunikatów to typy implementujące <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interfejs lub (lub) do użycia w klientach i klientach usług WCF odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="19b42-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="19b42-397">Elementy formatujące komunikatów są zwykle połączone przez zachowania.</span><span class="sxs-lookup"><span data-stu-id="19b42-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="19b42-398">Na przykład <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> wtyczki w programie formatującego komunikatów kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="19b42-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="19b42-399">Jest to wykonywane po stronie usługi przez ustawienie <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> do poprawnego programu formatującego w <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> metodzie lub po stronie klienta przez ustawienie <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> do poprawnego formatu programu formatującego w <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> metodzie.</span><span class="sxs-lookup"><span data-stu-id="19b42-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="19b42-400">Poniższa tabela zawiera listę metod, które może zaimplementować program formatujący komunikatów.</span><span class="sxs-lookup"><span data-stu-id="19b42-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="19b42-401">Interfejs</span><span class="sxs-lookup"><span data-stu-id="19b42-401">Interface</span></span>|<span data-ttu-id="19b42-402">Metoda</span><span class="sxs-lookup"><span data-stu-id="19b42-402">Method</span></span>|<span data-ttu-id="19b42-403">Akcja</span><span class="sxs-lookup"><span data-stu-id="19b42-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="19b42-404">Konwertuje przychodzące `Message` Parametry operacji</span><span class="sxs-lookup"><span data-stu-id="19b42-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="19b42-405">Tworzy `Message` Parametry wartości/out zwracanego elementu wychodzącego z operacji</span><span class="sxs-lookup"><span data-stu-id="19b42-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="19b42-406">Tworzy parametry wychodzące `Message` z operacji</span><span class="sxs-lookup"><span data-stu-id="19b42-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="19b42-407">Konwertuje przychodzące `Message` do parametrów wartości zwracanej/out</span><span class="sxs-lookup"><span data-stu-id="19b42-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="19b42-408">Serializacja</span><span class="sxs-lookup"><span data-stu-id="19b42-408">Serialization</span></span>  

 <span data-ttu-id="19b42-409">Za każdym razem, gdy korzystasz z kontraktów lub parametrów komunikatów do opisywania zawartości komunikatu, musisz użyć serializacji do konwersji między typami .NET Framework i reprezentacją XML sprawdzonych.</span><span class="sxs-lookup"><span data-stu-id="19b42-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="19b42-410">Serializacja jest używana w innych miejscach na platformie WCF, na przykład, <xref:System.ServiceModel.Channels.Message> ma metodę rodzajową, <xref:System.ServiceModel.Channels.Message.GetBody%2A> której można użyć do odczytania całej treści komunikatu deserializowanego do obiektu.</span><span class="sxs-lookup"><span data-stu-id="19b42-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="19b42-411">Usługa WCF obsługuje dwie technologie serializacji "poza Box" do serializacji i deserializacji parametrów i części komunikatów: <xref:System.Runtime.Serialization.DataContractSerializer> i `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="19b42-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="19b42-412">Dodatkowo można napisać Serializatory niestandardowe.</span><span class="sxs-lookup"><span data-stu-id="19b42-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="19b42-413">Jednak inne części WCF (takie jak Metoda generyczna `GetBody` lub Serializacja błędów SOAP) mogą być ograniczone do korzystania tylko z <xref:System.Runtime.Serialization.XmlObjectSerializer> podklas ( <xref:System.Runtime.Serialization.DataContractSerializer> i <xref:System.Runtime.Serialization.NetDataContractSerializer> , ale nie do <xref:System.Xml.Serialization.XmlSerializer> ) lub nawet być zakodowane w celu użycia tylko <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="19b42-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="19b42-414">`XmlSerializer`Jest to aparat serializacji używany w usługach sieci Web ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="19b42-414">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="19b42-415">`DataContractSerializer`To nowy aparat serializacji, który rozumie nowy model programowania kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="19b42-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="19b42-416">`DataContractSerializer` jest to wybór domyślny, a wybór użycia `XmlSerializer` może być wykonywany dla każdej operacji przy użyciu <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="19b42-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="19b42-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> i <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> są zachowaniami operacji odpowiedzialnymi za Podłączanie w programie formatującego komunikatów `DataContractSerializer` odpowiednio dla i `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="19b42-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="19b42-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior>Zachowanie może faktycznie działać z dowolnym serializatorem, który pochodzi z <xref:System.Runtime.Serialization.XmlObjectSerializer> , łącznie z <xref:System.Runtime.Serialization.NetDataContractSerializer> (opisany szczegółowo w temacie using Stand-Alone Serialization).</span><span class="sxs-lookup"><span data-stu-id="19b42-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="19b42-419">Zachowanie wywołuje jedną z `CreateSerializer` przeciążeń metody wirtualnej w celu uzyskania serializatora.</span><span class="sxs-lookup"><span data-stu-id="19b42-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="19b42-420">Aby podłączyć inny Serializator, Utwórz nową <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> podklasę i Zastąp oba `CreateSerializer` przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="19b42-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="19b42-421">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="19b42-421">See also</span></span>

- [<span data-ttu-id="19b42-422">Określanie transferu danych w kontraktach usług</span><span class="sxs-lookup"><span data-stu-id="19b42-422">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
